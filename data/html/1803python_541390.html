 <h2> Title: Extracting extension from filename in Python </h2> <h4> Alex, question_id: 541390 </h4>Score: 1803, Tags: {python,filenames,file-extension} <br><p>Is there a function to extract the extension from a filename?</p>
------------------------------------------------------------------ <br><h3> wookie, Id: 25454134, Score: -4: </h3><pre><code>name_only=file_name[:filename.index(".")
</code></pre>

<p>That will give you the file name up to the first ".", which would be the most common.</p>
<h4> ya_dimon, Comment 54839628 Score: 1: </h4>first, he needs not the name, but extension. Second, even if he would need name, it would be wrong by files like: <code>file.name.ext</code><br><h4> Umar Dastgir, Comment 99334974 Score: 0: </h4>As mentioned by @ya_dimon, this wont work for files names with dots. Plus, he needs the extension!<br>------------------------------------------------------------------ <br><h3> nosklo, Id: 541394, Score: 2593: </h3><p>Use <a href="https://docs.python.org/3/library/os.path.html#os.path.splitext" rel="noreferrer"><code>os.path.splitext</code></a>:</p>
<pre><code>&gt;&gt;&gt; import os
&gt;&gt;&gt; filename, file_extension = os.path.splitext('/path/to/somefile.ext')
&gt;&gt;&gt; filename
'/path/to/somefile'
&gt;&gt;&gt; file_extension
'.ext'
</code></pre>
<p>Unlike most manual string-splitting attempts, <code>os.path.splitext</code> will correctly treat <code>/a/b.c/d</code> as having no extension instead of having extension <code>.c/d</code>, and it will treat <code>.bashrc</code> as having no extension instead of having extension <code>.bashrc</code>:</p>
<pre><code>&gt;&gt;&gt; os.path.splitext('/a/b.c/d')
('/a/b.c/d', '')
&gt;&gt;&gt; os.path.splitext('.bashrc')
('.bashrc', '')
</code></pre>
<h4> ArtOfWarfare, Comment 44066968 Score: 239: </h4>The standard Python function naming convention is really annoying - almost every time I re-look this up, I mistake it as being <code>splittext</code>. If they would just do anything to signify the break between parts of this name, it&#39;d be much easier to recognize that it&#39;s <code>splitExt</code> or <code>split_ext</code>. Surely I can&#39;t be the only person who has made this mistake?<br><h4> nosklo, Comment 31872900 Score: 88: </h4>@klingt.net Well, in that case, <code>.asd</code> is really the extension!! If you think about it, <code>foo.tar.gz</code> is a <b>gzip-compressed file</b> (<code>.gz</code>) which happens to be a <b>tar file</b> (<code>.tar</code>). But it is a <b>gzip file</b> in first place. I wouldn&#39;t expect it to return the dual extension at all.<br><h4> Jiaaro, Comment 9049522 Score: 23: </h4>the use of <code>basename</code> is a little confusing here since <code>os.path.basename(&quot;&#47;path&#47;to&#47;somefile.ext&quot;)</code> would return <code>&quot;somefile.ext&quot;</code><br><h4> Sebastian Mach, Comment 27188208 Score: 22: </h4>wouldn&#39;t <code>endswith()</code> not be more portable and pythonic?<br><h4> klingt.net, Comment 31592436 Score: 9: </h4>You can&#39;t rely on that if you have files with &quot;double extensions&quot;, like <code>.mp3.asd</code> for example, because it will return you only the &quot;last&quot; extension!<br><h4> Jonathan H, Comment 85476048 Score: 2: </h4>@ArtOfWarfare Given the small size of the <code>os.path</code> submodule, you could conceivably remap the names manually in your own module saved on your Python path. E.g. <code>myospath.py</code> containing things like <code>splitExt = os.path.splitext</code>.<br><h4> Antony Hatchkins, Comment 20814610 Score: 2: </h4>see also ideas below concerning <code>lower()</code> and double extensions<br><h4> nosklo, Comment 98731937 Score: 1: </h4>@FranciscoMariaCalisto I&#39;m not sure what you mean. There is already one example of a file without extension in the answer, the  <code>&#47;a&#47;b.c&#47;d</code> file. If by &quot;opposite&quot; of splitting you mean joining the filename with an extension, that can be done by normal concatenation: <code>filename + file_extension</code><br><h4> Jan, Comment 72219336 Score: 1: </h4>a tuple is returned and if you want to get the extension use: <code>file_extension=os.path.splitext(&#39;&#47;path&#47;to&#47;somefile.ext&#39;)[1]</code> or if you want the filename use: <code>filename=os.path.splitext(&#39;&#47;path&#47;to&#47;somefile.ext&#39;)[0]</code><br><h4> Chris, Comment 108757150 Score: 1: </h4>If you just need the extension, without the <code>.</code> prefixed, use <code>os.path.splitext(&#39;filename.ext&#39;)[1][1:]</code>. Obvious but just a reminder for those of us who like to code mainly using [ctrl]+C/V.<br><h4> Francisco Maria Calisto, Comment 98731347 Score: 0: </h4>Despite not answering to the OP, it would be a great improvement if you also provide the opposite solution. Or a link for it. When I am saying the opposite, I am referring to now the filename with no extension.<br>------------------------------------------------------------------ <br><h3> jeromej, Id: 35188296, Score: 659: </h3><p><em>New in version 3.4.</em></p>
<pre><code>import pathlib

print(pathlib.Path('yourPath.example').suffix) # '.example'
print(pathlib.Path(&quot;hello/foo.bar.tar.gz&quot;).suffixes) # ['.bar', '.tar', '.gz']
print(pathlib.Path('/foo/bar.txt').stem) # 'bar'
</code></pre>
<p>I'm surprised no one has mentioned <a href="https://docs.python.org/3/library/pathlib.html" rel="noreferrer"><code>pathlib</code></a> yet, <code>pathlib</code> IS awesome!</p>
<h4> teichert, Comment 77944815 Score: 32: </h4>example for getting .tar.gz: <code>&#39;&#39;.join(pathlib.Path(&#39;somedir&#47;file.tar.gz&#39;).suffixes)</code><br><h4> jeromej, Comment 108473067 Score: 3: </h4>@user3780389 Wouldn&#39;t a &quot;foo.bar.tar.gz&quot; still be a valid &quot;.tar.gz&quot;? If so your snippet should be using <code>.suffixes[-2:]</code> to ensure only getting .tar.gz at most.<br><h4> user118967, Comment 102185856 Score: 0: </h4>Great answer. I found this tutorial more useful than the documentation: <a href="http://zetcode.com/python/pathlib/" rel="nofollow noreferrer">zetcode.com/python/pathlib</a><br><h4> eadmaster, Comment 115879442 Score: 0: </h4>there are still cases when this does not work as expected like <code>&quot;filename with.a dot inside.tar&quot;</code>. This is the solution i am using currently: <code>&quot;&quot;.join([s for s in pathlib.Path(&#39;somedir&#47;file.tar.gz&#39;).suffixes if not &quot; &quot; in s])</code><br><h4> soheshdoshi, Comment 136019955 Score: 0: </h4>this one should be acceptable answer<br>------------------------------------------------------------------ <br><h3> Brian Neal, Id: 541408, Score: 491: </h3><pre><code>import os.path
extension = os.path.splitext(filename)[1]
</code></pre>
<h4> Brian Neal, Comment 8662012 Score: 1: </h4>@kiswa - I suppose you could do it that way. I&#39;ve seen more code using <code>import os.path</code> though.<br><h4> Ivan Virabyan, Comment 11588848 Score: 1: </h4>but what&#39;s the point of importing <code>os.path</code> if we could just <code>import os</code>?<br><h4> dennmat, Comment 10167611 Score: 80: </h4>it depends really, if you use <code>from os import path</code> then the name <code>path</code> is taken up in your local scope, also others looking at the code may not immediately know that path is the path from the os module. Where as if you use <code>import os.path</code> it keeps it within the <code>os</code> namespace and wherever you make the call people know it&#39;s <code>path()</code> from the <code>os</code> module immediately.<br><h4> Tim Gilbert, Comment 39431078 Score: 29: </h4>I know it&#39;s not semantically any different, but I personally find the construction <code>_, extension = os.path.splitext(filename)</code> to be much nicer-looking.<br><h4> kiswa, Comment 8655020 Score: 26: </h4>Out of curiosity, why <code>import os.path</code> instead of <code>from os import path</code>?<br><h4> gerardw, Comment 84791418 Score: 3: </h4>If you want the extension as part of a more complex expression the [1] may be more useful:   <code>if check_for_gzip and os.path.splitext(filename)[1] == &#39;.gz&#39;:</code><br><h4> ArtOfWarfare, Comment 59571940 Score: 1: </h4>@TimGilbert Hmm... same exact number of characters, but I feel <code>_, </code> is less heavy/distracting than <code>[1]</code>, and maybe even a bit clearer. I ran both through <code>timeit</code>... your form takes between 2.02 usec and 2.04 usec on my computer, while the form in this answer takes between 2.04 usec and 2.06 usec. So performance is infinitesimally improved at best, or the exact same at worse. I can&#39;t come up with any reason to not use your form.<br><h4> Brian Neal, Comment 11626214 Score: 1: </h4>@IvanVirabyan See this question: <a href="http://stackoverflow.com/questions/2724348/should-i-use-import-os-path-or-import-os" title="should i use import os path or import os">stackoverflow.com/questions/2724348/&hellip;</a><br><h4> SurpriseDog, Comment 118511435 Score: 0: </h4>@kiswa The docs literally say to just import os: <code>help(os.path) -&gt;  &quot;Instead of importing this module directly, import os and refer to this module as os.path.&quot;</code><br><h4> Raleigh L., Comment 128481613 Score: 0: </h4>Make sure to append <code>[1:]</code> to the result, to remove the leading dot since that&#39;s not part of the extension: <a href="https://en.wikipedia.org/wiki/Filename_extension" rel="nofollow noreferrer">en.wikipedia.org/wiki/Filename_extension</a><br>------------------------------------------------------------------ <br><h3> wonzbak, Id: 7202805, Score: 143: </h3><pre><code>import os.path
extension = os.path.splitext(filename)[1][1:]
</code></pre>

<p>To get only the text of the extension, without the dot.</p>
<h4> user202729, Comment 115385814 Score: 2: </h4>This will return empty for both file names end with <code>.</code> and file names without an extension.<br>------------------------------------------------------------------ <br><h3> Murat &#199;orlu, Id: 10078116, Score: 112: </h3><p>For simple use cases one option may be splitting from dot:</p>

<pre><code>&gt;&gt;&gt; filename = "example.jpeg"
&gt;&gt;&gt; filename.split(".")[-1]
'jpeg'
</code></pre>

<p>No error when file doesn't have an extension:</p>

<pre><code>&gt;&gt;&gt; "filename".split(".")[-1]
'filename'
</code></pre>

<p>But you must be careful:</p>

<pre><code>&gt;&gt;&gt; "png".split(".")[-1]
'png'    # But file doesn't have an extension
</code></pre>

<p>Also will not work with hidden files in Unix systems:</p>

<pre><code>&gt;&gt;&gt; ".bashrc".split(".")[-1]
'bashrc'    # But this is not an extension
</code></pre>

<p>For general use, prefer <a href="https://docs.python.org/3/library/os.path.html#os.path.splitext" rel="noreferrer"><code>os.path.splitext</code></a></p>
<h4> Murat &#199;orlu, Comment 13665234 Score: 22: </h4>Not actually. Extension of a file named &quot;x.tar.gz&quot; is &quot;gz&quot; not &quot;tar.gz&quot;. os.path.splitext gives &quot;.os&quot; as extension too.<br><h4> Murat &#199;orlu, Comment 26941642 Score: 11: </h4>[-1] to get last item of items that splitted by dot. Example: <code>&quot;my.file.name.js&quot;.split(&#39;.&#39;) =&gt; [&#39;my&#39;,&#39;file&#39;,&#39;name&#39;,&#39;js]</code><br><h4> Kirill, Comment 13656231 Score: 5: </h4>This would get upset if you&#39;re uploading x.tar.gz<br><h4> Murat &#199;orlu, Comment 78788427 Score: 2: </h4>@BenjaminR ah ok, you are making an optimisation about result list. <code>[&#39;file&#39;, &#39;tar&#39;, &#39;gz&#39;]</code> with <code>&#39;file.tar.gz&#39;.split(&#39;.&#39;)</code> <b>vs</b> <code>[&#39;file.tar&#39;, &#39;gz&#39;]</code> with <code>&#39;file.tar.gz&#39;.rsplit(&#39;.&#39;, 1)</code>. yeah, could be.<br><h4> user765443, Comment 26937332 Score: 2: </h4>can we use [1] rather than [-1]. I could not understand [-1] with split<br><h4> Seaux, Comment 110281026 Score: 1: </h4>@Murat&#199;orlu The extension of <code>README</code> is <code>&quot;&quot;</code> because it has no extension. Whereas with this solution the extension of <code>README</code> would be <code>README</code> -- which is wrong. That does appear already stated in the answer though -- I just wanted to also point out the condition with directories.<br><h4> Benjamin R, Comment 78701487 Score: 0: </h4>@Murat&#199;orlu <code>rsplit[1]</code> is the better approach for this. I agree with you, though, the LAST extension represents the current wrapper or encoding of the file. <code>myfile.tar.gz</code> is a gzipped file <i>before</i> it is a tar.<br><h4> Benjamin R, Comment 78703776 Score: 0: </h4>@Murat&#199;orlu Whoops: <code>rsplit(&#39;.&#39;, 1)</code> is what I meant! Then you check if the length of the list being returned is &gt; 1 or not as a test.<br><h4> Murat &#199;orlu, Comment 78716110 Score: 0: </h4>@BenjaminR I couldn&#39;t get the motivation behind using <code>rsplit</code> instead of <code>split</code> for this case. <code>rsplit(&#39;.&#39;, 1)</code> also returns an array. So again you&#39;ll need to get last item of that array to get extension only, right? Also you can check the length of the array that <code>split</code> produce to test it has an extension or not.<br><h4> Benjamin R, Comment 78784149 Score: 0: </h4>@Murat&#199;orlu The return value from <code>rsplit</code> in this case is more reflective of what your intent is. You only care about what&#39;s split on the last period, not any other periods. Why have a list (it&#39;s not an array fyi) with bits you don&#39;t care about? You only care about what&#39;s before and after that last period.<br><h4> Seaux, Comment 110243761 Score: 0: </h4>just a heads up, this method fails if you have any directories in here that have <code>.</code> in them along with an extensionless file (which both are common in a *nix env) <code>&quot;&#47;home&#47;example&#47;.config&#47;README&quot;.split(&quot;.&quot;)[-1] == &quot;.config&#47;README&quot;</code><br><h4> Murat &#199;orlu, Comment 110277401 Score: 0: </h4>@Seaux Good point but question is about &quot;extracting extension from filename&quot;. What is the extension of README? So, if there is no extension, yes, this method will not work. To avoid the situation about directory names, a solution can be first find the &quot;filename&quot; from full path.<br><h4> Himanshu, Comment 22831031 Score: 0: </h4>This works when you are processing files for platforms other than the one you run.<br>------------------------------------------------------------------ <br><h3> blented, Id: 14066130, Score: 42: </h3><p>worth adding a lower in there so you don't find yourself wondering why the JPG's aren't showing up in your list.</p>

<pre><code>os.path.splitext(filename)[1][1:].strip().lower()
</code></pre>
<h4> Flimm, Comment 134268590 Score: 0: </h4>The <code>strip()</code> will break in rare edge-cases where the filename extension includes whitespace.<br><h4> Flimm, Comment 134268596 Score: 0: </h4>Some filesystems are case-sensitive (like the ones on Linux), and even NTFS is case-sensitive, although Windows tries to treat it in a case-insensitive manner. Be careful with case.<br>------------------------------------------------------------------ <br><h3> yamex5, Id: 7719562, Score: 22: </h3><p>Any of the solutions above work, but on linux I have found that there is a newline at the end of the extension string which will prevent matches from succeeding. Add the <code>strip()</code> method to the end. For example:  </p>

<pre><code>import os.path
extension = os.path.splitext(filename)[1][1:].strip() 
</code></pre>
<h4> Samuel Harmer, Comment 9396720 Score: 1: </h4>To aid my understanding, please could you explain what additional behaviour the second index/slice guards against? (i.e. the <code>[1:]</code> in <code>.splittext(filename)[1][1:]</code>) - thank you in advance<br><h4> Samuel Harmer, Comment 9396839 Score: 1: </h4>Figured it out for myself: <code>splittext()</code> (unlike if you split a string using &#39;.&#39;) includes the &#39;.&#39; character in the extension.  The additional <code>[1:]</code> gets rid of it.<br><h4> Flimm, Comment 134268585 Score: 0: </h4>This will break if the file extension contains whitespace. That&#39;s a rare case, I know, but it&#39;s still an edge-case that should be considered.<br>------------------------------------------------------------------ <br><h3> XavierCLL, Id: 14698139, Score: 22: </h3><p>With splitext there are problems with files with double extension (e.g. <code>file.tar.gz</code>, <code>file.tar.bz2</code>, etc..)</p>

<pre><code>&gt;&gt;&gt; fileName, fileExtension = os.path.splitext('/path/to/somefile.tar.gz')
&gt;&gt;&gt; fileExtension 
'.gz'
</code></pre>

<p>but should be: <code>.tar.gz</code></p>

<p>The possible solutions are <a href="https://stackoverflow.com/questions/6525334/getting-file-extension-using-pattern-matching-in-python">here</a></p>
<h4> Nuno Aniceto, Comment 40653477 Score: 2: </h4>This is why we have the extension &#39;tgz&#39; which means: tar+gzip ! :D<br><h4> maazza, Comment 24676594 Score: 1: </h4>do it twice to get the 2 extensions ?<br><h4> FlipMcF, Comment 24736520 Score: 1: </h4>@maazza yep.  <code>gunzip somefile.tar.gz</code>  what&#39;s the output filename?<br><h4> FlipMcF, Comment 41437253 Score: 1: </h4>@peterhil I don&#39;t think you want your python script to be aware of the application used to create the filename.  It&#39;s a bit out of scope of the question.  Don&#39;t pick on the example, &#39;filename.csv.gz&#39; is also quite valid.<br><h4> peterhil, Comment 41321357 Score: 0: </h4>@FlipMcF The filename should obviously be <code>somefile.tar</code>. For <code>tar -xzvf somefile.tar.gz</code> the filename should be <code>somefile</code>.<br>------------------------------------------------------------------ <br><h3> r3t40, Id: 51802997, Score: 22: </h3><p>You can find some great stuff in pathlib module (available in python 3.x).</p>

<pre><code>import pathlib
x = pathlib.PurePosixPath("C:\\Path\\To\\File\\myfile.txt").suffix
print(x)

# Output 
'.txt'
</code></pre>
<h4> Lior Elbaz, Comment 117585082 Score: 1: </h4>Using PosixPath for a windows path is wrong.<br>------------------------------------------------------------------ <br><h3> Alex, Id: 51810062, Score: 19: </h3><p>Just <code>join</code> all <code>pathlib suffixes</code>.</p>

<pre><code>&gt;&gt;&gt; x = 'file/path/archive.tar.gz'
&gt;&gt;&gt; y = 'file/path/text.txt'
&gt;&gt;&gt; ''.join(pathlib.Path(x).suffixes)
'.tar.gz'
&gt;&gt;&gt; ''.join(pathlib.Path(y).suffixes)
'.txt'
</code></pre>
------------------------------------------------------------------ <br><h3> weiyixie, Id: 42477550, Score: 17: </h3><p>Although it is an old topic, but i wonder why there is none mentioning a very simple api of python called rpartition in this case:</p>

<p>to get extension of a given file absolute path, you can simply type:</p>

<pre><code>filepath.rpartition('.')[-1]
</code></pre>

<p>example:</p>

<pre><code>path = '/home/jersey/remote/data/test.csv'
print path.rpartition('.')[-1]
</code></pre>

<p>will give you:  'csv'</p>
<h4> Nickolay, Comment 88105425 Score: 2: </h4>For those not familiar with the API, <a href="https://docs.python.org/3/library/stdtypes.html#str.rpartition" rel="nofollow noreferrer">rpartition</a> returns a tuple: <code>(&quot;string before the right-most occurrence of the separator&quot;, &quot;the separator itself&quot;, &quot;the rest of the string&quot;)</code>. If there&#39;s no separator found, the returned tuple will be: <code>(&quot;&quot;, &quot;&quot;, &quot;the original string&quot;)</code>.<br>------------------------------------------------------------------ <br><h3> PascalVKooten, Id: 34376810, Score: 12: </h3><p>Surprised this wasn't mentioned yet:</p>

<pre><code>import os
fn = '/some/path/a.tar.gz'

basename = os.path.basename(fn)  # os independent
Out[] a.tar.gz

base = basename.split('.')[0]
Out[] a

ext = '.'.join(basename.split('.')[1:])   # &lt;-- main part

# if you want a leading '.', and if no result `None`:
ext = '.' + ext if ext else None
Out[] .tar.gz
</code></pre>

<p>Benefits:</p>

<ul>
<li>Works as expected for anything I can think of</li>
<li>No modules</li>
<li>No regex</li>
<li>Cross-platform</li>
<li>Easily extendible (e.g. no leading dots for extension, only last part of extension)</li>
</ul>

<p>As function:</p>

<pre><code>def get_extension(filename):
    basename = os.path.basename(filename)  # os independent
    ext = '.'.join(basename.split('.')[1:])
    return '.' + ext if ext else None
</code></pre>
<h4> PADYMKO, Comment 69953727 Score: 7: </h4>This answer absolutely ignore a variant if a filename contains many points in name. Example get_extension(&#39;cmocka-1.1.0.tar.xz&#39;) =&gt; &#39;.1.0.tar.xz&#39; - wrong.<br><h4> thiruvenkadam, Comment 60335478 Score: 2: </h4>This results in an exception when the file doesn&#39;t have any extension.<br><h4> PascalVKooten, Comment 104848726 Score: 2: </h4>Just change to <code>[-1]</code> then.<br><h4> Douwe van der Leest, Comment 104838799 Score: 0: </h4>@PADYMKO, IMHO one should not create filenames with full stops as part of the filename. The code above is not supposed to result in &#39;tar.xz&#39;<br>------------------------------------------------------------------ <br><h3> soheshdoshi, Id: 49306849, Score: 12: </h3><p>You can use a <code>split</code> on a <code>filename</code>:</p>

<pre><code>f_extns = filename.split(".")
print ("The extension of the file is : " + repr(f_extns[-1]))
</code></pre>

<p>This does not require additional library</p>
------------------------------------------------------------------ <br><h3> staytime, Id: 21851612, Score: 11: </h3><pre><code>filename='ext.tar.gz'
extension = filename[filename.rfind('.'):]
</code></pre>
<h4> mattst, Comment 64522983 Score: 2: </h4>This results in the last char of <code>filename</code> being returned if the filename has no <code>.</code> at all. This is because <code>rfind</code> returns <code>-1</code> if the string is not found.<br>------------------------------------------------------------------ <br><h3> dataninsight, Id: 70074722, Score: 10: </h3><h1>Extracting extension from filename in Python</h1>
<h2>Python os module splitext()</h2>
<p><strong>splitext()</strong> function splits the file path into a tuple having two values â€“ root and extension.</p>
<pre><code>import os
# unpacking the tuple
file_name, file_extension = os.path.splitext(&quot;/Users/Username/abc.txt&quot;)
print(file_name)
print(file_extension)
</code></pre>
<h2>Get File Extension using Pathlib Module</h2>
<p>Pathlib module to get the file extension</p>
<pre><code>import pathlib
pathlib.Path(&quot;/Users/pankaj/abc.txt&quot;).suffix
#output:'.txt'
</code></pre>
------------------------------------------------------------------ <br><h3> Execuday, Id: 47010981, Score: 6: </h3><p>Even this question is already answered I'd add the solution in Regex. </p>

<pre><code>&gt;&gt;&gt; import re
&gt;&gt;&gt; file_suffix = ".*(\..*)"
&gt;&gt;&gt; result = re.search(file_suffix, "somefile.ext")
&gt;&gt;&gt; result.group(1)
'.ext'
</code></pre>
<h4> pault, Comment 85735420 Score: 2: </h4>Or <code>\.[0-9a-z]+$</code> as in <a href="https://stackoverflow.com/questions/6582171/javascript-regex-for-matching-extracting-file-extension">this post</a>.<br>------------------------------------------------------------------ <br><h3> Kenstars, Id: 49898155, Score: 6: </h3><p>This is a direct string representation techniques :
I see a lot of solutions mentioned, but I think most are looking at split.
Split however does it at every occurrence of "." .
What you would rather be looking for is partition.</p>

<pre><code>string = "folder/to_path/filename.ext"
extension = string.rpartition(".")[-1]
</code></pre>
<h4> Nickolay, Comment 88105433 Score: 4: </h4>rpartition was already suggested by <a href="https://stackoverflow.com/a/42477550/1026">@weiyixie</a>.<br>------------------------------------------------------------------ <br><h3> Arnaldo P. Figueira Figueira, Id: 20898777, Score: 5: </h3><p>Another solution with right split:</p>

<pre><code># to get extension only

s = 'test.ext'

if '.' in s: ext = s.rsplit('.', 1)[1]

# or, to get file name and extension

def split_filepath(s):
    """
    get filename and extension from filepath 
    filepath -&gt; (filename, extension)
    """
    if not '.' in s: return (s, '')
    r = s.rsplit('.', 1)
    return (r[0], r[1])
</code></pre>
------------------------------------------------------------------ <br><h3> Muhammad Salman, Id: 69525687, Score: 5: </h3><p>you can use following code to split file name and extension.</p>
<pre><code>    import os.path
    filenamewithext = os.path.basename(filepath)
    filename, ext = os.path.splitext(filenamewithext)
    #print file name
    print(filename)
    #print file extension
    print(ext)
</code></pre>
------------------------------------------------------------------ <br><h3> Waleed Khaled, Id: 73893691, Score: 3: </h3><p>Well , i know im late</p>
<p>that's my simple solution</p>
<pre><code>file = '/foo/bar/whatever.ext'
extension = file.split('.')[-1]
print(extension)

#output will be ext
</code></pre>
<h4> BSD, Comment 131427016 Score: 1: </h4>I agree that there are drawbacks for completeness, HOWEVER, this is a &quot;simple&quot; solution and for simple uses it works. In my case, for example, I&#39;ve already confirmed that the file exists and is one of several filtered file types. I just need to know which one. For that application, this works.<br><h4> Waleed Khaled, Comment 131220044 Score: 0: </h4>@NsaNinja  but the malware.pdf.exe is [exe] type !  also for tar.gz !<br>------------------------------------------------------------------ <br><h3> Victor Wang, Id: 60593888, Score: 2: </h3><p>A true one-liner, if you like regex. 
And it doesn't matter even if you have additional "." in the middle</p>

<pre><code>import re

file_ext = re.search(r"\.([^.]+)$", filename).group(1)
</code></pre>

<p>See here for the result: <a href="https://regex101.com/r/19IgSG/1" rel="nofollow noreferrer">Click Here</a></p>
------------------------------------------------------------------ <br><h3> cng.buff, Id: 72343972, Score: 2: </h3><p>You can use <strong>endswith</strong> to identify the file extension in python</p>
<p>like bellow example</p>
<pre><code>for file in os.listdir():
    if file.endswith('.csv'):
        df1 =pd.read_csv(file)
        frames.append(df1)
        result = pd.concat(frames)
</code></pre>
------------------------------------------------------------------ <br><h3> Ibnul Husainan, Id: 61333913, Score: 1: </h3><p>try this:</p>

<pre><code>files = ['file.jpeg','file.tar.gz','file.png','file.foo.bar','file.etc']
pen_ext = ['foo', 'tar', 'bar', 'etc']

for file in files: #1
    if (file.split(".")[-2] in pen_ext): #2
        ext =  file.split(".")[-2]+"."+file.split(".")[-1]#3
    else:
        ext = file.split(".")[-1] #4
    print (ext) #5
</code></pre>

<ol>
<li>get all file name inside the list</li>
<li>splitting file name and check the penultimate extension, is it in the pen_ext list or not?</li>
<li>if yes then join it with the last extension and set it as the file's extension</li>
<li>if not then just put the last extension as the file's extension</li>
<li>and then check it out</li>
</ol>
<h4> Robert, Comment 108502917 Score: 2: </h4>This breaks for a bunch of special cases. See the accepted answer. It&#39;s reinventing the wheel, only in a buggy way.<br><h4> Brian61354270, Comment 108503352 Score: 0: </h4>Hello! While this code may solve the question, <a href="https://meta.stackexchange.com/q/114762">including an explanation</a> of how and why this solves the problem would really help to improve the quality of your post, and probably result in more up-votes. Remember that you are answering the question for readers in the future, not just the person asking now. Please <a href="https://stackoverflow.com/posts/61333913/edit">edit</a> your answer to add explanations and give an indication of what limitations and assumptions apply.<br><h4> Ibnul Husainan, Comment 108503546 Score: 0: </h4>@Brian like that?<br><h4> Robert, Comment 108503951 Score: 0: </h4>You&#39;re only making it worse, breaking it in new ways. <code>foo.tar</code> is a valid file name. What happens if I throw that at your code? What about <code>.bashrc</code> or <code>foo</code>? There is a library function for this for a reason...<br><h4> Ibnul Husainan, Comment 108508741 Score: 0: </h4>just create a list of extension file for the penultimate extension, if not in list then just put the last extension as the file&#39;s extension<br>------------------------------------------------------------------ <br><h3> Harris Khan, Id: 73893537, Score: 1: </h3><p>The easiest way to get is to use <strong>mimtypes</strong>, below is the example:</p>
<pre><code>import mimetypes

mt = mimetypes.guess_type(&quot;file name&quot;)
file_extension =  mt[0]
print(file_extension)
</code></pre>
------------------------------------------------------------------ <br><h3> Eric, Id: 75423886, Score: 1: </h3><p>I'm definitely late to the party, but in case anyone wanted to achieve this without the use of another library:</p>
<pre><code>file_path = &quot;example_tar.tar.gz&quot;
file_name, file_ext = [file_path if &quot;.&quot; not in file_path else file_path.split(&quot;.&quot;)[0], &quot;&quot; if &quot;.&quot; not in file_path else file_path[file_path.find(&quot;.&quot;) + 1:]]
print(file_name, file_ext)
</code></pre>
<p>The 2nd line is basically just the following code but crammed into one line:</p>
<pre><code>def name_and_ext(file_path):
    if &quot;.&quot; not in file_path:
        file_name = file_path
    else:
        file_name = file_path.split(&quot;.&quot;)[0]
    if &quot;.&quot; not in file_path:
        file_ext = &quot;&quot;
    else:
        file_ext = file_path[file_path.find(&quot;.&quot;) + 1:]
    return [file_name, file_ext]
</code></pre>
<p>Even though this works, it might not work will all types of files, specifically <code>.zshrc</code>, I would recomment using <code>os</code>'s <code>os.path.splitext</code> function, example below:</p>
<pre><code>import os
file_path = &quot;example.tar.gz&quot;
file_name, file_ext = os.path.splitext(file_path)
print(file_name, file_ext)
</code></pre>
<p>Cheers :)</p>
------------------------------------------------------------------ <br><h3> eatmeimadanish, Id: 60230382, Score: 0: </h3><p>For funsies... just collect the extensions in a dict, and track all of them in a folder.  Then just pull the extensions you want. </p>

<pre><code>import os

search = {}

for f in os.listdir(os.getcwd()):
    fn, fe = os.path.splitext(f)
    try:
        search[fe].append(f)
    except:
        search[fe]=[f,]

extensions = ('.png','.jpg')
for ex in extensions:
    found = search.get(ex,'')
    if found:
        print(found)
</code></pre>
<h4> Robert, Comment 108502956 Score: 0: </h4>That&#39;s a terrible idea. Your code breaks for any file extension you haven&#39;t previously added!<br>------------------------------------------------------------------ <br><h3> Import Error, Id: 73045152, Score: 0: </h3><p>This method will require a dictonary, list, or set. you can just use &quot;.endswith&quot; using built in string methods. This will search for name in list at end of file and can be done with just <code>str.endswith(fileName[index])</code>. This is more for getting and comparing extensions.</p>
<p><a href="https://docs.python.org/3/library/stdtypes.html#string-methods" rel="nofollow noreferrer">https://docs.python.org/3/library/stdtypes.html#string-methods</a></p>
<p><strong>Example 1</strong>:</p>
<pre><code>dictonary = {0:&quot;.tar.gz&quot;, 1:&quot;.txt&quot;, 2:&quot;.exe&quot;, 3:&quot;.js&quot;, 4:&quot;.java&quot;, 5:&quot;.python&quot;, 6:&quot;.ruby&quot;,7:&quot;.c&quot;, 8:&quot;.bash&quot;, 9:&quot;.ps1&quot;, 10:&quot;.html&quot;, 11:&quot;.html5&quot;, 12:&quot;.css&quot;, 13:&quot;.json&quot;, 14:&quot;.abc&quot;} 
for x in dictonary.values():
    str = &quot;file&quot; + x
    str.endswith(x, str.index(&quot;.&quot;), len(str))
</code></pre>
<p><strong>Example 2:</strong></p>
<pre><code>set1 = {&quot;.tar.gz&quot;, &quot;.txt&quot;, &quot;.exe&quot;, &quot;.js&quot;, &quot;.java&quot;, &quot;.python&quot;, &quot;.ruby&quot;, &quot;.c&quot;, &quot;.bash&quot;, &quot;.ps1&quot;, &quot;.html&quot;, &quot;.html5&quot;, &quot;.css&quot;, &quot;.json&quot;, &quot;.abc&quot;}
for x in set1:
   str = &quot;file&quot; + x
   str.endswith(x, str.index(&quot;.&quot;), len(str))
</code></pre>
<p><strong>Example 3:</strong></p>
<pre><code>fileName = [&quot;.tar.gz&quot;, &quot;.txt&quot;, &quot;.exe&quot;, &quot;.js&quot;, &quot;.java&quot;, &quot;.python&quot;, &quot;.ruby&quot;, &quot;.c&quot;, &quot;.bash&quot;, &quot;.ps1&quot;, &quot;.html&quot;, &quot;.html5&quot;, &quot;.css&quot;, &quot;.json&quot;, &quot;.abc&quot;];
for x in range(0, len(fileName)):
    str = &quot;file&quot; + fileName[x]
    str.endswith(fileName[x], str.index(&quot;.&quot;), len(str))
</code></pre>
<p><strong>Example 4</strong></p>
<pre><code>fileName = [&quot;.tar.gz&quot;, &quot;.txt&quot;, &quot;.exe&quot;, &quot;.js&quot;, &quot;.java&quot;, &quot;.python&quot;, &quot;.ruby&quot;, &quot;.c&quot;, &quot;.bash&quot;, &quot;.ps1&quot;, &quot;.html&quot;, &quot;.html5&quot;, &quot;.css&quot;, &quot;.json&quot;, &quot;.abc&quot;];
str = &quot;file.txt&quot;
str.endswith(fileName[1], str.index(&quot;.&quot;), len(str))
</code></pre>
<p><strong>Examples 5, 6, 7 with output</strong>
<a href="https://i.stack.imgur.com/lmynI.png" rel="nofollow noreferrer"><img src="https://i.stack.imgur.com/lmynI.png" alt="enter image description here" /></a></p>
<p><strong>Example 8</strong></p>
<pre><code>fileName = [&quot;.tar.gz&quot;, &quot;.txt&quot;, &quot;.exe&quot;, &quot;.js&quot;, &quot;.java&quot;, &quot;.python&quot;, &quot;.ruby&quot;, &quot;.c&quot;, &quot;.bash&quot;, &quot;.ps1&quot;, &quot;.html&quot;, &quot;.html5&quot;, &quot;.css&quot;, &quot;.json&quot;, &quot;.abc&quot;];
exts = []
str = &quot;file.txt&quot;
for x in range(0, len(x)):
    if str.endswith(fileName[1]) == 1:
         exts += [x]
     
</code></pre>
------------------------------------------------------------------ <br><h3> Yes But No, Id: 74834604, Score: 0: </h3><p>Here if you want to extract the last file extension if it has multiple</p>
<pre class="lang-py prettyprint-override"><code>class functions:
    def listdir(self, filepath):
        return os.listdir(filepath)
    
func = functions()

os.chdir(&quot;C:\\Users\Asus-pc\Downloads&quot;) #absolute path, change this to your directory
current_dir = os.getcwd()

for i in range(len(func.listdir(current_dir))): #i is set to numbers of files and directories on path directory
    if os.path.isfile((func.listdir(current_dir))[i]): #check if it is a file
        fileName = func.listdir(current_dir)[i] #put the current filename into a variable
        rev_fileName = fileName[::-1] #reverse the filename
        currentFileExtension = rev_fileName[:rev_fileName.index('.')][::-1] #extract from beginning until before .
        print(currentFileExtension) #output can be mp3,pdf,ini,exe, depends on the file on your absolute directory
</code></pre>
<p>Output is mp3, even works if has only 1 extension name</p>
------------------------------------------------------------------ <br><h3> DragonX, Id: 29396553, Score: -2: </h3><pre class="lang-py prettyprint-override"><code># try this, it works for anything, any length of extension
# e.g www.google.com/downloads/file1.gz.rs -&gt; .gz.rs

import os.path

class LinkChecker:

    @staticmethod
    def get_link_extension(link: str)-&gt;str:
        if link is None or link == "":
            return ""
        else:
            paths = os.path.splitext(link)
            ext = paths[1]
            new_link = paths[0]
            if ext != "":
                return LinkChecker.get_link_extension(new_link) + ext
            else:
                return ""
</code></pre>
------------------------------------------------------------------ <br><h3> lendoo, Id: 66205362, Score: -2: </h3><pre><code>a = &quot;.bashrc&quot;
b = &quot;text.txt&quot;
extension_a = a.split(&quot;.&quot;)
extension_b = b.split(&quot;.&quot;)
print(extension_a[-1])  # bashrc
print(extension_b[-1])  # txt
</code></pre>
<h4> Audwin Oyong, Comment 122147220 Score: 0: </h4>Please add explanation of the code, rather than simply just the code snippets.<br>------------------------------------------------------------------ <br><h3> user5535053, Id: 33575151, Score: -3: </h3><pre><code>def NewFileName(fichier):
    cpt = 0
    fic , *ext =  fichier.split('.')
    ext = '.'.join(ext)
    while os.path.isfile(fichier):
        cpt += 1
        fichier = '{0}-({1}).{2}'.format(fic, cpt, ext)
    return fichier
</code></pre>
------------------------------------------------------------------ <br><h3> Ripon Kumar Saha, Id: 59589710, Score: -3: </h3><p>This is <strong>The Simplest Method</strong> to get both Filename &amp; Extension in just a <strong>single line</strong>.</p>

<pre><code>fName, ext = 'C:/folder name/Flower.jpeg'.split('/')[-1].split('.')

&gt;&gt;&gt; print(fName)
Flower
&gt;&gt;&gt; print(ext)
jpeg
</code></pre>

<p>Unlike other solutions, you don't need to import any package for this.</p>
<h4> studioj, Comment 107341098 Score: 4: </h4>this doesnt work for all files or types for example &#39;archive.tar.gz<br><h4> Flimm, Comment 134268621 Score: 0: </h4>Windows uses / as a path separator, but other operating systems use \<br>