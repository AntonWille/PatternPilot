 <h2> Title: How do I measure elapsed time in Python? </h2> <h3> gilbert8, question_id: 7370801 </h3>Score: 2061, Tags: {python,performance,measure,timeit} <br><p>I want to measure the time it took to execute a function. I couldn't get <code>timeit</code> to work:</p>
<pre><code>import timeit
start = timeit.timeit()
print(&quot;hello&quot;)
end = timeit.timeit()
print(end - start)
</code></pre>
<h4> Comment 118233992 Llopeth: </h4>timeit.timeit()  prints the time that it takes to execute its argument, which is &quot;pass&quot; by default.  you have to instead use start= time.time()    end = time.time()<br><h4> Comment 131410240 daniel blanco: </h4>I wrote this module that does the same as the accepted answer but with a decorator <a href="https://pypi.org/project/time-it/" rel="nofollow noreferrer">pypi.org/project/time-it</a><br><h4> Comment 132346054 Thomas: </h4>your example would be something like: <code>timeit.timeit(&#39;print(&quot;hello&quot;)&#39;,number=10)</code><br>------------------------------------------------------------------ <br><h3> Answer 7370824 NPE: </h3><p>Use <a href="http://docs.python.org/library/time.html#time.time" rel="noreferrer"><code>time.time()</code></a> to measure the elapsed wall-clock time between two points:</p>
<pre><code>import time

start = time.time()
print(&quot;hello&quot;)
end = time.time()
print(end - start)
</code></pre>
<p>This gives the execution time in seconds.</p>
<hr />
<p>Another option since Python 3.3 might be to use <a href="https://docs.python.org/3/library/time.html#time.perf_counter" rel="noreferrer"><code>perf_counter</code></a> or <a href="https://docs.python.org/3/library/time.html#time.process_time" rel="noreferrer"><code>process_time</code></a>, depending on your requirements. Before 3.3 it was recommended to use <a href="http://docs.python.org/library/time.html#time.clock" rel="noreferrer"><code>time.clock</code></a> (thanks <a href="https://stackoverflow.com/users/148870/amber">Amber</a>). However, it is currently deprecated:</p>
<blockquote>
<p>On Unix, return the current processor time as a floating point number
expressed in seconds. The precision, and in fact the very definition
of the meaning of “processor time”, depends on that of the C function
of the same name.</p>
<p>On Windows, this function returns wall-clock seconds elapsed since the
first call to this function, as a floating point number, based on the
Win32 function <code>QueryPerformanceCounter()</code>. The resolution is typically
better than one microsecond.</p>
<p><em>Deprecated since version 3.3</em>: The behaviour of this function depends
on the platform: <strong>use <code>perf_counter()</code> or <code>process_time()</code> instead</strong>,
depending on your requirements, to have a well defined behaviour.</p>
</blockquote>
<h4> Comment 136660478 Martin C. Martin: </h4>time.time() is affected by NTP errors, someone accidentally setting the year to 3023 by mistake then correcting it, leap seconds, etc.  So this is something that works most of the time, but occasionally gets it wrong, in ways that can be hard to understand and impossible to reproduce.<br><h4> Comment 136660488 Martin C. Martin: </h4>cloc(), perf_counter() and process_time() don&#39;t include sleep().  Sometimes, that&#39;s what you want, other times, it isn&#39;t.  For example, in finding out why a request is slow, &quot;my process was swapped out&quot; is something you&#39;d like to show up in your timing data.<br><h4> Comment 136660577 Martin C. Martin: </h4>time.monotonic() is designed for this use case.<br>------------------------------------------------------------------ <br><h3> Answer 25823885 jfs: </h3><p>Use <code>timeit.default_timer</code> instead of <code>timeit.timeit</code>. The former provides the best clock available on your platform and version of Python automatically:</p>
<pre><code>from timeit import default_timer as timer

start = timer()
# ...
end = timer()
print(end - start) # Time in seconds, e.g. 5.38091952400282
</code></pre>
<p><a href="http://docs.python.org/2/library/timeit.html#timeit.default_timer" rel="noreferrer">timeit.default_timer</a> is assigned to time.time() or time.clock() depending on OS. On Python 3.3+ <a href="http://docs.python.org/3/library/timeit#timeit.default_timer" rel="noreferrer">default_timer</a> is <a href="http://docs.python.org/3/library/time.html#time.perf_counter" rel="noreferrer">time.perf_counter()</a> on all platforms. See <a href="https://stackoverflow.com/q/85451/4279">Python - time.clock() vs. time.time() - accuracy?</a></p>
<p>See also:</p>
<ul>
<li><a href="http://scipy-lectures.github.io/advanced/optimizing/" rel="noreferrer">Optimizing code</a></li>
<li><a href="http://scikit-learn.org/stable/developers/performance.html" rel="noreferrer">How to optimize for speed</a></li>
</ul>
<h4> Comment 69371159 lkgarrison: </h4>Excellent answer - using <b>timeit</b> will produce far more accurate results since it will automatically account for things like garbage collection and OS differences<br><h4> Comment 135073498 Robin_hood_963: </h4>I use this in a script and it gives 62 secs and in another EXACTLY the same commands and i get this values for start , end and elapsed time  8357.5812534 8360.9289703 Elapsed time: 8340.9289703 seconds  what is going on??<br>------------------------------------------------------------------ <br><h3> Answer 21455138 Pierre Prinetti: </h3><h1>Python 3 only:</h1>
<p>Since <code>time.clock()</code> <a href="https://docs.python.org/3.3/library/time.html#time.clock" rel="noreferrer">is deprecated as of Python 3.3</a>, you will want to use <a href="https://docs.python.org/3/library/time.html#time.perf_counter" rel="noreferrer"><code>time.perf_counter()</code></a> for system-wide timing, or <a href="https://docs.python.org/3/library/time.html#time.process_time" rel="noreferrer"><code>time.process_time()</code></a> for process-wide timing, just the way you used to use <code>time.clock()</code>:</p>
<pre><code>import time

t = time.process_time()
#do some stuff
elapsed_time = time.process_time() - t
</code></pre>
<p>The new function <code>process_time</code> will not include time elapsed during sleep.</p>
<h4> Comment 133375496 MikeB: </h4>The docs say that <code>process_time()</code> returns the sum of CPU and user time. Doesn&#39;t that mean this only returns the time that <code># do some stuff</code> was running (and not blocking -- like on IO) and not the actual elapsed time?<br>------------------------------------------------------------------ <br><h3> Answer 55239060 Gal Bracha: </h3><p>Measuring time <strong>in seconds:</strong></p>
<pre class="lang-py prettyprint-override"><code>from timeit import default_timer as timer
from datetime import timedelta

start = timer()

# ....
# (your code runs here)
# ...

end = timer()
print(timedelta(seconds=end-start))
</code></pre>
<p><strong>Output</strong>:</p>
<pre><code>0:00:01.946339
</code></pre>
------------------------------------------------------------------ <br><h3> Answer 7370980 unutbu: </h3><p>Given a function you'd like to time,</p>

<p>test.py:</p>

<pre><code>def foo(): 
    # print "hello"   
    return "hello"
</code></pre>

<p>the easiest way to use <code>timeit</code> is to call it from the command line:</p>

<pre><code>% python -mtimeit -s'import test' 'test.foo()'
1000000 loops, best of 3: 0.254 usec per loop
</code></pre>

<p>Do not try to use <code>time.time</code> or <code>time.clock</code> (naively) to compare the speed of functions. <a href="https://stackoverflow.com/questions/1622943/timeit-versus-timing-decorator">They can give misleading results</a>.</p>

<p>PS. Do not put print statements in a function you wish to time; otherwise the time measured will depend on the <a href="https://stackoverflow.com/questions/3857052/why-is-printing-to-stdout-so-slow-can-it-be-sped-up/3860319#3860319">speed of the terminal</a>.</p>
------------------------------------------------------------------ <br><h3> Answer 30024601 gojomo: </h3><p>It's fun to do this with a context-manager that automatically remembers the start time upon entry to a <code>with</code> block, then freezes the end time on block exit. With a little trickery, you can even get a running elapsed-time tally inside the block from the same context-manager function. </p>

<p>The core library doesn't have this (but probably ought to). Once in place, you can do things like:</p>

<pre><code>with elapsed_timer() as elapsed:
    # some lengthy code
    print( "midpoint at %.2f seconds" % elapsed() )  # time so far
    # other lengthy code

print( "all done at %.2f seconds" % elapsed() )
</code></pre>

<p>Here's <a href="https://docs.python.org/dev/library/contextlib.html#contextlib.contextmanager" rel="noreferrer">contextmanager</a> code sufficient to do the trick:</p>

<pre><code>from contextlib import contextmanager
from timeit import default_timer

@contextmanager
def elapsed_timer():
    start = default_timer()
    elapser = lambda: default_timer() - start
    yield lambda: elapser()
    end = default_timer()
    elapser = lambda: end-start
</code></pre>

<p>And some runnable demo code:</p>

<pre><code>import time

with elapsed_timer() as elapsed:
    time.sleep(1)
    print(elapsed())
    time.sleep(2)
    print(elapsed())
    time.sleep(3)
</code></pre>

<p>Note that by design of this function, the return value of <code>elapsed()</code> is frozen on block exit, and further calls return the same duration (of about 6 seconds in this toy example). </p>
<h4> Comment 61565152 J&#233;r&#244;me: </h4>Other context manager example: <a href="http://dabeaz.blogspot.fr/2010/02/context-manager-for-timing-benchmarks.html" rel="nofollow noreferrer">dabeaz.blogspot.fr/2010/02/&hellip;</a><br><h4> Comment 70019895 Brian Burns: </h4>@J&#233;r&#244;me nice example - I adapted it as another answer - <a href="http://stackoverflow.com/a/41408510/243392">stackoverflow.com/a/41408510/243392</a><br><h4> Comment 136690772 Gergely M: </h4>My very similar indie solution:  <a href="https://stackoverflow.com/questions/77533604/python-execution-timing-with-context-manager" title="python execution timing with context manager">stackoverflow.com/questions/77533604/&hellip;</a><br>------------------------------------------------------------------ <br><h3> Answer 45668747 Reddspark: </h3><p>I prefer this. <code>timeit</code> doc is far too confusing. </p>

<pre><code>from datetime import datetime 

start_time = datetime.now() 

# INSERT YOUR CODE 

time_elapsed = datetime.now() - start_time 

print('Time elapsed (hh:mm:ss.ms) {}'.format(time_elapsed))
</code></pre>

<p>Note, that there isn't any formatting going on here, I just wrote <code>hh:mm:ss</code> into the printout so one can interpret <code>time_elapsed</code></p>
<h4> Comment 100792604 user1318499: </h4>It&#39;s risky to measure elapsed time this way because datetime.now() can change between the two calls for reasons like network time syncing, daylight savings switchover or the user twiddling the clock.<br><h4> Comment 83006908 Sreehari R: </h4>I was told that timeit calculates the CPU time, does datetime also take into account CPU time used? Are these the same thing?<br><h4> Comment 111761232 mic: </h4>From Shital Shah&#39;s answer: &quot;First, if you are debating between timeit and time.time, the timeit has two advantages:      timeit selects the best timer available on your OS and Python version.     timeit disables garbage collection, however, this is not something you may or may not want.&quot;<br>------------------------------------------------------------------ <br><h3> Answer 56928886 Mingwei He: </h3><p>Here's another way to do this:</p>

<pre><code>&gt;&gt; from pytictoc import TicToc
&gt;&gt; t = TicToc() # create TicToc instance
&gt;&gt; t.tic() # Start timer
&gt;&gt; # do something
&gt;&gt; t.toc() # Print elapsed time
Elapsed time is 2.612231 seconds.
</code></pre>

<p>Comparing with traditional way:</p>

<pre><code>&gt;&gt; from time import time
&gt;&gt; t1 = time()
&gt;&gt; # do something
&gt;&gt; t2 = time()
&gt;&gt; elapsed = t2 - t1
&gt;&gt; print('Elapsed time is %f seconds.' % elapsed)
Elapsed time is 2.612231 seconds.
</code></pre>

<p>Installation:</p>

<pre><code>pip install pytictoc
</code></pre>

<p>Refer to the <a href="https://pypi.org/project/pytictoc/" rel="noreferrer">PyPi page</a> for more details.</p>
<h4> Comment 100399019 hlg: </h4>It would be good to explain the advantage of using this library over other approaches.<br><h4> Comment 108007190 H. S&#225;nchez: </h4>@PetarMI : FYI, I just fixed the issue with <code>ttictoc</code>. Quite a mess I had, but it should be good now.<br><h4> Comment 103211214 ScottieB: </h4>I find the nesting a little confusing.  If I were to come across <code>t.tic()</code> buried in the code, it&#39;s up to me the developer to keep a mental list of where in the series I should expect this to be.  Do you find yourself setting up nests or just multiple tictocs?<br><h4> Comment 100481226 PetarMI: </h4>The nested functionality is actually broken. I opened an issue describing where the problem in the code is but the repo hasn&#39;t been maintained in a year so I wouldn&#39;t expect a change.<br><h4> Comment 114760688 Henri: </h4>@hlg If I remember correctly, MATLAB uses functions with similar names to time stuff. So I guess the advantage is the resemblance, for people who liked this in MATLAB but switched to Python.<br>------------------------------------------------------------------ <br><h3> Answer 62106731 Wojciech Moszczyński: </h3><p>The easiest way to calculate the duration of an operation:</p>
<pre><code>import time

start_time = time.monotonic()

&lt;operations, programs&gt;

print('seconds: ', time.monotonic() - start_time)
</code></pre>
<p>Official docs <a href="https://docs.python.org/3/library/time.html#time.monotonic" rel="noreferrer">here</a>.</p>
<h4> Comment 123249831 alexsmail: </h4>It is better to use <code>time.monotonic_ns()</code>, see <a href="https://docs.python.org/3/library/time.html#time.monotonic_ns" rel="nofollow noreferrer">docs.python.org/3/library/time.html#time.monotonic_ns</a><br><h4> Comment 118574134 Paolo: </h4>@user1318499 it&#39;s not that it returns negative values, it can return a lower value than a previous call. <a href="https://docs.python.org/3/library/time.html#time.time" rel="nofollow noreferrer">docs.python.org/3/library/time.html#time.time</a><br>------------------------------------------------------------------ <br><h3> Answer 52288622 Shital Shah: </h3><p>Here are my findings after going through many good answers here as well as a few other articles.</p>
<p>First, if you are debating between <code>timeit</code> and <code>time.time</code>, the <code>timeit</code> has two advantages:</p>
<ol>
<li><code>timeit</code> selects the best timer available on your OS and Python version.</li>
<li><code>timeit</code> disables garbage collection, however, this is not something you may or may not want.</li>
</ol>
<p>Now the problem is that <code>timeit</code> is not that simple to use because it needs setup and things get ugly when you have a bunch of imports. Ideally, you just want a decorator or use <code>with</code> block and measure time. Unfortunately, there is nothing built-in available for this so you have two options:</p>
<p><strong>Option 1: Use timebudget library</strong></p>
<p>The <a href="https://github.com/leopd/timebudget" rel="noreferrer">timebudget</a> is a versatile and very simple library that you can use just in one line of code after pip install.</p>
<pre><code>@timebudget  # Record how long this function takes
def my_method():
    # my code
</code></pre>
<p><strong>Option 2: Use my small module</strong></p>
<p>I created below little timing utility module called <a href="https://github.com/microsoft/archai/blob/6cdefa40f6f91ac12198e648a05b3ea839fae7e5/archai/common/timing.py" rel="noreferrer">timing.py</a>. Just drop this file in your project and start using it. The only external dependency is <a href="https://pypi.org/project/runstats/" rel="noreferrer">runstats</a> which is again small.</p>
<p>Now you can time any function just by putting a decorator in front of it:</p>
<pre><code>import timing

@timing.MeasureTime
def MyBigFunc():
    #do something time consuming
    for i in range(10000):
        print(i)

timing.print_all_timings()
</code></pre>
<p>If you want to time portion of code then just put it inside <code>with</code> block:</p>
<pre><code>import timing

#somewhere in my code

with timing.MeasureBlockTime(&quot;MyBlock&quot;):
    #do something time consuming
    for i in range(10000):
        print(i)

# rest of my code

timing.print_all_timings()
</code></pre>
<p>Advantages:</p>
<p>There are several half-backed versions floating around so I want to point out few highlights:</p>
<ol>
<li>Use timer from timeit instead of time.time for reasons described earlier.</li>
<li>You can disable GC during timing if you want.</li>
<li>Decorator accepts functions with named or unnamed params.</li>
<li>Ability to disable printing in block timing (use <code>with timing.MeasureBlockTime() as t</code> and then <code>t.elapsed</code>).</li>
<li>Ability to keep gc enabled for block timing.</li>
</ol>
<h4> Comment 111761731 mic: </h4>Regarding &quot;Ability to disable printing in block timing (use <code>with utils.MeasureBlockTime() as t</code> and then <code>t.elapsed</code>).&quot;: this doesn&#39;t work as is, as <code>t</code> is <code>None</code>. I think <code>__enter__</code> needs to return <code>self</code>, and to disable printing, we have to construct it as <code>utils.MeasureBlockTime(no_print=True)</code>.<br><h4> Comment 111778987 Shital Shah: </h4>@mic - thanks for pointing this out. I&#39;ve updated the answer with this and several other enhancements.<br>------------------------------------------------------------------ <br><h3> Answer 7370883 rocksportrocker: </h3><p>Using <code>time.time</code> to measure execution gives you the overall execution time of your commands including running time spent by other processes on your computer. It is the time the user notices, but is not good if you want to compare different code snippets / algorithms / functions / ...</p>

<p>More information on <code>timeit</code>:</p>

<ul>
<li><a href="http://www.diveintopython.net/performance_tuning/timeit.html" rel="noreferrer">Using the timeit Module</a></li>
<li><a href="http://www.doughellmann.com/PyMOTW/timeit/" rel="noreferrer">timeit – Time the execution of small bits of Python code</a></li>
</ul>

<p>If you want a deeper insight into profiling:</p>

<ul>
<li><a href="http://wiki.python.org/moin/PythonSpeed/PerformanceTips#Profiling_Code" rel="noreferrer">http://wiki.python.org/moin/PythonSpeed/PerformanceTips#Profiling_Code</a></li>
<li><a href="https://stackoverflow.com/questions/582336/how-can-you-profile-a-python-script">How can you profile a python script?</a></li>
</ul>

<p><strong>Update</strong>: I used <a href="http://pythonhosted.org/line_profiler/" rel="noreferrer">http://pythonhosted.org/line_profiler/</a> a lot during the last year and find it very helpfull and recommend to use it instead of Pythons profile module.</p>
------------------------------------------------------------------ <br><h3> Answer 34806005 DmitrySemenov: </h3><p><strong>on python3:</strong></p>
<pre><code>from time import sleep, perf_counter as pc
t0 = pc()
sleep(1)
print(pc()-t0)
</code></pre>
<p>elegant and short.</p>
<p><strong>output:</strong></p>
<pre><code>1.001345009999568
</code></pre>
<h4> Comment 110085293 Guimoute: </h4>@KIC It&#39;s in seconds.<br><h4> Comment 133923667 Markus Dutschke: </h4>I can&#39;t believe this is the first answer mentioning performance counter <code>perf_counter</code>! Thank you :)<br><h4> Comment 136294848 Joneron: </h4>Note there is a <code>time.perf_counter</code> and <code>time.perf_counter_ns</code> function :)<br><h4> Comment 102208566 KIC: </h4>what is this? ms?<br>------------------------------------------------------------------ <br><h3> Answer 41408510 Brian Burns: </h3><p>Here's another context manager for timing code -</p>

<p>Usage: </p>

<pre><code>from benchmark import benchmark

with benchmark("Test 1+1"):
    1+1
=&gt;
Test 1+1 : 1.41e-06 seconds
</code></pre>

<p>or, if you need the time value</p>

<pre><code>with benchmark("Test 1+1") as b:
    1+1
print(b.time)
=&gt;
Test 1+1 : 7.05e-07 seconds
7.05233786763e-07
</code></pre>

<p><strong>benchmark.py</strong>:</p>

<pre><code>from timeit import default_timer as timer

class benchmark(object):

    def __init__(self, msg, fmt="%0.3g"):
        self.msg = msg
        self.fmt = fmt

    def __enter__(self):
        self.start = timer()
        return self

    def __exit__(self, *args):
        t = timer() - self.start
        print(("%s : " + self.fmt + " seconds") % (self.msg, t))
        self.time = t
</code></pre>

<p>Adapted from <a href="http://dabeaz.blogspot.fr/2010/02/context-manager-for-timing-benchmarks.html" rel="noreferrer">http://dabeaz.blogspot.fr/2010/02/context-manager-for-timing-benchmarks.html</a></p>
------------------------------------------------------------------ <br><h3> Answer 45178581 Leonid Ganeline: </h3><p>Use profiler module. It gives a very detailed profile.</p>

<pre><code>import profile
profile.run('main()')
</code></pre>

<p>it outputs something like:</p>

<pre><code>          5 function calls in 0.047 seconds

   Ordered by: standard name

   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
        1    0.000    0.000    0.000    0.000 :0(exec)
        1    0.047    0.047    0.047    0.047 :0(setprofile)
        1    0.000    0.000    0.000    0.000 &lt;string&gt;:1(&lt;module&gt;)
        0    0.000             0.000          profile:0(profiler)
        1    0.000    0.000    0.047    0.047 profile:0(main())
        1    0.000    0.000    0.000    0.000 two_sum.py:2(twoSum)
</code></pre>

<p>I've found it very informative.</p>
<h4> Comment 91970312 not2qubit: </h4>What is <code>main()</code>? Would be more useful if you could provide a simple code example.<br>------------------------------------------------------------------ <br><h3> Answer 20791871 sanchitarora: </h3><p>The python cProfile and pstats modules offer great support for measuring time elapsed in certain functions without having to add any code around the existing functions.</p>

<p>For example if you have a python script timeFunctions.py:</p>

<pre><code>import time

def hello():
    print "Hello :)"
    time.sleep(0.1)

def thankyou():
    print "Thank you!"
    time.sleep(0.05)

for idx in range(10):
    hello()

for idx in range(100):
    thankyou()
</code></pre>

<p>To run the profiler and generate stats for the file you can just run:</p>

<pre><code>python -m cProfile -o timeStats.profile timeFunctions.py
</code></pre>

<p>What this is doing is using the cProfile module to profile all functions in timeFunctions.py and collecting the stats in the timeStats.profile file. Note that we did not have to add any code to existing module (timeFunctions.py) and this can be done with any module.</p>

<p>Once you have the stats file you can run the pstats module as follows:</p>

<pre><code>python -m pstats timeStats.profile
</code></pre>

<p>This runs the interactive statistics browser which gives you a lot of nice functionality. For your particular use case you can just check the stats for your function. In our example checking stats for both functions shows us the following:</p>

<pre><code>Welcome to the profile statistics browser.
timeStats.profile% stats hello
&lt;timestamp&gt;    timeStats.profile

         224 function calls in 6.014 seconds

   Random listing order was used
   List reduced from 6 to 1 due to restriction &lt;'hello'&gt;

   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
       10    0.000    0.000    1.001    0.100 timeFunctions.py:3(hello)

timeStats.profile% stats thankyou
&lt;timestamp&gt;    timeStats.profile

         224 function calls in 6.014 seconds

   Random listing order was used
   List reduced from 6 to 1 due to restriction &lt;'thankyou'&gt;

   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
      100    0.002    0.000    5.012    0.050 timeFunctions.py:7(thankyou)
</code></pre>

<p>The dummy example does not do much but give you an idea of what can be done. The best part about this approach is that I dont have to edit any of my existing code to get these numbers and obviously help with profiling.</p>
<h4> Comment 35112217 ShreevatsaR: </h4>Actually there is some confusion; it appears cProfile does look at wall-clock time by default. I&#39;ve upvoted your answer.<br><h4> Comment 92908549 JayRizzo: </h4>FYI: If you get <code>python -m pstats timeStats.profile ValueError: bad marshal data (unknown type code)</code> check your python version you are running.  I got this when i ran <code>python3 -m cProfile...</code> and <code>python -m pstats</code>. My mistake but got me for a second, so, I wanted to share <code>don&#39;t forget consistency</code>. =)<br><h4> Comment 35111826 ShreevatsaR: </h4>All this is fine, but AFAICT this still measures CPU time, not wall clock time.<br>------------------------------------------------------------------ <br><h3> Answer 27107047 Eyal Ch: </h3><p>(With Ipython only) you can use <a href="https://ipython.org/ipython-doc/3/interactive/magics.html#magic-timeit" rel="noreferrer">%timeit</a> to measure average processing time:</p>

<pre><code>def foo():
    print "hello"
</code></pre>

<p>and then:    </p>

<pre><code>%timeit foo()
</code></pre>

<p>the result is something like:</p>

<pre><code>10000 loops, best of 3: 27 µs per loop
</code></pre>
<h4> Comment 69529575 raacer: </h4>It worth to mention it is possible to pass flags to %timeit, for example -n specifies how many times the code should be repeated.<br><h4> Comment 135134343 Memming: </h4><code>%%timeit</code> for jupyter notebook cell!<br>------------------------------------------------------------------ <br><h3> Answer 35199035 Danijel: </h3><p>Here is a tiny timer class that returns "hh:mm:ss" string: </p>

<pre><code>class Timer:
  def __init__(self):
    self.start = time.time()

  def restart(self):
    self.start = time.time()

  def get_time_hhmmss(self):
    end = time.time()
    m, s = divmod(end - self.start, 60)
    h, m = divmod(m, 60)
    time_str = "%02d:%02d:%02d" % (h, m, s)
    return time_str
</code></pre>

<p>Usage: </p>

<pre><code># Start timer
my_timer = Timer()

# ... do something

# Get time string:
time_hhmmss = my_timer.get_time_hhmmss()
print("Time elapsed: %s" % time_hhmmss )

# ... use the timer again
my_timer.restart()

# ... do something

# Get time:
time_hhmmss = my_timer.get_time_hhmmss()

# ... etc
</code></pre>
<h4> Comment 116453214 howdoicode: </h4>And now with f-strings and <a href="https://docs.python.org/3/library/string.html#format-specification-mini-language" rel="nofollow noreferrer"><code>format specifications</code></a> included: <code>time_str = f&quot;{h:02d}:{m:02d}:{s:02d}&quot;</code><br>------------------------------------------------------------------ <br><h3> Answer 56655327 David: </h3><p>I like it <strong>simple</strong> (python 3):</p>

<pre><code>from timeit import timeit

timeit(lambda: print("hello"))
</code></pre>

<p>Output is <em>microseconds</em> for a single execution:</p>

<pre><code>2.430883963010274
</code></pre>

<p><strong>Explanation</strong>:
timeit executes the anonymous function <strong>1 million times</strong> by default and the result is given in <em>seconds</em>. Therefore the result for <em>1 single execution</em> is the same amount but in <em>microseconds</em> on average.</p>

<hr>

<p>For <strong>slow</strong> operations add a lower <em>number</em> of iterations or you could be waiting forever:</p>

<pre><code>import time

timeit(lambda: time.sleep(1.5), number=1)
</code></pre>

<p>Output is always in <em>seconds</em> for the total <em>number</em> of iterations:</p>

<pre><code>1.5015795179999714
</code></pre>
<h4> Comment 113491182 Harry Moreno: </h4>what do you mean by output? does timeit write to stdout?<br><h4> Comment 113538809 David: </h4>Nop. I mean the returned value.<br>------------------------------------------------------------------ <br><h3> Answer 56591404 Guillaume Chevalier: </h3><h1>To get insight on every function calls recursively, do:</h1>

<pre><code>%load_ext snakeviz
%%snakeviz
</code></pre>

<p>It just takes those <strong>2 lines of code</strong> in a <strong>Jupyter notebook</strong>, and it generates a nice interactive diagram. For example: </p>

<p><a href="https://i.stack.imgur.com/0ahaw.png" rel="noreferrer"><img src="https://i.stack.imgur.com/0ahaw.png" alt="enter image description here"></a></p>

<p>Here is the code. Again, the 2 lines starting with <code>%</code> are the only extra lines of code needed to use snakeviz: </p>

<pre><code># !pip install snakeviz
%load_ext snakeviz
import glob
import hashlib

%%snakeviz

files = glob.glob('*.txt')
def print_files_hashed(files):
    for file in files:
        with open(file) as f:
            print(hashlib.md5(f.read().encode('utf-8')).hexdigest())
print_files_hashed(files)
</code></pre>

<p>It also seems possible to run snakeviz outside notebooks. More info on the <a href="https://jiffyclub.github.io/snakeviz/" rel="noreferrer">snakeviz website</a>.</p>
------------------------------------------------------------------ <br><h3> Answer 61536335 Daniel Giger: </h3><p>If you want to be able to time functions conveniently, you can use a simple decorator:</p>
<pre class="lang-py prettyprint-override"><code>import time

def timing_decorator(func):
    def wrapper(*args, **kwargs):
        start = time.perf_counter()
        original_return_val = func(*args, **kwargs)
        end = time.perf_counter()
        print(&quot;time elapsed in &quot;, func.__name__, &quot;: &quot;, end - start, sep='')
        return original_return_val

    return wrapper
</code></pre>
<p>You can use it on a function that you want to time like this:</p>
<pre class="lang-py prettyprint-override"><code>@timing_decorator
def function_to_time():
    time.sleep(1)

function_to_time()
</code></pre>
<p>Any time you call <code>function_to_time</code>, it will print how long it took and the name of the function being timed.</p>
<h4> Comment 111953220 Frak: </h4>Is there a Python2.x way of doing this without having to import <code>print_function</code> from <code>__future__</code>? I tried to use <code>join</code> but I don&#39;t understand it well enough to get it to work.<br><h4> Comment 111953323 Frak: </h4>UPDATE. I figured it out and used this: <code>print(&#39;&#39;.join([&quot;time elapsed in &quot;,(func.__name__),&quot;: &quot;,str(end - start)]))</code><br><h4> Comment 130997076 haneulkim: </h4>Hi, is there way to measure time of function run conditionally? For example whenever I pass parameter <code>True</code> in it?<br>------------------------------------------------------------------ <br><h3> Answer 41164411 raacer: </h3><p>One more way to use <a href="https://docs.python.org/2/library/timeit.html" rel="noreferrer">timeit</a>:</p>

<pre class="lang-py prettyprint-override"><code>from timeit import timeit

def func():
    return 1 + 1

time = timeit(func, number=1)
print(time)
</code></pre>
------------------------------------------------------------------ <br><h3> Answer 63934234 Wojciech Moszczyński: </h3><p>How to measure the time between two operations. Compare the time of two operations.</p>
<pre><code>import time

b = (123*321)*123
t1 = time.time()

c = ((9999^123)*321)^123
t2 = time.time()

print(t2-t1)
</code></pre>
<p>7.987022399902344e-05</p>
<h4> Comment 124229700 Will Croxford: </h4>easy to read, easy to use, accurate enough for approx tests or comparisons. But, as I cannot seem to edit at time of writing, to, &#39;compare  the time of two operations&#39;, this should have <code>t0 = time.time()</code> I feel after import line. Then <code>print(t1 -t0)</code> is first operation time. 2 times are needed to compare 2 operations.<br>------------------------------------------------------------------ <br><h3> Answer 74502089 x0s: </h3><p>Here is an answer using:</p>
<ul>
<li>a concise context manager to time code snippets</li>
<li><code>time.perf_counter()</code> to compute time delta. It should be preferred as it is not adjustable (neither a sysadmin nor a daemon can change its value) contrary to <code>time.time()</code> (see <a href="https://docs.python.org/3/library/time.html#time.get_clock_info" rel="noreferrer">doc</a>)</li>
</ul>
<pre class="lang-py prettyprint-override"><code>import time
from collections.abc import Iterator
from contextlib import contextmanager

@contextmanager
def time_it() -&gt; Iterator[None]:
    tic: float = time.perf_counter()
    try:
        yield
    finally:
        toc: float = time.perf_counter()
        print(f&quot;Computation time = {1000*(toc - tic):.3f}ms&quot;)
</code></pre>
<p>An example how to use it:</p>
<pre class="lang-py prettyprint-override"><code># Example: vector dot product computation
with time_it():
    A = B = range(1_000_000)
    dot = sum(a*b for a,b in zip(A,B))
# Computation time = 95.353ms
</code></pre>
<h2>Appendix</h2>
<pre class="lang-py prettyprint-override"><code>import time

# to check adjustability
assert time.get_clock_info('time').adjustable
assert time.get_clock_info('perf_counter').adjustable is False
</code></pre>
<h4> Comment 133621899 andres: </h4>You probably want to subscript <code>collections.abc.Iterator</code> directly instead; see <a href="https://docs.python.org/3/library/typing.html#typing.Iterator" rel="nofollow noreferrer">docs.python.org/3/library/typing.html#typing.Iterator</a>. By the way, the minimum needed version to run this isn&#39;t <code>3.10</code> due to typing.<br><h4> Comment 133623171 x0s: </h4>Thanks for your review.  I was confused by the <a href="https://peps.python.org/pep-0604/" rel="nofollow noreferrer">PEP 604</a> enabling <code>Type | None</code> in place of <code>Optional[Type]</code> But this does not apply here. So, you&#39;re right python 3.10 is not required. <a href="https://peps.python.org/pep-0585/" rel="nofollow noreferrer">PEP 585</a> confirms your suggestion, so I&#39;ve updated my answer.<br>------------------------------------------------------------------ <br><h3> Answer 62141170 ruohola: </h3><p>Here's a pretty well documented and fully type hinted decorator I use as a general utility:</p>
<pre><code>from functools import wraps
from time import perf_counter
from typing import Any, Callable, Optional, TypeVar, cast

F = TypeVar(&quot;F&quot;, bound=Callable[..., Any])


def timer(prefix: Optional[str] = None, precision: int = 6) -&gt; Callable[[F], F]:
    &quot;&quot;&quot;Use as a decorator to time the execution of any function.

    Args:
        prefix: String to print before the time taken.
            Default is the name of the function.
        precision: How many decimals to include in the seconds value.

    Examples:
        &gt;&gt;&gt; @timer()
        ... def foo(x):
        ...     return x
        &gt;&gt;&gt; foo(123)
        foo: 0.000...s
        123
        &gt;&gt;&gt; @timer(&quot;Time taken: &quot;, 2)
        ... def foo(x):
        ...     return x
        &gt;&gt;&gt; foo(123)
        Time taken: 0.00s
        123

    &quot;&quot;&quot;
    def decorator(func: F) -&gt; F:
        @wraps(func)
        def wrapper(*args: Any, **kwargs: Any) -&gt; Any:
            nonlocal prefix
            prefix = prefix if prefix is not None else f&quot;{func.__name__}: &quot;
            start = perf_counter()
            result = func(*args, **kwargs)
            end = perf_counter()
            print(f&quot;{prefix}{end - start:.{precision}f}s&quot;)
            return result
        return cast(F, wrapper)
    return decorator
</code></pre>
<p>Example usage:</p>
<pre><code>from timer import timer


@timer(precision=9)
def takes_long(x: int) -&gt; bool:
    return x in (i for i in range(x + 1))


result = takes_long(10**8)
print(result)
</code></pre>
<blockquote>
<p>Output:</p>
<pre class="lang-none prettyprint-override"><code>takes_long: 4.942629056s
True
</code></pre>
</blockquote>
<p>The doctests can be checked with:</p>
<pre><code>$ python3 -m doctest --verbose -o=ELLIPSIS timer.py
</code></pre>
<p>And the type hints with:</p>
<pre><code>$ mypy timer.py
</code></pre>
<h4> Comment 109956614 Danny: </h4>This is super cool, thank you for sharing. I have not encountered the typing library or the nonlocal keyword -- fun to find new things to learn about. I&#39;m having trouble wrapping my head around this: <code>Callable[[AnyF], AnyF]</code>. What does it mean?<br><h4> Comment 109959564 ruohola: </h4>@Danny On the top I&#39;ve defined the type alias <code>AnyF</code> to mean <code>Callable[..., Any]</code>, so <code>AnyF</code> is a function that can take any amount of any type arguments and return anything. So <code>Callable[[AnyF], AnyF]</code> would expand to <code>Callable[[Callable[..., Any]], Callable[..., Any]]</code>. This is the type of the return value of <code>timer</code> aka the full type of <code>decorator</code>. It is a function that takes any kind of function as its only argument and returns any kind of function.<br><h4> Comment 109962600 Danny: </h4>Thanks for the explanation! I&#39;m still trying to fully wrap my head around the internals of decorators. This helped a lot!<br>------------------------------------------------------------------ <br><h3> Answer 45675005 Andreas Herman: </h3><p>Kind of a super later response, but maybe it serves a purpose for someone. This is a way to do it which I think is super clean.</p>

<pre><code>import time

def timed(fun, *args):
    s = time.time()
    r = fun(*args)
    print('{} execution took {} seconds.'.format(fun.__name__, time.time()-s))
    return(r)

timed(print, "Hello")
</code></pre>

<p>Keep in mind that "print" is a function in Python 3 and not Python 2.7. However, it works with any other function. Cheers!</p>
<h4> Comment 92395603 Daniel Moskovich: </h4>You can turn this into a decorator; this looks even better to me.<br><h4> Comment 81970748 Otieno Rowland: </h4>How can I print very small times? I kind of am getting 0.0sec always<br>------------------------------------------------------------------ <br><h3> Answer 44636960 Vlad Bezden: </h3><p>You can use timeit.</p>

<p>Here is an example on how to test naive_func that takes parameter using Python REPL:</p>

<pre><code>&gt;&gt;&gt; import timeit                                                                                         

&gt;&gt;&gt; def naive_func(x):                                                                                    
...     a = 0                                                                                             
...     for i in range(a):                                                                                
...         a += i                                                                                        
...     return a                                                                                          

&gt;&gt;&gt; def wrapper(func, *args, **kwargs):                                                                   
...     def wrapper():                                                                                    
...         return func(*args, **kwargs)                                                                  
...     return wrapper                                                                                    

&gt;&gt;&gt; wrapped = wrapper(naive_func, 1_000)                                                                  

&gt;&gt;&gt; timeit.timeit(wrapped, number=1_000_000)                                                              
0.4458435332577161  
</code></pre>

<p>You don't need wrapper function if function doesn't have any parameters.                                                                                      </p>
<h4> Comment 91272233 Ciro Santilli OurBigBook.com: </h4>A <code>lambda</code> would be more succinct: <code>print(timeit.timeit(lambda: naive_func(1_000), number=1_000_000))</code><br>------------------------------------------------------------------ <br><h3> Answer 64440741 Myeongsik Joo: </h3><p>print_elapsed_time function is below</p>
<pre><code>def print_elapsed_time(prefix=''):
    e_time = time.time()
    if not hasattr(print_elapsed_time, 's_time'):
        print_elapsed_time.s_time = e_time
    else:
        print(f'{prefix} elapsed time: {e_time - print_elapsed_time.s_time:.2f} sec')
        print_elapsed_time.s_time = e_time
</code></pre>
<p>use it in this way</p>
<pre><code>print_elapsed_time()
.... heavy jobs ...
print_elapsed_time('after heavy jobs')
.... tons of jobs ...
print_elapsed_time('after tons of jobs')
</code></pre>
<p>result is</p>
<pre><code>after heavy jobs elapsed time: 0.39 sec
after tons of jobs elapsed time: 0.60 sec  
</code></pre>
<p>the pros and cons of this function is that you don't need to pass start time</p>
------------------------------------------------------------------ <br><h3> Answer 39549755 Kamlesh Verma: </h3><p>We can also convert time into human-readable time.</p>

<pre><code>import time, datetime

start = time.clock()

def num_multi1(max):
    result = 0
    for num in range(0, 1000):
        if (num % 3 == 0 or num % 5 == 0):
            result += num

    print "Sum is %d " % result

num_multi1(1000)

end = time.clock()
value = end - start
timestamp = datetime.datetime.fromtimestamp(value)
print timestamp.strftime('%Y-%m-%d %H:%M:%S')
</code></pre>
------------------------------------------------------------------ <br><h3> Answer 66152141 Lee Netherton: </h3><p>Although it's not strictly asked in the question, it is quite often the case that you want a simple, uniform way to incrementally measure the elapsed time between several lines of code.</p>
<p>If you are using Python 3.8 or above, you can make use of <a href="https://www.python.org/dev/peps/pep-0572/" rel="noreferrer">assignment expressions</a> (a.k.a. the walrus operator) to achieve this in a fairly elegant way:</p>
<pre><code>import time

start, times = time.perf_counter(), {}

print(&quot;hello&quot;)
times[&quot;print&quot;] = -start + (start := time.perf_counter())

time.sleep(1.42)
times[&quot;sleep&quot;] = -start + (start := time.perf_counter())

a = [n**2 for n in range(10000)]
times[&quot;pow&quot;] = -start + (start := time.perf_counter())

print(times)
</code></pre>
<p>=&gt;</p>
<pre><code>{'print': 2.193450927734375e-05, 'sleep': 1.4210970401763916, 'power': 0.005671024322509766}
</code></pre>
------------------------------------------------------------------ <br><h3> Answer 30035725 Karl: </h3><p>I made a library for this, if you want to measure a function you can just do it like this </p>

<pre><code>
from pythonbenchmark import compare, measure
import time

a,b,c,d,e = 10,10,10,10,10
something = [a,b,c,d,e]

@measure
def myFunction(something):
    time.sleep(0.4)

@measure
def myOptimizedFunction(something):
    time.sleep(0.2)

myFunction(input)
myOptimizedFunction(input)
</code></pre>

<p><a href="https://github.com/Karlheinzniebuhr/pythonbenchmark" rel="noreferrer">https://github.com/Karlheinzniebuhr/pythonbenchmark</a> </p>
------------------------------------------------------------------ <br><h3> Answer 57931660 Asclepius: </h3><p>This unique class-based approach offers a printable string representation, customizable rounding, and convenient access to the elapsed time as a string or a float. It was developed with Python 3.7.</p>

<pre class="lang-py prettyprint-override"><code>import datetime
import timeit


class Timer:
    """Measure time used."""
    # Ref: https://stackoverflow.com/a/57931660/

    def __init__(self, round_ndigits: int = 0):
        self._round_ndigits = round_ndigits
        self._start_time = timeit.default_timer()

    def __call__(self) -&gt; float:
        return timeit.default_timer() - self._start_time

    def __str__(self) -&gt; str:
        return str(datetime.timedelta(seconds=round(self(), self._round_ndigits)))
</code></pre>

<p>Usage:</p>

<pre class="lang-py prettyprint-override"><code># Setup timer
&gt;&gt;&gt; timer = Timer()

# Access as a string
&gt;&gt;&gt; print(f'Time elapsed is {timer}.')
Time elapsed is 0:00:03.
&gt;&gt;&gt; print(f'Time elapsed is {timer}.')
Time elapsed is 0:00:04.

# Access as a float
&gt;&gt;&gt; timer()
6.841332235
&gt;&gt;&gt; timer()
7.970274425
</code></pre>
<h4> Comment 123340732 Dan Nissenbaum: </h4>This is simple and excellent - easy to code; I&#39;m surprised that (a) this kind of functionality isn&#39;t present in ANY of the existing Python profilers; and (b) that this answer, including a simple class that can be copied-and-pasted, wasn&#39;t offered to this question years ago with many more upvotes.<br>------------------------------------------------------------------ <br><h3> Answer 66730164 ingyhere: </h3><p>As a lambda, obtain time elapsed and time stamps:</p>
<pre><code>import datetime
t_set = lambda: datetime.datetime.now().astimezone().replace(microsecond=0)
t_diff = lambda t: str(t_set() - t)
t_stamp = lambda t=None: str(t) if t else str(t_set())
</code></pre>
<p>In practice:</p>
<pre><code>&gt;&gt;&gt; 
&gt;&gt;&gt; t_set()
datetime.datetime(2021, 3, 21, 1, 25, 17, tzinfo=datetime.timezone(datetime.timedelta(days=-1, seconds=61200), 'PDT'))
&gt;&gt;&gt; t = t_set()
&gt;&gt;&gt; t_diff(t)
'0:00:14'
&gt;&gt;&gt; t_diff(t)
'0:00:23'
&gt;&gt;&gt; t_stamp()
'2021-03-21 01:25:57-07:00'
&gt;&gt;&gt; t_stamp(t)
'2021-03-21 01:25:22-07:00'
&gt;&gt;&gt; 
</code></pre>
<h4> Comment 122749038 MEMark: </h4>I can&#39;t get this to work. <code>unsupported operand type(s) for -: &#39;datetime.datetime&#39; and &#39;function&#39;</code><br><h4> Comment 122758284 ingyhere: </h4>@MEMark Uncertainty here without seeing the code, but note that this was made for Python 3. The error means a the wrong datatype is being used in place of a <code>datetime</code> object. Could the code be trying <code>t_diff(t_diff())</code> or <code>t_diff(t())</code> instead of <code>t_diff(t)</code> (where <code>t</code> is a scalar set earlier as <code>t = t_set()</code>)?<br>------------------------------------------------------------------ <br><h3> Answer 58910352 Sky: </h3><pre><code>import time

def getElapsedTime(startTime, units):
    elapsedInSeconds = time.time() - startTime
    if units == 'sec':
        return elapsedInSeconds
    if units == 'min':
        return elapsedInSeconds/60
    if units == 'hour':
        return elapsedInSeconds/(60*60)
</code></pre>
<h4> Comment 110468298 user1318499: </h4>Don&#39;t do this because <code>time.time()</code> doesn&#39;t necessarily increment uniformly. You can get a negative duration if there&#39;s a daylight savings adjustment or whatever. Replace <code>time.time()</code> with <code>time.monotonic()</code>.<br>------------------------------------------------------------------ <br><h3> Answer 61426352 Aditya Patnaik: </h3><h1>Measure execution time of small code snippets.</h1>

<blockquote>
  <p><strong>Unit of time</strong>: <em>measured in seconds as a float</em></p>
</blockquote>

<pre><code>import timeit
t = timeit.Timer('li = list(map(lambda x:x*2,[1,2,3,4,5]))')
t.timeit()
t.repeat()
&gt;[1.2934070999999676, 1.3335035000000062, 1.422568500000125]
</code></pre>

<blockquote>
  <p>The repeat() method is a convenience to call timeit() multiple times and return a list of results.</p>

<pre><code>repeat(repeat=3)¶
</code></pre>
  
  <p>With this list we can take a mean of all times.</p>
  
  <p>By default, timeit() temporarily turns off garbage collection during the timing. time.Timer() solves this problem.</p>
  
  <h2><strong>Pros:</strong></h2>
  
  <blockquote>
    <p>timeit.Timer() makes independent timings more comparable. The gc may be an important component of the performance of the function being measured. If so, gc(garbage collector) can be re-enabled as the first statement in the setup string. For example:</p>
  </blockquote>

<pre><code>timeit.Timer('li = list(map(lambda x:x*2,[1,2,3,4,5]))',setup='gc.enable()')
</code></pre>
</blockquote>

<p>Source <a href="https://docs.python.org/3/library/timeit.html" rel="nofollow noreferrer" title="In the docs,Scroll down a bit to find time.Timer() class">Python Docs</a>!</p>
------------------------------------------------------------------ <br><h3> Answer 61613140 Xiang ZHU: </h3><p>based on the contextmanager solution given by <a href="https://stackoverflow.com/a/30024601/5095636">https://stackoverflow.com/a/30024601/5095636</a>, hereunder the lambda free version, as flake8 warns on the usage of lambda as per <a href="https://www.flake8rules.com/rules/E731.html" rel="nofollow noreferrer">E731</a>:</p>

<pre class="lang-py prettyprint-override"><code>from contextlib import contextmanager
from timeit import default_timer

@contextmanager
def elapsed_timer():
    start_time = default_timer()

    class _Timer():
      start = start_time
      end = default_timer()
      duration = end - start

    yield _Timer

    end_time = default_timer()
    _Timer.end = end_time
    _Timer.duration = end_time - start_time
</code></pre>

<p>test:</p>

<pre class="lang-py prettyprint-override"><code>from time import sleep

with elapsed_timer() as t:
    print("start:", t.start)
    sleep(1)
    print("end:", t.end)

t.start
t.end
t.duration
</code></pre>
------------------------------------------------------------------ <br><h3> Answer 71723858 N3RDIUM: </h3><h1>For Python 3</h1>
<p>If you use the <code>time</code> module, you can get the current timestamp, and then execute your code, and get the timestamp again. Now, the time taken will be the first timestamp minus the second timestamp:</p>
<pre><code>import time

first_stamp = int(round(time.time() * 1000))

# YOUR CODE GOES HERE
time.sleep(5)

second_stamp = int(round(time.time() * 1000))

# Calculate the time taken in milliseconds
time_taken = second_stamp - first_stamp

# To get time in seconds:
time_taken_seconds = round(time_taken / 1000)
print(f'{time_taken_seconds} seconds or {time_taken} milliseconds')
</code></pre>
------------------------------------------------------------------ <br><h3> Answer 72748433 STerliakov: </h3><p>I'm pretty late to the party, but this approach was not covered before. When we want to benchmark manually some piece of code, we may want to find out first which of class methods eats the execution time, and this is sometimes not obvious. I have built the following metaclass to solve exactly this problem:</p>
<pre class="lang-py prettyprint-override"><code>from __future__ import annotations

from functools import wraps
from time import time
from typing import Any, Callable, TypeVar, cast

F = TypeVar('F', bound=Callable[..., Any])


def timed_method(func: F, prefix: str | None = None) -&gt; F:
    prefix = (prefix + ' ') if prefix else ''

    @wraps(func)
    def inner(*args, **kwargs):  # type: ignore
        start = time()
        try:
            ret = func(*args, **kwargs)
        except BaseException:
            print(f'[ERROR] {prefix}{func.__qualname__}: {time() - start}')
            raise
        
        print(f'{prefix}{func.__qualname__}: {time() - start}')
        return ret

    return cast(F, inner)


class TimedClass(type):
    def __new__(
        cls: type[TimedClass],
        name: str,
        bases: tuple[type[type], ...],
        attrs: dict[str, Any],
        **kwargs: Any,
    ) -&gt; TimedClass:
        for name, attr in attrs.items():
            if isinstance(attr, (classmethod, staticmethod)):
                attrs[name] = type(attr)(timed_method(attr.__func__))
            elif isinstance(attr, property):
                attrs[name] = property(
                    timed_method(attr.fget, 'get') if attr.fget is not None else None,
                    timed_method(attr.fset, 'set') if attr.fset is not None else None,
                    timed_method(attr.fdel, 'del') if attr.fdel is not None else None,
                )
            elif callable(attr):
                attrs[name] = timed_method(attr)

        return super().__new__(cls, name, bases, attrs)
</code></pre>
<p>It allows usage like the following:</p>
<pre class="lang-py prettyprint-override"><code>class MyClass(metaclass=TimedClass):
    def foo(self): 
        print('foo')
    
    @classmethod
    def bar(cls): 
        print('bar')
    
    @staticmethod
    def baz(): 
        print('baz')
    
    @property
    def prop(self): 
        print('prop')
    
    @prop.setter
    def prop(self, v): 
        print('fset')
    
    @prop.deleter
    def prop(self): 
        print('fdel')


c = MyClass()

c.foo()
c.bar()
c.baz()
c.prop
c.prop = 2
del c.prop

MyClass.bar()
MyClass.baz()
</code></pre>
<p>It prints:</p>
<pre class="lang-none prettyprint-override"><code>foo
MyClass.foo: 1.621246337890625e-05
bar
MyClass.bar: 4.5299530029296875e-06
baz
MyClass.baz: 4.291534423828125e-06
prop
get MyClass.prop: 3.814697265625e-06
fset
set MyClass.prop: 3.5762786865234375e-06
fdel
del MyClass.prop: 3.5762786865234375e-06
bar
MyClass.bar: 3.814697265625e-06
baz
MyClass.baz: 4.0531158447265625e-06
</code></pre>
<p>It can be combined with other answers to replace <code>time.time</code> with something more precise.</p>
------------------------------------------------------------------ <br><h3> Answer 58924448 alshaboti: </h3><p>The <code>timeit</code> module is good for timing a small piece of Python code. It can be used at least in three forms: </p>

<p>1- As a command-line module</p>

<pre><code>python2 -m timeit 'for i in xrange(10): oct(i)' 
</code></pre>

<p>2- For a short code, pass it as arguments.</p>

<pre><code>import timeit
timeit.Timer('for i in xrange(10): oct(i)').timeit()
</code></pre>

<p>3- For longer code as:</p>

<pre><code>import timeit
code_to_test = """
a = range(100000)
b = []
for i in a:
    b.append(i*2)
"""
elapsed_time = timeit.timeit(code_to_test, number=100)/100
print(elapsed_time)
</code></pre>
<h4> Comment 131664411 Cris Luengo: </h4>You can also pass a lambda, which is a better way of timing.<br>------------------------------------------------------------------ <br><h3> Answer 60407865 Punit Vara: </h3><p>Time can also be measured by %timeit magic function as follow:</p>

<pre><code>%timeit -t -n 1 print("hello")
</code></pre>

<p><code>n 1</code> is for running function only 1 time.</p>
------------------------------------------------------------------ <br><h3> Answer 71779784 Michael Litvin: </h3><p>You can use <a href="https://github.com/michaelitvin/benchmark-timer" rel="nofollow noreferrer">Benchmark Timer</a> (disclaimer: I'm the author):</p>
<blockquote>
<h1>Benchmark Timer</h1>
<p>Use the <code>BenchmarkTimer</code> class to measure the time it takes to execute some piece of code. <br />
This gives more flexibility than the built-in timeit function, and runs in the same scope as the rest of your code.</p>
<h2>Installation</h2>
<pre><code>pip install git+https://github.com/michaelitvin/benchmark-timer.git@main#egg=benchmark-timer
</code></pre>
<h2>Usage</h2>
<h3>Single iteration example</h3>
<pre class="lang-py prettyprint-override"><code>from benchmark_timer import BenchmarkTimer
import time

with BenchmarkTimer(name=&quot;MySimpleCode&quot;) as tm, tm.single_iteration():
    time.sleep(.3)
</code></pre>
<p>Output:</p>
<pre><code>Benchmarking MySimpleCode...
MySimpleCode benchmark: n_iters=1 avg=0.300881s std=0.000000s range=[0.300881s~0.300881s]
</code></pre>
<h3>Multiple iterations example</h3>
<pre class="lang-py prettyprint-override"><code>from benchmark_timer import BenchmarkTimer
import time

with BenchmarkTimer(name=&quot;MyTimedCode&quot;, print_iters=True) as tm:
    for timing_iteration in tm.iterations(n=5, warmup=2):
        with timing_iteration:
            time.sleep(.1)

print(&quot;\n===================\n&quot;)
print(&quot;List of timings: &quot;, list(tm.timings.values()))
</code></pre>
<p>Output:</p>
<pre><code>Benchmarking MyTimedCode...
[MyTimedCode] iter=0 took 0.099755s (warmup)
[MyTimedCode] iter=1 took 0.100476s (warmup)
[MyTimedCode] iter=2 took 0.100189s 
[MyTimedCode] iter=3 took 0.099900s 
[MyTimedCode] iter=4 took 0.100888s 
MyTimedCode benchmark: n_iters=3 avg=0.100326s std=0.000414s range=[0.099900s~0.100888s]

===================

List of timings:  [0.10018850000000001, 0.09990049999999995, 0.10088760000000008]
</code></pre>
</blockquote>
------------------------------------------------------------------ <br><h3> Answer 53522888 vishes_shell: </h3><p>In addition to <code>%timeit</code> in <em>ipython</em> you can also use <strong><code>%%timeit</code></strong> for multi-line code snippets:</p>

<pre><code>In [1]: %%timeit
   ...: complex_func()
   ...: 2 + 2 == 5
   ...:
   ...:

1 s ± 1.93 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)
</code></pre>

<p>Also it can be used in <strong>jupyter notebook</strong> the same way, just put <a href="https://ipython.readthedocs.io/en/stable/interactive/magics.html#magic-timeit" rel="nofollow noreferrer">magic <code>%%timeit</code></a> at the beginning of cell.</p>
