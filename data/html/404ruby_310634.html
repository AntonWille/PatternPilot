 <h2> Title: What is the &quot;right&quot; way to iterate through an array in Ruby? </h2> <h4> Tom Lehman, question_id: 310634 </h4>Score: 404, Tags: {ruby,arrays,loops} <br><p>PHP, for all its warts, is pretty good on this count. There's no difference between an array and a hash (maybe I'm naive, but this seems obviously right to me), and to iterate through either you just do</p>

<pre><code>foreach (array/hash as $key =&gt; $value)
</code></pre>

<p>In Ruby there are a bunch of ways to do this sort of thing:</p>

<pre><code>array.length.times do |i|
end

array.each

array.each_index

for i in array
</code></pre>

<p>Hashes make more sense, since I just always use</p>

<pre><code>hash.each do |key, value|
</code></pre>

<p>Why can't I do this for arrays? If I want to remember just one method, I guess I can use <code>each_index</code> (since it makes both the index and value available), but it's annoying to have to do <code>array[index]</code> instead of just <code>value</code>.</p>

<hr>

<p>Oh right, I forgot about <code>array.each_with_index</code>. However, this one sucks because it goes <code>|value, key|</code> and <code>hash.each</code> goes <code>|key, value|</code>! Is this not insane?</p>
<h4> Matthew Carriere, Id: 44265774 Score: 3: </h4>If you are just getting started with loops in Ruby, then check out <a href="http://matthewcarriere.com/2008/06/23/using-select-reject-collect-inject-and-detect/" rel="nofollow noreferrer">using select, reject, collect, inject and detect</a><br><h4> Benjineer, Id: 36227271 Score: 1: </h4>I guess <code>array#each_with_index</code> uses <code>|value, key|</code> because the method name implies the order, whereas the order used for <code>hash#each</code> mimics the <code>hash[key] = value</code> syntax?<br>------------------------------------------------------------------ <br><h3> Robert Gamble, Id: 310638, Score: 640: </h3><p>This will iterate through all the elements:</p>
<pre class="lang-rb prettyprint-override"><code>array = [1, 2, 3, 4, 5, 6]
array.each { |x| puts x }

# Output:

1
2
3
4
5
6
</code></pre>
<p>This will iterate through all the elements giving you the value and the index:</p>
<pre class="lang-rb prettyprint-override"><code>array = [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;]
array.each_with_index {|val, index| puts &quot;#{val} =&gt; #{index}&quot; }

# Output:

A =&gt; 0
B =&gt; 1
C =&gt; 2
</code></pre>
<p>I'm not quite sure from your question which one you are looking for.</p>
<h4> Chris, Comment 128279296 Score: 1: </h4>As of Ruby 2.7, also <code>array.each { puts _1 }</code><br>------------------------------------------------------------------ <br><h3> AShelly, Id: 310661, Score: 118: </h3><p>I think there is no one <em>right</em> way.  There are a lot of different ways to iterate, and each has its own niche.</p>

<ul>
<li><code>each</code> is sufficient for many usages, since I don't often care about the indexes.  </li>
<li><code>each_ with _index</code> acts like Hash#each - you get the value and the index.</li>
<li><code>each_index</code> - just the indexes.  I don't use this one often. Equivalent to "length.times".</li>
<li><code>map</code> is another way to iterate, useful when you want to transform one array into another.</li>
<li><code>select</code> is the iterator to use when you want to choose a subset.</li>
<li><code>inject</code> is useful for generating sums or products, or collecting a single result. </li>
</ul>

<p>It may seem like a lot to remember, but don't worry, you can get by without knowing all of them.  But as you start to learn and use the different methods, your code will become cleaner and clearer, and you'll be on your way to Ruby mastery.</p>
<h4> Sandra Cieseck, Comment 105513608 Score: 0: </h4>great answer! I&#39;d like to mention the reverse like #reject and aliases like #collect.<br>------------------------------------------------------------------ <br><h3> Luis Esteban, Id: 691798, Score: 64: </h3><p>I'm not saying that <code>Array</code> -> <code>|value,index|</code> and <code>Hash</code> -> <code>|key,value|</code> is not insane (see Horace Loeb's comment), but I am saying that there is a sane way to expect this arrangement.</p>

<p>When I am dealing with arrays, I am focused on the elements in the array (not the index because the index is transitory).  The method is each with index, i.e. each+index, or |each,index|, or <code>|value,index|</code>.  This is also consistent with the index being viewed as an optional argument, e.g. |value| is equivalent to |value,index=nil| which is consistent with |value,index|.</p>

<p>When I am dealing with hashes, I am often more focused on the keys than the values, and I am usually dealing with keys and values in that order, either <code>key =&gt; value</code> or <code>hash[key] = value</code>.</p>

<p>If you want duck-typing, then either explicitly use a defined method as Brent Longborough showed, or an implicit method as maxhawkins showed.</p>

<p>Ruby is all about accommodating the language to suit the programmer, not about the programmer accommodating to suit the language.  This is why there are so many ways.  There are so many ways to think about something.  In Ruby, you choose the closest and the rest of the code usually falls out extremely neatly and concisely.</p>

<p>As for the original question, "What is the “right” way to iterate through an array in Ruby?", well, I think the core way (i.e. without powerful syntactic sugar or object oriented power) is to do:</p>

<pre><code>for index in 0 ... array.size
  puts "array[#{index}] = #{array[index].inspect}"
end
</code></pre>

<p>But Ruby is all about powerful syntactic sugar and object oriented power, but anyway here is the equivalent for hashes, and the keys can be ordered or not:</p>

<pre><code>for key in hash.keys.sort
  puts "hash[#{key.inspect}] = #{hash[key].inspect}"
end
</code></pre>

<p>So, my answer is, "The “right” way to iterate through an array in Ruby depends on you (i.e. the programmer or the programming team) and the project.".  The better Ruby programmer makes the better choice (of which syntactic power and/or which object oriented approach).  The better Ruby programmer continues to look for more ways.</p>

<hr>

<p>Now, I want to ask another question, "What is the “right” way to iterate through a Range in Ruby backwards?"!  (This question is how I came to this page.)</p>

<p>It is nice to do (for the forwards):</p>

<pre><code>(1..10).each{|i| puts "i=#{i}" }
</code></pre>

<p>but I don't like to do (for the backwards):</p>

<pre><code>(1..10).to_a.reverse.each{|i| puts "i=#{i}" }
</code></pre>

<p>Well, I don't actually mind doing that too much, but when I am teaching going backwards, I want to show my students a nice symmetry (i.e. with minimal difference, e.g. only adding a reverse, or a step -1, but without modifying anything else).
You can do (for symmetry):</p>

<pre><code>(a=*1..10).each{|i| puts "i=#{i}" }
</code></pre>

<p>and</p>

<pre><code>(a=*1..10).reverse.each{|i| puts "i=#{i}" }
</code></pre>

<p>which I don't like much, but you can't do</p>

<pre><code>(*1..10).each{|i| puts "i=#{i}" }
(*1..10).reverse.each{|i| puts "i=#{i}" }
#
(1..10).step(1){|i| puts "i=#{i}" }
(1..10).step(-1){|i| puts "i=#{i}" }
#
(1..10).each{|i| puts "i=#{i}" }
(10..1).each{|i| puts "i=#{i}" }   # I don't want this though.  It's dangerous
</code></pre>

<p>You could ultimately do</p>

<pre><code>class Range

  def each_reverse(&amp;block)
    self.to_a.reverse.each(&amp;block)
  end

end
</code></pre>

<p>but I want to teach pure Ruby rather than object oriented approaches (just yet).  I would like to iterate backwards:</p>

<ul>
<li>without creating an array (consider 0..1000000000)</li>
<li>working for any Range (e.g. Strings, not just Integers)</li>
<li>without using any extra object oriented power (i.e. no class modification)</li>
</ul>

<p>I believe this is impossible without defining a <code>pred</code> method, which means modifying the Range class to use it.  If you can do this please let me know, otherwise confirmation of impossibility would be appreciated though it would be disappointing.  Perhaps Ruby 1.9 addresses this.</p>

<p>(Thanks for your time in reading this.)</p>
<h4> Suren, Comment 13483040 Score: 5: </h4><code>1.upto(10) do |i| puts i end</code> and <code>10.downto(1) do puts i end</code> kind of gives the symmetry you wanted. Hope that helps. Not sure if it would work for strings and such.<br><h4> Hauleth, Comment 45314032 Score: 0: </h4>You can <code>[*1..10].each{|i| puts &quot;i=#{i}&quot; }</code>.<br><h4> Davidslv, Comment 19165192 Score: 0: </h4>(1..10).to_a.sort{ |x,y| y &lt;=&gt; x }.each{|i| puts &quot;i=#{i}&quot; } - reverse is more slow.<br>------------------------------------------------------------------ <br><h3> J Cooper, Id: 310644, Score: 20: </h3><p>Use each_with_index when you need both.</p>

<pre><code>ary.each_with_index { |val, idx| # ...
</code></pre>
------------------------------------------------------------------ <br><h3> Pistos, Id: 312676, Score: 12: </h3><p>The other answers are just fine, but I wanted to point out one other peripheral thing: Arrays are ordered, whereas Hashes are not in 1.8.  (In Ruby 1.9, Hashes are ordered by insertion order of keys.)  So it wouldn't make sense prior to 1.9 to iterate over a Hash in the same way/sequence as Arrays, which have always had a definite ordering.  I don't know what the default order is for PHP associative arrays (apparently my google fu isn't strong enough to figure that out, either), but I don't know how you can consider regular PHP arrays and PHP associative arrays to be "the same" in this context, since the order for associative arrays seems undefined.</p>

<p>As such, the Ruby way seems more clear and intuitive to me.  :)</p>
<h4> Tom Lehman, Comment 155436 Score: 2: </h4>hashes and arrays are the same thing! arrays map integers to objects and hashes map objects to objects. arrays are just special cases of hashes, no?<br><h4> Pistos, Comment 155748 Score: 1: </h4>Like I said, an array is an ordered set.  A mapping (in the generic sense) is unordered.  If you restrict the key set to integers (such as with arrays), it just so happens that the key set has an order.  In a generic mapping (Hash / Associative Array), the keys may not have an order.<br><h4> Zane, Comment 34478015 Score: 0: </h4>@Horace: Hashes and arrays are not the same. If one is a special acase of the other, they cannot be the same. But even worse, arrays are not a special kind of hashes, that&#39;s only an abstract way of viewing them. As Brent above pointed out, using hashes and arrays interchangeably might indicate a code smell.<br>------------------------------------------------------------------ <br><h3> Jake, Id: 32145814, Score: 11: </h3><p>Here are the four options listed in your question, arranged by freedom of control. You might want to use a different one depending on what you need.</p>

<ol>
<li><p>Simply go through values:</p>

<pre><code>array.each
</code></pre></li>
<li><p>Simply go through indices:</p>

<pre><code>array.each_index
</code></pre></li>
<li><p>Go through indices + index variable:</p>

<pre><code>for i in array
</code></pre></li>
<li><p>Control loop count + index variable:</p>

<pre><code>array.length.times do | i |
</code></pre></li>
</ol>
------------------------------------------------------------------ <br><h3> Brent.Longborough, Id: 311364, Score: 9: </h3><p>Trying to do the same thing consistently with arrays and hashes <em>might</em> just be a code smell, but, at the risk of my being branded as a codorous half-monkey-patcher, if you're looking for consistent behaviour, would this do the trick?:</p>

<pre><code>class Hash
    def each_pairwise
        self.each { | x, y |
            yield [x, y]
        }
    end
end

class Array
    def each_pairwise
        self.each_with_index { | x, y |
            yield [y, x]
        }
    end
end

["a","b","c"].each_pairwise { |x,y|
    puts "#{x} =&gt; #{y}"
}

{"a" =&gt; "Aardvark","b" =&gt; "Bogle","c" =&gt; "Catastrophe"}.each_pairwise { |x,y|
    puts "#{x} =&gt; #{y}"
}
</code></pre>
------------------------------------------------------------------ <br><h3> Dave Everitt, Id: 995448, Score: 5: </h3><p>I'd been trying to build a menu (in <em>Camping</em> and <em>Markaby</em>) using a hash.</p>

<p>Each item has 2 elements: a <strong>menu label</strong> and a <strong>URL</strong>, so a hash seemed right, but the '/' URL for 'Home' always appeared last (as you'd expect for a hash), so menu items appeared in the wrong order.</p>

<p>Using an array with <code>each_slice</code> does the job:</p>

<pre><code>['Home', '/', 'Page two', 'two', 'Test', 'test'].each_slice(2) do|label,link|
   li {a label, :href =&gt; link}
end
</code></pre>

<p>Adding extra values for each menu item (e.g. like a CSS <em>ID</em> name) just means increasing the slice value. So, like a hash but with groups consisting of any number of items. Perfect.</p>

<p>So this is just to say thanks for inadvertently hinting at a solution!</p>

<p>Obvious, but worth stating: I suggest checking if the length of the array is divisible by the slice value.</p>
------------------------------------------------------------------ <br><h3> maxhawkins, Id: 438041, Score: 4: </h3><p>If you use the <a href="http://www.ruby-doc.org/core/classes/Enumerable.html" rel="nofollow noreferrer">enumerable</a> mixin (as Rails does) you can do something similar to the php snippet listed. Just use the each_slice method and flatten the hash.</p>

<pre><code>require 'enumerator' 

['a',1,'b',2].to_a.flatten.each_slice(2) {|x,y| puts "#{x} =&gt; #{y}" }

# is equivalent to...

{'a'=&gt;1,'b'=&gt;2}.to_a.flatten.each_slice(2) {|x,y| puts "#{x} =&gt; #{y}" }
</code></pre>

<p>Less monkey-patching required.</p>

<p>However, this does cause problems when you have a recursive array or a hash with array values. In ruby 1.9 this problem is solved with a parameter to the flatten method that specifies how deep to recurse.</p>

<pre><code># Ruby 1.8
[1,2,[1,2,3]].flatten
=&gt; [1,2,1,2,3]

# Ruby 1.9
[1,2,[1,2,3]].flatten(0)
=&gt; [1,2,[1,2,3]]
</code></pre>

<p>As for the question of whether this is a code smell, I'm not sure. Usually when I have to bend over backwards to iterate over something I step back and realize I'm attacking the problem wrong.</p>
------------------------------------------------------------------ <br><h3> Amjed Shareef, Id: 26099644, Score: 3: </h3><p>In Ruby 2.1, each_with_index method is removed.
Instead you can use <a href="http://www.ruby-doc.org/core-2.1.3/Array.html#method-i-each_index" rel="nofollow">each_index</a></p>

<p>Example:</p>

<pre><code>a = [ "a", "b", "c" ]
a.each_index {|x| print x, " -- " }
</code></pre>

<p>produces:</p>

<pre><code>0 -- 1 -- 2 --
</code></pre>
<h4> ihaztehcodez, Comment 44617118 Score: 4: </h4>This is not true.  As stated in the comments of the accepted answer, the reason <code>each_with_index</code> does not appear in the documentation is because it is provided by the <code>Enumerable</code> module.<br>------------------------------------------------------------------ <br><h3> Dariusz G. Jagielski, Id: 21026363, Score: 2: </h3><p>The right way is the one you feel most comfortable with and which does what you want it to do. In programming there is rarely one 'correct' way to do things, more often there are multiple ways to choose. </p>

<p>If you are comfortable with certain way of doings things, do just it, unless it doesn't work - then it is time to find better way.</p>
------------------------------------------------------------------ <br><h3> tanius, Id: 61429880, Score: 2: </h3><p>Using the same method for iterating through both arrays and hashes makes sense, for example to process nested hash-and-array structures often resulting from parsers, from reading JSON files etc..</p>

<p>One clever way that has not yet been mentioned is how it's done in the <a href="http://rubyworks.github.io/facets/" rel="nofollow noreferrer">Ruby Facets</a> library of standard library extensions. From <a href="https://github.com/rubyworks/facets/blob/master/lib/core/facets/array/each_pair.rb" rel="nofollow noreferrer">here</a>:</p>

<pre><code>class Array

  # Iterate over index and value. The intention of this
  # method is to provide polymorphism with Hash.
  #
  def each_pair #:yield:
    each_with_index {|e, i| yield(i,e) }
  end

end
</code></pre>

<p>There is already <a href="https://ruby-doc.org/core-2.7.1/Hash.html#method-i-each" rel="nofollow noreferrer"><code>Hash#each_pair</code></a>, an alias of <code>Hash#each</code>. So after this patch, we also have <code>Array#each_pair</code> and can use it interchangeably to iterate through both Hashes and Arrays. This fixes the OP's observed insanity that <code>Array#each_with_index</code> has the block arguments reversed compared to <code>Hash#each</code>. Example usage:</p>

<pre><code>my_array = ['Hello', 'World', '!']
my_array.each_pair { |key, value| pp "#{key}, #{value}" }

# result: 
"0, Hello"
"1, World"
"2, !"

my_hash = { '0' =&gt; 'Hello', '1' =&gt; 'World', '2' =&gt; '!' }
my_hash.each_pair { |key, value| pp "#{key}, #{value}" }

# result: 
"0, Hello"
"1, World"
"2, !"
</code></pre>
