 <h2> Title: Find everything between two XML tags with RegEx </h2> <h4> Doz, question_id: 13241615, created_at: 2012-11-05 22:44:33+00:00 </h4>Score: 82, Tags: {java,php,regex,xml,perl} <br><p>In <code>RegEx</code>, I want to find the tag and everything between two <code>XML tags</code>, like the following:</p>

<pre><code>&lt;primaryAddress&gt;
    &lt;addressLine&gt;280 Flinders Mall&lt;/addressLine&gt;
    &lt;geoCodeGranularity&gt;PROPERTY&lt;/geoCodeGranularity&gt;
    &lt;latitude&gt;-19.261365&lt;/latitude&gt;
    &lt;longitude&gt;146.815585&lt;/longitude&gt;
    &lt;postcode&gt;4810&lt;/postcode&gt;
    &lt;state&gt;QLD&lt;/state&gt;
    &lt;suburb&gt;Townsville&lt;/suburb&gt;
    &lt;type&gt;PHYSICAL&lt;/type&gt;
&lt;/primaryAddress&gt;
</code></pre>

<p>I want to find the tag and everything between <code>primaryAddress</code>, and erase that. </p>

<p>Everything between the <code>primaryAddress</code> tag is a variable, but I want to remove the entire tag and sub-tags whenever I get <code>primaryAddress</code>.</p>

<p>Anyone have any idea how to do that?</p>
<h4> Comment by Necreaux, Score: 0, Id: 83218165, created_at: 2018-01-05 20:25:19+00:00 </h4>Possible duplicate of <a href="https://stackoverflow.com/questions/1732348/regex-match-open-tags-except-xhtml-self-contained-tags">RegEx match open tags except XHTML self-contained tags</a><hr><h3> ✔️ Answer by Ωmega, Id: 13241658, Score: 155, created_at: 2012-11-05 22:48:55+00:00 </h3><h3>It is not a good idea to use regex for HTML/XML parsing...</h3>
<p>However, if you want to do it anyway, search for regex pattern</p>
<pre><code>&lt;primaryAddress&gt;[\s\S]*?&lt;\/primaryAddress&gt;
</code></pre>
<p>and replace it with empty string...</p>
<h4> Comment by Gianluca Ghettini, Score: 13, Id: 18041365, created_at: 2012-11-05 22:52:03+00:00 </h4>Just for curiosity&#39;s sake: why is not a good idea to use regex for HTML/XML parsing?<h4> Comment by Ωmega, Score: 12, Id: 18041404, created_at: 2012-11-05 22:54:50+00:00 </h4>@G_G &gt;&gt; <a href="http://stackoverflow.com/questions/1732348/regex-match-open-tags-except-xhtml-self-contained-tags/1732454#1732454" title="regex match open tags except xhtml self contained tags">stackoverflow.com/questions/1732348/&hellip;</a><h4> Comment by Seth, Score: 4, Id: 52090048, created_at: 2015-08-19 14:05:54+00:00 </h4>Just in case you don&#39;t recognize it, <code>*?</code> means match everything up to the first occurence of <code>&lt;&#47;primaryAddress&gt;</code> (non-greedy match). This is important if your file has multiple <code>&lt;primaryAddress&gt;</code> elements in it. Thanks, @Ωmega.<h4> Comment by Magnilex, Score: 4, Id: 57627157, created_at: 2016-01-22 13:33:40+00:00 </h4>@Ωmega Agreed that regex and xml are not best friend. However, I just replaced 40-50 tags with an empty line through my IDE (IntelliJ IDEA), in about 5 seconds with help from your answer. In these cases, this regex and xml can be useful.<h4> Comment by Doz, Score: 3, Id: 18043444, created_at: 2012-11-06 01:09:04+00:00 </h4>Omega, I just wanted to get generic information on regex, i only said i use textmate in response to people marking down my question because its a bad idea to use RegEx. I know it is a bad idea but i am using it within a different context.<h4> Comment by Ωmega, Score: 0, Id: 18043540, created_at: 2012-11-06 01:17:05+00:00 </h4>@Doz - So then you got the general information in my answer... Good luck!<h4> Comment by Doz, Score: 0, Id: 18041917, created_at: 2012-11-05 23:23:08+00:00 </h4>Yeah i just want to find using TextMate, im not doing this in code or anything. But the example you gave me doesnt work. There is a space after &lt;primaryAddress&gt; and before &lt;/primaryAdddress&gt;<h4> Comment by Ωmega, Score: 0, Id: 18042709, created_at: 2012-11-06 00:17:16+00:00 </h4>@Doz - I don&#39;t know what syntax uses TextMate. Your question does not mention any specific information and is tagged with regex, so I have posted general regex solution that is working with majority of regex tools and programming languages. If you need further help, I suggest you to post a new question where you will be more specific about your requiremenets...<h4> Comment by Crashalot, Score: 0, Id: 110829810, created_at: 2020-07-01 07:16:46+00:00 </h4>@Seth thanks for the non-greedy match, tip! why use <code>[\s\S]*?</code> instead of <code>.*?</code>?<h4> Comment by Seth, Score: 0, Id: 110881261, created_at: 2020-07-02 16:36:01+00:00 </h4>@Crashalot the dot might not match a newline character. See the regex docs for your platform / language.<h4> Comment by Crashalot, Score: 0, Id: 110896776, created_at: 2020-07-03 07:10:28+00:00 </h4>@Seth thanks for the reply! yes just discovered this. :)<h4> Comment by JMM, Score: 0, Id: 56376848, created_at: 2015-12-16 16:44:36+00:00 </h4>This worked great for me, but in particular, anyone using this needs to be aware that it can&#39;t handle nested tags.  IE, if there was a primaryAddress node as one of the descendents of another primaryAddress node.  So make sure that&#39;s not a possibility in your xml document.<h4> Comment by Dima Naychuk, Score: 0, Id: 78584382, created_at: 2017-08-22 09:11:35+00:00 </h4>Great, this also works in case of new line characters inside of tag body. To catch also parametrized tags, e.g. <code>&lt;primaryAddress isValid=True&gt;</code>, I would suggest small update: <code>&lt;primaryAddress.*?&gt;[\\s\\S]*?&lt;&#47;primaryAddress&gt;</code><h4> Comment by Ωmega, Score: 0, Id: 78639689, created_at: 2017-08-23 13:29:53+00:00 </h4>@DimaNaychuk - In such case use <code>&lt;primaryAddress[^&gt;]*&gt;[\s\S]*?&lt;\&#47;primaryAddress&gt;</code><hr><h3>  Answer by doublesharp, Id: 13241652, Score: 23, created_at: 2012-11-05 22:48:07+00:00 </h3><p>You should be able to match it with: <code>/&lt;primaryAddress&gt;(.+?)&lt;\/primaryAddress&gt;/</code></p>

<p>The content between the tags will be in the matched group.</p>
<h4> Comment by Andrii Karaivanskyi, Score: 0, Id: 85047499, created_at: 2018-02-28 02:38:07+00:00 </h4>Apparently it won&#39;t work even for the example in the question. <code>.+</code> does not match carriage return symbols.<h4> Comment by doublesharp, Score: 0, Id: 85078020, created_at: 2018-02-28 18:51:05+00:00 </h4>You would use a multi-line flag.<hr><h3>  Answer by saman, Id: 53319107, Score: 18, created_at: 2018-11-15 12:03:22+00:00 </h3><p>It is not good to use this method but if you really want to split it with regex
</p>

<pre><code>&lt;primaryAddress.*&gt;((.|\n)*?)&lt;\/primaryAddress&gt;
</code></pre>

<p>
the verified answer returns the tags but this just return the value between tags.</p>
<hr><h3>  Answer by Valen, Id: 26564417, Score: 7, created_at: 2014-10-25 16:04:36+00:00 </h3><p>this can capture most outermost layer pair of tags, even with attribute in side or without end tags</p>

<pre><code>(&lt;!--((?!--&gt;).)*--&gt;|&lt;\w*((?!\/&lt;).)*\/&gt;|&lt;(?&lt;tag&gt;\w+)[^&gt;]*&gt;(?&gt;[^&lt;]|(?R))*&lt;\/\k&lt;tag&gt;\s*&gt;)
</code></pre>

<p>edit: as mentioned in comment above, regex is always not enough to parse xml, trying to modify the regex to fit more situation only makes it longer but still useless</p>
<hr><h3>  Answer by Eugene, Id: 64516670, Score: 1, created_at: 2020-10-24 18:24:27+00:00 </h3><p>In our case, we receive an XML as a <code>String</code> and need to get rid of the values that have some &quot;special&quot; characters, like <code>&amp;&lt;&gt;</code> etc. Basically someone can provide an XML to us in this form:</p>
<pre><code>&lt;notes&gt;
  &lt;note&gt;
     &lt;to&gt;jenice &amp; carl &lt;/to&gt;
     &lt;from&gt;your neighbor &lt;; &lt;/from&gt;
  &lt;/note&gt;
&lt;/notes&gt;
</code></pre>
<p>So I need to find in that <code>String</code> the values  <code>jenice &amp; carl</code> and <code>your neighbor &lt;;</code> and properly escape <code>&amp;</code> and <code>&lt;</code> (otherwise this is an invalid xml if you later pass it to an engine that shall rename unnamed).</p>
<p>Doing this with regex is a rather dumb idea to begin with, but it's cheap and easy. So the brave ones that would like to do the same thing I did, here you go:</p>
<pre><code>    String xml = ...
    Pattern p = Pattern.compile(&quot;&lt;(.+)&gt;(?!\\R&lt;)(.+)&lt;/(\\1)&gt;&quot;);
    Matcher m = p.matcher(xml);
    String result = m.replaceAll(mr -&gt; {
        if (mr.group(2).contains(&quot;&amp;&quot;)) {
            return &quot;&lt;&quot; + m.group(1) + &quot;&gt;&quot; + m.group(2) + &quot;+ some change&quot; + &quot;&lt;/&quot; + m.group(3) + &quot;&gt;&quot;;
        }
        return &quot;&lt;&quot; + m.group(1) + &quot;&gt;&quot; + mr.group(2) + &quot;&lt;/&quot; + m.group(3) + &quot;&gt;&quot;;
    });
</code></pre>
<hr><h3>  Answer by cjbarth, Id: 78002046, Score: 0, created_at: 2024-02-15 15:35:07+00:00 </h3><p>Expanding on this case, you might want to find such a tag that has certain contents. A little tweak can accomplish that would be:</p>
<pre><code>^\s*&lt;primaryAddress&gt;(?:(?!&lt;primaryAddress&gt;).)*?QLD.*?&lt;\/primaryAddress&gt;\r{0,1}\n
</code></pre>
<p>Such a regex would remove all the <code>&lt;primaryAddress&gt;</code> that have <code>QLD</code> in them. You could even expand this to include the opening and closing tag like so:</p>
<pre><code>^\s*&lt;primaryAddress&gt;(?:(?!&lt;primaryAddress&gt;).)*?&lt;state&gt;QLD&lt;\/state&gt;.*?&lt;\/primaryAddress&gt;\r{0,1}\n
</code></pre>
<p>The idea is that you capture the opening tag, then you capture everything that isn't the opening tag, followed by the text you want, followed by everything including the closing tag. This way you'll only ever capture a single tag that contains the text you want.</p>
<p>See <a href="https://regex101.com/r/P9eqon/1" rel="nofollow noreferrer">https://regex101.com/r/P9eqon/1</a></p>
