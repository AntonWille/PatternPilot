 <h2> Title: String compare in Perl with &quot;eq&quot; vs &quot;==&quot; </h2> <h3> hari, question_id: 14046669 </h3>Score: 82, Tags: {string,perl} <br><p>I am (a complete Perl newbie) doing string compare in an <code>if</code> statement:</p>

<p>If I do following:</p>

<pre><code>if ($str1 == "taste" &amp;&amp; $str2 == "waste") { }
</code></pre>

<p>I see the correct result (i.e. if the condition matches, it evaluates the "then" block). But I see these warnings:</p>

<blockquote>
  <p>Argument "taste" isn't numeric in numeric eq (==) at line number x. <br/>
  Argument "waste" isn't numeric in numeric eq (==) at line number x.</p>
</blockquote>

<p>But if I do:</p>

<pre><code>if ($str1 eq "taste" &amp;&amp; $str2 eq "waste") { }
</code></pre>

<p>Even if the if condition is satisfied, it doesn't evaluate the "then" block.</p>

<p>Here, <code>$str1</code> is <code>taste</code> and <code>$str2</code> is <code>waste</code>.</p>

<p>How should I fix this?</p>
<h4> Comment 19408321 Mike Samuel: </h4>Please post a self-contained example.  Without knowing what <code>$str1</code> and <code>$str2</code> are, we can&#39;t tell you why control is reaching more code we don&#39;t see.  To your question, <code>eq</code> compares scalars lexicographically so is useful here, while <code>==</code> compares numerically so won&#39;t meaningfully compare anything to <code>&quot;taste&quot;</code>.<br><h4> Comment 19412552 ikegami: </h4>It&#39;s not the correct result if the &quot;then&quot; block is evaluated even when the condition is false.<br><h4> Comment 19408356 cdhowie: </h4>@hari Post the exact code where the variables are initialized.  If possible, post the complete function or script.<br>------------------------------------------------------------------ <br><h3> Answer 14046720 Galimov Albert: </h3><p>First, <strong>eq</strong> is for comparing strings; <strong>==</strong> is for comparing numbers.</p>

<blockquote>
  <p>Even if the "if" condition is satisfied, it doesn't evaluate the "then" block.</p>
</blockquote>

<p>I think your problem is that your variables don't contain what you think they do. I think your <code>$str1</code> or <code>$str2</code> contains something like "taste\n" or so. Check them by printing before your <strong>if</strong>: <code>print "str1='$str1'\n";</code>.</p>

<p>The trailing newline can be removed with the <code>chomp($str1);</code> function.</p>
<h4> Comment 19409446 hari: </h4>Damn, I also had a carriage return. This is what I needed: $str1 =~ s/\r|\n//g; What a rookie mistake.<br><h4> Comment 19408395 squiguy: </h4>@hari use <code>chomp</code>. See <code>perldoc -f chomp</code>.<br><h4> Comment 19408388 hari: </h4>How do I remove trailing newline if present before comparing?<br><h4> Comment 63147860 Keith Thompson: </h4>@hari: This is a bit late, but if you have a <code>\r</code> character in your string I have to wonder how it got there. Windows uses <code>&#39;\r\n</code> to mark the end of a line, but if you read from a text file <i>in text mode</i> you&#39;ll just get the <code>&#39;\n</code>. Perhaps you&#39;re reading a Windows-formatted text file on a Unix or Cygwin system?<br><h4> Comment 19408882 hari: </h4>yes, $str1 has &quot;\n&quot; at the end but using chomp is not helping. If I do: if( $str1 eq &quot;taste\n&quot;) it works.<br>------------------------------------------------------------------ <br><h3> Answer 14046696 cdhowie: </h3><p><code>==</code> does a numeric comparison: it converts both arguments to a number and then compares them.  As long as <code>$str1</code> and <code>$str2</code> both evaluate to 0 as numbers, the condition will be satisfied.</p>

<p><code>eq</code> does a string comparison: the two arguments must match lexically (case-sensitive) for the condition to be satisfied.</p>

<pre><code>"foo" == "bar";   # True, both strings evaluate to 0.
"foo" eq "bar";   # False, the strings are not equivalent.
"Foo" eq "foo";   # False, the F characters are different cases.
"foo" eq "foo";   # True, both strings match exactly.
</code></pre>
<h4> Comment 42929060 Jean-Francois T.: </h4>&quot;2foo&quot; == &quot;3bar&quot;; #False, the strings evaluates to respectively 2 and 3<br><h4> Comment 42942734 cdhowie: </h4>@Jean-FrancoisT. A more interesting example would have been <code>&quot;2foo&quot; == &quot;2bar&quot;</code>, which would be true. Your example producing false is unsurprising and doesn&#39;t really illustrate the difference between the operators because those strings won&#39;t compare as equal with <i>any</i> operator.<br><h4> Comment 42943664 Jean-Francois T.: </h4>The idea behind the example was to draw the parallel with &quot;foo&quot;==&quot;bar&quot; which is true, while with &quot;2foo&quot;==&quot;3bar&quot; is not<br>------------------------------------------------------------------ <br><h3> Answer 26584521 user4185253: </h3><p>Did you try to chomp the <code>$str1</code> and <code>$str2</code>?</p>

<p>I found a similar issue with using (another) <code>$str1</code> eq 'Y' and it only went away when I first did:</p>

<pre><code>chomp($str1);
if ($str1 eq 'Y') {
....
}
</code></pre>

<p>works after that. </p>

<p>Hope that helps.</p>
<h4> Comment 62394164 CCNA: </h4>This helped me! :) It&#39;s good to know the function chomp does not return the result, but just change the string itself.<br>------------------------------------------------------------------ <br><h3> Answer 14054050 user1931990: </h3><p>Maybe the condition you are using is incorrect:</p>

<pre><code>$str1 == "taste" &amp;&amp; $str2 == "waste"
</code></pre>

<p>The program will enter into <code>THEN</code> part only when both of the stated conditions are true.</p>

<p>You can try with <code>$str1 == "taste" || $str2 == "waste"</code>. This will execute the <code>THEN</code> part if anyone of the above conditions are true.</p>
