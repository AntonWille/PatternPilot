 <h2> Title: Limiting floats to two decimal points </h2> <h4> kevin, question_id: 455612 </h4>Score: 2358, Tags: {python,floating-point,rounding,precision} <br><p>I want <code>a</code> to be rounded to <em>13.95</em>. I tried using <a href="https://docs.python.org/2/library/functions.html#round" rel="noreferrer"><code>round</code></a>, but I get:</p>
<pre><code>&gt;&gt;&gt; a
13.949999999999999
&gt;&gt;&gt; round(a, 2)
13.949999999999999
</code></pre>
<hr />
<p><sub>For the analogous issue with the standard library Decimal class, see <a href="https://stackoverflow.com/questions/1995615">How can I format a decimal to always show 2 decimal places?</a>.</sub></p>
<h4> Davoud Taghawi-Nejad, Id: 15186712 Score: 90: </h4>It is important not to represent currency in float. Floats are not precise. But penny or cent amounts are integers. Therefore integers are the correct way of representing currency.<br><h4> bad_keypoints, Id: 53261505 Score: 36: </h4>I&#39;m coming probably too late here, but I wanted to ask, have the developers of Python solved this problem? Because when I do round(13.949999999999999, 2), I simply get 13.95. I&#39;ve tried it in Python 2.7.6, as well as 3.4. It works. Not sure if 2.7 even was there in 2009. Maybe it&#39;s a Python 2.5 thing?<br><h4> SingleNegationElimination, Id: 25270062 Score: 13: </h4>Hmm... Are you trying to represent currency? If so, you should not be using floats for dollars. You could probably use floats for pennies, or whatever the smallest common unit of currency you&#39;re trying to model happens to be, but the best practice is to use a decimal representation, as HUAGHAGUAH suggested in his answer.<br><h4> hynekcer, Id: 64710447 Score: 10: </h4>@bad_keypoints: Yes, the rounding problem has been solved by by Python 2.7.0+. More in <a href="http://stackoverflow.com/a/35117668/448474">my answer</a> here<br><h4> Davoud Taghawi-Nejad, Id: 35381305 Score: 6: </h4>@Basic, it depends(mostly no). Using integers in cents, or pennies is fool prove.  Its the industry standard of representing money. If you know what you are doing, have a sound understanding of floating point arithmetic and python&#39;s decimal class, you might use decimal. But it depends much of your problem. Do you need arbitrary precision decimals? Or only two digits? If two digits: integer. It keeps you out of trouble. Source I worked in a software consultancy for banking.<br><h4> Basic, Id: 22603169 Score: 3: </h4>@DavoudTaghawi-Nejad or more to the point... The <a href="http://docs.python.org/2/library/decimal.html" rel="nofollow noreferrer">Decimal Type</a><br><h4> user3850, Id: 275621 Score: 2: </h4><a href="http://stackoverflow.com/questions/249467/what-is-a-simple-example-of-floating-point-rounding-error" title="what is a simple example of floating point rounding error">stackoverflow.com/questions/249467/&hellip;</a><br><h4> Palak Bansal, Id: 112879644 Score: 2: </h4>Its working for me on python 2.7. Must have been updated<br><h4> user3850, Id: 275620 Score: 1: </h4><a href="http://stackoverflow.com/questions/406361/floating-point-limitations" title="floating point limitations">stackoverflow.com/questions/406361/floating-point-limitation&zwnj;&#8203;s</a> <a href="http://stackoverflow.com/questions/286061/python-decimal-place-issues-with-floats" title="python decimal place issues with floats">stackoverflow.com/questions/286061/&hellip;</a><br><h4> Davoud Taghawi-Nejad, Id: 72694948 Score: 1: </h4>They are still integers, but with a lower base value. 0.5 cent for example would be 500 of denomination 1/1000 cent.<br><h4> gerrit, Id: 72646903 Score: 0: </h4>@DavoudTaghawi-Nejad <i>penny or cent amounts are integers</i>, not for petrol prices...<br><h4> EarlGrey, Id: 136912436 Score: 0: </h4>When someone says it has been solved, please note that it&#39;s still there: a=1.4e-4  In[1]:a/20.0 Out[1]: 6.999999999999999e-06  In[2]:a/2.0 Out[2]:7e-05<br>------------------------------------------------------------------ <br><h3> Rex Logan, Id: 455634, Score: 2255: </h3><p>You are running into the <a href="https://en.wikipedia.org/wiki/IEEE_754" rel="noreferrer">old problem</a> with floating point numbers that not all numbers can be represented exactly. The command line is just showing you the full floating point form from memory.</p>

<p>With floating point representation, your rounded version is the same number. Since computers are binary, they store floating point numbers as an integer and then divide it by a power of two so 13.95 will be represented in a similar fashion to 125650429603636838/(2**53).</p>

<p>Double precision numbers have 53 bits (16 digits) of precision and regular floats have 24 bits (8 digits) of precision. The <a href="http://docs.python.org/tutorial/floatingpoint.html" rel="noreferrer">floating point type in Python uses double precision</a> to store the values.</p>

<p>For example,</p>

<pre><code>&gt;&gt;&gt; 125650429603636838/(2**53)
13.949999999999999

&gt;&gt;&gt; 234042163/(2**24)
13.949999988079071

&gt;&gt;&gt; a = 13.946
&gt;&gt;&gt; print(a)
13.946
&gt;&gt;&gt; print("%.2f" % a)
13.95
&gt;&gt;&gt; round(a,2)
13.949999999999999
&gt;&gt;&gt; print("%.2f" % round(a, 2))
13.95
&gt;&gt;&gt; print("{:.2f}".format(a))
13.95
&gt;&gt;&gt; print("{:.2f}".format(round(a, 2)))
13.95
&gt;&gt;&gt; print("{:.15f}".format(round(a, 2)))
13.949999999999999
</code></pre>

<p>If you are after only two decimal places (to display a currency value, for example), then you have a couple of better choices:</p>

<ol>
<li>Use integers and store values in cents, not dollars and then divide by 100 to convert to dollars.</li>
<li>Or use a fixed point number like <a href="https://docs.python.org/library/decimal.html" rel="noreferrer">decimal</a>.</li>
</ol>
<h4> Basic, Comment 22603234 Score: 42: </h4>@Christian There&#39;s a fundamental difference between the value stored and how you <i>display</i> that value. Formatting the output should allow you to add padding as required, as well as adding comma separators, etc.<br><h4> worc, Comment 31685747 Score: 32: </h4>why is it that people always assume currency on floating-point rounding? sometimes you just want to work with less precision.<br><h4> andilabs, Comment 29295533 Score: 31: </h4>worth mention that <code>&quot;%.2f&quot; % round(a,2)</code> you can put in not only in printf, but also in such things like <code>str()</code><br><h4> John Y, Comment 63149312 Score: 17: </h4>@radtek: You did literally ask for an explanation. The most straightforward solution is indeed to use <code>Decimal</code>, and that was one of the solutions presented in this answer. The other was to convert your quantities to integer and use integer arithmetic. Both of these approaches also appeared in other answers and comments.<br><h4> John Y, Comment 63104410 Score: 11: </h4>@radtek: You need to understand that the binary value (of type <code>float</code>) is just the closest available approximation of the decimal number (that you are familiar with as a human being). There is no such (finitely representable) binary value as 0.245. It simply does not exist, and mathematically <b>cannot</b> exist. The binary value which is closest to 0.245 is slightly <b>less than</b> 0.245, so naturally it rounds down. Likewise, there is no such thing as 0.225 in binary, but the binary value which is closest to 0.225 is slightly <b>greater than</b> 0.225, so naturally it rounds up.<br><h4> Andrey Semakin, Comment 96352041 Score: 3: </h4>By the way, since Python 3.6 we can use f-strings: <code>f&quot;Result is {result:.2f}&quot;</code><br><h4> Alex Punnen, Comment 56180229 Score: 3: </h4>Note In the format 0 is positional argument not needed in  python 2.7 or 3.1 , I thought it was part of format and got strange results :) (&quot;{:.2f}&quot;.format(a)<br><h4> ShadowRanger, Comment 115377707 Score: 2: </h4>@MahdiAmrollahi: Computers have bits. They can&#39;t store &quot;real numbers&quot;. They just put bits together and interpret them in conventional ways. For integers, it&#39;s fairly easy (many bits are a number in base 2). But with only 0 and 1 you can&#39;t store &quot;the real value&quot;, especially if the real value is an irrational value (e.g. pi). IEEE-754 arithmetic (<code>float</code> in Python, <code>float</code>/<code>double</code> in C/C++/C#) is efficient and &quot;close enough&quot;. More precise options exist (<code>fractions.Fraction</code>, <code>decimal.Decimal</code>; the latter uses a storage format similar to what you&#39;re asking for), but they&#39;re slower and bigger.<br><h4> Christian, Comment 16619258 Score: 1: </h4>But, what about when the number is going from 13.95 to let&#39;s say 13.90 ? My output will then be 13.9   I would like it to show the zero<br><h4> radtek, Comment 63101705 Score: 1: </h4>@JohnY why then 0.245 rounds to 0.24 while 0.225 rounds correctly? I would like to see 0.245 round to 0.25<br><h4> sam-6174, Comment 37157533 Score: 1: </h4>It should be noted that <code>&quot;%.2f&quot; %0.245</code> will output <code>&#39;0.24&#39;</code>, i.e. it only rounds up on 6 or greater<br><h4> John Y, Comment 37504382 Score: 1: </h4>@user2426679: You seem not to have understood this answer. Try rounding 0.225 to two decimal places.<br><h4> Philip Couling, Comment 132312058 Score: 0: </h4>I realise it&#39;s an old answer but rounding twice <code>&quot;%.2f&quot; % round(a, 2)</code> seems a dangerous pattern. The classic mistake being to round once and then again with fewer decimal places.  Eg mistakenly <code>&quot;%.1f&quot; % round(a, 2)</code> might round 1.045 to 1.1 by rounding first 1.045 to 1.05 and then 1.05 to 1.1.  Generally this pattern of rounding twice should be avoided.<br><h4> Marc, Comment 136389365 Score: 0: </h4>for those of you who string interpolate like so <code>f&quot;{size=}&quot;</code>, you are not left out!  You can do <code>f&quot;{size=:.2f}&quot;</code> üòã<br><h4> Rex Logan, Comment 124133900 Score: 0: </h4>Yes the newer versions of 2.7 and 3.x have auto rounding when they display as a string. This was not the case 14 years ago<br><h4> user, Comment 122141319 Score: 0: </h4>I can&#39;t repeat the result. round(a,2) gets 13.95 by python 2.7 and 3.7.<br><h4> radtek, Comment 63148251 Score: 0: </h4>@JohnY I wasn&#39;t asking for an explanation, just a solution. I think the only solution is to use Decimal type, unless someone can name a better one.<br><h4> PV8, Comment 100139989 Score: 0: </h4>how does this one work, if I want to add a string in front for example: print(&#39;blabla floatnumber function(x))<br><h4> Mahdi Amrollahi, Comment 104499763 Score: 0: </h4>I could not understand correctly why the python store a number and then divide it by another number instead of storing the real value of the number? Why do not we have such a thing in c++ or c# or ...? Why cannot we store 0.0001_0000_0000_0000... for 0.1?<br>------------------------------------------------------------------ <br><h3> Xolve, Id: 6539677, Score: 798: </h3><p>There are new format specifications, <a href="http://docs.python.org/library/string.html#format-specification-mini-language" rel="noreferrer"><strong>String Format Specification Mini-Language</strong></a>:</p>

<p>You can do the same as:</p>

<pre><code>"{:.2f}".format(13.949999999999999)
</code></pre>

<p><strong>Note 1:</strong> the above returns a string. In order to get as float, simply wrap with <code>float(...)</code>:</p>

<pre><code>float("{:.2f}".format(13.949999999999999))
</code></pre>

<p><strong>Note 2:</strong> wrapping with <code>float()</code> doesn't change anything:</p>

<pre><code>&gt;&gt;&gt; x = 13.949999999999999999
&gt;&gt;&gt; x
13.95
&gt;&gt;&gt; g = float("{:.2f}".format(x))
&gt;&gt;&gt; g
13.95
&gt;&gt;&gt; x == g
True
&gt;&gt;&gt; h = round(x, 2)
&gt;&gt;&gt; h
13.95
&gt;&gt;&gt; x == h
True
</code></pre>
<h4> Andrey Semakin, Comment 96352072 Score: 55: </h4>By the way, since Python 3.6 we can use f-strings: <code>f&quot;Result is {result:.2f}&quot;</code><br><h4> Stephen Blum, Comment 37589018 Score: 27: </h4>to add commas as well you can <code>&#39;{0:,.2f}&#39;.format(1333.949999999)</code> which prints <code>&#39;1,333.95&#39;</code>.<br><h4> Ned Batchelder, Comment 39522953 Score: 5: </h4>@JossefHarush you can wrap it with float(), but you haven&#39;t gained anything.  Now you have a float again, with all the same imprecision.  13.9499999999999 and 13.95 are the same float.<br><h4> Jossef Harush Kadouri, Comment 39523212 Score: 4: </h4>@NedBatchelder: i agree that they are equal, but this limits the float to two decimal points :)<br><h4> Jossef Harush Kadouri, Comment 39522543 Score: 0: </h4>@OnurYƒ±ldƒ±rƒ±m: yes, but you can wrap it with <code>float()</code>; <code>float(&quot;{0:.2f}&quot;.format(13.9499999))</code><br><h4> Neil, Comment 80201346 Score: 0: </h4>There&#39;s no way to &quot;round&quot; a number. Formatting is just for pretty-printing. If you really need to store the digits (e.g. keeping track of money) use integers.<br><h4> Xolve, Comment 80204952 Score: 0: </h4>@NeilChowdhury True, I asked me same after writing the answer. Assumption of question is to display float where to two decimal places.<br><h4> AlejandroVD, Comment 81580402 Score: 0: </h4>Notice that if you want to format more than one number, you need to increment the integer before the colon:     &gt;&gt;&gt; print(&quot;{0:.2f} - {0:.2f}&quot;.format(.1234, .5678))     0.12 - 0.12     &gt;&gt;&gt; print(&quot;{0:.2f} - {1:.2f}&quot;.format(.1234, .5678))     0.12 - 0.57<br>------------------------------------------------------------------ <br><h3> chribsen, Id: 41407651, Score: 432: </h3><p>The built-in <code>round()</code> works just fine in Python 2.7 or later.</p>

<p>Example:</p>

<pre><code>&gt;&gt;&gt; round(14.22222223, 2)
14.22
</code></pre>

<p>Check out <a href="https://docs.python.org/3/library/functions.html#round" rel="noreferrer">the documentation</a>.</p>
<h4> Richard Dally, Comment 99028968 Score: 10: </h4>From Python 3 documentation page: <code>Note The behavior of round() for floats can be surprising: for example, round(2.675, 2) gives 2.67 instead of the expected 2.68. This is not a bug: it‚Äôs a result of the fact that most decimal fractions can‚Äôt be represented exactly as a float.</code><br><h4> Josh Correia, Comment 101168830 Score: 3: </h4>Note that if you try to use this method to print out a number such as 1.00000 it will only print out 1.0, regardless of how many decimal points you specify.<br><h4> Melroy van den Berg, Comment 93244316 Score: 2: </h4>For example, if you try to round the value 2.675 to two decimal places, you get this <code>&gt;&gt;&gt; round(2.675, 2) 2.67</code>  <a href="https://docs.python.org/2/tutorial/floatingpoint.html" rel="nofollow noreferrer">docs.python.org/2/tutorial/floatingpoint.html</a><br><h4> Michael M, Comment 78998089 Score: 1: </h4>So am I to understand that this is a Python 2.7 fail?  Why would such a fundamental function yield different results from v 2.7 to v 3?<br><h4> jiamo, Comment 83265885 Score: 1: </h4>but <code>round(2.16, 1)</code> give <code>2.2</code> why python just offer a <code>truncate</code> func<br><h4> Mark Ransom, Comment 134844177 Score: 0: </h4>@MichaelM I don&#39;t think <code>round</code> changed but <code>print</code> did. I have a question about it somewhere on this site.<br><h4> Md Sabbir Ahmed, Comment 115377788 Score: 0: </h4>@RichardDally Thanks for the much needed information. Can you please explain why <i>&quot;most decimal fractions can‚Äôt be represented exactly as a float&quot;</i>?<br>------------------------------------------------------------------ <br><h3> Matt Fletcher, Id: 47775345, Score: 351: </h3><p>Let me give an example in Python 3.6's <a href="https://en.wikipedia.org/wiki/Python_(programming_language)#Expressions" rel="noreferrer">f-string</a>/template-string format, which I think is beautifully neat:</p>
<pre><code>&gt;&gt;&gt; f'{a:.2f}'
</code></pre>
<p>It works well with longer examples too, with operators and not needing parentheses:</p>
<pre><code>&gt;&gt;&gt; print(f'Completed in {time.time() - start:.2f}s')
</code></pre>
<h4> NKM, Comment 136985568 Score: 0: </h4>All these solutions are converting the number into string after format. How to keep the number as float after format ?<br>------------------------------------------------------------------ <br><h3> grant zukowski, Id: 28142318, Score: 181: </h3><p>I feel that the simplest approach is to use the <code>format()</code> function.</p>

<p>For example:</p>

<pre><code>a = 13.949999999999999
format(a, '.2f')

13.95
</code></pre>

<p>This produces a float number as a string rounded to two decimal points.</p>
------------------------------------------------------------------ <br><h3> Roger Pate, Id: 455678, Score: 101: </h3><p>Most numbers cannot be exactly represented in floats. If you want to round the number because that's what your mathematical formula or algorithm requires, then you want to use round. If you just want to restrict the display to a certain precision, then don't even use round and just format it as that string. (If you want to display it with some alternate rounding method, and there are tons, then you need to mix the two approaches.)</p>

<pre><code>&gt;&gt;&gt; "%.2f" % 3.14159
'3.14'
&gt;&gt;&gt; "%.2f" % 13.9499999
'13.95'
</code></pre>

<p>And lastly, though perhaps most importantly, if you want <em>exact</em> math then you don't want floats at all. The usual example is dealing with money and to store 'cents' as an integer.</p>
------------------------------------------------------------------ <br><h3> Alexey Antonenko, Id: 45502081, Score: 101: </h3><p>Use</p>

<pre><code>print"{:.2f}".format(a)
</code></pre>

<p>instead of</p>

<pre><code>print"{0:.2f}".format(a)
</code></pre>

<p>Because the latter may lead to output errors when trying to output multiple variables (see comments).</p>
<h4> Hovo, Comment 84452033 Score: 3: </h4>You would be after print(&quot;{0:.2f} {1:.2f}&quot;.format(a, b)) if you have two variables<br><h4> Alexey Antonenko, Comment 84133339 Score: 2: </h4>For Python 3, you just need to add brackets print(...). And within them all I wrote is right.<br><h4> Alexey Antonenko, Comment 84133289 Score: 1: </h4>I mean, print&quot;{0:.2f} {0:.2f}&quot;.format(a, b) will lead to mistake in output - it will output &#39;a&#39; value twice. While print&quot;{:.2f} {:.2f}&quot;.format(a, b) will output &#39;a&#39; and &#39;b&#39; values.<br>------------------------------------------------------------------ <br><h3> hynekcer, Id: 35117668, Score: 73: </h3><h2>TLDR ;)</h2>
<p>The rounding problem of input and output has been <strong>solved definitively by Python 3.1</strong> and the fix is backported also to Python 2.7.0.</p>
<p><strong>Rounded numbers can be reversibly converted between float and string</strong> back and forth:<br />
<code>str -&gt; float() -&gt; repr() -&gt; float() ...</code> or <code>Decimal -&gt; float -&gt; str -&gt; Decimal</code></p>
<pre><code>&gt;&gt;&gt; 0.3
0.3
&gt;&gt;&gt; float(repr(0.3)) == 0.3
True
</code></pre>
<p>A <code>Decimal</code> type is not necessary for storage anymore.</p>
<p><strong>Results of arithmetic operations must be rounded again</strong> because rounding errors could accumulate more inaccuracy than that is possible after parsing one number. That is not fixed by the improved <code>repr()</code> algorithm (Python &gt;= 3.1, &gt;= 2.7.0):</p>
<pre><code>&gt;&gt;&gt; 0.1 + 0.2
0.30000000000000004
&gt;&gt;&gt; 0.1, 0.2, 0.3
(0.1, 0.2, 0.3)
</code></pre>
<hr />
<p>The output string function <code>str(float(...))</code> was rounded to 12 valid digits in Python &lt; 2.7x and &lt; 3.1, to prevent excessive invalid digits similar to unfixed repr() output. That was still insufficientl after subtraction of very similar numbers and it was too much rounded after other operations. Python 2.7 and 3.1 use the same length of str() although the repr() is fixed. Some old versions of Numpy had also excessive invalid digits, even with fixed Python. The current Numpy is fixed. Python versions &gt;= 3.2 have the same results of str() and repr() function and also output of similar functions in Numpy.</p>
<hr />
<h2>Test</h2>
<pre><code>import random
from decimal import Decimal
for _ in range(1000000):
    x = random.random()
    assert x == float(repr(x)) == float(Decimal(repr(x)))  # Reversible repr()
    assert str(x) == repr(x)
    assert len(repr(round(x, 12))) &lt;= 14         # no excessive decimal places.
</code></pre>
<hr />
<h2>Documentation</h2>
<p>See the <a href="https://docs.python.org/2.7/whatsnew/2.7.html#other-language-changes" rel="noreferrer">Release notes Python 2.7 - Other Language Changes</a> the fourth paragraph:</p>
<blockquote>
<p><strong>Conversions</strong> between floating-point numbers and strings are now <strong>correctly rounded</strong> on most platforms. These conversions occur in many different places: str() on floats and complex numbers; the float and complex constructors; numeric formatting; serializing and de-serializing floats and complex numbers using the <code>marshal</code>, <code>pickle</code> and <code>json</code> modules; parsing of float and imaginary literals in Python code; and Decimal-to-float conversion.</p>
<p>Related to this, the <strong>repr()</strong> of a floating-point number x now returns a result based on the <strong>shortest decimal string that‚Äôs guaranteed to round back to x</strong> under correct rounding (with round-half-to-even rounding mode). Previously it gave a string based on rounding x to 17 decimal digits.</p>
</blockquote>
<p><a href="https://bugs.python.org/issue7117" rel="noreferrer">The related issue</a></p>
<hr />
<p><strong>More information:</strong> The formatting of <code>float</code> before Python 2.7 was similar to the current <code>numpy.float64</code>. Both types use the same 64 bit <a href="https://en.wikipedia.org/wiki/Double-precision_floating-point_format" rel="noreferrer">IEEE 754</a> double precision with 52 bit mantissa. A big difference is that <code>np.float64.__repr__</code> is formatted frequently with an excessive decimal number so that no bit can be lost, but no valid IEEE 754 number exists between 13.949999999999999 and 13.950000000000001. The result is not nice and the conversion <code>repr(float(number_as_string))</code> is not reversible with numpy. On the other hand: <code>float.__repr__</code> is formatted so that every digit is important; the sequence is without gaps and the conversion is reversible. Simply: If you perhaps have a numpy.float64 number, convert it to normal float in order to be formatted for humans, not for numeric processors, otherwise nothing more is necessary with Python 2.7+.</p>
<h4> Rick James, Comment 75094580 Score: 1: </h4>Oops, that was <code>a*b</code> vs <code>b*a</code>.  Thanks for the links -- Nostalgia.<br><h4> J&#233;r&#244;me, Comment 86720702 Score: 0: </h4>The sample code fails for both Python 2.7.13 and Python 3.5.3.<br><h4> hynekcer, Comment 86743815 Score: 0: </h4>@J&#233;r&#244;me Thanks. Fixed now. I was a typo <code>x</code> instead of <code>y</code> when I combined two tests into this example for different order of magnitude.<br><h4> hynekcer, Comment 60884018 Score: 0: </h4>Why downvoted? The question was about Python <code>float</code> (double precision) and normal <code>round</code>, not about numpy.double and its conversion to string. Plain Python rounding really can not be done better than in Python 2.7. The most of answers has been written before 2.7, but they are obsoleted, though they were very good originally. This is the reason of my answer.<br><h4> Rick James, Comment 75058411 Score: 0: </h4>53 bits when you include the &quot;hidden bit&quot;, which is implicitly <code>1</code>, except during &quot;gradual underflow&quot;.<br><h4> Rick James, Comment 75058519 Score: 0: </h4>It&#39;s not round&#39;s fault, it&#39;s the display fault.<br><h4> hynekcer, Comment 75068535 Score: 0: </h4>Yes, it&#39;s well known. I miss however a context if you object to something in Python 2.7 Release notes or in my text or to nothing at all. It is more complicated than was necessary the purpose of this question. It should be added that also conversion from string to float has been fixed in Python 2.7 due to <a href="https://bugs.python.org/issue2937" rel="nofollow noreferrer">rounding bug on certain 32-bit Intel chips</a> and that &quot;The round() function is also <b>now</b> correctly rounded.&quot; (<a href="https://docs.python.org/2.7/whatsnew/2.7.html#python-3-1-features" rel="nofollow noreferrer">Release notes -  3.1 features backported to 2.7</a>). Can you agree?<br>------------------------------------------------------------------ <br><h3> ax003d, Id: 18438167, Score: 71: </h3><p>Try the code below:</p>

<pre><code>&gt;&gt;&gt; a = 0.99334
&gt;&gt;&gt; a = int((a * 100) + 0.5) / 100.0 # Adding 0.5 rounds it up
&gt;&gt;&gt; print a
0.99
</code></pre>
<h4> Pithikos, Comment 45476847 Score: 5: </h4>@interjay which is necessary if the <code>round()</code> doesn&#39;t work as the OP mentioned.<br><h4> arhuaco, Comment 29519945 Score: 3: </h4>If you go with this approach, you should add a 0.5 for a more accurate representation. int(a * 100 + 0.5) / 100.0 ; Using math.ceil is another option.<br><h4> John Y, Comment 37504586 Score: 3: </h4>@ShashankSawant: Well, for one thing, the answer as presented does not round, it truncates. The suggestion to add half at the end will round, but then there is no benefit to doing this over just using the <code>round</code> function in the first place. For another thing, because this solution still uses floating point, the OP&#39;s original problem remains, even for the &quot;corrected&quot; version of this &quot;solution&quot;.<br><h4> interjay, Comment 40388519 Score: 3: </h4>-1, this is just an unnecessary reimplementation of the <code>round</code> function (which was used in the question).<br><h4> duhaime, Comment 85208902 Score: 0: </h4>This works fine in Python 3, you just need to make sure you include the .0 in the denominator<br><h4> Mark Ransom, Comment 104991370 Score: 0: </h4>@Pithikos <code>round()</code> works just fine, and this code doesn&#39;t work any better. The problem is that Python uses binary floating point numbers, and the closest you can get to <code>13.95</code> is <code>13.949999999999999</code>.  If you see code that generates any other number, it&#39;s because more rounding is applied when converting to a string. See <a href="https://stackoverflow.com/q/588004/5987">Is floating point math broken?</a>.<br><h4> lifebalance, Comment 28316906 Score: 0: </h4>But be cautioned, value of a is still an imprecise float. Take a look here - <a href="http://repl.it/LJs" rel="nofollow noreferrer">repl.it/LJs</a> (Click &quot;Run Session&quot; on the top of the Right section).<br><h4> Shashank Sawant, Comment 37180375 Score: 0: </h4>If a member is going to down vote this answer, please provide an explanation, so that we can understand what&#39;s wrong with this approach. For the reason mentioned by <code>OriolJ</code>, I find this to be the best answer.<br>------------------------------------------------------------------ <br><h3> Irfan wani, Id: 64680730, Score: 66: </h3><p>Use:</p>
<pre><code>float_number = 12.234325335563
round(float_number, 2)
</code></pre>
<p>This will return;</p>
<pre><code>12.23
</code></pre>
<p><strong>Explanation:</strong></p>
<p>The <em>round</em> function takes two arguments;
The number to be rounded and the number of decimal places to be returned. Here I returned two decimal places.</p>
<h4> Naman Jain, Comment 114910748 Score: 2: </h4>But how did you get an additional 0 to show up if we have say, 0.093. This is giving me 0.1 as the answer<br><h4> Irfan wani, Comment 114919674 Score: 0: </h4>If you return 2 decimal places or in general 1 place more than the number of zeroes present in the decimal part on left side, then you will get the correct result as you want.e.g, if you apply simply my answer to the number 0.093, it will return 0.09 but if you want to get only 1 decimal place, then of course, it will return 0.1 as 0.0 is completely wrong.(and my code works in the same way. Maybe you want to get only 1 decimal place. If you want to get more accurate results, you must have to increase the number of decimal places.)<br><h4> Arar, Comment 117628984 Score: 0: </h4>It&#39;s not true that it will return decimal, according to the documentation ` The return value is an integer if ndigits is omitted or None.  Otherwise     the return value has the same type as the number.  ndigits may be negative.`<br><h4> aamarks, Comment 120505492 Score: 0: </h4>All these bogus up votes. Your answer just repeats the code the OP posted when asking the question a decade ago. The OP knows the round function. You didn&#39;t solve his problem with it at all. (The problem doesn&#39;t even exist today.)<br><h4> Eric, Comment 124254732 Score: 0: </h4>This doesn&#39;t work for larger numbers. Round doesn&#39;t behave like what people want. We want a decimal format not a round. 99.9999999987 should not turn into 100 it should be 99.99. That is the issue people want resolved. Simple small math is a no brainer.<br>------------------------------------------------------------------ <br><h3> Greg Hewgill, Id: 455658, Score: 59: </h3><p>You can modify the output format:</p>

<pre><code>&gt;&gt;&gt; a = 13.95
&gt;&gt;&gt; a
13.949999999999999
&gt;&gt;&gt; print "%.2f" % a
13.95
</code></pre>
------------------------------------------------------------------ <br><h3> A.J., Id: 20512207, Score: 55: </h3><p>With Python &lt; 3 (e.g. 2.6 or 2.7), there are two ways to do so.</p>

<pre><code># Option one 
older_method_string = "%.9f" % numvar

# Option two (note ':' before the '.9f')
newer_method_string = "{:.9f}".format(numvar)
</code></pre>

<p>But note that for Python versions above 3 (e.g. 3.2 or 3.3), option two is <a href="http://docs.python.org/2/library/stdtypes.html#str.format" rel="noreferrer">preferred</a>.</p>

<p>For more information on option two, I suggest this link on <a href="http://docs.python.org/2/library/string.html#formatstrings" rel="noreferrer">string formatting from the Python documentation</a>.</p>

<p>And for more information on option one, <a href="http://docs.python.org/2/library/stdtypes.html#string-formatting" rel="noreferrer">this link will suffice and has information on the various flags</a>.</p>

<p>Reference: <em><a href="https://stackoverflow.com/questions/15263597/convert-floating-point-number-to-certain-precision-then-copy-to-string">Convert floating point number to a certain precision, and then copy to string</a></em></p>
<h4> skytux, Comment 30726349 Score: 0: </h4>How do you represent an integer? If I use &quot;{i3}&quot;.format(numvar) I get an error.<br><h4> skytux, Comment 30727036 Score: 0: </h4>This is what I mean: If <code>numvar=12.456</code>, then <code>&quot;{:.2f}&quot;.format(numvar)</code> yields <code>12.46</code> but <code>&quot;{:2i}&quot;.format(numvar)</code> gives an error and I&#39;m expecting <code>12</code>.<br>------------------------------------------------------------------ <br><h3> Asad Manzoor, Id: 54547936, Score: 44: </h3><p>You can use <a href="https://docs.python.org/3.8/library/functions.html#format" rel="nofollow noreferrer">format</a> operator for rounding the value up to two decimal places in Python:</p>
<pre><code>print(format(14.4499923, '.2f')) // The output is 14.45
</code></pre>
<h4> Jemshit, Comment 97341120 Score: 6: </h4>This returns string<br><h4> Peter Mortensen, Comment 130489331 Score: 0: </h4>Operator? Isn&#39;t it a <a href="https://en.wikipedia.org/wiki/Subroutine" rel="nofollow noreferrer">function</a>?<br><h4> Arpan Saini, Comment 119627557 Score: 0: </h4>if we just want to truncate, how to get that.<br>------------------------------------------------------------------ <br><h3> toto_tico, Id: 48559582, Score: 35: </h3><p>As <a href="https://stackoverflow.com/questions/455612/limiting-floats-to-two-decimal-points/47775345#47775345">Matt pointed out</a>, Python 3.6 provides <a href="https://en.wikipedia.org/wiki/Python_(programming_language)#Expressions" rel="noreferrer">f-strings</a>, and they can also use <a href="https://docs.python.org/3/whatsnew/3.6.html#pep-498-formatted-string-literals" rel="noreferrer">nested parameters</a>:</p>
<pre><code>value = 2.34558
precision = 2
width = 4

print(f'result: {value:{width}.{precision}f}')
</code></pre>
<p>which will display <code>result: 2.35</code></p>
------------------------------------------------------------------ <br><h3> Shashank Singh, Id: 49318930, Score: 31: </h3><p>In Python 2.7:</p>

<pre><code>a = 13.949999999999999
output = float("%0.2f"%a)
print output
</code></pre>
<h4> Mark Dickinson, Comment 91872735 Score: 1: </h4>You&#39;re missing my point. Yes, your code prints <code>13.95</code>. But so does <code>print a</code>, for this particular value of <code>a</code>, in Python 2.7, so it&#39;s not really clear what the point of the formatting step was.<br><h4> Mark Dickinson, Comment 91873222 Score: 1: </h4>Did you actually try <code>a == output</code> for the code you show? It gives <code>True</code> for me, and I suspect it does for you, too.<br><h4> Mark Dickinson, Comment 88091306 Score: 1: </h4>This doesn&#39;t help at all. <code>output</code> has the <i>exact same</i> value as <code>a</code>, so you might as well have written <code>print a</code> instead of <code>print output</code> in the last line.<br><h4> Shashank Singh, Comment 91870322 Score: 0: </h4>@MarkDickinson Could you please try again. Because It is running as expected in my compiler.<br><h4> Shashank Singh, Comment 91873401 Score: 0: </h4>@MarkDickinson For <code>a=13.949999999999999</code>, I am getting <i>True</i>. For <code>a=13.9499999</code>, I am getting <i>False</i>.  I am a bit confused now!!!<br><h4> Shashank Singh, Comment 91873198 Score: 0: </h4>@MarkDickinson I have edited the code. I agree that &#39;print a&#39; does print the same value as &quot;print output&quot;. But if you compare &quot;a==output&quot;, the result will be &quot;False&quot; because formatting step does round off the floating value &quot;a&quot; to two decimal points.<br>------------------------------------------------------------------ <br><h3> passionatedevops, Id: 64130902, Score: 28: </h3><p>We multiple options to do that:</p>
<p>Option 1:</p>
<pre><code>x = 1.090675765757
g = float(&quot;{:.2f}&quot;.format(x))
print(g)
</code></pre>
<p>Option 2:
The built-in round() supports Python 2.7 or later.</p>
<pre><code>x = 1.090675765757
g = round(x, 2)
print(g)
</code></pre>
<h4> Gustavo Kawamoto, Comment 113528418 Score: 2: </h4>The question specifically says that the round method does not do what he wants. Check <a href="https://stackoverflow.com/a/455634/6580047">this answer</a> for more info on why is that<br>------------------------------------------------------------------ <br><h3> MD. SHIFULLAH, Id: 75048009, Score: 13: </h3><p><strong>For Raw Python:</strong></p>
<p><strong>For float to string converted 2 decimal points:</strong></p>
<pre><code>a = 13.949999999999999
format(a, '.2f')
</code></pre>
<p><strong>For float to float converted 2 decimal points:</strong></p>
<pre><code>a = 13.949999999999999
round(float(a), 2)
or
float(format(a, '.2f'))
</code></pre>
<h4> NKM, Comment 136985574 Score: 0: </h4>round() works fine - it keeps the number as float (does not format into string)<br>------------------------------------------------------------------ <br><h3> nosklo, Id: 456343, Score: 24: </h3><p>The Python tutorial has an appendix called <em><a href="http://docs.python.org/tutorial/floatingpoint.html" rel="noreferrer">Floating Point Arithmetic: Issues and Limitations</a></em>. Read it. It explains what is happening and why Python is doing its best. It has even an example that matches yours. Let me quote a bit:</p>

<blockquote>
<pre><code>&gt;&gt;&gt; 0.1
0.10000000000000001
</code></pre>
  
  <p>you may be tempted to use the <code>round()</code>
  function to chop it back to the single
  digit you expect. But that makes no
  difference:</p>

<pre><code>&gt;&gt;&gt; round(0.1, 1)
0.10000000000000001
</code></pre>
  
  <p>The problem is that the binary
  floating-point value stored for <code>‚Äú0.1‚Äù</code>
  was already the best possible binary
  approximation to <code>1/10</code>, so trying to
  round it again can‚Äôt make it better:
  it was already as good as it gets.</p>
  
  <p>Another consequence is that since <code>0.1</code>
  is not exactly <code>1/10</code>, summing ten
  values of <code>0.1</code> may not yield exactly
  <code>1.0</code>, either:</p>

<pre><code>&gt;&gt;&gt; sum = 0.0
&gt;&gt;&gt; for i in range(10):
...     sum += 0.1
...
&gt;&gt;&gt; sum
0.99999999999999989
</code></pre>
</blockquote>

<p>One alternative and solution to your problems would be using the <a href="http://docs.python.org/library/decimal.html" rel="noreferrer"><code>decimal</code></a> module.</p>
------------------------------------------------------------------ <br><h3> Jonathan L, Id: 56403329, Score: 15: </h3><p>Use combination of Decimal object and round() method.</p>

<pre><code>Python 3.7.3
&gt;&gt;&gt; from decimal import Decimal
&gt;&gt;&gt; d1 = Decimal (13.949999999999999) # define a Decimal
&gt;&gt;&gt; d1 
Decimal('13.949999999999999289457264239899814128875732421875')
&gt;&gt;&gt; d2 = round(d1, 2) # round to 2 decimals
&gt;&gt;&gt; d2
Decimal('13.95')
</code></pre>
<h4> Ray Tayek, Comment 125532430 Score: 0: </h4>nice icon. <a href="https://online-go.com/user/view/179" rel="nofollow noreferrer">online-go.com/user/view/179</a><br>------------------------------------------------------------------ <br><h3> HUAGHAGUAH, Id: 455662, Score: 13: </h3><p>It's doing exactly what you told it to do and is working correctly. Read more about <a href="http://www.lahey.com/float.htm" rel="nofollow noreferrer">floating point confusion</a> and maybe try <a href="http://docs.python.org/library/decimal.html" rel="nofollow noreferrer">decimal</a> objects instead.</p>
------------------------------------------------------------------ <br><h3> weaming, Id: 53881062, Score: 10: </h3><pre><code>from decimal import Decimal


def round_float(v, ndigits=2, rt_str=False):
    d = Decimal(v)
    v_str = ("{0:.%sf}" % ndigits).format(round(d, ndigits))
    if rt_str:
        return v_str
    return Decimal(v_str)
</code></pre>

<p>Results:</p>

<pre><code>Python 3.6.1 (default, Dec 11 2018, 17:41:10)
&gt;&gt;&gt; round_float(3.1415926)
Decimal('3.14')
&gt;&gt;&gt; round_float(3.1445926)
Decimal('3.14')
&gt;&gt;&gt; round_float(3.1455926)
Decimal('3.15')
&gt;&gt;&gt; round_float(3.1455926, rt_str=True)
'3.15'
&gt;&gt;&gt; str(round_float(3.1455926))
'3.15'
</code></pre>
<h4> alper, Comment 120932515 Score: 0: </h4>Instead of <code>Decimal</code> can we return <code>float</code>? like: <code>def round_float(v, ndigits=2) -&gt; float:         d = Decimal(v);     v_str = (&quot;{0:.%sf}&quot; % ndigits).format(round(d, ndigits));     return float(v_str)</code><br><h4> weaming, Comment 120962077 Score: 0: </h4>@alper you can return whatever you prefer to<br>------------------------------------------------------------------ <br><h3> S≈Çawomir Lenart, Id: 54426784, Score: 8: </h3><p>It's simple like:</p>
<ol>
<li><p>use <a href="https://docs.python.org/3/library/decimal.html" rel="nofollow noreferrer">decimal</a> module for fast correctly-rounded decimal floating point arithmetic:</p>
<pre><code> d = Decimal(10000000.0000009)
</code></pre>
<p>to achieve rounding:</p>
<pre><code> d.quantize(Decimal('0.01'))
</code></pre>
<p>will result with <code>Decimal('10000000.00')</code></p>
</li>
<li><p>make the above <a href="https://en.wikipedia.org/wiki/Don%27t_repeat_yourself" rel="nofollow noreferrer">DRY</a>:</p>
<pre><code>def round_decimal(number, exponent='0.01'):
    decimal_value = Decimal(number)
    return decimal_value.quantize(Decimal(exponent))
</code></pre>
<p><em>or</em></p>
<pre><code>def round_decimal(number, decimal_places=2):
    decimal_value = Decimal(number)
    return decimal_value.quantize(Decimal(10) ** -decimal_places)
</code></pre>
</li>
</ol>
<p>PS: critique of others: formatting is not rounding.</p>
------------------------------------------------------------------ <br><h3> Gustavo Mirapalheta, Id: 55886087, Score: 8: </h3><p>Use a lambda function like this:</p>
<pre><code>arred = lambda x,n : x*(10**n)//1/(10**n)
</code></pre>
<p>This way you could just do:</p>
<pre><code>arred(3.141591657, 2)
</code></pre>
<p>and get</p>
<pre><code>3.14
</code></pre>
<h4> Pedro Chiiip, Comment 130674989 Score: 0: </h4>@PeterMortensen arred is short for &quot;arredondamento&quot;, which is &quot;rounding&quot; in portuguese<br><h4> Gustavo Mirapalheta, Comment 130927227 Score: 0: </h4>@Karl Knechtel if you use &#39;lambda&#39; you get the same result with less lines of code.This is why I prefer using it (whenever possible) instead of &#39;def&#39;<br><h4> Peter Mortensen, Comment 130489301 Score: 0: </h4>What is &quot;arred&quot; for? Is it a Portuguese word?<br><h4> Karl Knechtel, Comment 130489313 Score: 0: </h4>@PeterMortensen just a name for the function, which could just as easily be written with <code>def</code>. Creating a <code>lambda</code> here is really just showing off for no particular gain.<br>------------------------------------------------------------------ <br><h3> Praveen Kumar, Id: 70998892, Score: 8: </h3><p>The simple solution is here</p>
<pre><code>value = 5.34343
rounded_value = round(value, 2) # 5.34
</code></pre>
<h4> Mark Dickinson, Comment 125835603 Score: 2: </h4>There&#39;s a lot of unnecessary stuff here. <code>8&#47;3</code> is already of type <code>float</code>, so the <code>float</code> call does nothing useful. And calling dunder methods directly is a bit odd - instead, simply call the function that delegates to those dunder methods. So a better way to spell the first line is simply <code>value = round(8&#47;3, 2)</code>. And at that point you&#39;re not really adding anything that isn&#39;t already in other answers.<br><h4> Praveen Kumar, Comment 125836883 Score: 0: </h4>Sorry for the irrelevant answer. I thought it is the correct method. Also, In the question section, he mentioned that the round method was not working and so I didn&#39;t check it.<br>------------------------------------------------------------------ <br><h3> Siamand, Id: 22821930, Score: 7: </h3><p>For fixing the floating point in type-dynamic languages such as Python and JavaScript, I use this technique</p>

<pre><code># For example:
a = 70000
b = 0.14
c = a * b

print c # Prints 980.0000000002
# Try to fix
c = int(c * 10000)/100000
print c # Prints 980
</code></pre>

<p>You can also use Decimal as following:</p>

<pre><code>from decimal import *
getcontext().prec = 6
Decimal(1) / Decimal(7)
# Results in 6 precision -&gt; Decimal('0.142857')

getcontext().prec = 28
Decimal(1) / Decimal(7)
# Results in 28 precision -&gt; Decimal('0.1428571428571428571428571429')
</code></pre>
<h4> Julio Marins, Comment 80100420 Score: 1: </h4><code>getcontext().prec = 6</code> works for just the scope of the function or all places?<br><h4> Siamand, Comment 80100958 Score: 1: </h4>Contexts are environments for arithmetic operations. They govern precision, set rules for rounding, determine which signals are treated as exceptions, and limit the range for exponents.  Each thread has its own current context @JulioMarins<br>------------------------------------------------------------------ <br><h3> MikeL, Id: 46037257, Score: 7: </h3><pre><code>orig_float = 232569 / 16000.0
</code></pre>

<blockquote>
  <p>14.5355625</p>
</blockquote>

<pre><code>short_float = float("{:.2f}".format(orig_float)) 
</code></pre>

<blockquote>
  <p>14.54</p>
</blockquote>
------------------------------------------------------------------ <br><h3> Shoaib Muhammad Arif, Id: 68570712, Score: 6: </h3><p>Here is the simple solution using the <em><a href="https://docs.python.org/3.8/library/functions.html#format" rel="nofollow noreferrer">format</a></em> function.</p>
<pre><code>float(format(num, '.2f'))
</code></pre>
<p><em>Note</em>: We are converting numbers to float, because the format method is returning a string.</p>
------------------------------------------------------------------ <br><h3> Yogesh Yadav, Id: 64937509, Score: 5: </h3><p>If you want to handle money, use the Python <a href="https://docs.python.org/3.6/library/decimal.html" rel="nofollow noreferrer">decimal</a> module:</p>
<pre><code>from decimal import Decimal, ROUND_HALF_UP

# 'amount' can be integer, string, tuple, float, or another Decimal object
def to_money(amount) -&gt; Decimal:
    money = Decimal(amount).quantize(Decimal('.00'), rounding=ROUND_HALF_UP)
    return money
</code></pre>
<h4> Steve Maguire, Comment 125512445 Score: 0: </h4>I tried to use this with a column of a DateFrame.  got the message:                             TypeError: conversion from Series to Decimal is not supported<br>------------------------------------------------------------------ <br><h3> Ray Tayek, Id: 59366924, Score: 4: </h3><pre class="lang-none prettyprint-override"><code>lambda x, n:int(x*10^n + 0.5)/10^n
</code></pre>
<p>has worked for me for <em>many</em> years in many languages.</p>
<h4> Ray Tayek, Comment 125532383 Score: 0: </h4>seems like two &#39;*&#39; in a row disappears.<br>------------------------------------------------------------------ <br><h3> iblasi, Id: 32222599, Score: 3: </h3><p>To round a number to a resolution, the best way is the following one, which can work with any resolution (0.01 for two decimals or even other steps):</p>

<pre><code>&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; value = 13.949999999999999
&gt;&gt;&gt; resolution = 0.01
&gt;&gt;&gt; newValue = int(np.round(value/resolution))*resolution
&gt;&gt;&gt; print newValue
13.95

&gt;&gt;&gt; resolution = 0.5
&gt;&gt;&gt; newValue = int(np.round(value/resolution))*resolution
&gt;&gt;&gt; print newValue
14.0
</code></pre>
<h4> iblasi, Comment 60805782 Score: 1: </h4>Looking for documentation I see the problem comes from <code>numpy.round</code> accuracy/precision. So it requires to define it as int before multiplication with resolution. I updated the code. Thank you for that!<br><h4> hynekcer, Comment 60889235 Score: 0: </h4>The only necessary is to convert <code>numpy.float64</code> result of np.round to <code>float</code> or simply to use <code>round(value, 2)</code>. No valid IEEE 754 number exists between 13.949999999999999 (= 1395 / 100.) and 3.950000000000001 (= 1395 * .01). Why do you think that your method is the best? The original value 13.949999999999999289 (= value = round(value, 2)) is even more exact than your 13.95000000000000178 (printed by np.float96). More info also for numpy is now added to <a href="http://stackoverflow.com/a/35117668/448474">my answer</a> that you probably downvoted by mistake. It wasn&#39;t about numpy originally.<br><h4> iblasi, Comment 60906245 Score: 0: </h4>@hynekcer I do not think that my answer is the best. Just wanted to add an example of limit float to n decimals but the nearest of a defined resolution. I checked as you said, that instead of <code>int</code>you can also use <code>float</code>for @szeitlin example. Thank you for your extra comment. (Sorry but I did not downvote you)<br><h4> Hejazzman, Comment 98172690 Score: 0: </h4>Adding whole new dependency for numeric processing (pandas) is the &quot;best way&quot;?<br><h4> szeitlin, Comment 60709053 Score: 0: </h4>doesn&#39;t work for me on python 3.4.3 and numpy 1.9.1 ? &gt;&gt;&gt; import numpy as np &gt;&gt;&gt; res = 0.01 &gt;&gt;&gt; value = 0.184 &gt;&gt;&gt; np.round(value/res) * res 0.17999999999999999<br>------------------------------------------------------------------ <br><h3> NMC, Id: 63035788, Score: 3: </h3><p>The answers I saw didn't work with the float(52.15) case. After some tests, there is the solution that I'm using:</p>
<pre><code>import decimal
        
def value_to_decimal(value, decimal_places):
    decimal.getcontext().rounding = decimal.ROUND_HALF_UP  # define rounding method
    return decimal.Decimal(str(float(value))).quantize(decimal.Decimal('1e-{}'.format(decimal_places)))
</code></pre>
<p>(The conversion of the 'value' to float and then string is very important, that way, 'value' can be of the type float, decimal, integer or string!)</p>
<p>Hope this helps anyone.</p>
------------------------------------------------------------------ <br><h3> heyom, Id: 69114417, Score: 0: </h3><p>Just use this function and pass bytes as an input to it:</p>
<pre><code>def getSize(bytes):
    kb = round(bytes/1024, 4)
    mb = round(kb/1024, 4)
    gb = round(mb/1024, 4)
    if(gb &gt; 1):
        return str(gb) + &quot; GB&quot;
    elif(mb &gt; 1):
        return str(mb) + &quot; MB&quot;
    else:
        return str(kb) + &quot; KB&quot;
</code></pre>
<p>This is the easiest way I could get to convert the data size from bytes to KB, MB or GB <strong>dynamically</strong>.</p>
------------------------------------------------------------------ <br><h3> DonCarleone, Id: 72483157, Score: 0: </h3><h2>One-liner function to print percentage:</h2>
<p>k - the numerator</p>
<p>n - the denominator</p>
<p>'%.2f' - means you want a precision of 2 decimal places</p>
<p>*100 - turns the number from a decimal to a percentage</p>
<pre><code>   percentage = lambda k, n: '%.2f' % (k/n*100)

   - equivalent to-

   def percentage(k,n):
       return '%.2f' % (k/n*100)
</code></pre>
<p><strong>percentage(1,3)</strong></p>
<p><strong>output -&gt; '33.33'</strong></p>
------------------------------------------------------------------ <br><h3> sai, Id: 77143347, Score: 0: </h3><pre class="lang-py prettyprint-override"><code>def custom_round(number, decimal_places):
    multiplier = 10 ** decimal_places
    rounded_number = round(number * multiplier) / multiplier
    return rounded_number

result = custom_round(13.9456789, 2)  # Rounds to 2 decimal places
print(result)  # Output will be 13.95
</code></pre>
<h4> Destroy666, Comment 136042469 Score: 0: </h4>Please don&#39;t post code only and add an explantation as to why you think that this is the optimal solution. People are supposed to learn from your answer, which might not occur if they just copy paste code without knowing why it should be used.<br>------------------------------------------------------------------ <br><h3> Artur Todeschini, Id: 74226514, Score: -1: </h3><p>To calculate I use a function to truncate value
maybe help to you</p>
<pre><code>import math


def truncate(number, digits) -&gt; float:
    stepper = pow(10.0, digits)
    return math.trunc(stepper * number) / stepper


print(truncate((0.1 + 0.2), 2))
</code></pre>
------------------------------------------------------------------ <br><h3> M. Zain Aldin, Id: 75958952, Score: -6: </h3><p>transform a to float first:</p>
<pre><code>round(float(a), 2)
</code></pre>
------------------------------------------------------------------ <br><h3> tdh, Id: 34543213, Score: -19: </h3><p>The method I use is that of string slicing. It's relatively quick and simple.</p>

<p>First, convert the float to a string, the choose the length you would like it to be.</p>

<pre><code>float = str(float)[:5]
</code></pre>

<p>In the single line above, we've converted the value to a string, then kept the string only to its first four digits or characters (inclusive).</p>

<p>Hope that helps!</p>
<h4> Angry 84, Comment 57083792 Score: 20: </h4>WOW... tdh... Please never make any accounting software... What happens if the number happen to be 113.94 ?? this would result in 113.9 ... leaving 0.04 missing....  Also this already has answers from over 5 years ago....<br><h4> vaultah, Comment 56828345 Score: 2: </h4>Please don&#39;t post identical answers to multiple questions.<br>