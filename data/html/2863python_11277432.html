 <h2> Title: How can I remove a key from a Python dictionary? </h2> <h4> Tony, question_id: 11277432 </h4>Score: 2863, Tags: {python,dictionary,unset} <br><p>I want to remove a key from a dictionary if it is present. I currently use this code:</p>
<pre class="lang-py prettyprint-override"><code>if key in my_dict:
    del my_dict[key]
</code></pre>
<p>Without the <code>if</code> statement, the code will raise <code>KeyError</code> if the key is <em>not</em> present. How can I handle this more simply?</p>
<hr />
<p><sub>See <a href="https://stackoverflow.com/questions/5844672">Delete an element from a dictionary</a> for more general approaches to the problem of removing a key from a dict (including ones which produce a modified copy).</sub></p>
<h4> Mattie, Id: 26911301 Score: 37: </h4>Benchmark script for the various methods proposed in the answers to this question: <a href="https://gist.github.com/zigg/6280653" rel="nofollow noreferrer">gist.github.com/zigg/6280653</a><br><h4> Abu Shoeb, Id: 116258323 Score: 2: </h4>Does this answer your question? <a href="https://stackoverflow.com/questions/5844672/delete-an-element-from-a-dictionary">Delete an element from a dictionary</a><br>------------------------------------------------------------------ <br><h3> Sven Marnach, Id: 11277439, Score: 4556: </h3><p>To delete a key regardless of whether it is in the dictionary, use the two-argument form of <a href="http://docs.python.org/library/stdtypes.html#dict.pop" rel="noreferrer"><code>dict.pop()</code></a>:</p>
<pre class="lang-py prettyprint-override"><code>my_dict.pop('key', None)
</code></pre>
<p>This will return <code>my_dict[key]</code> if <code>key</code> exists in the dictionary, and <code>None</code> otherwise. If the second parameter is not specified (i.e. <code>my_dict.pop('key')</code>) and <code>key</code> does not exist, a <code>KeyError</code> is raised.</p>
<p>To delete a key that is guaranteed to exist, you can also use</p>
<pre><code>del my_dict['key']
</code></pre>
<p>This will raise a <code>KeyError</code> if the key is not in the dictionary.</p>
<h4> kratenko, Comment 26848760 Score: 279: </h4>Sometimes an advantage of using <code>pop()</code> over <code>del</code>: it returns the value for that key. This way you can get and delete an entry from a dict in one line of code.<br><h4> Sven Marnach, Comment 76138280 Score: 60: </h4>@SalvatoreCosentino No, ignoring the return value of a function is not inefficient at all.  Quite the opposite – this solution is much faster than the <code>try</code>/<code>except</code> solution if the key does not exist.  You might find one or the other easier to read, which is fine.  Both are idiomatic Python, so choose whatever you prefer.  But claiming that this answer is more complex or inefficient simply makes no sense.<br><h4> Sven Marnach, Comment 76127391 Score: 19: </h4>@SalvatoreCosentino I can&#39;t follow your argument.  How is the code in this answer more complex than the code in in the other answer?<br><h4> Salvatore Cosentino, Comment 76059783 Score: 11: </h4>In the question it is not required to keep the value. This would only add unneeded complexity. The answer from @zigg (below) is much better.<br><h4> Sven Marnach, Comment 90265119 Score: 10: </h4>@user5359531 I don&#39;t understand.  How is this a problem?  None of the methods on Python&#39;s built-in types returns <code>self</code>, so it would be rather surprising if this one did.<br><h4> Sven Marnach, Comment 90318721 Score: 8: </h4>@user5359531 You should generally avoid list comprehensions with side effects, since they are confusing.  If <code>dict.pop()</code> returned the original dict, then <code>b = [d.pop(&quot;key&quot;) for d in a]</code> would modify <i>both</i> lists, <code>a</code> and <code>b</code>, since they would both share the same dictionary objects.  This is part of the reason why Python has the convention that mutating methods don&#39;t have a return value.  (In fact, <code>dict.pop()</code> is an exception of this convention, but it does not violate the spirit of the convention.)<br><h4> Sven Marnach, Comment 90318753 Score: 6: </h4>@user5359531 If you want to mutate a list of dictionaries in place, use a for loop: <code>for d in a: d.pop(&quot;key&quot;, None)</code>.  If you want to keep the original dictionaries unchanged, copy them first: <code>b = [d.copy() for d in a]</code>.<br><h4> Salvatore Cosentino, Comment 76132312 Score: 2: </h4>Hello @SvenMarnach, to  1) The answer below is more elegant in my opinion (e.g., handling the exception) 2) using &#39;pop&#39; in most programming languages (and data structures) is used when you want to store the deleted value, and the question only asks about deleting a key. Returning a value that is never used would be simply unefficient.<br><h4> user5359531, Comment 90318268 Score: 1: </h4>when trying to use this feature inside a list-comprehension, which is a pretty typical use case for one-liners in Python. Transforming one list of dicts into another where some keys have been removed.<br><h4> user5359531, Comment 90243151 Score: 0: </h4>A problem with this approach is that it returns the value of <code>key</code>, and not the original dict. So, <code>{&#39;a&#39;:1, &#39;b&#39;:2}.pop(&#39;b&#39;)</code> returns <code>2</code> instead of <code>{&#39;a&#39;:1}</code><br><h4> matanster, Comment 109603374 Score: 0: </h4>useful use case: creating hierarchy from a flat dict as in <code>new_dict = {my_dict.pop(&#39;key_to_promote&#39;): my_dict}</code><br><h4> Ambareesh, Comment 112353359 Score: 0: </h4>The equivalent for the <code>set</code> datastructure is the <code>discard</code> operation. For e.g <code>my_set.discard(k)</code> will remove k without raising KeyError, whereas <code>my_set.remove(k) </code> will raise KeyError if <code>k</code> is not present in the set.<br>------------------------------------------------------------------ <br><h3> Mattie, Id: 11277484, Score: 463: </h3><p>Specifically to answer "is there a one line way of doing this?"</p>

<pre><code>if 'key' in my_dict: del my_dict['key']
</code></pre>

<p>...well, you <em>asked</em> ;-)</p>

<p>You should consider, though, that this way of deleting an object from a <code>dict</code> is <a href="https://stackoverflow.com/q/17326067/722332">not atomic</a>—it is possible that <code>'key'</code> may be in <code>my_dict</code> during the <code>if</code> statement, but may be deleted before <code>del</code> is executed, in which case <code>del</code> will fail with a <code>KeyError</code>.  Given this, it would be safest to either <a href="https://stackoverflow.com/a/11277439/722332">use <code>dict.pop</code></a> or something along the lines of</p>

<pre><code>try:
    del my_dict['key']
except KeyError:
    pass
</code></pre>

<p>which, of course, is definitely <em>not</em> a one-liner.</p>
<h4> Mattie, Comment 14841265 Score: 38: </h4>Yeah, <code>pop</code> is a definitely more concise, though there is one key advantage of doing it this way: it&#39;s immediately clear what it&#39;s doing.<br><h4> Mattie, Comment 26911267 Score: 21: </h4>@ChrisBarker I&#39;ve found if the key exists, <code>try</code> is marginally faster, though if it doesn&#39;t, <code>try</code> is indeed a good deal slower.  <code>pop</code> is fairly consistent but slower than all but <code>try</code> with a non-present key.  See <a href="https://gist.github.com/zigg/6280653" rel="nofollow noreferrer">gist.github.com/zigg/6280653</a>.  Ultimately, it depends on how often you expect the key to actually be in the dictionary, and whether or not you need atomicity—and, of course, whether or not you&#39;re engaging in premature optimization ;)<br><h4> Chris Barker, Comment 26898702 Score: 8: </h4>The <code>try&#47;except</code> statement is more expensive. Raising an exception is slow.<br><h4> Marc, Comment 50636320 Score: 3: </h4>regarding expense of try/except, you can also go <code>if &#39;key&#39; in mydict: #then del...</code>. I needed to pull out a key/val from a dict to parse correctly, pop was not a perfect solution.<br><h4> Gloweye, Comment 91094888 Score: 1: </h4>@Marc if you need to process a key:value pair, use <code>popitem()</code> instead. Put it in a while loop to consume the entire dict.<br><h4> Mattie, Comment 50789460 Score: 1: </h4>@datamafia Like all <code>if k in d</code> solutions, though, that&#39;s not atomic and the <code>del</code> may fail. Why didn&#39;t <code>pop</code> work for you?<br><h4> Marc, Comment 50795632 Score: 0: </h4>@zigg I had a wonky data structure, in short I needed to order dict via a key/val pair nested in dict. So I used <code>if key in</code> to qualify if the trouble making key is in dict, copy to a temp dict, perform lambda/list comp ordering of dict, then add the value back in. Pop and del work the same in that instance. The conditional qualifier allowed the key/val to be placed in temp dict for ordering to work. This was a work around for some brownfield code, not perfect but we moved on. <code>pop()</code> would have also worked, I like the del verbosity. Try/catch can be expensive.<br><h4> juan Isaza, Comment 117553175 Score: 0: </h4>@ChrisBarker Python is a lang intended to manage exceptions, they are only marginally slower than other options see: <a href="https://stackoverflow.com/questions/2522005/cost-of-exception-handlers-in-python" title="cost of exception handlers in python">stackoverflow.com/questions/2522005/&hellip;</a><br>------------------------------------------------------------------ <br><h3> Akavall, Id: 15206537, Score: 200: </h3><p>It took me some time to figure out what exactly <code>my_dict.pop(&quot;key&quot;, None)</code> is doing. So I'll add this as an answer to save others googling time:</p>
<blockquote>
<h3><code>pop(key[, default])</code></h3>
<p>If <em>key</em> is in the dictionary, remove it and return its value, else
return <em>default</em>. If <em>default</em> is not given and <em>key</em> is not in the
dictionary, a <code>KeyError</code> is raised.</p>
</blockquote>
<p><a href="https://docs.python.org/2/library/stdtypes.html#dict.pop" rel="noreferrer">Documentation</a></p>
<h4> David Mulder, Comment 26474113 Score: 23: </h4>help() and dir() can be your friends when you need to know what something does.<br>------------------------------------------------------------------ <br><h3> Peter Smit, Id: 41017333, Score: 86: </h3><p><code>del my_dict[key]</code> is slightly faster than <code>my_dict.pop(key)</code> for removing a key from a dictionary when the key exists</p>

<pre><code>&gt;&gt;&gt; import timeit
&gt;&gt;&gt; setup = "d = {i: i for i in range(100000)}"

&gt;&gt;&gt; timeit.timeit("del d[3]", setup=setup, number=1)
1.79e-06
&gt;&gt;&gt; timeit.timeit("d.pop(3)", setup=setup, number=1)
2.09e-06
&gt;&gt;&gt; timeit.timeit("d2 = {key: val for key, val in d.items() if key != 3}", setup=setup, number=1)
0.00786
</code></pre>

<p>But when the key doesn't exist <code>if key in my_dict: del my_dict[key]</code> is slightly faster than <code>my_dict.pop(key, None)</code>. Both are at least three times faster than <code>del</code> in a <code>try</code>/<code>except</code> statement:</p>

<pre><code>&gt;&gt;&gt; timeit.timeit("if 'missing key' in d: del d['missing key']", setup=setup)
0.0229
&gt;&gt;&gt; timeit.timeit("d.pop('missing key', None)", setup=setup)
0.0426
&gt;&gt;&gt; try_except = """
... try:
...     del d['missing key']
... except KeyError:
...     pass
... """
&gt;&gt;&gt; timeit.timeit(try_except, setup=setup)
0.133
</code></pre>
------------------------------------------------------------------ <br><h3> Marc Maxmeister, Id: 32616904, Score: 70: </h3><p>If you need to remove a lot of keys from a dictionary in one line of code, I think using map() is quite succinct and Pythonic readable:</p>

<pre><code>myDict = {'a':1,'b':2,'c':3,'d':4}
map(myDict.pop, ['a','c']) # The list of keys to remove
&gt;&gt;&gt; myDict
{'b': 2, 'd': 4}
</code></pre>

<p>And if you need to catch errors where you pop a value that isn't in the dictionary, use lambda inside map() like this:</p>

<pre><code>map(lambda x: myDict.pop(x,None), ['a', 'c', 'e'])
[1, 3, None] # pop returns
&gt;&gt;&gt; myDict
{'b': 2, 'd': 4}
</code></pre>

<p>or in <code>python3</code>, you must use a list comprehension instead:</p>

<pre><code>[myDict.pop(x, None) for x in ['a', 'c', 'e']]
</code></pre>

<p>It works. And 'e' did not cause an error, even though myDict did not have an 'e' key.</p>
<h4> joel, Comment 135655431 Score: 0: </h4>I&#39;d suggest using a <code>for</code> loop instead of <code>map</code> if your function has side-effects like <code>pop</code> does. It&#39;s clearer<br>------------------------------------------------------------------ <br><h3> Shameem, Id: 41010331, Score: 67: </h3><p>You can use a <a href="https://docs.python.org/tutorial/datastructures.html#dictionaries" rel="noreferrer">dictionary comprehension</a> to create a new dictionary with that key removed:</p>

<pre><code>&gt;&gt;&gt; my_dict = {k: v for k, v in my_dict.items() if k != 'key'}
</code></pre>

<p>You can delete by conditions. No error if <code>key</code> doesn't exist.</p>
<h4> Jeff D. White, Comment 111889025 Score: 7: </h4>This answer is different than the others because it has no side-effects (it does not mutate the original dictionary).<br><h4> mazunki, Comment 114805052 Score: 2: </h4>While this is probably the way I would do it aswell, this makes a whole new dictionary in memory, copying (references to) objects to the new dictionary. It then saves it onto the old name. For big dictionaries this can take some time. <code>del dict[key]</code> or <code>dict.pop(key)</code> will be faster in all cases.<br><h4> Ramon Dias, Comment 127699198 Score: 0: </h4><code>del</code> and <code>pop</code> are faster, but sometimes you just <b>don&#39;t want</b> to modify the original dictionary. It would make more sense if in the example above, the comprehension result was assigned to another variable.<br>------------------------------------------------------------------ <br><h3> Innat, Id: 50424087, Score: 11: </h3><p>We can delete a key from a Python dictionary by the some of the following approaches.</p>
<p>Using the <code>del</code> keyword; it's almost the same approach like you did though -</p>
<pre><code> myDict = {'one': 100, 'two': 200, 'three': 300 }
 print(myDict)  # {'one': 100, 'two': 200, 'three': 300}
 if myDict.get('one') : del myDict['one']
 print(myDict)  # {'two': 200, 'three': 300}
</code></pre>
<p><strong>Or</strong></p>
<p>We can do like the following:</p>
<p>But one should keep in mind that, in this process actually it won't <strong>delete</strong> any key from the dictionary rather than making a specific key <strong>excluded</strong> from that dictionary. In addition, I observed that it returned a dictionary which was not ordered the same as <code>myDict</code>.</p>
<pre><code>myDict = {'one': 100, 'two': 200, 'three': 300, 'four': 400, 'five': 500}
{key:value for key, value in myDict.items() if key != 'one'}
</code></pre>
<p>If we run it in the shell, it'll execute something like <code>{'five': 500, 'four': 400, 'three': 300, 'two': 200}</code> - notice that it's not the same ordered as <code>myDict</code>. Again if we try to print <code>myDict</code>, then we can see all keys including which we excluded from the dictionary by this approach. However, we can make a new dictionary by assigning the following statement into a variable:</p>
<pre><code>var = {key:value for key, value in myDict.items() if key != 'one'}
</code></pre>
<p>Now if we try to print it, then it'll follow the parent order:</p>
<pre><code>print(var) # {'two': 200, 'three': 300, 'four': 400, 'five': 500}
</code></pre>
<p><strong>Or</strong></p>
<p>Using the <code>pop()</code> method.</p>
<pre><code>myDict = {'one': 100, 'two': 200, 'three': 300}
print(myDict)

if myDict.get('one') : myDict.pop('one')
print(myDict)  # {'two': 200, 'three': 300}
</code></pre>
<p>The difference between <code>del</code> and <code>pop</code> is that, using <code>pop()</code> method, we can actually store the <strong>key's value</strong> if needed, like the following:</p>
<pre><code>myDict = {'one': 100, 'two': 200, 'three': 300}
if myDict.get('one') : var = myDict.pop('one')
print(myDict) # {'two': 200, 'three': 300}
print(var)    # 100
</code></pre>
<p>Fork <a href="https://gist.github.com/innat/c8d04ef139060b9ef0b7fa8a164f87bc" rel="nofollow noreferrer">this gist</a> for future reference, if you find this useful.</p>
------------------------------------------------------------------ <br><h3> Alec, Id: 56301607, Score: 11: </h3><p>You can use exception handling if you want to be very verbose:</p>

<pre><code>try: 
    del dict[key]

except KeyError: pass
</code></pre>

<p>This is slower, however, than the <code>pop()</code> method, if the key doesn't exist.</p>

<pre><code>my_dict.pop('key', None)
</code></pre>

<p>It won't matter for a few keys, but if you're doing this repeatedly, then the latter method is a better bet.</p>

<p>The fastest approach is this:</p>

<pre><code>if 'key' in dict: 
    del myDict['key']
</code></pre>

<p>But this method is dangerous because if <code>'key'</code> is removed in between the two lines, a <code>KeyError</code> will be raised.</p>
------------------------------------------------------------------ <br><h3> CervEd, Id: 56594575, Score: 7: </h3><p>I prefer the immutable version</p>

<pre class="lang-py prettyprint-override"><code>foo = {
    1:1,
    2:2,
    3:3
}
removeKeys = [1,2]
def woKeys(dct, keyIter):
    return {
        k:v
        for k,v in dct.items() if k not in keyIter
    }

&gt;&gt;&gt; print(woKeys(foo, removeKeys))
{3: 3}
&gt;&gt;&gt; print(foo)
{1: 1, 2: 2, 3: 3}
</code></pre>
------------------------------------------------------------------ <br><h3> Sai Kiran Sangam, Id: 57980814, Score: 6: </h3><p>Another way is by using items() + dict comprehension.</p>
<p>items() coupled with dict comprehension can also help us achieve the task of key-value pair deletion, but it has the drawback of not being an in place dict technique. Actually a new dict if created except for the key we don’t wish to include.</p>
<pre><code>test_dict = {&quot;sai&quot; : 22, &quot;kiran&quot; : 21, &quot;vinod&quot; : 21, &quot;sangam&quot; : 21}

# Printing dictionary before removal
print (&quot;dictionary before performing remove is : &quot; + str(test_dict))

# Using items() + dict comprehension to remove a dict. pair
# removes  vinod
new_dict = {key:val for key, val in test_dict.items() if key != 'vinod'}

# Printing dictionary after removal
print (&quot;dictionary after remove is : &quot; + str(new_dict))
</code></pre>
<p>Output:</p>
<pre><code>dictionary before performing remove is : {'sai': 22, 'kiran': 21, 'vinod': 21, 'sangam': 21}
dictionary after remove is : {'sai': 22, 'kiran': 21, 'sangam': 21}
</code></pre>
------------------------------------------------------------------ <br><h3> cottontail, Id: 75542215, Score: 1: </h3><h5>Remove multiple keys</h5>
<p><a href="https://stackoverflow.com/a/32616904/19123103">Marc Maxmeister's post</a> discusses this but creates an unnecessary (imo) list while doing so. You can simply use a for-loop and throw away the popped values.</p>
<pre class="lang-py prettyprint-override"><code>my_dict = {'a': 1, 'b': 2, 'c': 3, 'd': 4}
lst = ['a', 'c', 'e']
for k in lst: my_dict.pop(k, None)
print(my_dict)                                              # {'b': 2, 'd': 4}
</code></pre>
<p>or if you want to use <code>map</code>, then exhaust the map using a deque with max length 0.</p>
<pre class="lang-py prettyprint-override"><code>from collections import deque
from itertools import repeat
deque(map(my_dict.pop, ['a', 'c', 'e'], repeat(None)), 0)
print(my_dict)                                              # {'b': 2, 'd': 4}
</code></pre>
<h5>Split dict into two</h5>
<p>One case where <code>dict.pop()</code> may be useful is if you want to create a new dictionary with the popped key-value pairs, effectively splitting a dictionary into two in one for-loop.</p>
<pre class="lang-py prettyprint-override"><code>new_dict = {k: v for k in lst if (v:=my_dict.pop(k, 'NULL')) != 'NULL'}
print(my_dict)                                              # {'b': 2, 'd': 4}
print(new_dict)                                             # {'a': 1, 'c': 3}
</code></pre>
