 <h2> Title: How to implement Enums in Ruby? </h2> <h4> auramo, question_id: 75759, created_at: 2008-09-16 19:02:09+00:00 </h4>Score: 371, Tags: {ruby,enums} <br><p>What's the best way to implement the enum idiom in Ruby? I'm looking for something which I can use (almost) like the Java/C# enums.</p>
<h4> Comment by Dan Rosenstark, Score: 7, Id: 2406815, created_at: 2010-03-11 09:57:38+00:00 </h4>@auramo, good question, and great choice for the best answer. Love it or hate it, you get no type-safety and (at least in Ruby) no typo-safety. I was thrilled when I discovered enums in C# and later in Java (pick a value, but from these!), Ruby doesn&#39;t provide a real way to do that in any case at all.<h4> Comment by user1164178, Score: 3, Id: 45344493, created_at: 2015-02-14 06:33:09+00:00 </h4>The problem with this question is that Java and C# enums are dramatically different things. A Java enum member is an object instance and a singleton. A Java enum can have a constructor. In contrast, C# enums are based off Primitive values. Which behaviour is the questioner looking for? While it&#39;s likely the case that the C# case is wanted, Java is explicitly mentioned, rather than C or C++, so there is some doubt. As for suggesting that there&#39;s no way to be &#39;safe&#39; in Ruby, that&#39;s transparently false, but you have to implement something more sophisticated.<hr><h3> ✔️ Answer by mlibby, Id: 76046, Score: 369, created_at: 2008-09-16 19:32:30+00:00 </h3><p>Two ways. Symbols (<code>:foo</code> notation) or constants (<code>FOO</code> notation).</p>
<p>Symbols are appropriate when you want to enhance readability without littering code with literal strings.</p>
<pre><code>postal_code[:minnesota] = &quot;MN&quot;
postal_code[:new_york] = &quot;NY&quot;
</code></pre>
<p>Constants are appropriate when you have an underlying value that is important. Just declare a module to hold your constants and then declare the constants within that.</p>
<pre><code>module Foo
  BAR = 1
  BAZ = 2
  BIZ = 4
end
 
flags = Foo::BAR | Foo::BAZ # flags = 3
</code></pre>
<p>Added 2021-01-17</p>
<p>If you are passing the enum value around (for example, storing it in a database) and you need to be able to translate the value back into the symbol, there's a mashup of both approaches</p>
<pre><code>COMMODITY_TYPE = {
  currency: 1,
  investment: 2,
}

def commodity_type_string(value)
  COMMODITY_TYPE.key(value)
end

COMMODITY_TYPE[:currency]
</code></pre>
<p>This approach inspired by andrew-grimm's answer <a href="https://stackoverflow.com/a/5332950/13468">https://stackoverflow.com/a/5332950/13468</a></p>
<p>I'd also recommend reading through the rest of the answers here since there are a lot of ways to solve this and it really boils down to what it is about the other language's enum that you care about</p>
<h4> Comment by thomthom, Score: 8, Id: 12331944, created_at: 2012-03-14 13:37:19+00:00 </h4>Wouldn&#39;t a module be better to group constants - as you&#39;re not going to be making any instances of it?<h4> Comment by Michael Brown, Score: 5, Id: 33906145, created_at: 2014-03-10 23:02:19+00:00 </h4>Not entirely true. The first letter of the constant must be capitalized, but not all letters need to be. This is a matter of convention preference. For example, all module names and class names are actually constants too.<h4> Comment by Rokujolady, Score: 3, Id: 22619075, created_at: 2013-04-08 18:41:30+00:00 </h4>Just a comment. Ruby&#39;s a bit of a pain about naming conventions but not really obvious about them until you trip over them. The names of the enums must be all caps and the first letter of the module name must be capitalized for ruby to know that the module is a module of constants.<h4> Comment by Phương Nguyễn, Score: 2, Id: 3087472, created_at: 2010-06-11 03:44:41+00:00 </h4>What if these enum is too be stored to the database? Will symbol notation works? I doubt...<h4> Comment by baash05, Score: 1, Id: 14954659, created_at: 2012-07-06 00:04:36+00:00 </h4>As well, the module would be faster, as the other one has a hash lookup. Small hash, sure, but still.<h4> Comment by mlibby, Score: 0, Id: 12538504, created_at: 2012-03-23 12:51:20+00:00 </h4>@thomthom absolutely, yes. I&#39;ve changed the answer. If there is no close coupling of the enums to the context of a class where it would make sense to declare them, then a module makes more sense.<h4> Comment by mlibby, Score: 0, Id: 3090359, created_at: 2010-06-11 12:40:52+00:00 </h4>I would use the constants approach if I were saving to a database. Of course then you have to do some sort of lookup when pulling the data back out of the DB. You could also use something like <code>:minnesota.to_s</code> when saving to a database to save the string version of the symbol. Rails, I believe, has some helper methods to deal with some of this.<h4> Comment by mlibby, Score: 0, Id: 11846155, created_at: 2012-02-21 14:09:11+00:00 </h4>@dfrankow, what do you mean? I&#39;ve never heard of order as a concern in the context of C# enums.<h4> Comment by dfrankow, Score: 0, Id: 11846198, created_at: 2012-02-21 14:11:32+00:00 </h4>Don&#39;t know about C#, but Java enums have order, and it is used: <a href="http://docs.oracle.com/javase/1.5.0/docs/guide/language/enums.html" rel="nofollow noreferrer">docs.oracle.com/javase/1.5.0/docs/guide/language/enums.html</a>. &quot;Note that each enum type has a static values method that returns an array containing all of the values of the enum type in the order they are declared. This method is commonly used in combination with the for-each loop to iterate over the values of an enumerated type.&quot;<h4> Comment by mlibby, Score: 0, Id: 11846406, created_at: 2012-02-21 14:21:23+00:00 </h4>@drankow, ah. For that to be automatic you would need to look at something like <a href="http://www.rubyfleebie.com/enumerations-and-ruby/" rel="nofollow noreferrer">rubyfleebie.com/enumerations-and-ruby</a> or <a href="http://code.dblock.org/how-to-define-enums-in-ruby" rel="nofollow noreferrer">code.dblock.org/how-to-define-enums-in-ruby</a> which support this behavior. Otherwise, if you use the constants approach, you can define a method like <code>Foo.values</code> that returns the constants as an array.<h4> Comment by Gayan Weerakutti, Score: 0, Id: 86901256, created_at: 2018-04-20 13:20:52+00:00 </h4>What if I want to do a type check as these are just constants?<hr><h3>  Answer by Charles, Id: 6170494, Score: 63, created_at: 2011-05-29 21:19:58+00:00 </h3><p>I'm surprised that no one has offered something like the following (harvested from the <a href="https://github.com/cstrahan/rapi/blob/master/lib/rapi.rb" rel="noreferrer">RAPI</a> gem):</p>

<pre><code>class Enum

  private

  def self.enum_attr(name, num)
    name = name.to_s

    define_method(name + '?') do
      @attrs &amp; num != 0
    end

    define_method(name + '=') do |set|
      if set
        @attrs |= num
      else
        @attrs &amp;= ~num
      end
    end
  end

  public

  def initialize(attrs = 0)
    @attrs = attrs
  end

  def to_i
    @attrs
  end
end
</code></pre>

<p>Which can be used like so:</p>

<pre><code>class FileAttributes &lt; Enum
  enum_attr :readonly,       0x0001
  enum_attr :hidden,         0x0002
  enum_attr :system,         0x0004
  enum_attr :directory,      0x0010
  enum_attr :archive,        0x0020
  enum_attr :in_rom,         0x0040
  enum_attr :normal,         0x0080
  enum_attr :temporary,      0x0100
  enum_attr :sparse,         0x0200
  enum_attr :reparse_point,  0x0400
  enum_attr :compressed,     0x0800
  enum_attr :rom_module,     0x2000
end
</code></pre>

<p>Example:</p>

<pre><code>&gt;&gt; example = FileAttributes.new(3)
=&gt; #&lt;FileAttributes:0x629d90 @attrs=3&gt;
&gt;&gt; example.readonly?
=&gt; true
&gt;&gt; example.hidden?
=&gt; true
&gt;&gt; example.system?
=&gt; false
&gt;&gt; example.system = true
=&gt; true
&gt;&gt; example.system?
=&gt; true
&gt;&gt; example.to_i
=&gt; 7
</code></pre>

<p>This plays well in database scenarios, or when dealing with C style constants/enums (as is the case when using <a href="https://github.com/ffi/ffi/" rel="noreferrer">FFI</a>, which RAPI makes extensive use of).</p>

<p>Also, you don't have to worry about typos causing silent failures, as you would with using a hash-type solution.</p>
<h4> Comment by user1164178, Score: 1, Id: 45344640, created_at: 2015-02-14 06:46:23+00:00 </h4>This is a bit incomplete, but serves as nice hint as to how you might implement solutions with a dynamic approach. It bears some resemblance to a C# enum with the FlagsAttribute set, but like the symbol/constant based solutions above, it&#39;s one answer of many. The problem is the original question, which is muddled in its intent (C# and Java aren&#39;t interchangeable). There are many ways to itemize objects in Ruby; selecting the right one depends on the problem being solved. Slavishly replicating features you don&#39;t need is misguided. The correct answer has to depend on the context.<h4> Comment by mlibby, Score: 1, Id: 11772863, created_at: 2012-02-17 14:21:35+00:00 </h4>That&#39;s a great way to solve that particular problem, but the reason no one suggested it probably has to do with the fact that it&#39;s not much like C#/Java enums.<h4> Comment by Greg Cobb, Score: 0, Id: 130497739, created_at: 2022-09-30 09:27:45+00:00 </h4>One problem with this design, if I&#39;m understanding it correctly, is that unlike something like C#, your solution requires a heap allocation every time you want to use an enum.  That means garbage collection and reduced read times one cache misses.  I like the way it works and how it looks when defining an enum, but I can&#39;t accept unnecessary heap allocations in many scenarios.<hr><h3>  Answer by Alexey, Id: 5675566, Score: 57, created_at: 2011-04-15 10:46:46+00:00 </h3><p>I use the following approach:</p>

<pre><code>class MyClass
  MY_ENUM = [MY_VALUE_1 = 'value1', MY_VALUE_2 = 'value2']
end
</code></pre>

<p>I like it for the following advantages:</p>

<ol>
<li>It groups values visually as one whole</li>
<li>It does some compilation-time checking (in contrast with just using symbols)</li>
<li>I can easily access the list of all possible values: just <code>MY_ENUM</code></li>
<li>I can easily access distinct values: <code>MY_VALUE_1</code></li>
<li>It can have values of any type, not just Symbol</li>
</ol>

<p>Symbols may be better cause you don't have to write the name of outer class, if you are using it in another class (<code>MyClass::MY_VALUE_1</code>)</p>
<h4> Comment by jaynetics, Score: 7, Id: 48007268, created_at: 2015-04-29 12:10:09+00:00 </h4>I think this is the best answer. The functionality, syntax and minimal code overhead come closest to Java/C#. Also you can nest the definitions even deeper than one level and still recover all values with MyClass::MY_ENUM.flatten. As a side note I would use uppercased names here as is the standard for constants in Ruby. MyClass::MyEnum might be mistaken for a reference to a subclass.<h4> Comment by Shelvacu, Score: 2, Id: 54331979, created_at: 2015-10-21 17:18:21+00:00 </h4>I&#39;m still a little confused, and the link 410&#39;d (no, not 404). Could you give examples as to how this enum would be used?<h4> Comment by Alexey, Score: 0, Id: 52931428, created_at: 2015-09-12 08:28:40+00:00 </h4>@Janosch, I&#39;ve updated the names. thanks for suggestion<hr><h3>  Answer by emk, Id: 75801, Score: 52, created_at: 2008-09-16 19:06:04+00:00 </h3><p>The most idiomatic way to do this is to use symbols.  For example, instead of:</p>

<pre><code>enum {
  FOO,
  BAR,
  BAZ
}

myFunc(FOO);
</code></pre>

<p>...you can just use symbols:</p>

<pre><code># You don't actually need to declare these, of course--this is
# just to show you what symbols look like.
:foo
:bar
:baz

my_func(:foo)
</code></pre>

<p>This is a bit more open-ended than enums, but it fits well with the Ruby spirit.</p>

<p>Symbols also perform very well. Comparing two symbols for equality, for example, is much faster than comparing two strings.</p>
<h4> Comment by mxcl, Score: 125, Id: 1047459, created_at: 2009-08-03 14:02:43+00:00 </h4>So the Ruby spirit is: &quot;Typos will compile&quot;<h4> Comment by emk, Score: 93, Id: 1140547, created_at: 2009-08-20 20:14:16+00:00 </h4>Popular Ruby frameworks rely heavily on runtime metaprogramming, and performing too much load-time checking would take away most of Ruby&#39;s expressive power. To avoid problems, most Ruby programmers practice test-driven design, which will find not just typos but also logic errors.<h4> Comment by emk, Score: 11, Id: 2401191, created_at: 2010-03-10 17:51:32+00:00 </h4>@yar: Well, language design is a series of tradeoffs, and language features interact. If you want a good, highly-dynamic language, go with Ruby, write your unit tests first, and go with the spirit of the language. :-) If that&#39;s not what you&#39;re looking for, there are dozens of other excellent languages out there, each of which makes different tradeoffs.<h4> Comment by Dan Rosenstark, Score: 10, Id: 2404228, created_at: 2010-03-10 23:52:05+00:00 </h4>@emk, I agree, but my personal issue is that I feel quite comfortable in Ruby, but I do not feel comfortable refactoring in Ruby. And now that I&#39;ve started writing unit tests (finally), I realize that they are not a panacea: my guess is 1) that Ruby code doesn&#39;t get massively refactored that often, in practice and 2) Ruby is not the end-of-the-line in terms of dynamic languages, precisely because it&#39;s hard to refactor automatically. See my question 2317579 which got taken over, strangely, by the Smalltalk folks.<h4> Comment by Ed Swangren, Score: 4, Id: 2578748, created_at: 2010-04-04 00:11:13+00:00 </h4>Yeah, but using those strings would not be in the spirit of the C# language, it is simply a bad practice.<h4> Comment by Dan Rosenstark, Score: 4, Id: 2606925, created_at: 2010-04-08 08:01:34+00:00 </h4>@emk, thanks for that: so basically you&#39;re replacing compile-time type checks with test-time human-written test code. Except for the fact that the latter is much more comprehensive, it doesn&#39;t sound like a very good tradeoff (more work). But I&#39;ll let you know what I think after a few months of Ruby with tests.<h4> Comment by emk, Score: 2, Id: 2624275, created_at: 2010-04-10 12:32:29+00:00 </h4>@yar, no problem! But even working in static languages, I tend to prefer very comprehensive test suites, because I design my APIs working from the test suites inwards to the actual implementation. So for people who&#39;ve adopted this style, Ruby is literally no extra work—and we get some cool dynamic features, too. (There are some exceptions to this in my experience, particularly higher-order mathematical code in Haskell, where types <i>and</i> tests are invaluable.) Good luck with Ruby!<h4> Comment by emk, Score: 2, Id: 2600868, created_at: 2010-04-07 14:18:13+00:00 </h4>@yar: For Ruby (and similar languages) to be truly usable and refactorable, you really do need excellent test coverage. The easiest way to do this is to never add a feature except to fix a failing test case. This will give near-complete coverage, and it completely transforms the experience of working in a dynamic language. And yes, I&#39;ve done some pretty serious refactorings of Ruby code. They&#39;re a bit harder than Eclipse refactorings, but there&#39;s usually far fewer lines of code, so it balances out.<h4> Comment by mlibby, Score: 2, Id: 2531888, created_at: 2010-03-28 11:20:30+00:00 </h4>@Max, the way Ruby works, what appears to be a typo at compile time may not be a typo at run time. Using symbols in Ruby is merely an idiomatic and performant way to do this. In a language like C, enums are really the only way to solve this problem. But in C# I see lots of people using strings to solve the &quot;named index&quot; problem rather than taking the time to build an enum. Strings have the same &quot;typos will compile&quot; problems as Ruby&#39;s symbols <i>and</i> confounds the IDE&#39;s autocomplete functionality.<h4> Comment by Rokujolady, Score: 2, Id: 22619137, created_at: 2013-04-08 18:43:37+00:00 </h4>Well, since ruby doesn&#39;t compile, I think the ruby way is &quot;Convention over Configuration&quot; which means &quot;We hardcode stuff and you guess what what we hardcoded.&quot;<h4> Comment by Dan Rosenstark, Score: 1, Id: 2365110, created_at: 2010-03-05 14:09:19+00:00 </h4>@emk, thanks for your comment, it really sums up the dynamic-lang crowd&#39;s thought on the thing. While I do think it&#39;s wrong, that&#39;s how it works :)<h4> Comment by Jahan Zinedine, Score: 0, Id: 17523238, created_at: 2012-10-17 09:04:59+00:00 </h4>@MaxHowell Actually there is no compilation, it just would be evaluated and there is nothing wrong with that.<hr><h3>  Answer by Jonke, Id: 164514, Score: 2, created_at: 2008-10-02 20:47:41+00:00 </h3><p>Symbols is the ruby way. However, sometimes one need to talk to some C code or something or Java that expose some enum for various things.</p>

<hr>

<pre><code>#server_roles.rb
module EnumLike

  def EnumLike.server_role
    server_Symb=[ :SERVER_CLOUD, :SERVER_DESKTOP, :SERVER_WORKSTATION]
    server_Enum=Hash.new
    i=0
    server_Symb.each{ |e| server_Enum[e]=i; i +=1}
    return server_Symb,server_Enum
  end

end
</code></pre>

<hr>

<p>This can then be used like this</p>

<hr>

<pre><code>require 'server_roles'

sSymb, sEnum =EnumLike.server_role()

foreignvec[sEnum[:SERVER_WORKSTATION]]=8
</code></pre>

<hr>

<p>This is can of course be made abstract and you can roll our own Enum class </p>
<h4> Comment by Jonke, Score: 1, Id: 6034970, created_at: 2011-03-17 19:55:49+00:00 </h4>@Andrew; this example were taken from a real world thing and the network protocol documentation used xxx_Yyy, so the code in several languages used the same  concept so one could follow changes of specification.<h4> Comment by Andrew Grimm, Score: 1, Id: 6036562, created_at: 2011-03-17 21:48:07+00:00 </h4>Code golfing: <code>server_Symb.each_with_index { |e,i| server_Enum[e] = i}</code>. No need for <code>i = 0</code>.<h4> Comment by Andrew Grimm, Score: 0, Id: 6020096, created_at: 2011-03-16 23:03:29+00:00 </h4>Are you capitalizing the second word in variables (eg <code>server_Symb</code>) for a particular reason? Unless there&#39;s a particular reason, it&#39;s idiomatic for variables to be <code>snake_case_with_all_lower_case</code>, and for symbols to be <code>:lower_case</code>.<hr><h3>  Answer by Vedant Agarwala, Id: 27349423, Score: 19, created_at: 2014-12-08 00:04:22+00:00 </h3><p>If you are using Rails 4.2 or greater you can use Rails enums.</p>

<p>Rails now has enums by default without the need for including any gems.</p>

<p>This is very similar (and more with features) to Java, C++ enums.</p>

<p>Quoted from <a href="http://edgeapi.rubyonrails.org/classes/ActiveRecord/Enum.html" rel="noreferrer">http://edgeapi.rubyonrails.org/classes/ActiveRecord/Enum.html</a> :</p>

<pre><code>class Conversation &lt; ActiveRecord::Base
  enum status: [ :active, :archived ]
end

# conversation.update! status: 0
conversation.active!
conversation.active? # =&gt; true
conversation.status  # =&gt; "active"

# conversation.update! status: 1
conversation.archived!
conversation.archived? # =&gt; true
conversation.status    # =&gt; "archived"

# conversation.update! status: 1
conversation.status = "archived"

# conversation.update! status: nil
conversation.status = nil
conversation.status.nil? # =&gt; true
conversation.status      # =&gt; nil
</code></pre>
<h4> Comment by Gerard, Score: 8, Id: 56077764, created_at: 2015-12-08 20:25:53+00:00 </h4>As you said - not useful if the OP is not using Rails (or more accurately the object is not of type ActiveRecord). Just explaining my downvote is all.<h4> Comment by Adam Lassek, Score: 4, Id: 61759406, created_at: 2016-05-09 06:08:54+00:00 </h4>These are not enums in Ruby, it is an ActiveRecord interface to Enums in your database. Not a generalizable solution that can be applied in any other use-case.<h4> Comment by Vedant Agarwala, Score: 1, Id: 61935838, created_at: 2016-05-13 05:34:21+00:00 </h4>I have aleady mentioned that in my answer.<h4> Comment by theUtherSide, Score: 1, Id: 68438922, created_at: 2016-11-15 04:10:00+00:00 </h4>This is the best answer IFF using Rails.<h4> Comment by prograils, Score: 1, Id: 76623153, created_at: 2017-06-29 09:42:05+00:00 </h4>I don&#39;t like it because it must be stored in a Rails database (to work) and because it allows to create many instances of the <code>Conversation</code> class - I believe it must allow only 1 instance.<hr><h3>  Answer by dB., Id: 5332215, Score: 12, created_at: 2011-03-16 21:46:48+00:00 </h3><p>Check out the ruby-enum gem, <a href="https://github.com/dblock/ruby-enum" rel="noreferrer">https://github.com/dblock/ruby-enum</a>.</p>

<pre><code>class Gender
  include Enum

  Gender.define :MALE, "male"
  Gender.define :FEMALE, "female"
end

Gender.all
Gender::MALE
</code></pre>
<hr><h3>  Answer by Oded Niv, Id: 13764335, Score: 12, created_at: 2012-12-07 13:46:41+00:00 </h3><p>I know it's been a long time since the guy posted this question, but I had the same question and this post didn't give me the answer. I wanted an easy way to see what the number represents, easy comparison, and most of all ActiveRecord support for lookup using the column representing the enum.</p>

<p>I didn't find anything, so I made an awesome implementation called <a href="https://github.com/toplex/enum" rel="noreferrer">yinum</a> which allowed everything I was looking for. Made ton of specs, so I'm pretty sure it's safe.</p>

<p>Some example features:</p>

<pre><code>COLORS = Enum.new(:COLORS, :red =&gt; 1, :green =&gt; 2, :blue =&gt; 3)
=&gt; COLORS(:red =&gt; 1, :green =&gt; 2, :blue =&gt; 3)
COLORS.red == 1 &amp;&amp; COLORS.red == :red
=&gt; true

class Car &lt; ActiveRecord::Base    
  attr_enum :color, :COLORS, :red =&gt; 1, :black =&gt; 2
end
car = Car.new
car.color = :red / "red" / 1 / "1"
car.color
=&gt; Car::COLORS.red
car.color.black?
=&gt; false
Car.red.to_sql
=&gt; "SELECT `cars`.* FROM `cars` WHERE `cars`.`color` = 1"
Car.last.red?
=&gt; true
</code></pre>
<hr><h3>  Answer by johnnypez, Id: 11455651, Score: 11, created_at: 2012-07-12 15:48:35+00:00 </h3><p>This is my approach to enums in Ruby. I was going for short and sweet, not necessarily the the most C-like. Any thoughts?</p>
<pre><code>module Kernel
  def enum(values)
    Module.new do |mod|
      values.each_with_index{ |v,i| mod.const_set(v.to_s.capitalize, 2**i) }

      def mod.inspect
        &quot;#{self.name} {#{self.constants.join(', ')}}&quot;
      end
    end
  end
end

States = enum %w(Draft Published Trashed)
=&gt; States {Draft, Published, Trashed} 

States::Draft
=&gt; 1

States::Published
=&gt; 2

States::Trashed
=&gt; 4

States::Draft | States::Trashed
=&gt; 5
</code></pre>
<hr><h3>  Answer by Daniel Lubarov, Id: 27574382, Score: 9, created_at: 2014-12-19 21:50:52+00:00 </h3><p>Perhaps the best lightweight approach would be</p>

<pre><code>module MyConstants
  ABC = Class.new
  DEF = Class.new
  GHI = Class.new
end
</code></pre>

<p>This way values have associated names, as in Java/C#:</p>

<pre><code>MyConstants::ABC
=&gt; MyConstants::ABC
</code></pre>

<p>To get all values, you can do</p>

<pre><code>MyConstants.constants
=&gt; [:ABC, :DEF, :GHI] 
</code></pre>

<p>If you want an enum's ordinal value, you can do</p>

<pre><code>MyConstants.constants.index :GHI
=&gt; 2
</code></pre>
<h4> Comment by wik, Score: 1, Id: 105059620, created_at: 2019-12-21 16:12:43+00:00 </h4>IMHO this very closely replicates the use and purpose (type safety) from Java, also, as a matter of preference, constants can be defined like this: <code>class ABC; end</code><hr><h3>  Answer by Andrew Grimm, Id: 5332950, Score: 7, created_at: 2011-03-16 23:14:48+00:00 </h3><p>If you're worried about typos with symbols, make sure your code raises an exception when you access a value with a non-existent key. You can do this by using <code>fetch</code> rather than <code>[]</code>:</p>

<pre><code>my_value = my_hash.fetch(:key)
</code></pre>

<p>or by making the hash raise an exception by default if you supply a non-existent key:</p>

<pre><code>my_hash = Hash.new do |hash, key|
  raise "You tried to access using #{key.inspect} when the only keys we have are #{hash.keys.inspect}"
end
</code></pre>

<p>If the hash already exists, you can add on exception-raising behaviour:</p>

<pre><code>my_hash = Hash[[[1,2]]]
my_hash.default_proc = proc do |hash, key|
  raise "You tried to access using #{key.inspect} when the only keys we have are #{hash.keys.inspect}"
end
</code></pre>

<p>Normally, you don't have to worry about typo safety with constants. If you misspell a constant name, it'll usually raise an exception.</p>
<h4> Comment by Teemu Leisti, Score: 0, Id: 27575502, created_at: 2013-09-10 09:06:44+00:00 </h4>It seems you&#39;re advocating emulating enums with <b>hashes</b>, without saying so explicitly. It might be a good idea to edit your answer to say so. (I also currently have a need for something like enums in Ruby, and my first approach to solving it is by using hashes: <code>FOO_VALUES = {missing: 0, something: 1, something_else: 2, ...}</code>. This defines the key symbols <code>missing</code>, <code>something</code>, etc., and also makes them comparable via the associated values.)<h4> Comment by Teemu Leisti, Score: 0, Id: 27576486, created_at: 2013-09-10 09:33:58+00:00 </h4>I mean, without saying so at the very start of the answer.<hr><h3>  Answer by Roger, Id: 45097718, Score: 6, created_at: 2017-07-14 07:58:12+00:00 </h3><p>Another solution is using OpenStruct. Its pretty straight forward and clean.</p>

<p><a href="https://ruby-doc.org/stdlib-2.3.1/libdoc/ostruct/rdoc/OpenStruct.html" rel="noreferrer">https://ruby-doc.org/stdlib-2.3.1/libdoc/ostruct/rdoc/OpenStruct.html</a></p>

<p>Example:</p>

<pre><code># bar.rb
require 'ostruct' # not needed when using Rails

# by patching Array you have a simple way of creating a ENUM-style
class Array
   def to_enum(base=0)
      OpenStruct.new(map.with_index(base).to_h)
   end
end

class Bar

    MY_ENUM = OpenStruct.new(ONE: 1, TWO: 2, THREE: 3)
    MY_ENUM2 = %w[ONE TWO THREE].to_enum

    def use_enum (value)
        case value
        when MY_ENUM.ONE
            puts "Hello, this is ENUM 1"
        when MY_ENUM.TWO
            puts "Hello, this is ENUM 2"
        when MY_ENUM.THREE
            puts "Hello, this is ENUM 3"
        else
            puts "#{value} not found in ENUM"
        end
    end

end

# usage
foo = Bar.new    
foo.use_enum 1
foo.use_enum 2
foo.use_enum 9


# put this code in a file 'bar.rb', start IRB and type: load 'bar.rb'
</code></pre>
<hr><h3>  Answer by mislav, Id: 76722, Score: 4, created_at: 2008-09-16 20:35:24+00:00 </h3><p>It all depends how you use Java or C# enums. How you use it will dictate the solution you'll choose in Ruby.</p>

<p>Try the native <code>Set</code> type, for instance:</p>

<pre><code>&gt;&gt; enum = Set['a', 'b', 'c']
=&gt; #&lt;Set: {"a", "b", "c"}&gt;
&gt;&gt; enum.member? "b"
=&gt; true
&gt;&gt; enum.member? "d"
=&gt; false
&gt;&gt; enum.add? "b"
=&gt; nil
&gt;&gt; enum.add? "d"
=&gt; #&lt;Set: {"a", "b", "c", "d"}&gt;
</code></pre>
<h4> Comment by Dan Rosenstark, Score: 10, Id: 2406789, created_at: 2010-03-11 09:50:38+00:00 </h4>Why not use symbols <code>Set[:a, :b, :c]</code>?<h4> Comment by Collin Graves, Score: 2, Id: 51011068, created_at: 2015-07-20 19:40:37+00:00 </h4>Much better practice to use symbols here, IMO.<hr><h3>  Answer by dlamblin, Id: 612357, Score: 4, created_at: 2009-03-04 20:47:49+00:00 </h3><p>Someone went ahead and wrote a ruby gem called <a href="http://renum.rubyforge.org/" rel="nofollow noreferrer">Renum</a>. It claims to get the closest Java/C# like behavior. Personally I'm still learning Ruby, and I was a little shocked when I wanted to make a specific class contain a static enum, possibly a hash, that it wasn't exactly easily found via google.</p>
<h4> Comment by Chuck, Score: 0, Id: 425036, created_at: 2009-03-04 20:53:36+00:00 </h4>I have never needed an enum in Ruby. Symbols and constants are idiomatic and solve the same problems, don&#39;t they?<h4> Comment by dlamblin, Score: 0, Id: 426098, created_at: 2009-03-05 01:33:29+00:00 </h4>Probably Chuck; but googling for an enum in ruby won&#39;t get you that far. It will show you results for people&#39;s best attempt at a direct equivalent. Which makes me wonder, maybe there&#39;s something nice about having the concept wrapped together.<h4> Comment by David Moles, Score: 0, Id: 46570297, created_at: 2015-03-20 21:44:15+00:00 </h4>@Chuck Symbols and constants don&#39;t enforce, e.g., that a value has to be one of a small set of values.<hr><h3>  Answer by ka8725, Id: 34498312, Score: 4, created_at: 2015-12-28 17:53:47+00:00 </h3><p>Recently we released a <a href="https://github.com/mezuka/enum" rel="nofollow">gem</a> that implements <strong>Enums in Ruby</strong>. In my <a href="http://railsguides.net/safe-enums-in-ruby/" rel="nofollow">post</a> you will find the answers on your questions. Also I described there why our implementation is better than existing ones (actually there are many implementations of this feature in Ruby yet as gems). </p>
<h4> Comment by dimid, Score: 0, Id: 69163515, created_at: 2016-12-05 14:59:45+00:00 </h4>It allows self incrementing values, without stating them explicitly. +1<hr><h3>  Answer by Masuschi, Id: 9482922, Score: 2, created_at: 2012-02-28 13:38:05+00:00 </h3><p>I have implemented enums like that </p>

<pre><code>module EnumType

  def self.find_by_id id
    if id.instance_of? String
      id = id.to_i
    end 
    values.each do |type|
      if id == type.id
        return type
      end
    end
    nil
  end

  def self.values
    [@ENUM_1, @ENUM_2] 
  end

  class Enum
    attr_reader :id, :label

    def initialize id, label
      @id = id
      @label = label
    end
  end

  @ENUM_1 = Enum.new(1, "first")
  @ENUM_2 = Enum.new(2, "second")

end
</code></pre>

<p>then its easy to do operations </p>

<pre><code>EnumType.ENUM_1.label
</code></pre>

<p>...</p>

<pre><code>enum = EnumType.find_by_id 1
</code></pre>

<p>...</p>

<pre><code>valueArray = EnumType.values
</code></pre>
<hr><h3>  Answer by Hossein, Id: 11432676, Score: 2, created_at: 2012-07-11 12:29:01+00:00 </h3><pre><code>module Status
  BAD  = 13
  GOOD = 24

  def self.to_str(status)
    for sym in self.constants
      if self.const_get(sym) == status
        return sym.to_s
      end
    end
  end

end


mystatus = Status::GOOD

puts Status::to_str(mystatus)
</code></pre>

<p>Output:</p>

<pre><code>GOOD
</code></pre>
<hr><h3>  Answer by jjk, Id: 16046129, Score: 2, created_at: 2013-04-16 20:09:44+00:00 </h3><p>This seems a bit superfluous, but this is a methodology that I have used a few times, especially where I am integrating with xml or some such.</p>

<pre><code>#model
class Profession
  def self.pro_enum
    {:BAKER =&gt; 0, 
     :MANAGER =&gt; 1, 
     :FIREMAN =&gt; 2, 
     :DEV =&gt; 3, 
     :VAL =&gt; ["BAKER", "MANAGER", "FIREMAN", "DEV"]
    }
  end
end

Profession.pro_enum[:DEV]      #=&gt;3
Profession.pro_enum[:VAL][1]   #=&gt;MANAGER
</code></pre>

<p>This gives me the rigor of a c# enum and it is tied to the model.</p>
<h4> Comment by jjk, Score: 1, Id: 102434179, created_at: 2019-09-19 16:15:42+00:00 </h4>The exact point is tying yourself to a value that is dictated by third parties. It&#39;s not about extensibility per se, but about having to deal with extraneous constraints that impact computability within your process boundaries.<h4> Comment by DaveMongoose, Score: 1, Id: 102523220, created_at: 2019-09-23 13:23:18+00:00 </h4>Fair point! In that case it definitely makes sense to specify the values, but I&#39;d be inclined to do the reverse lookup with <code>.key</code> or <code>.invert</code> rather than a <code>:VAL</code> key ( <a href="https://stackoverflow.com/a/10989394/2208016">stackoverflow.com/a/10989394/2208016</a> )<h4> Comment by DaveMongoose, Score: 0, Id: 102432743, created_at: 2019-09-19 15:25:18+00:00 </h4>I wouldn&#39;t advise this approach because it relies on you manually setting the values and ensuring you get the order right in <code>:VAL</code>. It would be better to start with an array and construct the hash using <code>.map.with_index</code><h4> Comment by jjk, Score: 0, Id: 103991958, created_at: 2019-11-14 15:38:54+00:00 </h4>Yeah, that is (back at you) a fair point. My ruby was inelegant and unwieldy. Would def use <code>key</code> or <code>invert</code><hr><h3>  Answer by Jan Kr&#252;ger, Id: 75787, Score: 1, created_at: 2008-09-16 19:04:45+00:00 </h3><p>Most people use symbols (that's the <code>:foo_bar</code> syntax). They're sort of unique opaque values. Symbols don't belong to any enum-style type so they're not really a faithful representation of C's enum type but this is pretty much as good as it gets.</p>
<hr><h3>  Answer by dark_src, Id: 32149803, Score: 1, created_at: 2015-08-21 21:54:19+00:00 </h3><p>Sometimes all I need is to be able to fetch enum's value and identify its name similar to java world.</p>

<pre><code>module Enum
     def get_value(str)
       const_get(str)
     end
     def get_name(sym)
       sym.to_s.upcase
     end
 end

 class Fruits
   include Enum
   APPLE = "Delicious"
   MANGO = "Sweet"
 end

 Fruits.get_value('APPLE') #'Delicious'
 Fruits.get_value('MANGO') # 'Sweet'

 Fruits.get_name(:apple) # 'APPLE'
 Fruits.get_name(:mango) # 'MANGO'
</code></pre>

<p>This to me serves the purpose of enum and keeps it very extensible too. You can add more methods to the Enum class and viola get them for free in all the defined enums. for example. get_all_names and stuff like that.</p>
<hr><h3>  Answer by horun, Id: 48199917, Score: 1, created_at: 2018-01-11 04:47:02+00:00 </h3><p>Try the inum.
<a href="https://github.com/alfa-jpn/inum" rel="nofollow noreferrer">https://github.com/alfa-jpn/inum</a></p>

<pre class="lang-js prettyprint-override"><code>class Color &lt; Inum::Base
  define :RED
  define :GREEN
  define :BLUE
end
</code></pre>

<pre class="lang-js prettyprint-override"><code>Color::RED 
Color.parse('blue') # =&gt; Color::BLUE
Color.parse(2)      # =&gt; Color::GREEN
</code></pre>

<p>see more <a href="https://github.com/alfa-jpn/inum#usage" rel="nofollow noreferrer">https://github.com/alfa-jpn/inum#usage</a></p>
<hr><h3>  Answer by Philippe Monnet, Id: 1494092, Score: 0, created_at: 2009-09-29 18:07:32+00:00 </h3><p>Another approach is to use a Ruby class with a hash containing names and values as described in the following <a href="http://www.rubyfleebie.com/enumerations-and-ruby/" rel="nofollow noreferrer">RubyFleebie blog post</a>. This allows you to convert easily between values and constants (especially if you add a class method to lookup the name for a given value).</p>
<hr><h3>  Answer by goreorto, Id: 2573093, Score: 0, created_at: 2010-04-03 23:57:49+00:00 </h3><p>I think the best way to implement enumeration like types is with symbols since the pretty much behave as integer (when it comes to performace, object_id is used to make comparisons  ); you don't need to worry about indexing and they look really neat in your code xD</p>
<hr><h3>  Answer by Anu, Id: 9582957, Score: 0, created_at: 2012-03-06 11:38:10+00:00 </h3><pre><code>irb(main):016:0&gt; num=[1,2,3,4]
irb(main):017:0&gt; alph=['a','b','c','d']
irb(main):018:0&gt; l_enum=alph.to_enum
irb(main):019:0&gt; s_enum=num.to_enum
irb(main):020:0&gt; loop do
irb(main):021:1* puts "#{s_enum.next} - #{l_enum.next}"
irb(main):022:1&gt; end
</code></pre>

<p>Output:</p>

<p>1 - a<br>
2 - b<br>
3 - c<br>
4 - d</p>
<h4> Comment by DaveMongoose, Score: 0, Id: 102432872, created_at: 2019-09-19 15:29:31+00:00 </h4><code>to_enum</code> gives you an enumera <i>tor</i> , whereas <code>enum</code> in the C#/Java sense is an enumera <i>tion</i><hr><h3>  Answer by Daniel Doubleday, Id: 14087590, Score: 0, created_at: 2012-12-30 01:44:43+00:00 </h3><p>Another way to mimic an enum with consistent equality handling (shamelessly adopted from Dave Thomas). Allows open enums (much like symbols) and closed (predefined) enums.</p>

<pre><code>class Enum
  def self.new(values = nil)
    enum = Class.new do
      unless values
        def self.const_missing(name)
          const_set(name, new(name))
        end
      end

      def initialize(name)
        @enum_name = name
      end

      def to_s
        "#{self.class}::#@enum_name"
      end
    end

    if values
      enum.instance_eval do
        values.each { |e| const_set(e, enum.new(e)) }
      end
    end

    enum
  end
end

Genre = Enum.new %w(Gothic Metal) # creates closed enum
Architecture = Enum.new           # creates open enum

Genre::Gothic == Genre::Gothic        # =&gt; true
Genre::Gothic != Architecture::Gothic # =&gt; true
</code></pre>
