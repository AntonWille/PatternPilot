 <h2> Title: The recognizing power of &quot;modern&quot; regexes </h2> <h3> tobyodavies, question_id: 4840988 </h3>Score: 83, Tags: {regex,perl,theory,context-free-grammar,language-theory} <br><p>What class of languages do real modern regexes actually recognise?</p>

<p>Whenever there is an unbounded length capturing group with a back-reference (e.g. <code>(.*)_\1</code>) a regex is now matching a non-regular language. But this, on its own, isn't enough to match something like <code>S ::= '(' S ')' | ε</code> — the context-free language of matching pairs of parens.</p>

<p>Recursive regexes (which are new to me, but I am assured exist in Perl and PCRE) appear to recognize at least most CFLs.</p>

<p>Has anyone done or read any research in this area? What are the limitations of these "modern" regexes? Do they recognize strictly more or strictly less than CFGs, of LL or LR grammars? Or do there exist both languages that can be recognized by a regex but not a CFG <em>and</em> the opposite?</p>

<p>Links to relevant papers would be much appreciated.</p>
<h4> Comment 5374375 arcain: </h4>Would this be better suited to <a href="http://cstheory.stackexchange.com">cstheory.stackexchange.com</a> ?<br><h4> Comment 5375031 tobyodavies: </h4>@arcain, i don&#39;t really consider this a &quot;research level question&quot;, as it is likely to have been done to death... I might try posting it there if i don&#39;t hear anything...<br><h4> Comment 5377770 arcain: </h4>@toby - sure, but it <i>is</i> a theoretical question, and the community at cstheory is a much more specialized audience. There volume is lower also, so there is less chance of your question getting lost in the flood of more easily-answerable ones. I just want to see your question get an answer.<br><h4> Comment 56826636 Anders: </h4>Old post, but I&#39;ve referred to this link several times: <a href="https://nikic.github.io/2012/06/15/The-true-power-of-regular-expressions.html" rel="nofollow noreferrer">nikic.github.io/2012/06/15/&hellip;</a><br><h4> Comment 5374369 tchrist: </h4>I don’t know of any formal work into the computability class of problems solvable by recursive patterns. I do know that your recursive production above is quite easily enough coded up as a recursive pattern in PCRE or Perl.<br><h4> Comment 5377501 tchrist: </h4>@Nylon: Just so all are informed... only the 2nd reference you gave covers recursive regexes using group recursion instead of via code inserts, which is too bad because the 3rd ref is the sort of discussion that @tobyodavies is looking for. However, it might still apply.<br><h4> Comment 5374686 Nylon Smile: </h4>You may want to take a look at these links (all are from Perl community, but contain useful information): <a href="http://perl.plover.com/yak/regex/samples/slide083.html" rel="nofollow noreferrer">perl.plover.com/yak/regex/samples/slide083.html</a> <a href="http://www.perlmonks.org/?node_id=660316" rel="nofollow noreferrer">perlmonks.org/?node_id=660316</a> <a href="http://www.perlmonks.org/?node_id=308283" rel="nofollow noreferrer">perlmonks.org/?node_id=308283</a><br>------------------------------------------------------------------ <br><h3> Answer 4843579 tchrist: </h3><h1>Pattern Recursion</h1>

<p>With recursive patterns, you have a form of recursive descent <em>matching</em>. </p>

<p>This is fine for a variety of problems, but once you want to actually do recursive descent <em>parsing</em>, you need to insert capture groups here and there, and it is awkward to recover the full parse structure in this way.  Damian Conway’s <a href="http://search.cpan.org/~dconway/Regexp-Grammars-1.012/lib/Regexp/Grammars.pm" rel="noreferrer">Regexp::Grammars</a> module for Perl transforms the simple pattern into an equivalent one that automatically does all that named capturing into a recursive data structure, making for far easier retrieval of the parsed structure.  I have a sample comparing these two approaches at end of this posting.</p>

<h1>Restrictions on Recursion</h1>

<p>The question was what kinds of grammars that recursive patterns can match. Well, they’re certainly <a href="http://en.wikipedia.org/wiki/Recursive_descent_parser" rel="noreferrer">recursive descent</a> type matchers. The only thing that comes to mind is that <strong>recursive patterns cannot handle <a href="http://en.wikipedia.org/wiki/Left_recursion" rel="noreferrer">left recursion</a>.</strong> This puts a constraint on the sorts of grammars that you can apply them to. Sometimes you can reorder your productions to eliminate left recursion.</p>

<p>BTW, PCRE and Perl differ slightly on how you’re allowed to phrase the recursion. See the sections on “RECURSIVE PATTERNS” and “Recursion difference from Perl” in the <em>pcrepattern</em> manpage. eg: Perl can handle <code>^(.|(.)(?1)\2)$</code> where PCRE requires <code>^((.)(?1)\2|.)$</code> instead.</p>

<h1>Recursion Demos</h1>

<p>The need for recursive patterns arises surprisingly frequently.  One well-visited example is when you need to match something that can nest, such as balanced parentheses, quotes, or even HTML/XML tags.  Here’s the match for balenced parens:</p>

<pre><code>\((?:[^()]*+|(?0))*\)
</code></pre>

<p>I find that trickier to read because of its compact nature.  This is easily curable with <code>/x</code> mode to make whitespace no longer significant:</p>

<pre><code>\( (?: [^()] *+ | (?0) )* \)
</code></pre>

<p>Then again, since we’re using parens for our recursion, a clearer example would be matching nested single quotes:</p>

<pre><code>‘ (?: [^‘’] *+ | (?0) )* ’
</code></pre>

<p>Another recursively defined thing you may wish to match would be a palindrome.  This simple pattern works in Perl:</p>

<pre><code>^((.)(?1)\2|.?)$
</code></pre>

<p>which you can test on most systems using something like this:</p>

<pre><code>$ perl -nle 'print if /^((.)(?1)\2|.?)$/i' /usr/share/dict/words
</code></pre>

<p>Note that PCRE’s implementation of recursion requires the more elaborate</p>

<pre><code>^(?:((.)(?1)\2|)|((.)(?3)\4|.))
</code></pre>

<p>This is because of restrictions on how PCRE recursion works.</p>

<h1>Proper Parsing</h1>

<p>To me, the examples above are mostly toy matches, not all <em>that</em> interesting, really. When it becomes interesting is when you have a real grammar you’re trying to parse. For example, RFC 5322 defines a mail address rather elaborately.  Here’s a “grammatical” pattern to match it:</p>

<pre><code>$rfc5322 = qr{

   (?(DEFINE)

     (?&lt;address&gt;         (?&amp;mailbox) | (?&amp;group))
     (?&lt;mailbox&gt;         (?&amp;name_addr) | (?&amp;addr_spec))
     (?&lt;name_addr&gt;       (?&amp;display_name)? (?&amp;angle_addr))
     (?&lt;angle_addr&gt;      (?&amp;CFWS)? &lt; (?&amp;addr_spec) &gt; (?&amp;CFWS)?)
     (?&lt;group&gt;           (?&amp;display_name) : (?:(?&amp;mailbox_list) | (?&amp;CFWS))? ; (?&amp;CFWS)?)
     (?&lt;display_name&gt;    (?&amp;phrase))
     (?&lt;mailbox_list&gt;    (?&amp;mailbox) (?: , (?&amp;mailbox))*)

     (?&lt;addr_spec&gt;       (?&amp;local_part) \@ (?&amp;domain))
     (?&lt;local_part&gt;      (?&amp;dot_atom) | (?&amp;quoted_string))
     (?&lt;domain&gt;          (?&amp;dot_atom) | (?&amp;domain_literal))
     (?&lt;domain_literal&gt;  (?&amp;CFWS)? \[ (?: (?&amp;FWS)? (?&amp;dcontent))* (?&amp;FWS)?
                                   \] (?&amp;CFWS)?)
     (?&lt;dcontent&gt;        (?&amp;dtext) | (?&amp;quoted_pair))
     (?&lt;dtext&gt;           (?&amp;NO_WS_CTL) | [\x21-\x5a\x5e-\x7e])

     (?&lt;atext&gt;           (?&amp;ALPHA) | (?&amp;DIGIT) | [!#\$%&amp;'*+-/=?^_`{|}~])
     (?&lt;atom&gt;            (?&amp;CFWS)? (?&amp;atext)+ (?&amp;CFWS)?)
     (?&lt;dot_atom&gt;        (?&amp;CFWS)? (?&amp;dot_atom_text) (?&amp;CFWS)?)
     (?&lt;dot_atom_text&gt;   (?&amp;atext)+ (?: \. (?&amp;atext)+)*)

     (?&lt;text&gt;            [\x01-\x09\x0b\x0c\x0e-\x7f])
     (?&lt;quoted_pair&gt;     \\ (?&amp;text))

     (?&lt;qtext&gt;           (?&amp;NO_WS_CTL) | [\x21\x23-\x5b\x5d-\x7e])
     (?&lt;qcontent&gt;        (?&amp;qtext) | (?&amp;quoted_pair))
     (?&lt;quoted_string&gt;   (?&amp;CFWS)? (?&amp;DQUOTE) (?:(?&amp;FWS)? (?&amp;qcontent))*
                          (?&amp;FWS)? (?&amp;DQUOTE) (?&amp;CFWS)?)

     (?&lt;word&gt;            (?&amp;atom) | (?&amp;quoted_string))
     (?&lt;phrase&gt;          (?&amp;word)+)

     # Folding white space
     (?&lt;FWS&gt;             (?: (?&amp;WSP)* (?&amp;CRLF))? (?&amp;WSP)+)
     (?&lt;ctext&gt;           (?&amp;NO_WS_CTL) | [\x21-\x27\x2a-\x5b\x5d-\x7e])
     (?&lt;ccontent&gt;        (?&amp;ctext) | (?&amp;quoted_pair) | (?&amp;comment))
     (?&lt;comment&gt;         \( (?: (?&amp;FWS)? (?&amp;ccontent))* (?&amp;FWS)? \) )
     (?&lt;CFWS&gt;            (?: (?&amp;FWS)? (?&amp;comment))*
                         (?: (?:(?&amp;FWS)? (?&amp;comment)) | (?&amp;FWS)))

     # No whitespace control
     (?&lt;NO_WS_CTL&gt;       [\x01-\x08\x0b\x0c\x0e-\x1f\x7f])

     (?&lt;ALPHA&gt;           [A-Za-z])
     (?&lt;DIGIT&gt;           [0-9])
     (?&lt;CRLF&gt;            \x0d \x0a)
     (?&lt;DQUOTE&gt;          ")
     (?&lt;WSP&gt;             [\x20\x09])
   )

   (?&amp;address)

}x;
</code></pre>

<p>As you see, that’s very BNF-like.  The problem is it is just a match, not a capture. And you really don’t want to just surround the whole thing with capturing parens because that doesn’t tell you which production matched which part.  Using the previously mentioned Regexp::Grammars module, we can.  </p>

<pre><code>#!/usr/bin/env perl

use strict;
use warnings;
use 5.010;
use Data::Dumper "Dumper";

my $rfc5322 = do {
    use Regexp::Grammars;    # ...the magic is lexically scoped
    qr{

    # Keep the big stick handy, just in case...
    # &lt;debug:on&gt;

    # Match this...
    &lt;address&gt;

    # As defined by these...
    &lt;token: address&gt;         &lt;mailbox&gt; | &lt;group&gt;
    &lt;token: mailbox&gt;         &lt;name_addr&gt; | &lt;addr_spec&gt;
    &lt;token: name_addr&gt;       &lt;display_name&gt;? &lt;angle_addr&gt;
    &lt;token: angle_addr&gt;      &lt;CFWS&gt;? \&lt; &lt;addr_spec&gt; \&gt; &lt;CFWS&gt;?
    &lt;token: group&gt;           &lt;display_name&gt; : (?:&lt;mailbox_list&gt; | &lt;CFWS&gt;)? ; &lt;CFWS&gt;?
    &lt;token: display_name&gt;    &lt;phrase&gt;
    &lt;token: mailbox_list&gt;    &lt;[mailbox]&gt; ** (,)

    &lt;token: addr_spec&gt;       &lt;local_part&gt; \@ &lt;domain&gt;
    &lt;token: local_part&gt;      &lt;dot_atom&gt; | &lt;quoted_string&gt;
    &lt;token: domain&gt;          &lt;dot_atom&gt; | &lt;domain_literal&gt;
    &lt;token: domain_literal&gt;  &lt;CFWS&gt;? \[ (?: &lt;FWS&gt;? &lt;[dcontent]&gt;)* &lt;FWS&gt;?

    &lt;token: dcontent&gt;        &lt;dtext&gt; | &lt;quoted_pair&gt;
    &lt;token: dtext&gt;           &lt;.NO_WS_CTL&gt; | [\x21-\x5a\x5e-\x7e]

    &lt;token: atext&gt;           &lt;.ALPHA&gt; | &lt;.DIGIT&gt; | [!#\$%&amp;'*+-/=?^_`{|}~]
    &lt;token: atom&gt;            &lt;.CFWS&gt;? &lt;.atext&gt;+ &lt;.CFWS&gt;?
    &lt;token: dot_atom&gt;        &lt;.CFWS&gt;? &lt;.dot_atom_text&gt; &lt;.CFWS&gt;?
    &lt;token: dot_atom_text&gt;   &lt;.atext&gt;+ (?: \. &lt;.atext&gt;+)*

    &lt;token: text&gt;            [\x01-\x09\x0b\x0c\x0e-\x7f]
    &lt;token: quoted_pair&gt;     \\ &lt;.text&gt;

    &lt;token: qtext&gt;           &lt;.NO_WS_CTL&gt; | [\x21\x23-\x5b\x5d-\x7e]
    &lt;token: qcontent&gt;        &lt;.qtext&gt; | &lt;.quoted_pair&gt;
    &lt;token: quoted_string&gt;   &lt;.CFWS&gt;? &lt;.DQUOTE&gt; (?:&lt;.FWS&gt;? &lt;.qcontent&gt;)*
                             &lt;.FWS&gt;? &lt;.DQUOTE&gt; &lt;.CFWS&gt;?

    &lt;token: word&gt;            &lt;.atom&gt; | &lt;.quoted_string&gt;
    &lt;token: phrase&gt;          &lt;.word&gt;+

    # Folding white space
    &lt;token: FWS&gt;             (?: &lt;.WSP&gt;* &lt;.CRLF&gt;)? &lt;.WSP&gt;+
    &lt;token: ctext&gt;           &lt;.NO_WS_CTL&gt; | [\x21-\x27\x2a-\x5b\x5d-\x7e]
    &lt;token: ccontent&gt;        &lt;.ctext&gt; | &lt;.quoted_pair&gt; | &lt;.comment&gt;
    &lt;token: comment&gt;         \( (?: &lt;.FWS&gt;? &lt;.ccontent&gt;)* &lt;.FWS&gt;? \)
    &lt;token: CFWS&gt;            (?: &lt;.FWS&gt;? &lt;.comment&gt;)*
                             (?: (?:&lt;.FWS&gt;? &lt;.comment&gt;) | &lt;.FWS&gt;)

    # No whitespace control
    &lt;token: NO_WS_CTL&gt;       [\x01-\x08\x0b\x0c\x0e-\x1f\x7f]
    &lt;token: ALPHA&gt;           [A-Za-z]
    &lt;token: DIGIT&gt;           [0-9]
    &lt;token: CRLF&gt;            \x0d \x0a
    &lt;token: DQUOTE&gt;          "
    &lt;token: WSP&gt;             [\x20\x09]
    }x;
};

while (my $input = &lt;&gt;) {
    if ($input =~ $rfc5322) {
        say Dumper \%/;       # ...the parse tree of any successful match
                              # appears in this punctuation variable
    }
}
</code></pre>

<p>As you see, by using a very slightly different notation in the pattern, you now get something which stores the entire parse tree away for you in the <code>%/</code> variable, with everything neatly labelled. The result of the transformation is still a pattern, as you can see by the <code>=~</code> operator. It’s just a bit magical.</p>
<h4> Comment 5387650 tchrist: </h4>@tobyodavies: I could have explained the PCRE restrictions further; they have to do with atomicity of groups: you cannot invoke recursion on a group that hasn&#39;t been completed yet in PCRE but you can in Perl. The grammatical RFC 5322 pattern should work equally well in PCRE; the whole <code>((DEFINE)…)</code> idea is <b>extremely powerful</b> and useful, allowing for separation of declaration (and its ordering) from execution, just like all top-down programming. I can&#39;t recall which other languages have group recursion; it may be something exotic like C♯ or its ilk.<br><h4> Comment 5381918 hobbs: </h4>The limitation on left-recursion is definitely worth knowing about, but if I remember properly, it doesn&#39;t have an effect on &quot;recognizing power&quot; strictly, since for any left-recursive grammar, there&#39;s a right-recursive grammar that matches the same language -- it just might be a lot more cumbersome.<br>