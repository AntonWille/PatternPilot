 <h2> Title: Command line: search and replace in all filenames matched by grep </h2> <h4> Michael Kristofik, question_id: 471183, created_at: 2009-01-22 22:54:15+00:00 </h4>Score: 80, Tags: {linux,perl,awk,sed,grep} <br><p>I'm trying to search and replace a string in all files matched by grep:</p>
<p><code>grep -n 'foo' *</code> will give me output in the form:</p>
<pre><code>[filename]:[line number]:[text]
</code></pre>
<p>For each file returned by grep, I'd like to modify the file by replacing <code>foo</code> with <code>bar</code>.</p>
<hr><h3>  Answer by MattJ, Id: 471560, Score: 108, created_at: 2009-01-23 01:41:57+00:00 </h3><p>This appears to be what you want, based on the example you gave:</p>

<pre><code>sed -i 's/foo/bar/g' *
</code></pre>

<p>It is not recursive (it will not descend into subdirectories). For a nice solution replacing in selected files throughout a tree I would use find:</p>

<pre><code>find . -name '*.html' -print -exec sed -i.bak 's/foo/bar/g' {} \;
</code></pre>

<p>The <code>*.html</code> is the expression that files must match, the <code>.bak</code> after the <code>-i</code> makes a copy of the original file, with a .bak extension (it can be any extension you like) and the <code>g</code> at the end of the sed expression tells sed to replace multiple copies on one line (rather than only the first one). The <code>-print</code> to find is a convenience to show which files were being matched. All this depends on the exact versions of these tools on your system.</p>
<h4> Comment by MattJ, Score: 4, Id: 28086933, created_at: 2013-09-25 16:41:15+00:00 </h4>@knocte -i tells sed to modify the file, otherwise it just prints the modified version to stdout. If you don&#39;t want the .bak file created, just omit the &#39;.bak&#39; part, -i works standalone too.<h4> Comment by Michiel Kauw-A-Tjoe, Score: 2, Id: 37555726, created_at: 2014-06-19 08:06:52+00:00 </h4>On OSX you need to give the <code>find</code> command a directory to start from, for example <code>find . -name &#39;*.html&#39;</code> or <code>find directoryname&#47; -name &#39;*&#39;</code>.<h4> Comment by kaskelotti, Score: 1, Id: 26537152, created_at: 2013-08-08 10:30:31+00:00 </h4>A word of warning for cygwin users. find and sed combo seems to change the user rights for the files that are streamed through. This can be simply fixed by using the command chmod -R 644 * from the same dir level that was used when find/sed was operated.<h4> Comment by knocte, Score: 0, Id: 28079783, created_at: 2013-09-25 13:41:33+00:00 </h4>A word of warning to the people that don&#39;t want to use the -i argument: if you don&#39;t use it, it doesn&#39;t work (don&#39;t ask me why)<h4> Comment by KrishPrabakar, Score: 0, Id: 106596719, created_at: 2020-02-17 13:51:45+00:00 </h4>Is &quot;foo&quot;, &quot;bar&quot; are just words (for exact match) or a regex?<h4> Comment by MattJ, Score: 0, Id: 106703442, created_at: 2020-02-20 13:49:12+00:00 </h4>@KrishPrabakar regex<h4> Comment by vish, Score: 0, Id: 40657269, created_at: 2014-09-22 04:36:15+00:00 </h4>i needed to add a -e, otherwise it thought the &#39;s...&#39; part was the suffix <code>sed -ie &#39;s&#47;foo&#47;bar&#47;g&#39; *</code><hr><h3> ✔️ Answer by armandino, Id: 471192, Score: 71, created_at: 2009-01-22 22:57:36+00:00 </h3><p>Do you mean search and replace a string in all files matched by grep?</p>

<pre><code>perl -p -i -e 's/oldstring/newstring/g' `grep -ril searchpattern *`
</code></pre>

<p><strong>Edit</strong></p>

<p>Since this seems to be a fairly popular question thought I'd update.</p>

<p>Nowadays I mostly use <code>ack-grep</code> as it's more user-friendly. So the above command would be:</p>

<pre><code>perl -p -i -e 's/old/new/g' `ack -l searchpattern`
</code></pre>

<p>To handle whitespace in file names you can run:</p>

<pre><code>ack --print0 -l searchpattern | xargs -0 perl -p -i -e 's/old/new/g'
</code></pre>

<p>you can do more with <code>ack-grep</code>. Say you want to restrict the search to HTML files only:</p>

<pre><code>ack --print0 --html -l searchpattern | xargs -0 perl -p -i -e 's/old/new/g'
</code></pre>

<p>And if white space is not an issue it's even shorter:</p>

<pre><code>perl -p -i -e 's/old/new/g' `ack -l --html searchpattern`
perl -p -i -e 's/old/new/g' `ack -f --html` # will match all html files
</code></pre>
<h4> Comment by Xeoncross, Score: 3, Id: 10380797, created_at: 2011-12-06 20:07:12+00:00 </h4>I think this might have a problem with files/folders that contain spaces. <code>Can&#39;t open Untitled: No such file or directory, &lt;&gt; line 5</code> when trying &quot;Untitled Folder/file.txt&quot;.<hr><h3>  Answer by Keltia, Id: 471203, Score: 14, created_at: 2009-01-22 22:59:28+00:00 </h3><p>If your <code>sed(1)</code> has a <code>-i</code> option, then use it like this:</p>

<pre><code>for i in *; do
  sed -i 's/foo/bar/' $i
done
</code></pre>

<p>If not, there are several ways variations on the following depending on which language you want to play with:</p>

<pre><code>ruby -i.bak -pe 'sub(%r{foo}, 'bar')' *
perl -pi.bak -e 's/foo/bar/' *
</code></pre>
<h4> Comment by Jens, Score: 2, Id: 14126370, created_at: 2012-06-01 08:46:24+00:00 </h4><code>for i in *; do ...</code> is redundant, sed can take a list of files as arguments.<h4> Comment by Magpie, Score: 2, Id: 37756606, created_at: 2014-06-25 11:43:48+00:00 </h4>@Jens why not improve this answer by adding your own example to the one above?<h4> Comment by cat, Score: 0, Id: 63854808, created_at: 2016-07-06 02:50:36+00:00 </h4>Variables should always be quoted <code>for i in *; do; sed -i &#39;s&#47;foo&#47;bar&#47;g&#39; &quot;$i&quot;; done</code><hr><h3>  Answer by hans, Id: 3292996, Score: 6, created_at: 2010-07-20 18:14:03+00:00 </h3><p>I like and used the above solution or a system wide search and replace among thousands of files:</p>

<pre><code>find -name '*.htm?' -print -exec sed -i.bak 's/foo/bar/g' {} \;
</code></pre>

<p>I assume with the '*.htm?' instead of .html it searches and finds .htm and .html files alike.</p>

<p>I replace the .bak with the more system wide used tilde (~) to make clean up of backup files easier.</p>
<hr><h3>  Answer by pymarco, Id: 20721349, Score: 4, created_at: 2013-12-21 16:58:47+00:00 </h3><p>This works using grep without needing to use perl or find.</p>

<pre><code>grep -rli 'old-word' * | xargs -i@ sed -i 's/old-word/new-word/g' @
</code></pre>
<h4> Comment by Tony Adams, Score: 0, Id: 42025604, created_at: 2014-11-03 15:48:50+00:00 </h4>xargs does not have a -i on OSX or BSD <a href="http://www.openbsd.org/cgi-bin/man.cgi/OpenBSD-current/man1/xargs.1?query=xargs&amp;sec=1" rel="nofollow noreferrer">openbsd.org/cgi-bin/man.cgi/OpenBSD-current/man1/&hellip;</a> did you mean to use an upper case &quot;I&quot; ?<h4> Comment by pymarco, Score: 0, Id: 42026456, created_at: 2014-11-03 16:09:53+00:00 </h4>I didn&#39;t know <code>-i</code> didn&#39;t work for other OS&#39;s. Works for me on ubuntu.<h4> Comment by Max Wallace, Score: 0, Id: 63498012, created_at: 2016-06-25 13:22:38+00:00 </h4>My <code>xargs</code> manpage (on Ubuntu) says that <code>-i</code> is deprecated, and to use <code>-I</code> instead. So, we should say: <code>grep -rli &#39;old-word&#39; * | xargs -I filepath sed -i &#39;s&#47;old-word&#47;new-word&#47;g&#39; filepath</code><hr><h3>  Answer by koolb, Id: 8342282, Score: 3, created_at: 2011-12-01 13:40:56+00:00 </h3><p><code>find . -type f -print0 | xargs -0 &lt;sed/perl/ruby cmd&gt;</code> will process multiple space contained file names at once loading one interpreter per batch. Much faster.</p>
<h4> Comment by Tony Adams, Score: 0, Id: 42025463, created_at: 2014-11-03 15:44:49+00:00 </h4>@knocte, &quot;cmd&quot; is a token for the entire search and replace command for whichever given tool one chooses. This answer answers the question about how to deal with the white-space contained file names.<hr><h3>  Answer by jlevy, Id: 29191591, Score: 1, created_at: 2015-03-22 06:15:52+00:00 </h3><p>The answer already given of using <strong>find</strong> and <strong>sed</strong></p>

<p><code>find -name '*.html' -print -exec sed -i.bak 's/foo/bar/g' {} \;</code></p>

<p>is probably the standard answer. Or you could use <code>perl -pi -e s/foo/bar/g'</code> instead of the <code>sed</code> command.</p>

<p>For most quick uses, you may find the command <strong>rpl</strong> is easier to remember. Here is replacement (foo -> bar), recursively on all files in the current directory:</p>

<p><code>rpl -R foo bar .</code></p>

<p>It's not available by default on most Linux distros but is quick to install (<code>apt-get install rpl</code> or similar).</p>

<p>However, for tougher jobs that involve regular expressions and back substitution, or file renames as well as search-and-replace, the most general and powerful tool I'm aware of is <strong>repren</strong>, a small Python script I wrote a while back for some thornier renaming and refactoring tasks. The reasons you might prefer it are:</p>

<ul>
<li>Support renaming of files as well as search-and-replace on file contents (including moving files between directories and creating new parent directories).</li>
<li>See changes before you commit to performing the search and replace.</li>
<li>Support regular expressions with back substitution, whole words, case insensitive, and case preserving (replace foo -> bar, Foo -> Bar, FOO -> BAR) modes.</li>
<li>Works with multiple replacements, including swaps (foo -> bar and bar -> foo) or sets of non-unique replacements (foo -> bar, f -> x).</li>
</ul>

<p><a href="https://github.com/jlevy/repren" rel="nofollow">Check the README</a> for examples.</p>
<hr><h3>  Answer by siliconrockstar, Id: 33794818, Score: 1, created_at: 2015-11-19 03:35:32+00:00 </h3><p>This is actually easier than it seems.</p>

<pre><code>grep -Rl 'foo' ./ | xargs -n 1 -I % sh -c "ls %; sed -i 's/foo/bar/g' %";
</code></pre>

<ul>
<li>grep recurses through your tree (-R) and prints just the file name (-l), starting at the current directory (./)</li>
<li>that gets piped to xargs, which processes them one at a time (-n 1), and uses % as a placeholder (-I %) in a shell command (sh -c)</li>
<li>in the shell command, first the file name is printed (ls %;)</li>
<li>then sed does an inline operation (-i), a substution('s/') of foo with bar (foo/bar), globally (/g) on the file (again, represented by %)</li>
</ul>

<p>Easy peasy.  If you get a good grasp on find, grep, xargs, sed, and awk, almost nothing is impossible when it comes to text file manipulation in bash :)</p>
<h4> Comment by siliconrockstar, Score: 0, Id: 55356282, created_at: 2015-11-19 03:37:51+00:00 </h4>Bah, disregard, this pymarco already covered this above.  Leaving my answer for the explanation.<hr><h3>  Answer by jian, Id: 70693991, Score: 0, created_at: 2022-01-13 09:14:37+00:00 </h3><p>2022 answer.<br />
<a href="https://github.com/BurntSushi/ripgrep/blob/master/FAQ.md#how-can-i-search-and-replace-with-ripgrep" rel="nofollow noreferrer">https://github.com/BurntSushi/ripgrep/blob/master/FAQ.md#how-can-i-search-and-replace-with-ripgrep</a></p>
<pre><code>rg foo --files-with-matches | xargs sed -i 's/foo/bar/g'
</code></pre>
<p>will replace all instances of 'foo' with 'bar' in the files in which ripgrep finds the foo pattern. The -i flag to sed indicates that you are editing files in place, and s/foo/bar/g says that you are performing a substitution of the pattern foo for bar, and that you are doing this substitution globally (all occurrences of the pattern in each file).</p>
