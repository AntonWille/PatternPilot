 <h2> Title: Perl flags -pe, -pi, -p, -w, -d, -i, -t? </h2> <h3> Tudor Constantin, question_id: 6302025 </h3>Score: 132, Tags: {perl,command-line,flags} <br><p>I have seen lots of ways of running Perl code or scripts, with different flags. However, when I try to google for what each flag means, I mainly get results to generic Perl sites and no specific information regarding the flags or their use is found there.</p>

<p>Below are the flags that I encounter most often, and I don't have a clue what they mean:</p>

<ul>
<li>perl <strong>-pe</strong></li>
<li>perl <strong>-pi</strong></li>
<li>perl <strong>-p</strong></li>
<li>perl <strong>-w</strong></li>
<li>perl <strong>-d</strong></li>
<li>perl <strong>-i</strong></li>
<li>perl <strong>-t</strong></li>
</ul>

<p>I will be very grateful if you tell me what each of those mean and some use cases for them, or at least tell me a way of finding out their meaning.</p>
<h4> Comment 7362595 ysth: </h4>googling for basic answers about perl will often lead you to some really unhelpful sites.  always check perl&#39;s own documentation first.<br><h4> Comment 82510746 Roger Krueger: </h4>Google problem: The minus sign is interpreted by Google as meaning &quot;exclude this term.&quot; To avoid this behavior place the term containing the minus sign in quotes.<br><h4> Comment 7397073 Sherm Pendley: </h4>Seconded. In this case, <code>perldoc perlrun</code> has a list of all the command-line options Perl accepts.<br><h4> Comment 47493291 Dave Cross: </h4><a href="http://www.perl.com/pub/2004/08/09/commandline.html" rel="nofollow noreferrer">Useful guide to some of Perl&#39;s command line options</a> over on perl.com.<br>------------------------------------------------------------------ <br><h3> Answer 6302045 paxdiablo: </h3><p>Yes, Google is notoriously difficult for looking up punctuation and, unfortunately, Perl <em>does</em> seem to be mostly made up of punctuation :-)</p>
<p>The command line switches are all detailed in <a href="http://perldoc.perl.org/perlrun.html" rel="noreferrer">perlrun</a> (available from the command line by calling <code>perldoc perlrun</code>). Going into the options briefly, one-by-one:</p>
<ul>
<li><code>-p</code>: Places a printing loop around your command so that it acts on each line of standard input. Used mostly so Perl can beat the pants off Awk in terms of power AND simplicity :-)</li>
<li><code>-n</code>: Places a non-printing loop around your command.</li>
<li><code>-e</code>: Allows you to provide the program as an argument rather than in a file. You don't want to have to create a script file for every little Perl one-liner.</li>
<li><code>-i</code>: Modifies your input file in-place (making a backup of the original). Handy to modify files without the <code>{copy, delete-original, rename}</code> process.</li>
<li><code>-w</code>: Activates some warnings. Any good Perl coder will use this.</li>
<li><code>-d</code>: Runs under the Perl debugger. For debugging your Perl code, obviously.</li>
<li><code>-t</code>: Treats certain &quot;tainted&quot; (dubious) code as warnings (proper taint mode will error on this dubious code). Used to beef up Perl security, especially when running code for other users, such as setuid scripts or web stuff.</li>
</ul>
<h4> Comment 7365142 plusplus: </h4><code>-w</code> is generally avoided, but it should be replaced with <code>use warnings</code> in your own code.<br><h4> Comment 7397081 Sherm Pendley: </h4>@duskwuff: In general I agree, and I do <code>use warnings</code> in my own code, but -w does have a use - it helps weed out poorly-written CPAN modules. :-)<br><h4> Comment 7362754 user149341: </h4><code>-w</code> is generally to be avoided, actually, as it enables warnings for <b>all</b> code, including CPAN modules which weren&#39;t written with warnings in mind. The results are generally pretty noisy, as well as pretty useless.<br><h4> Comment 62293240 tjd: </h4>@IanBytchek Arguments that may/must take an additional parameter can&#39;t be inside a compressed list.  <code>-i</code> takes an extension for the backup.  <code>-e</code> takes a perl command.  In <code>-0ep</code>  you are telling perl that &#39;p&#39; is a perl command instead of an argument.  That won&#39;t work out well at all.<br><h4> Comment 7362431 Alan Haggai Alavi: </h4>I did not notice that you referred to <code>perldoc perlrun</code>. I have deleted my answer. :-)<br><h4> Comment 42794745 Ian Bytchek: </h4>Can you enlighten about the order of the flags? If I do <code>perl -i -0pe</code> everything works as expected, if I do <code>perl -i -0ep</code> it doesn&#39;t, if I change other flags order, it also breaks. What&#39;s the deal with that? I&#39;m very confusedâ€¦<br>------------------------------------------------------------------ <br><h3> Answer 6302065 zellio: </h3><p>The <code>-p</code> flag basically runs the script with</p>
<pre><code>while (&lt;&gt;) {
# exec here
}
continue {
    print or die &quot;-p destination: $!\n&quot;;
}
</code></pre>
<p><code>-e</code> allows you to pass a script to as a parameter rather than as a file:</p>
<pre><code>perl -e '$x = &quot;Hello world!\n&quot;; print $x;'
</code></pre>
<p><code>-i</code> directs the interpreter that all data passed to <code>STDIN</code> by the executing script is to be done inplace.</p>
<p><code>-w</code> is the same as <code>use warnings;</code>, but in a global rather than local scope</p>
<p><code>-d</code> runs the Perl debugger</p>
<h4> Comment 7365255 plusplus: </h4><code>-w</code> is not quite the same as <code>use warnings</code>, the latter is scoped to the local file<br><h4> Comment 7372188 William Pursell: </h4>Passing the script as an argument is not the same as passing it on STDIN.   -i takes file names from the argument list, not stdin.  While STDIN is often associated with the controlling terminal, and is inherited from the shell that reads stdin and sets up the argument list to perl, they are NOT the same thing.<br><h4> Comment 7369231 zellio: </h4>plusplus, true, patching answer.<br>------------------------------------------------------------------ <br><h3> Answer 6325612 liame: </h3><p>Other have mentioned perlrun. If you use B::Deparse, you can <strong>see</strong> what it means (for most things):</p>

<pre><code>$ perl -MO=Deparse   -p  -e 1
LINE: while (defined($_ = &lt;ARGV&gt;)) {
    '???';
}
continue {
    die "-p destination: $!\n" unless print $_;
}
-e syntax OK
</code></pre>

<p>1 is represented by '???', because it is optimized away.</p>

<pre><code>$ perl -MO=Deparse   -p -i  -e 1
BEGIN { $^I = ""; }
LINE: while (defined($_ = &lt;ARGV&gt;)) {
    '???';
}
continue {
    die "-p destination: $!\n" unless print $_;
}
-e syntax OK
</code></pre>

<p>-i sets $^I, like</p>

<pre><code>$ perl -MO=Deparse   -p -i.bak  -e 1
BEGIN { $^I = ".bak"; }
LINE: while (defined($_ = &lt;ARGV&gt;)) {
    '???';
}
continue {
    die "-p destination: $!\n" unless print $_;
}
-e syntax OK
</code></pre>

<p>But remember, &lt;ARGV&gt; uses 2-argument open, so don't have filenames that start with <code>&gt; &lt;</code> or start/end with <code>|</code>.</p>
------------------------------------------------------------------ <br><h3> Answer 37390329 rustyx: </h3><p>There is also one important flag <code>-n</code> which is not mentioned in the list.</p>

<p><code>-n</code> works the same as <code>-p</code>, only it does not print <code>$_</code> by default. This can be very useful in filtering text files.</p>

<p>In this way Perl can replace <code>grep | sed</code> in a single one-liner.</p>

<p>For example:</p>

<p><code>perl -ne 'print "$1\n" if /Messages read: (\d+)/' &lt;my_input.txt</code></p>

<p>Will print out every integer value found after "Messages read: ", and nothing more.</p>
<h4> Comment 74756238 devoured elysium: </h4>This can be further simplified. There&#39;s no need for the &quot;print &quot;$1\n&quot;&quot;. You can just use &quot;print&quot; instead.<br><h4> Comment 74789127 rustyx: </h4>No it can&#39;t, <code>print $1</code> is not the same as <code>print</code> (<code>print $_</code>).<br><h4> Comment 74819567 devoured elysium: </h4>It can:  <code>echo abc | perl -nw -e &quot;print if (1)&quot;</code> will print <code>abc</code>. No need for the <code>$1</code> reference.<br><h4> Comment 84459906 Ingo Blechschmidt: </h4>@devouredelysium: Yes, but doesn&#39;t want to print the whole line, but only the number matched by the regular expression.<br>