 <h2> Title: Should I use alias or alias_method? </h2> <h4> ma11hew28, question_id: 4763121 </h4>Score: 370, Tags: {ruby,alias} <br><p>I found a blog post on <code>alias</code> vs. <code>alias_method</code>. As shown in the example given in that blog post, I simply want to alias a method to another within the same class. Which should I use? I always see <code>alias</code> used, but someone told me <code>alias_method</code> is better.</p>

<p><strong>Usage of alias</strong></p>

<pre><code>class User

  def full_name
    puts "Johnnie Walker"
  end

  alias name full_name
end

User.new.name #=&gt;Johnnie Walker
</code></pre>

<p><strong>Usage of alias_method</strong></p>

<pre><code>class User

  def full_name
    puts "Johnnie Walker"
  end

  alias_method :name, :full_name
end

User.new.name #=&gt;Johnnie Walker
</code></pre>

<p><a href="http://blog.bigbinary.com/2012/01/08/alias-vs-alias-method.html" rel="noreferrer">Blog post link here</a></p>
<h4> jtzero, Id: 66601760 Score: 6: </h4>The ruby style guide now recommends <code>alias</code> &quot;when aliasing methods in lexical class scope&quot; and <code>alias_method</code> &quot;when aliasing methods of modules, classes, or singleton classes at runtime&quot; <a href="https://github.com/bbatsov/ruby-style-guide#alias-method-lexically" rel="nofollow noreferrer">github.com/bbatsov/ruby-style-guide#alias-method-lexically</a><br><h4> Boris Stitnicky, Id: 17991677 Score: 5: </h4>@marcog: I&#39;ve read it through, and I&#39;m not convinced. Defining aliases inside methods, that&#39;s not something one should do often.<br><h4> moinudin, Id: 5269822 Score: 4: </h4>Doesn&#39;t that post answer your question?<br><h4> lukas.pukenis, Id: 27994769 Score: 2: </h4>@digitalextremist link works<br>------------------------------------------------------------------ <br><h3> Jacob Relkin, Id: 4763178, Score: 388: </h3><p><code>alias_method</code> can be redefined if need be. (it's defined in the <code>Module</code> class.)</p>

<p><code>alias</code>'s behavior changes depending on its scope and can be quite unpredictable at times.</p>

<p>Verdict: Use <code>alias_method</code> - it gives you a ton more flexibility.</p>

<p>Usage:</p>

<pre><code>def foo
  "foo"
end

alias_method :baz, :foo
</code></pre>
<h4> Boris Stitnicky, Comment 17991644 Score: 47: </h4>What do you mean by unpredictable. Na&#239;vely, one would say that the option that is less flexible will be more predictable. Also, can you provide any practical example of benefitting from redefining alias_method?<br><h4> Daniel Rikowski, Comment 70344165 Score: 16: </h4>One could argue the same for <code>def</code> vs. <code>define_method</code>: &quot;<code>define_method</code> can be redefined if need be. (it&#39;s defined in the <code>Module</code> class.) <code>def</code>&#39;s behavior changes depending on its scope and can be quite unpredictable at times. Verdict: Use <code>define_method</code> - it gives you a ton more flexibility.&quot;<br><h4> Joshua Pinter, Comment 35530584 Score: 13: </h4>The word he&#39;s looking for here is more <b>expected</b> results. <code>alias_method</code> is determined at runtime and not when the code is read, like <code>alias</code>, so it behaves more how we would <b>expect</b> it to.<br><h4> boulder_ruby, Comment 19002559 Score: 7: </h4>example use case: <code>alias :new_method_name :old_method_name</code> OR <code>alias_method :new_method_name, :old_method_name</code><br><h4> akostadinov, Comment 38316144 Score: 4: </h4>expecting that methods are defined on the fly during runtime is not what most programmers expect. At least it&#39;s like flying pigs to me.<br><h4> ablarg, Comment 61181492 Score: 0: </h4>akostadinov, I agree, although more flexible it certainly fails to follow the principle of least surprise.<br><h4> Nakilon, Comment 131816601 Score: 0: </h4>Never run for &quot;flexibility&quot; until it&#39;s impossible to avoid. One of the unwritten rules of good coding.<br>------------------------------------------------------------------ <br><h3> Darme, Id: 27310250, Score: 92: </h3><p>Apart from the syntax, <strong>the main difference is in the scoping</strong>:</p>

<pre><code># scoping with alias_method
class User

  def full_name
    puts "Johnnie Walker"
  end

  def self.add_rename
    alias_method :name, :full_name
  end

end

class Developer &lt; User
  def full_name
    puts "Geeky geek"
  end
  add_rename
end

Developer.new.name #=&gt; 'Geeky geek'
</code></pre>

<p>In the above case method “name” picks the method “full_name” defined in “Developer” class. Now lets try with <code>alias</code>.</p>

<pre><code>class User

  def full_name
    puts "Johnnie Walker"
  end

  def self.add_rename
    alias name full_name
  end
end

class Developer &lt; User
  def full_name
    puts "Geeky geek"
  end
  add_rename
end

Developer.new.name #=&gt; 'Johnnie Walker'
</code></pre>

<p>With the usage of alias the method “name” is not able to pick the method “full_name” defined in Developer.</p>

<p>This is because <code>alias</code> is a keyword and it is lexically scoped. It means it treats <code>self</code> as the value of self at the time the source code was read . In contrast <code>alias_method</code> treats <code>self</code> as the value determined at the run time.</p>

<p>Source: <a href="http://blog.bigbinary.com/2012/01/08/alias-vs-alias-method.html" rel="noreferrer">http://blog.bigbinary.com/2012/01/08/alias-vs-alias-method.html</a></p>
<h4> NobodysNightmare, Comment 113407548 Score: 3: </h4>Since this answer gives an actual example on the impact of scope, I like it much better than the accepted answer.<br>------------------------------------------------------------------ <br><h3> Bruno Roh&#233;e, Id: 5184851, Score: 39: </h3><p>A point in favor of <code>alias</code> instead of <code>alias_method</code> is that its semantic is recognized by rdoc, leading to neat cross references in the generated documentation, while rdoc completely ignore <code>alias_method</code>.</p>
<h4> Szymon Jeż, Comment 8768117 Score: 60: </h4>Maybe RDoc should start treating alias_method the same as alias. We should tell them about it ;)<br><h4> user1115652, Comment 36108563 Score: 9: </h4>How is RDoc supposed to understand the consequences of a method that is evaluated at runtime?<br><h4> iconoclast, Comment 96065922 Score: 2: </h4>@user1115652 Is your point that someone <i>might have</i> monkey-patched <code>alias_method</code>?  That seems <i>really</i> unlikely, and if someone does that, then they should be willing to suffer the consequences in RDoc.  If your point is that it&#39;s impossible, then why do you think that and how do you think Yardoc does it?<br>------------------------------------------------------------------ <br><h3> agenty, Id: 20538816, Score: 37: </h3><p>I think there is an unwritten rule (something like a convention) that says to use 'alias' just for registering a method-name alias, means if you like to give the user of your code one method with more than one name:</p>

<pre><code>class Engine
  def start
    #code goes here
  end
  alias run start
end
</code></pre>

<p>If you need to extend your code, use the ruby meta alternative.</p>

<pre><code>class Engine
  def start
    puts "start me"
  end
end

Engine.new.start() # =&gt; start me

Engine.class_eval do
  unless method_defined?(:run)
    alias_method :run, :start
    define_method(:start) do
      puts "'before' extension"
      run()
      puts "'after' extension"
    end
  end
end

Engine.new.start
# =&gt; 'before' extension
# =&gt; start me
# =&gt; 'after' extension

Engine.new.run # =&gt; start me
</code></pre>
------------------------------------------------------------------ <br><h3> Kamil Lelonek, Id: 26688602, Score: 27: </h3><p>A year after asking the question comes a new article on the subject:</p>

<p><a href="http://erniemiller.org/2014/10/23/in-defense-of-alias/">http://erniemiller.org/2014/10/23/in-defense-of-alias/</a></p>

<p>It seems that "so many men, so many minds." From the former article author encourages to use <code>alias_method</code>, while the latter suggests using <code>alias</code>.</p>

<p>However there's a common overview of these methods in both blogposts and answers above:</p>

<ul>
<li>use <code>alias</code> when you want to limit aliasing to the scope where it's defined</li>
<li>use <code>alias_method</code> to allow inherited classes to access it</li>
</ul>
------------------------------------------------------------------ <br><h3> B.G., Id: 48183349, Score: 20: </h3><p>The rubocop gem contributors propose in their <a href="https://github.com/bbatsov/ruby-style-guide#alias-method-lexically" rel="noreferrer">Ruby Style Guide</a>:</p>

<blockquote>
  <p>Prefer alias when aliasing methods in lexical class scope as the
  resolution of self in this context is also lexical, and it
  communicates clearly to the user that the indirection of your alias
  will not be altered at runtime or by any subclass unless made
  explicit.</p>
</blockquote>

<pre><code>class Westerner
  def first_name
   @names.first
  end

 alias given_name first_name
end
</code></pre>

<blockquote>
  <p>Always use alias_method when aliasing methods of modules, classes, or
  singleton classes at runtime, as the lexical scope of alias leads to
  unpredictability in these cases</p>
</blockquote>

<pre><code>module Mononymous
  def self.included(other)
    other.class_eval { alias_method :full_name, :given_name }
  end
end

class Sting &lt; Westerner
  include Mononymous
end
</code></pre>
------------------------------------------------------------------ <br><h3> Ajay, Id: 49752751, Score: -1: </h3><p><strong>alias_method</strong> <strong>new_method</strong>, <strong>old_method</strong></p>

<p><strong>old_method</strong> will be declared in a class or module which is being inherited now to our class where <strong>new_method</strong> will be used.</p>

<p>these can be variable or method both.</p>

<p>Suppose Class_1 has old_method, and Class_2 and Class_3 both of them inherit Class_1.</p>

<p>If, initialization of Class_2 and Class_3 is done in Class_1 then both can have different name in Class_2 and Class_3 and its usage.</p>
