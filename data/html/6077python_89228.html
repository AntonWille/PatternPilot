 <h2> Title: How do I execute a program or call a system command? </h2> <h3> freshWoWer, question_id: 89228 </h3>Score: 6077, Tags: {python,shell,terminal,subprocess,command} <br><p>How do I call an external command within Python as if I had typed it in a shell or command prompt?</p>
------------------------------------------------------------------ <br><h3> Answer 89243 David Cournapeau: </h3><p>Use <a href="https://docs.python.org/library/subprocess.html#subprocess.run" rel="noreferrer"><code>subprocess.run</code></a>:</p>
<pre class="lang-py prettyprint-override"><code>import subprocess

subprocess.run([&quot;ls&quot;, &quot;-l&quot;]) 
</code></pre>
<p>Another common way is <a href="https://docs.python.org/library/os.html#os.system" rel="noreferrer"><code>os.system</code></a> but you shouldn't use it because it is unsafe if any parts of the command come from outside your program or can contain spaces or other special characters, also <code>subprocess.run</code> is generally more flexible (you can get the <a href="https://docs.python.org/library/subprocess.html#subprocess.CompletedProcess.stdout" rel="noreferrer"><code>stdout</code></a>, <a href="https://docs.python.org/library/subprocess.html#subprocess.CompletedProcess.stderr" rel="noreferrer"><code>stderr</code></a>, the <a href="https://docs.python.org/library/subprocess.html#subprocess.CompletedProcess.returncode" rel="noreferrer">&quot;real&quot; status code</a>, better <a href="https://docs.python.org/library/subprocess.html#subprocess.CalledProcessError" rel="noreferrer">error handling</a>, etc.). Even the <a href="https://docs.python.org/library/os.html#os.system" rel="noreferrer">documentation for <code>os.system</code></a> recommends using <code>subprocess</code> instead.</p>
<p>On Python 3.4 and earlier, use <code>subprocess.call</code> instead of <code>.run</code>:</p>
<pre class="lang-py prettyprint-override"><code>subprocess.call([&quot;ls&quot;, &quot;-l&quot;])
</code></pre>
<h4> Comment 55091938 Murmel: </h4>@KevinWheeler You should NOT use <code>shell=True</code>, for this purpose Python comes with <a href="https://docs.python.org/2/library/os.path.html#os.path.expandvars" rel="nofollow noreferrer">os.path.expandvars</a>. In your case you can write: <code>os.path.expandvars(&quot;$PATH&quot;)</code>. @SethMMorton please reconsider your comment -&gt; <a href="https://docs.python.org/2/library/subprocess.html#frequently-used-arguments" rel="nofollow noreferrer">Why not to use shell=True</a><br><h4> Comment 52559086 Kevin Wheeler: </h4>Is there a way to use variable substitution? IE I tried to do <code>echo $PATH</code> by using <code>call([&quot;echo&quot;, &quot;$PATH&quot;])</code>, but it just echoed the literal string <code>$PATH</code> instead of doing any substitution. I know I could get the PATH environment variable, but I&#39;m wondering if there is an easy way to have the command behave exactly as if I had executed it in bash.<br><h4> Comment 123644441 Charlie Parker: </h4>what if I want to pipe things e.g. <code>pip list | grep anatome</code>?<br><h4> Comment 127649670 Sergey Anisimov: </h4>Many arguments version looks like that:  <code>subprocess.run([&quot;balcon.exe&quot;,&quot;-n&quot;,&quot;Tatyana&quot;,&quot;-t&quot;, &quot;Hello world&quot;])</code><br><h4> Comment 134537130 user3064538: </h4>@thatrandomperson your comment is useless because you didn&#39;t provide an example. no one is able to evaluate what you actually tried, why you expected it to work and explain to you why it didn&#39;t work. We just have to take your word that a function used by millions of programs &quot;doesn&#39;t work&quot;?<br><h4> Comment 52598063 SethMMorton: </h4>@KevinWheeler You&#39;ll have to use <code>shell=True</code> for that to work.<br>------------------------------------------------------------------ <br><h3> Answer 95246 EmmEff: </h3><p>Typical implementation:</p>
<pre class="lang-py prettyprint-override"><code>import subprocess

p = subprocess.Popen('ls', shell=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
for line in p.stdout.readlines():
    print line,
retval = p.wait()
</code></pre>
<p>You are free to do what you want with the <code>stdout</code> data in the pipe.  In fact, you can simply omit those parameters (<code>stdout=</code> and <code>stderr=</code>) and it'll behave like <code>os.system()</code>.</p>
<h4> Comment 18336103 jfs: </h4><code>.readlines()</code> reads <i>all</i> lines at once i.e., it blocks until the subprocess exits (closes its end of the pipe). To read in real time (if there is no buffering issues) you could: <code>for line in iter(p.stdout.readline, &#39;&#39;): print line,</code><br><h4> Comment 18358805 jfs: </h4>the child process may use block-buffering in non-interactive mode instead of line-buffering so <code>p.stdout.readline()</code> (note: no <code>s</code> at the end) won&#39;t see any data until the child fills its buffer. If the child doesn&#39;t produce much data then the output won&#39;t be in real time. See the second reason in <a href="http://www.noah.org/wiki/Pexpect#Q:_Why_not_just_use_a_pipe_.28popen.28.29.29.3F" rel="nofollow noreferrer">Q: Why not just use a pipe (popen())?</a>. Some workarounds are provided <a href="http://stackoverflow.com/a/12471855/4279">in this answer</a> (pexpect, pty, stdbuf)<br><h4> Comment 94039263 tripleee: </h4>This answer was fine for its time, but we should no longer recommend <code>Popen</code> for simple tasks. This also needlessly specifies <code>shell=True</code>. Try one of the <code>subprocess.run()</code> answers.<br><h4> Comment 18358836 jfs: </h4>the buffering issue only matters if you want output in real time and doesn&#39;t apply to your code that doesn&#39;t print anything until <i>all</i> data is received<br><h4> Comment 18358478 EmmEff: </h4>Could you elaborate on what you mean by &quot;if there is no buffering issues&quot;?  If the process blocks definitely, the subprocess call also blocks.  The same could happen with my original example as well. What else could happen with respect to buffering?<br>------------------------------------------------------------------ <br><h3> Answer 92395 Eli Courtwright: </h3><p>Here is a summary of ways to call external programs, including their advantages and disadvantages:</p>
<ol>
<li><p><a href="https://docs.python.org/3/library/os.html#os.system" rel="noreferrer"><code>os.system</code></a> passes the command and arguments to your system's shell. This is nice because you can actually run multiple commands at once in this manner and set up pipes and input/output redirection. For example:</p>
<pre class="lang-py prettyprint-override"><code>os.system(&quot;some_command &lt; input_file | another_command &gt; output_file&quot;)  
</code></pre>
<p>However, while this is convenient, you have to manually handle the escaping of shell characters such as spaces, et cetera. On the other hand, this also lets you run commands which are simply shell commands and not actually external programs.</p>
</li>
<li><p><a href="https://docs.python.org/3/library/os.html#os.popen" rel="noreferrer"><code>os.popen</code></a> will do the same thing as <code>os.system</code> except that it gives you a file-like object that you can use to access standard input/output for that process. There are 3 other variants of popen that all handle the i/o slightly differently. If you pass everything as a string, then your command is passed to the shell; if you pass them as a list then you don't need to worry about escaping anything. Example:</p>
<pre class="lang-py prettyprint-override"><code>print(os.popen(&quot;ls -l&quot;).read())
</code></pre>
</li>
<li><p><a href="https://docs.python.org/3/library/subprocess.html#subprocess.Popen" rel="noreferrer"><code>subprocess.Popen</code></a>. This is intended as a replacement for <code>os.popen</code>, but has the downside of being slightly more complicated by virtue of being so comprehensive. For example, you'd say:</p>
<pre class="lang-py prettyprint-override"><code>print subprocess.Popen(&quot;echo Hello World&quot;, shell=True, stdout=subprocess.PIPE).stdout.read()
</code></pre>
<p>instead of</p>
<pre class="lang-py prettyprint-override"><code>print os.popen(&quot;echo Hello World&quot;).read()
</code></pre>
<p>but it is nice to have all of the options there in one unified class instead of 4 different popen functions. See <a href="https://docs.python.org/3/library/subprocess.html#popen-constructor" rel="noreferrer">the documentation</a>.</p>
</li>
<li><p><a href="https://docs.python.org/3/library/subprocess.html#subprocess.call" rel="noreferrer"><code>subprocess.call</code></a>. This is basically just like the <code>Popen</code> class and takes all of the same arguments, but it simply waits until the command completes and gives you the return code. For example:</p>
<pre class="lang-py prettyprint-override"><code>return_code = subprocess.call(&quot;echo Hello World&quot;, shell=True)
</code></pre>
</li>
<li><p><a href="https://docs.python.org/3/library/subprocess.html#subprocess.run" rel="noreferrer"><code>subprocess.run</code></a>. Python 3.5+ only. Similar to the above but even more flexible and returns a <a href="https://docs.python.org/3/library/subprocess.html#subprocess.CompletedProcess" rel="noreferrer"><code>CompletedProcess</code></a> object when the command finishes executing.</p>
</li>
<li><p><code>os.fork</code>, <code>os.exec</code>, <code>os.spawn</code> are similar to their C language counterparts, but I don't recommend using them directly.</p>
</li>
</ol>
<p>The <code>subprocess</code> module should probably be what you use.</p>
<p>Finally, please be aware that for all methods where you pass the final command to be executed by the shell as a string and you are responsible for escaping it. <strong>There are serious security implications</strong> if any part of the string that you pass can not be fully trusted. For example, if a user is entering some/any part of the string. If you are unsure, only use these methods with constants. To give you a hint of the implications consider this code:</p>
<pre class="lang-py prettyprint-override"><code>print subprocess.Popen(&quot;echo %s &quot; % user_input, stdout=PIPE).stdout.read()
</code></pre>
<p>and imagine that the user enters something &quot;<code>my mama didnt love me &amp;&amp; rm -rf /</code>&quot; which could erase the whole filesystem.</p>
<h4> Comment 49018699 Jean: </h4>Nice answer/explanation.  How is this answer justifying Python&#39;s motto as described in this article ?  <a href="http://www.fastcompany.com/3026446/the-fall-of-perl-the-webs-most-promising-language" rel="nofollow noreferrer">fastcompany.com/3026446/&hellip;</a>  &quot;Stylistically, Perl and Python have different philosophies. Perl’s best known mottos is &quot; There’s More Than One Way to Do It&quot;. Python is designed to have one obvious way to do it&quot;  Seem like it should be the other way! In Perl I know only two ways to execute a command - using back-tick or <code>open</code>.<br><h4> Comment 53820265 johnthagen: </h4>If using Python 3.5+, use <code>subprocess.run()</code>. <a href="https://docs.python.org/3.5/library/subprocess.html#subprocess.run" rel="nofollow noreferrer">docs.python.org/3.5/library/subprocess.html#subprocess.run</a><br><h4> Comment 94039654 tripleee: </h4>This is arguably the wrong way around. Most people only need <code>subprocess.run()</code> or its older siblings <code>subprocess.check_call()</code> et al. For cases where these do not suffice, see <code>subprocess.Popen()</code>. <code>os.popen()</code> should perhaps not be mentioned at all, or come even after &quot;hack your own fork/exec/spawn code&quot;.<br><h4> Comment 62619897 Evgeni Sergeev: </h4>What one typically needs to know is what is done with the child process&#39;s STDOUT and STDERR, because if they are ignored, under some (quite common) conditions, eventually the child process will issue a system call to write to STDOUT (STDERR too?) that would exceed the output buffer provided for the process by the OS, and the OS will cause it to block until some process reads from that buffer. So, with the currently recommended ways, <code>subprocess.run(..)</code>, what exactly does <i>&quot;This does not capture stdout or stderr by default.&quot;</i> imply? What about <code>subprocess.check_output(..)</code> and STDERR?<br><h4> Comment 80783837 Charlie Parker: </h4>which of the commands you recommended block my script? i.e. if I want to run multiple commands in a <code>for</code> loop how do I do it without it blocking my python script? I don&#39;t care about the output of the command I just want to run lots of them.<br><h4> Comment 130160646 Ben L: </h4>Can you please explain when to use &quot;shell=True&quot; and when not to use it?<br><h4> Comment 130180611 Eli Courtwright: </h4>@BenL: That causes the command to be passed directly to a shell (e.g. bash) as opposed to doing a fork/exec using the underlying system calls.  Using shell might be required because some commands aren&#39;t actually executable programs and are instead shell commands build into your shell (e.g. <code>export</code> in bash is a shell command).  Using a shell is a bad idea if you&#39;re taking untrusted user input, because it&#39;s more likely to cause a security issue.<br>------------------------------------------------------------------ <br><h3> Answer 2251026 newtover: </h3><p>Some hints on detaching the child process from the calling one (starting the child process in background).</p>

<p>Suppose you want to start a long task from a CGI script. That is, the child process should live longer than the CGI script execution process.</p>

<p>The classical example from the subprocess module documentation is:</p>

<pre><code>import subprocess
import sys

# Some code here

pid = subprocess.Popen([sys.executable, "longtask.py"]) # Call subprocess

# Some more code here
</code></pre>

<p>The idea here is that you do not want to wait in the line 'call subprocess' until the longtask.py is finished. But it is not clear what happens after the line 'some more code here' from the example.</p>

<p>My target platform was FreeBSD, but the development was on Windows, so I faced the problem on Windows first.</p>

<p>On Windows (Windows&nbsp;XP), the parent process will not finish until the longtask.py has finished its work. It is not what you want in a CGI script. The problem is not specific to Python; in the PHP community the problems are the same.</p>

<p>The solution is to pass DETACHED_PROCESS <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms684863(v=vs.85).aspx" rel="noreferrer">Process Creation Flag</a> to the underlying CreateProcess function in Windows API.
If you happen to have installed pywin32, you can import the flag from the win32process module, otherwise you should define it yourself:</p>

<pre><code>DETACHED_PROCESS = 0x00000008

pid = subprocess.Popen([sys.executable, "longtask.py"],
                       creationflags=DETACHED_PROCESS).pid
</code></pre>

<p>/* <em>UPD 2015.10.27</em> @eryksun in a comment below notes, that the semantically correct flag is CREATE_NEW_CONSOLE (0x00000010) */</p>

<p>On FreeBSD we have another problem: when the parent process is finished, it finishes the child processes as well. And that is not what you want in a CGI script either. Some experiments showed that the problem seemed to be in sharing sys.stdout. And the working solution was the following:</p>

<pre><code>pid = subprocess.Popen([sys.executable, "longtask.py"], stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE)
</code></pre>

<p>I have not checked the code on other platforms and do not know the reasons of the behaviour on FreeBSD. If anyone knows, please share your ideas. Googling on starting background processes in Python does not shed any light yet.</p>
<h4> Comment 54511646 Eryk Sun: </h4>The following is incorrect: &quot;[o]n windows (win xp), the parent process will not finish until the longtask.py has finished its work&quot;. The parent will exit normally, but the console window (conhost.exe instance) only closes when the last attached process exits, and the child may have inherited the parent&#39;s console. Setting <code>DETACHED_PROCESS</code> in <code>creationflags</code> avoids this by preventing the child from inheriting or creating a console. If you instead want a new console, use <code>CREATE_NEW_CONSOLE</code> (0x00000010).<br><h4> Comment 54543759 Eryk Sun: </h4>I didn&#39;t mean that executing as a detached process is incorrect. That said, you may need to set the standard handles to files, pipes, or <code>os.devnull</code> because some console programs exit with an error otherwise. Create a new console when you want the child process to interact with the user concurrently with the parent process. It would be confusing to try to do both in a single window.<br><h4> Comment 18336228 jfs: </h4>you might also need CREATE_NEW_PROCESS_GROUP flag. See <a href="http://stackoverflow.com/q/13243807/4279">Popen waiting for child process even when the immediate child has terminated</a><br><h4> Comment 41807947 ubershmekel: </h4>I&#39;m seeing <code>import subprocess as sp;sp.Popen(&#39;calc&#39;)</code> not waiting for the subprocess to complete. It seems the creationflags aren&#39;t necessary. What am I missing?<br><h4> Comment 41828669 newtover: </h4>@ubershmekel, I am not sure what you mean and don&#39;t have a windows installation. If I recall correctly, without the flags you can not close the <code>cmd</code> instance from which you started the <code>calc</code>.<br><h4> Comment 96483004 Charlie Parker: </h4>your answer seems strange to me. I just opened a <code>subprocess.Popen</code> and nothing bad happened (not had to wait). Why exactly do we need to worry about the scenario you are pointing out? I&#39;m skeptical.<br><h4> Comment 2615898 maranas: </h4>i noticed a possible &quot;quirk&quot; with developing py2exe apps in pydev+eclipse. i was able to tell that the main script was not detached because eclipse&#39;s output window was not terminating; even if the script executes to completion it is still waiting for returns. but, when i tried compiling to a py2exe executable, the expected behavior occurs (runs the processes as detached, then quits). i am not sure, but the executable name is not in the process list anymore. this works for all approaches (os.system(&quot;start *&quot;), os.spawnl with os.P_DETACH, subprocs, etc.)<br><h4> Comment 13051553 Alexey Lebedev: </h4>Windows gotcha: even though I spawned process with DETACHED_PROCESS, when I killed my Python daemon all ports opened by it wouldn&#39;t free until all spawned processes terminate. WScript.Shell solved all my problems. Example here: <a href="http://pastebin.com/xGmuvwSx" rel="nofollow noreferrer">pastebin.com/xGmuvwSx</a><br><h4> Comment 85343139 Dr_Zaszuś: </h4><code>stdout=subprocess.PIPE</code> will make your code hang up if you have long output from a child. For more details see <a href="https://thraxil.org/users/anders/posts/2008/03/13/Subprocess-Hanging-PIPE-is-your-enemy/" rel="nofollow noreferrer">thraxil.org/users/anders/posts/2008/03/13/&hellip;</a><br><h4> Comment 41897323 ubershmekel: </h4>I&#39;m on Windows 8.1 and <code>calc</code> seems to survive the closing of <code>python</code>.<br><h4> Comment 48222496 SuperBiasedMan: </h4>Is there any significance to using &#39;0x00000008&#39;? Is that a specific value that has to be used or one of multiple options?<br>------------------------------------------------------------------ <br><h3> Answer 89237 nimish: </h3><pre class="lang-py prettyprint-override"><code>import os
os.system(&quot;your command&quot;)
</code></pre>
<p>Note that this is dangerous, since the command isn't cleaned. See the documentation of <a href="https://docs.python.org/3/library/os.html" rel="noreferrer">the <code>os</code></a> and <a href="https://docs.python.org/3/library/sys.html" rel="noreferrer"><code>sys</code></a> modules. There are a bunch of functions (<a href="https://docs.python.org/3/library/os.html#os.execl" rel="noreferrer"><code>exec*</code></a> and <a href="https://docs.python.org/3/library/os.html#os.spawnl" rel="noreferrer"><code>spawn*</code></a>) that will do similar things.</p>
<h4> Comment 88457934 nimish: </h4>No idea what I meant nearly a decade ago (check the date!), but if I had to guess, it would be that there&#39;s no validation done.<br><h4> Comment 94038788 tripleee: </h4>This should now point to <code>subprocess</code> as a slightly more versatile and portable solution. Running external commands is of course inherently unportable (you have to make sure the command is available on every architecture you need to support) and passing user input as an external command is inherently unsafe.<br><h4> Comment 133983043 Nathan B: </h4>And how do you get the output?<br><h4> Comment 134557176 user3064538: </h4>@NathanB by using <code>result = subprocess.run()</code> instead and then doing <code>result.stdout</code>. It might also be possible by <a href="https://stackoverflow.com/a/40417352">intercepting stdout</a><br>------------------------------------------------------------------ <br><h3> Answer 89255 sirwart: </h3><p>I'd recommend using the <a href="http://docs.python.org/library/subprocess.html" rel="noreferrer">subprocess</a> module instead of os.system because it does shell escaping for you and is therefore much safer.</p>

<pre><code>subprocess.call(['ping', 'localhost'])
</code></pre>
<h4> Comment 94078666 Lie Ryan: </h4>This is incorrect: &quot;<b>it does shell escaping for you and is therefore much safer</b>&quot;. subprocess doesn&#39;t do shell escaping, subprocess doesn&#39;t pass your command through the shell, so there&#39;s no need to shell escape.<br><h4> Comment 91805349 Daniel F: </h4>If you want to <b>create a list out of a command with parameters</b>, a list which can be used with <code>subprocess</code> when <code>shell=False</code>, then use <code>shlex.split</code> for an easy way to do this <a href="https://docs.python.org/2/library/shlex.html#shlex.split" rel="nofollow noreferrer">docs.python.org/2/library/shlex.html#shlex.split</a> (it&#39;s the recommended way according to the docs <a href="https://docs.python.org/2/library/subprocess.html#popen-constructor" rel="nofollow noreferrer">docs.python.org/2/library/subprocess.html#popen-constructor</a>)<br>------------------------------------------------------------------ <br><h3> Answer 89238 Alexandra Franks: </h3><pre><code>import os
cmd = 'ls -al'
os.system(cmd)
</code></pre>

<p>If you want to return the results of the command, you can use <a href="https://docs.python.org/2/library/os.html#os.popen" rel="noreferrer"><code>os.popen</code></a>. However, this is deprecated since version 2.6 in favor of the <a href="https://docs.python.org/2/library/subprocess.html#module-subprocess" rel="noreferrer">subprocess module</a>, which other answers have covered well.</p>
<h4> Comment 39233700 tew: </h4>popen <a href="https://docs.python.org/2/library/os.html#os.popen" rel="nofollow noreferrer">is deprecated</a> in favor of <a href="https://docs.python.org/2/library/subprocess.html" rel="nofollow noreferrer">subprocess</a>.<br><h4> Comment 81287939 Stefan Gruenwald: </h4>You can also save your result with the os.system call, since it works like the UNIX shell itself, like for example os.system(&#39;ls -l &gt; test2.txt&#39;)<br>------------------------------------------------------------------ <br><h3> Answer 40319875 Tom Fuller: </h3><p>There are lots of different libraries which allow you to call external commands with Python. For each library I've given a description and shown an example of calling an external command. The command I used as the example is <code>ls -l</code> (list all files). If you want to find out more about any of the libraries I've listed and linked the documentation for each of them.</p>
<h3>Sources</h3>
<ul>
<li>subprocess: <a href="https://docs.python.org/3.5/library/subprocess.html" rel="noreferrer">https://docs.python.org/3.5/library/subprocess.html</a></li>
<li>shlex: <a href="https://docs.python.org/3/library/shlex.html" rel="noreferrer">https://docs.python.org/3/library/shlex.html</a></li>
<li>os: <a href="https://docs.python.org/3.5/library/os.html" rel="noreferrer">https://docs.python.org/3.5/library/os.html</a></li>
<li>sh: <a href="https://amoffat.github.io/sh/" rel="noreferrer">https://amoffat.github.io/sh/</a></li>
<li>plumbum: <a href="https://plumbum.readthedocs.io/en/latest/" rel="noreferrer">https://plumbum.readthedocs.io/en/latest/</a></li>
<li>pexpect: <a href="https://pexpect.readthedocs.io/en/stable/" rel="noreferrer">https://pexpect.readthedocs.io/en/stable/</a></li>
<li>fabric: <a href="http://www.fabfile.org/" rel="noreferrer">http://www.fabfile.org/</a></li>
<li>envoy: <a href="https://github.com/kennethreitz/envoy" rel="noreferrer">https://github.com/kennethreitz/envoy</a></li>
<li>commands: <a href="https://docs.python.org/2/library/commands.html" rel="noreferrer">https://docs.python.org/2/library/commands.html</a></li>
</ul>
<h3>These are all the libraries</h3>
<p>Hopefully this will help you make a decision on which library to use :)</p>
<h3><em>subprocess</em></h3>
<p>Subprocess allows you to call external commands and connect them to their input/output/error pipes (stdin, stdout, and stderr). Subprocess is the default choice for running commands, but sometimes other modules are better.</p>
<pre><code>subprocess.run([&quot;ls&quot;, &quot;-l&quot;]) # Run command
subprocess.run([&quot;ls&quot;, &quot;-l&quot;], stdout=subprocess.PIPE) # This will run the command and return any output
subprocess.run(shlex.split(&quot;ls -l&quot;)) # You can also use the shlex library to split the command
</code></pre>
<h3><em>os</em></h3>
<p>os is used for &quot;operating system dependent functionality&quot;. It can also be used to call external commands with <code>os.system</code> and <code>os.popen</code> (Note: There is also a subprocess.popen). os will always run the shell and is a simple alternative for people who don't need to, or don't know how to use <code>subprocess.run</code>.</p>
<pre class="lang-python prettyprint-override"><code>os.system(&quot;ls -l&quot;) # Run command
os.popen(&quot;ls -l&quot;).read() # This will run the command and return any output
</code></pre>
<h3><em>sh</em></h3>
<p>sh is a subprocess interface which lets you call programs as if they were functions. This is useful if you want to run a command multiple times.</p>
<pre><code>sh.ls(&quot;-l&quot;) # Run command normally
ls_cmd = sh.Command(&quot;ls&quot;) # Save command as a variable
ls_cmd() # Run command as if it were a function
</code></pre>
<h3><em>plumbum</em></h3>
<p>plumbum is a library for &quot;script-like&quot; Python programs. You can call programs like functions as in <code>sh</code>. Plumbum is useful if you want to run a pipeline without the shell.</p>
<pre><code>ls_cmd = plumbum.local(&quot;ls -l&quot;) # Get command
ls_cmd() # Run command
</code></pre>
<h3><em>pexpect</em></h3>
<p>pexpect lets you spawn child applications, control them and find patterns in their output. This is a better alternative to subprocess for commands that expect a tty on Unix.</p>
<pre><code>pexpect.run(&quot;ls -l&quot;) # Run command as normal
child = pexpect.spawn('scp foo user@example.com:.') # Spawns child application
child.expect('Password:') # When this is the output
child.sendline('mypassword')
</code></pre>
<h3><em>fabric</em></h3>
<p>fabric is a Python 2.5 and 2.7 library. It allows you to execute local and remote shell commands. Fabric is simple alternative for running commands in a secure shell (SSH)</p>
<pre><code>fabric.operations.local('ls -l') # Run command as normal
fabric.operations.local('ls -l', capture = True) # Run command and receive output
</code></pre>
<h3><em>envoy</em></h3>
<p>envoy is known as &quot;subprocess for humans&quot;. It is used as a convenience wrapper around the <code>subprocess</code> module.</p>
<pre><code>r = envoy.run(&quot;ls -l&quot;) # Run command
r.std_out # Get output
</code></pre>
<h3><em>commands</em></h3>
<p><code>commands</code> contains wrapper functions for <code>os.popen</code>, but it has been removed from Python 3 since <code>subprocess</code> is a better alternative.</p>
<h4> Comment 135182929 innisfree: </h4>I think it should be <code>ls_cmd = plumbum.local[&quot;ls -l&quot;]</code> # Get command<br>------------------------------------------------------------------ <br><h3> Answer 15954964 Honza Javorek: </h3><h3>With the standard library</h3>

<p>Use the <a href="https://docs.python.org/3/library/subprocess.html#subprocess.run" rel="noreferrer">subprocess module</a> (Python 3):</p>

<pre><code>import subprocess
subprocess.run(['ls', '-l'])
</code></pre>

<p>It is the recommended standard way. However, more complicated tasks (pipes, output, input, etc.) can be tedious to construct and write.</p>

<p><em>Note on Python version: If you are still using Python 2, <a href="https://docs.python.org/2/library/subprocess.html#subprocess.call" rel="noreferrer">subprocess.call</a> works in a similar way.</em></p>

<p><em>ProTip: <a href="https://docs.python.org/2/library/shlex.html#shlex.split" rel="noreferrer">shlex.split</a> can help you to parse the command for <code>run</code>, <code>call</code>, and other <code>subprocess</code> functions in case you don't want (or you can't!) provide them in form of lists:</em></p>

<pre><code>import shlex
import subprocess
subprocess.run(shlex.split('ls -l'))
</code></pre>

<h3>With external dependencies</h3>

<p>If you do not mind external dependencies, use <a href="https://pypi.python.org/pypi/plumbum" rel="noreferrer">plumbum</a>:</p>

<pre><code>from plumbum.cmd import ifconfig
print(ifconfig['wlan0']())
</code></pre>

<p>It is the best <code>subprocess</code> wrapper. It's cross-platform, i.e. it works on both Windows and Unix-like systems. Install by <code>pip install plumbum</code>.</p>

<p>Another popular library is <a href="https://pypi.python.org/pypi/sh" rel="noreferrer">sh</a>:</p>

<pre><code>from sh import ifconfig
print(ifconfig('wlan0'))
</code></pre>

<p>However, <code>sh</code> dropped Windows support, so it's not as awesome as it used to be. Install by <code>pip install sh</code>.</p>
------------------------------------------------------------------ <br><h3> Answer 9676642 Jorge E. Cardona: </h3><p>I always use <code>fabric</code> for doing these things. Here is a demo code:</p>
<pre><code>from fabric.operations import local
result = local('ls', capture=True)
print &quot;Content:/n%s&quot; % (result, )
</code></pre>
<p>But this seems to be a good tool: <a href="https://github.com/amoffat/sh" rel="nofollow noreferrer"><code>sh</code> (Python subprocess interface)</a>.</p>
<p>Look at an example:</p>
<pre><code>from sh import vgdisplay
print vgdisplay()
print vgdisplay('-v')
print vgdisplay(v=True)
</code></pre>
------------------------------------------------------------------ <br><h3> Answer 3879406 athanassis: </h3><p>Check the "pexpect" Python library, too.</p>

<p>It allows for interactive controlling of external programs/commands, even ssh, ftp, telnet, etc. You can just type something like:</p>

<pre><code>child = pexpect.spawn('ftp 192.168.0.24')

child.expect('(?i)name .*: ')

child.sendline('anonymous')

child.expect('(?i)password')
</code></pre>
------------------------------------------------------------------ <br><h3> Answer 5824565 Facundo Casco: </h3><p>If you need the output from the command you are calling,
then you can use <a href="https://docs.python.org/3.6/library/subprocess.html#subprocess.check_output" rel="noreferrer">subprocess.check_output</a> (Python 2.7+).</p>

<pre><code>&gt;&gt;&gt; subprocess.check_output(["ls", "-l", "/dev/null"])
'crw-rw-rw- 1 root root 1, 3 Oct 18  2007 /dev/null\n'
</code></pre>

<p>Also note the <a href="https://docs.python.org/3.6/library/subprocess.html#frequently-used-arguments" rel="noreferrer">shell</a> parameter.</p>

<blockquote>
  <p>If shell is <code>True</code>, the specified command will be executed through the shell. This can be useful if you are using Python primarily for the enhanced control flow it offers over most system shells and still want convenient access to other shell features such as shell pipes, filename wildcards, environment variable expansion, and expansion of ~ to a user’s home directory. However, note that Python itself offers implementations of many shell-like features (in particular, <code>glob</code>, <code>fnmatch</code>, <code>os.walk()</code>, <code>os.path.expandvars()</code>, <code>os.path.expanduser()</code>, and <code>shutil</code>).</p>
</blockquote>
<h4> Comment 84050970 Bruno Bronosky: </h4>Note that <code>check_output</code> requires a list rather than a string. If you don&#39;t rely on quoted spaces to make your call valid, the simplest, most readable way to do this is <code>subprocess.check_output(&quot;ls -l &#47;dev&#47;null&quot;.split())</code>.<br><h4> Comment 120034000 tripleee: </h4>Like the answer vaguely mentions, and many other answers on this page explain in more detail, you can pass a list, or with <code>shell=True</code> a single string which the shell then takes care of parsing and executing. Using plain <code>.split()</code> is fine under the circumstances you mention, but beginners typically don&#39;t understand the nuances; you are probably better off recommending <code>shlex.split()</code> which does handle quoting and backslash escapes correctly.<br>------------------------------------------------------------------ <br><h3> Answer 46815111 Russia Must Remove Putin: </h3><blockquote>
<h2>How to execute a program or call a system command from Python</h2>
</blockquote>
<p>Simple, use <code>subprocess.run</code>, which returns a <code>CompletedProcess</code> object:</p>
<pre><code>&gt;&gt;&gt; from subprocess import run
&gt;&gt;&gt; from shlex import split
&gt;&gt;&gt; completed_process = run(split('python --version'))
Python 3.8.8
&gt;&gt;&gt; completed_process
CompletedProcess(args=['python', '--version'], returncode=0)
</code></pre>
<p>(<code>run</code> wants a list of lexically parsed shell arguments - this is what you'd type in a shell, separated by spaces, but not where the spaces are quoted, so use a specialized function, <code>split</code>, to split up what you would literally type into your shell)</p>
<h3>Why?</h3>
<p>As of Python 3.5, the documentation recommends <a href="https://docs.python.org/3/library/subprocess.html#subprocess.run" rel="noreferrer">subprocess.run</a>:</p>
<blockquote>
<p>The recommended approach to invoking subprocesses is to use the run() function for all use cases it can handle. For more advanced use cases, the underlying Popen interface can be used directly.</p>
</blockquote>
<p>Here's an example of the simplest possible usage - and it does exactly as asked:</p>
<pre><code>&gt;&gt;&gt; from subprocess import run
&gt;&gt;&gt; from shlex import split
&gt;&gt;&gt; completed_process = run(split('python --version'))
Python 3.8.8
&gt;&gt;&gt; completed_process
CompletedProcess(args=['python', '--version'], returncode=0)
</code></pre>
<p><code>run</code> waits for the command to successfully finish, then returns a <code>CompletedProcess</code> object. It may instead raise <code>TimeoutExpired</code> (if you give it a <code>timeout=</code> argument) or <code>CalledProcessError</code> (if it fails and you pass <code>check=True</code>).</p>
<p>As you might infer from the above example, stdout and stderr both get piped to your own stdout and stderr by default.</p>
<p>We can inspect the returned object and see the command that was given and the returncode:</p>
<pre><code>&gt;&gt;&gt; completed_process.args
['python', '--version']
&gt;&gt;&gt; completed_process.returncode
0
</code></pre>
<h3>Capturing output</h3>
<p>If you want to capture the output, you can pass <code>subprocess.PIPE</code> to the appropriate <code>stderr</code> or <code>stdout</code>:</p>
<pre><code>&gt;&gt;&gt; from subprocess import PIPE
&gt;&gt;&gt; completed_process = run(shlex.split('python --version'), stdout=PIPE, stderr=PIPE)
&gt;&gt;&gt; completed_process.stdout
b'Python 3.8.8\n'
&gt;&gt;&gt; completed_process.stderr
b''
</code></pre>
<p>And those respective attributes return bytes.</p>
<h2>Pass a command list</h2>
<p>One might easily move from manually providing a command string (like the question suggests) to providing a string built programmatically. <strong>Don't build strings programmatically.</strong> This is a potential security issue. It's better to assume you don't trust the input.</p>
<pre><code>&gt;&gt;&gt; import textwrap
&gt;&gt;&gt; args = ['python', textwrap.__file__]
&gt;&gt;&gt; cp = run(args, stdout=subprocess.PIPE)
&gt;&gt;&gt; cp.stdout
b'Hello there.\n  This is indented.\n'
</code></pre>
<p>Note, only <code>args</code> should be passed positionally.</p>
<h2>Full Signature</h2>
<p>Here's the actual signature in the source and as shown by <code>help(run)</code>:</p>
<blockquote>
<pre><code>def run(*popenargs, input=None, timeout=None, check=False, **kwargs):
</code></pre>
</blockquote>
<p>The <code>popenargs</code> and <code>kwargs</code> are given to the <code>Popen</code> constructor. <code>input</code> can be a string of bytes (or unicode, if specify encoding or <code>universal_newlines=True</code>) that will be piped to the subprocess's stdin.</p>
<p>The documentation describes <code>timeout=</code> and <code>check=True</code> better than I could:</p>
<blockquote>
<p>The timeout argument is passed to Popen.communicate(). If the timeout
expires, the child process will be killed and waited for. The
TimeoutExpired exception will be re-raised after the child process has
terminated.</p>
<p>If check is true, and the process exits with a non-zero exit code, a
CalledProcessError exception will be raised. Attributes of that
exception hold the arguments, the exit code, and stdout and stderr if
they were captured.</p>
</blockquote>
<p>and this example for <code>check=True</code> is better than one I could come up with:</p>
<blockquote>
<pre><code>&gt;&gt;&gt; subprocess.run(&quot;exit 1&quot;, shell=True, check=True)
Traceback (most recent call last):
  ...
subprocess.CalledProcessError: Command 'exit 1' returned non-zero exit status 1
</code></pre>
</blockquote>
<h3>Expanded Signature</h3>
<p>Here's an expanded signature, as given in the documentation:</p>
<blockquote>
<pre><code>subprocess.run(args, *, stdin=None, input=None, stdout=None, stderr=None, 
shell=False, cwd=None, timeout=None, check=False, encoding=None, 
errors=None)
</code></pre>
</blockquote>
<p>Note that this indicates that only the args list should be passed positionally. So pass the remaining arguments as keyword arguments.</p>
<h3>Popen</h3>
<p>When use <code>Popen</code> instead? I would struggle to find use-case based on the arguments alone. Direct usage of <code>Popen</code> would, however, give you access to its methods, including <code>poll</code>, 'send_signal', 'terminate', and 'wait'.</p>
<p>Here's the <code>Popen</code> signature as given in <a href="https://github.com/python/cpython/blob/master/Lib/subprocess.py#L752" rel="noreferrer">the source</a>. I think this is the most precise encapsulation of the information (as opposed to <code>help(Popen)</code>):</p>
<pre><code>
def __init__(self, args, bufsize=-1, executable=None,
             stdin=None, stdout=None, stderr=None,
             preexec_fn=None, close_fds=True,
             shell=False, cwd=None, env=None, universal_newlines=None,
             startupinfo=None, creationflags=0,
             restore_signals=True, start_new_session=False,
             pass_fds=(), *, user=None, group=None, extra_groups=None,
             encoding=None, errors=None, text=None, umask=-1, pipesize=-1):

</code></pre>
<p>But more informative is <a href="https://docs.python.org/3/library/subprocess.html#popen-constructor" rel="noreferrer">the <code>Popen</code> documentation</a>:</p>
<blockquote>
<pre><code>subprocess.Popen(args, bufsize=-1, executable=None, stdin=None, stdout=None, 
stderr=None, preexec_fn=None, close_fds=True, shell=False, cwd=None,
env=None, universal_newlines=None, startupinfo=None, creationflags=0, 
restore_signals=True, start_new_session=False, pass_fds=(), *, group=None, 
extra_groups=None, user=None, umask=-1, encoding=None, errors=None, 
text=None)
</code></pre>
<p>Execute a child program in a new process. On POSIX, the class uses
os.execvp()-like behavior to execute the child program. On Windows,
the class uses the Windows CreateProcess() function. The arguments to
Popen are as follows.</p>
</blockquote>
<p>Understanding the remaining documentation on <code>Popen</code> will be left as an exercise for the reader.</p>
<h4> Comment 92598860 James Hirschorn: </h4>A simple example of two-way communication between a primary process and a subprocess can be found here: <a href="https://stackoverflow.com/a/52841475/1349673">stackoverflow.com/a/52841475/1349673</a><br>------------------------------------------------------------------ <br><h3> Answer 13402722 Joe: </h3><h1>Update:</h1>

<p><code>subprocess.run</code> is the recommended approach <a href="https://docs.python.org/3.6/whatsnew/3.5.html#whatsnew-subprocess" rel="noreferrer">as of Python 3.5</a> if your code does not need to maintain compatibility with earlier Python versions. It's more consistent and offers similar ease-of-use as Envoy. (Piping isn't as straightforward though. See <a href="https://stackoverflow.com/questions/7389662/link-several-popen-commands-with-pipes">this question for how</a>.)</p>

<p>Here's some examples from <a href="https://docs.python.org/3.6/library/subprocess.html#subprocess.run" rel="noreferrer">the documentation</a>.</p>

<p>Run a process:</p>

<pre><code>&gt;&gt;&gt; subprocess.run(["ls", "-l"])  # Doesn't capture output
CompletedProcess(args=['ls', '-l'], returncode=0)
</code></pre>

<p>Raise on failed run:</p>

<pre><code>&gt;&gt;&gt; subprocess.run("exit 1", shell=True, check=True)
Traceback (most recent call last):
  ...
subprocess.CalledProcessError: Command 'exit 1' returned non-zero exit status 1
</code></pre>

<p>Capture output:</p>

<pre><code>&gt;&gt;&gt; subprocess.run(["ls", "-l", "/dev/null"], stdout=subprocess.PIPE)
CompletedProcess(args=['ls', '-l', '/dev/null'], returncode=0,
stdout=b'crw-rw-rw- 1 root root 1, 3 Jan 23 16:23 /dev/null\n')
</code></pre>

<h1>Original answer:</h1>

<p>I recommend trying <a href="https://github.com/kennethreitz/envoy" rel="noreferrer">Envoy</a>. It's a wrapper for subprocess, which in turn <a href="http://docs.python.org/2/library/subprocess.html" rel="noreferrer">aims to replace</a> the older modules and functions. Envoy is subprocess for humans.</p>

<p>Example usage from <a href="https://github.com/kennethreitz/envoy#readme" rel="noreferrer">the README</a>:</p>

<pre><code>&gt;&gt;&gt; r = envoy.run('git config', data='data to pipe in', timeout=2)

&gt;&gt;&gt; r.status_code
129
&gt;&gt;&gt; r.std_out
'usage: git config [options]'
&gt;&gt;&gt; r.std_err
''
</code></pre>

<p>Pipe stuff around too:</p>

<pre><code>&gt;&gt;&gt; r = envoy.run('uptime | pbcopy')

&gt;&gt;&gt; r.command
'pbcopy'
&gt;&gt;&gt; r.status_code
0

&gt;&gt;&gt; r.history
[&lt;Response 'uptime'&gt;]
</code></pre>
------------------------------------------------------------------ <br><h3> Answer 13106558 Usman Khan: </h3><p>This is how I run my commands. This code has everything you need pretty much</p>

<pre><code>from subprocess import Popen, PIPE
cmd = "ls -l ~/"
p = Popen(cmd , shell=True, stdout=PIPE, stderr=PIPE)
out, err = p.communicate()
print "Return code: ", p.returncode
print out.rstrip(), err.rstrip()
</code></pre>
<h4> Comment 34789609 Adam Matan: </h4>I think it&#39;s acceptable for hard-coded commands, if it increases readability.<br>------------------------------------------------------------------ <br><h3> Answer 89262 Ben Hoffstein: </h3><p>Use <em><a href="https://docs.python.org/2/library/subprocess.html" rel="noreferrer">subprocess</a></em>.</p>

<p>...or for a very simple command:</p>

<pre><code>import os
os.system('cat testfile')
</code></pre>
------------------------------------------------------------------ <br><h3> Answer 64341833 fameman: </h3><p><em>As of <strong>Python 3.7.0 released on June 27th 2018 (<a href="https://docs.python.org/3/whatsnew/3.7.html" rel="noreferrer">https://docs.python.org/3/whatsnew/3.7.html</a>)</strong>, you can achieve your desired result in the most powerful while equally simple way. This answer intends to show you the essential summary of various options in a short manner. For in-depth answers, please see the other ones.</em></p>
<hr />
<h1>TL;DR in 2021</h1>
<p>The big advantage of <code>os.system(...)</code> was its simplicity. <code>subprocess</code> is better and still easy to use, especially as of <strong>Python 3.5</strong>.</p>
<pre><code>import subprocess
subprocess.run(&quot;ls -a&quot;, shell=True)
</code></pre>
<p><em><strong>Note:</strong></em> This is the exact answer to your question - running a command</p>
<blockquote>
<p>like in a shell</p>
</blockquote>
<hr />
<h3>Preferred Way</h3>
<p>If possible, remove the shell overhead and run the command directly (requires a list).</p>
<pre><code>import subprocess
subprocess.run([&quot;help&quot;])
subprocess.run([&quot;ls&quot;, &quot;-a&quot;])
</code></pre>
<p>Pass program arguments in a list. <strong>Don't include <code>\&quot;</code>-escaping for arguments containing spaces.</strong></p>
<hr />
<h1>Advanced Use Cases</h1>
<h2>Checking The Output</h2>
<p>The following code speaks for itself:</p>
<pre><code>import subprocess
result = subprocess.run([&quot;ls&quot;, &quot;-a&quot;], capture_output=True, text=True)
if &quot;stackoverflow-logo.png&quot; in result.stdout:
    print(&quot;You're a fan!&quot;)
else:
    print(&quot;You're not a fan?&quot;)
</code></pre>
<p><code>result.stdout</code> is all normal program output <strong>excluding errors</strong>. Read <code>result.stderr</code> to get them.</p>
<p><code>capture_output=True</code> - turns capturing on. Otherwise <code>result.stderr</code> and <code>result.stdout</code> would be <code>None</code>. Available from <em>Python 3.7</em>.</p>
<p><code>text=True</code> - a convenience argument added in <em>Python 3.7</em> which converts the received binary data to Python strings you can easily work with.</p>
<h2>Checking the returncode</h2>
<p>Do</p>
<pre><code>if result.returncode == 127: print(&quot;The program failed for some weird reason&quot;)
elif result.returncode == 0: print(&quot;The program succeeded&quot;)
else: print(&quot;The program failed unexpectedly&quot;)
</code></pre>
<p>If you just want to check if the program succeeded (returncode == 0) and otherwise throw an Exception, there is a more convenient function:</p>
<pre><code>result.check_returncode()
</code></pre>
<p>But it's Python, so there's an even more convenient argument <code>check</code> which does the same thing automatically for you:</p>
<pre><code>result = subprocess.run(..., check=True)
</code></pre>
<h2>stderr should be inside stdout</h2>
<p>You might want to have all program output inside stdout, even errors. To accomplish this, run</p>
<pre><code>result = subprocess.run(..., stderr=subprocess.STDOUT)
</code></pre>
<p><code>result.stderr</code> will then be <code>None</code> and <code>result.stdout</code> will contain everything.</p>
<h2>Using shell=False with an argument string</h2>
<p><code>shell=False</code> expects a <strong>list</strong> of arguments. You might however, split an argument string on your own using shlex.</p>
<pre><code>import subprocess
import shlex
subprocess.run(shlex.split(&quot;ls -a&quot;))
</code></pre>
<p>That's it.</p>
<h1>Common Problems</h1>
<p>Chances are high you just started using Python when you come across this question. Let's look at some common problems.</p>
<blockquote>
<p>FileNotFoundError: [Errno 2] No such file or directory: 'ls -a': 'ls -a'</p>
</blockquote>
<p><em>You're running a subprocess without <code>shell=True</code> . Either use a list (<code>[&quot;ls&quot;, &quot;-a&quot;]</code>) or set <code>shell=True</code>.</em></p>
<blockquote>
<p>TypeError: [...] NoneType [...]</p>
</blockquote>
<p><em>Check that you've set <code>capture_output=True</code>.</em></p>
<blockquote>
<p>TypeError: a bytes-like object is required, not [...]</p>
</blockquote>
<p><em>You always receive byte results from your program. If you want to work with it like a normal string, set <code>text=True</code>.</em></p>
<blockquote>
<p>subprocess.CalledProcessError: Command '[...]' returned non-zero exit status 1.</p>
</blockquote>
<p><em>Your command didn't run successfully. You could disable returncode checking or check your actual program's validity.</em></p>
<blockquote>
<p>TypeError: <strong>init</strong>() got an unexpected keyword argument [...]</p>
</blockquote>
<p><em>You're likely using a version of Python older than 3.7.0; update it to the most recent one available. Otherwise there are other answers in this Stack Overflow post showing you older alternative solutions.</em></p>
<h4> Comment 118133803 fameman: </h4>Summing up, <code>os.system(...)</code> is valid to use, indeed. But as soon as you&#39;re writing more than a quick python helper script, I&#39;d recommend you to go for subprocess.run without <code>shell=True</code>. For more information about the drawbacks of os.system, I&#39;d like to propose you a read through this SO answer: <a href="https://stackoverflow.com/a/44731082/6685358">stackoverflow.com/a/44731082/6685358</a><br><h4> Comment 118105684 reducing activity: </h4>&quot;The big advantage of os.system(...) was its simplicity. subprocess is better&quot; - how subprocess is better? I am happily using os.system, not sure how switching to subprocess and remembering extra <code>shell=True</code> benefits me. What kind of thing is better in subprocess?<br><h4> Comment 118133731 fameman: </h4>You&#39;re right in that <code>os.system(...)</code> is a reasonable choice for executing commands in terms of simple &quot;blind&quot; execution. However, the use cases are rather limited - as soon as you want to capture the output, you have to use a whole other library and then you start having both - subprocess and os for similar use cases in your code. I prefer to keep the code clean and use only one of them.  Second, and I would have put that section at the top but the TL;DR has to answer the question <b>exactly</b>, you should <b>not</b> use <code>shell=True</code>, but instead what I&#39;ve written in the <code>Preferred Way</code> section.<br><h4> Comment 118133786 fameman: </h4>The problem with <code>os.system(...)</code> and <code>shell=True</code> is that you&#39;re spawning a new shell process, just to execute your command. This means, you have to do manual escaping which is not as simple as you might think - especially when targeting both POSIX and Windows. For user-supplied input, this is a no-go (just imagine the user entered something with <code>&quot;</code> quotes - you&#39;d have to escape them as well). Also, the shell process itself could load code you don&#39;t need - not only does it delay the program, but it could also lead to unexpected side effects, ending with a wrong return code.<br>------------------------------------------------------------------ <br><h3> Answer 89304 Martin W: </h3><p><code>os.system</code> is OK, but kind of dated.  It's also not very secure.  Instead, try <code>subprocess</code>.  <code>subprocess</code> does not call sh directly and is therefore more secure than <code>os.system</code>.</p>

<p>Get more information <a href="https://docs.python.org/library/subprocess.html" rel="noreferrer">here</a>.</p>
<h4> Comment 94039191 tripleee: </h4>While I agree with the overall recommendation, <code>subprocess</code> does not remove all of the security problems, and has some pesky issues of its own.<br>------------------------------------------------------------------ <br><h3> Answer 26305089 stuckintheshuck: </h3><p>There is also <a href="http://plumbum.readthedocs.org/en/latest/">Plumbum</a></p>

<pre><code>&gt;&gt;&gt; from plumbum import local
&gt;&gt;&gt; ls = local["ls"]
&gt;&gt;&gt; ls
LocalCommand(&lt;LocalPath /bin/ls&gt;)
&gt;&gt;&gt; ls()
u'build.py\ndist\ndocs\nLICENSE\nplumbum\nREADME.rst\nsetup.py\ntests\ntodo.txt\n'
&gt;&gt;&gt; notepad = local["c:\\windows\\notepad.exe"]
&gt;&gt;&gt; notepad()                                   # Notepad window pops up
u''                                             # Notepad window is closed by user, command returns
</code></pre>
<h4> Comment 118415297 Peter Mortensen: </h4>An explanation would be in order.<br>------------------------------------------------------------------ <br><h3> Answer 31114625 Niranga: </h3><p>Use:</p>

<pre><code>import os

cmd = 'ls -al'

os.system(cmd)
</code></pre>

<p><strong>os - This module provides a portable way of using operating system-dependent functionality.</strong></p>

<p>For the more <code>os</code> functions, <a href="https://docs.python.org/2/library/os.html" rel="noreferrer">here</a> is the documentation.</p>
<h4> Comment 56118340 Corey Goldberg: </h4>it&#39;s also deprecated.  use subprocess<br>------------------------------------------------------------------ <br><h3> Answer 50101887 Samadi Salahedine: </h3><p>It can be this simple:</p>

<pre><code>import os
cmd = "your command"
os.system(cmd)
</code></pre>
<h4> Comment 94038650 tripleee: </h4>This fails to point out the drawbacks, which are explained in much more detail in <a href="https://www.python.org/dev/peps/pep-0324/" rel="nofollow noreferrer">PEP-324</a>. The documentation for <code>os.system</code> explicitly recommends avoiding it in favor of <code>subprocess</code>.<br>------------------------------------------------------------------ <br><h3> Answer 2030768 Atinc Delican: </h3><p>There is another difference here which is not mentioned previously.</p>

<p><code>subprocess.Popen</code> executes the &lt;command> as a subprocess. In my case, I need to execute file &lt;a> which needs to communicate with another program, &lt;b>. </p>

<p>I tried subprocess, and execution was successful. However &lt;b> could not communicate with &lt;a>.
Everything is normal when I run both from the terminal.</p>

<p>One more: 
(NOTE: kwrite behaves different from other applications. If you try the below with Firefox, the results will not be the same.)</p>

<p>If you try <code>os.system("kwrite")</code>, program flow freezes until the user closes kwrite. To overcome that I tried instead <code>os.system(konsole -e kwrite)</code>. This time program continued to flow, but kwrite became the subprocess of the console.</p>

<p>Anyone runs the kwrite not being a subprocess (i.e. in the system monitor it must appear at the leftmost edge of the tree).</p>
<h4> Comment 88350869 Peter Mortensen: </h4>What do you mean by <i>&quot;Anyone runs the kwrite not being a subprocess&quot;</i>?<br><h4> Comment 120034031 tripleee: </h4>It is baffling indeed that <code>subprocess</code> runs a subprocess.<br>------------------------------------------------------------------ <br><h3> Answer 10988365 Saurabh Bangad: </h3><p><code>os.system</code> does not allow you to store results, so if you want to store results in some list or something, a <code>subprocess.call</code> works.</p>
------------------------------------------------------------------ <br><h3> Answer 4728086 cdunn2001: </h3><p><code>subprocess.check_call</code> is convenient if you don't want to test return values. It throws an exception on any error.</p>
------------------------------------------------------------------ <br><h3> Answer 23391049 Emil Stenstr&#246;m: </h3><p>I tend to use <a href="https://docs.python.org/2/library/subprocess.html" rel="noreferrer">subprocess</a> together with <a href="https://docs.python.org/2/library/shlex.html" rel="noreferrer">shlex</a> (to handle escaping of quoted strings):</p>

<pre><code>&gt;&gt;&gt; import subprocess, shlex
&gt;&gt;&gt; command = 'ls -l "/your/path/with spaces/"'
&gt;&gt;&gt; call_params = shlex.split(command)
&gt;&gt;&gt; print call_params
["ls", "-l", "/your/path/with spaces/"]
&gt;&gt;&gt; subprocess.call(call_params)
</code></pre>
------------------------------------------------------------------ <br><h3> Answer 40824514 Yuval Atzmon: </h3><p>Under Linux, in case you would like to call an external command that will execute independently (will keep running after the Python script terminates), you can use a simple queue as <a href="http://vicerveza.homeunix.net/%7Eviric/soft/ts/" rel="noreferrer">task spooler</a> or the <a href="https://linux.die.net/man/1/at" rel="noreferrer">at</a> command.</p>
<p>An example with task spooler:</p>
<pre><code>import os
os.system('ts &lt;your-command&gt;')
</code></pre>
<p>Notes about task spooler (<code>ts</code>):</p>
<ol>
<li><p>You could set the number of concurrent processes to be run (&quot;slots&quot;) with:</p>
<p><code>ts -S &lt;number-of-slots&gt;</code></p>
</li>
<li><p>Installing <code>ts</code> doesn't requires admin privileges. You can download and compile it from source with a simple <code>make</code>, add it to your path and you're done.</p>
</li>
</ol>
<h4> Comment 94039329 tripleee: </h4><code>ts</code> is not standard on any distro I know of, though the pointer to <code>at</code> is mildly useful. You should probably also mention <code>batch</code>. As elsewhere, the <code>os.system()</code> recommendation should probably at least mention that <code>subprocess</code> is its recommended replacement.<br>------------------------------------------------------------------ <br><h3> Answer 23416345 houqp: </h3><p>I wrote a library for this, <em><a href="https://github.com/houqp/shell.py" rel="nofollow noreferrer">shell.py</a></em>.</p>
<p>It's basically a wrapper for popen and shlex for now. It also supports piping commands, so you can chain commands easier in Python. So you can do things like:</p>
<pre><code>ex('echo hello shell.py') | &quot;awk '{print $2}'&quot;
</code></pre>
------------------------------------------------------------------ <br><h3> Answer 52339862 Valery Ramusik: </h3><p><strong><a href="http://www.pyinvoke.org/" rel="noreferrer">Invoke</a></strong> is a Python (2.7 and 3.4+) task execution tool and library. It provides a clean, high-level API for running shell commands:</p>
<pre><code>&gt;&gt;&gt; from invoke import run
&gt;&gt;&gt; cmd = &quot;pip install -r requirements.txt&quot;
&gt;&gt;&gt; result = run(cmd, hide=True, warn=True)
&gt;&gt;&gt; print(result.ok)
True
&gt;&gt;&gt; print(result.stdout.splitlines()[-1])
Successfully installed invocations-0.13.0 pep8-1.5.7 spec-1.3.1
</code></pre>
<h4> Comment 96968474 user9074332: </h4>This is a great library.  I was trying to explain it to a coworker the other day adn described it like this: <code>invoke</code> is to <code>subprocess</code> as <code>requests</code> is to <code>urllib3</code>.<br>------------------------------------------------------------------ <br><h3> Answer 37877635 Swadhikar: </h3><p>In Windows you can just import the <code>subprocess</code> module and run external commands by calling <code>subprocess.Popen()</code>, <code>subprocess.Popen().communicate()</code> and <code>subprocess.Popen().wait()</code> as below:</p>

<pre><code># Python script to run a command line
import subprocess

def execute(cmd):
    """
        Purpose  : To execute a command and return exit status
        Argument : cmd - command to execute
        Return   : exit_code
    """
    process = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    (result, error) = process.communicate()

    rc = process.wait()

    if rc != 0:
        print "Error: failed to execute command:", cmd
        print error
    return result
# def

command = "tasklist | grep python"
print "This process detail: \n", execute(command)
</code></pre>

<p>Output:</p>

<pre><code>This process detail:
python.exe                     604 RDP-Tcp#0                  4      5,660 K
</code></pre>
------------------------------------------------------------------ <br><h3> Answer 11507283 kanghyojmun: </h3><p>You can use Popen, and then you can check the procedure's status:</p>

<pre><code>from subprocess import Popen

proc = Popen(['ls', '-l'])
if proc.poll() is None:
    proc.kill()
</code></pre>

<p>Check out <a href="http://docs.python.org/library/subprocess.html#popen-objects" rel="noreferrer">subprocess.Popen</a>.</p>
------------------------------------------------------------------ <br><h3> Answer 25476624 amehta: </h3><p>A simple way is to use the <a href="https://docs.python.org/2/library/os.html" rel="noreferrer">os module</a>:</p>

<pre><code>import os
os.system('ls')
</code></pre>

<p>Alternatively, you can also use the subprocess module:</p>

<pre><code>import subprocess
subprocess.check_call('ls')
</code></pre>

<p>If you want the result to be stored in a variable try:</p>

<pre><code>import subprocess
r = subprocess.check_output('ls')
</code></pre>
------------------------------------------------------------------ <br><h3> Answer 38477871 IRSHAD: </h3><p>To fetch the network id from the <a href="https://en.wikipedia.org/wiki/OpenStack" rel="noreferrer">OpenStack</a> <a href="https://en.wikipedia.org/wiki/OpenStack#Networking_(Neutron)" rel="noreferrer">Neutron</a>:</p>

<pre><code>#!/usr/bin/python
import os
netid = "nova net-list | awk '/ External / { print $2 }'"
temp = os.popen(netid).read()  /* Here temp also contains new line (\n) */
networkId = temp.rstrip()
print(networkId)
</code></pre>

<p>Output of <strong>nova net-list</strong></p>

<pre><code>+--------------------------------------+------------+------+
| ID                                   | Label      | CIDR |
+--------------------------------------+------------+------+
| 431c9014-5b5d-4b51-a357-66020ffbb123 | test1      | None |
| 27a74fcd-37c0-4789-9414-9531b7e3f126 | External   | None |
| 5a2712e9-70dc-4b0e-9281-17e02f4684c9 | management | None |
| 7aa697f5-0e60-4c15-b4cc-9cb659698512 | Internal   | None |
+--------------------------------------+------------+------+
</code></pre>

<p>Output of <strong>print(networkId)</strong></p>

<pre><code>27a74fcd-37c0-4789-9414-9531b7e3f126
</code></pre>
<h4> Comment 94039444 tripleee: </h4>You should not recommend <code>os.popen()</code> in 2016. The Awk script could easily be replaced with native Python code.<br>------------------------------------------------------------------ <br><h3> Answer 11644161 Garfield: </h3><p>Very simplest way to run any command and get the result back:</p>

<pre><code>from commands import getstatusoutput

try:
    return getstatusoutput("ls -ltr")
except Exception, e:
    return None
</code></pre>
<h4> Comment 94038710 tripleee: </h4>Indeed, the <a href="https://docs.python.org/2/library/commands.html" rel="nofollow noreferrer"><code>commands</code> documentation from Python 2.7</a> says it was deprecated in 2.6 and will be removed in 3.0.<br>------------------------------------------------------------------ <br><h3> Answer 59090212 N.Nonkovic: </h3><p><em><strong>MOST OF THE CASES:</strong></em></p>
<p><strong>For the most of cases, a short snippet of code like this is all you are going to need</strong>:</p>
<pre class="lang-py prettyprint-override"><code>import subprocess
import shlex

source = &quot;test.txt&quot;
destination = &quot;test_copy.txt&quot;

base = &quot;cp {source} {destination}'&quot;
cmd = base.format(source=source, destination=destination)
subprocess.check_call(shlex.split(cmd))
</code></pre>
<p><strong>It is clean and simple</strong>.</p>
<blockquote>
<p><code>subprocess.check_call</code> run command with arguments and wait for
command to complete.</p>
<p><code>shlex.split</code> split the string cmd using shell-like syntax</p>
</blockquote>
<p><em><strong>REST OF THE CASES:</strong></em></p>
<p>If this do not work for some specific command, most probably you have a problem with <a href="https://en.wikipedia.org/wiki/List_of_command-line_interpreters" rel="nofollow noreferrer"> <strong>command-line interpreters</strong></a>. The operating system chose the default one which is not suitable for your type of program or could not found an adequate one on the system executable path.</p>
<p><strong>Example:</strong></p>
<p>Using the redirection operator on a Unix system</p>
<pre class="lang-py prettyprint-override"><code>input_1 = &quot;input_1.txt&quot;
input_2 = &quot;input_2.txt&quot;
output = &quot;merged.txt&quot;
base_command = &quot;/bin/bash -c 'cat {input} &gt;&gt; {output}'&quot;

base_command.format(input_1, output=output)
subprocess.check_call(shlex.split(base_command))

base_command.format(input_2, output=output)
subprocess.check_call(shlex.split(base_command))
</code></pre>
<blockquote>
<p>As it is stated in <a href="https://www.python.org/dev/peps/pep-0020/" rel="nofollow noreferrer">The Zen of Python</a>: <strong>Explicit is better than
implicit</strong></p>
</blockquote>
<p>So if using a Python &gt;=3.6 function, it would look something like this:</p>
<pre class="lang-py prettyprint-override"><code>import subprocess
import shlex

def run_command(cmd_interpreter: str, command: str) -&gt; None:
    base_command = f&quot;{cmd_interpreter} -c '{command}'&quot;
    subprocess.check_call(shlex.split(base_command)

</code></pre>
------------------------------------------------------------------ <br><h3> Answer 49441486 am5: </h3><p>Often, I use the following function for external commands, and this is especially handy for <strong>long running processes</strong>. The below method <strong>tails process output</strong> <em>while</em> it is running and returns the output, <strong>raises an exception</strong> if process fails.</p>

<p>It comes out if the process is done using the <strong>poll() method on the process</strong>.</p>

<pre><code>import subprocess,sys

def exec_long_running_proc(command, args):
    cmd = "{} {}".format(command, " ".join(str(arg) if ' ' not in arg else arg.replace(' ','\ ') for arg in args))
    print(cmd)
    process = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)

    # Poll process for new output until finished
    while True:
        nextline = process.stdout.readline().decode('UTF-8')
        if nextline == '' and process.poll() is not None:
            break
        sys.stdout.write(nextline)
        sys.stdout.flush()

    output = process.communicate()[0]
    exitCode = process.returncode

    if (exitCode == 0):
        return output
    else:
        raise Exception(command, exitCode, output)
</code></pre>

<p><strong>You can invoke it like this:</strong></p>

<pre><code>exec_long_running_proc(command = "hive", args=["-f", hql_path])
</code></pre>
<h4> Comment 93572709 am5: </h4>@sbk <code>repr(arg)</code> didn&#39;t really help, the above code handles spaces as well. Now the following works <code>exec_long_running_proc(command = &quot;ls&quot;, args=[&quot;-l&quot;, &quot;~&#47;test file*&quot;])</code><br><h4> Comment 87797622 sbk: </h4>You&#39;ll get unexpected results passing an arg with space. Using <code>repr(arg)</code> instead of <code>str(arg)</code> might help by the mere coincidence that python and sh escape quotes the same way<br>------------------------------------------------------------------ <br><h3> Answer 33118899 user2081554: </h3><p>Here are my two cents: In my view, this is the best practice when dealing with external commands...</p>

<p>These are the return values from the execute method...</p>

<pre><code>pass, stdout, stderr = execute(["ls","-la"],"/home/user/desktop")
</code></pre>

<p>This is the execute method...</p>

<pre><code>def execute(cmdArray,workingDir):

    stdout = ''
    stderr = ''

    try:
        try:
            process = subprocess.Popen(cmdArray,cwd=workingDir, stdout=subprocess.PIPE, stderr=subprocess.PIPE, bufsize=1)
        except OSError:
            return [False, '', 'ERROR : command(' + ' '.join(cmdArray) + ') could not get executed!']

        for line in iter(process.stdout.readline, b''):

            try:
                echoLine = line.decode("utf-8")
            except:
                echoLine = str(line)

            stdout += echoLine

        for line in iter(process.stderr.readline, b''):

            try:
                echoLine = line.decode("utf-8")
            except:
                echoLine = str(line)

            stderr += echoLine

    except (KeyboardInterrupt,SystemExit) as err:
        return [False,'',str(err)]

    process.stdout.close()

    returnCode = process.wait()
    if returnCode != 0 or stderr != '':
        return [False, stdout, stderr]
    else:
        return [True, stdout, stderr]
</code></pre>
<h4> Comment 63894693 pppery: </h4>Deadlock potential: use the <code>.communicate</code> method instead<br><h4> Comment 94039026 tripleee: </h4>Better yet, avoid <code>Popen()</code> and use the higher-level API which is now collected into the single function <code>subprocess.run()</code><br>------------------------------------------------------------------ <br><h3> Answer 17202916 imagineerThat: </h3><p>Just to add to the discussion, if you include using a Python console, you can call external commands from <a href="http://en.wikipedia.org/wiki/IPython" rel="noreferrer">IPython</a>. While in the IPython prompt, you can call shell commands by prefixing '!'. You can also combine Python code with the shell, and assign the output of shell scripts to Python variables.</p>

<p>For instance:</p>

<pre><code>In [9]: mylist = !ls

In [10]: mylist
Out[10]:
['file1',
 'file2',
 'file3',]
</code></pre>
------------------------------------------------------------------ <br><h3> Answer 53063521 C&#233;dric: </h3><p>I wrote a small library to help with this use case:</p>
<p><a href="https://pypi.org/project/citizenshell/" rel="nofollow noreferrer">https://pypi.org/project/citizenshell/</a></p>
<p>It can be installed using</p>
<pre><code>pip install citizenshell
</code></pre>
<p>And then used as follows:</p>
<pre><code>from citizenshell import sh
assert sh(&quot;echo Hello World&quot;) == &quot;Hello World&quot;
</code></pre>
<p>You can separate standard output from standard error and extract the exit code as follows:</p>
<pre><code>result = sh(&quot;&gt;&amp;2 echo error &amp;&amp; echo output &amp;&amp; exit 13&quot;)
assert result.stdout() == [&quot;output&quot;]
assert result.stderr() == [&quot;error&quot;]
assert result.exit_code() == 13
</code></pre>
<p>And the cool thing is that you don't have to wait for the underlying shell to exit before starting processing the output:</p>
<pre><code>for line in sh(&quot;for i in 1 2 3 4; do echo -n 'It is '; date +%H:%M:%S; sleep 1; done&quot;, wait=False)
    print &quot;&gt;&gt;&gt;&quot;, line + &quot;!&quot;
</code></pre>
<p>will print the lines as they are available thanks to the wait=False</p>
<pre class="lang-none prettyprint-override"><code>&gt;&gt;&gt; It is 14:24:52!
&gt;&gt;&gt; It is 14:24:53!
&gt;&gt;&gt; It is 14:24:54!
&gt;&gt;&gt; It is 14:24:55!
</code></pre>
<p>More examples can be found at <a href="https://github.com/meuter/citizenshell" rel="nofollow noreferrer">https://github.com/meuter/citizenshell</a></p>
------------------------------------------------------------------ <br><h3> Answer 23030076 andruso: </h3><p>Use <a href="https://docs.python.org/2/library/subprocess.html" rel="noreferrer">subprocess.call</a>:</p>



<pre class="lang-python prettyprint-override"><code>from subprocess import call

# Using list
call(["echo", "Hello", "world"])

# Single string argument varies across platforms so better split it
call("echo Hello world".split(" "))
</code></pre>
------------------------------------------------------------------ <br><h3> Answer 49644672 rashok: </h3><p><strong>Calling an external command in Python</strong></p>

<p>A simple way to call an external command is using <code>os.system(...)</code>. And this function returns the exit value of the command. But the drawback is we won't get stdout and stderr.</p>

<pre><code>ret = os.system('some_cmd.sh')
if ret != 0 :
    print 'some_cmd.sh execution returned failure'
</code></pre>

<p><strong>Calling an external command in Python in background</strong></p>

<p><code>subprocess.Popen</code> provides more flexibility for running an external command rather than using <code>os.system</code>. We can start a command in the background and wait for it to finish. And after that we can get the stdout and stderr.</p>

<pre><code>proc = subprocess.Popen(["./some_cmd.sh"], stdout=subprocess.PIPE)
print 'waiting for ' + str(proc.pid)
proc.wait()
print 'some_cmd.sh execution finished'
(out, err) = proc.communicate()
print 'some_cmd.sh output : ' + out
</code></pre>

<p><strong>Calling a long running external command in Python in the background and stop after some time</strong></p>

<p>We can even start a long running process in the background using <code>subprocess.Popen</code> and kill it after sometime once its task is done.</p>

<pre><code>proc = subprocess.Popen(["./some_long_run_cmd.sh"], stdout=subprocess.PIPE)
# Do something else
# Now some_long_run_cmd.sh exeuction is no longer needed, so kill it
os.system('kill -15 ' + str(proc.pid))
print 'Output : ' proc.communicate()[0]
</code></pre>
------------------------------------------------------------------ <br><h3> Answer 16062355 Jens Timmerman: </h3><p>There are a lot of different ways to run external commands in Python,
and all of them have their own plus sides and drawbacks.</p>
<p>My colleagues and me have been writing Python system administration tools, so we need to run a lot of external commands, and sometimes you want them to block or run asynchronously, time-out, update every second, etc.</p>
<p>There are also different ways of handling the return code and errors,
and you might want to parse the output, and provide new input (in an <a href="http://en.wikipedia.org/wiki/Expect" rel="nofollow noreferrer">expect</a> kind of style). Or you will need to redirect <a href="https://en.wikipedia.org/wiki/Standard_streams#Standard_input_(stdin)" rel="nofollow noreferrer">standard input</a>, <a href="https://en.wikipedia.org/wiki/Standard_streams#Standard_output_.28stdout.29" rel="nofollow noreferrer">standard output</a>, and <a href="https://en.wikipedia.org/wiki/Standard_streams#Standard_error_(stderr)" rel="nofollow noreferrer">standard error</a> to run in a different tty (e.g., when using <a href="https://en.wikipedia.org/wiki/GNU_Screen" rel="nofollow noreferrer">GNU Screen</a>).</p>
<p>So you will probably have to write a lot of wrappers around the external command. So here is a Python module which we have written which can handle
almost anything you would want, and if not, it's very flexible so you can easily extend it:</p>
<p><a href="https://github.com/hpcugent/vsc-base/blob/master/lib/vsc/utils/run.py" rel="nofollow noreferrer">https://github.com/hpcugent/vsc-base/blob/master/lib/vsc/utils/run.py</a></p>
<p>It doesn't work stand-alone and requires some of our other tools, and got a lot of specialised functionality over the years, so it might not be a drop-in replacement for you, but it can give you a lot of information on how the internals of Python for running commands work and ideas on how to handle certain situations.</p>
------------------------------------------------------------------ <br><h3> Answer 38012358 David Okwii: </h3><p>Use:</p>

<pre><code>import subprocess

p = subprocess.Popen("df -h", shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE).communicate()[0]
print p.split("\n")
</code></pre>

<p>It gives nice output which is easier to work with:</p>

<pre><code>['Filesystem      Size  Used Avail Use% Mounted on',
 '/dev/sda6        32G   21G   11G  67% /',
 'none            4.0K     0  4.0K   0% /sys/fs/cgroup',
 'udev            1.9G  4.0K  1.9G   1% /dev',
 'tmpfs           387M  1.4M  386M   1% /run',
 'none            5.0M     0  5.0M   0% /run/lock',
 'none            1.9G   58M  1.9G   3% /run/shm',
 'none            100M   32K  100M   1% /run/user',
 '/dev/sda5       340G  222G  100G  69% /home',
 '']
</code></pre>
------------------------------------------------------------------ <br><h3> Answer 48548332 user8468899: </h3><p>As an example (in Linux):</p>

<pre><code>import subprocess
subprocess.run('mkdir test.dir', shell=True)
</code></pre>

<p>This creates test.dir in the current directory.
Note that this also works:</p>

<pre><code>import subprocess
subprocess.call('mkdir test.dir', shell=True)
</code></pre>

<p>The equivalent code using os.system is:</p>

<pre><code>import os
os.system('mkdir test.dir')
</code></pre>

<p>Best practice would be to use subprocess instead of os, with .run favored over .call. 
All you need to know about subprocess is <a href="https://docs.python.org/3.5/library/subprocess.html" rel="noreferrer">here</a>.
Also, note that all Python documentation is available for download from <a href="https://docs.python.org/3/download.html" rel="noreferrer">here</a>. I downloaded the PDF packed as .zip. I mention this because there's a nice overview of the os module in tutorial.pdf (page 81). Besides, it's an authoritative resource for Python coders.</p>
<h4> Comment 85785785 Nick: </h4>According to <a href="https://docs.python.org/2/library/subprocess.html#frequently-used-arguments" rel="nofollow noreferrer">docs.python.org/2/library/&hellip;</a>, &quot;shell=True&quot; may raise a security concern.<br><h4> Comment 94038828 tripleee: </h4>The basic warning is in the documentation but this question explains it in more detail: <a href="https://stackoverflow.com/questions/3172470/actual-meaning-of-shell-true-in-subprocess" title="actual meaning of shell true in subprocess">stackoverflow.com/questions/3172470/&hellip;</a><br><h4> Comment 85832373 user8468899: </h4>@Nick Predley: noted, but &quot;shell=False&quot; doesn&#39;t perform the desired function. What specifically are the security concerns and what&#39;s the alternative? Please let me know asap: I do not wish to post anything which may cause problems for anyone viewing this.<br>------------------------------------------------------------------ <br><h3> Answer 54414217 Farzad Vertigo: </h3><p>For using <code>subprocess</code> in Python 3.5+, the following did the trick for me on Linux:</p>
<pre><code>import subprocess

# subprocess.run() returns a completed process object that can be inspected
c = subprocess.run([&quot;ls&quot;, &quot;-ltrh&quot;], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
print(c.stdout.decode('utf-8'))
</code></pre>
<p>As mentioned in <a href="https://docs.python.org/3/library/subprocess.html#subprocess.CompletedProcess" rel="nofollow noreferrer">the documentation</a>, <code>PIPE</code> values are byte sequences and for properly showing them decoding should be considered. For later versions of Python, <code>text=True</code> and <code>encoding='utf-8'</code> are added to kwargs of <a href="https://docs.python.org/3.6/library/subprocess.html#subprocess.run" rel="nofollow noreferrer"><code>subprocess.run()</code></a>.</p>
<p>The output of the abovementioned code is:</p>
<pre><code>total 113M
-rwxr-xr-x  1 farzad farzad  307 Jan 15  2018 vpnscript
-rwxrwxr-x  1 farzad farzad  204 Jan 15  2018 ex
drwxrwxr-x  4 farzad farzad 4.0K Jan 22  2018 scripts
.... # Some other lines
</code></pre>
------------------------------------------------------------------ <br><h3> Answer 22395328 Jake W: </h3><p>After some research, I have the following code which works very well for me. It basically prints both standard output and standard error in real time.</p>
<pre><code>stdout_result = 1
stderr_result = 1


def stdout_thread(pipe):
    global stdout_result
    while True:
        out = pipe.stdout.read(1)
        stdout_result = pipe.poll()
        if out == '' and stdout_result is not None:
            break

        if out != '':
            sys.stdout.write(out)
            sys.stdout.flush()


def stderr_thread(pipe):
    global stderr_result
    while True:
        err = pipe.stderr.read(1)
        stderr_result = pipe.poll()
        if err == '' and stderr_result is not None:
            break

        if err != '':
            sys.stdout.write(err)
            sys.stdout.flush()


def exec_command(command, cwd=None):
    if cwd is not None:
        print '[' + ' '.join(command) + '] in ' + cwd
    else:
        print '[' + ' '.join(command) + ']'

    p = subprocess.Popen(
        command, stdout=subprocess.PIPE, stderr=subprocess.PIPE, cwd=cwd
    )

    out_thread = threading.Thread(name='stdout_thread', target=stdout_thread, args=(p,))
    err_thread = threading.Thread(name='stderr_thread', target=stderr_thread, args=(p,))

    err_thread.start()
    out_thread.start()

    out_thread.join()
    err_thread.join()

    return stdout_result + stderr_result
</code></pre>
<h4> Comment 50758994 jfs: </h4>your code may lose data when the subprocess exits while there is some data is buffered. Read until EOF instead, see <a href="http://stackoverflow.com/q/4984428/4279">teed_call()</a><br>------------------------------------------------------------------ <br><h3> Answer 39969619 Rajiv Sharma: </h3><p>Here is calling an external command and return or print the command's output:</p>

<p>Python <a href="https://docs.python.org/2/library/subprocess.html" rel="nofollow noreferrer">Subprocess</a> check_output is good for</p>

<blockquote>
  <p>Run command with arguments and return its output as a byte string.</p>
</blockquote>

<pre><code>import subprocess
proc = subprocess.check_output('ipconfig /all')
print proc
</code></pre>
<h4> Comment 94038929 tripleee: </h4>The argument should properly be tokenized into a list, or you should explicitly pass in <code>shell=True</code>. In Python 3.x (where x &gt; 3 I think) you can retrieve the output as a proper string with <code>universal_newlines=True</code> and you probably want to switch to <code>subproces.run()</code><br>------------------------------------------------------------------ <br><h3> Answer 50242060 dportman: </h3><p>If you need to call a shell command from a Python notebook (like <a href="https://en.wikipedia.org/wiki/IPython#Project_Jupyter" rel="noreferrer">Jupyter</a>, Zeppelin, Databricks, or Google Cloud Datalab) you can just use the <code>!</code> prefix.</p>

<p>For example,</p>

<pre><code>!ls -ilF
</code></pre>
------------------------------------------------------------------ <br><h3> Answer 57696996 noɥʇʎԀʎzɐɹƆ: </h3><p>If you're writing a Python shell script and have <a href="http://en.wikipedia.org/wiki/IPython" rel="nofollow noreferrer">IPython</a> installed on your system, you can use the bang prefix to run a shell command inside IPython:</p>

<pre><code>!ls
filelist = !ls
</code></pre>
<h4> Comment 104456009 noɥʇʎԀʎzɐɹƆ: </h4>@PeterMortensen I don&#39;t think it works in DOS, but it should work in Cygwin.<br>------------------------------------------------------------------ <br><h3> Answer 16089689 Colonel Panic: </h3><p>Update 2015: Python 3.5 added <a href="https://docs.python.org/3/library/subprocess.html#subprocess.run" rel="nofollow noreferrer">subprocess.run</a> which is much easier to use than subprocess.Popen. I recommend that.</p>
<pre class="lang-py prettyprint-override"><code>&gt;&gt;&gt; subprocess.run([&quot;ls&quot;, &quot;-l&quot;])  # doesn't capture output
CompletedProcess(args=['ls', '-l'], returncode=0)

&gt;&gt;&gt; subprocess.run(&quot;exit 1&quot;, shell=True, check=True)
Traceback (most recent call last):
  ...
subprocess.CalledProcessError: Command 'exit 1' returned non-zero exit status 1

&gt;&gt;&gt; subprocess.run([&quot;ls&quot;, &quot;-l&quot;, &quot;/dev/null&quot;], capture_output=True)
CompletedProcess(args=['ls', '-l', '/dev/null'], returncode=0,
stdout=b'crw-rw-rw- 1 root root 1, 3 Jan 23 16:23 /dev/null\n', stderr=b'')
</code></pre>
<h4> Comment 22988454 Misch: </h4>Deprecated doesn&#39;t only mean &quot;isn&#39;t developed anymore&quot; but also &quot;you are discouraged from using this&quot;. Deprecated features may break anytime, may be removed anytime, or may dangerous. You should never use this in important code. Deprecation is merely a better way than removing a feature immediately, because it gives programmers the time to adapt and replace their deprecated functions.<br><h4> Comment 23118703 Misch: </h4>With dangerous, I didn&#39;t mean that it may be removed anytime (that&#39;s a different problem), neither did I say that it is dangerous to use this specific module. However it may become dangerous if a security vulnerability is discovered but the module isn&#39;t further developed or maintained. (I don&#39;t want to say that this module is or isn&#39;t vulnerable to security issues, just talking about deprecated stuff in general)<br><h4> Comment 22988607 Misch: </h4>Just to prove my point: &quot;Deprecated since version 2.6: The commands module has been removed in Python 3. Use the subprocess module instead.&quot;<br><h4> Comment 23118138 Colonel Panic: </h4>It&#39;s not dangerous! The Python devs are careful only to break features between major releases (ie. between 2.x and 3.x). I&#39;ve been using the commands module since 2004&#39;s Python 2.4. It works the same today in Python 2.7.<br>------------------------------------------------------------------ <br><h3> Answer 39447501 liuyip: </h3><p>There are many ways to call a command.</p>

<ul>
<li>For example:</li>
</ul>

<p>if <code>and.exe</code> needs two parameters. In cmd we can call <code>sample.exe</code> use this:
   <code>and.exe 2 3</code> and it show <code>5</code> on screen.</p>

<p>If we use a Python script to call <code>and.exe</code>, we should do like..</p>

<ol>
<li><p><code>os.system(cmd,...)</code></p>

<ul>
<li><code>os.system(("and.exe" + " " + "2" + " " + "3"))</code></li>
</ul></li>
<li><p><code>os.popen(cmd,...)</code></p>

<ul>
<li><code>os.popen(("and.exe" + " " + "2" + " " + "3"))</code></li>
</ul></li>
<li><code>subprocess.Popen(cmd,...)</code>

<ul>
<li><code>subprocess.Popen(("and.exe" + " " + "2" + " " + "3"))</code></li>
</ul></li>
</ol>

<p>It's too hard, so we can join cmd with a space:</p>

<pre><code>import os
cmd = " ".join(exename,parameters)
os.popen(cmd)
</code></pre>
<h4> Comment 94038976 tripleee: </h4><code>os.popen</code> should not be recommended and perhaps even mentioned any longer. The <code>subpocess</code> example should pass the arguments as a list instead of joining them with spaces.<br>------------------------------------------------------------------ <br><h3> Answer 36058314 chtenb: </h3><p>For Python 3.5+ it is recommended that you use the <a href="https://docs.python.org/3.5/library/subprocess.html#subprocess.run" rel="nofollow noreferrer">run function from the subprocess module</a>. This returns a <code>CompletedProcess</code> object, from which you can easily obtain the output as well as return code.</p>

<pre><code>from subprocess import PIPE, run

command = ['echo', 'hello']
result = run(command, stdout=PIPE, stderr=PIPE, universal_newlines=True)
print(result.returncode, result.stdout, result.stderr)
</code></pre>
<h4> Comment 72595849 Greg Eremeev: </h4>answer with run function was added in 2015 year. You repeated it. I think it was a reason of down vote<br>------------------------------------------------------------------ <br><h3> Answer 55440842 geckos: </h3><p>If you are <strong>not</strong> using user input in the commands, you can use this:</p>
<pre><code>from os import getcwd
from subprocess import check_output
from shlex import quote

def sh(command):
    return check_output(quote(command), shell=True, cwd=getcwd(), universal_newlines=True).strip()
</code></pre>
<p>And use it as</p>
<pre><code>branch = sh('git rev-parse --abbrev-ref HEAD')
</code></pre>
<p><code>shell=True</code> will spawn a shell, so you can use pipe and such shell things <code>sh('ps aux | grep python')</code>. This is very very handy for running hardcoded commands and processing its output. The <code>universal_lines=True</code> make sure the output is returned in a string instead of binary.</p>
<p><code>cwd=getcwd()</code> will make sure that the command is run with the same working directory as the interpreter. This is handy for Git commands to work like the Git branch name example above.</p>
<p>Some recipes</p>
<ul>
<li>free memory in megabytes: <code>sh('free -m').split('\n')[1].split()[1]</code></li>
<li>free space on / in percent <code>sh('df -m /').split('\n')[1].split()[4][0:-1]</code></li>
<li>CPU load <code>sum(map(float, sh('ps -ef -o pcpu').split('\n')[1:])</code></li>
</ul>
<p>But this isn't safe for user input, from the documentation:</p>
<blockquote>
<p>Security Considerations</p>
<p>Unlike some other popen functions, this implementation will never
implicitly call a system shell. This means that all characters,
including shell metacharacters, can safely be passed to child
processes. If the shell is invoked explicitly, via shell=True, it is
the application’s responsibility to ensure that all whitespace and
metacharacters are quoted appropriately to avoid shell injection
vulnerabilities.</p>
<p>When using shell=True, the shlex.quote() function can be used to
properly escape whitespace and shell metacharacters in strings that
are going to be used to construct shell commands.</p>
</blockquote>
<p>Even using the <code>shlex.quote()</code>, it is good to keep a little paranoid when using user inputs on shell commands. One option is using a hardcoded command to take some generic output and filtering by user input. Anyway using <code>shell=False</code> will make sure that only the exactly process that you want to execute will be executed or you get a <code>No such file or directory</code> error.</p>
<p>Also there is some performance impact on <code>shell=True</code>, from my tests it seems about 20% slower than <code>shell=False</code> (the default).</p>
<pre class="lang-none prettyprint-override"><code>In [50]: timeit(&quot;check_output('ls -l'.split(), universal_newlines=True)&quot;, number=1000, globals=globals())
Out[50]: 2.6801227919995654

In [51]: timeit(&quot;check_output('ls -l', universal_newlines=True, shell=True)&quot;, number=1000, globals=globals())
Out[51]: 3.243950183999914
</code></pre>
------------------------------------------------------------------ <br><h3> Answer 58297652 Vishal: </h3><pre class="lang-py prettyprint-override"><code>import subprocess

p = subprocess.run(["ls", "-ltr"], capture_output=True)
print(p.stdout.decode(), p.stderr.decode())
</code></pre>

<p><strong><a href="https://code.labstack.com/GIzH7jnS" rel="noreferrer">Try online</a></strong></p>
<h4> Comment 118415842 Peter Mortensen: </h4>An explanation would be in order. E.g, what is the idea and how is it different from the previous 50 answers 11 years later?<br><h4> Comment 120033907 tripleee: </h4>This is identical to <a href="https://stackoverflow.com/a/58212263">your own answer from a few days earlier</a> only with even less detail.<br>------------------------------------------------------------------ <br><h3> Answer 72216447 Mr. Day: </h3><p>You can try using <code>os.system()</code> for running external commands.</p>
<p>Example:</p>
<pre><code>import os

try:
  os.system('ls')
  pass
except:
  print(&quot;Error running command&quot;)
  pass
</code></pre>
<p>In the example, the script imports <code>os</code> and tries to run the command listed in <code>os.system()</code>. If the command was to fail then it would print &quot;Error running command&quot; without the script stopping due to the error.</p>
<p>And yes, it’s just that simple!</p>
------------------------------------------------------------------ <br><h3> Answer 31618111 Asif Hasnain: </h3><p>Using the <code>Popen</code> function of the <code>subprocess</code> Python module is the simplest way of running Linux commands. In that, the <code>Popen.communicate()</code> function will give your commands output. For example</p>

<pre><code>import subprocess

..
process = subprocess.Popen(..)   # Pass command and arguments to the function
stdout, stderr = process.communicate()   # Get command output and error
..
</code></pre>
<h4> Comment 94039076 tripleee: </h4>This is no longer true, and probably wasn&#39;t when this answer was posted. You should prefer <code>subprocess.check_call()</code> and friends unless you absolutely need the lower-level control of the more-complex <code>Popen()</code>. In recent Python versions, the go-to workhorse is <code>subprocess.run()</code><br>------------------------------------------------------------------ <br><h3> Answer 59050139 Trect: </h3><p><code>os.popen()</code> is the easiest and the most safest way to execute a command. You can execute any command that you run on the command line. In addition you will also be able to capture the output of the command using <code>os.popen().read()</code></p>

<p>You can do it like this:</p>

<pre><code>import os
output = os.popen('Your Command Here').read()
print (output)
</code></pre>

<p>An example where you list all the files in the current directory:</p>

<pre><code>import os
output = os.popen('ls').read()
print (output)
# Outputs list of files in the directory
</code></pre>
------------------------------------------------------------------ <br><h3> Answer 60427071 Kashif Iftikhar: </h3><p>There are a number of ways of <em>calling</em> an external <em>command</em> from Python. There are some functions and modules with the good helper functions that can make it really easy. But the recommended thing among all is the <code>subprocess</code> module.</p>
<pre><code>import subprocess as s
s.call([&quot;command.exe&quot;, &quot;...&quot;])
</code></pre>
<p>The call function will start the external process, pass some command line arguments and wait for it to finish. When it finishes you continue executing. Arguments in <em>call</em> function are passed through the list. The first argument in the list is the command typically in the form of an executable file and subsequent arguments in the list whatever you want to pass.</p>
<p>If you have called processes from the command line in the windows before, you'll be aware that you often need to quote arguments. You need to put quotations mark around it. If there's a space then there's a backslash and there are some complicated rules, but you can avoid a whole lot of that in Python by using <code>subprocess</code> module because it is a list and each item is known to be a distinct and python can get quoting correctly for you.</p>
<p>In the end, after the list, there are a number of optional parameters one of these is a shell and if you set shell equals to true then your command is going to be run as if you have typed in at the command prompt.</p>
<pre><code>s.call([&quot;command.exe&quot;, &quot;...&quot;], shell=True)
</code></pre>
<p>This gives you access to functionality like piping, you can redirect to files, you can call multiple commands in one thing.</p>
<p>One more thing, if your script relies on the process succeeding then you want to check the result and the result can be checked with the check call helper function.</p>
<pre><code>s.check_call(...)
</code></pre>
<p>It is exactly the same as a call function, it takes the same arguments, takes the same list, you can pass in any of the extra arguments but it going to wait for the functions to complete. And if the exit code of the function is anything other then zero, it will through an exception in the python script.</p>
<p>Finally, if you want tighter control <code>Popen</code> constructor which is also from the <code>subprocess</code> module. It also takes the same arguments as incall &amp; check_call function but it returns an object representing the running process.</p>
<pre><code>p=s.Popen(&quot;...&quot;)
</code></pre>
<p>It does not wait for the running process to finish also it's not going to throw any exception immediately but it gives you an object that will let you do things like wait for it to finish, let you communicate to it, you can redirect standard input, standard output if you want to display output somewhere else and a lot more.</p>
------------------------------------------------------------------ <br><h3> Answer 36913076 Viswesn: </h3><p>I would recommend the following method 'run' and it will help us in getting <a href="https://en.wikipedia.org/wiki/Standard_streams#Standard_output_.28stdout.29" rel="nofollow noreferrer">standard output</a>, <a href="https://en.wikipedia.org/wiki/Standard_streams#Standard_error_(stderr)" rel="nofollow noreferrer">standard error</a> and exit status as a dictionary; the caller of this can read the dictionary return by 'run' method to know the actual state of the process.</p>
<pre><code>  def run (cmd):
       print &quot;+ DEBUG exec({0})&quot;.format(cmd)
       p = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, universal_newlines=True, shell=True)
       (out, err) = p.communicate()
       ret        = p.wait()
       out        = filter(None, out.split('\n'))
       err        = filter(None, err.split('\n'))
       ret        = True if ret == 0 else False
       return dict({'output': out, 'error': err, 'status': ret})
  #end
</code></pre>
<h4> Comment 94039494 tripleee: </h4>This incompletely reimplements something like <code>subprocess.run()</code>. You should particularly avoid <code>shell=True</code> when it&#39;s not strictly necessary.<br><h4> Comment 118415430 Peter Mortensen: </h4>What is <code>#end</code> for?<br>------------------------------------------------------------------ <br><h3> Answer 58212263 Vishal: </h3><p>Python 3.5+</p>

<pre class="lang-py prettyprint-override"><code>import subprocess

p = subprocess.run(["ls", "-ltr"], capture_output=True)
print(p.stdout.decode(), p.stderr.decode())
</code></pre>

<p><a href="https://code.labstack.com/GIzH7jnS" rel="nofollow noreferrer"><strong>Try online</strong></a></p>
------------------------------------------------------------------ <br><h3> Answer 69012133 Bilal Ahmed Yaseen: </h3><p>You can run any command using <em><strong>Popen</strong></em> from the <em><strong>subprocess</strong></em> module.</p>
<pre><code>from subprocess import Popen
</code></pre>
<p>First of all, a command object is created with all arguments which you want to run. For example, in the snippet below, the <em>gunicorm</em> command object has been formed with all the arguments:</p>
<pre><code>cmd = (
        &quot;gunicorn &quot;
        &quot;-c gunicorn_conf.py &quot;
        &quot;-w {workers} &quot;
        &quot;--timeout {timeout} &quot;
        &quot;-b {address}:{port} &quot;
        &quot;--limit-request-line 0 &quot;
        &quot;--limit-request-field_size 0 &quot;
        &quot;--log-level debug &quot;
        &quot;--max-requests {max_requests} &quot;
        &quot;manage:app&quot;).format(**locals())
</code></pre>
<p>Then this command object is used with <em><strong>Popen</strong></em> to instantiate a process:</p>
<pre><code>process = Popen(cmd, shell=True)
</code></pre>
<p>This process can be terminated as well based upon any signal, using the code line below:</p>
<pre><code>Popen.terminate(process)
</code></pre>
<p>And you can wait till the completion of above command's execution:</p>
<pre><code>process.wait()
</code></pre>
------------------------------------------------------------------ <br><h3> Answer 70789418 Badr Elmers: </h3><p>Here there are a lot of answers, but none fulfilled all my needs.</p>
<ul>
<li>I need to run the command and capture the <strong>output</strong> and <strong>exit code</strong>.</li>
<li>I need to <strong>timeout</strong> the executed program and <strong>force</strong> it to exit if timeout is reached, and <strong>kill all its child processes</strong>.</li>
<li>and I need that it works in <a href="https://en.wikipedia.org/wiki/Windows_XP" rel="nofollow noreferrer">Windows XP</a> and later, <a href="https://en.wikipedia.org/wiki/Cygwin" rel="nofollow noreferrer">Cygwin</a> and Linux. In Python 2 and 3.</li>
</ul>
<p>So I created this:</p>
<pre class="lang-py prettyprint-override"><code>def _run(command, timeout_s=False, shell=False):
    ### run a process, capture the output and wait for it to finish. if timeout is specified then Kill the subprocess and its children when the timeout is reached (if parent did not detach)
    ## usage: _run(arg1, arg2, arg3)
        # arg1: command + arguments. Always pass a string; the function will split it when needed
        # arg2: (optional) timeout in seconds before force killing
        # arg3: (optional) shell usage. default shell=False
    ## return: a list containing: exit code, output, and if timeout was reached or not

    # - Tested on Python 2 and 3 on Windows XP, Windows 7, Cygwin and Linux.
    # - preexec_fn=os.setsid (py2) is equivalent to start_new_session (py3) (works on Linux only), in Windows and Cygwin we use TASKKILL
    # - we use stderr=subprocess.STDOUT to merge standard error and standard output
    import sys, subprocess, os, signal, shlex, time

    def _runPY3(command, timeout_s=None, shell=False):
        # py3.3+ because: timeout was added to communicate() in py3.3.
        new_session=False
        if sys.platform.startswith('linux'): new_session=True
        p = subprocess.Popen(command, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, start_new_session=new_session, shell=shell)

        try:
            out = p.communicate(timeout=timeout_s)[0].decode('utf-8')
            is_timeout_reached = False
        except subprocess.TimeoutExpired:
            print('Timeout reached: Killing the whole process group...')
            killAll(p.pid)
            out = p.communicate()[0].decode('utf-8')
            is_timeout_reached = True
        return p.returncode, out, is_timeout_reached

    def _runPY2(command, timeout_s=0, shell=False):
        preexec=None
        if sys.platform.startswith('linux'): preexec=os.setsid
        p = subprocess.Popen(command, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, preexec_fn=preexec, shell=shell)

        start_time = time.time()
        is_timeout_reached = False
        while timeout_s and p.poll() == None:
            if time.time()-start_time &gt;= timeout_s:
                print('Timeout reached: Killing the whole process group...')
                killAll(p.pid)
                is_timeout_reached = True
                break
            time.sleep(1)
        out = p.communicate()[0].decode('utf-8')
        return p.returncode, out, is_timeout_reached

    def killAll(ParentPid):
        if sys.platform.startswith('linux'):
            os.killpg(os.getpgid(ParentPid), signal.SIGTERM)
        elif sys.platform.startswith('cygwin'):
            # subprocess.Popen(shlex.split('bash -c &quot;TASKKILL /F /PID $(&lt;/proc/{pid}/winpid) /T&quot;'.format(pid=ParentPid)))
            winpid=int(open(&quot;/proc/{pid}/winpid&quot;.format(pid=ParentPid)).read())
            subprocess.Popen(['TASKKILL', '/F', '/PID', str(winpid), '/T'])
        elif sys.platform.startswith('win32'):
            subprocess.Popen(['TASKKILL', '/F', '/PID', str(ParentPid), '/T'])

    # - In Windows, we never need to split the command, but in Cygwin and Linux we need to split if shell=False (default), shlex will split the command for us
    if shell==False and (sys.platform.startswith('cygwin') or sys.platform.startswith('linux')):
        command=shlex.split(command)

    if sys.version_info &gt;= (3, 3): # py3.3+
        if timeout_s==False:
            returnCode, output, is_timeout_reached = _runPY3(command, timeout_s=None, shell=shell)
        else:
            returnCode, output, is_timeout_reached = _runPY3(command, timeout_s=timeout_s, shell=shell)
    else:  # Python 2 and up to 3.2
        if timeout_s==False:
            returnCode, output, is_timeout_reached = _runPY2(command, timeout_s=0, shell=shell)
        else:
            returnCode, output, is_timeout_reached = _runPY2(command, timeout_s=timeout_s, shell=shell)

    return returnCode, output, is_timeout_reached
</code></pre>
<p>Then use it like this:</p>
<p>Always pass the command as one string (it is easier). You do not need to split it; the function will split it when needed.</p>
<p>If your command works in your shell, it will work with this function, so test your command in your shell first cmd/Bash.</p>
<p>So we can use it like this with a timeout:</p>
<pre class="lang-py prettyprint-override"><code>a=_run('cmd /c echo 11111 &amp; echo 22222 &amp; calc',3)
for i in a[1].splitlines(): print(i)
</code></pre>
<p>Or without a timeout:</p>
<pre class="lang-py prettyprint-override"><code>b=_run('cmd /c echo 11111 &amp; echo 22222 &amp; calc')
</code></pre>
<p>More examples:</p>
<pre class="lang-py prettyprint-override"><code>b=_run('''wmic nic where 'NetConnectionID=&quot;Local Area Connection&quot;' get NetConnectionStatus /value''')
print(b)

c=_run('cmd /C netsh interface ip show address &quot;Local Area Connection&quot;')
print(c)

d=_run('printf &quot;&lt;%s&gt;\n&quot; &quot;{foo}&quot;')
print(d)
</code></pre>
<p>You can also specify shell=True, but it is useless in most cases with this function. I prefer to choose myself the shell I want, but here it is if you need it too:</p>
<pre class="lang-py prettyprint-override"><code># windows
e=_run('echo 11111 &amp; echo 22222 &amp; calc',3, shell=True)
print(e)
# Cygwin/Linux:
f=_run('printf &quot;&lt;%s&gt;\n&quot; &quot;{foo}&quot;', shell=True)
print(f)
</code></pre>
<hr />
<p><strong>Why did I not use the simpler new method <code>subprocess.run()</code>?</strong></p>
<ul>
<li>because it is supported in Python <em>3.7+</em>, but the last supported Python version in Windows XP is <em>3.4</em>.</li>
<li>and because the timeout argument of this function is useless in Windows, it does not kill the child processes of the executed command.</li>
<li>if you use the <code>capture_output</code> + <code>timeout</code> argument, it will hang if there is a child process still running. And it is still broken in Windows, for which the <a href="https://bugs.python.org/issue31447" rel="nofollow noreferrer">issue 31447</a> is <a href="https://bugs.python.org/issue32795" rel="nofollow noreferrer">still open</a>.</li>
</ul>
<h4> Comment 127834268 bfontaine: </h4>I removed the &quot;2022 answer&quot; because it’s misleading. In 2022 you don’t support winxp nor Python 2 and you use <code>subprocess.run()</code>. The question is not &quot;how do I run system commands on old platforms&quot; but &quot;how do I run system commands&quot;, period.<br>------------------------------------------------------------------ <br><h3> Answer 46921537 Asav Patel: </h3><p>I have written a wrapper to handle errors and redirecting output and other stuff.</p>

<pre><code>import shlex
import psutil
import subprocess

def call_cmd(cmd, stdout=sys.stdout, quiet=False, shell=False, raise_exceptions=True, use_shlex=True, timeout=None):
    """Exec command by command line like 'ln -ls "/var/log"'
    """
    if not quiet:
        print("Run %s", str(cmd))
    if use_shlex and isinstance(cmd, (str, unicode)):
        cmd = shlex.split(cmd)
    if timeout is None:
        process = subprocess.Popen(cmd, stdout=stdout, stderr=sys.stderr, shell=shell)
        retcode = process.wait()
    else:
        process = subprocess.Popen(cmd, stdout=stdout, stderr=sys.stderr, shell=shell)
        p = psutil.Process(process.pid)
        finish, alive = psutil.wait_procs([p], timeout)
        if len(alive) &gt; 0:
            ps = p.children()
            ps.insert(0, p)
            print('waiting for timeout again due to child process check')
            finish, alive = psutil.wait_procs(ps, 0)
        if len(alive) &gt; 0:
            print('process {} will be killed'.format([p.pid for p in alive]))
            for p in alive:
                p.kill()
            if raise_exceptions:
                print('External program timeout at {} {}'.format(timeout, cmd))
                raise CalledProcessTimeout(1, cmd)
        retcode = process.wait()
    if retcode and raise_exceptions:
        print("External program failed %s", str(cmd))
        raise subprocess.CalledProcessError(retcode, cmd)
</code></pre>

<p>You can call it like this:</p>

<pre><code>cmd = 'ln -ls "/var/log"'
stdout = 'out.txt'
call_cmd(cmd, stdout)
</code></pre>
------------------------------------------------------------------ <br><h3> Answer 56842257 Zach Valenta: </h3><p><a href="https://github.com/aeroxis/sultan" rel="nofollow noreferrer">Sultan</a> is a recent-ish package meant for this purpose. It provides some niceties around managing user privileges and adding helpful error messages.</p>
<pre class="lang-py prettyprint-override"><code>from sultan.api import Sultan

with Sultan.load(sudo=True, hostname=&quot;myserver.com&quot;) as sultan:
  sultan.yum(&quot;install -y tree&quot;).run()
</code></pre>
------------------------------------------------------------------ <br><h3> Answer 75282403 Muhammad Abdullah: </h3><p>Here is a Python script that will run the command on Ubuntu, while also showing the logs in real-time:</p>
<pre class="lang-py prettyprint-override"><code>command = 'your command here'    
process = subprocess.Popen(command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    while True:
        output = process.stdout.readline().decode()
        if output == '' and process.poll() is not None:
            break
        if output:
            print(output.strip())
    rc = process.poll()
    if rc == 0:
        print(&quot;Command succeeded.&quot;)
       
    else:
        print(&quot;Command failed.&quot;)

</code></pre>
------------------------------------------------------------------ <br><h3> Answer 76755082 poorya: </h3><p>Using the Python subprocess module to execute shell commands and write the output to a file.</p>
<p>The below script will run the <strong>ps -ef</strong> command, filter lines containing <strong>python3</strong>, and write them to a file called <strong>python_processes.txt</strong>. Note that the code does not handle any exceptions that might occur during execution.</p>
<pre><code>import subprocess

# Command to execute
cmd = [&quot;ps&quot;, &quot;-ef&quot;]

# Execute the command
process = subprocess.Popen(cmd, stdout=subprocess.PIPE)
output, error = process.communicate()

# Check if the command was executed without errors
if error is None:
    # Filter lines with 'python3'
    python_processes = [line for line in output.decode('utf-8').split('\n') if 'python3' in line]

    # Write the output to a file
    with open('python_processes.txt', 'w') as f:
        for process in python_processes:
            f.write(process + '\n')
else:
    print(f&quot;Error occurred while executing command: {error}&quot;)


</code></pre>
------------------------------------------------------------------ <br><h3> Answer 77720259 KaiLando: </h3><p>I would recommend using <code>os.system(&quot;command&quot;)</code> from my experience.</p>
<h4> Comment 137021743 Eric Aya: </h4>Solution already given in the most upvoted <a href="https://stackoverflow.com/a/89237/2227743">answer</a><br>------------------------------------------------------------------ <br><h3> Answer 61307412 ivanmara: </h3><p>I use this for Python 3.6+:</p>
<pre><code>import subprocess
def execute(cmd):
    &quot;&quot;&quot;
        Purpose  : To execute a command and return exit status
        Argument : cmd - command to execute
        Return   : result, exit_code
    &quot;&quot;&quot;
    process = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    (result, error) = process.communicate()
    rc = process.wait()
    if rc != 0:
        print (&quot;Error: failed to execute command: &quot;, cmd)
        print (error.rstrip().decode(&quot;utf-8&quot;))
    return result.rstrip().decode(&quot;utf-8&quot;), serror.rstrip().decode(&quot;utf-8&quot;)
# def
</code></pre>
<h4> Comment 108457518 user5994461: </h4>Don&#39;t use set <code>shell=True</code> to run commands, it opens the program to command injection vulnerabilities. You&#39;re supposed to pass the command as a list with arguments <code>cmd=[&quot;&#47;bin&#47;echo&quot;, &quot;hello word&quot;]</code>. <a href="https://docs.python.org/3/library/subprocess.html#security-considerations" rel="nofollow noreferrer">docs.python.org/3/library/&hellip;</a><br>