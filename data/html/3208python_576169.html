 <h2> Title: Understanding Python super() with __init__() methods </h2> <h3> Mizipzor, question_id: 576169 </h3>Score: 3208, Tags: {python,class,oop,inheritance,super} <br><p>Why is <code>super()</code> used?</p>
<p>Is there a difference between using <code>Base.__init__</code> and <code>super().__init__</code>?</p>
<pre><code>class Base(object):
    def __init__(self):
        print &quot;Base created&quot;
        
class ChildA(Base):
    def __init__(self):
        Base.__init__(self)
        
class ChildB(Base):
    def __init__(self):
        super(ChildB, self).__init__()
        
ChildA() 
ChildB()
</code></pre>
<h4> Comment 123484895 Charlie Parker: </h4>this is a very simple intro to classes worth going through: <a href="https://realpython.com/python-super/#an-overview-of-pythons-super-function" rel="nofollow noreferrer">realpython.com/python-super/&hellip;</a>. It&#39;s easier to digest than the answers given that are for most of us I assume too detailed in the implementation of python. It also has examples to make it concrete.<br><h4> Comment 127875715 Max: </h4>I still don&#39;t get it. I want to define a <code>class Event(tuple)</code> which creates tuples (timestamp, description) and where the timestamp should default to the current time. Thus, something like <code>e = Event(description=&quot;stored the current time&quot;)</code> should give an instance of the subclass <code>Event</code> of the tuple <code>(1653520485,&quot;stored...&quot;)</code>. But in <code>__init__()</code> I cannot modify <code>self</code> as I would do for a subclass of <code>dict</code>. So I thought I could use <code>super().__init__</code> to set the components of the tuple <code>self</code>. Can I ?<br>------------------------------------------------------------------ <br><h3> Answer 576183 Kiv: </h3><p><code>super()</code> lets you avoid referring to the base class explicitly, which can be nice. But the main advantage comes with multiple inheritance, where all sorts of <a href="http://www.artima.com/weblogs/viewpost.jsp?thread=236275" rel="noreferrer">fun stuff</a> can happen. See the <a href="https://docs.python.org/2/library/functions.html#super" rel="noreferrer">standard docs on super</a> if you haven't already.</p>

<p>Note that <a href="https://docs.python.org/3/library/functions.html#super" rel="noreferrer">the syntax changed in Python 3.0</a>: you can just say <code>super().__init__()</code> instead of <code>super(ChildB, self).__init__()</code> which IMO is quite a bit nicer. The standard docs also refer to a <a href="https://rhettinger.wordpress.com/2011/05/26/super-considered-super/" rel="noreferrer">guide to using <code>super()</code></a> which is quite explanatory.</p>
<h4> Comment 91152718 Omnik: </h4>@rimiro The syntax of super() is <code>super([type [, object]])</code> This will return the superclass of <code>type</code>. So in this case the superclass of <code>ChildB</code> will be returned. If the second argument is omitted, the super object returned is unbound. If the second argument is an object, then <code>isinstance(object, type)</code> must be true.<br><h4> Comment 99497805 Charlie Parker: </h4>can you actually explain what the code does? I don&#39;t want to click to 1 million more places to find the answer to this.<br><h4> Comment 96295531 eric: </h4>If you are here and still confused, please read the answer by Aaron Hall you will leave this page much happier: <a href="https://stackoverflow.com/a/27134600/1886357">stackoverflow.com/a/27134600/1886357</a><br><h4> Comment 132532703 Marcos Brigante: </h4>&quot;main advantage comes with multiple inheritance, where all sorts of FUN stuff can happen&quot; - python programmers have a strange definition of fun<br>------------------------------------------------------------------ <br><h3> Answer 27134600 Russia Must Remove Putin: </h3><blockquote>
<h2>I'm trying to understand <code>super()</code></h2>
</blockquote>
<p>The reason we use <code>super</code> is so that child classes that may be using cooperative multiple inheritance will call the correct next parent class function in the Method Resolution Order (MRO).</p>
<p>In Python 3, we can call it like this:</p>
<pre><code>class ChildB(Base):
    def __init__(self):
        super().__init__()
</code></pre>
<p>In Python 2, we were required to call <code>super</code> like this with the defining class's name and <code>self</code>, but we'll avoid this from now on because it's redundant, slower (due to the name lookups), and more verbose (so update your Python if you haven't already!):</p>
<pre><code>        super(ChildB, self).__init__()
</code></pre>
<p>Without super, you are limited in your ability to use multiple inheritance because you hard-wire the next parent's call:</p>
<pre><code>        Base.__init__(self) # Avoid this.
</code></pre>
<p>I further explain below.</p>
<blockquote>
<h2>&quot;What difference is there actually in this code?:&quot;</h2>
</blockquote>
<pre><code>class ChildA(Base):
    def __init__(self):
        Base.__init__(self)

class ChildB(Base):
    def __init__(self):
        super().__init__()
</code></pre>
<p>The primary difference in this code is that in <code>ChildB</code> you get a layer of indirection in the <code>__init__</code> with <code>super</code>, which uses the class in which it is defined to determine the next class's <code>__init__</code> to look up in the MRO.</p>
<p>I illustrate this difference in an answer at the <a href="https://stackoverflow.com/a/33469090/541136">canonical question, How to use 'super' in Python?</a>, which demonstrates <strong>dependency injection</strong> and <strong>cooperative multiple inheritance</strong>.</p>
<h2>If Python didn't have <code>super</code></h2>
<p>Here's code that's actually closely equivalent to <code>super</code> (how it's implemented in C, minus some checking and fallback behavior, and translated to Python):</p>
<pre><code>class ChildB(Base):
    def __init__(self):
        mro = type(self).mro()
        check_next = mro.index(ChildB) + 1 # next after *this* class.
        while check_next &lt; len(mro):
            next_class = mro[check_next]
            if '__init__' in next_class.__dict__:
                next_class.__init__(self)
                break
            check_next += 1
</code></pre>
<p>Written a little more like native Python:</p>
<pre><code>class ChildB(Base):
    def __init__(self):
        mro = type(self).mro()
        for next_class in mro[mro.index(ChildB) + 1:]: # slice to end
            if hasattr(next_class, '__init__'):
                next_class.__init__(self)
                break
</code></pre>
<p>If we didn't have the <code>super</code> object, we'd have to write this manual code everywhere (or recreate it!) to ensure that we call the proper next method in the Method Resolution Order!</p>
<p>How does super do this in Python 3 without being told explicitly which class and instance from the method it was called from?</p>
<p>It gets the calling stack frame, and finds the class (implicitly stored as a local free variable, <code>__class__</code>, making the calling function a closure over the class) and the first argument to that function, which should be the instance or class that informs it which Method Resolution Order (MRO) to use.</p>
<p>Since it requires that first argument for the MRO, <a href="https://bugs.python.org/issue31118" rel="noreferrer">using <code>super</code> with static methods is impossible as they do not have access to the MRO of the class from which they are called</a>.</p>
<h2>Criticisms of other answers:</h2>
<blockquote>
<p>super() lets you avoid referring to the base class explicitly, which can be nice. . But the main advantage comes with multiple inheritance, where all sorts of fun stuff can happen. See the standard docs on super if you haven't already.</p>
</blockquote>
<p>It's rather hand-wavey and doesn't tell us much, but the point of <code>super</code> is not to avoid writing the parent class. The point is to ensure that the next method in line in the method resolution order (MRO) is called. This becomes important in multiple inheritance.</p>
<p>I'll explain here.</p>
<pre><code>class Base(object):
    def __init__(self):
        print(&quot;Base init'ed&quot;)

class ChildA(Base):
    def __init__(self):
        print(&quot;ChildA init'ed&quot;)
        Base.__init__(self)

class ChildB(Base):
    def __init__(self):
        print(&quot;ChildB init'ed&quot;)
        super().__init__()
</code></pre>
<p>And let's create a dependency that we want to be called after the Child:</p>
<pre><code>class UserDependency(Base):
    def __init__(self):
        print(&quot;UserDependency init'ed&quot;)
        super().__init__()
</code></pre>
<p>Now remember, <code>ChildB</code> uses super, <code>ChildA</code> does not:</p>
<pre><code>class UserA(ChildA, UserDependency):
    def __init__(self):
        print(&quot;UserA init'ed&quot;)
        super().__init__()

class UserB(ChildB, UserDependency):
    def __init__(self):
        print(&quot;UserB init'ed&quot;)
        super().__init__()
</code></pre>
<p>And <code>UserA</code> does not call the UserDependency method:</p>
<pre><code>&gt;&gt;&gt; UserA()
UserA init'ed
ChildA init'ed
Base init'ed
&lt;__main__.UserA object at 0x0000000003403BA8&gt;
</code></pre>
<p>But <code>UserB</code> does in-fact call UserDependency because <code>ChildB</code> invokes <code>super</code>:</p>
<pre><code>&gt;&gt;&gt; UserB()
UserB init'ed
ChildB init'ed
UserDependency init'ed
Base init'ed
&lt;__main__.UserB object at 0x0000000003403438&gt;
</code></pre>
<h3>Criticism for another answer</h3>
<p>In no circumstance should you do the following, which another answer suggests, as you'll definitely get errors when you subclass ChildB:</p>
<pre><code>super(self.__class__, self).__init__()  # DON'T DO THIS! EVER.
</code></pre>
<p><sub>(That answer is not clever or particularly interesting, but in spite of direct criticism in the comments and over 17 downvotes, the answerer persisted in suggesting it until a kind editor fixed his problem.)</sub></p>
<p>Explanation: Using <code>self.__class__</code> as a substitute for the class name in <code>super()</code> will lead to recursion. <code>super</code> lets us look up the next parent in the MRO (see the first section of this answer) for child classes. If you tell <code>super</code> we're in the child instance's method, it will then lookup the next method in line (probably this one) resulting in recursion, probably causing a logical failure (in the answerer's example, it does) or a <code>RuntimeError</code> when the recursion depth is exceeded.</p>
<pre><code>&gt;&gt;&gt; class Polygon(object):
...     def __init__(self, id):
...         self.id = id
...
&gt;&gt;&gt; class Rectangle(Polygon):
...     def __init__(self, id, width, height):
...         super(self.__class__, self).__init__(id)
...         self.shape = (width, height)
...
&gt;&gt;&gt; class Square(Rectangle):
...     pass
...
&gt;&gt;&gt; Square('a', 10, 10)
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
  File &quot;&lt;stdin&gt;&quot;, line 3, in __init__
TypeError: __init__() missing 2 required positional arguments: 'width' and 'height'
</code></pre>
<p>Python 3's new <code>super()</code> calling method with no arguments fortunately allows us to sidestep this issue.</p>
<h4> Comment 106403150 facehugger: </h4>Maybe <code>if &#39;__init__&#39; in next_class.__dict__:</code> is better<br><h4> Comment 75499971 Yohan Obadia: </h4>I&#39;ll still need to work my head around this <code>super()</code> function, however, this answer is clearly the best in terms of depth and details. I also appreciate greatly the criticisms inside the answer. It also help to better understand the concept by identifying pitfalls in other answers. Thank you !<br><h4> Comment 93310728 Mike - SMT: </h4>I have been using <code>tk.Tk.__init__(self)</code> over <code>super().__init__()</code> as I didn&#39;t fully understand what super was but this post has been very enlightening. I guess in the case of Tkinter classes <code>tk.Tk.__init__(self)</code> and <code>super().__init__()</code> are the same thing but it looks like you are saying we should avoid doing something like <code>Base.__init__(self)</code> so I may be switching to <code>super()</code> even though I am still trying to grasp its complexity.<br><h4> Comment 96034070 physincubus: </h4>this answer is especially comprehensive, and really filled in gaps in my knowledge. hats off to you sir.<br><h4> Comment 106403134 facehugger: </h4>Your second &quot;native Python&quot; example behaves differently than the first example (and as <code>super</code>-based solution). <code>hasattr(next_class, &#39;__init__&#39;)</code> used may implicitly indicate the presence of an unnecessary method. For example, imagine canonical diamond hierarchy <code>class A(): ...; class B(A): ...; class C(A): ...; class D(B, C): ...</code> where <code>A</code> and <code>С</code> have their own <code>__init__</code> methods and <code>D</code> has <code>__init__</code> such as in the described example. Then calling <code>D().__init__()</code> will cause <code>A.__init__</code> to call instead of <code>C.__init__</code><br><h4> Comment 106405009 Russia Must Remove Putin: </h4>@facehugger it&#39;s a translation of a translation - it&#39;s not supposed to behave <i>exactly</i> the same, it&#39;s supposed to retain the semantics while being as simple as possible.<br><h4> Comment 136562536 Rhubarb: </h4>Thank you - this also answers the <i>actual</i> question that <i>I</i> was searching for: &quot;Why is <code>super</code> a function call rather than a simple variable or property. Answer: because it has this complex _function_ality: of invoking the specified method (function) on potentially several other classes. Even so though... it might be doable and not too hacky to make it a special property. <code>super.__init__()</code> seems a lot more readable to me ( maybe because I keep writing it :(. hence this search)<br>------------------------------------------------------------------ <br><h3> Answer 19257335 AnjoMan: </h3><p>It's been noted that in Python 3.0+ you can use</p>

<pre><code>super().__init__()
</code></pre>

<p>to make your call, which is concise and does not require you to reference the parent OR class names explicitly, which can be handy. I just want to add that for Python 2.7 or under, some people implement a name-insensitive behaviour by writing <code>self.__class__</code> instead of the class name, i.e.</p>

<pre><code>super(self.__class__, self).__init__()  # DON'T DO THIS!
</code></pre>

<p>HOWEVER, this breaks calls to <code>super</code> for any classes that inherit from your class, where <code>self.__class__</code> could return a child class. For example:</p>

<pre><code>class Polygon(object):
    def __init__(self, id):
        self.id = id

class Rectangle(Polygon):
    def __init__(self, id, width, height):
        super(self.__class__, self).__init__(id)
        self.shape = (width, height)

class Square(Rectangle):
    pass
</code></pre>

<p>Here I have a class <code>Square</code>, which is a sub-class of <code>Rectangle</code>. Say I don't want to write a separate constructor for <code>Square</code> because the constructor for <code>Rectangle</code> is good enough, but for whatever reason I want to implement a Square so I can reimplement some other method.</p>

<p>When I create a <code>Square</code> using <code>mSquare = Square('a', 10,10)</code>, Python calls the constructor for <code>Rectangle</code> because I haven't given <code>Square</code> its own constructor. However, in the constructor for <code>Rectangle</code>, the call <code>super(self.__class__,self)</code> is going to return the superclass of <code>mSquare</code>, so it calls the constructor for <code>Rectangle</code> again. This is how the infinite loop happens, as was mentioned by @S_C. In this case, when I run <code>super(...).__init__()</code> I am calling the constructor for <code>Rectangle</code> but since I give it no arguments, I will get an error.</p>
<h4> Comment 34687908 glglgl: </h4>What this answer suggests, <code>super(self.__class__, self).__init__()</code> does not work if you subclass again without providing a new <code>__init__</code>. Then you have an infinite recursion.<br><h4> Comment 64699522 Veky: </h4>This answer is ridiculous. If you&#39;re going to abuse super this way, you might as well just hardcode the base class name. It is less wrong than this. The whole point of first argument of super is that it&#39;s <i>not</i> necessarily the type of self. Please read &quot;super considered super&quot; by rhettinger (or watch some of his videos).<br><h4> Comment 70477586 Ryan Hiebert: </h4>The shortcut demonstrated here for Python 2 has pitfalls that have been mentioned already. Don&#39;t use this, or your code will break in ways you can&#39;t predict. This &quot;handy shortcut&quot; breaks super, but you may not realize it until you&#39;ve sunk a whole lot of time into debugging. Use Python 3 if super is too verbose.<br><h4> Comment 82185680 Russia Must Remove Putin: </h4>What makes no sense is to tell someone they can do something that is trivially demonstrated as incorrect. You can alias <code>echo</code> to <code>python</code>. Nobody would ever suggest it!<br><h4> Comment 81806431 AnjoMan: </h4>@Tino I don&#39;t really agree with your edits. It doesn&#39;t make sense to say both that one cannot do something and that one shouldn&#39;t do it - it is possible to do what I describe in my post, and for the reasons I lay out it is a bad idea.<br>------------------------------------------------------------------ <br><h3> Answer 10759155 rgenito: </h3><p>Just a heads up... with Python 2.7, and I believe ever since <code>super()</code> was introduced in version 2.2, you can only call <a href="http://docs.python.org/library/functions.html#super" rel="noreferrer"><code>super()</code></a> if one of the parents inherit from a class that eventually inherits <code>object</code> (<a href="http://docs.python.org/glossary.html#term-new-style-class" rel="noreferrer">new-style classes</a>).</p>

<p>Personally, as for python 2.7 code, I'm going to continue using <code>BaseClassName.__init__(self, args)</code> until I actually get the advantage of using <code>super()</code>.</p>
<h4> Comment 25871497 andilabs: </h4>very good point. IF you don&#39;t clearly mention:     class Base(object): then you will get error like that:      &quot;TypeError: must be type, not classobj&quot;<br>------------------------------------------------------------------ <br><h3> Answer 13595092 S C: </h3><p>Super has no side effects</p>
<pre class="lang-py prettyprint-override"><code>Base = ChildB

Base()
</code></pre>
<p>works as expected</p>
<pre class="lang-py prettyprint-override"><code>Base = ChildA

Base()
</code></pre>
<p>gets into infinite recursion.</p>
<h4> Comment 79970928 Russia Must Remove Putin: </h4>The statement, &quot;Super has no side effects,&quot; doesn&#39;t make sense in this context. Super simply guarantees we call the correct next class&#39;s method in the method resolution order, whereas the other way hard-codes the next method to be called, which makes cooperative multiple inheritance more difficult.<br><h4> Comment 112662116 MarkHu: </h4>This answer is fragmentary (code examples only makes sense as a continuation of code from the answer.)<br>------------------------------------------------------------------ <br><h3> Answer 576179 Devin Jeanpierre: </h3><p>There isn't, really. <code>super()</code> looks at the next class in the MRO (method resolution order, accessed with <code>cls.__mro__</code>) to call the methods. Just calling the base <code>__init__</code> calls the base <code>__init__</code>. As it happens, the MRO has exactly one item-- the base. So you're really doing the exact same thing, but in a nicer way with <code>super()</code> (particularly if you get into multiple inheritance later).</p>
<h4> Comment 388099 Devin Jeanpierre: </h4>Actually, it would be one super() line. When you have multiple inheritance, the MRO is still flat. So the first super().__init__ call calls the next class&#39;s <b>init</b>, which then calls the next, and so on. You should really check out some docs on it.<br><h4> Comment 388090 Mizipzor: </h4>I see. Could you elaborate a little as to why its nicer to use super() with multiple inheritance? To me, the base.__init__(self) is shorter (cleaner). If I had two baseclasses, it would be two of those lines, or two super() lines. Or did I misunderstand what you meant by &quot;nicer&quot;?<br><h4> Comment 388171 James Brady: </h4>Also note that classic classes (pre 2.2) don&#39;t support super - you have to explicitly refer to base classes.<br><h4> Comment 388167 James Brady: </h4>The child class MRO contains object too - a class&#39;s MRO is visible in the <b>mro</b> class variable.<br><h4> Comment 388495 Devin Jeanpierre: </h4>&quot;The child class MRO contains object too - a class&#39;s MRO is visible in the <b>mro</b> class variable.&quot; That is a big oops. Whoops.<br><h4> Comment 55144370 nispio: </h4>To say that &quot;the MRO has exactly one item&quot; assumes that <code>ChildB</code> will never be subclassed.  You don&#39;t actually know until runtime what the MRO will be when the call to <code>super()</code> happens.<br>------------------------------------------------------------------ <br><h3> Answer 32688823 RubenLaguna: </h3><p>The main difference is that <code>ChildA.__init__</code> will unconditionally call <code>Base.__init__</code> whereas <code>ChildB.__init__</code> will call <code>__init__</code> in <strong>whatever class happens to be <code>ChildB</code> ancestor in <code>self</code>'s line of ancestors</strong>
(which may differ from what you expect).</p>
<p>If you add a <code>ClassC</code> that uses multiple inheritance:</p>
<pre><code>class Mixin(Base):
  def __init__(self):
    print &quot;Mixin stuff&quot;
    super(Mixin, self).__init__()

class ChildC(ChildB, Mixin):  # Mixin is now between ChildB and Base
  pass

ChildC()
help(ChildC) # shows that the Method Resolution Order is ChildC-&gt;ChildB-&gt;Mixin-&gt;Base
</code></pre>
<p>then <strong><code>Base</code> is no longer the parent of <code>ChildB</code></strong> for <code>ChildC</code> instances. Now <code>super(ChildB, self)</code> will point to <code>Mixin</code> if <code>self</code> is a <code>ChildC</code> instance.</p>
<p>You have inserted <code>Mixin</code> in between <code>ChildB</code> and <code>Base</code>. And you can take advantage of it with <code>super()</code></p>
<p>So if you are designed your classes so that they can be used in a Cooperative Multiple Inheritance scenario, you use <code>super</code> because you don't really know who is going to be the ancestor at runtime.</p>
<p>The <a href="https://rhettinger.wordpress.com/2011/05/26/super-considered-super/" rel="noreferrer">super considered super post</a> and <a href="https://youtu.be/EiOglTERPEo" rel="noreferrer">pycon 2015 accompanying video</a> explain this pretty well.</p>
<h4> Comment 55144255 nispio: </h4>This.  The meaning of <code>super(ChildB, self)</code> changes depending on the MRO of the object referred to by <code>self</code>, which cannot be known until runtime.  In other words, the author of <code>ChildB</code> has no way of knowing what <code>super()</code> will resolve to in all cases unless they can guarantee that <code>ChildB</code> will never be subclassed.<br>