 <h2> Title: Perl build, unit testing, code coverage: A complete working example </h2> <h4> Kurt W. Leucht, question_id: 533553 </h4>Score: 89, Tags: {perl,unit-testing,build-process,build-automation,code-coverage} <br><p>Most Stackoverflow answers that I have found in regards to the Perl build process and unit testing and code coverage simply point me to CPAN for the documentation there.  There's absolutely nothing wrong with pointing to CPAN modules because that's where the full documentation is supposed to reside.  I've had trouble finding complete working code examples in many cases, though.  </p>

<p>I've been searching all over the Internet for actual working code samples that I can download or paste into my IDE, like your typical tutorial "Hello World" example source code, but of an example that demonstrates the build process with unit testing and code coverage analysis.  Does anyone have a small example of a complete working project that demonstrates these technologies and processes?  </p>

<p><em>(I do have a small working example and I will answer my own question with it, but there are probably other SO users who have better examples than the ones I came up with.)</em></p>
------------------------------------------------------------------ <br><h3> Kurt W. Leucht, Id: 533577, Score: 111: </h3><p>It took me a while and it also took me taking small snippets from a number of different sources and melting them together, but I think I have a small working example that sufficiently demonstrates to a Perl newbie the Perl build process including unit testing and code coverage analysis &amp; reporting.  (I'm using <a href="http://www.activestate.com/activeperl/" rel="noreferrer">ActiveState ActivePerl</a> v5.10.0 on a Windows XP Pro PC, <a href="http://search.cpan.org/~ewilhelm/Module-Build-0.31012/lib/Module/Build.pm" rel="noreferrer">Module::Build</a>, <a href="http://search.cpan.org/dist/Test-Simple/lib/Test/More.pm" rel="noreferrer">Test::More</a>, <a href="http://search.cpan.org/dist/Devel-Cover/lib/Devel/Cover.pm" rel="noreferrer">Devel::Cover</a>)</p>

<p>Start out with a directory for your Perl project and then create a "lib" directory and a "t" directory under your project directory:</p>

<pre><code>HelloPerlBuildWorld
        |
        |----------&gt; lib
        |
        |----------&gt; t
</code></pre>

<p>In the "lib" directory, create a text file named "HelloPerlBuildWorld.pm".  This file is your Perl module that you will be building and testing.  Paste the following content into this file:</p>

<pre><code>use strict;
use warnings;
package HelloPerlBuildWorld;

$HelloPerlBuildWorld::VERSION = '0.1';

sub hello {
   return "Hello, Perl Build World!";
}

sub bye {
   return "Goodbye, cruel world!";
}

sub repeat {
   return 1;
}

sub argumentTest {
    my ($booleanArg) = @_;

    if (!defined($booleanArg)) {
        return "null";
    }
    elsif ($booleanArg eq "false") {
        return "false";
    }
    elsif ($booleanArg eq "true") {
        return "true";
    }
    else {
        return "unknown";
    }

   return "Unreachable code: cannot be covered";
}

1;
</code></pre>

<p>In the "t" directory, create a text file named "HelloPerlBuildWorld.t".  This file is your unit test script that will attempt to fully test your Perl module above.  Paste the following content into this file:</p>

<pre><code>use strict;
use warnings;
use Test::More qw(no_plan);

# Verify module can be included via "use" pragma
BEGIN { use_ok('HelloPerlBuildWorld') };

# Verify module can be included via "require" pragma
require_ok( 'HelloPerlBuildWorld' );

# Test hello() routine using a regular expression
my $helloCall = HelloPerlBuildWorld::hello();
like($helloCall, qr/Hello, .*World/, "hello() RE test");

# Test hello_message() routine using a got/expected routine
is($helloCall, "Hello, Perl Build World!", "hello() IS test");

# Do not test bye() routine

# Test repeat() routine using a got/expected routine
for (my $ctr=1; $ctr&lt;=10; $ctr++) {
    my $repeatCall = HelloPerlBuildWorld::repeat();
    is($repeatCall, 1, "repeat() IS test");
}

# Test argumentTest() 
my $argumentTestCall1 = HelloPerlBuildWorld::argumentTest();
is($argumentTestCall1, "null", "argumentTest() IS null test");

# Test argumentTest("true") 
my $argumentTestCall2 = HelloPerlBuildWorld::argumentTest("true");
is($argumentTestCall2, "true", "argumentTest() IS true test");

# Test argumentTest("false") 
my $argumentTestCall3 = HelloPerlBuildWorld::argumentTest("false");
is($argumentTestCall3, "false", "argumentTest() IS false test");

# Test argumentTest(123) 
my $argumentTestCall4 = HelloPerlBuildWorld::argumentTest(123);
is($argumentTestCall4, "unknown", "argumentTest() IS unknown test");
</code></pre>

<p>Now back up in your top level project directory, create a text file named "Build.PL".  This file will create your build scripts that you will use later.  Paste the following content into this file:</p>

<pre><code>use strict;
use warnings;
use Module::Build;

my $builder = Module::Build-&gt;new(
    module_name         =&gt; 'HelloPerlBuildWorld',
    license             =&gt; 'perl',
    dist_abstract       =&gt; 'HelloPerlBuildWorld short description',
    dist_author         =&gt; 'Author Name &lt;email_addy@goes.here&gt;',
    build_requires =&gt; {
        'Test::More' =&gt; '0.10',
    },
);

$builder-&gt;create_build_script();
</code></pre>

<p>That's all the files you need.  Now from the command line in the top level project directory, type the following command:  </p>

<pre><code>perl Build.PL
</code></pre>

<p>You will see something similar to the following:</p>

<pre><code>Checking prerequisites...
Looks good

Creating new 'Build' script for 'HelloPerlBuildWorld' version '0.1'
</code></pre>

<p>Now you should be able to run your unit tests with the following command:</p>

<pre><code>Build test
</code></pre>

<p>And see something similar to this:</p>

<pre><code>Copying lib\HelloPerlBuildWorld.pm -&gt; blib\lib\HelloPerlBuildWorld.pm
t\HelloPerlBuildWorld....ok
All tests successful.
Files=1, Tests=18,  0 wallclock secs ( 0.00 cusr +  0.00 csys =  0.00 CPU)
</code></pre>

<p>To run your unit tests with code coverage analysis, try this:</p>

<pre><code>Build testcover
</code></pre>

<p>And you'll see something on the order of this:</p>

<pre><code>t\HelloPerlBuildWorld....ok
All tests successful.
Files=1, Tests=18, 12 wallclock secs ( 0.00 cusr +  0.00 csys =  0.00 CPU)
cover
Reading database from D:/Documents and Settings/LeuchKW/workspace/HelloPerlBuildWorld/cover_db


----------------------------------- ------ ------ ------ ------ ------ ------
File                                  stmt   bran   cond    sub   time  total
----------------------------------- ------ ------ ------ ------ ------ ------
D:/Perl/lib/ActivePerl/Config.pm       0.0    0.0    0.0    0.0    n/a    0.0
D:/Perl/lib/ActiveState/Path.pm        0.0    0.0    0.0    0.0    n/a    0.0
D:/Perl/lib/AutoLoader.pm              0.0    0.0    0.0    0.0    n/a    0.0
D:/Perl/lib/B.pm                      18.6   16.7   13.3   19.2   96.4   17.6
 ...
[SNIP]
 ...
D:/Perl/lib/re.pm                      0.0    0.0    0.0    0.0    n/a    0.0
D:/Perl/lib/strict.pm                 84.6   50.0   50.0  100.0    0.0   73.1
D:/Perl/lib/vars.pm                   44.4   36.4    0.0  100.0    0.0   36.2
D:/Perl/lib/warnings.pm               15.3   12.1    0.0   11.1    0.0   12.0
D:/Perl/lib/warnings/register.pm       0.0    0.0    n/a    0.0    n/a    0.0
blib/lib/HelloPerlBuildWorld.pm       87.5  100.0    n/a   83.3    0.0   89.3
Total                                  9.9    4.6    2.8   11.3  100.0    7.6
----------------------------------- ------ ------ ------ ------ ------ ------


Writing HTML output to D:/Documents and Settings/LeuchKW/workspace/HelloPerlBuildWorld/cover_db/coverage.html ...
done.
</code></pre>

<p><em>(Someone please tell me how to configure Cover to ignore all the Perl libraries except and just report back to me on my single file that I wrote.  I could not get Cover filtering to work according to the CPAN documentation!)</em></p>

<p>Now if you refresh your top level directory, you can see a new subdirectory called "cover_db".  Go into that directory and double click on the "coverage.html" file to open the code coverage report in your favorite web browser.  It gives you a nice color coded hypertext report where you can click on your file name and see detailed statement, branch, condition, subroutine coverage statistics for your Perl module right there in the report next to the actual source code.  You can see in this report that we did not cover the "bye()" routine at all and also there is a line of code that is unreachable that was not covered as we expected.</p>

<p><a href="https://i.stack.imgur.com/bW6cH.jpg" rel="noreferrer"><img src="https://i.stack.imgur.com/bW6cH.jpg" alt="snapshot of code coverage report"></a><br>
<sub>(source: <a href="http://www.leucht.com/images/CodeCoverageExample.jpg" rel="noreferrer">leucht.com</a>)</sub>  </p>

<p>One more thing you can do to help automate this process in your IDE is to make some more "Build.PL" type files that explicitly perform some of the build targets that we did above manually from the command line.  For example, I use a "BuildTest.PL" file with the following content:</p>

<pre><code>use strict;
use warnings;
use Module::Build;

my $build = Module::Build-&gt;resume (
  properties =&gt; {
    config_dir =&gt; '_build',
  },
);

$build-&gt;dispatch('build');
$build-&gt;dispatch('test');
</code></pre>

<p>Then I set up my IDE to execute this file (via "perl BuiltTest.PL") with a single mouse click and it automatically runs my unit test code from the IDE instead of me doing it manually from the command line.  Replace the "dispatch('test')" with "dispatch('testcover')" for automated code coverage execution.  Type "Build help" for a complete list of build targets that are available from Module::Build.  </p>
<h4> Michael Carman, Comment 2749390 Score: 4: </h4>To filter results in Devel::Cover I add options to <code>$ENV{HARNESS_PERL_SWITCHES}</code>. For example: <code>-MDevel::Cover=+ignore,.t$,+inc,&#47;app&#47;lib,-select,MyModule.pm</code> where <code>&#47;app&#47;lib</code> is the application-private library and <code>MyModule.pm</code> is the module under test.<br><h4> brian d foy, Comment 348488 Score: 2: </h4>Module::Build just isn&#39;t for CPAN. You can still get all the features from the various CPAN tools even if it isn&#39;t on CPAN. You can still build, test, distribute, and install it with the same process even though it is a private module.<br><h4> Kurt W. Leucht, Comment 346381 Score: 2: </h4>Leon, are you suggesting a perl script that makes command line calls?   If so, I&#39;d rather not make command line calls if there is an OO way to make the calls programmatically as in the example BuiltTest.PL file.<br><h4> Leon Timmermans, Comment 346428 Score: 1: </h4>That&#39;s not necessary, see my own answer<br><h4> mpeters, Comment 347011 Score: 1: </h4>One more thing to note is that there&#39;s not really a need to get Module::Build involved if you&#39;re not planning to put it on CPAN. If you just want to be able to run tests, then look at prove - <a href="http://search.cpan.org/~andya/Test-Harness-3.14/bin/prove" rel="nofollow noreferrer">search.cpan.org/~andya/Test-Harness-3.14/bin/prove</a>. You could run your tests with just &quot;prove t/&quot;.<br><h4> Adam Bellaire, Comment 347756 Score: 1: </h4>That&#39;s true, but being able to build a project can be useful even if you don&#39;t plan on putting it on CPAN.  Especially if you&#39;re developing a whole app and not just a module.  If you have separate testing and production deployments for your app, being able to &quot;Build install&quot; the project is great!<br><h4> Leon Timmermans, Comment 346366 Score: 1: </h4>Your idea to set up a BuiltTest.PL doesn&#39;t sound good to me. Why can&#39;t you just write a script that does <code>Build build</code> and then <code>Build test</code>?<br><h4> CodeClown42, Comment 63138432 Score: 0: </h4>+1 Just for this line: <code>$builder-&gt;create_build_script();</code> -&gt; Something which AFAICT is completely missing from any of the <code>Module::Build</code> documentation (boo).   I&#39;ve been using <code>ExtUtils::MakeMaker</code> for years and when <code>perl Build.PL</code> did absolutely nothing with a file calling the constructor with required arguments I had a real WTF moment.<br>------------------------------------------------------------------ <br><h3> Leon Timmermans, Id: 533652, Score: 14: </h3><p>In response to Kurt, I would propose this alternative to his BuiltTest.PL script.</p>

<pre><code>use strict;
use warnings;
use Module::Build;

my $build = Module::Build-&gt;resume (
  properties =&gt; {
    config_dir =&gt; '_build',
  },
);

$build-&gt;dispatch('build');
$build-&gt;dispatch('test');
</code></pre>

<p>It reuses the database build by Build.PL (and thus assumes that already ran).</p>
<h4> Kurt W. Leucht, Comment 346462 Score: 0: </h4>Perfect!  Thanks, Leon.  I knew something was wrong with my example, but I&#39;m still new to this perl build stuff myself!  :-)<br>------------------------------------------------------------------ <br><h3> brian d foy, Id: 535828, Score: 12: </h3><p>I cover this in <a href="http://oreilly.com/catalog/9780596102067/" rel="noreferrer">Intermediate Perl</a> as well as <a href="http://oreilly.com/catalog/9780596527242/" rel="noreferrer">Mastering Perl</a>. Kurt, however, has given a nice summary.</p>

<p>I combine all of this into a release script using <a href="http://search.cpan.org/dist/Module-Release" rel="noreferrer">Module::Release</a> though. I type one command and it all happens.</p>
------------------------------------------------------------------ <br><h3> Gaurav, Id: 536113, Score: 12: </h3><p>The fantastically helpful <a href="http://search.cpan.org/dist/Module-Starter/bin/module-starter" rel="noreferrer"><code>module-starter</code></a> generates an easy-to-use skeleton project which handles module installation, creation of documentation and a good layout for module files to live in, and -- I <em>think</em> -- code coverage support. It's IMO a great start for any Perl module-related endeavour.</p>

<p>Also: using CPAN-related tools like <code>Module::Build</code> -- even for modules which are likely never going to be released publically -- <a href="http://perlbuzz.com/2008/10/write-your-code-like-its-going-on-cpan.html" rel="noreferrer">is a very good idea</a>.</p>
------------------------------------------------------------------ <br><h3> jplindstrom, Id: 1283193, Score: 7: </h3><p>(disclosure: I'm the author)</p>

<p>Once you have everything sorted as described above, you could take the next step and use <a href="http://search.cpan.org/dist/Devel-CoverX-Covered/lib/Devel/CoverX/Covered.pm" rel="noreferrer">Devel::CoverX::Covered</a> to e.g.</p>

<ul>
<li>Given a source file, list the test files that provide coverage to that source file. This can be done on a file, sub routine and row level.</li>
<li>Given a test file, list the source files and subs covered by that test file.</li>
<li>Given a source file, report efficiently on the coverage details per row, or sub.</li>
</ul>

<p>See the <a href="http://search.cpan.org/dist/Devel-CoverX-Covered/lib/Devel/CoverX/Covered.pm#SYNOPSIS" rel="noreferrer">synopsis</a> for concrete command line examples.</p>

<p>In <a href="http://search.cpan.org/dist/Devel-PerlySense/lib/Devel/PerlySense.pm" rel="noreferrer">Devel::PerlySense</a> there's Emacs support to display the coverage information in the source code buffer (<a href="http://cpansearch.perl.org/src/JOHANL/Devel-PerlySense-0.0180/doc/code_coverage.html" rel="noreferrer">screen shot</a>), and to navigate to/from covering test files.</p>
