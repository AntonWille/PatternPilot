 <h2> Title: What does map(&amp;:name) mean in Ruby? </h2> <h3> collimarco, question_id: 1217088 </h3>Score: 553, Tags: {ruby,syntax,operators,parameter-passing} <br><p>I found this code in <a href="http://railscasts.com/episodes/167-more-on-virtual-attributes" rel="noreferrer">a RailsCast</a>:</p>

<pre><code>def tag_names
  @tag_names || tags.map(&amp;:name).join(' ')
end
</code></pre>

<p>What does the <code>(&amp;:name)</code> in <code>map(&amp;:name)</code> mean?</p>
<h4> Comment 4137004 Josh Lee: </h4>I have heard this called “pretzel colon”, by the way.<br><h4> Comment 25294608 fontno: </h4>Calling it &quot;pretzel colon&quot; is misleading, although catchy. There is no &quot;&amp;:&quot; in ruby. The ampersand (&amp;) is a &quot;unary ampersand operator&quot; with a pushed together :symbol. If anything, it&#39;s a &quot;pretzel symbol&quot;. Just saying.<br><h4> Comment 20977481 DragonFax: </h4>Haha. I know that as an Ampersand. I have never heard it called a &quot;pretzel&quot; but that makes sense.<br><h4> Comment 64252366 kaushal sharma: </h4>tags.map(&amp;:name) is sort from of tags.map{|s| s.name}<br><h4> Comment 24595834 itsnikolay: </h4>Also you can drop out the brackets <code>tags.map &amp;:name</code> for the extra shortest entry.<br><h4> Comment 89641983 jgomo3: </h4><a href="https://www.brianstorti.com/understanding-ruby-idiom-map-with-symbol/" rel="nofollow noreferrer">brianstorti.com/understanding-ruby-idiom-map-with-symbol</a><br>------------------------------------------------------------------ <br><h3> Answer 1217114 Josh Lee: </h3><p>It's shorthand for <code>tags.map(&amp;:name.to_proc).join(' ')</code></p>

<p>If <code>foo</code> is an object with a <code>to_proc</code> method, then you can pass it to a method as <code>&amp;foo</code>, which will call <code>foo.to_proc</code> and use that as the method's block.</p>

<p>The <code>Symbol#to_proc</code> method was originally added by ActiveSupport but has been integrated into Ruby 1.8.7. This is its implementation:</p>

<pre><code>class Symbol
  def to_proc
    Proc.new do |obj, *args|
      obj.send self, *args
    end
  end
end
</code></pre>
<h4> Comment 1041546 Simone Carletti: </h4>tags.map(:name.to_proc) is itself a shorthand for tags.map { |tag| tag.name }<br><h4> Comment 7613386 horseyguy: </h4>this isn&#39;t valid ruby code, you still need the <code>&amp;</code>, i.e <code>tags.map(&amp;:name.to_proc).join(&#39; &#39;)</code><br><h4> Comment 7741639 Andrew Grimm: </h4>Symbol#to_proc is implemented in C, not in Ruby, but that&#39;s what it&#39;d look like in Ruby.<br><h4> Comment 20831945 Cameron Martin: </h4>@AndrewGrimm it was first added in Ruby on Rails, using that code. It was then added as a native ruby feature in version 1.8.7.<br><h4> Comment 26366983 jazzyfresh: </h4>@SimoneCarletti - While <code>tags.map { |tag| tag.name }</code> is effectively what <code>tags.map(&amp;:name.to_proc)</code> does, it is not exactly shorthand, per se. This is because procs can be converted to blocks, using the &amp; operator, when they are passed to methods that use yield and thus require a block. (See the Ruby documentation <a href="http://www.ruby-doc.org/core-2.0/doc/syntax/calling_methods_rdoc.html#label-Proc+to+Block+Conversion" rel="nofollow noreferrer">here</a>). As Josh Lee showed in his post above, symbols can also be converted to procs and, from there, can then be converted to a block, which is necessary because map uses blocks.<br><h4> Comment 27452389 Tero Tilus: </h4>@JaredBeck had it right: the ampersand just tells ruby that <i>&quot;this argument is the block, try your best to make it one if it ain&#39;t yet&quot;</i><br><h4> Comment 24951665 Mogox: </h4>Great answer! I think a link to show the entire Symbol implementation class would be useful. <a href="https://github.com/rubinius/rubinius/blob/master/kernel/common/symbol19.rb" rel="nofollow noreferrer">github.com/rubinius/rubinius/blob/master/kernel/common/&hellip;</a><br><h4> Comment 27383716 Jinzhao Huo: </h4>I found a great article to explain more detailed ampersand operator in Ruby, hope it helps people. The &quot;foo&quot; followed &quot;&amp;&quot; can be either a symbol or an Object.   <a href="http://ablogaboutcode.com/2012/01/04/the-ampersand-operator-in-ruby/" rel="nofollow noreferrer">ablogaboutcode.com/2012/01/04/the-ampersand-operator-in-ruby</a><br><h4> Comment 53974305 Luca Guidi: </h4>You should use <code>#__send__</code> instead of <code>#send</code> at it&#39;s safer. An object can override <code>send</code> for some reason (eg. sending emails), but if you do the same with <code>#__send__</code>, Ruby VM throws a warning.<br><h4> Comment 63228748 imtk: </h4>It&#39;s not just a shorthand, but also 20% faster and more idiomatic ruby code.<br><h4> Comment 13751148 Jared Beck: </h4>&quot;A block may be associated with a method call using either a literal block .. or a parameter containing a reference to a Proc or Method object prefixed with an ampersand character.&quot;  <a href="http://bit.ly/n8GpYw" rel="nofollow noreferrer">bit.ly/n8GpYw</a><br><h4> Comment 12210911 Gerry: </h4>@banister I think you can write <code>tags.map(&amp;:name).join(&#39; &#39;)</code> without the <code>to_proc</code><br><h4> Comment 75901626 Marko Avlijaš: </h4><code>If foo is an object with a to_proc method, then you can pass it to a method as &amp;foo</code>.  Please illustrate with an example, it&#39;s way too abstract for me. What is <code>&amp;foo</code> language construct even called? Don&#39;t know what to google to make this more clear.<br><h4> Comment 109700920 Jon Schneider: </h4>Wait -- <code>&amp;:name</code> is shorthand for <code>&amp;:name.to_proc</code>? If <code>&amp;:name</code> unrolls to <code>&amp;:name.to_proc</code>, then can&#39;t we apply the same &quot;unroll&quot; on that result, yielding <code>&amp;:name.to_proc.to_proc</code>, ad infinitum? This doesn&#39;t make sense to me.<br><h4> Comment 59039601 Muhammad Umer: </h4>it doesn&#39;t talk about how symbols are mapped/connected to actual methods. Symbol to proc sounds all good. But symbols are empty how do they become block of code.<br>------------------------------------------------------------------ <br><h3> Answer 9622553 Gerry: </h3><p>Another cool shorthand, unknown to many, is</p>

<pre><code>array.each(&amp;method(:foo))
</code></pre>

<p>which is a shorthand for </p>

<pre><code>array.each { |element| foo(element) }
</code></pre>

<p>By calling <code>method(:foo)</code> we took a <code>Method</code> object from <code>self</code> that represents its <code>foo</code> method, and used the <code>&amp;</code> to signify that it has a <code>to_proc</code> <a href="http://www.ruby-doc.org/core/Method.html#method-i-to_proc" rel="noreferrer">method</a> that converts it into a <code>Proc</code>.</p>

<p>This is very useful when you want to do things <em>point-free</em> style. An example is to check if there is any string in an array that is equal to the string <code>"foo"</code>. There is the conventional way:</p>

<pre><code>["bar", "baz", "foo"].any? { |str| str == "foo" }
</code></pre>

<p>And there is the point-free way:</p>

<pre><code>["bar", "baz", "foo"].any?(&amp;"foo".method(:==))
</code></pre>

<p>The preferred way should be the most readable one.</p>
<h4> Comment 13751020 Jared Beck: </h4><code>array.each{|e| foo(e)}</code> is shorter still :-) +1 anyways<br><h4> Comment 45048422 Gerry: </h4>@finishingmove yeah I guess. Try this <code>[1,2,3].map(&amp;Array.method(:new))</code><br><h4> Comment 45014881 holographic-principle: </h4>Could you map a constructor of another class using <code>&amp;method</code> ?<br><h4> Comment 131489382 Cadoiz: </h4>Spoiler: the result is <code>[[nil], [nil, nil], [nil, nil, nil]]</code> - this could get useful.<br>------------------------------------------------------------------ <br><h3> Answer 1217095 Sophie Alpert: </h3><p>It's equivalent to</p>

<pre><code>def tag_names
  @tag_names || tags.map { |tag| tag.name }.join(' ')
end
</code></pre>
------------------------------------------------------------------ <br><h3> Answer 40353702 Albert.Qing: </h3><pre><code>tags.map(&amp;:name)
</code></pre>

<p><strong>is The same as</strong></p>

<pre><code>tags.map{|tag| tag.name}
</code></pre>

<p><code>&amp;:name</code> just uses the symbol as the method name to be called.</p>
<h4> Comment 131765522 Qasim: </h4>Can I do this with multiple values, like <code>tags.map(&amp;:name, &amp;:id)</code>.<br><h4> Comment 131825192 Albert.Qing: </h4>@Qasim You can&#39;t do it, but you can do it like this <code>tags.map { |t| t.name.to_s &lt;&lt; t.age.to_s }</code><br>------------------------------------------------------------------ <br><h3> Answer 1217090 Oliver N.: </h3><p>It's shorthand for <code>tags.map { |tag| tag.name }.join(' ')</code></p>
<h4> Comment 1041553 Chuck: </h4>@collimarco: As jleedev says in his answer, the unary <code>&amp;</code> operator calls <code>to_proc</code> on its operand. So it&#39;s not specific to the map method, and in fact works on any method that takes a block and passes one or more arguments to the block.<br><h4> Comment 1041502 Chuck: </h4>Nope, it&#39;s in Ruby 1.8.7 and above.<br><h4> Comment 1041503 collimarco: </h4>Is it a simple idiom for map or Ruby always interpret the &#39;&amp;&#39; in a particular way?<br>------------------------------------------------------------------ <br><h3> Answer 13473388 Boris Stitnicky: </h3><p>While let us also note that ampersand <code>#to_proc</code> magic can work with any class, not just Symbol. Many Rubyists choose to define <code>#to_proc</code> on Array class:</p>

<pre><code>class Array
  def to_proc
    proc { |receiver| receiver.send *self }
  end
end

# And then...

[ 'Hello', 'Goodbye' ].map &amp;[ :+, ' world!' ]
#=&gt; ["Hello world!", "Goodbye world!"]
</code></pre>

<p>Ampersand <code>&amp;</code> works by sending <code>to_proc</code> message on its operand, which, in the above code, is of Array class. And since I defined <code>#to_proc</code> method on Array, the line becomes:</p>

<pre><code>[ 'Hello', 'Goodbye' ].map { |receiver| receiver.send( :+, ' world!' ) }
</code></pre>
------------------------------------------------------------------ <br><h3> Answer 36511806 devpuppy: </h3><p>Two things are happening here, and it's important to understand both.</p>

<p>As described in other answers, the <code>Symbol#to_proc</code> method is being called.</p>

<p>But the reason <code>to_proc</code> is being called on the symbol is because it's being passed to <code>map</code> as a block argument. Placing <code>&amp;</code> in front of an argument in a method call causes it to be passed this way. This is true for any Ruby method, not just <code>map</code> with symbols.</p>

<pre><code>def some_method(*args, &amp;block)
  puts "args: #{args.inspect}"
  puts "block: #{block.inspect}"
end

some_method(:whatever)
# args: [:whatever]
# block: nil

some_method(&amp;:whatever)
# args: []
# block: #&lt;Proc:0x007fd23d010da8&gt;

some_method(&amp;"whatever")
# TypeError: wrong argument type String (expected Proc)
# (String doesn't respond to #to_proc)
</code></pre>

<p>The <code>Symbol</code> gets converted to a <code>Proc</code> because it's passed in as a block. We can show this by trying to pass a proc to <code>.map</code> without the ampersand: </p>

<pre><code>arr = %w(apple banana)
reverse_upcase = proc { |i| i.reverse.upcase }
reverse_upcase.is_a?(Proc)
=&gt; true

arr.map(reverse_upcase)
# ArgumentError: wrong number of arguments (1 for 0)
# (map expects 0 positional arguments and one block argument)

arr.map(&amp;reverse_upcase)
=&gt; ["ELPPA", "ANANAB"]
</code></pre>

<p>Even though it doesn't need to be converted, the method won't know how to use it because it expects a block argument. Passing it with <code>&amp;</code> gives <code>.map</code> the block it expects.</p>
------------------------------------------------------------------ <br><h3> Answer 21319345 prosseek: </h3><p>Josh Lee's answer is almost correct except that the equivalent Ruby code should have been as follows. </p>

<pre><code>class Symbol
  def to_proc
    Proc.new do |receiver|
      receiver.send self
    end
  end
end
</code></pre>

<p>not</p>

<pre><code>class Symbol
  def to_proc
    Proc.new do |obj, *args|
      obj.send self, *args
    end
  end
end
</code></pre>

<p>With this code, when <code>print [[1,'a'],[2,'b'],[3,'c']].map(&amp;:first)</code> is executed, Ruby splits the first input <code>[1,'a']</code> into 1 and 'a' to give <code>obj</code> 1 and <code>args*</code> 'a' to cause an error as Fixnum object 1 does not have the method self (which is :first). </p>

<hr>

<p>When <code>[[1,'a'],[2,'b'],[3,'c']].map(&amp;:first)</code> is executed;</p>

<ol>
<li><p><code>:first</code> is a Symbol object, so when <code>&amp;:first</code> is given to a map method as a parameter, Symbol#to_proc is invoked.</p></li>
<li><p>map sends call message to :first.to_proc with parameter <code>[1,'a']</code>, e.g., <code>:first.to_proc.call([1,'a'])</code> is executed. </p></li>
<li><p>to_proc procedure in Symbol class sends a send message to an array object (<code>[1,'a']</code>) with parameter (:first), e.g., <code>[1,'a'].send(:first)</code> is executed.</p></li>
<li><p>iterates over the rest of the elements in <code>[[1,'a'],[2,'b'],[3,'c']]</code> object.</p></li>
</ol>

<p>This is the same as executing <code>[[1,'a'],[2,'b'],[3,'c']].map(|e| e.first)</code> expression.</p>
<h4> Comment 36515493 Uri Agassi: </h4>Josh Lee&#39;s answer is <i>absolutely</i> correct, as you can see by thinking about <code>[1,2,3,4,5,6].inject(&amp;:+)</code> - inject expects a lambda with two parameters (memo and item) and <code>:+.to_proc</code> delivers it - <code>Proc.new |obj, *args| { obj.send(self, *args) }</code> or <code>{ |m, o| m.+(o) }</code><br>------------------------------------------------------------------ <br><h3> Answer 39137586 tessie: </h3><p>(&amp;:name) is short for (&amp;:name.to_proc) it is same as <code>tags.map{ |t| t.name }.join(' ')</code></p>

<p>to_proc is actually implemented in C</p>
------------------------------------------------------------------ <br><h3> Answer 52124956 Sunda: </h3><p><strong>map(&amp;:name)</strong> takes an enumerable object (tags in your case) and runs the name method for each element/tag, outputting each returned value from the method.</p>

<p>It is a shorthand for</p>

<pre><code>array.map { |element| element.name }
</code></pre>

<p>which returns the array of element(tag) names</p>
------------------------------------------------------------------ <br><h3> Answer 60698262 Christoph: </h3><p>First, <code>&amp;:name</code> is a shortcut for <code>&amp;:name.to_proc</code>, where <code>:name.to_proc</code> returns a <code>Proc</code> (something that is similar, but not identical to a lambda) that when called with an object as (first) argument, calls the <code>name</code> method on that object.</p>

<p>Second, while <code>&amp;</code> in <code>def foo(&amp;block) ... end</code> converts a block passed to <code>foo</code> to a <code>Proc</code>, it does the opposite when applied to a <code>Proc</code>.</p>

<p>Thus, <code>&amp;:name.to_proc</code> is a block that takes an object as argument and calls the <code>name</code> method on it, i. e. <code>{ |o| o.name }</code>.</p>
------------------------------------------------------------------ <br><h3> Answer 47717274 Jonathan Duarte: </h3><p>Although we have great answers already, looking through a perspective of a beginner I'd like to add the additional information:</p>

<blockquote>
  <p>What does map(&amp;:name) mean in Ruby?</p>
</blockquote>

<p>This means, that you are passing another method as parameter to the map function. 
(In reality you're passing a symbol that gets converted into a proc. But this isn't that important in this particular case).</p>

<p>What is important is that you have a <code>method</code> named <code>name</code> that will be used by the map method as an argument instead of the traditional <code>block</code> style.</p>
------------------------------------------------------------------ <br><h3> Answer 54654360 Olalekan Sogunle: </h3><p>It basically execute the method call <code>tag.name</code> on each tags in the array.</p>

<p>It is a simplified ruby shorthand.</p>
------------------------------------------------------------------ <br><h3> Answer 73688547 MD Shahid Khan: </h3><p>There isn't a &amp;: operator in Ruby. What you are seeing is the &amp; operator applied to a :symbol.</p>
<p>In a method argument list, the &amp; operator takes its operand, converts it to a Proc object if it isn't already (by calling to_proc on it) and passes it to the method as if a block had been used.</p>
<p>my_proc = Proc.new { puts &quot;foo&quot; }</p>
<p>my_method_call(&amp;my_proc) # is identical to:
my_method_call { puts &quot;foo&quot; }</p>
------------------------------------------------------------------ <br><h3> Answer 38115498 timlentse: </h3><p>Here <code>:name</code> is the symbol which point to the method <code>name</code> of tag object.
When we pass <code>&amp;:name</code> to <code>map</code>, it will treat <code>name</code> as a proc object. 
For short, <code>tags.map(&amp;:name)</code> acts as: </p>

<pre><code>tags.map do |tag|
  tag.name
end
</code></pre>
------------------------------------------------------------------ <br><h3> Answer 41242320 DDD: </h3><p>it means</p>

<pre><code>array.each(&amp;:to_sym.to_proc)
</code></pre>
------------------------------------------------------------------ <br><h3> Answer 38050404 Naveen Kumar: </h3><p>It is same as below:</p>

<pre><code>def tag_names
  if @tag_names
    @tag_names
  else
    tags.map{ |t| t.name }.join(' ')
end
</code></pre>
