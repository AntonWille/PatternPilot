 <h2> Title: What does map(&amp;:name) mean in Ruby? </h2> <h4> collimarco, question_id: 1217088, created_at: 2009-08-01 17:35:58+00:00 </h4>Score: 553, Tags: {ruby,syntax,operators,parameter-passing} <br><p>I found this code in <a href="http://railscasts.com/episodes/167-more-on-virtual-attributes" rel="noreferrer">a RailsCast</a>:</p>

<pre><code>def tag_names
  @tag_names || tags.map(&amp;:name).join(' ')
end
</code></pre>

<p>What does the <code>(&amp;:name)</code> in <code>map(&amp;:name)</code> mean?</p>
<h4> Comment by DragonFax, Score: 7, Id: 20977481, created_at: 2013-02-18 21:51:56+00:00 </h4>Haha. I know that as an Ampersand. I have never heard it called a &quot;pretzel&quot; but that makes sense.<h4> Comment by Josh Lee, Score: 139, Id: 4137004, created_at: 2010-10-07 20:40:37+00:00 </h4>I have heard this called “pretzel colon”, by the way.<h4> Comment by fontno, Score: 81, Id: 25294608, created_at: 2013-07-02 03:42:34+00:00 </h4>Calling it &quot;pretzel colon&quot; is misleading, although catchy. There is no &quot;&amp;:&quot; in ruby. The ampersand (&amp;) is a &quot;unary ampersand operator&quot; with a pushed together :symbol. If anything, it&#39;s a &quot;pretzel symbol&quot;. Just saying.<h4> Comment by kaushal sharma, Score: 4, Id: 64252366, created_at: 2016-07-17 15:43:35+00:00 </h4>tags.map(&amp;:name) is sort from of tags.map{|s| s.name}<h4> Comment by itsnikolay, Score: 1, Id: 24595834, created_at: 2013-06-10 07:40:09+00:00 </h4>Also you can drop out the brackets <code>tags.map &amp;:name</code> for the extra shortest entry.<h4> Comment by jgomo3, Score: 0, Id: 89641983, created_at: 2018-07-13 21:57:28+00:00 </h4><a href="https://www.brianstorti.com/understanding-ruby-idiom-map-with-symbol/" rel="nofollow noreferrer">brianstorti.com/understanding-ruby-idiom-map-with-symbol</a><hr><h3> ✔️ Answer by Josh Lee, Id: 1217114, Score: 551, created_at: 2009-08-01 17:50:37+00:00 </h3><p>It's shorthand for <code>tags.map(&amp;:name.to_proc).join(' ')</code></p>

<p>If <code>foo</code> is an object with a <code>to_proc</code> method, then you can pass it to a method as <code>&amp;foo</code>, which will call <code>foo.to_proc</code> and use that as the method's block.</p>

<p>The <code>Symbol#to_proc</code> method was originally added by ActiveSupport but has been integrated into Ruby 1.8.7. This is its implementation:</p>

<pre><code>class Symbol
  def to_proc
    Proc.new do |obj, *args|
      obj.send self, *args
    end
  end
end
</code></pre>
<h4> Comment by Simone Carletti, Score: 104, Id: 1041546, created_at: 2009-08-01 18:05:44+00:00 </h4>tags.map(:name.to_proc) is itself a shorthand for tags.map { |tag| tag.name }<h4> Comment by horseyguy, Score: 6, Id: 7613386, created_at: 2011-06-25 13:00:28+00:00 </h4>this isn&#39;t valid ruby code, you still need the <code>&amp;</code>, i.e <code>tags.map(&amp;:name.to_proc).join(&#39; &#39;)</code><h4> Comment by Andrew Grimm, Score: 5, Id: 7741639, created_at: 2011-07-04 02:46:41+00:00 </h4>Symbol#to_proc is implemented in C, not in Ruby, but that&#39;s what it&#39;d look like in Ruby.<h4> Comment by Cameron Martin, Score: 5, Id: 20831945, created_at: 2013-02-13 19:13:09+00:00 </h4>@AndrewGrimm it was first added in Ruby on Rails, using that code. It was then added as a native ruby feature in version 1.8.7.<h4> Comment by jazzyfresh, Score: 4, Id: 26366983, created_at: 2013-08-02 21:46:13+00:00 </h4>@SimoneCarletti - While <code>tags.map { |tag| tag.name }</code> is effectively what <code>tags.map(&amp;:name.to_proc)</code> does, it is not exactly shorthand, per se. This is because procs can be converted to blocks, using the &amp; operator, when they are passed to methods that use yield and thus require a block. (See the Ruby documentation <a href="http://www.ruby-doc.org/core-2.0/doc/syntax/calling_methods_rdoc.html#label-Proc+to+Block+Conversion" rel="nofollow noreferrer">here</a>). As Josh Lee showed in his post above, symbols can also be converted to procs and, from there, can then be converted to a block, which is necessary because map uses blocks.<h4> Comment by Mogox, Score: 2, Id: 24951665, created_at: 2013-06-20 20:21:17+00:00 </h4>Great answer! I think a link to show the entire Symbol implementation class would be useful. <a href="https://github.com/rubinius/rubinius/blob/master/kernel/common/symbol19.rb" rel="nofollow noreferrer">github.com/rubinius/rubinius/blob/master/kernel/common/&hellip;</a><h4> Comment by Tero Tilus, Score: 2, Id: 27452389, created_at: 2013-09-05 19:47:52+00:00 </h4>@JaredBeck had it right: the ampersand just tells ruby that <i>&quot;this argument is the block, try your best to make it one if it ain&#39;t yet&quot;</i><h4> Comment by Jinzhao Huo, Score: 1, Id: 27383716, created_at: 2013-09-04 03:33:56+00:00 </h4>I found a great article to explain more detailed ampersand operator in Ruby, hope it helps people. The &quot;foo&quot; followed &quot;&amp;&quot; can be either a symbol or an Object.   <a href="http://ablogaboutcode.com/2012/01/04/the-ampersand-operator-in-ruby/" rel="nofollow noreferrer">ablogaboutcode.com/2012/01/04/the-ampersand-operator-in-ruby</a><h4> Comment by Luca Guidi, Score: 1, Id: 53974305, created_at: 2015-10-12 10:27:51+00:00 </h4>You should use <code>#__send__</code> instead of <code>#send</code> at it&#39;s safer. An object can override <code>send</code> for some reason (eg. sending emails), but if you do the same with <code>#__send__</code>, Ruby VM throws a warning.<h4> Comment by imtk, Score: 1, Id: 63228748, created_at: 2016-06-17 17:16:55+00:00 </h4>It&#39;s not just a shorthand, but also 20% faster and more idiomatic ruby code.<h4> Comment by Jared Beck, Score: 1, Id: 13751148, created_at: 2012-05-16 05:22:15+00:00 </h4>&quot;A block may be associated with a method call using either a literal block .. or a parameter containing a reference to a Proc or Method object prefixed with an ampersand character.&quot;  <a href="http://bit.ly/n8GpYw" rel="nofollow noreferrer">bit.ly/n8GpYw</a><h4> Comment by Gerry, Score: 0, Id: 12210911, created_at: 2012-03-08 17:58:32+00:00 </h4>@banister I think you can write <code>tags.map(&amp;:name).join(&#39; &#39;)</code> without the <code>to_proc</code><h4> Comment by Marko Avlijaš, Score: 0, Id: 75901626, created_at: 2017-06-09 08:09:35+00:00 </h4><code>If foo is an object with a to_proc method, then you can pass it to a method as &amp;foo</code>.  Please illustrate with an example, it&#39;s way too abstract for me. What is <code>&amp;foo</code> language construct even called? Don&#39;t know what to google to make this more clear.<h4> Comment by Jon Schneider, Score: 0, Id: 109700920, created_at: 2020-05-26 14:54:00+00:00 </h4>Wait -- <code>&amp;:name</code> is shorthand for <code>&amp;:name.to_proc</code>? If <code>&amp;:name</code> unrolls to <code>&amp;:name.to_proc</code>, then can&#39;t we apply the same &quot;unroll&quot; on that result, yielding <code>&amp;:name.to_proc.to_proc</code>, ad infinitum? This doesn&#39;t make sense to me.<h4> Comment by Muhammad Umer, Score: 0, Id: 59039601, created_at: 2016-02-28 09:40:39+00:00 </h4>it doesn&#39;t talk about how symbols are mapped/connected to actual methods. Symbol to proc sounds all good. But symbols are empty how do they become block of code.<hr><h3>  Answer by Gerry, Id: 9622553, Score: 199, created_at: 2012-03-08 18:07:09+00:00 </h3><p>Another cool shorthand, unknown to many, is</p>

<pre><code>array.each(&amp;method(:foo))
</code></pre>

<p>which is a shorthand for </p>

<pre><code>array.each { |element| foo(element) }
</code></pre>

<p>By calling <code>method(:foo)</code> we took a <code>Method</code> object from <code>self</code> that represents its <code>foo</code> method, and used the <code>&amp;</code> to signify that it has a <code>to_proc</code> <a href="http://www.ruby-doc.org/core/Method.html#method-i-to_proc" rel="noreferrer">method</a> that converts it into a <code>Proc</code>.</p>

<p>This is very useful when you want to do things <em>point-free</em> style. An example is to check if there is any string in an array that is equal to the string <code>"foo"</code>. There is the conventional way:</p>

<pre><code>["bar", "baz", "foo"].any? { |str| str == "foo" }
</code></pre>

<p>And there is the point-free way:</p>

<pre><code>["bar", "baz", "foo"].any?(&amp;"foo".method(:==))
</code></pre>

<p>The preferred way should be the most readable one.</p>
<h4> Comment by Cadoiz, Score: 0, Id: 131489382, created_at: 2022-11-18 08:42:28+00:00 </h4>Spoiler: the result is <code>[[nil], [nil, nil], [nil, nil, nil]]</code> - this could get useful.<h4> Comment by Jared Beck, Score: 31, Id: 13751020, created_at: 2012-05-16 05:13:05+00:00 </h4><code>array.each{|e| foo(e)}</code> is shorter still :-) +1 anyways<h4> Comment by Gerry, Score: 5, Id: 45048422, created_at: 2015-02-05 19:24:01+00:00 </h4>@finishingmove yeah I guess. Try this <code>[1,2,3].map(&amp;Array.method(:new))</code><h4> Comment by holographic-principle, Score: 0, Id: 45014881, created_at: 2015-02-05 00:20:48+00:00 </h4>Could you map a constructor of another class using <code>&amp;method</code> ?<hr><h3>  Answer by Sophie Alpert, Id: 1217095, Score: 84, created_at: 2009-08-01 17:39:52+00:00 </h3><p>It's equivalent to</p>

<pre><code>def tag_names
  @tag_names || tags.map { |tag| tag.name }.join(' ')
end
</code></pre>
<hr><h3>  Answer by Albert.Qing, Id: 40353702, Score: 69, created_at: 2016-11-01 03:23:29+00:00 </h3><pre><code>tags.map(&amp;:name)
</code></pre>

<p><strong>is The same as</strong></p>

<pre><code>tags.map{|tag| tag.name}
</code></pre>

<p><code>&amp;:name</code> just uses the symbol as the method name to be called.</p>
<h4> Comment by Qasim, Score: 1, Id: 131765522, created_at: 2022-12-02 04:58:09+00:00 </h4>Can I do this with multiple values, like <code>tags.map(&amp;:name, &amp;:id)</code>.<h4> Comment by Albert.Qing, Score: 1, Id: 131825192, created_at: 2022-12-05 13:42:04+00:00 </h4>@Qasim You can&#39;t do it, but you can do it like this <code>tags.map { |t| t.name.to_s &lt;&lt; t.age.to_s }</code><hr><h3>  Answer by Boris Stitnicky, Id: 13473388, Score: 52, created_at: 2012-11-20 12:38:28+00:00 </h3><p>While let us also note that ampersand <code>#to_proc</code> magic can work with any class, not just Symbol. Many Rubyists choose to define <code>#to_proc</code> on Array class:</p>

<pre><code>class Array
  def to_proc
    proc { |receiver| receiver.send *self }
  end
end

# And then...

[ 'Hello', 'Goodbye' ].map &amp;[ :+, ' world!' ]
#=&gt; ["Hello world!", "Goodbye world!"]
</code></pre>

<p>Ampersand <code>&amp;</code> works by sending <code>to_proc</code> message on its operand, which, in the above code, is of Array class. And since I defined <code>#to_proc</code> method on Array, the line becomes:</p>

<pre><code>[ 'Hello', 'Goodbye' ].map { |receiver| receiver.send( :+, ' world!' ) }
</code></pre>
<hr><h3>  Answer by Oliver N., Id: 1217090, Score: 41, created_at: 2009-08-01 17:37:34+00:00 </h3><p>It's shorthand for <code>tags.map { |tag| tag.name }.join(' ')</code></p>
<h4> Comment by Chuck, Score: 7, Id: 1041553, created_at: 2009-08-01 18:11:19+00:00 </h4>@collimarco: As jleedev says in his answer, the unary <code>&amp;</code> operator calls <code>to_proc</code> on its operand. So it&#39;s not specific to the map method, and in fact works on any method that takes a block and passes one or more arguments to the block.<h4> Comment by Chuck, Score: 0, Id: 1041502, created_at: 2009-08-01 17:41:56+00:00 </h4>Nope, it&#39;s in Ruby 1.8.7 and above.<h4> Comment by collimarco, Score: 0, Id: 1041503, created_at: 2009-08-01 17:43:06+00:00 </h4>Is it a simple idiom for map or Ruby always interpret the &#39;&amp;&#39; in a particular way?<hr><h3>  Answer by devpuppy, Id: 36511806, Score: 19, created_at: 2016-04-09 01:43:55+00:00 </h3><p>Two things are happening here, and it's important to understand both.</p>

<p>As described in other answers, the <code>Symbol#to_proc</code> method is being called.</p>

<p>But the reason <code>to_proc</code> is being called on the symbol is because it's being passed to <code>map</code> as a block argument. Placing <code>&amp;</code> in front of an argument in a method call causes it to be passed this way. This is true for any Ruby method, not just <code>map</code> with symbols.</p>

<pre><code>def some_method(*args, &amp;block)
  puts "args: #{args.inspect}"
  puts "block: #{block.inspect}"
end

some_method(:whatever)
# args: [:whatever]
# block: nil

some_method(&amp;:whatever)
# args: []
# block: #&lt;Proc:0x007fd23d010da8&gt;

some_method(&amp;"whatever")
# TypeError: wrong argument type String (expected Proc)
# (String doesn't respond to #to_proc)
</code></pre>

<p>The <code>Symbol</code> gets converted to a <code>Proc</code> because it's passed in as a block. We can show this by trying to pass a proc to <code>.map</code> without the ampersand: </p>

<pre><code>arr = %w(apple banana)
reverse_upcase = proc { |i| i.reverse.upcase }
reverse_upcase.is_a?(Proc)
=&gt; true

arr.map(reverse_upcase)
# ArgumentError: wrong number of arguments (1 for 0)
# (map expects 0 positional arguments and one block argument)

arr.map(&amp;reverse_upcase)
=&gt; ["ELPPA", "ANANAB"]
</code></pre>

<p>Even though it doesn't need to be converted, the method won't know how to use it because it expects a block argument. Passing it with <code>&amp;</code> gives <code>.map</code> the block it expects.</p>
<hr><h3>  Answer by prosseek, Id: 21319345, Score: 15, created_at: 2014-01-23 21:08:40+00:00 </h3><p>Josh Lee's answer is almost correct except that the equivalent Ruby code should have been as follows. </p>

<pre><code>class Symbol
  def to_proc
    Proc.new do |receiver|
      receiver.send self
    end
  end
end
</code></pre>

<p>not</p>

<pre><code>class Symbol
  def to_proc
    Proc.new do |obj, *args|
      obj.send self, *args
    end
  end
end
</code></pre>

<p>With this code, when <code>print [[1,'a'],[2,'b'],[3,'c']].map(&amp;:first)</code> is executed, Ruby splits the first input <code>[1,'a']</code> into 1 and 'a' to give <code>obj</code> 1 and <code>args*</code> 'a' to cause an error as Fixnum object 1 does not have the method self (which is :first). </p>

<hr>

<p>When <code>[[1,'a'],[2,'b'],[3,'c']].map(&amp;:first)</code> is executed;</p>

<ol>
<li><p><code>:first</code> is a Symbol object, so when <code>&amp;:first</code> is given to a map method as a parameter, Symbol#to_proc is invoked.</p></li>
<li><p>map sends call message to :first.to_proc with parameter <code>[1,'a']</code>, e.g., <code>:first.to_proc.call([1,'a'])</code> is executed. </p></li>
<li><p>to_proc procedure in Symbol class sends a send message to an array object (<code>[1,'a']</code>) with parameter (:first), e.g., <code>[1,'a'].send(:first)</code> is executed.</p></li>
<li><p>iterates over the rest of the elements in <code>[[1,'a'],[2,'b'],[3,'c']]</code> object.</p></li>
</ol>

<p>This is the same as executing <code>[[1,'a'],[2,'b'],[3,'c']].map(|e| e.first)</code> expression.</p>
<h4> Comment by Uri Agassi, Score: 2, Id: 36515493, created_at: 2014-05-20 04:18:02+00:00 </h4>Josh Lee&#39;s answer is <i>absolutely</i> correct, as you can see by thinking about <code>[1,2,3,4,5,6].inject(&amp;:+)</code> - inject expects a lambda with two parameters (memo and item) and <code>:+.to_proc</code> delivers it - <code>Proc.new |obj, *args| { obj.send(self, *args) }</code> or <code>{ |m, o| m.+(o) }</code><hr><h3>  Answer by tessie, Id: 39137586, Score: 5, created_at: 2016-08-25 05:50:15+00:00 </h3><p>(&amp;:name) is short for (&amp;:name.to_proc) it is same as <code>tags.map{ |t| t.name }.join(' ')</code></p>

<p>to_proc is actually implemented in C</p>
<hr><h3>  Answer by Sunda, Id: 52124956, Score: 5, created_at: 2018-09-01 04:48:06+00:00 </h3><p><strong>map(&amp;:name)</strong> takes an enumerable object (tags in your case) and runs the name method for each element/tag, outputting each returned value from the method.</p>

<p>It is a shorthand for</p>

<pre><code>array.map { |element| element.name }
</code></pre>

<p>which returns the array of element(tag) names</p>
<hr><h3>  Answer by Christoph, Id: 60698262, Score: 5, created_at: 2020-03-15 22:22:59+00:00 </h3><p>First, <code>&amp;:name</code> is a shortcut for <code>&amp;:name.to_proc</code>, where <code>:name.to_proc</code> returns a <code>Proc</code> (something that is similar, but not identical to a lambda) that when called with an object as (first) argument, calls the <code>name</code> method on that object.</p>

<p>Second, while <code>&amp;</code> in <code>def foo(&amp;block) ... end</code> converts a block passed to <code>foo</code> to a <code>Proc</code>, it does the opposite when applied to a <code>Proc</code>.</p>

<p>Thus, <code>&amp;:name.to_proc</code> is a block that takes an object as argument and calls the <code>name</code> method on it, i. e. <code>{ |o| o.name }</code>.</p>
<hr><h3>  Answer by Jonathan Duarte, Id: 47717274, Score: 4, created_at: 2017-12-08 15:23:39+00:00 </h3><p>Although we have great answers already, looking through a perspective of a beginner I'd like to add the additional information:</p>

<blockquote>
  <p>What does map(&amp;:name) mean in Ruby?</p>
</blockquote>

<p>This means, that you are passing another method as parameter to the map function. 
(In reality you're passing a symbol that gets converted into a proc. But this isn't that important in this particular case).</p>

<p>What is important is that you have a <code>method</code> named <code>name</code> that will be used by the map method as an argument instead of the traditional <code>block</code> style.</p>
<hr><h3>  Answer by Olalekan Sogunle, Id: 54654360, Score: 2, created_at: 2019-02-12 16:15:36+00:00 </h3><p>It basically execute the method call <code>tag.name</code> on each tags in the array.</p>

<p>It is a simplified ruby shorthand.</p>
<hr><h3>  Answer by MD Shahid Khan, Id: 73688547, Score: 2, created_at: 2022-09-12 11:26:52+00:00 </h3><p>There isn't a &amp;: operator in Ruby. What you are seeing is the &amp; operator applied to a :symbol.</p>
<p>In a method argument list, the &amp; operator takes its operand, converts it to a Proc object if it isn't already (by calling to_proc on it) and passes it to the method as if a block had been used.</p>
<p>my_proc = Proc.new { puts &quot;foo&quot; }</p>
<p>my_method_call(&amp;my_proc) # is identical to:
my_method_call { puts &quot;foo&quot; }</p>
<hr><h3>  Answer by timlentse, Id: 38115498, Score: 1, created_at: 2016-06-30 06:30:44+00:00 </h3><p>Here <code>:name</code> is the symbol which point to the method <code>name</code> of tag object.
When we pass <code>&amp;:name</code> to <code>map</code>, it will treat <code>name</code> as a proc object. 
For short, <code>tags.map(&amp;:name)</code> acts as: </p>

<pre><code>tags.map do |tag|
  tag.name
end
</code></pre>
<hr><h3>  Answer by DDD, Id: 41242320, Score: 1, created_at: 2016-12-20 12:25:09+00:00 </h3><p>it means</p>

<pre><code>array.each(&amp;:to_sym.to_proc)
</code></pre>
<hr><h3>  Answer by Naveen Kumar, Id: 38050404, Score: -1, created_at: 2016-06-27 09:32:18+00:00 </h3><p>It is same as below:</p>

<pre><code>def tag_names
  if @tag_names
    @tag_names
  else
    tags.map{ |t| t.name }.join(' ')
end
</code></pre>
