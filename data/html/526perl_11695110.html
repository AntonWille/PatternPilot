 <h2> Title: Why is this program valid? I was trying to create a syntax error </h2> <h4> Bill Ruppert, question_id: 11695110, created_at: 2012-07-27 20:19:22+00:00 </h4>Score: 526, Tags: {perl} <br><p>I'm running ActiveState's 32 bit <a href="https://www.activestate.com/activeperl" rel="noreferrer">ActivePerl</a> 5.14.2 on Windows 7. I wanted to mess around with a Git pre-commit hook to detect programs being checked in with syntax errors. (Somehow I just managed to do such a bad commit.) So as a test program I randomly jotted this:</p>

<pre><code>use strict;
use warnings;

Syntax error!

exit 0;
</code></pre>

<p>However, it compiles and executes with no warnings, and errorlevel is zero on exit. How is this valid syntax?</p>
<h4> Comment by Peter M, Score: 140, Id: 15853182, created_at: 2012-08-10 19:16:56+00:00 </h4>Did you just prove that typing random words into perl produces working programs??!?!?!?!<h4> Comment by Bill Ruppert, Score: 13, Id: 15875552, created_at: 2012-08-12 12:06:09+00:00 </h4>@PeterM Hardly random words.  I proved I don&#39;t know enough about Perl syntax.  Now I know a bit more.<h4> Comment by LeoNerd, Score: 11, Id: 33936360, created_at: 2014-03-11 16:39:44+00:00 </h4>You probably want <code>no indirect</code> to stop those ones from happening<h4> Comment by clt60, Score: 3, Id: 72369081, created_at: 2017-03-06 08:00:21+00:00 </h4>This is the <b>most famous</b> perl question ever. Even better as <a href="http://www.perlmonks.org/?node_id=663393" rel="nofollow noreferrer">Schwartz&#39;s snippet</a>: <code>whatever  &#47; 25 ; # &#47; ; die &quot;this dies!&quot;;</code><h4> Comment by bbaassssiiee, Score: 0, Id: 116532674, created_at: 2021-01-26 20:48:54+00:00 </h4>Written by linguist Larry Wall, Perl allows authors a lot of creative space. There is a sub-category in perl programming called Perl Poetry, valid Perl expressing stuff beyond computer interpretation: <a href="https://www.perlmonks.org/?node_id=1111395" rel="nofollow noreferrer">perlmonks.org/?node_id=1111395</a><hr><h3> ✔️ Answer by ikegami, Id: 11695310, Score: 573, created_at: 2012-07-27 20:36:00+00:00 </h3><p>Perl has a syntax called &quot;indirect method notation&quot;. It allows</p>
<pre><code>Foo-&gt;new($bar)
</code></pre>
<p>to be written as</p>
<pre><code>new Foo $bar
</code></pre>
<p>So that means</p>
<pre><code>Syntax error ! exit 0;
</code></pre>
<p>is the same as</p>
<pre><code>error-&gt;Syntax(! exit 0);
</code></pre>
<p>or</p>
<pre><code>error-&gt;Syntax(!exit(0));
</code></pre>
<p>Not only is it valid syntax, it doesn't result in a run-time error because the first thing executed is <code>exit(0)</code>.</p>
<hr />
<p>This feature can be disabled using any of the following:</p>
<pre class="lang-perl prettyprint-override"><code>no feature qw( indirect );  # Perl 5.32+

use v5.36;                  # Perl 5.36+

no indirect;                # CPAN module
</code></pre>
<h4> Comment by ikegami, Score: 12, Id: 15510016, created_at: 2012-07-27 21:25:37+00:00 </h4>@Hassan, The language has types. Specifically, values have types. Operators and subs are simply not confined to returning specific types of values. This turns out to be <i>very</i> useful at little cost (thanks to warnings).<h4> Comment by ikegami, Score: 6, Id: 15519789, created_at: 2012-07-28 14:51:51+00:00 </h4>@Nawaz, It&#39;s actually quite popular. It&#39;s used by everyone that constructs objects in Java and C++, and a large body of Perl programmers that uses <code>new Class</code> and <code>print $fh ...</code> instead of <code>Class-&gt;new(...)</code> and <code>$fh-&gt;print(...)</code>. I will grant you that it causes a weird error messages, though<h4> Comment by ikegami, Score: 6, Id: 15509412, created_at: 2012-07-27 20:51:33+00:00 </h4>@Hassan, Think of it this way, <code>!exit(0)</code> can no more be a type error than <code>!$x</code> since neither are typed.<h4> Comment by Bill Ruppert, Score: 3, Id: 15509221, created_at: 2012-07-27 20:43:50+00:00 </h4>I got as far as reading it as &quot;Syntax error !exit 0;&quot;, but I didn&#39;t think about indirect invocation.  Spent a lot of time forgetting that!<h4> Comment by user377628, Score: 1, Id: 15509591, created_at: 2012-07-27 20:58:46+00:00 </h4>Non-typed languages give me the jitters.<h4> Comment by ikegami, Score: 1, Id: 15509301, created_at: 2012-07-27 20:47:06+00:00 </h4>@Hassan, When <code>exit</code> returns (never), it does return a boolean, just like every single other op and sub in scalar context. That&#39;s wouldn&#39;t be a syntax error anyway, that would be a type error.<h4> Comment by ikegami, Score: 1, Id: 15509144, created_at: 2012-07-27 20:39:49+00:00 </h4>@Hassan, Why? It&#39;s followed by an expression.<h4> Comment by user377628, Score: 1, Id: 15509213, created_at: 2012-07-27 20:43:16+00:00 </h4>Okay, maybe because I don&#39;t know perl, but in many other languages, that would only work if <code>exit</code>&#39;s return value is a boolean (or something else that can be the operand of <code>!</code>), ie simply being an expression is not enough.<h4> Comment by user377628, Score: 0, Id: 15509134, created_at: 2012-07-27 20:39:16+00:00 </h4>Good explanation! But shouldn&#39;t the not operator (<code>!</code>) cause a syntax error?<h4> Comment by user377628, Score: 0, Id: 15509340, created_at: 2012-07-27 20:48:52+00:00 </h4>Ahh, I see. Again, I&#39;m pretty perl-ignorant, so sorry about that.<hr><h3>  Answer by pavel, Id: 11695199, Score: 118, created_at: 2012-07-27 20:26:55+00:00 </h3><p>I don't know why, but this is what Perl makes of it:</p>

<pre><code>perl -MO=Deparse -w yuck
BEGIN { $^W = 1; }
use warnings;
use strict 'refs';
'error'-&gt;Syntax(!exit(0));
yuck syntax OK
</code></pre>

<p>It seems that the parser thinks you're calling the method <code>Syntax</code> on the <code>error</code>-object... Strange indeed!</p>
<h4> Comment by mob, Score: 119, Id: 15508977, created_at: 2012-07-27 20:32:28+00:00 </h4>Congratulations. You found a program where you need to add a semi-colon in order do get the compile to fail.<h4> Comment by amon, Score: 7, Id: 15508927, created_at: 2012-07-27 20:30:06+00:00 </h4>Perl seems to assume the &quot;indirect (object) syntax&quot;, usually used like <code>new Class</code> instead of <code>Class-&gt;new()</code>. To call the method <code>Syntax</code>, the <code>exit</code> function is executed, so the run-time error never occures.<h4> Comment by user149341, Score: 3, Id: 15508926, created_at: 2012-07-27 20:29:59+00:00 </h4>That&#39;s indirect method call syntax. It&#39;s (sort of) working here because the <code>exit(0)</code> is evaluated first, making the program exit before it tries to pass the result to <code>&#39;error&#39;-&gt;Syntax()</code>.<h4> Comment by user4401178, Score: 0, Id: 56260292, created_at: 2015-12-14 03:43:38+00:00 </h4><code>use strict; use warnings;  error-&gt;Syntax(! print &quot;hi&quot;);</code>  Yields: Syntax Ok on perl -MO=Deparse as well, but with <code>use warnings</code> it should probably say something since it can figure out that its not being loaded. Instead it throws a runtime error &quot;Can&#39;t locate object method .. &quot;.<hr><h3>  Answer by TLP, Id: 11695318, Score: 57, created_at: 2012-07-27 20:36:41+00:00 </h3><p>The reason you do not get an error is that the first executed code is </p>

<pre><code>exit(0);
</code></pre>

<p>Because you did not have a semicolon on the first line:</p>

<pre><code>Syntax error!
</code></pre>

<p>The compiler will guess (incorrectly) that this is a subroutine call with a <code>not</code> operator <code>!</code> thrown in. It will then execute the arguments to this subroutine, which happens to be <code>exit(0)</code>, at which point the program exits and sets errorlevel to 0. Nothing else is executed, so no more runtime errors are reported.</p>

<p>You will notice that if you change <code>exit(0)</code> to something like <code>print "Hello world!"</code> you do get an error:</p>

<pre class="lang-none prettyprint-override"><code>Can't locate object method "Syntax" via package "error" ...
</code></pre>

<p>and your error level will be set:</p>

<pre><code>&gt; echo %errorlevel%
255
</code></pre>
<h4> Comment by TLP, Score: 16, Id: 46202080, created_at: 2015-03-10 22:47:50+00:00 </h4>@LiamLaverty Yes, it can. It can guess incorrectly what the human meant.<h4> Comment by Liam Laverty, Score: 7, Id: 46197690, created_at: 2015-03-10 20:15:10+00:00 </h4><code>&gt;The compiler will guess (incorrectly)</code>  The compiler can&#39;t do anything incorrectly.<h4> Comment by Liam Laverty, Score: 4, Id: 46202242, created_at: 2015-03-10 22:54:42+00:00 </h4>The human is the incorrect one in the equation. The compiler can only be &quot;correct&quot; or &quot;broken&quot;. It doesn&#39;t get an opinion on the definition of the language or a user&#39;s intention.<h4> Comment by TLP, Score: 4, Id: 46204686, created_at: 2015-03-11 01:01:27+00:00 </h4>@LiamLaverty It would be a pretty neat compiler if it could guess the user&#39;s intention in this case, yes. Hence, the compiler cannot guess correctly. You might be doing some technical jargon analysis of my statement, which is, I might add, the incorrect way to read it.<h4> Comment by Rikki, Score: 0, Id: 65951432, created_at: 2016-09-03 17:08:42+00:00 </h4>Isn&#39;t it an interpretater? ;-)<h4> Comment by TLP, Score: 0, Id: 65955211, created_at: 2016-09-03 20:46:55+00:00 </h4>@Rikki Possibly an interpreter. :P<hr><h3>  Answer by Mark Fowler, Id: 22840240, Score: 35, created_at: 2014-04-03 14:07:28+00:00 </h3><p>As noted above this is caused by the indirect method calling notation.  You can warn on this:</p>

<pre><code>use strict;
use warnings;
no indirect;

Syntax error!

exit 0;
</code></pre>

<p>Produces:</p>

<pre><code>Indirect call of method "Syntax" on object "error" at - line 5.
</code></pre>

<p>This requires the <a href="http://metacpan.org/module/indirect">indirect CPAN module</a>.</p>

<p>You can also use <code>no indirect "fatal";</code> to cause the program to die (this is what I do)</p>
<h4> Comment by Rsh, Score: 0, Id: 114353274, created_at: 2020-11-04 04:58:18+00:00 </h4>From Perl 5.32 onwards you can disable indirect feature and you longer need to add a CPAN module: <code>use v.5:32; no feature &#39;indirect&#39;;</code><hr><h3>  Answer by moritz, Id: 35233397, Score: 6, created_at: 2016-02-05 21:00:05+00:00 </h3><p>Try <a href="https://perl6.org/">Perl 6</a>, it seems to fulfill your expectations more readily:</p>

<pre><code>===SORRY!=== Error while compiling synerror.p6
Negation metaoperator not followed by valid infix
at synerror.p6:1
------&gt; Syntax error!⏏&lt;EOL&gt;
    expecting any of:
        infix
        infix stopper
</code></pre>
<hr><h3>  Answer by Holli, Id: 59600789, Score: 3, created_at: 2020-01-05 14:22:17+00:00 </h3><blockquote>
  <p>In this <a href="https://famicol.in/sigbovik/" rel="nofollow noreferrer">paper</a>, we aim to answer a long-standing open problem in the
  programming languages community: is it possible to smear paint on the
  wall without creating valid Perl?</p>
</blockquote>

<p>TLDR; Hardly</p>
