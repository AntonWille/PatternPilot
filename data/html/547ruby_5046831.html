 <h2> Title: Why use Ruby&#39;s attr_accessor, attr_reader and attr_writer? </h2> <h4> Saturn, question_id: 5046831 </h4>Score: 547, Tags: {ruby,attributes,attr-accessor} <br><p>Ruby has this handy and convenient way to share instance variables by using keys like</p>

<pre><code>attr_accessor :var
attr_reader :var
attr_writer :var
</code></pre>

<p>Why would I choose <code>attr_reader</code> or <code>attr_writer</code> if I could simply use <code>attr_accessor</code>? Is there something like performance (which I doubt)? I guess there is a reason, otherwise they wouldn't have made such keys.</p>
<h4> sschuberth, Id: 43297859 Score: 2: </h4>possible duplicate of <a href="http://stackoverflow.com/questions/4370960/what-is-attr-accessor-in-ruby">What is attr_accessor in Ruby?</a><br>------------------------------------------------------------------ <br><h3> Wayne Conrad, Id: 5046915, Score: 778: </h3><p>You may use the different accessors to communicate your intent to someone reading your code, and make it easier to write classes which will work correctly no matter how their public API is called.</p>

<pre><code>class Person
  attr_accessor :age
  ...
end
</code></pre>

<p>Here, I can see that I may both read and write the age.</p>

<pre><code>class Person
  attr_reader :age
  ...
end
</code></pre>

<p>Here, I can see that I may only read the age.  Imagine that it is set by the constructor of this class and after that remains constant.  If there were a mutator (writer) for age and the class were written assuming that age, once set, does not change, then a bug could result from code calling that mutator.</p>

<p>But what is happening behind the scenes?</p>

<p>If you write:</p>

<pre><code>attr_writer :age
</code></pre>

<p>That gets translated into:</p>

<pre><code>def age=(value)
  @age = value
end
</code></pre>

<p>If you write:</p>

<pre><code>attr_reader :age
</code></pre>

<p>That gets translated into:</p>

<pre><code>def age
  @age
end
</code></pre>

<p>If you write:</p>

<pre><code>attr_accessor :age
</code></pre>

<p>That gets translated into:</p>

<pre><code>def age=(value)
  @age = value
end

def age
  @age
end
</code></pre>

<p>Knowing that, here's another way to think about it: If you did not have the attr_... helpers, and had to write the accessors yourself, would you write any more accessors than your class needed?  For example, if age only needed to be read, would you also write a method allowing it to be written?</p>
<h4> Wayne Conrad, Comment 11178061 Score: 85: </h4>@Nitrodist, Interesting.  For Ruby 1.8.7, the <code>attr_reader</code> defined accesor takes 86% of the time that the manually defined accessor does.  For Ruby 1.9.0, the <code>attr_reader</code> defined accessor takes 94% of the time that the manually defined accessor does.  In all of my tests, however, accessors are fast: an accessor takes about 820 nanoseconds (Ruby 1.8.7) or 440 nanoseconds (Ruby 1.9).  At those speeds, you&#39;ll need to call an accessor hundreds of  millions of times for the performance benefit of <code>attr_accessor</code> to improve overall runtime by even one second.<br><h4> Nitrodist, Comment 11177486 Score: 59: </h4>There is also a <i>significant</i> performance advantage to writing <code>attr_reader :a</code> vs. <code>def a; return a; end</code> <a href="http://confreaks.net/videos/427-rubyconf2010-zomg-why-is-this-code-so-slow" rel="nofollow noreferrer">confreaks.net/videos/&hellip;</a><br><h4> mlibby, Comment 16209125 Score: 24: </h4>&quot;Presumably, it is set by the constructor of this class and remains constant.&quot; That is not accurate. Instance variables with readers might change frequently. However it is intended that their values only be changed privately by the class.<br><h4> Andrew_1510, Comment 32058701 Score: 12: </h4>You can use &quot;,&quot; to add more than 2 attributes, such as: <code>attr_accessor :a, :b</code><br><h4> molli, Comment 81534900 Score: 3: </h4>for what is worth after all these years: <a href="https://github.com/JuanitoFatas/fast-ruby#attr_accessor-vs-getter-and-setter-code" rel="nofollow noreferrer">github.com/JuanitoFatas/&hellip;</a> according to the latest benchmarks on ruby 2.2.0 attr_* are faster than getters and setters.<br><h4> Wayne Conrad, Comment 16209541 Score: 0: </h4>@mcl, Good point.  I favor functional idioms, which flavored the way I worded that paragraph.  I&#39;ve (hopefully) improved it.  Thanks!<br><h4> Deepender Singla, Comment 38100780 Score: 0: </h4>@WayneConrad The time difference is because attr_accessor use  class_eval( code ) which runs code on fly rather than creating method.<br><h4> Ben, Comment 41723934 Score: 0: </h4>Okay that&#39;s the point, but what could be a use case ? Things I don&#39;t getâ€¦ Apart showing how you&#39;d handle the attributes ?<br><h4> Wayne Conrad, Comment 41727373 Score: 0: </h4>@Ben I&#39;d like to improve the answer.  Can you please help me to understand what doesn&#39;t make sense?<br><h4> Ben, Comment 41753679 Score: 0: </h4>@WayneConrad finally got it; perfect answer. it was a bit too abstract for me at first.<br>------------------------------------------------------------------ <br><h3> hawx, Id: 5806371, Score: 28: </h3><p>All of the answers above are correct; <code>attr_reader</code> and <code>attr_writer</code> are more convenient to write than manually typing the methods they are shorthands for. Apart from that they offer much better performance than writing the method definition yourself. For more info see slide 152 onwards from <a href="http://www.slideshare.net/tenderlove/zomg-why-is-this-code-so-slow/152">this talk</a> (<a href="http://tenderlovemaking.com/RubyConf2010.pdf">PDF</a>) by Aaron Patterson.</p>
------------------------------------------------------------------ <br><h3> Korsmakolnikov, Id: 31189587, Score: 18: </h3><p>It is important to understand that accessors restrict access to variables, but not their content. In ruby, like in some other OO languages, every variable is a pointer to an instance. So if you have an attribute to an Hash, for example, and you set it to be &quot;read only&quot; you always could change its content, but not the content of pointer.
Look at this:</p>
<pre><code>&gt; class A
&gt;   attr_reader :a
&gt;   def initialize
&gt;     @a = {a:1, b:2}
&gt;   end
&gt; end
=&gt; :initialize
&gt; a = A.new
=&gt; #&lt;A:0x007ffc5a10fe88 @a={:a=&gt;1, :b=&gt;2}&gt;
&gt; a.a
=&gt; {:a=&gt;1, :b=&gt;2}
&gt; a.a.delete(:b)
=&gt; 2
&gt; a.a
=&gt; {:a=&gt;1}
&gt; a.a = {}
NoMethodError: undefined method `a=' for #&lt;A:0x007ffc5a10fe88 @a={:a=&gt;1}&gt;
        from (irb):34
        from /usr/local/bin/irb:11:in `&lt;main&gt;'
</code></pre>
<p>As you can see is possible delete a key/value pair from the Hash @a, as add new keys, change values, eccetera. But you can't point to a new object because is a read only instance variable.</p>
------------------------------------------------------------------ <br><h3> Chuck, Id: 5047256, Score: 17: </h3><p>Not all attributes of an object are meant to be directly set from outside the class. Having writers for all your instance variables is generally a sign of weak encapsulation and a warning that you're introducing too much coupling between your classes.</p>

<p>As a practical example: I wrote a design program where you put items inside containers. The item had <code>attr_reader :container</code>, but it didn't make sense to offer a writer, since the only time the item's container should change is when it's placed in a new one, which also requires positioning information.</p>
------------------------------------------------------------------ <br><h3> coreyward, Id: 5046907, Score: 14: </h3><p>You don't always want your instance variables to be fully accessible from outside of the class. There are plenty of cases where allowing read access to an instance variable makes sense, but writing to it might not (e.g. a model that retrieves data from a read-only source). There are cases where you want the opposite, but I can't think of any that aren't contrived off the top of my head.</p>
