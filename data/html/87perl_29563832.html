 <h2> Title: Why don&#39;t I get any syntax errors when I execute my Python script with Perl? </h2> <h3> Dacav, question_id: 29563832 </h3>Score: 87, Tags: {python,perl} <br><p>I just wrote some testing python code into <code>test.py</code>, and I'm launching it as follows:</p>

<pre><code>perl test.py
</code></pre>

<p>After a while I realized my mistake. I say "after a while", because the
Python code gets actually correctly executed, as if in Python interpreter!</p>

<p>Why is my Perl interpreting my Python? <code>test.py</code> looks like this:</p>

<pre><code>#!/usr/bin/python

...Python code here...
</code></pre>

<p>Interestingly, if I do the opposite (i.e. call <code>python something.pl</code>) I get a good deal of syntax errors.</p>
<h4> Comment 47277355 Sobrique: </h4>No. The point of the shebang path it to specify an interpreter. If you don&#39;t trust the code to run, then you shouldn&#39;t be running it in the first place.<br><h4> Comment 47277295 Dacav: </h4>I&#39;m guessing it&#39;s because of the <code>#!</code> in the beginning of the file. Indeed if I remove the she-bang, I&#39;m getting the expected behavior. Isn&#39;t that a bad idea from the security perspective, anyway?<br><h4> Comment 47289728 ikegami: </h4>&quot;Why is my Perl interpreting my Python?&quot; is not &quot;a problem that can no longer be reproduced or a simple typographical error.&quot; Voted to reopen. The upvotes on the Q and the A show this is a question of popular interest.<br><h4> Comment 47289945 ThisSuitIsBlackNot: </h4>@ikegami Regardless of popularity, this is clearly not &quot;a simple typographical error...resolved in a manner unlikely to help future readers.&quot; Voted to reopen.<br><h4> Comment 47277422 Sobrique: </h4>No, not really. Your script is a text file. No more, no less. It won&#39;t &#39;run&#39; without an interpreter.<br><h4> Comment 47277474 styts: </h4>All depends on the content of your file. The interpreter for each language will try to execute the code in the corresponding language.<br><h4> Comment 47277403 Dacav: </h4>@Sobrique, fair point... still there&#39;s something inherently odd here.<br><h4> Comment 47487247 Dacav: </h4>(I&#39;m a bit astonished on how much points I&#39;m getting for this question... I tought it was a dumb question to ask, and I should have read perlrun...)<br><h4> Comment 115985991 brian d foy: </h4>Perl.com explains it in detail in <a href="https://www.perl.com/article/bang-bang/" rel="nofollow noreferrer">Bang Bang</a>.<br>------------------------------------------------------------------ <br><h3> Answer 29563961 ikegami: </h3><p>From <a href="http://perldoc.perl.org/perlrun.html" rel="nofollow noreferrer">perlrun</a>,</p>

<blockquote>
  <p>If the <code>#!</code> line does not contain the word "perl" nor the word "indir" the program named after the <code>#!</code> is executed instead of the Perl interpreter. This is slightly bizarre, but it helps people on machines that don't do <code>#!</code> , because they can tell a program that their SHELL is <em>/usr/bin/perl</em>, and Perl will then dispatch the program to the correct interpreter for them.</p>
</blockquote>

<p>For example,</p>

<pre><code>$ cat a
#!/bin/cat
meow

$ perl a
#!/bin/cat
meow
</code></pre>
<h4> Comment 47279690 cjm: </h4>Wow.  Talk about your obscure features.  I&#39;ve been using Perl for more than 20 years, and I had no idea it did that.<br><h4> Comment 47282730 tjd: </h4>I started using Perl v4 on DOS, VMS &amp; Solaris.  It&#39;s OS agnostic/bridging features like this that made cross platform life so much easier.<br><h4> Comment 47458889 Barmar: </h4>This just cements Perl&#39;s reputation as the kitchen sink of programming languages. As an interesting observation, I believe the original implementation of shebang was as a shell feature, it only moved into the Unix kernel later. Perl includes many shell mechanism (e.g. backticks for substituting command output), this is just one more.<br><h4> Comment 47523015 Vadim Pushtaev: </h4><code>ruby</code> does the same &gt;.&lt;<br><h4> Comment 47300169 zxq9: </h4>@MarcvanLeeuwen When you write programs for Linux, OSX, VAX/VMS, Windows, Solaris, OS/2, and whatever else the most annoying part of porting a script-language program is getting it started, as many of these systems, though usually sharing the &quot;type a command, have it found &amp; executed&quot; feature in common, do nearly everything else differently. This Perl feature makes Perl an easy gap-bridge in functionality -- you can write <i>just</i> a Unix-style shebang and if Perl is present the code, whether Perl code or not, will <i>always</i> work -- its like a more universal <code>#! &#47;usr&#47;bin&#47;env foo</code>.<br><h4> Comment 47319839 ThisSuitIsBlackNot: </h4>@immibis From the thread <a href="https://groups.google.com/forum/m/#!topic/perl.perl5.porters/UlKtqq6q0JA" rel="nofollow noreferrer">Shebang line parsing mystery</a> on the perl5-porters mailing list: &quot;<code>indir</code> was a program designed to indirectly execute other programs.  My recollection is that it was supposed to be particularly useful in setuid situations where the OS didn&#39;t natively provide you much help, and/or perhaps in situations where the OS kernel limited you to 32 character command lines.&quot;<br><h4> Comment 47297538 Marc van Leeuwen: </h4>I find the documentation rather bizarre in itself. Why the hell would &quot;on machines that don&#39;t do <code>#!</code>&quot; there be scripts that start with <code>#!</code> in the first place? I don&#39;t think having <code>&#47;usr&#47;bin&#47;perl</code> (and I would doubt that on mentioned machines it would actually be that path) as you <code>SHELL</code> would be any fun.<br><h4> Comment 47418208 Maurice Reeves: </h4>GG Perl knows you didn&#39;t mean to invoke perl and sends the work to the right executable anyway.  What a swell guy!<br>