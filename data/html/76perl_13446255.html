 <h2> Title: how to remove the first two columns in a file using shell (awk, sed, whatever) </h2> <h3> wenzi, question_id: 13446255 </h3>Score: 76, Tags: {perl,shell,awk,sed,cut} <br><p>I have a file with many lines
in each line there are many columns(fields) separated by blank " "
the numbers of columns in each line are different
I want to remove the first two columns
how to?</p>
<h4> Comment 95156920 Ciro Santilli OurBigBook.com: </h4>Possible duplicate of <a href="https://stackoverflow.com/questions/2961635/using-awk-to-print-all-columns-from-the-nth-to-the-last">Using awk to print all columns from the nth to the last</a><br>------------------------------------------------------------------ <br><h3> Answer 13446273 sampson-chen: </h3><p>You can do it with <code>cut</code>:</p>

<pre><code>cut -d " " -f 3- input_filename &gt; output_filename
</code></pre>

<p><strong>Explanation:</strong></p>

<ul>
<li><code>cut</code>: invoke the cut command</li>
<li><code>-d " "</code>: use a single space as the delimiter (<code>cut</code> uses TAB by default)</li>
<li><code>-f</code>: specify fields to keep</li>
<li><code>3-</code>: all the fields starting with field 3</li>
<li><code>input_filename</code>: use this file as the input</li>
<li><code>&gt; output_filename</code>: write the output to this file.</li>
</ul>

<p>Alternatively, you can do it with <code>awk</code>:</p>

<pre><code>awk '{$1=""; $2=""; sub("  ", " "); print}' input_filename &gt; output_filename
</code></pre>

<p><strong>Explanation:</strong></p>

<ul>
<li><code>awk</code>: invoke the awk command</li>
<li><code>$1=""; $2="";</code>: set field 1 and 2 to the empty string</li>
<li><code>sub(...);</code>: clean up the output fields because fields 1 &amp; 2 will still be delimited by " "</li>
<li><code>print</code>: print the modified line</li>
<li><code>input_filename &gt; output_filename</code>: same as above.</li>
</ul>
<h4> Comment 18385651 sampson-chen: </h4>@wenzi oops, forgot that <code>cut</code> uses tab as delimiter by default. See updated answer - just tested and it works. all else being equal, I would recommend using <code>cut</code> over <code>awk</code>.<br><h4> Comment 18400673 Ed Morton: </h4>You could do it in awk with just <code>awk &#39;{sub(&#47;([^ ]+ ){2}&#47;, &quot;&quot;)}1&#39;</code>. I agree cut is the better choice anyway if you have a single-char field separator though.<br><h4> Comment 83313830 jirislav: </h4>there are still some whitespaces left, use <code>awk &#39;{$1=&quot;&quot;; $2=&quot;&quot;; sub(&#47;^ +&#47;, &quot;&quot;); print}&#39;</code> instead or shorter <code>awk &#39;{$1=$2=&quot;&quot;; sub(&#47;^ +&#47;, &quot;&quot;)}1&#39;</code><br><h4> Comment 130838716 Brian Peterson: </h4>Thanks for explaining the individual flags, didn&#39;t realize you could specify &quot;3-&quot; to mean &quot;3 onwards&quot;.<br>------------------------------------------------------------------ <br><h3> Answer 14715189 raychi: </h3><p>Here's one way to do it with Awk that's relatively easy to understand:</p>

<pre><code>awk '{print substr($0, index($0, $3))}'
</code></pre>

<p>This is a simple awk command with no pattern, so action inside <code>{}</code> is run for every input line. </p>

<p>The action is to simply prints the substring starting with the position of the 3rd field.</p>

<ul>
<li><code>$0</code>: the whole input line</li>
<li><code>$3</code>: 3rd field</li>
<li><code>index(in, find)</code>: returns the position of <code>find</code> in string <code>in</code></li>
<li><code>substr(string, start)</code>: return a substring starting at index <code>start</code></li>
</ul>

<p>If you want to use a different delimiter, such as comma, you can specify it with the -F option:</p>

<pre><code>awk -F"," '{print substr($0, index($0, $3))}'
</code></pre>

<p>You can also operate this on a subset of the input lines by specifying a pattern before the action in <code>{}</code>. Only lines matching the pattern will have the action run.</p>

<pre><code>awk 'pattern{print substr($0, index($0, $3))}'
</code></pre>

<p>Where pattern can be something such as:</p>

<ul>
<li><code>/abcdef/</code>: use regular expression, operates on $0 by default.</li>
<li><code>$1 ~ /abcdef/</code>: operate on a specific field.</li>
<li><code>$1 == blabla</code>: use string comparison</li>
<li><code>NR &gt; 1</code>: use record/line number</li>
<li><code>NF &gt; 0</code>: use field/column number</li>
</ul>
<h4> Comment 37750467 CMCDragonkai: </h4>How about removing the last 2 column, counting from the reverse?<br><h4> Comment 53179673 PHP Learner: </h4>This will not work correctly if field #2 and field #3 has same contents.<br>------------------------------------------------------------------ <br><h3> Answer 24601841 Felipe Alvarez: </h3><p>Thanks for posting the question. I'd also like to add the script that helped me.</p>

<pre><code>awk '{ $1=""; print $0 }' file
</code></pre>
<h4> Comment 43239651 timurb: </h4>Awk doesn&#39;t keep field delimiters in this case.<br><h4> Comment 113742887 MichaelChirico: </h4>You can add <code>OFS=FS</code> to keep the delimiters:<a href="https://unix.stackexchange.com/a/252748/112834">unix.stackexchange.com/a/252748/112834</a><br>------------------------------------------------------------------ <br><h3> Answer 13446583 Jonathan Leffler: </h3><p>You can use <code>sed</code>:</p>

<pre><code>sed 's/^[^ ][^ ]* [^ ][^ ]* //'
</code></pre>

<p>This looks for lines starting with one-or-more non-blanks, a blank, another set of one-or-more non-blanks and another blank, and deletes the matched material, aka the first two fields.  The <code>[^ ][^ ]*</code> is marginally shorter than the equivalent but more explicit <code>[^ ]\{1,\}</code> notation, and the second might run into issues with GNU <code>sed</code> (though if you use <code>--posix</code> as an option, even GNU <code>sed</code> can't screw it up).  OTOH, if the character class to be repeated was more complex, the numbered notation wins for brevity.  It is easy to extend this to handle 'blank or tab' as separator, or 'multiple blanks' or 'multiple blanks or tabs'.  It could also be modified to handle optional leading blanks (or tabs) before the first field, etc.</p>

<p>For <code>awk</code> and <code>cut</code>, see <a href="https://stackoverflow.com/users/1741864/sampson-chen">Sampson-Chen</a>'s <a href="https://stackoverflow.com/a/13446273/15168">answer</a>.  There are other ways to write the <code>awk</code> script, but they're not materially better than the answer given.  Note that you might need to set the field separator explicitly (<code>-F" "</code>) in <code>awk</code> if you do not want tabs treated as separators, or you might have multiple blanks between fields.  The POSIX standard <code>cut</code> does not support multiple separators between fields; GNU <code>cut</code> has the useful but non-standard <code>-i</code> option to allow for multiple separators between fields.</p>

<p>You can also do it in pure shell:</p>

<pre><code>while read junk1 junk2 residue
do echo "$residue"
done &lt; in-file &gt; out-file
</code></pre>
<h4> Comment 18387778 Ed Morton: </h4>If <code>residue</code> can contain a backslash, the above read will interpret it and not reproduce it in the output. Always use <code>while IFS= read -r ...</code>.<br><h4> Comment 18387811 Jonathan Leffler: </h4>If <code>bash</code> interprets the contents with a plain <code>read</code>, then <code>bash</code> is broken (again).  The read command in original shells didn&#39;t do such nonsense; I don&#39;t believe it is required by POSIX shell.  It would irritate the blazes out of me to find that <code>bash</code> does what you say it does â€” I already have a love/hate relation with the program since it does a lot of things well, but there are some things that it does badly, and changing legacy behaviour is one of the worst, and requiring an option to enable the old standard behaviour is ... very irritating.  It seems you&#39;re right; <code>bash</code> is borked!<br><h4> Comment 18400298 Ed Morton: </h4>That behavior is POSIX, see <a href="http://pubs.opengroup.org/onlinepubs/9699919799/utilities/read.html" rel="nofollow noreferrer">pubs.opengroup.org/onlinepubs/9699919799/utilities/read.html</a>&zwnj;&#8203;.<br><h4> Comment 18400763 Ed Morton: </h4>I see I didn&#39;t say it explicitly but the reason you need IFS= is that if the first field in the input was empty, then default field splitting would strip leading blanks so <code>residue</code> would start at field 4 (or later) instead of field 3.<br><h4> Comment 18402548 Jonathan Leffler: </h4>Damn...OK; POSIX is borked, but <code>bash</code> is following POSIX 2008.  I&#39;ve never wanted that functionality in more than a quarter century of shell programming, but I guess I must be in a minority.<br>------------------------------------------------------------------ <br><h3> Answer 24602199 technosaurus: </h3><p>Its pretty straight forward to do it with only shell</p>

<pre><code>while read A B C; do
echo "$C"
done &lt; oldfile &gt;newfile
</code></pre>
<h4> Comment 82565600 robert: </h4>This is a great answer, however you will want to use <code>read -r</code> instead of <code>read</code>.<br><h4> Comment 82565636 robert: </h4><code>read -r</code> will preserve backslashes. <code>read</code> will not. For example: <code>echo &quot;foo ba\r&quot;</code> will produce an output of <code>foo ba\r</code>. However, <code>echo &quot;foo ba\r&quot; |  (while read first_column second_column; do echo &quot;$second_column&quot;; done)</code> will produce just <code>bar</code> as the output (with the backslash removed. Adding the <code>-r</code> flag produces the correct output of <code>ba\r</code><br>------------------------------------------------------------------ <br><h3> Answer 27397206 Vijay: </h3><p>perl:</p>

<pre><code>perl -lane 'print join(' ',@F[2..$#F])' File
</code></pre>

<p>awk:</p>

<pre><code>awk '{$1=$2=""}1' File
</code></pre>
------------------------------------------------------------------ <br><h3> Answer 47912906 Carlos: </h3><p>Using awk, and based in some of the options below, using a for loop makes a bit more flexible; sometimes I may want to delete the first 9 columns ( if I do an "ls -lrt" for example), so I change the 2 for a 9 and that's it:</p>

<p><code>awk '{ for(i=0;i++&lt;2;){$i=""}; print $0 }' your_file.txt</code></p>
------------------------------------------------------------------ <br><h3> Answer 13449192 potong: </h3><p>This might work for you (GNU sed):</p>

<pre><code>sed -r 's/^([^ ]+ ){2}//' file
</code></pre>

<p>or for columns separated by one or more white spaces:</p>

<pre><code>sed -r 's/^(\S+\s+){2}//' file
</code></pre>
------------------------------------------------------------------ <br><h3> Answer 43933171 Holger Brandl: </h3><p>Use <a href="https://github.com/holgerbrandl/kscript" rel="nofollow noreferrer">kscript</a></p>

<pre><code>kscript 'lines.split().select(-1,-2).print()' file
</code></pre>
