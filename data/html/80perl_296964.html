 <h2> Title: What does shift() do in Perl? </h2> <h4> cam, question_id: 296964, created_at: 2008-11-17 21:16:35+00:00 </h4>Score: 80, Tags: {perl,built-in} <br><p>What could the following line possibly mean?</p>

<pre><code>my $x = shift;
</code></pre>
<h4> Comment by cowgod, Score: 43, Id: 143725, created_at: 2008-11-17 21:29:05+00:00 </h4>It doesn&#39;t matter if he Googled it or not.  It&#39;s a great question and should definitely be a part of the Stack Overflow database.<h4> Comment by Sherm Pendley, Score: 7, Id: 145532, created_at: 2008-11-18 18:34:14+00:00 </h4>@friedo - Agreed 100%! This should not become a &quot;read the docs to me&quot; site.<h4> Comment by user166390, Score: 2, Id: 11114649, created_at: 2012-01-17 04:36:18+00:00 </h4><code>perldoc -f shift</code> contains useful information from &quot;perlfunc&quot;. See <a href="http://perldoc.perl.org/perlfunc.html" rel="nofollow noreferrer">perfun</a>, or even <a href="http://perldoc.perl.org/functions/shift.html" rel="nofollow noreferrer">perlfun: shift()</a>. None of the answers do a real good job of linking/pulling from documentation. So, &quot;RTFM&quot; or not, a reference should be included.<h4> Comment by Sherm Pendley, Score: 2, Id: 20569688, created_at: 2008-11-17 21:27:18+00:00 </h4>Perl has built-in docs for every standard function. They&#39;re also online. In this case, &quot;<a href="http://perldoc.perl.org/functions/shift.html" rel="nofollow noreferrer">perldoc -f shift</a>.&quot;<hr><h3>  Answer by cowgod, Id: 297003, Score: 68, created_at: 2008-11-17 21:27:25+00:00 </h3><p><code>shift()</code> is a built in Perl subroutine that takes an array as an argument, then returns and deletes the first item in that array.  It is common practice to obtain all parameters passed into a subroutine with <code>shift</code> calls.  For example, say you have a subroutine <code>foo</code> that takes three arguments.  One way to get these parameters assigned to local variables is with <code>shift</code> like so:</p>

<pre><code>sub foo() {
  my $x = shift;
  my $y = shift;
  my $z = shift;
  # do something
}
</code></pre>

<p>The confusion here is that it appears shift is not being passed an array as an argument.  In fact, it is being passed the "default" array implicitly, which is <code>@_</code> inside a subroutine or <code>@ARGV</code> outside a subroutine.</p>
<h4> Comment by Brad Gilbert, Score: 5, Id: 6101715, created_at: 2011-03-22 17:43:14+00:00 </h4>I prefer to use <code>sub foo{ my($x,$y,$z) = @_ }</code> myself, it is less repetitive.<h4> Comment by EvdB, Score: 1, Id: 149803, created_at: 2008-11-20 15:09:03+00:00 </h4>you don&#39;t want the &#39;()&#39; after the name of the sub - it should be &#39;sub foo {...&#39;. With the &#39;()&#39; you are saying that foo accepts no arguments, which is not what you want in this case<h4> Comment by Alnitak, Score: 0, Id: 143726, created_at: 2008-11-17 21:31:16+00:00 </h4>or @ARGV, if you&#39;re not in a function (see my answer)<hr><h3>  Answer by Alnitak, Id: 296991, Score: 15, created_at: 2008-11-17 21:24:21+00:00 </h3><p>The <code>shift</code> function removes the first element from an array, and returns it.  The array is shortened by one element.</p>

<p>The default array (if one isn't given as a parameter) is <code>@_</code> if you're in a function, or <code>@ARGV</code> if you're at file scope.</p>

<p>So in this case <code>$x</code> is either being set to the first function parameter, or to the first command line parameter.</p>
<h4> Comment by Svante, Score: 7, Id: 143899, created_at: 2008-11-17 22:49:17+00:00 </h4>It should be added that @_ is the array containing the parameters given to a function, and @ARGV is the array containing the parameters given to a program.<hr><h3>  Answer by Gaurav, Id: 297919, Score: 10, created_at: 2008-11-18 05:25:47+00:00 </h3><p>In Perl, many methods use the default variables (<code>$_</code> and <code>@_</code>) if you don't explicitly specify arguments. Your code is identical to:</p>

<pre><code>my $x = shift @_;
</code></pre>

<p>As pointed out by PullMonkey earlier, within a subroutine, <code>@_</code> contains the arguments passed to that subroutine (as described in <a href="http://perldoc.perl.org/perlsub.html#DESCRIPTION" rel="noreferrer"><code>perlsub</code></a>). <code>shift</code> will remove the first argument value from <code>@_</code> and store it in <code>$x</code>, so <code>$_[0]</code> will now give you the <strong>second</strong> argument passed to your subroutine.</p>
<hr><h3>  Answer by David Nehme, Id: 296969, Score: 3, created_at: 2008-11-17 21:17:57+00:00 </h3><p>This is usually an idiom for: $x is a local variable assigned to the first parameter passed to the subroutine, although.</p>

<pre><code>my ($x) = @_;
</code></pre>

<p>is probably clearer (and it doesn't modify the argument list).</p>
<hr><h3>  Answer by mhd, Id: 307689, Score: 3, created_at: 2008-11-21 02:59:19+00:00 </h3><p>In layman's terms, from a very highlevel view, <em><a href="https://perldoc.perl.org/perlfunc.html#shift-ARRAY" rel="nofollow noreferrer">shift</a></em> is taking the first element of an array (the leftmost part), while the opposite is <em><a href="https://perldoc.perl.org/perlfunc.html#pop-ARRAY" rel="nofollow noreferrer">pop</a></em> which is taking the last element of array (the rightmost part).</p>

<pre>
my @array1=(5,6,7,8,9);
my $x = shift @array1;
print "$x\n"; # 5
print "@array1\n"; # 6 7 8 9
</pre>
<hr><h3>  Answer by PullMonkey, Id: 296995, Score: 1, created_at: 2008-11-17 21:25:40+00:00 </h3><p>If you are in a subroutine this line will <code>shift</code> on <code>@_</code> (the params that are passed in).<br>
So <code>$x</code> would be the first item <code>popped</code> from the <code>@_</code> array.</p>

<p>So usually you would see <code>$x = shift if @_;</code></p>
<h4> Comment by Dave Sherohman, Score: 2, Id: 144178, created_at: 2008-11-18 02:02:05+00:00 </h4>No real need for the if.  &quot;my $x = shift;&quot; and &quot;my $x; $x = shift if @_;&quot; are equivalent and will both result in $x being undef if @_ is empty, nor will either violate strict or emit a warning.  The only difference is the amount of typing you have to do.<hr><h3>  Answer by U. Windl, Id: 72054829, Score: -1, created_at: 2022-04-29 08:16:19+00:00 </h3><p>Do you still have questions after reading the output of <code>perldoc -f shift</code>?</p>
<p>(That is not a question; it is an answer ;-))</p>
<p>Another recommended reading is <code>man perlbook</code>.</p>
<p>Perl &quot;shifts off&quot; the first element from <code>@_</code>, returning it.
So <code>$x</code> is assigned to the first element of <code>@_</code> after removing it from there.
<code>@_</code> itself are the routine parameters.</p>
<p>So these three are common alternatives (not the very same, however):</p>
<pre class="lang-perl prettyprint-override"><code>my $a = shift;
my $b = shift;
my $c = shift;
</code></pre>
<pre class="lang-perl prettyprint-override"><code>my ($a, $b, $c) = @_;
</code></pre>
<pre class="lang-perl prettyprint-override"><code>my $a = $_[0];
my $b = $_[1];
my $c = $_[2];
</code></pre>
<p>Only the first variant modifies <code>@_</code>.</p>
