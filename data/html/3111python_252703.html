 <h2> Title: What is the difference between Python&#39;s list methods append and extend? </h2> <h4> Claudiu, question_id: 252703 </h4>Score: 3111, Tags: {python,list,data-structures,append,extend} <br><p>What's the difference between the list methods <code>append()</code> and <code>extend()</code>?</p>
------------------------------------------------------------------ <br><h3> Greg Hewgill, Id: 252704, Score: 138: </h3><p><code>append</code> appends a single element. <code>extend</code> appends a list of elements.</p>

<p>Note that if you pass a list to append, it still adds one element:</p>

<pre><code>&gt;&gt;&gt; a = [1, 2, 3]
&gt;&gt;&gt; a.append([4, 5, 6])
&gt;&gt;&gt; a
[1, 2, 3, [4, 5, 6]]
</code></pre>
------------------------------------------------------------------ <br><h3> kender, Id: 252711, Score: 5856: </h3><p><a href="https://docs.python.org/3/library/stdtypes.html#mutable-sequence-types" rel="noreferrer"><code>.append()</code></a> appends a specified object at the end of the list:</p>
<pre><code>&gt;&gt;&gt; x = [1, 2, 3]
&gt;&gt;&gt; x.append([4, 5])
&gt;&gt;&gt; print(x)
[1, 2, 3, [4, 5]]
</code></pre>
<p><a href="https://docs.python.org/3/library/stdtypes.html#mutable-sequence-types" rel="noreferrer"><code>.extend()</code></a> extends the list by appending elements from the specified iterable:</p>
<pre><code>&gt;&gt;&gt; x = [1, 2, 3]
&gt;&gt;&gt; x.extend([4, 5])
&gt;&gt;&gt; print(x)
[1, 2, 3, 4, 5]
</code></pre>
<h4> Russia Must Remove Putin, Comment 77269150 Score: 410: </h4>Actually there&#39;s a <b><i>big difference</i></b> - <code>x + [4, 5]</code> gives you a new list assigned to x - <code>x.extend()</code> mutates the original list. I elaborate in my answer here below.<br><h4> Rohan, Comment 75510248 Score: 171: </h4>What is the difference between <code>extend</code> and simply using the addition operator - in the above example, <code>x = x + [4, 5]</code>?<br><h4> Astitva Srivastava, Comment 94380769 Score: 10: </h4>@AaronHall @Rohan but it is same as <code>x += [4,5]</code>.<br><h4> Anthony, Comment 97108479 Score: 2: </h4>The keyword when using <code>append</code> is <b>Object</b>. If you try to use <code>extend</code> and you pass in a <b>dictionary</b>, it will append the <b>key</b>, and not the whole hash to the end of the array.<br><h4> mcagriardic, Comment 111475552 Score: 2: </h4>@Rohan, the time complexity of x = x + [4, 5] would be O(len(x) + len([4,5])) where as extend has the time complexity of O(len([4, 5]))<br><h4> C-3PO, Comment 131555040 Score: 0: </h4><code>x += [4,5]</code> is the same as <code>extend</code>, and <code>x += [[4,5]]</code> behaves like <code>append</code>.<br><h4> Willem van Houten, Comment 132380088 Score: 0: </h4>Is there a benefit of .append above += ?  To clarify, I have some code that usually appends a single element to a given list, but occasionaly extends with a list.  For the sake of brevity, I consider putting both operations in a single function, inventory += item. Any arguments against that?<br>------------------------------------------------------------------ <br><h3> Harley Holcombe, Id: 252705, Score: 738: </h3><p><code>.append()</code> adds an element to a list,<br />
whereas <code>.extend()</code> concatenates the first list with another list/iterable.</p>
<pre><code>&gt;&gt;&gt; xs = ['A', 'B']
&gt;&gt;&gt; xs
['A', 'B']

&gt;&gt;&gt; xs.append(&quot;D&quot;)
&gt;&gt;&gt; xs
['A', 'B', 'D']

&gt;&gt;&gt; xs.append([&quot;E&quot;, &quot;F&quot;])
&gt;&gt;&gt; xs
['A', 'B', 'D', ['E', 'F']]

&gt;&gt;&gt; xs.insert(2, &quot;C&quot;)
&gt;&gt;&gt; xs
['A', 'B', 'C', 'D', ['E', 'F']]

&gt;&gt;&gt; xs.extend([&quot;G&quot;, &quot;H&quot;])
&gt;&gt;&gt; xs
['A', 'B', 'C', 'D', ['E', 'F'], 'G', 'H']
</code></pre>
------------------------------------------------------------------ <br><h3> Russia Must Remove Putin, Id: 28119966, Score: 658: </h3><blockquote>
<h2>What is the difference between the list methods append and extend?</h2>
</blockquote>
<ul>
<li><code>.append()</code> adds its argument as a single element to the end of a list. The length of the list itself will increase by one.</li>
<li><code>.extend()</code> iterates over its argument adding each element to the list, extending the list. The length of the list will increase by however many elements were in the iterable argument.</li>
</ul>
<h2><code>.append()</code></h2>
<p>The <code>.append()</code> method appends an object to the end of the list.</p>
<pre><code>my_list.append(object) 
</code></pre>
<p>Whatever the object is, whether a number, a string, another list, or something else, it gets added onto the end of <code>my_list</code> as a single entry on the list.</p>
<pre><code>&gt;&gt;&gt; my_list
['foo', 'bar']
&gt;&gt;&gt; my_list.append('baz')
&gt;&gt;&gt; my_list
['foo', 'bar', 'baz']
</code></pre>
<p>So keep in mind that a list is an object. If you append another list onto a list, the first list will be a single object at the end of the list (which may not be what you want):</p>
<pre><code>&gt;&gt;&gt; another_list = [1, 2, 3]
&gt;&gt;&gt; my_list.append(another_list)
&gt;&gt;&gt; my_list
['foo', 'bar', 'baz', [1, 2, 3]]
                     #^^^^^^^^^--- single item at the end of the list.
</code></pre>
<h2><code>.extend()</code></h2>
<p>The <code>.extend()</code> method extends a list by appending elements from an iterable:</p>
<pre><code>my_list.extend(iterable)
</code></pre>
<p>So with extend, each element of the iterable gets appended onto the list. For example:</p>
<pre><code>&gt;&gt;&gt; my_list
['foo', 'bar']
&gt;&gt;&gt; another_list = [1, 2, 3]
&gt;&gt;&gt; my_list.extend(another_list)
&gt;&gt;&gt; my_list
['foo', 'bar', 1, 2, 3]
</code></pre>
<p>Keep in mind that a string is an iterable, so if you extend a list with a string, you'll append each character as you iterate over the string (which may not be what you want):</p>
<pre><code>&gt;&gt;&gt; my_list.extend('baz')
&gt;&gt;&gt; my_list
['foo', 'bar', 1, 2, 3, 'b', 'a', 'z']
</code></pre>
<h2>Operator Overload, <code>__add__</code> (<code>+</code>) and <code>__iadd__</code> (<code>+=</code>)</h2>
<p>Both <code>+</code> and <code>+=</code> operators are defined for <code>list</code>. They are semantically similar to extend.</p>
<p><code>my_list + another_list</code> creates a third list in memory, so you can return the result of it, but it requires that the second iterable be a list.</p>
<p><code>my_list += another_list</code> modifies the list in-place (it <em>is</em> the in-place operator, and lists are mutable objects, as we've seen) so it does not create a new list. It also works like extend, in that the second iterable can be any kind of iterable.</p>
<p>Don't get confused - <code>my_list = my_list + another_list</code> is not equivalent to <code>+=</code> - it gives you a brand new list assigned to my_list.</p>
<h2>Time Complexity</h2>
<p>Append has (<a href="https://stackoverflow.com/a/33045038/541136">amortized</a>) <a href="https://wiki.python.org/moin/TimeComplexity" rel="noreferrer">constant time complexity</a>, O(1).</p>
<p>Extend has time complexity, O(k).</p>
<p>Iterating through the multiple calls to <code>.append()</code> adds to the complexity, making it equivalent to that of extend, and since extend's iteration is implemented in C, it will always be faster if you intend to append successive items from an iterable onto a list.</p>
<p>Regarding &quot;amortized&quot; - from the <a href="https://github.com/python/cpython/blob/3.9/Objects/listobject.c#L52" rel="noreferrer">list object implementation source</a>:</p>
<pre class="lang-none prettyprint-override"><code>    /* This over-allocates proportional to the list size, making room
     * for additional growth.  The over-allocation is mild, but is
     * enough to give linear-time amortized behavior over a long
     * sequence of appends() in the presence of a poorly-performing
     * system realloc().
</code></pre>
<p>This means that we get the benefits of a larger than needed memory reallocation up front, but we may pay for it on the next marginal reallocation with an even larger one. Total time for all appends is linear at O(n), and that time allocated per append, becomes O(1).</p>
<h2>Performance</h2>
<p>You may wonder what is more performant, since append can be used to achieve the same outcome as extend. The following functions do the same thing:</p>
<pre><code>def append(alist, iterable):
    for item in iterable:
        alist.append(item)
        
def extend(alist, iterable):
    alist.extend(iterable)
</code></pre>
<p>So let's time them:</p>
<pre><code>import timeit

&gt;&gt;&gt; min(timeit.repeat(lambda: append([], &quot;abcdefghijklmnopqrstuvwxyz&quot;)))
2.867846965789795
&gt;&gt;&gt; min(timeit.repeat(lambda: extend([], &quot;abcdefghijklmnopqrstuvwxyz&quot;)))
0.8060121536254883
</code></pre>
<h3>Addressing a comment on timings</h3>
<p>A commenter said:</p>
<blockquote>
<p>Perfect answer, I just miss the timing of comparing adding only one element</p>
</blockquote>
<p>Do the semantically correct thing. If you want to append all elements in an iterable, use <code>.extend()</code>. If you're just adding one element, use <code>.append()</code>.</p>
<p>Ok, so let's create an experiment to see how this works out in time:</p>
<pre><code>def append_one(a_list, element):
    a_list.append(element)

def extend_one(a_list, element):
    &quot;&quot;&quot;creating a new list is semantically the most direct
    way to create an iterable to give to extend&quot;&quot;&quot;
    a_list.extend([element])

import timeit
</code></pre>
<p>And we see that going out of our way to create an iterable just to use extend is a (minor) waste of time:</p>
<pre><code>&gt;&gt;&gt; min(timeit.repeat(lambda: append_one([], 0)))
0.2082819009956438
&gt;&gt;&gt; min(timeit.repeat(lambda: extend_one([], 0)))
0.2397019260097295
</code></pre>
<p>We learn from this that there's nothing gained from using <code>.extend()</code> when we have only <em>one</em> element to append.</p>
<p>Also, these timings are not that important. I am just showing them to make the point that, in Python, doing the semantically correct thing is doing things the <em>Right</em> Way™.</p>
<p>It's conceivable that you might test timings on two comparable operations and get an ambiguous or inverse result. Just focus on doing the semantically correct thing.</p>
<h2>Conclusion</h2>
<p>We see that <code>.extend()</code> is semantically clearer, and that it can run much faster than <code>.append()</code>, <em>when you intend to append each element in an iterable to a list.</em></p>
<p>If you only have a single element (not in an iterable) to add to the list, use <code>.append()</code>.</p>
<h4> Jean-Francois T., Comment 86962262 Score: 22: </h4>Perfect answer indeed. What about performance of <code>l1 += l2</code> vs <code>l1.extend(l2)</code>?<br><h4> ShadowRanger, Comment 90754266 Score: 12: </h4>@Jean-FrancoisT.: <code>l1 += l2</code> and <code>l1.extend(l2)</code> ultimately execute the same code (the <code>list_extend</code> function in <code>listobject.c</code>). The only differences are: 1. <code>+=</code> reassigns <code>l1</code> (to itself for <code>list</code>s, but the reassignment supports immutable types that aren&#39;t the same object after), which makes it illegal if <code>l1</code> is actually an attribute of an immutable object; for example, <code>t = ([],)</code>, <code>t[0] += lst</code> would fail, while <code>t[0].extend(lst)</code> would work. 2. <code>l1 += l2</code> uses dedicated bytecodes, while <code>l1.extend(l2)</code> uses generalized method dispatch; this makes <code>+=</code> faster than <code>extend</code>.<br><h4> ShadowRanger, Comment 90754463 Score: 4: </h4>The fact that <code>+=</code> must reassign <code>l1</code> does mean that in some cases, the slower dispatch of <code>extend</code> is partially or wholly made up for by not assigning back to the left hand side. For example, if the <code>list</code> is an attribute of an object, <code>self.l1 += l2</code> and <code>self.l1.extend(l2)</code> have identical performance on my Python 3.6 install, simply because real operation is more like <code>self.l1 = self.l1.__iadd__(l2)</code>, which means it must perform a moderately expensive <code>STORE_ATTR</code> that <code>self.l1.extend(l2)</code> doesn&#39;t have to.<br><h4> ShadowRanger, Comment 90754732 Score: 3: </h4>Simple comparison in local tests: For a local variable (so the <code>+=</code> is just using <code>STORE_FAST</code>, which is super cheap), where the value being added is an existing <code>list</code> with one item in it, with the operation repeated 1000 times, <code>+=</code> took about 33 ns on average, while <code>extend</code> took 78 ns, a difference of 45 ns. If <code>l1</code> is a global (requires more expensive <code>STORE_GLOBAL</code>), the difference narrows to 17 ns. If <code>l1</code> is actually <code>local.l1</code> (requires even more expensive <code>STORE_ATTR</code>), there is no meaningful difference between <code>+=</code> and <code>extend</code> (timings roughly identical; <code>extend</code> sometimes wins).<br><h4> ilias iliadis, Comment 86189418 Score: 1: </h4>@Aaron Hall One small comment in algorithm for timing. &quot;extend_one&quot; may return &quot;slightly wrong&quot; time because the creation of a list is also involved. Probably better is to create the items as variables (<code>ex1 = 0</code> and <code>ex2 = [0]</code>) and pass these variables, if you want to be more strict.<br><h4> Russia Must Remove Putin, Comment 118576708 Score: 1: </h4>@Daniel I added some information to that section - which should lead you to more relevant information if you&#39;re interested.<br><h4> ShadowRanger, Comment 123463488 Score: 1: </h4>@zk82: Yep. It completes the whole operation, then fails on the reassignment. Probably best to avoid it; I&#39;d be forced to tar and feather anyone who actually used <code>+=</code> like that and just used a <code>try:</code>/<code>except TypeError: pass</code> to silence the exception. :-)<br><h4> Daniel, Comment 118569300 Score: 0: </h4>@Aaron Hall you said that <code>append</code> for <code>array a</code> takes O(1) time but what about the creation of a new array with size <code>sizeof(a)+1</code> with the desired values? (first items as in a and the last new item). I am really asking because I don&#39;t know how it works in python<br><h4> Tony Suffolk 66, Comment 110682424 Score: 0: </h4>@tparker - if you have another name (foo) bound to my_list (say you are inside a function) then using += doesn&#39;t rebind my_list to a new object and therefore foo and my_list are still the same list. doing the explicit + and assignment (i.e. not using +=) means the RHS is a new list, and the name my_list is rebound, meaning that my_list and foo are no longer bound to the same object.<br><h4> zk82, Comment 123449628 Score: 0: </h4>A bit weird, &quot;l1[0] += l2&quot; fails but it extends the list, indeed (at least in my Python version) @ShadowRanger &gt;&gt;&gt; try: ...   l1 = ([], ) ...   l1[0] += range(3) ... except TypeError: ...   print(&#39;Exception got, but l1 is:&#39;, l1) ... Exception got, but l1 is: ([0, 1, 2],)<br><h4> tparker, Comment 94645109 Score: 0: </h4>Could you clarify the difference in behavior between <code>my_list = my_list + another_list</code> and <code>my_list += another_list</code>? What&#39;s the practical difference between modifying an existing list and creating a new list to have identical contents and rebinding the name?<br>------------------------------------------------------------------ <br><h3> PythonProgrammi, Id: 46804939, Score: 94: </h3><h1> Append vs Extend</h1>

<h2><a href="https://i.stack.imgur.com/KH5jB.png" rel="noreferrer"><img src="https://i.stack.imgur.com/KH5jB.png" alt="enter image description here"></a></h2>

<p>With append you can append a single element that will extend the list:</p>

<pre><code>&gt;&gt;&gt; a = [1,2]
&gt;&gt;&gt; a.append(3)
&gt;&gt;&gt; a
[1,2,3]
</code></pre>

<p>If you want to extend more than one element you should use extend, because you can only append one elment or one list of element:</p>

<pre><code>&gt;&gt;&gt; a.append([4,5])
&gt;&gt;&gt; a
&gt;&gt;&gt; [1,2,3,[4,5]]
</code></pre>

<p>So that you get a nested list</p>

<p>Instead with extend, you can extend a single element like this</p>

<pre><code>&gt;&gt;&gt; a = [1,2]
&gt;&gt;&gt; a.extend([3])
&gt;&gt;&gt; a
[1,2,3]
</code></pre>

<p>Or, differently, from append, extend more elements in one time without nesting the list into the original one (that's the reason of the name extend)</p>

<pre><code>&gt;&gt;&gt; a.extend([4,5,6])
&gt;&gt;&gt; a
[1,2,3,4,5,6]
</code></pre>

<h1> Adding one element with both methods</h1>

<h2><a href="https://i.stack.imgur.com/lGF2k.png" rel="noreferrer"><img src="https://i.stack.imgur.com/lGF2k.png" alt="enter image description here"></a></h2>

<p>Both append and extend can add one element to the end of the list, though append is simpler.</p>

<h2> append 1 element </h2>

<pre><code>&gt;&gt;&gt; x = [1,2]
&gt;&gt;&gt; x.append(3)
&gt;&gt;&gt; x
[1,2,3]
</code></pre>

<h2> extend one element </h2>

<pre><code>&gt;&gt;&gt; x = [1,2]
&gt;&gt;&gt; x.extend([3])
&gt;&gt;&gt; x
[1,2,3]
</code></pre>

<h1> Adding more elements... with different results </h1>

<p>If you use append for more than one element, you have to pass a list of elements as arguments and you will obtain a NESTED list!</p>

<pre><code>&gt;&gt;&gt; x = [1,2]
&gt;&gt;&gt; x.append([3,4])
&gt;&gt;&gt; x
[1,2,[3,4]]
</code></pre>

<p>With extend, instead, you pass a list as an argument, but you will obtain a list with the new element that is not nested in the old one.</p>

<pre><code>&gt;&gt;&gt; z = [1,2] 
&gt;&gt;&gt; z.extend([3,4])
&gt;&gt;&gt; z
[1,2,3,4]
</code></pre>

<p>So, with more elements, you will use extend to get a list with more items.
However, appending a list will not add more elements to the list, but one element that is a nested list as you can clearly see in the output of the code.</p>

<p><a href="https://i.stack.imgur.com/lJK1M.png" rel="noreferrer"><img src="https://i.stack.imgur.com/lJK1M.png" alt="enter image description here"></a></p>

<p><a href="https://i.stack.imgur.com/KC2Ji.png" rel="noreferrer"><img src="https://i.stack.imgur.com/KC2Ji.png" alt="enter image description here"></a></p>
------------------------------------------------------------------ <br><h3> Nova, Id: 12045242, Score: 67: </h3><p>The following two snippets are semantically equivalent:</p>

<pre><code>for item in iterator:
    a_list.append(item)
</code></pre>

<p>and</p>

<pre><code>a_list.extend(iterator)
</code></pre>

<p>The latter may be faster as the loop is implemented in C.</p>
<h4> Alex L, Comment 19416853 Score: 22: </h4>Extending is ~4x faster on my machine than appending in a loop (16us vs 4us for 100 loops of zeros)<br><h4> Mad Physicist, Comment 54406419 Score: 6: </h4><code>extend()</code> probably preallocates, while <code>append()</code> likely does not.<br><h4> Soren Bjornstad, Comment 100977352 Score: 0: </h4>@MadPhysicist: For completeness&#39; sake, there would be times where <code>extend()</code> <i>can&#39;t</i> preallocate sensibly since some iterables don&#39;t implement <code>__len__()</code>, but like you I&#39;d be surprised if it doesn&#39;t try. Some of the performance gain also comes from doing the iteration part in pure C instead of in Python, as pointed out in <a href="https://stackoverflow.com/a/28119966/">Aaron&#39;s answer</a>.<br>------------------------------------------------------------------ <br><h3> CodyChan, Id: 19707477, Score: 47: </h3><p>The <code>append()</code> method adds a single item to the end of the list.</p>

<pre><code>x = [1, 2, 3]
x.append([4, 5])
x.append('abc')
print(x)
# gives you
[1, 2, 3, [4, 5], 'abc']
</code></pre>

<p>The <code>extend()</code> method takes one argument, a list, and appends each of the items of the argument to the original list. (Lists are implemented as classes. “Creating” a list is really instantiating a class. As such, a list has methods that operate on it.)</p>

<pre><code>x = [1, 2, 3]
x.extend([4, 5])
x.extend('abc')
print(x)
# gives you
[1, 2, 3, 4, 5, 'a', 'b', 'c']
</code></pre>

<p>From <em><a href="https://rads.stackoverflow.com/amzn/click/com/1430224150" rel="noreferrer" rel="nofollow noreferrer">Dive Into Python</a></em>.</p>
<h4> aneroid, Comment 40781525 Score: 0: </h4>You can&#39;t extend with just 6 since it&#39;s not iterable. And the second output in your example is wrong. &#39;abc&#39; gets added as a single element since you passed it in to <code>extend</code> as a list with one element <code>[&#39;abc&#39;]</code>: [1, 2, 3, 4, 5, &#39;abc&#39;]. To make your example output correct, change the abc line to: <code>x.extend(&#39;abc&#39;)</code>. And remove the <code>x.extend(6)</code> or change it to <code>x.extend([6])</code>.<br><h4> am70, Comment 125485027 Score: 0: </h4>Also &quot;The extend() method takes one argument, a list,&quot; is wrong<br>------------------------------------------------------------------ <br><h3> den.run.ai, Id: 18442908, Score: 41: </h3><p>You can use "+" for returning extend, instead of extending in place.</p>

<pre><code>l1=range(10)

l1+[11]

[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 11]

l2=range(10,1,-1)

l1+l2

[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 9, 8, 7, 6, 5, 4, 3, 2]
</code></pre>

<p>Similarly <code>+=</code> for in place behavior, but with slight differences from <code>append</code> &amp; <code>extend</code>. One of the biggest differences of <code>+=</code> from <code>append</code> and <code>extend</code> is when it is used in function scopes, see <a href="https://www.toptal.com/python/top-10-mistakes-that-python-programmers-make?utm_medium=referral&amp;utm_source=zeef.com&amp;utm_campaign=ZEEF" rel="noreferrer">this blog post</a>.</p>
<h4> den.run.ai, Comment 51044106 Score: 5: </h4>@franklin, see this answer for details: <a href="http://stackoverflow.com/a/28119966/2230844">stackoverflow.com/a/28119966/2230844</a><br><h4> pppery, Comment 89610375 Score: 3: </h4>I don&#39;t see how this answers the question<br><h4> franklin, Comment 50959206 Score: 0: </h4>Does using the &#39;+&#39; to return extend have any affect on time complexity?<br><h4> blackraven, Comment 129787825 Score: 0: </h4>I think <code>list.extend([item])</code> is more efficient than <code>list.append(item)</code><br>------------------------------------------------------------------ <br><h3> Chaitanya, Id: 16511403, Score: 25: </h3><p><code>append(object)</code> updates the list by adding the object to the list.</p>
<pre><code>x = [20]
# List passed to the append(object) method is treated as a single object.
x.append([21, 22, 23])
# Hence the resultant list length will be 2
print(x)
--&gt; [20, [21, 22, 23]]
</code></pre>
<p><code>extend(list)</code> concatenates the two lists essentially.</p>
<pre><code>x = [20]
# The parameter passed to extend(list) method is treated as a list.
# Eventually it is two lists being concatenated.
x.extend([21, 22, 23])
# Here the resultant list's length is 4
print(x)
--&gt; [20, 21, 22, 23]
</code></pre>
------------------------------------------------------------------ <br><h3> bconstanzo, Id: 25144368, Score: 15: </h3><p>An interesting point that has been hinted, but not explained, is that extend is faster than append. For any loop that has append inside should be considered to be replaced by list.extend(processed_elements).</p>

<p>Bear in mind that apprending new elements might result in the realloaction of the whole list to a better location in memory. If this is done several times because we are appending 1 element at a time, overall performance suffers. In this sense, list.extend is analogous to "".join(stringlist).</p>
------------------------------------------------------------------ <br><h3> kiriloff, Id: 16510635, Score: 23: </h3><p><code>extend()</code> can be used with an iterator argument. Here is an example. You wish to make a list out of a list of lists this way:</p>

<p>From</p>

<pre><code>list2d = [[1,2,3],[4,5,6], [7], [8,9]]
</code></pre>

<p>you want</p>

<pre><code>&gt;&gt;&gt;
[1, 2, 3, 4, 5, 6, 7, 8, 9]
</code></pre>

<p>You may use <code>itertools.chain.from_iterable()</code> to do so. This method's output is an iterator. Its implementation is equivalent to</p>

<pre><code>def from_iterable(iterables):
    # chain.from_iterable(['ABC', 'DEF']) --&gt; A B C D E F
    for it in iterables:
        for element in it:
            yield element
</code></pre>

<p>Back to our example, we can do</p>

<pre><code>import itertools
list2d = [[1,2,3],[4,5,6], [7], [8,9]]
merged = list(itertools.chain.from_iterable(list2d))
</code></pre>

<p>and get the wanted list.</p>

<p>Here is how equivalently <code>extend()</code> can be used with an iterator argument:</p>

<pre><code>merged = []
merged.extend(itertools.chain.from_iterable(list2d))
print(merged)
&gt;&gt;&gt;
[1, 2, 3, 4, 5, 6, 7, 8, 9]
</code></pre>
------------------------------------------------------------------ <br><h3> skdev75, Id: 24632188, Score: 23: </h3><p>This is the equivalent of <code>append</code> and <code>extend</code> using the <code>+</code> operator:</p>

<pre><code>&gt;&gt;&gt; x = [1,2,3]
&gt;&gt;&gt; x
[1, 2, 3]
&gt;&gt;&gt; x = x + [4,5,6] # Extend
&gt;&gt;&gt; x
[1, 2, 3, 4, 5, 6]
&gt;&gt;&gt; x = x + [[7,8]] # Append
&gt;&gt;&gt; x
[1, 2, 3, 4, 5, 6, [7, 8]]
</code></pre>
------------------------------------------------------------------ <br><h3> The Gr8 Adakron, Id: 37787163, Score: 18: </h3><p><strong><em>append()</em></strong>: It is basically used in Python to add one element.</p>

<blockquote>
  <p>Example 1:</p>
</blockquote>

<pre><code>&gt;&gt; a = [1, 2, 3, 4]
&gt;&gt; a.append(5)
&gt;&gt; print(a)
&gt;&gt; a = [1, 2, 3, 4, 5]
</code></pre>

<blockquote>
  <p>Example 2:</p>
</blockquote>

<pre><code>&gt;&gt; a = [1, 2, 3, 4]
&gt;&gt; a.append([5, 6])
&gt;&gt; print(a)
&gt;&gt; a = [1, 2, 3, 4, [5, 6]]
</code></pre>

<p><strong><em>extend()</em></strong>: Where extend(), is used to merge two lists or insert multiple elements in one list.</p>

<blockquote>
  <p>Example 1:</p>
</blockquote>

<pre><code>&gt;&gt; a = [1, 2, 3, 4]
&gt;&gt; b = [5, 6, 7, 8]
&gt;&gt; a.extend(b)
&gt;&gt; print(a)
&gt;&gt; a = [1, 2, 3, 4, 5, 6, 7, 8]
</code></pre>

<blockquote>
  <p>Example 2:</p>
</blockquote>

<pre><code>&gt;&gt; a = [1, 2, 3, 4]
&gt;&gt; a.extend([5, 6])
&gt;&gt; print(a)
&gt;&gt; a = [1, 2, 3, 4, 5, 6]
</code></pre>
------------------------------------------------------------------ <br><h3> Shiv, Id: 26397913, Score: 15: </h3><p>Append adds the entire data at once. The whole data will be added to the newly created index. On the other hand, <code>extend</code>, as it name suggests, extends the current array. </p>

<p>For example</p>

<pre><code>list1 = [123, 456, 678]
list2 = [111, 222]
</code></pre>

<p>With <code>append</code> we get:</p>

<pre><code>result = [123, 456, 678, [111, 222]]
</code></pre>

<p>While on <code>extend</code> we get:</p>

<pre><code>result = [123, 456, 678, 111, 222]
</code></pre>
------------------------------------------------------------------ <br><h3> kmario23, Id: 48036819, Score: 11: </h3><p>An English dictionary defines the words <code>append</code> and <code>extend</code> as:</p>

<p><strong>append</strong>: add (something) to the end of a written document. <br/>
<strong>extend</strong>: make larger. Enlarge or expand</p>

<hr>

<p>With that knowledge, now let's understand</p>

<p>1) <strong>The difference between <code>append</code> and <code>extend</code></strong></p>

<p><strong><code>append</code></strong>:</p>

<ul>
<li>Appends <em>any Python object as-is</em> to the end of the list (i.e. as a
the last element in the list).</li>
<li>The resulting list may be nested and contain heterogeneous elements (i.e. list, string, tuple, dictionary, set, etc.)</li>
</ul>

<p><strong><code>extend</code></strong>:</p>

<ul>
<li>Accepts any <em>iterable</em> as its argument and makes the list <em>larger</em>.</li>
<li>The resulting list is always one-dimensional list (i.e. no nesting) and it may contain heterogeneous elements in it (e.g. characters, integers, float) as a result of applying <code>list(iterable)</code>.</li>
</ul>

<p>2) <strong>Similarity between <code>append</code> and <code>extend</code></strong></p>

<ul>
<li>Both take exactly one argument.</li>
<li>Both modify the list <em>in-place</em>.</li>
<li>As a result, both returns <code>None</code>.</li>
</ul>

<hr>

<p><strong>Example</strong></p>

<pre><code>lis = [1, 2, 3]

# 'extend' is equivalent to this
lis = lis + list(iterable)

# 'append' simply appends its argument as the last element to the list
# as long as the argument is a valid Python object
list.append(object)
</code></pre>
------------------------------------------------------------------ <br><h3> Crabime, Id: 42171373, Score: 7: </h3><p>I hope I can make a useful supplement to this question. If your list stores a specific type object, for example <code>Info</code>, here is a situation that <code>extend</code> method is not suitable: In a <code>for</code> loop and and generating an <code>Info</code> object every time and using <code>extend</code> to store it into your list, it will fail. The exception is like below:</p>

<blockquote>
  <p>TypeError: 'Info' object is not iterable</p>
</blockquote>

<p>But if you use the <code>append</code> method, the result is OK. Because every time using the <code>extend</code> method, it will always treat it as a list or any other collection type, iterate it, and place it after the previous list. A specific object can not be iterated, obviously.</p>
------------------------------------------------------------------ <br><h3> Wizard, Id: 47631056, Score: 5: </h3><p>To distinguish them intuitively</p>

<pre><code>l1 = ['a', 'b', 'c']
l2 = ['d', 'e', 'f']
l1.append(l2)
l1
['a', 'b', 'c', ['d', 'e', 'f']]
</code></pre>

<p>It's like <code>l1</code> reproduce a body inside her body(nested).</p>

<pre><code># Reset l1 = ['a', 'b', 'c']
l1.extend(l2)
l1
['a', 'b', 'c', 'd', 'e', 'f']
</code></pre>

<p>It's like that two separated individuals get married and construct an united family.</p>

<p>Besides I make an exhaustive cheatsheet of all list's methods for your reference.</p>

<pre><code>list_methods = {'Add': {'extend', 'append', 'insert'},
                'Remove': {'pop', 'remove', 'clear'}
                'Sort': {'reverse', 'sort'},
                'Search': {'count', 'index'},
                'Copy': {'copy'},
                }
</code></pre>
------------------------------------------------------------------ <br><h3> tessie, Id: 39256397, Score: 3: </h3><p><code>extend(L)</code> extends the list by appending all the items in the given list <code>L</code>.</p>

<pre><code>&gt;&gt;&gt; a
[1, 2, 3]
a.extend([4])  #is eqivalent of a[len(a):] = [4]
&gt;&gt;&gt; a
[1, 2, 3, 4]
a = [1, 2, 3]
&gt;&gt;&gt; a
[1, 2, 3]
&gt;&gt;&gt; a[len(a):] = [4]
&gt;&gt;&gt; a
[1, 2, 3, 4]
</code></pre>
------------------------------------------------------------------ <br><h3> ilias iliadis, Id: 49591233, Score: 0: </h3><p><code>append</code> "extends" the list (in place) by <strong>only one item</strong>, the single object passed (as argument).</p>

<p><code>extend</code> "extends" the list (in place) by <strong>as many items as</strong> the object passed (as argument) contains.</p>

<p>This may be slightly confusing for <code>str</code> objects.</p>

<ol>
<li>If you pass a string as argument:
<code>append</code> will add a single string item at the end but
<code>extend</code> will add as many "single" 'str' items as the length of that string.</li>
<li>If you pass a list of strings as argument:
<code>append</code> will still add a single 'list' item at the end and
<code>extend</code> will add as many 'list' items as the length of the passed list.</li>
</ol>

<blockquote>
<pre><code>def append_o(a_list, element):
    a_list.append(element)
    print('append:', end = ' ')
    for item in a_list:
        print(item, end = ',')
    print()

def extend_o(a_list, element):
    a_list.extend(element)
    print('extend:', end = ' ')
    for item in a_list:
        print(item, end = ',')
    print()
append_o(['ab'],'cd')

extend_o(['ab'],'cd')
append_o(['ab'],['cd', 'ef'])
extend_o(['ab'],['cd', 'ef'])
append_o(['ab'],['cd'])
extend_o(['ab'],['cd'])
</code></pre>
</blockquote>

<p>produces:</p>

<pre><code>append: ab,cd,
extend: ab,c,d,
append: ab,['cd', 'ef'],
extend: ab,cd,ef,
append: ab,['cd'],
extend: ab,cd,
</code></pre>
<h4> Shweta Lodha, Comment 129009249 Score: 0: </h4>You can check out my recoding explaining Extend and Append in Python: <a href="https://youtu.be/8A5ohA-UeiI" rel="nofollow noreferrer">youtu.be/8A5ohA-UeiI</a><br>------------------------------------------------------------------ <br><h3> vivek, Id: 51375427, Score: 0: </h3><p>Append and extend are one of the extensibility mechanisms in python. </p>

<p>Append: Adds an element to the end of the list. </p>

<pre><code>my_list = [1,2,3,4]
</code></pre>

<p>To add a new element to the list, we can use append method in the following way.</p>

<pre><code>my_list.append(5)
</code></pre>

<p>The default location that the new element will be added is always in the (length+1) position. </p>

<p>Insert: The insert method was used to overcome the limitations of append. With insert, we can explicitly define the exact position we want our new element to be inserted at. </p>

<p>Method descriptor of insert(index, object). It takes two arguments, first being the index we want to insert our element and second the element itself. </p>

<pre><code>Example: my_list = [1,2,3,4]
my_list[4, 'a']
my_list
[1,2,3,4,'a']
</code></pre>

<p>Extend: This is very useful when we want to join two or more lists into a single list. Without extend, if we want to join two lists, the resulting object will contain a list of lists. </p>

<pre><code>a = [1,2]
b = [3]
a.append(b)
print (a)
[1,2,[3]]
</code></pre>

<p>If we try to access the element at pos 2, we get a list ([3]), instead of the element. To join two lists, we'll have to use append. </p>

<pre><code>a = [1,2]
b = [3]
a.extend(b)
print (a)
[1,2,3]
</code></pre>

<p>To join multiple lists</p>

<pre><code>a = [1]
b = [2]
c = [3]
a.extend(b+c)
print (a)
[1,2,3]
</code></pre>
