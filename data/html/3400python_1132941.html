 <h2> Title: &quot;Least Astonishment&quot; and the Mutable Default Argument </h2> <h4> Stefano Borini, question_id: 1132941 </h4>Score: 3400, Tags: {python,language-design,default-parameters,least-astonishment} <br><p>Anyone tinkering with Python long enough has been bitten (or torn to pieces) by the following issue:</p>
<pre><code>def foo(a=[]):
    a.append(5)
    return a
</code></pre>
<p>Python novices would expect this function called with no parameter to always return a list with only one element: <code>[5]</code>. The result is instead very different, and very astonishing (for a novice):</p>
<pre><code>&gt;&gt;&gt; foo()
[5]
&gt;&gt;&gt; foo()
[5, 5]
&gt;&gt;&gt; foo()
[5, 5, 5]
&gt;&gt;&gt; foo()
[5, 5, 5, 5]
&gt;&gt;&gt; foo()
</code></pre>
<p>A manager of mine once had his first encounter with this feature, and called it &quot;a dramatic design flaw&quot; of the language. I replied that the behavior had an underlying explanation, and it is indeed very puzzling and unexpected if you don't understand the internals. However, I was not able to answer (to myself) the following question: what is the reason for binding the default argument at function definition, and not at function execution? I doubt the experienced behavior has a practical use (who really used static variables in C, without breeding bugs?)</p>
<p><strong>Edit</strong>:</p>
<p><a href="https://stackoverflow.com/a/1137164/7487335">Baczek made an interesting example</a>. Together with most of your comments and <a href="https://stackoverflow.com/a/1134623/7487335">Utaal's in particular</a>, I elaborated further:</p>
<pre><code>def a():
    print(&quot;a executed&quot;)
    return []

           
def b(x=a()):
    x.append(5)
    print(x)

a executed
&gt;&gt;&gt; b()
[5]
&gt;&gt;&gt; b()
[5, 5]
</code></pre>
<p>To me, it seems that the design decision was relative to where to put the scope of parameters: inside the function, or &quot;together&quot; with it?</p>
<p>Doing the binding inside the function would mean that <code>x</code> is effectively bound to the specified default when the function is called, not defined, something that would present a deep flaw: the <code>def</code> line would be &quot;hybrid&quot; in the sense that part of the binding (of the function object) would happen at definition, and part (assignment of default parameters) at function invocation time.</p>
<p>The actual behavior is more consistent: everything of that line gets evaluated when that line is executed, meaning at function definition.</p>
<h4> Jonathan Livni, Id: 11530621 Score: 81: </h4>Complementary question - <a href="http://stackoverflow.com/questions/9158294/good-uses-for-mutable-function-argument-default-values">Good uses for mutable default arguments</a><br><h4> symplectomorphic, Id: 76883169 Score: 32: </h4>&quot;Python novices would expect this function to always return a list with only one element: <code>[5]</code>.&quot; I&#39;m a Python novice, and I wouldn&#39;t expect this, because obviously <code>foo([1])</code> will return <code>[1, 5]</code>, not <code>[5]</code>. What you meant to say is that a novice would expect the function <i>called with no parameter</i> will always return <code>[5]</code>.<br><h4> Serge, Id: 73589342 Score: 9: </h4>I have not doubt mutable arguments violate least astonishment principle for an average person, and I have seen beginners stepping there, then heroically replacing mailing lists with mailing tuples. Nevertheless mutable arguments are still in line with Python Zen (Pep 20) and falls into &quot;obvious for Dutch&quot; (understood/exploited by hard core python programmers) clause.  The recommended  workaround with doc string is the best, yet resistance to doc strings and any (written) docs is not so uncommon nowadays. Personally, I would prefer a decorator (say @fixed_defaults).<br><h4> smci, Id: 98233496 Score: 7: </h4>This question asks <b><i>&quot;Why did this [the wrong way] get implemented so?&quot;</i></b> It doesn&#39;t ask <b><i>&quot;What&#39;s the right way?&quot;</i></b>, which is covered by [<i>Why does using arg=None fix Python&#39;s mutable default argument issue?</i>]*(<a href="https://stackoverflow.com/questions/10676729/why-does-using-arg-none-fix-pythons-mutable-default-argument-issue" title="why does using arg none fix pythons mutable default argument issue">stackoverflow.com/questions/10676729/&hellip;</a>). New users are almost always less interested in the former and much more in the latter, so that&#39;s sometimes a very useful link/dupe to cite.<br><h4> Alan Leuthard, Id: 75640338 Score: 6: </h4>My argument when I come across this is:  &quot;Why do you need to create a function that returns a mutable that could optionally be a mutable you would pass to the function?  Either it alters a mutable or creates a new one.  Why do you need to do both with one function?  And why should the interpreter be rewritten to allow you to do that without adding three lines to your code?&quot; Because we are talking about rewriting the way the interpreter handles function definitions and evocations here.  That&#39;s a lot to do for a barely necessary use case.<br><h4> Jon Kiparsky, Id: 118334948 Score: 2: </h4>Clearly the issue is that <code>[]</code> is syntactic sugar for a function call which returns a value. To the beginner, it looks like &quot;the default argument is a new empty list&quot;, not &quot;the default argument is a reference to a particular list, initially empty&quot;. The &quot;language bug&quot; that I&#39;m seeing here is that python is designed so that people can get by without thinking about references for a lot longer than in other languages, and when they turn up, it&#39;s startling and disconcerting. However, this is usually considered a feature.<br><h4> bob, Id: 109810030 Score: 2: </h4>I can&#39;t help but think the answer in the edit is arguing for X by assuming X. In this case it&#39;s arguing that it&#39;s ok to violate the Principle of Least Astonishment (POLA) here because doing so allows you to instantiate objects inline as default parameters, something that IMHO also violates POLA. Whereas if only literals and object refs were allowed as default parameters, that would satisfy POLA <i>and</i> I think would be easier to implement in a way that makes sense to the average Python dev. Yes you <i>can</i> learn the weird way things are done, but you shouldn&#39;t have to. POLA.<br><h4> Jotaf, Id: 94058606 Score: 2: </h4>The problem is mutable defaults. The answer then is obvious: <i>only allow immutable defaults</i>. This wouldn&#39;t change the most common cases, which are literals, None, and still allow some others like tuples and frozen sets.<br><h4> Reversed Engineer, Id: 101245328 Score: 1: </h4>As a Python newbie since about two weeks ago, I notice that the <a href="https://docs.python.org/3/tutorial/controlflow.html#default-argument-values" rel="nofollow noreferrer">official tutorial</a> contains a warning about this - <b>Important warning:</b> The default value is evaluated only once. This makes a difference when the default is a mutable object such as a list, dictionary, or instances of most classes.<br><h4> Charles Duffy, Id: 108027718 Score: 1: </h4>This question has proven in practice to be contentious and opinion-driven (rather than fact-based), generating &quot;more heat than light&quot; in precisely the way we try not to operate here.<br><h4> natersoz, Id: 108041649 Score: 1: </h4>I disagree. There is some very informative information about why python was designed the way that it was. This helps elucidate how not just this pattern may be problematic but how other mutable default parameters will behave.<br><h4> Blaze, Id: 117102422 Score: 1: </h4>The only thing I find astonishing is someone mutating a parameter.   If you do that, you really should expect the unexpected.<br><h4> Shoaib Wani, Id: 116949716 Score: 0: </h4>Knowing what mutable objects and immutable objects are one can explain this behaviour. It is best example to teach a novice like me the behaviour of mutable and non-mutable objects!<br><h4> wjandrea, Id: 125959877 Score: 0: </h4>@JonKiparsky Eh? You&#39;d have exactly the same problem with <code>list()</code> in place of <code>[]</code>.<br><h4> Jon Kiparsky, Id: 126054675 Score: 0: </h4>@wjandrea Not sure which problem you&#39;re highlighting as &quot;exactly the same&quot;. I&#39;m talking about a user expectation problem, not a language behavior problem. I could be wrong, but I think the user would not have the same expectations of <code>list()</code> as they do for <code>[]</code>  - I agree that setting <code>list()</code> as a parameter for a function would have exactly the same problem as using <code>[]</code>, but I&#39;m not sure that users would expect the former to work, where they clearly expect the latter to work.<br><h4> Flimm, Id: 126671046 Score: 0: </h4>Currently, the only two answers that admit this is a design flaw in Python are:  <a href="https://stackoverflow.com/a/1139730/247696">stackoverflow.com/a/1139730/247696</a> and <a href="https://stackoverflow.com/a/71674471/247696">stackoverflow.com/a/71674471/247696</a><br><h4> Karl Knechtel, Id: 127992708 Score: 0: </h4>@Flimm what is or isn&#39;t a &quot;design flaw&quot; is subjective, as seen by the fact that the top answer <i>explicitly refutes</i> that assessment and builds intuition as to why the behaviour should be expected. There are also plausible uses for it (although there are better tools for those uses). At any rate, Stack Overflow is not supposed to be about such judgments: see <a href="https://stackoverflow.com/help/dont-ask">stackoverflow.com/help/dont-ask</a>.<br><h4> BadZen, Id: 131795599 Score: 0: </h4>This behavior is not only correct if you are thinking &quot;Pythonically&quot;, /it is absolutely necessary/ - because you will encounter places where you need to capture a locally scoped value in a closure defined in that scope.   Your only options are either binding the function with <code>__get__</code>, or passing it as a default arg.  The latter is much cleaner, more concise, and the standard idiom.<br><h4> BadZen, Id: 131795627 Score: 0: </h4>It&#39;s very simple:  argument defaults are part of the function definition, just like the rest of the function signature.  It&#39;s actually wacky to implicitly have a lexical expression &quot;stored magically&quot; and executed every time the function is run - it only doesn&#39;t seem as such because your mind has already been bent by other languages =).   (What is this extra piece of code?  Where does it live?  etc...)  If you want a &quot;factory&quot; pattern that creates a new object each time the function is run, /it is trivial and more clear to explicitly do that/.<br><h4> Karl Knechtel, Id: 133795991 Score: 0: </h4>@smci Much more precise for &quot;what&#39;s the right way?&quot; is <a href="https://stackoverflow.com/questions/366422">What is the pythonic way to avoid default parameters that are empty lists?</a>. What you found is explaining how the most common way works - which is not very interesting, and also doesn&#39;t make a particularly good argument for it being the right way.<br><h4> Karl Knechtel, Id: 133795996 Score: 0: </h4>(Personally, I think it is <b>often not</b> the right way, for command-query separation reasons. If the code should return a value, it shouldn&#39;t modify the argument, and thus shouldn&#39;t need a mutable argument; if it does, it can&#39;t sanely be defaulted, because the calling code needs to check for the mutation in order to understand what happened.)<br><h4> Karl Knechtel, Id: 133796025 Score: 0: </h4>(The &quot;why does using <code>None</code> fix the problem?&quot; question is not really about mutable default arguments anyway: it is <b>primarily</b> yet another question about assignment vs. mutation.)<br><h4> bob, Id: 109810159 Score: 0: </h4>When I say literals, I mean strings, numbers, objects, and lists, the latter two only composed of strings and numbers, or objects and lists composed only of...well you get the picture. And it would then create a deep copy of the default param each time it is called, passing it in so there&#39;s no cross-talk between calls.<br><h4> sdaffa23fdsf, Id: 84070991 Score: 0: </h4>For <a href="https://docs.python.org/3/tutorial/controlflow.html#default-argument-values" rel="nofollow noreferrer">example in Python tutorial</a>, why is <code>if L is None:</code> needed? I removed this test and it made no difference<br><h4> nehem, Id: 89176442 Score: 0: </h4>@sdaffa23fdsf What if <code>L</code> is not <code>None</code>, You wouldn&#39;t want to override the incoming value of that parameter.<br>------------------------------------------------------------------ <br><h3> joedborg, Id: 14336301, Score: 16: </h3><p>You can get round this by replacing the object (and therefore the tie with the scope):</p>

<pre><code>def foo(a=[]):
    a = list(a)
    a.append(5)
    return a
</code></pre>

<p>Ugly, but it works.</p>
<h4> Michael Scott Asato Cuthbert, Comment 20074742 Score: 3: </h4>This is a nice solution in cases where you&#39;re using automatic documentation generation software to document the types of arguments expected by the function.  Putting a=None and then setting a to [] if a is None doesn&#39;t help a reader understand at a glance what is expected.<br><h4> holdenweb, Comment 83550838 Score: 0: </h4>Cool idea: rebinding that name guarantees it can never be modified. I really like that.<br><h4> Mark Ransom, Comment 88079491 Score: 0: </h4>This is exactly the way to do it. Python doesn&#39;t make a copy of the parameter, so it&#39;s up to you to make the copy explicitly. Once you have a copy, it&#39;s yours to modify as you please without any unexpected side effects.<br><h4> Flimm, Comment 126670875 Score: 0: </h4>This doesn&#39;t answer the question, though.<br>------------------------------------------------------------------ <br><h3> rob, Id: 1145781, Score: 1918: </h3><p>Actually, this is not a design flaw, and it is not because of internals or performance. It comes simply from the fact that functions in Python are first-class objects, and not only a piece of code.</p>
<p>As soon as you think of it this way, then it completely makes sense: a function is an object being evaluated on its definition; default parameters are kind of &quot;member data&quot; and therefore their state may change from one call to the other - exactly as in any other object.</p>
<p>In any case, the effbot (Fredrik Lundh) has a very nice explanation of the reasons for this behavior in <a href="https://web.archive.org/web/20200221224620id_/http://effbot.org/zone/default-values.htm" rel="noreferrer">Default Parameter Values in Python</a>.
I found it very clear, and I really suggest reading it for a better knowledge of how function objects work.</p>
<h4> BlueRaja - Danny Pflughoeft, Comment 24551066 Score: 554: </h4>Sorry, but anything considered &quot;The biggest WTF in Python&quot; is <b>most definitely a design flaw</b>.  This is a source of bugs for <i>everyone</i> at some point, because no one expects that behavior at first - which means it should not have been designed that way to begin with.  I don&#39;t care what hoops they had to jump through, they <b>should</b> have designed Python so that default arguments are non-static.<br><h4> Mark Amery, Comment 31573411 Score: 318: </h4>Whether or not it&#39;s a design flaw, your answer seems to imply that this behaviour is somehow necessary, natural and obvious given that functions are first-class objects, and that simply isn&#39;t the case. Python has closures. If you replace the default argument with an assignment on the first line of the function, it evaluates the expression each call (potentially using names declared in an enclosing scope). There is no reason at all that it wouldn&#39;t be possible or reasonable to have default arguments evaluated each time the function is called in exactly the same way.<br><h4> gerrit, Comment 19820636 Score: 161: </h4>Even if it&#39;s a first-class object, one might still envision a design where the <i>code</i> for each default value is stored along with the object and re-evaluated each time the function is called. I&#39;m not saying that would be better, just that functions being first-class objects does not fully preclude it.<br><h4> Cam Jackson, Comment 9448792 Score: 105: </h4>To anyone reading the above answer, I strongly recommend you take the time to read through the linked Effbot article. As well as all the other useful info, the part on how this language feature can be used for result caching/memoisation is very handy to know!<br><h4> bukzor, Comment 35944779 Score: 62: </h4>The design doesn&#39;t directly follow from <code>functions are objects</code>. In your paradigm, the proposal would be to implement functions&#39; default values as properties rather than attributes.<br><h4> Ryan Delucchi, Comment 24249826 Score: 23: </h4>I would argue that this is a language design flaw for one very simple reason: A function definition should be internally state-less between invocations.  I say &quot;internally stateless&quot;, because state can <i>externally</i> be changed if data is passed by reference or as a side-effect of calling other state-changing methods.  But with all external state removed, subsequent calls of a function should not effect the future behavior of said function.  Violating this becomes a liability that undermines code modularization (in-terms of both separation of concerns and functional programming).<br><h4> Kaffiene, Comment 123120365 Score: 18: </h4>This IS a design flaw. The Effbot justification is terrible. &quot;If you need to handle arbitrary objects (including None), you can use a sentinel object&quot; -  you shouldn&#39;t have to write code to stop the language doing something non-obvious in the first place. The memoisation example is awful - memoisation is achieved by adding a parameter which is not actually intended as a parameter but which is only there for the side effect of exploiting the non-obvious behaviour under discussion. It&#39;s not convincing to say &quot;this awful hack isn&#39;t a design flaw because it enables this other awful hack&quot;<br><h4> Elazar, Comment 25086797 Score: 7: </h4>This is not a design flaw. It is a design decision; perhaps a bad one, but not an accident. The state thing is just like any other closure: a closure is not a function, and a function with mutable default argument is not a function. <code>x = [ [1,2,3] ] * 5</code> is also a seriou source of bugs, but not a design flaw.<br><h4> user3714134, Comment 118287552 Score: 6: </h4>I just ran into this &quot;design choice&quot;, it definitely is a design flaw.<br><h4> Xanthir, Comment 122733481 Score: 6: </h4>No, this is a design choice, not an obvious consequence. See, for example, JavaScript, which has the identical feature but gives them the behavior that the OP and most people expect - defaults are evaluated at each invocation, as if they were code executed on the first line of the function body.  The JS behavior is more complicated <i>internally</i> (there&#39;s a lot of complex stuff in the spec with setting up lexical scopes) but it presents a more intuitive feature to authors.<br><h4> Flimm, Comment 126670588 Score: 5: </h4>I downvoted this answer, because this is definitely a design flaw in Python. So much so, that the core developers of Python are discussing <a href="https://lwn.net/Articles/875441/" rel="nofollow noreferrer">introducing new syntax to support late-bound argument defaults for Python</a>.<br><h4> Torxed, Comment 22870627 Score: 5: </h4>I&#39;m suprised that no one has mentioned <a href="http://www.jeffknupp.com/blog/2013/02/14/drastically-improve-your-python-understanding-pythons-execution-model/" rel="nofollow noreferrer">jeffknupp.com/blog/2013/02/14/&hellip;</a> which gives you a clearer understanding of the execution model and why <code>a</code> would &quot;resurface&quot; instead of being recreated every call?<br><h4> flash42, Comment 120649816 Score: 4: </h4>Mutable data structures are funny. Mutable functions are unbelievable.<br><h4> trincot, Comment 129091005 Score: 2: </h4>Why would this be related to &quot;first class objects&quot;? It is a <b>choice</b> (a bad one) to have default arguments be part of the <b>definition</b> phase and not part of the <b>execution</b> phase, like the body of the function where apparently it is no problem to create new lists at the <i>execution</i> phase, even though functions are &quot;first class objects&quot;. It just is a bad choice and there is no good reason for it.<br><h4> atevm, Comment 130836164 Score: 2: </h4>so Python functions has internal state, nice, no design flaw at all. I love state. Everything should have state. Mathematical functions should have state. That would make the world soooo much easier. (sarcasm at the highest orda)<br><h4> mtraceur, Comment 131459107 Score: 1: </h4>A design flaw is a design decision or omission that we can judge as flawed. This answer seems to be using a strange definition of &quot;design flaw&quot; that excludes all consciously intended design choices and results of design choices, but it is precisely the fact that it is a result of deliberate decisions that makes it a <i>design</i> flaw. Perhaps this answer is trying to say that it is not a <i>flaw</i> (despite the fact that it is a perpetual pitfall for novices) but if so then this answer&#39;s wording isn&#39;t the best way to say that.<br><h4> Nick W., Comment 121599724 Score: 1: </h4>This functionality is already built into classes, its the main reason to use classes, adding mutable into functions was a shit &quot;design choice&quot; that serves little to no purpose. They would of caused significantly less headaches properly segmenting the uses cases for classes and functions. This also could of been avoided by Python having a functional variable scoping mechanism like most other languages.<br><h4> Mark Amery, Comment 31573136 Score: 1: </h4>@RyanDelucchi Your comment very nearly amounts to &#39;closures that allow assignment to closure variables, or closures that can involve mutable objects, are inherently bad&#39;. You&#39;ll <i>hate</i> JavaScript. Things I find awesome, like the ability to construct generators with closures like <code>var numbersIterator = function () {var i=0; return function () {return i++;}}()</code>, will probably give you nightmares.<br><h4> Cort Ammon, Comment 126632683 Score: 0: </h4>Daring to weigh in on this, I&#39;d point out that while what is &quot;natural&quot; is often a personal opinion, trying to reconcile this design choice with the Zen of Python is a challenge.  All that seems to apply to it is &quot;Special cases aren&#39;t special enough to break the rules&quot; (without its essential couple, &quot;Although practicality beats purity&quot;) and &quot;Although that way may not be obvious at first unless you&#39;re Dutch.&quot;<br><h4> Dave Doknjas, Comment 135345488 Score: 0: </h4>All programming languages have some design flaws or oversights. This is either a design flaw or an oversight. Some language proponents will never admit that their favorite language has flaws and will go to great lengths to argue otherwise.<br><h4> cregox, Comment 2655022 Score: 0: </h4>What do you mean by &quot;first-class objects&quot;, Roberto? Is this it, the &quot;programmer&#39;s note&quot; right above the &quot;class definitions&quot;? <a href="http://docs.python.org/reference/compound_stmts.html#class-definitions" rel="nofollow noreferrer">docs.python.org/reference/compound_stmts.html#class-definiti&zwnj;&#8203;ons</a><br><h4> rob, Comment 2655315 Score: 0: </h4>I mean that they are &quot;objects&quot;, not much different from what you create by instantiating a class.<br>------------------------------------------------------------------ <br><h3> Eli Courtwright, Id: 1133013, Score: 336: </h3><p>Suppose you have the following code</p>
<pre><code>fruits = (&quot;apples&quot;, &quot;bananas&quot;, &quot;loganberries&quot;)

def eat(food=fruits):
    ...
</code></pre>
<p>When I see the declaration of eat, the least astonishing thing is to think that if the first parameter is not given, that it will be equal to the tuple <code>(&quot;apples&quot;, &quot;bananas&quot;, &quot;loganberries&quot;)</code></p>
<p>However, suppose later on in the code, I do something like</p>
<pre><code>def some_random_function():
    global fruits
    fruits = (&quot;blueberries&quot;, &quot;mangos&quot;)
</code></pre>
<p>then if default parameters were bound at function execution rather than function declaration, I would be astonished (in a very bad way) to discover that fruits had been changed. This would be more astonishing IMO than discovering that your <code>foo</code> function above was mutating the list.</p>
<p>The real problem lies with mutable variables, and all languages have this problem to some extent. Here's a question: suppose in Java I have the following code:</p>
<pre class="lang-java prettyprint-override"><code>StringBuffer s = new StringBuffer(&quot;Hello World!&quot;);
Map&lt;StringBuffer,Integer&gt; counts = new HashMap&lt;StringBuffer,Integer&gt;();
counts.put(s, 5);
s.append(&quot;!!!!&quot;);
System.out.println( counts.get(s) );  // does this work?
</code></pre>
<p>Now, does my map use the value of the <code>StringBuffer</code> key when it was placed into the map, or does it store the key by reference? Either way, someone is astonished; either the person who tried to get the object out of the <code>Map</code> using a value identical to the one they put it in with, or the person who can't seem to retrieve their object even though the key they're using is literally the same object that was used to put it into the map (this is actually why Python doesn't allow its mutable built-in data types to be used as dictionary keys).</p>
<p>Your example is a good one of a case where Python newcomers will be surprised and bitten. But I'd argue that if we &quot;fixed&quot; this, then that would only create a different situation where they'd be bitten instead, and that one would be even less intuitive. Moreover, this is always the case when dealing with mutable variables; you always run into cases where someone could intuitively expect one or the opposite behavior depending on what code they're writing.</p>
<p>I personally like Python's current approach: default function arguments are evaluated when the function is defined and that object is always the default. I suppose they could special-case using an empty list, but that kind of special casing would cause even more astonishment, not to mention be backwards incompatible.</p>
<h4> Ben Blank, Comment 950592 Score: 72: </h4>Actually, I don&#39;t think I agree with your first example.  I&#39;m not sure I like the idea of modifying an initializer like that in the first place, but if I did, I&#39;d expect it to behave exactly as you describe — changing the default value to <code>(&quot;blueberries&quot;, &quot;mangos&quot;)</code>.<br><h4> Stefano Borini, Comment 950511 Score: 52: </h4>I think it&#39;s a matter of debate. You are acting on a global variable. Any evaluation performed anywhere in your code involving your global variable will now (correctly) refer to (&quot;blueberries&quot;, &quot;mangos&quot;). the default parameter could just be like any other case.<br><h4> user3467349, Comment 44679235 Score: 30: </h4>You just explicitly declared <code>global</code> and reassigned the tuple - there is absolutely nothing surprising if <code>eat</code> works differently after that.<br><h4> alexis, Comment 41236608 Score: 28: </h4>I find the example misleading rather than brilliant. If <code>some_random_function()</code> appends to <code>fruits</code> instead of assigning to it, the behaviour of <code>eat()</code> <i>will</i> change. So much for the current wonderful design. If you use a default argument that&#39;s referenced elsewhere and then modify the reference from outside the function, you are asking for trouble. The real WTF is when people define a fresh default argument (a list literal or a call to a constructor), and <i>still</i> get bit.<br><h4> Lennart Regebro, Comment 950800 Score: 15: </h4>The default parameter <i>is</i> like any other case. What is unexpected is that the parameter is a global variable, and not a local one. Which in turn is because the code is executed at function definition, not call. Once you get that, and that the same goes for classes, it&#39;s perfectly clear.<br><h4> Eric Duminil, Comment 80464226 Score: 9: </h4>One more awful example to try to justify this design bug. I notice a trend here! If I see <code>globals x; x = new_value</code>, I&#39;ll become very cautious and kinda expect weird behaviour somewhere else. Python is dynamic, it&#39;s easy to break it if you want. It shouldn&#39;t shoot itself in the foot automatically, though.<br><h4> alexis, Comment 43954589 Score: 6: </h4>@jpm, that&#39;s partly why I called the example misleading. The whole issue is about <i>mutable</i> default arguments (as this answer even points out).<br><h4> Nicolas Daoust, Comment 95674935 Score: 5: </h4>As soon as I saw the function declaration referring to the &#39;fruits&#39; variable, I thought &quot;OK, so the programmer wants that default value to be changeable.&quot;  I am disappointed that it is not the case.<br><h4> jpmc26, Comment 43911938 Score: 4: </h4>@alexis <code>fruits</code> is intentionally a <code>tuple</code> here to prevent the case you describe. <code>tuple</code>s are immutable. It cannot be appended. That choice also clearly suggests that the author does not expect it to change.<br><h4> Dan Lenski, Comment 40502943 Score: 3: </h4>@EliCourtwright, this is the best answer to this question I have read. Nicely explained. As you show, a &quot;fix&quot; is not desirable here. My proposal for how to not confuse the newbies would be to emit a compile-time warning about mutable built-in types as default arguments, although this is not a very Pythonic thing to do either :-P<br><h4> Kaffiene, Comment 123120480 Score: 2: </h4>I&#39;m unconvinced. I think the Java example with a mutable key is infinitely more understandable than a mutable function parameter<br><h4> jpmc26, Comment 43954657 Score: 2: </h4>@alexis The point of the example here is to show why making it work the other way would be just as surprising or problematic in another situation. The choice of an immutable type in this particular example makes it easier to focus on the scoping issues that arise from the alternative behavior, since mutability is no longer is an issue. Examples that intentionally avoid particular issues they&#39;re not designed for discussing are not misleading; they&#39;re good examples.<br><h4> jpmc26, Comment 43954693 Score: 2: </h4>@StefanoBorini To some degree, it is a matter of opinion, but the language designers made a very good choice. By doing it the way they did, they <i>localized the damage your bug can do</i>. Doing it the other way, as described here, creates bugs related to <i>global state modification</i>. Global state modification problems can be very difficult to track down and fix, so the Python decision forces you to be very explicit about when you want shared state. With the way they did it, your bug exists in a single location, is easily found, and is easily fixed, all within the scope of a single function.<br><h4> BlueRaja - Danny Pflughoeft, Comment 24551118 Score: 1: </h4>I have no idea what to expect in that first code example.  It really shouldn&#39;t be legal code to begin with <i>(I seriously hope it isn&#39;t)</i><br><h4> Benjamin Berger, Comment 120134778 Score: 0: </h4>This can be avoided by capturing variables at function definition time, but evaluating the expressions for the default arguments (which may involve these captured variables) when the function is called.<br><h4> Benjamin Berger, Comment 120134944 Score: 0: </h4>(Continued) Capture of local variables is a desirable feature anyway, but it&#39;s messy to implement if you want the captured variables to be aliases for the local variables of the enclosing scope, and not being able to change captured variables by reassigning them in the outer scope may break some programmers&#39; expectations. Java solves this by forcing captured variables to be final.<br>------------------------------------------------------------------ <br><h3> glglgl, Id: 11416002, Score: 315: </h3><p>The relevant part of the <a href="http://docs.python.org/reference/compound_stmts.html#function-definitions" rel="noreferrer">documentation</a>:</p>

<blockquote>
  <p><strong>Default parameter values are evaluated from left to right when the function definition is executed.</strong> This means that the expression is evaluated once, when the function is defined, and that the same “pre-computed” value is used for each call. This is especially important to understand when a default parameter is a mutable object, such as a list or a dictionary: if the function modifies the object (e.g. by appending an item to a list), the default value is in effect modified. This is generally not what was intended. A way around this is to use <code>None</code> as the default, and explicitly test for it in the body of the function, e.g.:</p>

<pre><code>def whats_on_the_telly(penguin=None):
    if penguin is None:
        penguin = []
    penguin.append("property of the zoo")
    return penguin
</code></pre>
</blockquote>
<h4> bukzor, Comment 35944900 Score: 293: </h4>The phrases &quot;this is not generally what was intended&quot; and &quot;a way around this is&quot; smell like they&#39;re documenting a design flaw.<br><h4> holdenweb, Comment 43555974 Score: 49: </h4>The phrase &quot;this is not generally what was intended&quot; means &quot;not what the programmer actually wanted to happen,&quot; not &quot;not what Python is supposed to do.&quot;<br><h4> code_dredd, Comment 80032999 Score: 20: </h4>@holdenweb Wow, I&#39;m mega-late to the party. Given the context, bukzor is completely right: they&#39;re documenting behavior/consequence that was not &quot;intended&quot; when they they decided the language should exec the function&#39;s definition. Since it&#39;s an unintended consequence of their design choice, it&#39;s a design flaw. If it were not a design flaw, there&#39;d be no need to even offer &quot;a way around this&quot;.<br><h4> Matthew, Comment 37577356 Score: 16: </h4>@bukzor: Pitfalls need to be noted and documented, which is why this question is good and has received so many upvotes. At the same time, pitfalls don&#39;t necessarily need to be removed. How many Python beginners have passed a list to a function that modified it, and were shocked to see the changes show up in the original variable? Yet mutable object types are wonderful, when you understand how to use them. I guess it just boils down to opinion on this particular pitfall.<br><h4> holdenweb, Comment 80051888 Score: 10: </h4>We could take it to chat and discuss how else it could be, but the semantics have been thoroughly debated and nobody could come up with a sensible mechanism for create-default-value-on-call. One serious issue is that the scope on call is often entirely different from that on definition, making name resolution uncertain if defaults were evaluated at call time. A &quot;way around&quot; means &quot;you can achieve your desired end in the following way,&quot; not &quot;this is a mistake in Python&#39;s design.&quot;<br><h4> bukzor, Comment 37549919 Score: 6: </h4>@Matthew: I&#39;m well aware, but it&#39;s not worth the pitfall. You&#39;ll generally see style guides and linters unconditionally flag mutable default values as wrong for this reason. The explicit way to do the same thing is to stuff an attribute onto the function (<code>function.data = []</code>) or better yet, make an object.<br><h4> jtpereyda, Comment 96784743 Score: 3: </h4>@holdenweb regarding your Dec 19 &#39;14 comment: &quot;not what Python is supposed to do&quot; would describe an implementation flaw, not a design flaw. We know the implementation matches the design -- the question of a design flaw concerns whether that design was a good idea in the first place.<br><h4> Esteban, Comment 135968101 Score: 1: </h4>@Matthew this question is popular (upvoted, commented, etc.) because too many people struggle with Python&#39;s bad decision. If the design around default parameter values were intuitive, if a question existed about it it would be way less popular.<br><h4> Flimm, Comment 126670779 Score: 1: </h4>This doesn&#39;t answer the question. The question isn&#39;t &quot;how does Python behave?&quot;, but &quot;why does anyone think this is a good design?&quot;<br><h4> miraculixx, Comment 42431824 Score: 0: </h4>@bukzor it is well documented behavior. It is a documentation flaw, not a design flaw.<br>------------------------------------------------------------------ <br><h3> Utaal, Id: 1134623, Score: 148: </h3><p>I know nothing about the Python interpreter inner workings (and I'm not an expert in compilers and interpreters either) so don't blame me if I propose anything unsensible or impossible.</p>

<p>Provided that python objects <strong>are mutable</strong> I think that this should be taken into account when designing the default arguments stuff.
When you instantiate a list:</p>

<pre><code>a = []
</code></pre>

<p>you expect to get a <strong>new</strong> list referenced by <code>a</code>.</p>

<p>Why should the <code>a=[]</code> in</p>

<pre><code>def x(a=[]):
</code></pre>

<p>instantiate a new list on function definition and not on invocation?
It's just like you're asking "if the user doesn't provide the argument then <em>instantiate</em> a new list and use it as if it was produced by the caller".
I think this is ambiguous instead:</p>

<pre><code>def x(a=datetime.datetime.now()):
</code></pre>

<p>user, do you want <code>a</code> to default to the datetime corresponding to when you're defining or executing <code>x</code>?
In this case, as in the previous one, I'll keep the same behaviour as if the default argument "assignment" was the first instruction of the function (<code>datetime.now()</code> called on function invocation).
On the other hand, if the user wanted the definition-time mapping he could write:</p>

<pre><code>b = datetime.datetime.now()
def x(a=b):
</code></pre>

<p>I know, I know: that's a closure. Alternatively Python might provide a keyword to force definition-time binding:</p>

<pre><code>def x(static a=b):
</code></pre>
<h4> AndreasT, Comment 6587169 Score: 35: </h4>Thank you for this. I couldn&#39;t really put my finger on why this  irks me to no end. You have done it beautifully with a minimum of fuzz and confusion. As someone comming from systems programming in C++ and sometimes naively &quot;translating&quot; language features, this false friend kicked me in the in the soft of the head big time, just like class attributes. I understand why things are this way, but I cannot help but dislike it, no matter what positive might come of it. At least it is so contrary to my experience, that I&#39;ll probably (hopefully) never forget it...<br><h4> Anon, Comment 952595 Score: 14: </h4>You could do: def x(a=None): And then, if a is None, set a=datetime.datetime.now()<br><h4> Lutz Prechelt, Comment 46876103 Score: 8: </h4>The function <b>definition</b> is executed at module load time. The function <b>body</b> is executed at function call time. The default argument is part of the function definition, not of the function body. (It gets more complicated for nested functions.)<br><h4> AndreasT, Comment 8112414 Score: 8: </h4>Normative structure is no quirk or limitation in my book. I know it can be clumsy and ugly, but you can call it a &quot;definition&quot; of something. The dynamic languages seem a bit like anarchists to me: Sure everybody is free, but you need structure to get someone to empty the trash and pave the road. Guess I&#39;m old... :)<br><h4> Karl Knechtel, Comment 8065966 Score: 6: </h4>@Andreas once you use Python for long enough, you begin to see how logical it is for Python to interpret things as class attributes the way it does - it is only because of the particular quirks and limitations of languages like C++ (and Java, and C#...) that it makes any sense for contents of the <code>class {}</code> block to be interpreted as belonging to the <i>instances</i> :) But when classes are first-class objects, obviously the natural thing is for their contents (in memory) to reflect their contents (in code).<br><h4> MisterMiyagi, Comment 65638847 Score: 2: </h4>Having such a <code>static</code> keyword in a python function signature doesn&#39;t make sense. If the signature is evaluated <i>once</i> (how python does it), then the default is also only evaluated once, and thus &quot;static&quot; is redundant. If the signature is <i>not</i> evaluated once (how python doesn&#39;t do it), then &quot;static&quot; would be evaluated every time the function is called - which wouldn&#39;t be static.<br><h4> Wildcard, Comment 65773995 Score: 2: </h4>As someone learning Python, I understood the answers above this one but I couldn&#39;t understand this one; I found it very unclear.  It seems to be a language design change proposal mixed in with a description of how the language currently works, and it&#39;s unclear which of your questions are rhetorical.  (And then the phrase, &quot;It&#39;s just like you&#39;re asking&quot; is followed by a statement rather than a question.)<br>------------------------------------------------------------------ <br><h3> Lennart Regebro, Id: 1133255, Score: 99: </h3><p>Well, the reason is quite simply that bindings are done when code is executed, and the function definition is executed, well... when the functions is defined.</p>

<p>Compare this:</p>

<pre><code>class BananaBunch:
    bananas = []

    def addBanana(self, banana):
        self.bananas.append(banana)
</code></pre>

<p>This code suffers from the exact same unexpected happenstance. bananas is a class attribute, and hence, when you add things to it, it's added to all instances of that class. The reason is exactly the same.</p>

<p>It's just "How It Works", and making it work differently in the function case would probably be complicated, and in the class case likely impossible, or at least slow down object instantiation a lot, as you would have to keep the class code around and execute it when objects are created.</p>

<p>Yes, it is unexpected. But once the penny drops, it fits in perfectly with how Python works in general. In fact, it's a good teaching aid, and once you understand why this happens, you'll grok python much better.</p>

<p>That said it should feature prominently in any good Python tutorial. Because as you mention, everyone runs into this problem sooner or later.</p>
<h4> Lennart Regebro, Comment 950938 Score: 21: </h4>If it&#39;s different for each instance it&#39;s not a class attribute. Class attributes are attributes on the CLASS. Hence the name. Hence they are the same for all instances.<br><h4> Lennart Regebro, Comment 955627 Score: 3: </h4>@Kievieli: You ARE talking about normal member variables of a class. :-)  You define instance attributes by saying self.attribute = value in any method. For example __init__().<br><h4> Kieveli, Comment 955561 Score: 2: </h4>How do you define an attribute in a class that is different for each instance of a class? (Re-defined for those who could not determine that a person not familiar with Python&#39;s naming convenctions might be asking about normal member variables of a class).<br><h4> Kieveli, Comment 950835 Score: 0: </h4>How do you define a class attribute that is different for each instance of a class?<br><h4> Ethan Furman, Comment 10928164 Score: 0: </h4>@Kieveli: Two answers:  you can&#39;t, because any thing you define at a class level will be a class attribute, and any instance that accesses that attribute will access the same class attribute; you can, /sort of/, by using <code>property</code>s -- which are actually class level functions that act like normal attributes but save the attribute in the instance instead of the class (by using <code>self.attribute = value</code> as Lennart said).<br>------------------------------------------------------------------ <br><h3> Dimitris Fasarakis Hilliard, Id: 34172768, Score: 89: </h3><h2>Why don't you introspect?</h2>

<p>I'm <em>really</em> surprised no one has performed the insightful introspection offered by Python (<code>2</code> and <code>3</code> apply) on callables. </p>

<p>Given a simple little function <code>func</code> defined as:</p>

<pre><code>&gt;&gt;&gt; def func(a = []):
...    a.append(5)
</code></pre>

<p>When Python encounters it, the first thing it will do is compile it in order to create a <code>code</code> object for this function. While this compilation step is done, <em>Python <strong>evaluates</strong>* and then <strong>stores</strong> the default arguments (an empty list <code>[]</code> here) in the function object itself</em>. As the top answer mentioned: the list <code>a</code> can now be considered a <em>member</em> of the function <code>func</code>.</p>

<p>So, let's do some introspection, a before and after to examine how the list gets expanded <strong>inside</strong> the function object. I'm using <code>Python 3.x</code> for this, for Python 2 the same applies (use <code>__defaults__</code> or <code>func_defaults</code> in Python 2; yes, two names for the same thing).</p>

<h3>Function Before Execution:</h3>

<pre><code>&gt;&gt;&gt; def func(a = []):
...     a.append(5)
...     
</code></pre>

<p>After Python executes this definition it will take any default parameters specified (<code>a = []</code> here) and <a href="https://docs.python.org/3/reference/datamodel.html#the-standard-type-hierarchy" rel="noreferrer">cram them in the <code>__defaults__</code> attribute for the function object</a> (relevant section: Callables):     </p>

<pre><code>&gt;&gt;&gt; func.__defaults__
([],)
</code></pre>

<p>O.k, so an empty list as the single entry in <code>__defaults__</code>, just as expected. </p>

<h3>Function After Execution:</h3>

<p>Let's now execute this function:</p>

<pre><code>&gt;&gt;&gt; func()
</code></pre>

<p>Now, let's see those <code>__defaults__</code> again: </p>

<pre><code>&gt;&gt;&gt; func.__defaults__
([5],)
</code></pre>

<p><em>Astonished?</em> The value inside the object changes! Consecutive calls to the function will now simply append to that embedded <code>list</code> object:</p>

<pre><code>&gt;&gt;&gt; func(); func(); func()
&gt;&gt;&gt; func.__defaults__
([5, 5, 5, 5],)
</code></pre>

<p>So, there you have it, the reason why this <em>'flaw'</em> happens, is because default arguments are part of the function object. There's nothing weird going on here, it's all just a bit surprising.</p>

<p>The common solution to combat this is to use <code>None</code> as the default and then initialize in the function body:</p>

<pre><code>def func(a = None):
    # or: a = [] if a is None else a
    if a is None:
        a = []
</code></pre>

<p>Since the function body is executed anew each time, you always get a fresh new empty list if no argument was passed for <code>a</code>.</p>

<hr>

<p>To further verify that the list in <code>__defaults__</code> is the same as that used in the function <code>func</code> you can just change your function to return the <code>id</code> of the list <code>a</code> used inside the function body. Then, compare it to the list in <code>__defaults__</code> (position <code>[0]</code> in <code>__defaults__</code>) and you'll see how these are indeed refering to the same list instance:</p>

<pre><code>&gt;&gt;&gt; def func(a = []): 
...     a.append(5)
...     return id(a)
&gt;&gt;&gt;
&gt;&gt;&gt; id(func.__defaults__[0]) == func()
True
</code></pre>

<p>All with the power of introspection! </p>

<hr>

<p><sup>*</sup> To verify that Python evaluates the default arguments during compilation of the function, try executing the following:</p>

<pre><code>def bar(a=input('Did you just see me without calling the function?')): 
    pass  # use raw_input in Py2
</code></pre>

<p>as you'll notice, <code>input()</code> is called before the process of building the function and binding it to the name <code>bar</code> is made.</p>
<h4> das-g, Comment 59433843 Score: 1: </h4>Is <code>id(...)</code> needed for that last verification, or would the <code>is</code> operator answer the same question?<br><h4> Dimitris Fasarakis Hilliard, Comment 59434204 Score: 2: </h4>@das-g <code>is</code> would do just fine, I just used <code>id(val)</code> because I think it might be more intuitive.<br><h4> Brilliand, Comment 103227664 Score: 0: </h4>Using <code>None</code> as the default severely limits the usefulness of the <code>__defaults__</code> introspection, so I don&#39;t think that works well as a defense of having <code>__defaults__</code> work the way it does.  Lazy-evaluation would do more to keep function defaults useful from both sides.<br>------------------------------------------------------------------ <br><h3> Brian, Id: 1136611, Score: 71: </h3><p>I used to think that creating the objects at runtime would be the better approach.  I'm less certain now, since you do lose some useful features, though it may be worth it regardless simply to prevent newbie confusion.  The disadvantages of doing so are:</p>

<p><strong>1. Performance</strong></p>

<pre><code>def foo(arg=something_expensive_to_compute())):
    ...
</code></pre>

<p>If call-time evaluation is used, then the expensive function is called every time your function is used without an argument.  You'd either pay an expensive price on each call, or need to manually cache the value externally, polluting your namespace and adding verbosity.</p>

<p><strong>2. Forcing bound parameters</strong></p>

<p>A useful trick is to bind parameters of a lambda to the <em>current</em> binding of a variable when the lambda is created.  For example:</p>

<pre><code>funcs = [ lambda i=i: i for i in range(10)]
</code></pre>

<p>This returns a list of functions that return 0,1,2,3... respectively.  If the behaviour is changed, they will instead bind <code>i</code> to the <em>call-time</em> value of i, so you would get a list of functions that all returned <code>9</code>.</p>

<p>The only way to implement this otherwise would be to create a further closure with the i bound, ie:</p>

<pre><code>def make_func(i): return lambda: i
funcs = [make_func(i) for i in range(10)]
</code></pre>

<p><strong>3. Introspection</strong></p>

<p>Consider the code:</p>

<pre><code>def foo(a='test', b=100, c=[]):
   print a,b,c
</code></pre>

<p>We can get information about the arguments and defaults using the <code>inspect</code> module, which </p>

<pre><code>&gt;&gt;&gt; inspect.getargspec(foo)
(['a', 'b', 'c'], None, None, ('test', 100, []))
</code></pre>

<p>This information is very useful for things like document generation, metaprogramming, decorators etc.</p>

<p>Now, suppose the behaviour of defaults could be changed so that this is the equivalent of:</p>

<pre><code>_undefined = object()  # sentinel value

def foo(a=_undefined, b=_undefined, c=_undefined)
    if a is _undefined: a='test'
    if b is _undefined: b=100
    if c is _undefined: c=[]
</code></pre>

<p>However, we've lost the ability to introspect, and see what the default arguments <em>are</em>.  Because the objects haven't been constructed, we can't ever get hold of them without actually calling the function.  The best we could do is to store off the source code and return that as a string.</p>
<h4> Glenn Maynard, Comment 957188 Score: 4: </h4>A different language design often just means writing things differently.  Your first example could easily be written as: _expensive = expensive(); def foo(arg=_expensive), if you specifically <i>don&#39;t</i> want it reevaluated.<br><h4> Brian, Comment 954628 Score: 3: </h4>@yairchu: That assumes the construction is safe to so (ie has no side effects).  Introspecting the args shouldn&#39;t <i>do</i> anything, but evaluating arbitrary code could well end up having an effect.<br><h4> yairchu, Comment 954490 Score: 2: </h4>you could achieve introspection also if for each there was a function to create the default argument instead of a value. the inspect module will just call that function.<br><h4> Brian, Comment 957359 Score: 0: </h4>@Glenn - that&#39;s what I was referring to with &quot;cache the variable externally&quot; - it is a bit more verbose, and you end up with extra variables in your namespace though.<br><h4> Brian, Comment 957371 Score: 0: </h4>I think the comment problems are because they&#39;ve implented restricted markdown for comments, so your _ is being treated as italic.  <code>if this shows as code, then you can use backticks to prevent it</code><br><h4> Brian, Comment 957413 Score: 0: </h4>@SilentGhost: Actually, rereading that, I can see your point - I worded that pretty badly.  Edited to clarify my meaning.<br><h4> Marcin, Comment 14994331 Score: 0: </h4>In addition, to special-case this would add considerable complexity, especially in understanding the effect of inner function definitions.<br><h4> Brian, Comment 954611 Score: 0: </h4>@SilentGhost:  I&#39;m talking about if the behaviour was changed to recreate it - creating it once is the current behaviour, and why the mutable default problem exists.<br>------------------------------------------------------------------ <br><h3> Lutz Prechelt, Id: 29344819, Score: 65: </h3><h1>5 points in defense of Python</h1>
<ol>
<li><p><strong>Simplicity</strong>: The behavior is simple in the following sense:
Most people fall into this trap only once, not several times.</p>
</li>
<li><p><strong>Consistency</strong>: Python <em>always</em> passes objects, not names.
The default parameter is, obviously, part of the function
heading (not the function body). It therefore ought to be evaluated
at module load time (and only at module load time, unless nested), not
at function call time.</p>
</li>
<li><p><strong>Usefulness</strong>: As Frederik Lundh points out in his explanation
of <a href="https://web.archive.org/web/20201112004749/http://effbot.org/zone/default-values.htm" rel="noreferrer">&quot;Default Parameter Values in Python&quot;</a>, the
current behavior can be quite useful for advanced programming.
(Use sparingly.)</p>
</li>
<li><p><strong>Sufficient documentation</strong>: In the most basic Python documentation,
the tutorial, the issue is loudly announced as
an <strong>&quot;Important warning&quot;</strong> in the <em>first</em> subsection of Section
<a href="https://docs.python.org/3/tutorial/controlflow.html#default-argument-values" rel="noreferrer">&quot;More on Defining Functions&quot;</a>.
The warning even uses boldface,
which is rarely applied outside of headings.
RTFM: Read the fine manual.</p>
</li>
<li><p><strong>Meta-learning</strong>: Falling into the trap is actually a very
helpful moment (at least if you are a reflective learner),
because you will subsequently better understand the point
&quot;Consistency&quot; above and that will
teach you a great deal about Python.</p>
</li>
</ol>
<h4> oriadam, Comment 52693997 Score: 24: </h4>It took me a year to find this behavior is messing up my code on production, ended up removing a complete feature until I bumped into this design flaw by chance.  I&#39;m using Django.  Since the staging environment did not have many requests, this bug never had any impact on QA.  When we went live and received many simultaneous requests - some utility functions started overwriting each other&#39;s parameters!  Making security holes, bugs and what not.<br><h4> Wildcard, Comment 65774123 Score: 22: </h4>@oriadam, no offense, but I wonder how you learned Python without running into this before.  I am just learning Python now and this possible pitfall is <a href="https://docs.python.org/3/tutorial/controlflow.html#default-argument-values" rel="nofollow noreferrer">mentioned in the official Python tutorial</a> right alongside the first mention of default arguments.  (As mentioned in point 4 of this answer.)  I suppose the moral is—rather unsympathetically—to read the <b>official docs</b> of the language you use to create production software.<br><h4> Robin De Schepper, Comment 115930547 Score: 8: </h4>@oriadam, your company needs code review and actual expert coders in the language they write in by the time they have development, staging and production environments. Newbie bugs and bad code habits should not make it to production code<br><h4> Matthew Read, Comment 132089110 Score: 2: </h4>Senior coders cannot magically catch all bugs.  Code review is excellent and necessary, but don&#39;t pretend they can prevent &quot;newbie bugs&quot; from making it to production.  Even experts introduce such bugs themselves once in a while.<br><h4> Vatine, Comment 65920805 Score: 2: </h4>Also, it would be surprising (to me) if a function of unknown complexity was called in addition to the function call I am making.<br>------------------------------------------------------------------ <br><h3> ymv, Id: 1133375, Score: 58: </h3><p>This behavior is easy explained by:</p>

<ol>
<li>function (class etc.) declaration is executed only once, creating all default value objects</li>
<li>everything is passed by reference</li>
</ol>

<p>So:</p>

<pre><code>def x(a=0, b=[], c=[], d=0):
    a = a + 1
    b = b + [1]
    c.append(1)
    print a, b, c
</code></pre>

<ol>
<li><code>a</code> doesn't change - every assignment call creates new int object - new object is printed</li>
<li><code>b</code> doesn't change - new array is build from default value and printed</li>
<li><code>c</code> changes - operation is performed on same object - and it is printed</li>
</ol>
<h4> Anon, Comment 952500 Score: 0: </h4>(Actually, <b>add</b> is a bad example, but integers being immutable still is my main point.)<br><h4> Anon, Comment 952539 Score: 0: </h4>Realized it to my chagrin after checking to see that, with b set to [], b.__add__([1]) returns [1] but also leaves b still [] even though lists are mutable.  My bad.<br><h4> Veky, Comment 36118858 Score: 0: </h4>@ANon: there is <code>__iadd__</code>, but it doesn&#39;t work with int. Of course. :-)<br>------------------------------------------------------------------ <br><h3> hynekcer, Id: 13518071, Score: 43: </h3><p>1)  The so-called problem of "Mutable Default Argument" is in general a special example demonstrating that:<br>
"All functions with this problem <strong>suffer also from similar side effect problem on the actual parameter</strong>,"<br>
That is against the rules of functional programming, usually undesiderable and should be fixed both together.</p>

<p>Example:</p>

<pre><code>def foo(a=[]):                 # the same problematic function
    a.append(5)
    return a

&gt;&gt;&gt; somevar = [1, 2]           # an example without a default parameter
&gt;&gt;&gt; foo(somevar)
[1, 2, 5]
&gt;&gt;&gt; somevar
[1, 2, 5]                      # usually expected [1, 2]
</code></pre>

<p><strong>Solution</strong>:  a <strong>copy</strong><br>
An absolutely safe solution is to <strong><code>copy</code></strong> or <strong><code>deepcopy</code></strong> the input object first and then to do whatever with the copy.</p>

<pre><code>def foo(a=[]):
    a = a[:]     # a copy
    a.append(5)
    return a     # or everything safe by one line: "return a + [5]"
</code></pre>

<p>Many builtin mutable types have a copy method like <code>some_dict.copy()</code> or <code>some_set.copy()</code> or can be copied easy like <code>somelist[:]</code> or <code>list(some_list)</code>. Every object can be also copied by <code>copy.copy(any_object)</code> or more thorough by <code>copy.deepcopy()</code> (the latter useful if the mutable object is composed from mutable objects). Some objects are fundamentally based on side effects like "file" object and can not be meaningfully reproduced by copy. <a href="http://effbot.org/pyfaq/how-do-i-copy-an-object-in-python.htm" rel="noreferrer">copying</a></p>

<p>Example problem for <a href="https://stackoverflow.com/q/13484107/448474">a similar SO question</a></p>

<pre><code>class Test(object):            # the original problematic class
  def __init__(self, var1=[]):
    self._var1 = var1

somevar = [1, 2]               # an example without a default parameter
t1 = Test(somevar)
t2 = Test(somevar)
t1._var1.append([1])
print somevar                  # [1, 2, [1]] but usually expected [1, 2]
print t2._var1                 # [1, 2, [1]] but usually expected [1, 2]
</code></pre>

<p>It shouldn't be neither saved in any <em>public</em> attribute of an instance returned by this function. (Assuming that <em>private</em> attributes of instance should not be modified from outside of this class or subclasses by convention. i.e. <code>_var1</code> is a private attribute )</p>

<p>Conclusion:<br>
Input parameters objects shouldn't be modified in place (mutated) nor they should not be binded into an object returned by the function. (If we prefere programming without side effects which is strongly recommended. see <a href="http://en.wikipedia.org/wiki/Side_effect_%28computer_science%29" rel="noreferrer">Wiki about "side effect"</a> (The first two paragraphs are relevent in this context.)
.)</p>

<p>2)<br>
Only if the side effect on the actual parameter is required but unwanted on the default parameter then the useful solution is <code>def ...(var1=None):</code> <code>if var1 is None:</code> <code>var1 = []</code> <a href="http://effbot.org/zone/default-values.htm#what-to-do-instead" rel="noreferrer">More..</a></p>

<p>3) In some cases is <a href="http://effbot.org/zone/default-values.htm#valid-uses-for-mutable-defaults" rel="noreferrer">the mutable behavior of default parameters useful</a>.</p>
<h4> hynekcer, Comment 36126140 Score: 11: </h4>Yes, Python is a multi-paragigm language with some functional features. (&quot;Don&#39;t make every problem look like a nail just because you have a hammer.&quot;) Many of them are in Python best practicies. Python has an interesting <a href="https://docs.python.org/2/howto/functional.html" rel="nofollow noreferrer">HOWTO Functional Programming</a> Other features are closures and currying, not mentioned here.<br><h4> Veky, Comment 36118939 Score: 7: </h4>I hope you&#39;re aware that Python is <i>not</i> a functional programming language.<br><h4> holdenweb, Comment 83550760 Score: 4: </h4>I&#39;d also add, at this late stage, that Python&#39;s assignment semantics have been designed explicitly to avoid data copying where necessary, so the creation of copies (and especially of deep copies) will affect both run-time and memory usage adversely. They should therefore be used only when necessary, but newcomers often have difficulty understanding when that is.<br><h4> hynekcer, Comment 84730659 Score: 2: </h4>@holdenweb My answer was about what interesting was missing in other answers. I hope that everybody who reads it, says: &quot;Wow, a solution exists even for forgetful obsessed programmers even in more complicated cases, but I prefer ... I&#39;m making a resolution to not modify parameters unexpectedly,&quot; Also you wrote in another comment &quot;rebinding that name guarantees it can never be modified.&quot; (you meant rebinding also individual items) Diligence or copying is an acceptable price for freedom in Python and I like it.<br><h4> hynekcer, Comment 119502574 Score: 1: </h4>@MartinKealey A mutable default value is the only place there a function can hold a modified status between calls. Don&#39;t think about it in advance like about a bug in the language because many features in Python can be more dynamic than in other languages. One general respected rule in Python programming is that a mutable default argument should not be used unless you want to preserve some information in that mutable object between calls or you prevent that the default value can not be modified unintentionally. That&#39;s easy. Languages have different paradigms.<br><h4> holdenweb, Comment 84724683 Score: 1: </h4>You can always find pathological cases. If you need a complex structure you have little alternative but to re-create or copy it each time. Python encourages the programmer to adopt practical solutions (in my opinion). There are better languages for functional purists.<br><h4> holdenweb, Comment 84724707 Score: 1: </h4>By the way, PEP8 recommends omitting the spaces for &quot;keyword&quot; arguments, as in <code>def f(x=None)</code>.<br><h4> hynekcer, Comment 83606638 Score: 1: </h4>@holdenweb I agree. A temporary copy is the most usual way and sometimes the only possible way how to protect the original mutable data from an extraneous function that modifies them potentially. Fortunately a function that unreasonably modifies data is considered a bug and therefore uncommon.<br><h4> koddo, Comment 84665509 Score: 0: </h4>I agree with this answer. And I don&#39;t understand why the <code>def f( a = None )</code> construct is recommended when you really mean something else. Copying is ok, because you shouldn&#39;t mutate arguments. And when you do <code>if a is None: a = [1, 2, 3]</code>, you do copy the list anyway.<br><h4> hynekcer, Comment 84671142 Score: 0: </h4>@koddo I wrote &quot;useful&quot; only, not generalized to &quot;recommended&quot;. Immutable default values of the same type are also useful. A different type like <code>some_list=()</code> would be more unexpected. If an optional parameter with a nonzero default value is added instead of some original constant, e.g. max_iterations=10 then you can be tempted to copy the same default value to the header of another function that calls it. If you expect the original default  could be changed later and you want consistency, then the default=None is better and leave the responsibility for value to the body of the function.<br><h4> koddo, Comment 84686074 Score: 0: </h4>@hynekcer, I&#39;m sorry, we have a misunderstanding here. I don&#39;t mean you, I mean every other answer and blog post recommends <code>def f(x = None)</code> and never discusses <code>x = copy(x)</code>. I think, while the former has its own uses, it&#39;s not the first thing that should be mentioned. Again, I agree with your answer and I upvoted it.<br><h4> koddo, Comment 84686252 Score: 0: </h4>@holdenweb, what happens when the code has <code>if x is None: x = { a deeply nested structure here }</code>? Isn&#39;t the structure deepcopied anyway from somewhere to be bound to <code>x</code> every time the func called with the default <code>x = None</code>?<br><h4> koddo, Comment 84686362 Score: 0: </h4>@holdenweb, addition to the previous comment: it gets constructed, not deepcopied, but semantically and performance-wise, is there a difference?<br><h4> Martin Kealey, Comment 119499276 Score: 0: </h4>It seems to me that combining &quot;an array value is a reference to a mutable array container&quot; with &quot;designed to avoid copying&quot; was perhaps a premature optimisation. In true functional languages the compiler can infer when it&#39;s necessary to make a copy. I like how C++ does everything as logical &quot;copies&quot; but allows you to create constructors that defer actually copying until strictly necessary.<br>------------------------------------------------------------------ <br><h3> Glenn Maynard, Id: 1133737, Score: 42: </h3><p>What you're asking is why this:</p>

<pre><code>def func(a=[], b = 2):
    pass
</code></pre>

<p>isn't internally equivalent to this:</p>

<pre><code>def func(a=None, b = None):
    a_default = lambda: []
    b_default = lambda: 2
    def actual_func(a=None, b=None):
        if a is None: a = a_default()
        if b is None: b = b_default()
    return actual_func
func = func()
</code></pre>

<p>except for the case of explicitly calling func(None, None), which we'll ignore.</p>

<p>In other words, instead of evaluating default parameters, why not store each of them, and evaluate them when the function is called?</p>

<p>One answer is probably right there--it would effectively turn every function with default parameters into a closure.  Even if it's all hidden away in the interpreter and not a full-blown closure, the data's got to be stored somewhere.  It'd be slower and use more memory.</p>
<h4> Lennart Regebro, Comment 954824 Score: 11: </h4>True, but it would still slow Python down, and it would actually be quite surprising, unless you do the same for class definitions, which would make it stupidly slow as you would have to re-run the whole class definition each time you instantiate a class.  As mentioned, the fix would be more surprising than the problem.<br><h4> Brian, Comment 954338 Score: 10: </h4>It wouldn&#39;t need to be a closure - a better way to think of it would simply to make the bytecode creating defaults the first line of code - after all you&#39;re compiling the body at that point anyway - there&#39;s no real difference between code in the arguments and code in the body.<br><h4> Glenn Maynard, Comment 957116 Score: 9: </h4>Changing it now would be insanity--we&#39;re just exploring why it is the way it is.  If it did late default evaluation to begin with, it wouldn&#39;t necessarily be surprising.  It&#39;s definitely true that such a core a difference of parsing would have sweeping, and probably many obscure, effects on the language as a whole.<br><h4> Jason Baker, Comment 955297 Score: 0: </h4>Agreed with Lennart.  As Guido is fond of saying, for every language feature or standard library, there&#39;s <i>someone</i> out there using it.<br>------------------------------------------------------------------ <br><h3> Ben, Id: 6092808, Score: 34: </h3><p>This actually has nothing to do with default values, other than that it often comes up as an unexpected behaviour when you write functions with mutable default values.</p>

<pre><code>&gt;&gt;&gt; def foo(a):
    a.append(5)
    print a

&gt;&gt;&gt; a  = [5]
&gt;&gt;&gt; foo(a)
[5, 5]
&gt;&gt;&gt; foo(a)
[5, 5, 5]
&gt;&gt;&gt; foo(a)
[5, 5, 5, 5]
&gt;&gt;&gt; foo(a)
[5, 5, 5, 5, 5]
</code></pre>

<p>No default values in sight in this code, but you get exactly the same problem.</p>

<p>The problem is that <code>foo</code> is <em>modifying</em> a mutable variable passed in from the caller, when the caller doesn't expect this. Code like this would be fine if the function was called something like <code>append_5</code>; then the caller would be calling the function in order to modify the value they pass in, and the behaviour would be expected. But such a function would be very unlikely to take a default argument, and probably wouldn't return the list (since the caller already has a reference to that list; the one it just passed in).</p>

<p>Your original <code>foo</code>, with a default argument, shouldn't be modifying <code>a</code> whether it was explicitly passed in or got the default value. Your code should leave mutable arguments alone unless it is clear from the context/name/documentation that the arguments are supposed to be modified. Using mutable values passed in as arguments as local temporaries is an extremely bad idea, whether we're in Python or not and whether there are default arguments involved or not.</p>

<p>If you need to destructively manipulate a local temporary in the course of computing something, and you need to start your manipulation from an argument value, you need to make a copy.</p>
<h4> Andy Hayden, Comment 16186544 Score: 10: </h4>Although related, I think this is distinct behaviour (as we expect <code>append</code> to change <code>a</code> &quot;in-place&quot;). That a <b>default mutable is not re-instantiated on each call</b> is the &quot;unexpected&quot; bit... at least for me. :)<br><h4> Mark Ransom, Comment 80529225 Score: 3: </h4>@AndyHayden if the function is <i>expected</i> to modify the argument, why would it make sense to have a default?<br><h4> Ben, Comment 80546281 Score: 2: </h4>@AndyHayden The point of my answer is that if you are ever astonished by accidentally mutating the default value of an argument, then you have another bug, which is that your code can accidentally mutate a caller&#39;s value when the default <i>wasn&#39;t</i> used. And note that using <code>None</code> and assigning the real default if the arg is <code>None</code> <i>does not resolve that problem</i> (I consider it an anti pattern for that reason). If you fix the other bug by avoiding mutating argument values whether or not they have defaults then you&#39;ll never notice or care about this &quot;astonishing&quot; behavior.<br><h4> Ben, Comment 80549269 Score: 1: </h4>@AndyHayden And if you&#39;re putting <code>self.foo = foo.copy()</code> in there anyway, what harm is it if the default value for <code>foo</code> is <code>[]</code>? It&#39;s the <b>copy</b> that protects you from mutable argument woes, not setting the default to <code>None</code> when you really want a default of <code>[]</code>. Sure you <i>could</i> write <code>if foo is None: self.foo = []; else: self.foo = foo.copy()</code>, but why when you could replace 4 lines with a single line (which is one of the 4 you need anyway), <i>and</i> have the real value of the default argument be clearer in the function definition?<br><h4> Ben, Comment 80548974 Score: 1: </h4>@AndyHayden That&#39;s the subtle thing though, what happens in the case you describe if the caller of the constructor provides a value instead of using the default? Now you&#39;ve gone and aliased your object&#39;s internal attribute to an external value owned by the caller! That sort of thing is a very rich source of hard-to-track-down bugs; it&#39;s almost <i>worse</i> than accidentally storing the default value and then mutating it (since that at least should show head-scratching behaviour pretty soon, if you instantiate the class more than once).<br><h4> Mark Ransom, Comment 80539521 Score: 1: </h4>@AndyHayden I left my own answer here with an expansion of that sentiment. Let me know what you think. I might add your example of <code>cache={}</code> into it for completeness.<br><h4> Andy Hayden, Comment 80549198 Score: 0: </h4>@Ben you make a copy! I mean, sure you could mutate but that&#39;s a bug. BTW I am thinking of pandas dataframe/series constructors e.g. where you can optionally pass an index or columns (where if not passed pandas essentially/previously uses <code>list(range(n))</code>.<br><h4> Andy Hayden, Comment 80548810 Score: 0: </h4>@Ben 100% you shouldn&#39;t mutate optional arguments. I think the only legitimate usage of <code>None</code> that I&#39;ve seen is in a constructor, where you want a mutable attribute (but don&#39;t want it to be shared across all classes), of course you can <code>.copy()</code> before setting it so that it can&#39;t mutate the original.<br><h4> Andy Hayden, Comment 80539303 Score: 0: </h4>@MarkRansom the only example I can think of is <code>cache={}</code>. However, I suspect this &quot;least astonishment&quot; comes up is when you <i>don&#39;t</i> expect (or want) the function you&#39;re calling to mutate the argument.<br><h4> Andy Hayden, Comment 80551926 Score: 0: </h4>@Ben The harm - as usual - is programmer-error! You can&#39;t rely on the language to do &quot;the right thing&quot;. If you&#39;re writing a library that&#39;s especially a concern. If, for example, it was an list-like you could smash it with <code>list(foo) = foo</code> as the first line, this would guarantee it wasn&#39;t mutated BUT it might be a performance hit you were unwilling to take (e.g. if it was a numpy array and hitting it with list could OOM).<br><h4> Andy Hayden, Comment 80551943 Score: 0: </h4>@Ben In that case you could do <code>self.foo = foo.copy() if foo else []</code> :P<br>------------------------------------------------------------------ <br><h3> Russia Must Remove Putin, Id: 36968932, Score: 33: </h3><h1>Python: The Mutable Default Argument</h1>
<p>Default arguments get evaluated at the time the function is compiled into a function object, at the start of the program runtime. When used by the function, multiple times by that function, they are and remain the same object in memory, and when mutated (if the object is of a mutable type) they remain mutated on consecutive calls.</p>
<p>They are mutated and stay mutated because they are the same object each time the function is called.</p>
<h2>Equivalent code:</h2>
<p>Since the list is bound to the function when the function object is compiled and instantiated, this:</p>
<pre><code>def foo(mutable_default_argument=[]): # make a list the default argument
    &quot;&quot;&quot;function that uses a list&quot;&quot;&quot;
</code></pre>
<p>is almost exactly equivalent to this:</p>
<pre><code>_a_list = [] # create a list in the globals

def foo(mutable_default_argument=_a_list): # make it the default argument
    &quot;&quot;&quot;function that uses a list&quot;&quot;&quot;

del _a_list # remove globals name binding
</code></pre>
<h2>Demonstration</h2>
<p>Here's a demonstration - you can verify that they are the same object each time they are referenced by</p>
<ul>
<li>seeing that the list is created before the function has finished compiling to a function object,</li>
<li>observing that the id is the same each time the list is referenced,</li>
<li>observing that the list stays changed when the function that uses it is called a second time,</li>
<li>observing the order in which the output is printed from the source (which I conveniently numbered for you):</li>
</ul>
<p><code>example.py</code></p>
<pre><code>print('1. Global scope being evaluated')

def create_list():
    '''noisily create a list for usage as a kwarg'''
    l = []
    print('3. list being created and returned, id: ' + str(id(l)))
    return l

print('2. example_function about to be compiled to an object')

def example_function(default_kwarg1=create_list()):
    print('appending &quot;a&quot; in default default_kwarg1')
    default_kwarg1.append(&quot;a&quot;)
    print('list with id: ' + str(id(default_kwarg1)) + 
          ' - is now: ' + repr(default_kwarg1))

print('4. example_function compiled: ' + repr(example_function))


if __name__ == '__main__':
    print('5. calling example_function twice!:')
    example_function()
    example_function()
</code></pre>
<p>and running it with <code>python example.py</code>:</p>
<pre><code>1. Global scope being evaluated
2. example_function about to be compiled to an object
3. list being created and returned, id: 140502758808032
4. example_function compiled: &lt;function example_function at 0x7fc9590905f0&gt;
5. calling example_function twice!:
appending &quot;a&quot; in default default_kwarg1
list with id: 140502758808032 - is now: ['a']
appending &quot;a&quot; in default default_kwarg1
list with id: 140502758808032 - is now: ['a', 'a']
</code></pre>
<h2>Does this violate the principle of &quot;Least Astonishment&quot;?</h2>
<p>This order of execution is frequently confusing to new users of Python. If you understand the Python execution model, then it becomes quite expected.</p>
<h2>The usual instruction to new Python users:</h2>
<p>But this is why the usual instruction to new users is to create their default arguments like this instead:</p>
<pre><code>def example_function_2(default_kwarg=None):
    if default_kwarg is None:
        default_kwarg = []
</code></pre>
<p>This uses the None singleton as a sentinel object to tell the function whether or not we've gotten an argument other than the default. If we get no argument, then we actually want to use a new empty list, <code>[]</code>, as the default.</p>
<p>As the <a href="https://docs.python.org/tutorial/controlflow.html#default-argument-values" rel="nofollow noreferrer">tutorial section on control flow</a> says:</p>
<blockquote>
<p>If you don’t want the default to be shared between subsequent calls,
you can write the function like this instead:</p>
<pre><code>def f(a, L=None):
    if L is None:
        L = []
    L.append(a)
    return L
</code></pre>
</blockquote>
------------------------------------------------------------------ <br><h3> Baczek, Id: 1137164, Score: 29: </h3><p>The shortest answer would probably be "definition is execution", therefore the whole argument makes no strict sense. As a more contrived example, you may cite this:</p>

<pre><code>def a(): return []

def b(x=a()):
    print x
</code></pre>

<p>Hopefully it's enough to show that not executing the default argument expressions at the execution time of the <code>def</code> statement isn't easy or doesn't make sense, or both.</p>

<p>I agree it's a gotcha when you try to use default constructors, though.</p>
------------------------------------------------------------------ <br><h3> St&#233;phane, Id: 29290566, Score: 29: </h3><p>Already busy topic, but from what I read here, the following helped me realizing how it's working internally:</p>

<pre><code>def bar(a=[]):
     print id(a)
     a = a + [1]
     print id(a)
     return a

&gt;&gt;&gt; bar()
4484370232
4484524224
[1]
&gt;&gt;&gt; bar()
4484370232
4484524152
[1]
&gt;&gt;&gt; bar()
4484370232 # Never change, this is 'class property' of the function
4484523720 # Always a new object 
[1]
&gt;&gt;&gt; id(bar.func_defaults[0])
4484370232
</code></pre>
<h4> J&#246;rn Hees, Comment 73656522 Score: 4: </h4>actually this might be a bit confusing for newcomers as <code>a = a + [1]</code> overloads <code>a</code>... consider changing it to <code>b = a + [1] ; print id(b)</code> and add a line <code>a.append(2)</code>. That will make it more obvious that <code>+</code> on two lists always creates a new list (assigned to <code>b</code>), while a modified <code>a</code> can still have the same <code>id(a)</code>.<br>------------------------------------------------------------------ <br><h3> Jason Baker, Id: 1134613, Score: 28: </h3><p>It's a performance optimization.  As a result of this functionality, which of these two function calls do you think is faster?</p>

<pre><code>def print_tuple(some_tuple=(1,2,3)):
    print some_tuple

print_tuple()        #1
print_tuple((1,2,3)) #2
</code></pre>

<p>I'll give you a hint.  Here's the disassembly (see <a href="http://docs.python.org/library/dis.html" rel="noreferrer">http://docs.python.org/library/dis.html</a>):</p>

<h1><code>#</code>1</h1>

<pre><code>0 LOAD_GLOBAL              0 (print_tuple)
3 CALL_FUNCTION            0
6 POP_TOP
7 LOAD_CONST               0 (None)
10 RETURN_VALUE
</code></pre>

<h1><code>#</code>2</h1>

<pre><code> 0 LOAD_GLOBAL              0 (print_tuple)
 3 LOAD_CONST               4 ((1, 2, 3))
 6 CALL_FUNCTION            1
 9 POP_TOP
10 LOAD_CONST               0 (None)
13 RETURN_VALUE
</code></pre>

<blockquote>
  <p>I doubt the experienced behavior has a practical use (who really used static variables in C, without breeding bugs ?)</p>
</blockquote>

<p>As you can see, there <em>is</em> a performance benefit when using immutable default arguments.  This can make a difference if it's a frequently called function or the default argument takes a long time to construct.  Also, bear in mind that Python isn't C.  In C you have constants that are pretty much free.  In Python you don't have this benefit.</p>
------------------------------------------------------------------ <br><h3> Dmitry Minkovsky, Id: 10304917, Score: 25: </h3><p>This behavior is not surprising if you take the following into consideration:</p>
<ol>
<li>The behavior of read-only class attributes upon assignment attempts, and that</li>
<li>Functions are objects (explained well in the accepted answer).</li>
</ol>
<p>The role of <strong>(2)</strong> has been covered extensively in this thread. <strong>(1)</strong> is likely the astonishment causing factor, as this behavior is not &quot;intuitive&quot; when coming from other languages.</p>
<p><strong>(1)</strong> is described in the Python <a href="http://docs.python.org/tutorial/classes.html" rel="noreferrer">tutorial on classes</a>. In an attempt to assign a value to a read-only class attribute:</p>
<blockquote>
<p>...all variables found outside of the innermost scope are
read-only (<em><strong>an attempt to write to such a variable will simply create a
new local variable in the innermost scope, leaving the identically
named outer variable unchanged</strong></em>).</p>
</blockquote>
<p>Look back to the original example and consider the above points:</p>
<pre><code>def foo(a=[]):
    a.append(5)
    return a
</code></pre>
<p>Here <code>foo</code> is an object and <code>a</code> is an attribute of <code>foo</code> (available at <code>foo.func_defs[0]</code>). Since <code>a</code> is a list, <code>a</code> is mutable and is thus a read-write attribute of <code>foo</code>. It is initialized to the empty list as specified by the signature when the function is instantiated, and is available for reading and writing as long as the function object exists.</p>
<p>Calling <code>foo</code> without overriding a default uses that default's value from <code>foo.func_defs</code>. In this case, <code>foo.func_defs[0]</code> is used for <code>a</code> within function object's code scope. Changes to <code>a</code> change <code>foo.func_defs[0]</code>, which is part of the <code>foo</code> object and persists between execution of the code in <code>foo</code>.</p>
<p>Now, compare this to the example from the documentation on <a href="http://docs.python.org/tutorial/controlflow.html#default-argument-values" rel="noreferrer">emulating the default argument behavior of other languages</a>, such that the function signature defaults are used every time the function is executed:</p>
<pre><code>def foo(a, L=None):
    if L is None:
        L = []
    L.append(a)
    return L
</code></pre>
<p>Taking <strong>(1)</strong> and <strong>(2)</strong> into account, one can see why this accomplishes the desired behavior:</p>
<ul>
<li>When the <code>foo</code> function object is instantiated, <code>foo.func_defs[0]</code> is set to <code>None</code>, an immutable object.</li>
<li>When the function is executed with defaults (with no parameter specified for <code>L</code> in the function call), <code>foo.func_defs[0]</code> (<code>None</code>) is available in the local scope as <code>L</code>.</li>
<li>Upon <code>L = []</code>, the assignment cannot succeed at <code>foo.func_defs[0]</code>, because that attribute is read-only.</li>
<li>Per <strong>(1)</strong>, <em><strong>a new local variable also named <code>L</code> is created in the local scope</strong></em> and used for the remainder of the function call. <code>foo.func_defs[0]</code> thus remains unchanged for future invocations of <code>foo</code>.</li>
</ul>
------------------------------------------------------------------ <br><h3> Christos Hayward, Id: 1139730, Score: 22: </h3><p>It may be true that:</p>

<ol>
<li>Someone is using every language/library feature, and</li>
<li>Switching the behavior here would be ill-advised, but</li>
</ol>

<p>it is entirely consistent to hold to both of the features above and still make another point:</p>

<ol start="3">
<li>It is a confusing feature and it is unfortunate in Python.</li>
</ol>

<p>The other answers, or at least some of them either make points 1 and 2 but not 3, or make point 3 and downplay points 1 and 2. <strong>But all three are true.</strong></p>

<p>It may be true that switching horses in midstream here would be asking for significant breakage, and that there could be more problems created by changing Python to intuitively handle Stefano's opening snippet. And it may be true that someone who knew Python internals well could explain a minefield of consequences. <em>However,</em></p>

<p>The existing behavior is not Pythonic, and Python is successful because very little about the language violates the principle of least astonishment anywhere <em>near</em> this badly. It is a real problem, whether or not it would be wise to uproot it. It is a design flaw. If you understand the language much better by trying to trace out the behavior, I can say that C++ does all of this and more; you learn a lot by navigating, for instance, subtle pointer errors. But this is not Pythonic: people who care about Python enough to persevere in the face of this behavior are people who are drawn to the language because Python has far fewer surprises than other language. Dabblers and the curious become Pythonistas when they are astonished at how little time it takes to get something working--not because of a design fl--I mean, hidden logic puzzle--that cuts against the intuitions of programmers who are drawn to Python because it <strong>Just Works</strong>.</p>
<h4> Marcin, Comment 14994287 Score: 7: </h4>-1 Although a defensible perspective, this not an answer, <b>and</b> I disagree with it. Too many special exceptions beget their own corner cases.<br><h4> Christos Hayward, Comment 19435546 Score: 6: </h4>So then, it is &quot;amazingly ignorant&quot; to say that in Python it would make more sense for a default argument of [] to remain [] every time the function is called?<br><h4> Christos Hayward, Comment 19436087 Score: 5: </h4>But in Python, part of the spirit of the language is that you don&#39;t have to take too many deep dives; array.sort() works, and works  regardless of how little you understand about sorting, big-O, and constants. The beauty of Python in the array sorting mechanism, to give one of innumerable examples, is that you are not required to take a deep dive into internals. And to say it differently, the beauty of Python is that one is not ordinarily required to take a deep dive into implementation to get something that Just Works. And there is a workaround (...if argument == None: argument = []), FAIL.<br><h4> Jerry B, Comment 28401661 Score: 4: </h4>As a standalone, the statement <code>x=[]</code> means &quot;create an empty list object, and bind the name &#39;x&#39; to it.&quot;  So, in <code>def f(x=[])</code>, an empty list is also created.  It doesn&#39;t always get bound to x, so instead it gets bound to the default surrogate.  Later when f() is called, the default is hauled out and bound to x.  Since it was the empty list itself that was squirreled away, that same list is the only thing available to bind to x, whether anything has been stuck inside it or not.  How could it be otherwise?<br><h4> Christos Hayward, Comment 19435596 Score: 4: </h4>And it is ignorant to consider as an unfortunate idiom setting a default argument to None, and then in the body of the body of the function setting if argument == None: argument = []? Is it ignorant to consider this idiom unfortunate as often people want what a naive newcomer would expect, that if you assign f(argument = []), argument will automatically default to a value of []?<br><h4> Rob Grant, Comment 43896730 Score: 2: </h4>@JerryB the argued less surprising behaviour is simply to create an empty list object each time the default argument is needed, rather than keep the same one around and haul it out each time. Not sure why you&#39;re saying compile the text is necessary (what text?); surely the practical implementation could be churned out in bytecode.<br><h4> Clement Cherlin, Comment 119880193 Score: 1: </h4>@JerryB &quot;How could it be otherwise?&quot; Easily. The effect of a default argument is to create a closure <i>either way it is implemented</i>. Binding a default value to a function argument is creating a kind of closure. Binding a default initializer to a function argument is creating a different kind of closure. Claiming that the current implementation is the only conceivable one is to claim that all the people who are baffled by it <i>don&#39;t exist</i>, and neither do all the languages that implement it differently.<br><h4> Christos Hayward, Comment 19436037 Score: 1: </h4>In C, it is arguably not a FAIL for a main() with &#39;int a; scanf(&quot;%d&quot;, a);&#39; to crash; the answer involves a dive into internals and an explanation that pass by reference is achieved by an (arguably surrogate) use of pointers. And in Tcl, it is arguably not a FAIL that things do not work in &#39;{[...]}&#39; that work everywhere else; in both cases the answer is, &quot;Take a deep dive into internals, deeper than you understand now.&quot;<br><h4> Jerry B, Comment 43928154 Score: 0: </h4>Turning the text <code>x=[]</code> into byte code <b>is</b> compiling.  And that code will have to be executed for any default value that isn&#39;t an immutable literal (anything that doesn&#39;t <b>provably</b> give the same result every time it&#39;s executed).<br><h4> Jerry B, Comment 28401675 Score: 0: </h4>To achieve what you want, you&#39;d have to save the <b>text</b> of the default value, and compile and execute it each each time the function is called, or compile the text and execute it for each call.  The overhead for every call would be horrendous, multiplied by the number of default arguments.  And a <b>lot</b> of the standard library functions have several defaults.  <b>And</b> the results would depend on the context the call is made in, not the context the function was defined in.<br><h4> Flimm, Comment 126670640 Score: 0: </h4>Interestingly, Python developers are considering introducing new syntax to support late-bound default arguments: <a href="https://lwn.net/Articles/875441/" rel="nofollow noreferrer">lwn.net/Articles/875441</a><br>------------------------------------------------------------------ <br><h3> hugo24, Id: 15133978, Score: 22: </h3><p>A simple workaround using None</p>

<pre><code>&gt;&gt;&gt; def bar(b, data=None):
...     data = data or []
...     data.append(b)
...     return data
... 
&gt;&gt;&gt; bar(3)
[3]
&gt;&gt;&gt; bar(3)
[3]
&gt;&gt;&gt; bar(3)
[3]
&gt;&gt;&gt; bar(3, [34])
[34, 3]
&gt;&gt;&gt; bar(3, [34])
[34, 3]
</code></pre>
<h4> Flimm, Comment 126670851 Score: 0: </h4>This isn&#39;t an answer to the question.<br>------------------------------------------------------------------ <br><h3> Alexander, Id: 32535706, Score: 20: </h3><p>I am going to demonstrate an alternative structure to pass a default list value to a function (it works equally well with dictionaries).  </p>

<p>As others have extensively commented, the list parameter is bound to the function when it is defined as opposed to when it is executed.  Because lists and dictionaries are mutable, any alteration to this parameter will affect other calls to this function.  As a result, subsequent calls to the function will receive this shared list which may have been altered by any other calls to the function.  Worse yet, two parameters are using this function's shared parameter at the same time oblivious to the changes made by the other.</p>

<p><strong>Wrong Method (probably...)</strong>:</p>

<pre><code>def foo(list_arg=[5]):
    return list_arg

a = foo()
a.append(6)
&gt;&gt;&gt; a
[5, 6]

b = foo()
b.append(7)
# The value of 6 appended to variable 'a' is now part of the list held by 'b'.
&gt;&gt;&gt; b
[5, 6, 7]  

# Although 'a' is expecting to receive 6 (the last element it appended to the list),
# it actually receives the last element appended to the shared list.
# It thus receives the value 7 previously appended by 'b'.
&gt;&gt;&gt; a.pop()             
7
</code></pre>

<p>You can verify that they are one and the same object by using <code>id</code>:</p>

<pre><code>&gt;&gt;&gt; id(a)
5347866528

&gt;&gt;&gt; id(b)
5347866528
</code></pre>

<p>Per Brett Slatkin's "Effective Python: 59 Specific Ways to Write Better Python", <em>Item 20: Use <code>None</code> and Docstrings to specify dynamic default arguments</em> (p. 48)</p>

<blockquote>
  <p>The convention for achieving the desired result in Python is to
  provide a default value of <code>None</code> and to document the actual behaviour
  in the docstring.</p>
</blockquote>

<p>This implementation ensures that each call to the function either receives the default list or else the list passed to the function.</p>

<p><strong>Preferred Method</strong>:</p>

<pre><code>def foo(list_arg=None):
   """
   :param list_arg:  A list of input values. 
                     If none provided, used a list with a default value of 5.
   """
   if not list_arg:
       list_arg = [5]
   return list_arg

a = foo()
a.append(6)
&gt;&gt;&gt; a
[5, 6]

b = foo()
b.append(7)
&gt;&gt;&gt; b
[5, 7]

c = foo([10])
c.append(11)
&gt;&gt;&gt; c
[10, 11]
</code></pre>

<p>There may be legitimate use cases for the 'Wrong Method' whereby the programmer intended the default list parameter to be shared, but this is more likely the exception than the rule.</p>
------------------------------------------------------------------ <br><h3> Marcin, Id: 9791799, Score: 17: </h3><p>The solutions here are:</p>

<ol>
<li>Use <code>None</code> as your default value (or a nonce <code>object</code>), and switch on that to create your values at runtime; or</li>
<li>Use a <code>lambda</code> as your default parameter, and call it within a try block to get the default value (this is the sort of thing that lambda abstraction is for).</li>
</ol>

<p>The second option is nice because users of the function can pass in a callable, which may be already existing (such as a <code>type</code>)</p>
<h4> Flimm, Comment 126670870 Score: 1: </h4>This doesn&#39;t answer the question.<br>------------------------------------------------------------------ <br><h3> Saish, Id: 25797695, Score: 16: </h3><p>When we do this:</p>

<pre><code>def foo(a=[]):
    ...
</code></pre>

<p>... we assign the argument <code>a</code> to an <em>unnamed</em> list, if the caller does not pass the value of a.</p>

<p>To make things simpler for this discussion, let's temporarily give the unnamed list a name. How about <code>pavlo</code> ?</p>

<pre><code>def foo(a=pavlo):
   ...
</code></pre>

<p>At any time, if the caller doesn't tell us what <code>a</code> is, we reuse <code>pavlo</code>.</p>

<p>If <code>pavlo</code> is mutable (modifiable), and <code>foo</code> ends up modifying it, an effect we notice the next time <code>foo</code> is called without specifying <code>a</code>.</p>

<p>So this is what you see (Remember, <code>pavlo</code> is initialized to []):</p>

<pre><code> &gt;&gt;&gt; foo()
 [5]
</code></pre>

<p>Now, <code>pavlo</code> is [5].</p>

<p>Calling <code>foo()</code> again modifies <code>pavlo</code> again:</p>

<pre><code>&gt;&gt;&gt; foo()
[5, 5]
</code></pre>

<p>Specifying <code>a</code> when calling <code>foo()</code> ensures <code>pavlo</code> is not touched.</p>

<pre><code>&gt;&gt;&gt; ivan = [1, 2, 3, 4]
&gt;&gt;&gt; foo(a=ivan)
[1, 2, 3, 4, 5]
&gt;&gt;&gt; ivan
[1, 2, 3, 4, 5]
</code></pre>

<p>So, <code>pavlo</code> is still <code>[5, 5]</code>.</p>

<pre><code>&gt;&gt;&gt; foo()
[5, 5, 5]
</code></pre>
------------------------------------------------------------------ <br><h3> bgreen-litl, Id: 28354667, Score: 16: </h3><p>I sometimes exploit this behavior as an alternative to the following pattern:</p>

<pre><code>singleton = None

def use_singleton():
    global singleton

    if singleton is None:
        singleton = _make_singleton()

    return singleton.use_me()
</code></pre>

<p>If <code>singleton</code> is only used by <code>use_singleton</code>, I like the following pattern as a replacement:</p>

<pre><code># _make_singleton() is called only once when the def is executed
def use_singleton(singleton=_make_singleton()):
    return singleton.use_me()
</code></pre>

<p>I've used this for instantiating client classes that access external resources, and also for creating dicts or lists for memoization.</p>

<p>Since I don't think this pattern is well known, I do put a short comment in to guard against future misunderstandings.</p>
<h4> Stefano Borini, Comment 45063880 Score: 2: </h4>I prefer to add a decorator for memoization, and put the memoization cache onto the function object itself.<br><h4> Yann Vernier, Comment 81702357 Score: 0: </h4>This example doesn&#39;t replace the more complex pattern you show, because you call <code>_make_singleton</code> at def time in the default argument example, but at call time in the global example. A true substitution would use some sort of mutable box for the default argument value, but the addition of the argument makes an opportunity to pass alternate values.<br>------------------------------------------------------------------ <br><h3> Przemek D, Id: 54018161, Score: 15: </h3><p>Every other answer explains why this is actually a nice and desired behavior, or why you shouldn't be needing this anyway. Mine is for those stubborn ones who want to exercise their right to bend the language to their will, not the other way around.</p>
<p>We will &quot;fix&quot; this behavior with a decorator that will copy the default value instead of reusing the same instance for each positional argument left at its default value.</p>

<pre class="lang-py prettyprint-override"><code>import inspect
from copy import deepcopy  # copy would fail on deep arguments like nested dicts

def sanify(function):
    def wrapper(*a, **kw):
        # store the default values
        defaults = inspect.getargspec(function).defaults # for python2
        # construct a new argument list
        new_args = []
        for i, arg in enumerate(defaults):
            # allow passing positional arguments
            if i in range(len(a)):
                new_args.append(a[i])
            else:
                # copy the value
                new_args.append(deepcopy(arg))
        return function(*new_args, **kw)
    return wrapper
</code></pre>
<p>Now let's redefine our function using this decorator:</p>
<pre class="lang-py prettyprint-override"><code>@sanify
def foo(a=[]):
    a.append(5)
    return a

foo() # '[5]'
foo() # '[5]' -- as desired
</code></pre>
<p>This is particularly neat for functions that take multiple arguments. Compare:</p>
<pre class="lang-py prettyprint-override"><code># the 'correct' approach
def bar(a=None, b=None, c=None):
    if a is None:
        a = []
    if b is None:
        b = []
    if c is None:
        c = []
    # finally do the actual work
</code></pre>
<p>with</p>
<pre class="lang-py prettyprint-override"><code># the nasty decorator hack
@sanify
def bar(a=[], b=[], c=[]):
    # wow, works right out of the box!
</code></pre>
<p>It's important to note that the above solution breaks if you try to use keyword args, like so:</p>
<pre class="lang-py prettyprint-override"><code>foo(a=[4])
</code></pre>
<p>The decorator could be adjusted to allow for that, but we leave this as an exercise for the reader ;)</p>
<h4> Flimm, Comment 126670698 Score: 1: </h4>This also breaks if the default argument is deep, like <code>{&quot;grandparent&quot;: {&quot;parent&quot;: {&quot;child&quot;: &quot;value&quot;}}}</code> . Only the top-level dictionary gets copied by value, the other dictionaries get copied by reference. This problem occurs because you used <code>copy</code> instead of <code>deepcopy</code><br><h4> Przemek D, Comment 126698761 Score: 1: </h4>@Flimm I find your phrase &quot;this breaks&quot; rather unfair as it seems to suggests the entire concept is somehow flawed, while it is in fact only a minor detail of the implementation. But thank you for the comment nonetheless, I shall edit and improve my answer.<br>------------------------------------------------------------------ <br><h3> Flimm, Id: 71674471, Score: 12: </h3><h3>Yes, this is  a design flaw in Python</h3>
<p>I've read all the other answers and I'm not convinced. This design does violate the principle of least astonishment.</p>
<p>The defaults could have been designed to be evaluated when the function is called, rather than when the function is defined. This is how Javascript does it:</p>
<p><div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js prettyprint-override"><code>function foo(a=[]) {
  a.push(5);
  return a;
}
console.log(foo()); // [5]
console.log(foo()); // [5]
console.log(foo()); // [5]</code></pre>
</div>
</div>
</p>
<p>As further evidence that this is a design flaw, Python core developers are currently discussing introducing new syntax to fix this problem. See this article: <a href="https://lwn.net/Articles/875441/" rel="noreferrer">Late-bound argument defaults for Python</a>.</p>
<p>For even more evidence that this a design flaw, if you Google &quot;Python gotchas&quot;, this design is mentioned as a gotcha, usually the first gotcha in the list, in the first 9 Google results (<a href="https://docs.python-guide.org/writing/gotchas/" rel="noreferrer">1</a>, <a href="https://inventwithpython.com/beyond/chapter8.html" rel="noreferrer">2</a>, <a href="https://towardsdatascience.com/five-python-gotchas-3073145fe083" rel="noreferrer">3</a>, <a href="https://www.geeksforgeeks.org/gotchas-in-python/" rel="noreferrer">4</a>, <a href="https://8thlight.com/blog/shibani-mookerjee/2019/05/07/some-common-gotchas-in-python.html" rel="noreferrer">5</a>, <a href="https://miguendes.me/python-gotchas" rel="noreferrer">6</a>, <a href="https://medium.com/codex/python-beginner-gotchas-af16f26325dd" rel="noreferrer">7</a>, <a href="https://www.reddit.com/r/learnpython/comments/2xwc6s/python_gotchas/" rel="noreferrer">8</a>, <a href="https://www.toptal.com/python/top-10-mistakes-that-python-programmers-make" rel="noreferrer">9</a>). In contrast, if you Google &quot;Javascript gotchas&quot;, the behaviour of default arguments in Javascript is not mentioned as a gotcha even once.</p>
<p>Gotchas, by definition, violate the principle of least astonishment. They astonish. Given there are superiour designs for the behaviour of default argument values, the inescapable conclusion is that Python's behaviour here represents a design flaw.</p>
<p>I say this as someone who loves Python. We can be fans of Python, and still admit that everyone who is unpleasantly surprised by this aspect of Python is unpleasantly surprised because it <em>is</em> a genuine &quot;gotcha&quot;.</p>
<h4> Flimm, Comment 134245549 Score: 2: </h4>@LutzPrechelt Just because the <code>def</code> statement is executed at module load time, that does not mean that the default arg values should be executed at module load time too. Take the statement <code>foobar = lambda x: print(&quot;hi&quot;)</code> . Would you be surprised if <code>hi</code> got printed at module load time? I know I would be, even though this statement is executed at module load time. Intuitively, we expect that the <code>print</code> part of this statement would only be executed once the lambda is called. Likewise, as evidenced by people&#39;s well-documented surprised, we expect the default value to be executed when called<br><h4> Lutz Prechelt, Comment 134265120 Score: 1: </h4><a href="https://en.wikipedia.org/wiki/Orthogonality_(programming)" rel="nofollow noreferrer">en.wikipedia.org/wiki/Orthogonality_(programming)</a> is a mostly good discussion of the idea.<br><h4> Lutz Prechelt, Comment 134224065 Score: 1: </h4>Calling it a design flaw assumes there is a better solution. But that solution (whichever one is chosen in particular) would break the orthogonality of Python (from which the incriminated behavior follows), which would create lots more surprise in other places.<br><h4> Flimm, Comment 134224456 Score: 1: </h4>@LutzPrechelt There is a better design, namely, the one used in some other programming languages, like JavaScript, as I mentioned in my answer. I don&#39;t understand how the better design would break things in Python, except for backwards compatibility. What do you mean by &quot;orthogonality&quot;?<br><h4> Lutz Prechelt, Comment 134242605 Score: 1: </h4>by orthogonality I mean that in Python <code>def</code> is a statement that is executed at module load time (for a top-level function). The default argument definition is part of that statement and therefore ought to be executed at load time as well -- and any other behavior would also be surprising.<br><h4> Flimm, Comment 134245560 Score: 0: </h4>@LutzPrechelt Could you provide a reference for this definition of &quot;orthogonality&quot;? I haven&#39;t heard it used this way before.<br>------------------------------------------------------------------ <br><h3> Norfeldt, Id: 17782210, Score: 9: </h3><p>This "bug" gave me a lot of overtime work hours! But I'm beginning to see a potential use of it (but I would have liked it to be at the execution time, still)</p>

<p>I'm gonna give you what I see as a useful example.</p>

<pre><code>def example(errors=[]):
    # statements
    # Something went wrong
    mistake = True
    if mistake:
        tryToFixIt(errors)
        # Didn't work.. let's try again
        tryToFixItAnotherway(errors)
        # This time it worked
    return errors

def tryToFixIt(err):
    err.append('Attempt to fix it')

def tryToFixItAnotherway(err):
    err.append('Attempt to fix it by another way')

def main():
    for item in range(2):
        errors = example()
    print '\n'.join(errors)

main()
</code></pre>

<p>prints the following</p>

<pre><code>Attempt to fix it
Attempt to fix it by another way
Attempt to fix it
Attempt to fix it by another way
</code></pre>
<h4> Mark Ransom, Comment 119658319 Score: 2: </h4>Your example doesn&#39;t seem very realistic.  Why would you pass <code>errors</code> as a parameter rather than starting from scratch every time?<br>------------------------------------------------------------------ <br><h3> rassa45, Id: 30447095, Score: 8: </h3><p>Just change the function to be:</p>

<pre><code>def notastonishinganymore(a = []): 
    '''The name is just a joke :)'''
    a = a[:]
    a.append(5)
    return a
</code></pre>
<h4> Flimm, Comment 126670893 Score: 0: </h4>This doesn&#39;t answer the question, though.<br>------------------------------------------------------------------ <br><h3> Mark Ransom, Id: 46796007, Score: 8: </h3><p><em>This is not a design flaw</em>. Anyone who trips over this is doing something wrong.</p>

<p>There are 3 cases I see where you might run into this problem:</p>

<ol>
<li>You intend to modify the argument as a side effect of the function. In this case it <em>never makes sense</em> to have a default argument. The only exception is when you're abusing the argument list to have function attributes, e.g. <code>cache={}</code>, and you wouldn't be expected to call the function with an actual argument at all.</li>
<li>You intend to leave the argument unmodified, but you accidentally <em>did</em> modify it. That's a bug, fix it.</li>
<li>You intend to modify the argument for use inside the function, but didn't expect the modification to be viewable outside of the function. In that case you need to make a <em>copy</em> of the argument, whether it was the default or not! Python is not a call-by-value language so it doesn't make the copy for you, you need to be explicit about it.</li>
</ol>

<p>The example in the question could fall into category 1 or 3. It's odd that it both modifies the passed list and returns it; you should pick one or the other.</p>
<h4> aCuria, Comment 119639032 Score: 5: </h4>Totally disagree, its absolutely a design flaw in many cases and not the programmer doing something wong<br><h4> Clement Cherlin, Comment 119970601 Score: 2: </h4>@MarkRansom No, they&#39;re not; for example, <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Default_parameters#evaluated_at_call_time" rel="nofollow noreferrer">JavaScript doesn&#39;t have this design flaw</a>.<br><h4> Clement Cherlin, Comment 119879935 Score: 2: </h4>@MarkRansom If we take it as given that side effects are OK, there&#39;s nothing wrong with modifying a default argument as part of a side-effect-ful function. Let&#39;s say you have a function that does <i>something</i> to a list and returns the list. We want to ensure that the function always returns a list. Then having an empty (or non-empty) list as a default makes perfect sense. The language is violating a large proportion of new Python programmers&#39; expectations. Why are they wrong and the language right? Would you be making the opposite argument if the language had the opposite behavior?<br><h4> qwr, Comment 119654728 Score: 1: </h4>I have never run into the problem of the OP even though it is so highly upvoted, because having a default argument be mutable is weird design to me.<br><h4> Andy Hayden, Comment 80540093 Score: 1: </h4>&quot;Doing something wrong&quot; is the diagnosis. That said, I think there are times were =None pattern is useful, but generally you don&#39;t want to modify if passed a mutable in that case (2). The <code>cache={}</code> pattern is really an interview-only solution, in real code you probably want <a href="https://docs.python.org/3/library/functools.html#functools.lru_cache" rel="nofollow noreferrer"><code>@lru_cache</code></a>!<br><h4> Mark Ransom, Comment 119881138 Score: 1: </h4>@ClementCherlin you&#39;re missing my point.  If you&#39;re going to return a result, it&#39;s redundant to <i>also</i> mutate the passed argument.  You should do one or the other, not both.  <code>x = modified(x)</code> is a well known idiom in Python, and would work well with a default argument - as long as you make sure to <i>copy</i> the input before you start making modifications.<br><h4> Clement Cherlin, Comment 119970391 Score: 1: </h4>@MarkRansom I&#39;m not missing your point, I&#39;m disagreeing with it. <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort" rel="nofollow noreferrer">Array.sort()</a> in JavaScript sorts an array in-place <i>and returns it</i>. <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Arrays.html#sort(int%5B%5D)" rel="nofollow noreferrer">Arrays.sort()</a> in Java sorts an array in-place and has no return value. Whether to return an input modified in-place is a matter of opinion/preference, not correctness. I, personally, prefer methods that return the input so I can use method chaining.<br><h4> Mark Ransom, Comment 119970553 Score: 0: </h4>@ClementCherlin fine, then in that case <i>don&#39;t have a default</i>.  Or if you do, make it <code>None</code> and use the <code>if x is None:</code> idiom.  Realize that Python and Javascript are not the same.<br><h4> Mark Ransom, Comment 119970912 Score: 0: </h4>@ClementCherlin I guess we&#39;ll have to continue to disagree then, because I don&#39;t consider it a design flaw.  I&#39;m just glad I don&#39;t have to implement a Javascript compiler, I have no idea how they pull that off.<br><h4> Mark Ransom, Comment 119643222 Score: 0: </h4>@aCuria so you have a case 4 that&#39;s different from the 3 I presented?  I&#39;d love to hear about it, please tell me more.  Python&#39;s behavior may not make sense in this circumstance, but it&#39;s very useful in other places and to change it would be a disaster.<br>------------------------------------------------------------------ <br><h3> MisterMiyagi, Id: 53792207, Score: 8: </h3><p>TLDR: Define-time defaults are consistent and strictly more expressive.</p>

<hr>

<p>Defining a function affects two scopes: the defining scope <em>containing</em> the function, and the execution  scope <em>contained by</em> the function. While it is pretty clear how blocks map to scopes, the question is where <code>def &lt;name&gt;(&lt;args=defaults&gt;):</code> belongs to:</p>

<pre><code>...                           # defining scope
def name(parameter=default):  # ???
    ...                       # execution scope
</code></pre>

<p>The <code>def name</code> part <strong>must</strong> evaluate in the defining scope - we want <code>name</code> to be available there, after all. Evaluating the function only inside itself would make it inaccessible.</p>

<p>Since <code>parameter</code> is a constant name, we can "evaluate" it at the same time as <code>def name</code>. This also has the advantage it produces the function with a known signature as <code>name(parameter=...):</code>, instead of a bare <code>name(...):</code>.</p>

<p>Now, when to evaluate <code>default</code>?</p>

<p>Consistency already says "at definition": everything else of <code>def &lt;name&gt;(&lt;args=defaults&gt;):</code> is best evaluated at definition as well. Delaying parts of it would be the astonishing choice.</p>

<p>The two choices are not equivalent, either: If <code>default</code> is evaluated at definition time, it <em>can still</em> affect execution time. If <code>default</code> is evaluated at execution time, it <em>cannot</em> affect definition time. Choosing "at definition" allows expressing both cases, while choosing "at execution" can express only one:</p>

<pre><code>def name(parameter=defined):  # set default at definition time
    ...

def name(parameter=default):     # delay default until execution time
    parameter = default if parameter is None else parameter
    ...
</code></pre>
<h4> LarsH, Comment 102525948 Score: 2: </h4>&quot;Consistency already says &quot;at definition&quot;: everything else of <code>def &lt;name&gt;(&lt;args=defaults&gt;):</code> is best evaluated at definition as well.&quot; I don&#39;t think the conclusion follows from the premise. Just because two things are on the same line doesn&#39;t mean they should be evaluated in the same scope. <code>default</code> is a different thing than the rest of the line: it&#39;s an expression. Evaluating an expression is a very different process from defining a function.<br><h4> LarsH, Comment 102560686 Score: 2: </h4>OK, creating a function means evaluation in some sense, but obviously not in the sense that every expression within it is evaluated at the time of definition. Most aren&#39;t. It&#39;s not clear to me in what sense the signature is especially &quot;evaluated&quot; at definition time any more than the function body is &quot;evaluated&quot; (parsed into a suitable representation); whereas expressions in the function body are clearly not evaluated in the full sense. From this point of view, consistency would say that expressions in the signature shouldn&#39;t be &quot;fully&quot; evaluated either.<br><h4> LarsH, Comment 102560689 Score: 2: </h4>I don&#39;t mean that you&#39;re wrong, only that your conclusion doesn&#39;t follow from consistency alone.<br><h4> MisterMiyagi, Comment 102527403 Score: 1: </h4>@LarsH Function definitions are <i>are</i> evaluated in Python. Whether that is from a statement (<code>def</code>) or expression (<code>lambda</code>) does not change that creating a function means evaluation -- especially of its signature. And defaults are part of a function&#39;s signature. That does not mean defaults <i>have</i> to be evaluated immediately -- type hints may not, for example. But it certainly suggests they should unless there is a good reason not to.<br><h4> MisterMiyagi, Comment 102560884 Score: 0: </h4>@LarsH Defaults are neither part of the body, nor am I claiming that consistency is the only criteria. Can you make a suggestion how to clarify the answer?<br><h4> LarsH, Comment 102562247 Score: 0: </h4>You could change &#39;Consistency already says &quot;at definition&quot;&#39; to &#39;Consistency within the first line says &quot;at definition&quot;&#39;, to distinguish it from &#39;Consistency among expressions says &quot;at execution&quot;&#39;. (And I agree that defaults are not lexically part of the body. But they are part of the function definition, as are all the expressions in the body.)<br>------------------------------------------------------------------ <br><h3> user2384994, Id: 18372696, Score: 5: </h3><p>I think the answer to this question lies in how python pass data to parameter (pass by value or by reference), not mutability or how python handle the "def" statement.</p>

<p>A brief introduction. First, there are two type of data types in python, one is simple elementary data type, like numbers, and another data type is objects. Second, when passing data to parameters, python pass elementary data type by value, i.e., make a local copy of the value to a local variable, but pass object by reference, i.e., pointers to the object.</p>

<p>Admitting the above two points, let's explain what happened to the python code. It's only because of passing by reference for objects, but has nothing to do with mutable/immutable, or arguably the fact that "def" statement is executed only once when it is defined.</p>

<p>[] is an object, so python pass the reference of [] to <code>a</code>, i.e., <code>a</code> is only a pointer to [] which lies in memory as an object. There is only one copy of [] with, however, many references to it. For the first foo(), the list [] is changed to <a href="http://effbot.org/zone/default-values.htm" rel="noreferrer">1</a> by append method. But Note that there is only one copy of the list object and this object now becomes <a href="http://effbot.org/zone/default-values.htm" rel="noreferrer">1</a>. When running the second foo(), what effbot webpage says (items is not evaluated any more) is wrong. <code>a</code> is evaluated to be the list object, although now the content of the object is <a href="http://effbot.org/zone/default-values.htm" rel="noreferrer">1</a>. This is the effect of passing by reference! The result of foo(3) can be easily derived in the same way.</p>

<p>To further validate my answer, let's take a look at two additional codes.</p>

<p>====== No. 2 ========</p>

<pre><code>def foo(x, items=None):
    if items is None:
        items = []
    items.append(x)
    return items

foo(1)  #return [1]
foo(2)  #return [2]
foo(3)  #return [3]
</code></pre>

<p><code>[]</code> is an object, so is <code>None</code> (the former is mutable while the latter is immutable. But the mutability has nothing to do with the question). None is somewhere in the space but we know it's there and there is only one copy of None there. So every time foo is invoked, items is evaluated (as opposed to some answer that it is only evaluated once) to be None, to be clear, the reference (or the address) of None. Then in the foo, item is changed to [], i.e., points to another object which has a different address. </p>

<p>====== No. 3 =======</p>

<pre><code>def foo(x, items=[]):
    items.append(x)
    return items

foo(1)    # returns [1]
foo(2,[]) # returns [2]
foo(3)    # returns [1,3]
</code></pre>

<p>The invocation of foo(1) make items point to a list object [] with an address, say, 11111111. the content of the list is changed to <a href="http://effbot.org/zone/default-values.htm" rel="noreferrer">1</a> in the foo function in the sequel, but the address is not changed, still 11111111. Then foo(2,[]) is coming. Although the [] in foo(2,[]) has the same content as the default parameter [] when calling foo(1), their address are different! Since we provide the parameter explicitly, <code>items</code> has to take the address of this new <code>[]</code>, say 2222222, and return it after making some change. Now foo(3) is executed. since only <code>x</code> is provided, items has to take its default value again. What's the default value? It is set when defining the foo function: the list object located in 11111111. So the items is evaluated to be the address 11111111 having an element 1. The list located at 2222222 also contains one element 2, but it is not pointed by items any more. Consequently, An append of 3 will make <code>items</code> [1,3]. </p>

<p>From the above explanations, we can see that the <a href="http://effbot.org/zone/default-values.htm" rel="noreferrer">effbot</a> webpage recommended in the accepted answer failed to give a relevant answer to this question. What is more, I think a point in the effbot webpage is wrong. I think the code regarding the UI.Button is correct:</p>

<pre><code>for i in range(10):
    def callback():
        print "clicked button", i
    UI.Button("button %s" % i, callback)
</code></pre>

<p>Each button can hold a distinct callback function which will display different value of <code>i</code>. I can provide an example to show this:</p>

<pre><code>x=[]
for i in range(10):
    def callback():
        print(i)
    x.append(callback) 
</code></pre>

<p>If we execute <code>x[7]()</code> we'll get 7 as expected, and <code>x[9]()</code> will gives 9, another value of <code>i</code>.</p>
<h4> Duncan, Comment 28304217 Score: 6: </h4>Your last point is wrong. Try it and you&#39;ll see that <code>x[7]()</code> is <code>9</code>.<br><h4> Veky, Comment 42551885 Score: 4: </h4>&quot;python pass elementary data type by value, i.e., make a local copy of the value to a local variable&quot; is completely incorrect. I am astonished that someone can obviously know Python very well, yet have such horrible misunderstanding of fundamentals. :-(<br>------------------------------------------------------------------ <br><h3> david, Id: 75409293, Score: 1: </h3><p><strong>Documentation failure</strong></p>
<pre><code>def fn(&lt;mutable object&gt; = [manifest constant]):
</code></pre>
<p>This python syntax is for an optional <em>initializer</em> for a mutable object. Calling the manifest constant a <em>default</em> value is both wrong and confusing. It is particularly unfortunate that the official python documentation uses the misleading description, and that the painfully misleading term has been copied across the web, including in the question here.</p>
<p>The problem would not be completely solved by correcting the documentation: people would still <em>want</em> python to implement a <em>default value</em> for mutable objects.  But it would be a start.</p>
------------------------------------------------------------------ <br><h3> Karl Knechtel, Id: 75853780, Score: 1: </h3><h2>Argument from command-query separation</h2>
<p>Python strongly respects the principle of <a href="https://en.wikipedia.org/wiki/Command%E2%80%93query_separation" rel="nofollow noreferrer">command-query separation</a>. For example, ordinary assignment is considered a statement, not an expression, and thus cannot be used as a sub-expression; and <a href="/q/75851273">many built-in and standard library methods return <code>None</code></a>, rather than the object, when they work primarily by modifying the object.</p>
<p>We can make a simple argument against using mutable default values for parameters, as follows:</p>
<ol>
<li><p>There are <a href="https://stackoverflow.com/questions/3052793/">two ways to get information out of the function</a>: by <code>return</code>ing it, or by modifying some variable in an enclosing scope.</p>
</li>
<li><p>However, the only sane, reusable way to &quot;modify a variable in an enclosing scope&quot; is to modify one of the parameters. Modifying the function itself makes the interface much more awkward (and could cause problems for recursive code). Modifying anything else requires the function and the caller to share that context; this means polluting a global namespace and, again, creating an awkward and highly non-standard interface.</p>
</li>
<li><p>The point of default parameter values is to be able to call the function without the corresponding argument; therefore, we must design for the case where that happens.</p>
</li>
<li><p>Suppose we call the function without the corresponding argument, so that that the default is used. How will we signal the change? The object for the default value is not in scope for the caller, and it is not an attribute of the function; therefore, it is not readily accessible to the caller. Therefore, we can't readily get the information back via the now-mutated default.</p>
</li>
<li><p>Therefore, in order to communicate a result, we would have to <code>return</code> some information instead.</p>
</li>
<li><p>In order for the interface to be consistent, and avoid complicated special cases for using it, the function should therefore <em>consistently</em> return a calculated result.</p>
</li>
<li><p>But <em>because of command-query separation</em>, this therefore means that the function should <em>not</em> modify the parameter. We cannot do both, because then &quot;asking the question could change the answer&quot;.</p>
</li>
<li><p>Since the function will not modify the parameter, it will not modify the default-value object.</p>
</li>
<li><p>But if the object will not be modified, <strong>there is no reason for it to be mutable</strong>. Using a mutable type misleadingly implies an intent to mutate the value.</p>
</li>
</ol>
<p>In practice, people sometimes write default arguments like <code>{}</code> even when the code will not mutate them. It's easy enough to replace <code>[]</code> with <code>()</code>, but it's not trivial to express &quot;an empty, immutable mapping&quot;. Of course, using <code>None</code> (which is immutable) as a sentinel and then explicitly checking for that value, neatly sidesteps the problem.</p>
------------------------------------------------------------------ <br><h3> Charles Merriam, Id: 59638236, Score: -3: </h3><p>There is a simple way to understand why this happens.</p>

<p><strong>Python executes code, from top to bottom, in a namespace.</strong></p>

<p>The 'internals' just embody of this rule.   </p>

<p>The reason for this choice is to "let the language fit in your head".  All the odd corner cases tend to simplify to executing code in a namespace:  default immutables, nested functions, classes (with a little patch-up when done compiling), the self argument, etc.  Similarly, complex syntax could be written in simple syntax:  <code>a.foo(...)</code> is just <code>a.lookup('foo').__call__(a,...)</code>.  This works with list comprehensions; decorators; metaclasses; and more.  This gives you a near perfect  view of the strange corners.  The language fits in your head.</p>

<p>You should keep at it.  Learning Python has a period of railing at the language, but it gets comfortable.  It's the only language I've worked in that gets simpler the more you look at corner cases. </p>

<p>Keep Hacking!  Keep notes.</p>

<p>For your specific code, in too much detail:</p>

<pre><code>def foo(a=[]):
    a.append(5)
    return a

foo()
</code></pre>

<p>is one statement, equivalent to:</p>

<ol>
<li>Start making a code object.</li>
<li>Interpreting <code>(a=[])</code> right now, as we go.  The <code>[]</code> is the default value of argument a.  It is of type list, as <code>[]</code> always is.</li>
<li>Compile all the code after the <code>:</code> into Python bytecode and stick it in another list.</li>
<li>Create the callable dictionary, with the arguments and code in the '<strong>code</strong>' field</li>
<li>Add the callable to the current namespace in the 'foo' field.</li>
</ol>

<p>Then, it goes to the next line, <code>foo()</code>.</p>

<ol>
<li>It's not a reserved word, so <a href="https://stackoverflow.com/questions/291978/short-description-of-the-scoping-rules">look it up in the namespace</a>.  </li>
<li>Call the function, which will use the list as the default argument. Start executing its bytecode in its namespace. </li>
<li><code>append</code> does not create a new list, so the old one is modified.</li>
</ol>
