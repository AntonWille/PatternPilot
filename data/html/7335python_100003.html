 <h2> Title: What are metaclasses in Python? </h2> <h3> Bite code, question_id: 100003 </h3>Score: 7335, Tags: {python,oop,metaclass,python-class,python-datamodel} <br><p>What are <a href="https://docs.python.org/3/reference/datamodel.html#metaclasses" rel="noreferrer">metaclasses</a>? What are they used for?</p>
------------------------------------------------------------------ <br><h3> Answer 6581949 Bite code: </h3><h1>Classes as objects</h1>
<p>Prior to delving into metaclasses, a solid grasp of Python classes is beneficial. Python holds a particularly distinctive concept of classes, a notion it adopts from the Smalltalk language.</p>
<p>In most languages, classes are just pieces of code that describe how to produce an object. That is somewhat true in Python too:</p>
<pre><code>&gt;&gt;&gt; class ObjectCreator(object):
...     pass

&gt;&gt;&gt; my_object = ObjectCreator()
&gt;&gt;&gt; print(my_object)
    &lt;__main__.ObjectCreator object at 0x8974f2c&gt;
</code></pre>
<p>But classes are more than that in Python. <strong>Classes are objects too.</strong></p>
<p>Yes, objects.</p>
<p>When a Python script runs, every line of code is executed from top to bottom. When the Python interpreter encounters the <code>class</code> keyword, Python creates an <strong>object</strong> out of the &quot;description&quot; of the class that follows. Thus, the following instruction</p>
<pre><code>&gt;&gt;&gt; class ObjectCreator(object):
...     pass
</code></pre>
<p>...creates an <em>object</em> with the name <code>ObjectCreator</code>!</p>
<p>This object (the class) is itself capable of creating objects (called <em>instances</em>).</p>
<p>But still, it's an object. Therefore, like all objects:</p>
<ul>
<li>you can assign it to a variable<sup>1</sup>
<pre><code>JustAnotherVariable = ObjectCreator
</code></pre>
</li>
<li>you can attach attributes to it
<pre><code>ObjectCreator.class_attribute = 'foo'
</code></pre>
</li>
<li>you can pass it as a function parameter
<pre><code>print(ObjectCreator)
</code></pre>
</li>
</ul>
<p><sup><sup>1</sup> Note that merely assigning it to another variable doesn't change the class's <code>__name__</code>, i.e.,</p>
<pre><code>&gt;&gt;&gt; print(JustAnotherVariable)
    &lt;class '__main__.ObjectCreator'&gt;

&gt;&gt;&gt; print(JustAnotherVariable())
    &lt;__main__.ObjectCreator object at 0x8997b4c&gt;
</code></pre>
</sup>
<h1>Creating classes dynamically</h1>
<p>Since classes are objects, you can create them on the fly, like any object.</p>
<p>First, you can create a class in a function using <code>class</code>:</p>
<pre><code>&gt;&gt;&gt; def choose_class(name):
...     if name == 'foo':
...         class Foo(object):
...             pass
...         return Foo # return the class, not an instance
...     else:
...         class Bar(object):
...             pass
...         return Bar

&gt;&gt;&gt; MyClass = choose_class('foo')

&gt;&gt;&gt; print(MyClass) # the function returns a class, not an instance
    &lt;class '__main__.Foo'&gt;

&gt;&gt;&gt; print(MyClass()) # you can create an object from this class
    &lt;__main__.Foo object at 0x89c6d4c&gt;
</code></pre>
<p>But it's not so dynamic, since you still have to write the whole class yourself.</p>
<p>Since classes are objects, they must be generated by something.</p>
<p>When you use the <code>class</code> keyword, Python creates this object automatically. But as
with most things in Python, it gives you a way to do it manually.</p>
<p>Remember the function <code>type</code>? The good old function that lets you know what
type an object is:</p>
<pre><code>&gt;&gt;&gt; print(type(1))
    &lt;type 'int'&gt;

&gt;&gt;&gt; print(type(&quot;1&quot;))
    &lt;type 'str'&gt;

&gt;&gt;&gt; print(type(ObjectCreator))
    &lt;type 'type'&gt;

&gt;&gt;&gt; print(type(ObjectCreator()))
    &lt;class '__main__.ObjectCreator'&gt;
</code></pre>
<p>Well, <a href="http://docs.python.org/2/library/functions.html#type" rel="noreferrer"><code>type</code></a> has also a completely different ability: it can create classes on the fly. <code>type</code> can take the description of a class as parameters,
and return a class.</p>
<p>(I  know, it's silly that the same function can have two completely different uses according to the parameters you pass to it. It's an issue due to backward
compatibility in Python)</p>
<p><code>type</code> works this way:</p>
<pre><code>type(name, bases, attrs)
</code></pre>
<p>Where:</p>
<ul>
<li><strong><code>name</code></strong>: name of the class</li>
<li><strong><code>bases</code></strong>: tuple of the parent class (for inheritance, can be empty)</li>
<li><strong><code>attrs</code></strong>: dictionary containing attributes names and values</li>
</ul>
<p>e.g.:</p>
<pre><code>&gt;&gt;&gt; class MyShinyClass(object):
...     pass
</code></pre>
<p>can be created manually this way:</p>
<pre><code>&gt;&gt;&gt; MyShinyClass = type('MyShinyClass', (), {}) # returns a class object
&gt;&gt;&gt; print(MyShinyClass)
    &lt;class '__main__.MyShinyClass'&gt;

&gt;&gt;&gt; print(MyShinyClass()) # create an instance with the class
    &lt;__main__.MyShinyClass object at 0x8997cec&gt;
</code></pre>
<p>You'll notice that we use <code>MyShinyClass</code> as the name of the class
and as the variable to hold the class reference. They can be different,
but there is no reason to complicate things.</p>
<p><code>type</code> accepts a dictionary to define the attributes of the class. So:</p>
<pre><code>&gt;&gt;&gt; class Foo(object):
...     bar = True
</code></pre>
<p>Can be translated to:</p>
<pre><code>&gt;&gt;&gt; Foo = type('Foo', (), {'bar':True})
</code></pre>
<p>And used as a normal class:</p>
<pre><code>&gt;&gt;&gt; print(Foo)
    &lt;class '__main__.Foo'&gt;

&gt;&gt;&gt; print(Foo.bar)
    True

&gt;&gt;&gt; f = Foo()
&gt;&gt;&gt; print(f)
    &lt;__main__.Foo object at 0x8a9b84c&gt;

&gt;&gt;&gt; print(f.bar)
    True
</code></pre>
<p>And of course, you can inherit from it, so:</p>
<pre><code>&gt;&gt;&gt; class FooChild(Foo):
...     pass
</code></pre>
<p>would be:</p>
<pre><code>&gt;&gt;&gt; FooChild = type('FooChild', (Foo,), {})
&gt;&gt;&gt; print(FooChild)
    &lt;class '__main__.FooChild'&gt;

&gt;&gt;&gt; print(FooChild.bar) # bar is inherited from Foo
    True
</code></pre>
<p>Eventually, you'll want to add methods to your class. Just define a function
with the proper signature and assign it as an attribute.</p>
<pre><code>&gt;&gt;&gt; def echo_bar(self):
...     print(self.bar)

&gt;&gt;&gt; FooChild = type('FooChild', (Foo,), {'echo_bar': echo_bar})

&gt;&gt;&gt; hasattr(Foo, 'echo_bar')
    False

&gt;&gt;&gt; hasattr(FooChild, 'echo_bar')
    True

&gt;&gt;&gt; my_foo = FooChild()
&gt;&gt;&gt; my_foo.echo_bar()
    True
</code></pre>
<p>And you can add even more methods after you dynamically create the class, just like adding methods to a normally created class object.</p>
<pre><code>&gt;&gt;&gt; def echo_bar_more(self):
...     print('yet another method')

&gt;&gt;&gt; FooChild.echo_bar_more = echo_bar_more
&gt;&gt;&gt; hasattr(FooChild, 'echo_bar_more')
    True
</code></pre>
<p>You see where we are going: in Python, classes are objects, and you can create a class on the fly, dynamically.</p>
<p>This is what Python does when you use the keyword <code>class</code>, and it does so by using a metaclass.</p>
<h1>What are metaclasses (finally)</h1>
<p>Metaclasses are the 'stuff' that creates classes.</p>
<p>You define classes in order to create objects, right?</p>
<p>But we learned that Python classes are objects.</p>
<p>Well, metaclasses are what create these objects. They are the classes' classes,
you can picture them this way:</p>
<pre><code>MyClass = MetaClass()
my_object = MyClass()
</code></pre>
<p>You've seen that <code>type</code> lets you do something like this:</p>
<pre><code>MyClass = type('MyClass', (), {})
</code></pre>
<p>It's because the function <code>type</code> is in fact a metaclass. <code>type</code> is the
metaclass Python uses to create all classes behind the scenes.</p>
<p>Now you wonder &quot;why the heck is it written in lowercase, and not <code>Type</code>?&quot;</p>
<p>Well, I guess it's a matter of consistency with <code>str</code>, the class that creates
strings objects, and <code>int</code> the class that creates integer objects. <code>type</code> is
just the class that creates class objects.</p>
<p>You see that by checking the <code>__class__</code> attribute.</p>
<p>Everything, and I mean everything, is an object in Python. That includes integers,
strings, functions and classes. All of them are objects. And all of them have
been created from a class:</p>
<pre><code>&gt;&gt;&gt; age = 35
&gt;&gt;&gt; age.__class__
    &lt;type 'int'&gt;

&gt;&gt;&gt; name = 'bob'
&gt;&gt;&gt; name.__class__
    &lt;type 'str'&gt;

&gt;&gt;&gt; def foo(): pass
&gt;&gt;&gt; foo.__class__
    &lt;type 'function'&gt;

&gt;&gt;&gt; class Bar(object): pass
&gt;&gt;&gt; b = Bar()
&gt;&gt;&gt; b.__class__
    &lt;class '__main__.Bar'&gt;
</code></pre>
<p>Now, what is the <code>__class__</code> of any <code>__class__</code> ?</p>
<pre><code>&gt;&gt;&gt; age.__class__.__class__
    &lt;type 'type'&gt;

&gt;&gt;&gt; name.__class__.__class__
    &lt;type 'type'&gt;

&gt;&gt;&gt; foo.__class__.__class__
    &lt;type 'type'&gt;

&gt;&gt;&gt; b.__class__.__class__
    &lt;type 'type'&gt;
</code></pre>
<p>So, a metaclass is just the stuff that creates class objects.</p>
<p>You can call it a 'class factory' if you wish.</p>
<p><code>type</code> is the built-in metaclass Python uses, but of course, you can create your
own metaclass.</p>
<h1>The <a href="http://docs.python.org/2/reference/datamodel.html?highlight=__metaclass__#__metaclass__" rel="noreferrer"><code>__metaclass__</code></a> attribute</h1>
<p>In Python 2, you can add a <code>__metaclass__</code> attribute when you write a class (see next section for the Python 3 syntax):</p>
<pre><code>class Foo(object):
    __metaclass__ = something...
    [...]
</code></pre>
<p>If you do so, Python will use the metaclass to create the class <code>Foo</code>.</p>
<p>Careful, it's tricky.</p>
<p>You write <code>class Foo(object)</code> first, but the class object <code>Foo</code> is not created
in memory yet.</p>
<p>Python will look for <code>__metaclass__</code> in the class definition. If it finds it,
it will use it to create the object class <code>Foo</code>. If it doesn't, it will use
<code>type</code> to create the class.</p>
<p>Read that several times.</p>
<p>When you do:</p>
<pre><code>class Foo(Bar):
    pass
</code></pre>
<p>Python does the following:</p>
<p>Is there a <code>__metaclass__</code> attribute in <code>Foo</code>?</p>
<p>If yes, create in-memory a class object (I said a class object, stay with me here), with the name <code>Foo</code> by using what is in <code>__metaclass__</code>.</p>
<p>If Python can't find <code>__metaclass__</code>, it will look for a <code>__metaclass__</code> at the MODULE level, and try to do the same (but only for classes that don't inherit anything, basically old-style classes).</p>
<p>Then if it can't find any <code>__metaclass__</code> at all, it will use the <code>Bar</code>'s (the first parent) own metaclass (which might be the default <code>type</code>) to create the class object.</p>
<p>Be careful here that the <code>__metaclass__</code> attribute will not be inherited, the metaclass of the parent (<code>Bar.__class__</code>) will be. If <code>Bar</code> used a <code>__metaclass__</code> attribute that created <code>Bar</code> with <code>type()</code> (and not <code>type.__new__()</code>), the subclasses will not inherit that behavior.</p>
<p>Now the big question is, what can you put in <code>__metaclass__</code>?</p>
<p>The answer is something that can create a class.</p>
<p>And what can create a class? <code>type</code>, or anything that subclasses or uses it.</p>
<h1>Metaclasses in Python 3</h1>
<p>The syntax to set the metaclass has been changed in Python 3:</p>
<pre><code>class Foo(object, metaclass=something):
    ...
</code></pre>
<p>i.e. the <code>__metaclass__</code> attribute is no longer used, in favor of a keyword argument in the list of base classes.</p>
<p>The behavior of metaclasses however stays <a href="https://www.python.org/dev/peps/pep-3115/" rel="noreferrer">largely the same</a>.</p>
<p>One thing added to metaclasses in Python 3 is that you can also pass attributes as keyword-arguments into a metaclass, like so:</p>
<pre><code>class Foo(object, metaclass=something, kwarg1=value1, kwarg2=value2):
    ...
</code></pre>
<p>Read the section below for how Python handles this.</p>
<h1>Custom metaclasses</h1>
<p>The main purpose of a metaclass is to change the class automatically,
when it's created.</p>
<p>You usually do this for APIs, where you want to create classes matching the
current context.</p>
<p>Imagine a stupid example, where you decide that all classes in your module
should have their attributes written in uppercase. There are several ways to
do this, but one way is to set <code>__metaclass__</code> at the module level.</p>
<p>This way, all classes of this module will be created using this metaclass,
and we just have to tell the metaclass to turn all attributes to uppercase.</p>
<p>Luckily, <code>__metaclass__</code> can actually be any callable, it doesn't need to be a
formal class (I know, something with 'class' in its name doesn't need to be
a class, go figure... but it's helpful).</p>
<p>So we will start with a simple example, by using a function.</p>
<pre><code># the metaclass will automatically get passed the same argument
# that you usually pass to `type`
def upper_attr(future_class_name, future_class_parents, future_class_attrs):
    &quot;&quot;&quot;
      Return a class object, with the list of its attribute turned
      into uppercase.
    &quot;&quot;&quot;
    # pick up any attribute that doesn't start with '__' and uppercase it
    uppercase_attrs = {
        attr if attr.startswith(&quot;__&quot;) else attr.upper(): v
        for attr, v in future_class_attrs.items()
    }

    # let `type` do the class creation
    return type(future_class_name, future_class_parents, uppercase_attrs)

__metaclass__ = upper_attr # this will affect all classes in the module

class Foo(): # global __metaclass__ won't work with &quot;object&quot; though
    # but we can define __metaclass__ here instead to affect only this class
    # and this will work with &quot;object&quot; children
    bar = 'bip'
</code></pre>
<p>Let's check:</p>
<pre><code>&gt;&gt;&gt; hasattr(Foo, 'bar')
    False

&gt;&gt;&gt; hasattr(Foo, 'BAR')
    True

&gt;&gt;&gt; Foo.BAR
    'bip'
</code></pre>
<p>Now, let's do exactly the same, but using a real class for a metaclass:</p>
<pre><code># remember that `type` is actually a class like `str` and `int`
# so you can inherit from it
class UpperAttrMetaclass(type):
    # __new__ is the method called before __init__
    # it's the method that creates the object and returns it
    # while __init__ just initializes the object passed as parameter
    # you rarely use __new__, except when you want to control how the object
    # is created.
    # here the created object is the class, and we want to customize it
    # so we override __new__
    # you can do some stuff in __init__ too if you wish
    # some advanced use involves overriding __call__ as well, but we won't
    # see this
    def __new__(
        upperattr_metaclass,
        future_class_name,
        future_class_parents,
        future_class_attrs
    ):
        uppercase_attrs = {
            attr if attr.startswith(&quot;__&quot;) else attr.upper(): v
            for attr, v in future_class_attrs.items()
        }
        return type(future_class_name, future_class_parents, uppercase_attrs)
</code></pre>
<p>Let's rewrite the above, but with shorter and more realistic variable names now that we know what they mean:</p>
<pre><code>class UpperAttrMetaclass(type):
    def __new__(cls, clsname, bases, attrs):
        uppercase_attrs = {
            attr if attr.startswith(&quot;__&quot;) else attr.upper(): v
            for attr, v in attrs.items()
        }
        return type(clsname, bases, uppercase_attrs)
</code></pre>
<p>You may have noticed the extra argument <code>cls</code>. There is
nothing special about it: <code>__new__</code> always receives the class it's defined in, as the first parameter. Just like you have <code>self</code> for ordinary methods which receive the instance as the first parameter, or the defining class for class methods.</p>
<p>But this is not proper OOP. We are calling <code>type</code> directly and we aren't overriding or calling the parent's <code>__new__</code>. Let's do that instead:</p>
<pre><code>class UpperAttrMetaclass(type):
    def __new__(cls, clsname, bases, attrs):
        uppercase_attrs = {
            attr if attr.startswith(&quot;__&quot;) else attr.upper(): v
            for attr, v in attrs.items()
        }
        return type.__new__(cls, clsname, bases, uppercase_attrs)
</code></pre>
<p>We can make it even cleaner by using <code>super</code>, which will ease inheritance (because yes, you can have metaclasses, inheriting from metaclasses, inheriting from type):</p>
<pre><code>class UpperAttrMetaclass(type):
    def __new__(cls, clsname, bases, attrs):
        uppercase_attrs = {
            attr if attr.startswith(&quot;__&quot;) else attr.upper(): v
            for attr, v in attrs.items()
        }

        # Python 2 requires passing arguments to super:
        return super(UpperAttrMetaclass, cls).__new__(
            cls, clsname, bases, uppercase_attrs)

        # Python 3 can use no-arg super() which infers them:
        return super().__new__(cls, clsname, bases, uppercase_attrs)
</code></pre>
<p>Oh, and in Python 3 if you do this call with keyword arguments, like this:</p>
<pre><code>class Foo(object, metaclass=MyMetaclass, kwarg1=value1):
    ...
</code></pre>
<p>It translates to this in the metaclass to use it:</p>
<pre><code>class MyMetaclass(type):
    def __new__(cls, clsname, bases, dct, kwargs1=default):
        ...
</code></pre>
<p>That's it. There is really nothing more about metaclasses.</p>
<p>The reason behind the complexity of the code using metaclasses is not because
of metaclasses, it's because you usually use metaclasses to do twisted stuff
relying on introspection, manipulating inheritance, vars such as <code>__dict__</code>, etc.</p>
<p>Indeed, metaclasses are especially useful to do black magic, and therefore
complicated stuff. But by themselves, they are simple:</p>
<ul>
<li>intercept a class creation</li>
<li>modify the class</li>
<li>return the modified class</li>
</ul>
<h1>Why would you use metaclasses classes instead of functions?</h1>
<p>Since <code>__metaclass__</code> can accept any callable, why would you use a class
since it's obviously more complicated?</p>
<p>There are several reasons to do so:</p>
<ul>
<li>The intention is clear. When you read <code>UpperAttrMetaclass(type)</code>, you know
what's going to follow</li>
<li>You can use OOP. Metaclass can inherit from metaclass, override parent methods. Metaclasses can even use metaclasses.</li>
<li>Subclasses of a class will be instances of its metaclass if you specified a metaclass-class, but not with a metaclass-function.</li>
<li>You can structure your code better. You never use metaclasses for something as trivial as the above example. It's usually for something complicated. Having the ability to make several methods and group them in one class is very useful to make the code easier to read.</li>
<li>You can hook on <code>__new__</code>, <code>__init__</code> and <code>__call__</code>. Which will allow you to do different stuff, Even if usually you can do it all in <code>__new__</code>,
some people are just more comfortable using <code>__init__</code>.</li>
<li>These are called metaclasses, damn it! It must mean something!</li>
</ul>
<h1>Why would you use metaclasses?</h1>
<p>Now the big question. Why would you use some obscure error-prone feature?</p>
<p>Well, usually you don't:</p>
<blockquote>
<p>Metaclasses are deeper magic that
99% of users should never worry about it.
If you wonder whether you need them,
you don't (the people who actually
need them know with certainty that
they need them, and don't need an
explanation about why).</p>
</blockquote>
<p><em>Python Guru Tim Peters</em></p>
<p>The main use case for a metaclass is creating an API. A typical example of this is the Django ORM. It allows you to define something like this:</p>
<pre><code>class Person(models.Model):
    name = models.CharField(max_length=30)
    age = models.IntegerField()
</code></pre>
<p>But if you do this:</p>
<pre><code>person = Person(name='bob', age='35')
print(person.age)
</code></pre>
<p>It won't return an <code>IntegerField</code> object. It will return an <code>int</code>, and can even take it directly from the database.</p>
<p>This is possible because <code>models.Model</code> defines <code>__metaclass__</code> and
it uses some magic that will turn the <code>Person</code> you just defined with simple statements
into a complex hook to a database field.</p>
<p>Django makes something complex look simple by exposing a simple API
and using metaclasses, recreating code from this API to do the real job
behind the scenes.</p>
<h1>The last word</h1>
<p>First, you know that classes are objects that can create instances.</p>
<p>Well, in fact, classes are themselves instances. Of metaclasses.</p>
<pre><code>&gt;&gt;&gt; class Foo(object): pass
&gt;&gt;&gt; id(Foo)
    142630324
</code></pre>
<p>Everything is an object in Python, and they are all either instance of classes
or instances of metaclasses.</p>
<p>Except for <code>type</code>.</p>
<p><code>type</code> is actually its own metaclass. This is not something you could
reproduce in pure Python, and is done by cheating a little bit at the implementation
level.</p>
<p>Secondly, metaclasses are complicated. You may not want to use them for
very simple class alterations. You can change classes by using two different techniques:</p>
<ul>
<li><a href="http://en.wikipedia.org/wiki/Monkey_patch" rel="noreferrer">monkey patching</a></li>
<li>class decorators</li>
</ul>
<p>99% of the time you need class alteration, you are better off using these.</p>
<p>But 98% of the time, you don't need class alteration at all.</p>
<h4> Comment 73803183 Max Goodridge: </h4>It appears that in Django <code>models.Model</code> it does not use <code>__metaclass__</code> but rather <code>class Model(metaclass=ModelBase):</code> to reference a <code>ModelBase</code> class which then does the aforementioned metaclass magic. Great post! Here&#39;s the Django source: <a href="https://github.com/django/django/blob/master/django/db/models/base.py#L382" rel="nofollow noreferrer">github.com/django/django/blob/master/django/db/models/&hellip;</a><br><h4> Comment 74291770 petrux: </h4>&lt;&lt;Be careful here that the <code>__metaclass__</code> attribute will not be inherited, the metaclass of the parent (<code>Bar.__class__</code>) will be. If <code>Bar</code> used a <code>__metaclass__</code> attribute that created <code>Bar</code> with <code>type()</code> (and not <code>type.__new__()</code>), the subclasses will not inherit that behavior.&gt;&gt; -- Could you/someone please explain a bit deeper this passage?<br><h4> Comment 76037462 TBBle: </h4>@MaxGoodridge That&#39;s the Python 3 syntax for metaclasses. See <a href="https://docs.python.org/3.6/reference/datamodel.html#metaclasses" rel="nofollow noreferrer">Python 3.6 Data model</a> VS <a href="https://docs.python.org/2.7/reference/datamodel.html?#customizing-class-creation" rel="nofollow noreferrer">Python 2.7 Data model</a><br><h4> Comment 81299800 Brōtsyorfuzthrāx: </h4>It&#39;s a community wiki answer (so, those who commented with corrections/improvements might consider editing their comments into the answer, if they&#39;re sure they are correct).<br><h4> Comment 79928729 Mr_and_Mrs_D: </h4><code>Now you wonder why the heck is it written in lowercase, and not Type?</code> - well because it&#39;s implemented in C - it&#39;s the same reason defaultdict is lowercase while OrderedDict (in python 2) is normal CamelCase<br><h4> Comment 78377186 Philip Stark: </h4>@Deep: The <i>actual</i> metaclass of a class is specified in <code>.__class__</code>, whereas <code>.__metaclass__</code> specifies which callable should be used to alter the class during creation. If for example <code>.__metaclass__</code> contains a function <code>foo_bar()</code> that uses <code>type(x,y,z)</code> to alter the class, then you will have .<code>__metaclass__ = foo_bar</code> which will not be inherited but <code>.__class__</code>  will be <code>type</code>, because that&#39;s what was used to create the new altered class.  Read this a few times. I am 99% sure I haven&#39;t made a mistake ;)<br><h4> Comment 99322592 skytree: </h4>Why <code>type(...)</code> is not really OOP compared with <code>type.__new__(...)</code> ?<br><h4> Comment 110237486 chepner: </h4>@3rdi It&#39;s not really a proper tree, as there is no true root. There is no type that has no metaclass; the metaclass of <code>type</code> is <code>type</code>. It&#39;s this loop in the graph that prevents it from being a tree, and the prevents <code>type</code> from being defined in Python itself. It has to be provided by the implementation.<br><h4> Comment 100469454 karuhanga: </h4><code>Subclasses of a class will be instances of its metaclass if you specified a metaclass-class, but not with a metaclass-function.</code>  Why is this the case?<br><h4> Comment 98173392 polarise: </h4>Dynamically creating methods is a bit more tricky than the text illustrates. While it works here it fails to account for cases where we refer to the <code>self</code> object. For example the method <code>def foo(self, *args, **kwargs): print(self, args, kwargs)</code> will do different things if created dynamically or as part of the class definition. The right way to create it dynamically is to execute the body in a namespace then attach it (see <i>Python Essential Reference 4th Edition, David Beazly p.138</i>).<br><h4> Comment 123090899 ShadowRanger: </h4>@Mr_and_Mrs_D: The rule for <code>lowercase</code> names vs. <code>CapWords</code> isn&#39;t C vs. Python implemented (that would cause problems when they C accelerate a class later on). They&#39;re just inconsistent about it. Built-ins (things you don&#39;t need to import) are always <code>lowercase</code> (though exceptions are <code>Exceptional</code>). Things used in a function-like way (even implemented with classes, e.g. <code>contextlib.closing</code>) are also <code>lowercase</code>. And <i>some</i> things that are subclasses of builtins follow the <code>lowercase</code> convention (<code>defaultdict</code>) while others don&#39;t (<code>OrderedDict</code>); there&#39;s no real rhyme or reason to it.<br><h4> Comment 133838524 Shay Tsadok: </h4>Probably the best answer I have ever read in stackoverflow... Thanks!<br><h4> Comment 134061367 Lokesh Sanapalli: </h4>Wow... what a beautiful writeup... I am obsessed with it... I am in love with this...  Maybe the best explanation is ever written... Thank you for explaining the concept so beautifully...<br><h4> Comment 74073568 Spybdai: </h4>what if indicate different <b>metaclass</b> in both base and derived class?<br><h4> Comment 77936026 pppery: </h4>&quot;type is actually its own metaclass. This is not something you could reproduce in pure Python, and is done by cheating a little bit at the implementation level.&quot; is not true. <code>__class__</code> is writable in Python, so one can create a subclass of type with a custom metaclass, and then set its class to itself.<br><h4> Comment 76475706 Deep: </h4>echoing @petrux question. I was lost at the statement:       <code>Be careful here that the __metaclass__ attribute will not be inherited, the metaclass of the parent (Bar.__class__) will be. If Bar used a __metaclass__ attribute that created Bar with type() (and not type.__new__()), the subclasses will not inherit that behavior.</code>    Can someone please explain this a little bit deeper? Would really appreciate some help here.<br><h4> Comment 136989535 FreelanceConsultant: </h4>Where the line <code>bar = True</code> is - shouldn&#39;t this be <code>self.bar = True</code>?<br><h4> Comment 124959326 Rick Henderson: </h4>I suppose it could also be said that just as <b>int</b> creates <b>int</b> objects, <b>type</b> creates <b>type</b> objects. As in data type.<br><h4> Comment 128375008 smwikipedia: </h4><a href="https://docs.python.org/3/library/functions.html#abs" rel="nofollow noreferrer">docs.python.org/3/library/functions.html#abs</a> lists the builtin functions and <b>types</b>. <code>class type</code> is a built-in type, not a built-in function. Note the <code>class</code> keyword. A built-in function doesn&#39;t have <code>class</code> keyword, such as <code>abs()</code> . So the sentence &quot;<i>It&#39;s because the function type is in fact a metaclass.</i>&quot; is inaccurate.<br><h4> Comment 128376535 smwikipedia: </h4>For <code>return super(UpperAttrMetaclass, cls).__new__(cls, clsname, bases, uppercase_attrs)</code>, why not just <code>return super().__new__(cls, clsname, bases, uppercase_attrs)</code><br><h4> Comment 130224397 ShadowRanger: </h4>@smwikipedia: Because the answer was written back when Python 2 was still common, and no-arg <code>super()</code> is only supported on Python 3. If you&#39;re doing this in Python 3, <code>return super().__new__(cls, clsname, bases, uppercase_attrs)</code> works just fine.<br><h4> Comment 130488656 Gulzar: </h4>I am lost on what gets and doesn&#39;t get inherited by <code>B(A)</code> when some class <code>A</code> defines a metaclass: <code>A(metaclass=...)</code> with its metaclass &quot;doing something&quot;<br><h4> Comment 130488693 Gulzar: </h4>Can anyone please explain why the use of <code>__new__</code> here over <code>__init__</code>? Also, why the explicit call <code>type.__new__</code> over just <code>type()</code>? I fail to see what these complications solve or avoid<br><h4> Comment 109536175 3rdi: </h4>May i know, if everything is an object in Python... type is also an object. So type is also created using some parent class. If we try to understand this where exactly this parent tree ends? What is its root? and how is this all mapped. In short i am asking for how to build something like python from scratch probably.<br><h4> Comment 108823005 artu-hnrq: </h4>Karuhanga, <code>metaclass-function</code> was referring any method that manipulates a class declaration, calling <code>type.__new__(x, y, z)</code> directly in way that no specific <code>__metaclass__</code> is set to the just created class (i.e. its metaclass will be <code>type</code>). Thus this class&#39; subclasses will also have by default its same mataclass (that is, <code>type</code>)<br>------------------------------------------------------------------ <br><h3> Answer 100146 Thomas Wouters: </h3><p>A metaclass is the class of a class. A class defines how an instance of the class (i.e. an object) behaves while a metaclass defines how a class behaves. A class is an instance of a metaclass.</p>

<p>While in Python you can use arbitrary callables for metaclasses (like <a href="https://stackoverflow.com/questions/100003/what-is-a-metaclass-in-python/100037#100037">Jerub</a> shows), the better approach is to make it an actual class itself. <code>type</code> is the usual metaclass in Python. <code>type</code> is itself a class, and it is its own type. You won't be able to recreate something like <code>type</code> purely in Python, but Python cheats a little. To create your own metaclass in Python you really just want to subclass <code>type</code>.</p>

<p>A metaclass is most commonly used as a class-factory. When you create an object by calling the class, Python creates a new class (when it executes the 'class' statement) by calling the metaclass. Combined with the normal <code>__init__</code> and <code>__new__</code> methods, metaclasses therefore allow you to do 'extra things' when creating a class, like registering the new class with some registry or replace the class with something else entirely.</p>

<p>When the <code>class</code> statement is executed, Python first executes the body of the <code>class</code> statement as a normal block of code. The resulting namespace (a dict) holds the attributes of the class-to-be. The metaclass is determined by looking at the baseclasses of the class-to-be (metaclasses are inherited), at the <code>__metaclass__</code> attribute of the class-to-be (if any) or the <code>__metaclass__</code> global variable. The metaclass is then called with the name, bases and attributes of the class to instantiate it.</p>

<p>However, metaclasses actually define the <em>type</em> of a class, not just a factory for it, so you can do much more with them. You can, for instance, define normal methods on the metaclass. These metaclass-methods are like classmethods in that they can be called on the class without an instance, but they are also not like classmethods in that they cannot be called on an instance of the class. <code>type.__subclasses__()</code> is an example of a method on the <code>type</code> metaclass. You can also define the normal 'magic' methods, like <code>__add__</code>, <code>__iter__</code> and <code>__getattr__</code>, to implement or change how the class behaves.</p>

<p>Here's an aggregated example of the bits and pieces:</p>

<pre><code>def make_hook(f):
    """Decorator to turn 'foo' method into '__foo__'"""
    f.is_hook = 1
    return f

class MyType(type):
    def __new__(mcls, name, bases, attrs):

        if name.startswith('None'):
            return None

        # Go over attributes and see if they should be renamed.
        newattrs = {}
        for attrname, attrvalue in attrs.iteritems():
            if getattr(attrvalue, 'is_hook', 0):
                newattrs['__%s__' % attrname] = attrvalue
            else:
                newattrs[attrname] = attrvalue

        return super(MyType, mcls).__new__(mcls, name, bases, newattrs)

    def __init__(self, name, bases, attrs):
        super(MyType, self).__init__(name, bases, attrs)

        # classregistry.register(self, self.interfaces)
        print "Would register class %s now." % self

    def __add__(self, other):
        class AutoClass(self, other):
            pass
        return AutoClass
        # Alternatively, to autogenerate the classname as well as the class:
        # return type(self.__name__ + other.__name__, (self, other), {})

    def unregister(self):
        # classregistry.unregister(self)
        print "Would unregister class %s now." % self

class MyObject:
    __metaclass__ = MyType


class NoneSample(MyObject):
    pass

# Will print "NoneType None"
print type(NoneSample), repr(NoneSample)

class Example(MyObject):
    def __init__(self, value):
        self.value = value
    @make_hook
    def add(self, other):
        return self.__class__(self.value + other.value)

# Will unregister the class
Example.unregister()

inst = Example(10)
# Will fail with an AttributeError
#inst.unregister()

print inst + inst
class Sibling(MyObject):
    pass

ExampleSibling = Example + Sibling
# ExampleSibling is now a subclass of both Example and Sibling (with no
# content of its own) although it will believe it's called 'AutoClass'
print ExampleSibling
print ExampleSibling.__mro__
</code></pre>
<h4> Comment 91736655 Holle van: </h4>ppperry he obviously meant you can&#39;t recreate type without using type itself as a metaclass. Which is fair enough to say.<br><h4> Comment 98519860 BlackShift: </h4>Note that <code>__metaclass__</code> is not supported in Python 3. In Python 3 use <code>class MyObject(metaclass=MyType)</code>, see <a href="https://www.python.org/dev/peps/pep-3115/" rel="nofollow noreferrer">python.org/dev/peps/pep-3115</a> and the answer below.<br><h4> Comment 77935564 pppery: </h4><code>class A(type):pass&lt;NEWLINE&gt;class B(type,metaclass=A):pass&lt;NEWLINE&gt;b.__class__ = b</code><br><h4> Comment 93929134 Ciasto piekarz: </h4>Shouldn&#39;t unregister()  be called by instance of Example class ?<br><h4> Comment 105503046 chepner: </h4>The documentation describes <a href="https://docs.python.org/3/reference/datamodel.html#determining-the-appropriate-metaclass" rel="nofollow noreferrer">how the metaclass is chosen</a>. The metaclass isn&#39;t inherited so much as it is derived. If you specify a metaclass, it has to be a subtype of each base class metaclass; otherwise, you&#39;ll use the a base class metaclass that is a subtype of each other base class metaclass. Note that it is possible that <i>no</i> valid metaclass can be found, and the definition will fail.<br><h4> Comment 103741093 kapad: </h4>@thomas-wouters Is this line <code>metaclasses are inherited</code> correct? <a href="https://stackoverflow.com/questions/100003/what-is-a-metaclass-in-python/100037#100037">Jerub&#39;s</a> answer says that metaclasses <i>are not</i> inherited. Also, what happens if the class subclasses multiple classes, and they each have their own <code>__metaclass__</code> (or two or more parent classes define a <code>__metaclass__</code>).<br><h4> Comment 101851909 kapad: </h4><code>The metaclass is determined by looking at the baseclasses of the class-to-be (metaclasses are inherited), at the __metaclass__ attribute of the class-to-be (if any) or the __metaclass__ global variable.</code>; Is this ordering correct? Or will python first look at <code>__metaclass__</code> in the class-to-be and then it&#39;s baseclasses and then the global <code>__metaclass__</code>?<br><h4> Comment 102430482 George Mauer: </h4>Which version of python does this code example assume and does it matter?<br><h4> Comment 111019130 Vishesh Mangla: </h4>Well can someone also explain what does register tag do? I &#39;m using class X(ABC): from lot of time to create interfaces but what exactly register will enable me to do? The docs literally says one line about register.<br><h4> Comment 115526811 Reinderien: </h4>What @BlackShift says. This could use a big, bold warning at the top that the entire answer is deprecated, as it relies on Python 2 which is itself deprecated.<br>------------------------------------------------------------------ <br><h3> Answer 100037 Jerub: </h3><p><em>Note, this answer is for Python 2.x as it was written in 2008, metaclasses are slightly different in 3.x.</em></p>

<p>Metaclasses are the secret sauce that make 'class' work. The default metaclass for a new style object is called 'type'.</p>

<pre class="lang-none prettyprint-override"><code>class type(object)
  |  type(object) -&gt; the object's type
  |  type(name, bases, dict) -&gt; a new type
</code></pre>

<p>Metaclasses take 3 args. '<strong>name</strong>', '<strong>bases</strong>' and '<strong>dict</strong>'</p>

<p>Here is where the secret starts. Look for where name, bases and the dict come from in this example class definition.</p>

<pre><code>class ThisIsTheName(Bases, Are, Here):
    All_the_code_here
    def doesIs(create, a):
        dict
</code></pre>

<p>Lets define a metaclass that will demonstrate how '<strong>class:</strong>' calls it.</p>

<pre><code>def test_metaclass(name, bases, dict):
    print 'The Class Name is', name
    print 'The Class Bases are', bases
    print 'The dict has', len(dict), 'elems, the keys are', dict.keys()

    return "yellow"

class TestName(object, None, int, 1):
    __metaclass__ = test_metaclass
    foo = 1
    def baz(self, arr):
        pass

print 'TestName = ', repr(TestName)

# output =&gt; 
The Class Name is TestName
The Class Bases are (&lt;type 'object'&gt;, None, &lt;type 'int'&gt;, 1)
The dict has 4 elems, the keys are ['baz', '__module__', 'foo', '__metaclass__']
TestName =  'yellow'
</code></pre>

<p>And now, an example that actually means something, this will automatically make the variables in the list "attributes" set on the class, and set to None.</p>

<pre><code>def init_attributes(name, bases, dict):
    if 'attributes' in dict:
        for attr in dict['attributes']:
            dict[attr] = None

    return type(name, bases, dict)

class Initialised(object):
    __metaclass__ = init_attributes
    attributes = ['foo', 'bar', 'baz']

print 'foo =&gt;', Initialised.foo
# output=&gt;
foo =&gt; None
</code></pre>

<p><strong>Note that the magic behaviour that <code>Initialised</code> gains by having the metaclass <code>init_attributes</code> is not passed onto a subclass of <code>Initialised</code>.</strong></p>

<p>Here is an even more concrete example, showing how you can subclass 'type' to make a metaclass that performs an action when the class is created. This is quite tricky:</p>

<pre><code>class MetaSingleton(type):
    instance = None
    def __call__(cls, *args, **kw):
        if cls.instance is None:
            cls.instance = super(MetaSingleton, cls).__call__(*args, **kw)
        return cls.instance

class Foo(object):
    __metaclass__ = MetaSingleton

a = Foo()
b = Foo()
assert a is b
</code></pre>
------------------------------------------------------------------ <br><h3> Answer 6428779 kindall: </h3><p>Others have explained how metaclasses work and how they fit into the Python type system. Here's an example of what they can be used for. In a testing framework I wrote, I wanted to keep track of the order in which classes were defined, so that I could later instantiate them in this order. I found it easiest to do this using a metaclass.</p>

<pre><code>class MyMeta(type):

    counter = 0

    def __init__(cls, name, bases, dic):
        type.__init__(cls, name, bases, dic)
        cls._order = MyMeta.counter
        MyMeta.counter += 1

class MyType(object):              # Python 2
    __metaclass__ = MyMeta

class MyType(metaclass=MyMeta):    # Python 3
    pass
</code></pre>

<p>Anything that's a subclass of <code>MyType</code> then gets a class attribute <code>_order</code> that records the order in which the classes were defined.</p>
<h4> Comment 98108978 kindall: </h4>I wanted the classes themselves, not their instances, to be numbered.<br><h4> Comment 119148264 kindall: </h4>It was a documentation testing framework and the classes were declarative descriptions of the specific files to be tested, tests to be run, and so forth. The framework reported the results of these in a nicely formatted report grouped by product, document, and test. The report was more useful if it the tests were run in a predictable order.  :-)<br><h4> Comment 103320847 mike rodent: </h4>This is a jolly interesting example, not least because one can genuinely see why a metaclass could be neeeded with this, to supply a solution to a specific difficulty. OTOH I struggle to be convinced that anyone would really need to instantiate objects in the order in which their classes were defined: I guess we just have to take your word for that :).<br><h4> Comment 98151100 Michael Gundlach: </h4>Right, duh. Thanks. My code would reset MyType&#39;s attribute on every instantiation, and would never set the attribute if an instance of MyType was never created.  Oops.  (And a class property could also work, but unlike the metaclass it offers no obvious place to store the counter.)<br><h4> Comment 98108709 Michael Gundlach: </h4>Thanks for the example.  Why did you find this easier than inheriting from MyBase, whose <code>__init__(self)</code> says <code>type(self)._order = MyBase.counter; MyBase.counter += 1</code> ?<br>------------------------------------------------------------------ <br><h3> Answer 100091 Antti Rasinen: </h3><p>One use for metaclasses is adding new properties and methods to an instance automatically.</p>

<p>For example, if you look at <a href="http://docs.djangoproject.com/en/dev/topics/db/models/" rel="noreferrer">Django models</a>, their definition looks a bit confusing. It looks as if you are only defining class properties:</p>

<pre><code>class Person(models.Model):
    first_name = models.CharField(max_length=30)
    last_name = models.CharField(max_length=30)
</code></pre>

<p>However, at runtime the Person objects are filled with all sorts of useful methods. See the <a href="http://code.djangoproject.com/browser/django/trunk/django/db/models/base.py" rel="noreferrer">source</a> for some amazing metaclassery.</p>
<h4> Comment 70991701 trixn: </h4>Isn&#39;t the use of meta classes adding new properties and methods to a <b>class</b> and not an instance? As far as i understood it the meta class alters the class itself and as a result the instances can be constructed differently by the altered class. Could be a bit misleading to people who try to get the nature of a meta class. Having useful methods on instances can be achieved by normal inherence. The reference to Django code as an example is good, though.<br>------------------------------------------------------------------ <br><h3> Answer 100059 Matthias Kestenholz: </h3><p>I think the ONLamp introduction to metaclass programming is well written and gives a really good introduction to the topic despite being several years old already.</p>

<p><a href="http://www.onlamp.com/pub/a/python/2003/04/17/metaclasses.html" rel="noreferrer">http://www.onlamp.com/pub/a/python/2003/04/17/metaclasses.html</a> (archived at <a href="https://web.archive.org/web/20080206005253/http://www.onlamp.com/pub/a/python/2003/04/17/metaclasses.html" rel="noreferrer">https://web.archive.org/web/20080206005253/http://www.onlamp.com/pub/a/python/2003/04/17/metaclasses.html</a>)</p>

<p>In short: A class is a blueprint for the creation of an instance, a metaclass is a blueprint for the creation of a class. It can be easily seen that in Python classes need to be first-class objects too to enable this behavior.</p>

<p>I've never written one myself, but I think one of the nicest uses of metaclasses can be seen in the <a href="http://www.djangoproject.com/" rel="noreferrer">Django framework</a>. The model classes use a metaclass approach to enable a declarative style of writing new models or form classes. While the metaclass is creating the class, all members get the possibility to customize the class itself.</p>

<ul>
<li><a href="http://docs.djangoproject.com/en/dev/intro/tutorial01/#id3" rel="noreferrer">Creating a new model</a></li>
<li><a href="http://code.djangoproject.com/browser/django/trunk/django/db/models/base.py#L25" rel="noreferrer">The metaclass enabling this</a></li>
</ul>

<p>The thing that's left to say is: If you don't know what metaclasses are, the probability that you <strong>will not need them</strong> is 99%.</p>
------------------------------------------------------------------ <br><h3> Answer 31930795 Russia Must Remove Putin: </h3><blockquote>
  <h2>What are metaclasses? What do you use them for?</h2>
</blockquote>

<p>TLDR: A metaclass instantiates and defines behavior for a class just like a class instantiates and defines behavior for an instance. </p>

<p>Pseudocode:</p>

<pre><code>&gt;&gt;&gt; Class(...)
instance
</code></pre>

<p>The above should look familiar. Well, where does <code>Class</code> come from? It's an instance of a metaclass (also pseudocode):</p>

<pre><code>&gt;&gt;&gt; Metaclass(...)
Class
</code></pre>

<p>In real code, we can pass the default metaclass, <code>type</code>, everything we need to instantiate a class and we get a class:</p>

<pre><code>&gt;&gt;&gt; type('Foo', (object,), {}) # requires a name, bases, and a namespace
&lt;class '__main__.Foo'&gt;
</code></pre>

<h2>Putting it differently</h2>

<ul>
<li><p>A class is to an instance as a metaclass is to a class. </p>

<p>When we instantiate an object, we get an instance:</p>

<pre><code>&gt;&gt;&gt; object()                          # instantiation of class
&lt;object object at 0x7f9069b4e0b0&gt;     # instance
</code></pre>

<p>Likewise, when we define a class explicitly with the default metaclass, <code>type</code>, we instantiate it:</p>

<pre><code>&gt;&gt;&gt; type('Object', (object,), {})     # instantiation of metaclass
&lt;class '__main__.Object'&gt;             # instance
</code></pre></li>
<li><p>Put another way, a class is an instance of a metaclass:</p>

<pre><code>&gt;&gt;&gt; isinstance(object, type)
True
</code></pre></li>
<li><p>Put a third way, a metaclass is a class's class.</p>

<pre><code>&gt;&gt;&gt; type(object) == type
True
&gt;&gt;&gt; object.__class__
&lt;class 'type'&gt;
</code></pre></li>
</ul>

<p>When you write a class definition and Python executes it, it uses a metaclass to instantiate the class object (which will, in turn, be used to instantiate instances of that class).</p>

<p>Just as we can use class definitions to change how custom object instances behave, we can use a metaclass class definition to change the way a class object behaves.</p>

<p>What can they be used for? From the <a href="https://docs.python.org/3/reference/datamodel.html#metaclass-example" rel="noreferrer">docs</a>:</p>

<blockquote>
  <p>The potential uses for metaclasses are boundless. Some ideas that have been explored include logging, interface checking, automatic delegation, automatic property creation, proxies, frameworks, and automatic resource locking/synchronization.</p>
</blockquote>

<p>Nevertheless, it is usually encouraged for users to avoid using metaclasses unless absolutely necessary.</p>

<h1>You use a metaclass every time you create a class:</h1>

<p>When you write a class definition, for example, like this,</p>

<pre><code>class Foo(object): 
    'demo'
</code></pre>

<p>You instantiate a class object.</p>

<pre><code>&gt;&gt;&gt; Foo
&lt;class '__main__.Foo'&gt;
&gt;&gt;&gt; isinstance(Foo, type), isinstance(Foo, object)
(True, True)
</code></pre>

<p>It is the same as functionally calling <code>type</code> with the appropriate arguments and assigning the result to a variable of that name:</p>

<pre><code>name = 'Foo'
bases = (object,)
namespace = {'__doc__': 'demo'}
Foo = type(name, bases, namespace)
</code></pre>

<p>Note, some things automatically get added to the <code>__dict__</code>, i.e., the namespace:</p>

<pre><code>&gt;&gt;&gt; Foo.__dict__
dict_proxy({'__dict__': &lt;attribute '__dict__' of 'Foo' objects&gt;, 
'__module__': '__main__', '__weakref__': &lt;attribute '__weakref__' 
of 'Foo' objects&gt;, '__doc__': 'demo'})
</code></pre>

<p>The <em>metaclass</em> of the object we created, in both cases, is <code>type</code>. </p>

<p>(A side-note on the contents of the class <code>__dict__</code>: <code>__module__</code> is there because classes must know where they are defined, and  <code>__dict__</code> and <code>__weakref__</code> are there because we don't define <code>__slots__</code> - if we <a href="https://stackoverflow.com/q/472000/541136">define <code>__slots__</code></a> we'll save a bit of space in the instances, as we can disallow <code>__dict__</code> and <code>__weakref__</code> by excluding them. For example:</p>

<pre><code>&gt;&gt;&gt; Baz = type('Bar', (object,), {'__doc__': 'demo', '__slots__': ()})
&gt;&gt;&gt; Baz.__dict__
mappingproxy({'__doc__': 'demo', '__slots__': (), '__module__': '__main__'})
</code></pre>

<p>... but I digress.)</p>

<h1>We can extend <code>type</code> just like any other class definition:</h1>

<p>Here's the default <code>__repr__</code> of classes:</p>

<pre><code>&gt;&gt;&gt; Foo
&lt;class '__main__.Foo'&gt;
</code></pre>

<p>One of the most valuable things we can do by default in writing a Python object is to provide it with a good <code>__repr__</code>. When we call <code>help(repr)</code> we learn that there's a good test for a <code>__repr__</code> that also requires a test for equality - <code>obj == eval(repr(obj))</code>. The following simple implementation of <code>__repr__</code> and <code>__eq__</code> for class instances of our type class provides us with a demonstration that may improve on the default <code>__repr__</code> of classes:</p>

<pre><code>class Type(type):
    def __repr__(cls):
        """
        &gt;&gt;&gt; Baz
        Type('Baz', (Foo, Bar,), {'__module__': '__main__', '__doc__': None})
        &gt;&gt;&gt; eval(repr(Baz))
        Type('Baz', (Foo, Bar,), {'__module__': '__main__', '__doc__': None})
        """
        metaname = type(cls).__name__
        name = cls.__name__
        parents = ', '.join(b.__name__ for b in cls.__bases__)
        if parents:
            parents += ','
        namespace = ', '.join(': '.join(
          (repr(k), repr(v) if not isinstance(v, type) else v.__name__))
               for k, v in cls.__dict__.items())
        return '{0}(\'{1}\', ({2}), {{{3}}})'.format(metaname, name, parents, namespace)
    def __eq__(cls, other):
        """
        &gt;&gt;&gt; Baz == eval(repr(Baz))
        True            
        """
        return (cls.__name__, cls.__bases__, cls.__dict__) == (
                other.__name__, other.__bases__, other.__dict__)
</code></pre>

<p>So now when we create an object with this metaclass, the <code>__repr__</code> echoed on the command line provides a much less ugly sight than the default:</p>

<pre><code>&gt;&gt;&gt; class Bar(object): pass
&gt;&gt;&gt; Baz = Type('Baz', (Foo, Bar,), {'__module__': '__main__', '__doc__': None})
&gt;&gt;&gt; Baz
Type('Baz', (Foo, Bar,), {'__module__': '__main__', '__doc__': None})
</code></pre>

<p>With a nice <code>__repr__</code> defined for the class instance, we have a stronger ability to debug our code. However, much further checking with <code>eval(repr(Class))</code> is unlikely (as functions would be rather impossible to eval from their default <code>__repr__</code>'s).</p>

<h1>An expected usage: <code>__prepare__</code> a namespace</h1>

<p>If, for example, we want to know in what order a class's methods are created in, we could provide an ordered dict as the namespace of the class. We would do this with <code>__prepare__</code> which <a href="https://docs.python.org/3/reference/datamodel.html#preparing-the-class-namespace" rel="noreferrer">returns the namespace dict for the class if it is implemented in Python 3</a>: </p>

<pre><code>from collections import OrderedDict

class OrderedType(Type):
    @classmethod
    def __prepare__(metacls, name, bases, **kwargs):
        return OrderedDict()
    def __new__(cls, name, bases, namespace, **kwargs):
        result = Type.__new__(cls, name, bases, dict(namespace))
        result.members = tuple(namespace)
        return result
</code></pre>

<p>And usage:</p>

<pre><code>class OrderedMethodsObject(object, metaclass=OrderedType):
    def method1(self): pass
    def method2(self): pass
    def method3(self): pass
    def method4(self): pass
</code></pre>

<p>And now we have a record of the order in which these methods (and other class attributes) were created:</p>

<pre><code>&gt;&gt;&gt; OrderedMethodsObject.members
('__module__', '__qualname__', 'method1', 'method2', 'method3', 'method4')
</code></pre>

<p>Note, this example was adapted from the <a href="https://docs.python.org/3/reference/datamodel.html#metaclass-example" rel="noreferrer">documentation</a> - the new <a href="https://github.com/python/cpython/blob/master/Lib/enum.py" rel="noreferrer">enum in the standard library</a> does this.</p>

<p>So what we did was instantiate a metaclass by creating a class. We can also treat the metaclass as we would any other class. It has a method resolution order:</p>

<pre><code>&gt;&gt;&gt; inspect.getmro(OrderedType)
(&lt;class '__main__.OrderedType'&gt;, &lt;class '__main__.Type'&gt;, &lt;class 'type'&gt;, &lt;class 'object'&gt;)
</code></pre>

<p>And it has approximately the correct <code>repr</code> (which we can no longer eval unless we can find a way to represent our functions.):</p>

<pre><code>&gt;&gt;&gt; OrderedMethodsObject
OrderedType('OrderedMethodsObject', (object,), {'method1': &lt;function OrderedMethodsObject.method1 at 0x0000000002DB01E0&gt;, 'members': ('__module__', '__qualname__', 'method1', 'method2', 'method3', 'method4'), 'method3': &lt;function OrderedMet
hodsObject.method3 at 0x0000000002DB02F0&gt;, 'method2': &lt;function OrderedMethodsObject.method2 at 0x0000000002DB0268&gt;, '__module__': '__main__', '__weakref__': &lt;attribute '__weakref__' of 'OrderedMethodsObject' objects&gt;, '__doc__': None, '__d
ict__': &lt;attribute '__dict__' of 'OrderedMethodsObject' objects&gt;, 'method4': &lt;function OrderedMethodsObject.method4 at 0x0000000002DB0378&gt;})
</code></pre>
------------------------------------------------------------------ <br><h3> Answer 35732111 Ethan Furman: </h3><p><strong>Python 3 update</strong></p>

<p>There are (at this point) two key methods in a metaclass:</p>

<ul>
<li><code>__prepare__</code>, and</li>
<li><code>__new__</code></li>
</ul>

<p><code>__prepare__</code> lets you supply a custom mapping (such as an <code>OrderedDict</code>) to be used as the namespace while the class is being created.  You must return an instance of whatever namespace you choose.  If you don't implement <code>__prepare__</code> a normal <code>dict</code> is used.</p>

<p><code>__new__</code> is responsible for the actual creation/modification of the final class.</p>

<p>A bare-bones, do-nothing-extra metaclass would like:</p>

<pre><code>class Meta(type):

    def __prepare__(metaclass, cls, bases):
        return dict()

    def __new__(metacls, cls, bases, clsdict):
        return super().__new__(metacls, cls, bases, clsdict)
</code></pre>

<p>A simple example:</p>

<p>Say you want some simple validation code to run on your attributes -- like it must always be an <code>int</code> or a <code>str</code>.  Without a metaclass, your class would look something like:</p>

<pre><code>class Person:
    weight = ValidateType('weight', int)
    age = ValidateType('age', int)
    name = ValidateType('name', str)
</code></pre>

<p>As you can see, you have to repeat the name of the attribute twice.  This makes typos possible along with irritating bugs.</p>

<p>A simple metaclass can address that problem:</p>

<pre><code>class Person(metaclass=Validator):
    weight = ValidateType(int)
    age = ValidateType(int)
    name = ValidateType(str)
</code></pre>

<p>This is what the metaclass would look like (not using <code>__prepare__</code> since it is not needed):</p>

<pre><code>class Validator(type):
    def __new__(metacls, cls, bases, clsdict):
        # search clsdict looking for ValidateType descriptors
        for name, attr in clsdict.items():
            if isinstance(attr, ValidateType):
                attr.name = name
                attr.attr = '_' + name
        # create final class and return it
        return super().__new__(metacls, cls, bases, clsdict)
</code></pre>

<p>A sample run of:</p>

<pre><code>p = Person()
p.weight = 9
print(p.weight)
p.weight = '9'
</code></pre>

<p>produces:</p>

<pre><code>9
Traceback (most recent call last):
  File "simple_meta.py", line 36, in &lt;module&gt;
    p.weight = '9'
  File "simple_meta.py", line 24, in __set__
    (self.name, self.type, value))
TypeError: weight must be of type(s) &lt;class 'int'&gt; (got '9')
</code></pre>

<hr>

<p><strong>Note</strong>:  This example is simple enough it could have also been accomplished with a class decorator, but presumably an actual metaclass would be doing much more.</p>

<p>The 'ValidateType' class for reference:</p>

<pre><code>class ValidateType:
    def __init__(self, type):
        self.name = None  # will be set by metaclass
        self.attr = None  # will be set by metaclass
        self.type = type
    def __get__(self, inst, cls):
        if inst is None:
            return self
        else:
            return inst.__dict__[self.attr]
    def __set__(self, inst, value):
        if not isinstance(value, self.type):
            raise TypeError('%s must be of type(s) %s (got %r)' %
                    (self.name, self.type, value))
        else:
            inst.__dict__[self.attr] = value
</code></pre>
<h4> Comment 107036974 Lars: </h4>Note that since python 3.6, you can use <code>__set_name__(cls, name)</code> in the descriptor (<code>ValidateType</code>) to set the name in the descriptor (<code>self.name</code> and in this case also <code>self.attr</code>). This was added to not have to dive into metaclasses for this specific common use case (see PEP 487).<br>------------------------------------------------------------------ <br><h3> Answer 40017019 Michael Ekoka: </h3><h1>Role of a metaclass' <code>__call__()</code> method when creating a class instance</h1>

<p>If you've done Python programming for more than a few months you'll eventually stumble upon code that looks like this:</p>

<pre><code># define a class
class SomeClass(object):
    # ...
    # some definition here ...
    # ...

# create an instance of it
instance = SomeClass()

# then call the object as if it's a function
result = instance('foo', 'bar')
</code></pre>

<p>The latter is possible when you implement the <code>__call__()</code> magic method on the class.</p>

<pre><code>class SomeClass(object):
    # ...
    # some definition here ...
    # ...

    def __call__(self, foo, bar):
        return bar + foo
</code></pre>

<p>The <code>__call__()</code> method is invoked when an instance of a class is used as a callable. But as we've seen from previous answers a class itself is an instance of a metaclass, so when we use the class as a callable (i.e. when we create an instance of it) we're actually calling its metaclass' <code>__call__()</code> method. At this point most Python programmers are a bit confused because they've been told that when creating an instance like this <code>instance = SomeClass()</code> you're calling its <code>__init__()</code> method. Some who've dug a bit deeper know that before <code>__init__()</code> there's <code>__new__()</code>. Well, today another layer of truth is being revealed, before <code>__new__()</code> there's the metaclass' <code>__call__()</code>.</p>

<p>Let's study the method call chain from specifically the perspective of creating an instance of a class.</p>

<p>This is a metaclass that logs exactly the moment before an instance is created and the moment it's about to return it.</p>

<pre><code>class Meta_1(type):
    def __call__(cls):
        print "Meta_1.__call__() before creating an instance of ", cls
        instance = super(Meta_1, cls).__call__()
        print "Meta_1.__call__() about to return instance."
        return instance
</code></pre>

<p>This is a class that uses that metaclass</p>

<pre><code>class Class_1(object):

    __metaclass__ = Meta_1

    def __new__(cls):
        print "Class_1.__new__() before creating an instance."
        instance = super(Class_1, cls).__new__(cls)
        print "Class_1.__new__() about to return instance."
        return instance

    def __init__(self):
        print "entering Class_1.__init__() for instance initialization."
        super(Class_1,self).__init__()
        print "exiting Class_1.__init__()."
</code></pre>

<p>And now let's create an instance of <code>Class_1</code></p>

<pre><code>instance = Class_1()
# Meta_1.__call__() before creating an instance of &lt;class '__main__.Class_1'&gt;.
# Class_1.__new__() before creating an instance.
# Class_1.__new__() about to return instance.
# entering Class_1.__init__() for instance initialization.
# exiting Class_1.__init__().
# Meta_1.__call__() about to return instance.
</code></pre>

<p>Observe that the code above doesn't actually do anything more than logging the tasks. Each method delegates the actual work to its parent's implementation, thus keeping the default behavior. Since <code>type</code> is <code>Meta_1</code>'s parent class (<code>type</code> being the default parent metaclass) and considering the ordering sequence of the output above, we now have a clue as to what would be the pseudo implementation of <code>type.__call__()</code>:</p>

<pre><code>class type:
    def __call__(cls, *args, **kwarg):

        # ... maybe a few things done to cls here

        # then we call __new__() on the class to create an instance
        instance = cls.__new__(cls, *args, **kwargs)

        # ... maybe a few things done to the instance here

        # then we initialize the instance with its __init__() method
        instance.__init__(*args, **kwargs)

        # ... maybe a few more things done to instance here

        # then we return it
        return instance
</code></pre>

<p>We can see that the metaclass' <code>__call__()</code> method is the one that's called first. It then delegates creation of the instance to the class's <code>__new__()</code> method and initialization to the instance's <code>__init__()</code>. It's also the one that ultimately returns the instance.</p>

<p>From the above it stems that the metaclass' <code>__call__()</code> is also given the opportunity to decide whether or not a call to <code>Class_1.__new__()</code> or <code>Class_1.__init__()</code> will eventually be made. Over the course of its execution it could actually return an object that hasn't been touched by either of these methods. Take for example this approach to the singleton pattern:</p>

<pre><code>class Meta_2(type):
    singletons = {}

    def __call__(cls, *args, **kwargs):
        if cls in Meta_2.singletons:
            # we return the only instance and skip a call to __new__()
            # and __init__()
            print ("{} singleton returning from Meta_2.__call__(), "
                   "skipping creation of new instance.".format(cls))
            return Meta_2.singletons[cls]

        # else if the singleton isn't present we proceed as usual
        print "Meta_2.__call__() before creating an instance."
        instance = super(Meta_2, cls).__call__(*args, **kwargs)
        Meta_2.singletons[cls] = instance
        print "Meta_2.__call__() returning new instance."
        return instance

class Class_2(object):

    __metaclass__ = Meta_2

    def __new__(cls, *args, **kwargs):
        print "Class_2.__new__() before creating instance."
        instance = super(Class_2, cls).__new__(cls)
        print "Class_2.__new__() returning instance."
        return instance

    def __init__(self, *args, **kwargs):
        print "entering Class_2.__init__() for initialization."
        super(Class_2, self).__init__()
        print "exiting Class_2.__init__()."
</code></pre>

<p>Let's observe what happens when repeatedly trying to create an object of type <code>Class_2</code></p>

<pre><code>a = Class_2()
# Meta_2.__call__() before creating an instance.
# Class_2.__new__() before creating instance.
# Class_2.__new__() returning instance.
# entering Class_2.__init__() for initialization.
# exiting Class_2.__init__().
# Meta_2.__call__() returning new instance.

b = Class_2()
# &lt;class '__main__.Class_2'&gt; singleton returning from Meta_2.__call__(), skipping creation of new instance.

c = Class_2()
# &lt;class '__main__.Class_2'&gt; singleton returning from Meta_2.__call__(), skipping creation of new instance.

a is b is c # True
</code></pre>
<h4> Comment 104328842 Rich Lysakowski PhD: </h4>This is a good addition to the previously upvoted &quot;accepted answer&quot;.  It provides examples for intermediate coders to chew on.<br>------------------------------------------------------------------ <br><h3> Answer 21999253 Craig: </h3><p>A <code>metaclass</code> is a class that tells how (some) other class should be created.</p>
<p>This is a case where I saw <code>metaclass</code> as a solution to my problem:
I had a really complicated problem, that probably could have been solved differently, but I chose to solve it using a <code>metaclass</code>.  Because of the complexity, it is one of the few modules I have written where the comments in the module surpass the amount of code that has been written.  Here it is...</p>
<pre class="lang-py prettyprint-override"><code>#!/usr/bin/env python

# Copyright (C) 2013-2014 Craig Phillips.  All rights reserved.

# This requires some explaining.  The point of this metaclass excercise is to
# create a static abstract class that is in one way or another, dormant until
# queried.  I experimented with creating a singlton on import, but that did
# not quite behave how I wanted it to.  See now here, we are creating a class
# called GsyncOptions, that on import, will do nothing except state that its
# class creator is GsyncOptionsType.  This means, docopt doesn't parse any
# of the help document, nor does it start processing command line options.
# So importing this module becomes really efficient.  The complicated bit
# comes from requiring the GsyncOptions class to be static.  By that, I mean
# any property on it, may or may not exist, since they are not statically
# defined; so I can't simply just define the class with a whole bunch of
# properties that are @property @staticmethods.
#
# So here's how it works:
#
# Executing 'from libgsync.options import GsyncOptions' does nothing more
# than load up this module, define the Type and the Class and import them
# into the callers namespace.  Simple.
#
# Invoking 'GsyncOptions.debug' for the first time, or any other property
# causes the __metaclass__ __getattr__ method to be called, since the class
# is not instantiated as a class instance yet.  The __getattr__ method on
# the type then initialises the class (GsyncOptions) via the __initialiseClass
# method.  This is the first and only time the class will actually have its
# dictionary statically populated.  The docopt module is invoked to parse the
# usage document and generate command line options from it.  These are then
# paired with their defaults and what's in sys.argv.  After all that, we
# setup some dynamic properties that could not be defined by their name in
# the usage, before everything is then transplanted onto the actual class
# object (or static class GsyncOptions).
#
# Another piece of magic, is to allow command line options to be set in
# in their native form and be translated into argparse style properties.
#
# Finally, the GsyncListOptions class is actually where the options are
# stored.  This only acts as a mechanism for storing options as lists, to
# allow aggregation of duplicate options or options that can be specified
# multiple times.  The __getattr__ call hides this by default, returning the
# last item in a property's list.  However, if the entire list is required,
# calling the 'list()' method on the GsyncOptions class, returns a reference
# to the GsyncListOptions class, which contains all of the same properties
# but as lists and without the duplication of having them as both lists and
# static singlton values.
#
# So this actually means that GsyncOptions is actually a static proxy class...
#
# ...And all this is neatly hidden within a closure for safe keeping.
def GetGsyncOptionsType():
    class GsyncListOptions(object):
        __initialised = False

    class GsyncOptionsType(type):
        def __initialiseClass(cls):
            if GsyncListOptions._GsyncListOptions__initialised: return

            from docopt import docopt
            from libgsync.options import doc
            from libgsync import __version__

            options = docopt(
                doc.__doc__ % __version__,
                version = __version__,
                options_first = True
            )

            paths = options.pop('&lt;path&gt;', None)
            setattr(cls, &quot;destination_path&quot;, paths.pop() if paths else None)
            setattr(cls, &quot;source_paths&quot;, paths)
            setattr(cls, &quot;options&quot;, options)

            for k, v in options.iteritems():
                setattr(cls, k, v)

            GsyncListOptions._GsyncListOptions__initialised = True

        def list(cls):
            return GsyncListOptions

        def __getattr__(cls, name):
            cls.__initialiseClass()
            return getattr(GsyncListOptions, name)[-1]

        def __setattr__(cls, name, value):
            # Substitut option names: --an-option-name for an_option_name
            import re
            name = re.sub(r'^__', &quot;&quot;, re.sub(r'-', &quot;_&quot;, name))
            listvalue = []

            # Ensure value is converted to a list type for GsyncListOptions
            if isinstance(value, list):
                if value:
                    listvalue = [] + value
                else:
                    listvalue = [ None ]
            else:
                listvalue = [ value ]

            type.__setattr__(GsyncListOptions, name, listvalue)

    # Cleanup this module to prevent tinkering.
    import sys
    module = sys.modules[__name__]
    del module.__dict__['GetGsyncOptionsType']

    return GsyncOptionsType

# Our singlton abstract proxy class.
class GsyncOptions(object):
    __metaclass__ = GetGsyncOptionsType()
</code></pre>
<h4> Comment 126889979 Leroy Scandal: </h4>pylint says your code has been rated at -1.03/10.<br>------------------------------------------------------------------ <br><h3> Answer 41338238 noɥʇʎԀʎzɐɹƆ: </h3><h2>The tl;dr version</h2>

<p>The <code>type(obj)</code> function gets you the type of an object. </p>

<p><strong>The <code>type()</code> of a class is its <em>metaclass</em>.</strong></p>

<p>To use a metaclass:</p>

<pre><code>class Foo(object):
    __metaclass__ = MyMetaClass
</code></pre>

<p><code>type</code> is its own metaclass. The class of a class is a metaclass-- the body of a class is the arguments passed to the metaclass that is used to construct the class.</p>

<p><a href="https://docs.python.org/3/reference/datamodel.html#metaclasses" rel="noreferrer">Here</a> you can read about how to use metaclasses to customize class construction.</p>
------------------------------------------------------------------ <br><h3> Answer 38858285 Mushahid Khan: </h3><p><code>type</code> is actually a <code>metaclass</code> -- a class that creates another classes.
Most <code>metaclass</code> are the subclasses of <code>type</code>. The <code>metaclass</code> receives the <code>new</code> class as its first argument and provide access to class object with details as mentioned below:</p>

<pre><code>&gt;&gt;&gt; class MetaClass(type):
...     def __init__(cls, name, bases, attrs):
...         print ('class name: %s' %name )
...         print ('Defining class %s' %cls)
...         print('Bases %s: ' %bases)
...         print('Attributes')
...         for (name, value) in attrs.items():
...             print ('%s :%r' %(name, value))
... 

&gt;&gt;&gt; class NewClass(object, metaclass=MetaClass):
...    get_choch='dairy'
... 
class name: NewClass
Bases &lt;class 'object'&gt;: 
Defining class &lt;class 'NewClass'&gt;
get_choch :'dairy'
__module__ :'builtins'
__qualname__ :'NewClass'
</code></pre>

<p><code>Note:</code></p>

<p>Notice that the class was not instantiated at any time; the simple act of creating the class triggered execution of the <code>metaclass</code>.</p>
------------------------------------------------------------------ <br><h3> Answer 45074712 Xingzhou Liu: </h3><p>Python classes are themselves objects - as in instance - of their meta-class. </p>

<p>The default metaclass, which is applied when when you determine classes as:</p>

<pre><code>class foo:
    ...
</code></pre>

<p>meta class are used to apply some rule to an entire set of classes. For example, suppose you're building an ORM to access a database, and you want records from each table to be of a class mapped to that table (based on fields, business rules, etc..,), a possible use of metaclass is for instance, connection pool logic, which is share by all classes of record from all tables. Another use is logic to to support foreign keys, which involves multiple classes of records. </p>

<p>when you define metaclass, you subclass type, and can overrided the following magic methods to insert your logic. </p>

<pre><code>class somemeta(type):
    __new__(mcs, name, bases, clsdict):
      """
  mcs: is the base metaclass, in this case type.
  name: name of the new class, as provided by the user.
  bases: tuple of base classes 
  clsdict: a dictionary containing all methods and attributes defined on class

  you must return a class object by invoking the __new__ constructor on the base metaclass. 
 ie: 
    return type.__call__(mcs, name, bases, clsdict).

  in the following case:

  class foo(baseclass):
        __metaclass__ = somemeta

  an_attr = 12

  def bar(self):
      ...

  @classmethod
  def foo(cls):
      ...

      arguments would be : ( somemeta, "foo", (baseclass, baseofbase,..., object), {"an_attr":12, "bar": &lt;function&gt;, "foo": &lt;bound class method&gt;}

      you can modify any of these values before passing on to type
      """
      return type.__call__(mcs, name, bases, clsdict)


    def __init__(self, name, bases, clsdict):
      """ 
      called after type has been created. unlike in standard classes, __init__ method cannot modify the instance (cls) - and should be used for class validaton.
      """
      pass


    def __prepare__():
        """
        returns a dict or something that can be used as a namespace.
        the type will then attach methods and attributes from class definition to it.

        call order :

        somemeta.__new__ -&gt;  type.__new__ -&gt; type.__init__ -&gt; somemeta.__init__ 
        """
        return dict()

    def mymethod(cls):
        """ works like a classmethod, but for class objects. Also, my method will not be visible to instances of cls.
        """
        pass
</code></pre>

<p>anyhow, those two are the most commonly used hooks. metaclassing is powerful, and above is nowhere near and exhaustive list of uses for metaclassing. </p>
------------------------------------------------------------------ <br><h3> Answer 48222963 binbjz: </h3><p>The type() function can return the type of an object or create a new type, </p>

<p>for example, we can create a Hi class with the type() function and do not  need to use this way with class Hi(object):</p>

<pre><code>def func(self, name='mike'):
    print('Hi, %s.' % name)

Hi = type('Hi', (object,), dict(hi=func))
h = Hi()
h.hi()
Hi, mike.

type(Hi)
type

type(h)
__main__.Hi
</code></pre>

<p>In addition to using type() to create classes dynamically, you can control creation behavior of class and use metaclass.</p>

<p>According to the Python object model, the class is the object, so the class must be an instance of another certain class.
By default, a Python class is instance of the type class. That is, type is metaclass of most of the built-in classes and metaclass of user-defined classes.</p>

<pre><code>class ListMetaclass(type):
    def __new__(cls, name, bases, attrs):
        attrs['add'] = lambda self, value: self.append(value)
        return type.__new__(cls, name, bases, attrs)

class CustomList(list, metaclass=ListMetaclass):
    pass

lst = CustomList()
lst.add('custom_list_1')
lst.add('custom_list_2')

lst
['custom_list_1', 'custom_list_2']
</code></pre>

<p>Magic will take effect when we passed keyword arguments in metaclass, it indicates the Python interpreter to create the CustomList through ListMetaclass. <strong>new</strong> (), at this point, we can modify the class definition, for example, and add a new method and then return the revised definition.</p>
------------------------------------------------------------------ <br><h3> Answer 52344780 Andy Jazz: </h3><p>In addition to the published answers I can say that a <code>metaclass</code> defines the behaviour for a class. So, you can explicitly set your metaclass. Whenever Python gets a keyword <code>class</code> then it starts searching for the <code>metaclass</code>. If it's not found – the default metaclass type is used to create the class's object. Using the <code>__metaclass__</code> attribute, you can set <code>metaclass</code> of your class:</p>

<pre><code>class MyClass:
   __metaclass__ = type
   # write here other method
   # write here one more method

print(MyClass.__metaclass__)
</code></pre>

<p>It'll produce the output like this:</p>

<pre><code>class 'type'
</code></pre>

<p>And, of course, you can create your own <code>metaclass</code> to define the behaviour of any class that are created using your class.</p>

<p>For doing that, your default <code>metaclass</code> type class must be inherited as this is the main <code>metaclass</code>:</p>

<pre><code>class MyMetaClass(type):
   __metaclass__ = type
   # you can write here any behaviour you want

class MyTestClass:
   __metaclass__ = MyMetaClass

Obj = MyTestClass()
print(Obj.__metaclass__)
print(MyMetaClass.__metaclass__)
</code></pre>

<p>The output will be:</p>

<pre><code>class '__main__.MyMetaClass'
class 'type'
</code></pre>
------------------------------------------------------------------ <br><h3> Answer 60504738 Lars: </h3><p>Note that in python 3.6 a new dunder method <code>__init_subclass__(cls, **kwargs)</code> was introduced to replace a lot of common use cases for metaclasses. Is is called when a subclass of the defining class is created. See <a href="https://docs.python.org/3.6/reference/datamodel.html" rel="noreferrer">python docs</a>.</p>
------------------------------------------------------------------ <br><h3> Answer 59424178 Carson: </h3><p>Here's another example of what it can be used for:</p>

<ul>
<li>You can use the <code>metaclass</code> to change the function of its instance (the class).</li>
</ul>

<pre><code>class MetaMemberControl(type):
    __slots__ = ()

    @classmethod
    def __prepare__(mcs, f_cls_name, f_cls_parents,  # f_cls means: future class
                    meta_args=None, meta_options=None):  # meta_args and meta_options is not necessarily needed, just so you know.
        f_cls_attr = dict()
        if not "do something or if you want to define your cool stuff of dict...":
            return dict(make_your_special_dict=None)
        else:
            return f_cls_attr

    def __new__(mcs, f_cls_name, f_cls_parents, f_cls_attr,
                meta_args=None, meta_options=None):

        original_getattr = f_cls_attr.get('__getattribute__')
        original_setattr = f_cls_attr.get('__setattr__')

        def init_getattr(self, item):
            if not item.startswith('_'):  # you can set break points at here
                alias_name = '_' + item
                if alias_name in f_cls_attr['__slots__']:
                    item = alias_name
            if original_getattr is not None:
                return original_getattr(self, item)
            else:
                return super(eval(f_cls_name), self).__getattribute__(item)

        def init_setattr(self, key, value):
            if not key.startswith('_') and ('_' + key) in f_cls_attr['__slots__']:
                raise AttributeError(f"you can't modify private members:_{key}")
            if original_setattr is not None:
                original_setattr(self, key, value)
            else:
                super(eval(f_cls_name), self).__setattr__(key, value)

        f_cls_attr['__getattribute__'] = init_getattr
        f_cls_attr['__setattr__'] = init_setattr

        cls = super().__new__(mcs, f_cls_name, f_cls_parents, f_cls_attr)
        return cls


class Human(metaclass=MetaMemberControl):
    __slots__ = ('_age', '_name')

    def __init__(self, name, age):
        self._name = name
        self._age = age

    def __getattribute__(self, item):
        """
        is just for IDE recognize.
        """
        return super().__getattribute__(item)

    """ with MetaMemberControl then you don't have to write as following
    @property
    def name(self):
        return self._name

    @property
    def age(self):
        return self._age
    """


def test_demo():
    human = Human('Carson', 27)
    # human.age = 18  # you can't modify private members:_age  &lt;-- this is defined by yourself.
    # human.k = 18  # 'Human' object has no attribute 'k'  &lt;-- system error.
    age1 = human._age  # It's OK, although the IDE will show some warnings. (Access to a protected member _age of a class)

    age2 = human.age  # It's OK! see below:
    """
    if you do not define `__getattribute__` at the class of Human,
    the IDE will show you: Unresolved attribute reference 'age' for class 'Human'
    but it's ok on running since the MetaMemberControl will help you.
    """


if __name__ == '__main__':
    test_demo()

</code></pre>

<p>The <code>metaclass</code> is powerful, there are many things (such as monkey magic) you can do with it, but be careful this may only be known to you.</p>
------------------------------------------------------------------ <br><h3> Answer 68417609 Manukumar: </h3><p><strong>The top answer is correct</strong>.</p>
<p>But readers may be coming here searching answers about similarly named inner classes. They are present in popular libraries, such as <code>Django</code> and <code>WTForms</code>.</p>
<p>As DavidW points out in the comments beneath this answer, <strong>these are <em>library-specific</em> features and are not to be confused with the advanced, unrelated <em>Python language</em> feature with a similar name</strong>.</p>
<p>Rather, these are namespaces within classes' dicts. They are constructed using inner classes for sake of readability.</p>
<p>In this example special field, <code>abstract</code> is visibly separate from fields of Author model.</p>
<pre><code>from django.db import models

class Author(models.Model):
    name = models.CharField(max_length=50)
    email = models.EmailField()

    class Meta:
        abstract = True
</code></pre>
<p>Another example is from the documentation for <code>WTForms</code>:</p>
<pre><code>from wtforms.form import Form
from wtforms.csrf.session import SessionCSRF
from wtforms.fields import StringField

class MyBaseForm(Form):
    class Meta:
        csrf = True
        csrf_class = SessionCSRF

    name = StringField(&quot;name&quot;)
</code></pre>
<p>This syntax does not get special treatment in the python programming language. <code>Meta</code> is not a keyword here, and does not trigger metaclass behavior. Rather, third-party library code in packages like <code>Django</code> and <code>WTForms</code> reads this property in the constructors of certain classes, and elsewhere.</p>
<p>The presence of these declarations modifies the behavior of the classes that have these declarations. For example, <code>WTForms</code> reads <code>self.Meta.csrf</code> to determine if the form needs a <code>csrf</code> field.</p>
<h4> Comment 121895614 DavidW: </h4>This is a Django-specific feature where a nested class called <code>Meta</code> has a special meaning. The question is about an unrelated Python language feature with a similar name.<br><h4> Comment 122439128 DavidW: </h4>@AlexWaygood I&#39;d probably have rejected the edit (too big a change...) but I can see that it does clarify something that&#39;s a point of confusion so it probably is useful. With that in mind, I&#39;ve removed my downvote.<br><h4> Comment 122440234 Alex Waygood: </h4>@DavidW yeah, I think you could argue it both ways. I wouldn&#39;t normally approve an edit that large. But I felt like it kept to the spirit of the original post, and it seemed like a fair amount of work had gone into a noble endeavour (clarifying a legitimate point of confusion), so decided to approve.<br><h4> Comment 122429868 Alex Waygood: </h4>@DavidW — hamilyon undertook a heroic edit of this post. It&#39;s now, in my opinion, quite a useful answer.<br>------------------------------------------------------------------ <br><h3> Answer 56945952 Venu Gopal Tewari: </h3><p>In object-oriented programming, a metaclass is a class whose instances are classes. Just as an ordinary class defines the behavior of certain objects, a metaclass defines the behavior of certain class and their instances
The term metaclass simply means something used to create classes. In other words, it is the class of a class. The metaclass is used to create the class so like the object being an instance of a class, a class is an instance of a metaclass. In python classes are also considered objects.</p>
<h4> Comment 100573238 verisimilitude: </h4>Rather than giving bookish definitions, would have been better if you had added some examples. The first line of your answer seems to have been copied from the Wikipedia entry of Metaclasses.<br><h4> Comment 100596443 Venu Gopal Tewari: </h4>@verisimilitude I am also learning can you help me improving this answer by providing some practical examples from your experience ??<br>------------------------------------------------------------------ <br><h3> Answer 59818321 Swati Srivastava: </h3><p>A class, in Python, is an object, and just like any other object, it is an instance of "something". This "something" is what is termed as a Metaclass. This metaclass is a special type of class that creates other class's objects. Hence, metaclass is responsible for making new classes. This allows the programmer to customize the way classes are generated.</p>

<p>To create a metaclass, overriding of <strong>new</strong>() and <strong>init</strong>() methods is usually done. <strong>new</strong>() can be overridden to change the way objects are created, while <strong>init</strong>() can be overridden to change the way of initializing the object. Metaclass can be created by a number of ways. One of the ways is to use type() function. type() function, when called with 3 parameters, creates a metaclass. The parameters are :-</p>

<ol>
<li>Class Name</li>
<li>Tuple having base classes inherited by class</li>
<li>A dictionary having all class methods and class variables</li>
</ol>

<p>Another way of creating a metaclass comprises of 'metaclass' keyword. Define the metaclass as a simple class. In the parameters of inherited class, pass metaclass=metaclass_name</p>

<p>Metaclass can be specifically used in the following situations :-</p>

<ol>
<li>when a particular effect has to be applied to all the subclasses</li>
<li>Automatic change of class (on creation) is required</li>
<li>By API developers</li>
</ol>
------------------------------------------------------------------ <br><h3> Answer 68354618 Emma Brown: </h3><p>I saw an interesting use case for metaclasses in a package called <code>classutilities</code>. It checks if all class variables are in upper case format (it is convenient to have unified logic for configuration classes), and checks if there are no instance level methods in class.
Another interesting example for metaclases was deactivation of unittests based on complex conditions (checking values of multiple environmental variables).</p>
------------------------------------------------------------------ <br><h3> Answer 67201732 DrosnickX: </h3><p>In Python, a metaclass is a subclass of a subclass that determines how a subclass behaves. A class is an instance of another metaclass. In Python, a class specifies how the class's instance will behave.</p>
<p>Since metaclasses are in charge of class generation, you can write your own custom metaclasses to change how classes are created by performing additional actions or injecting code. Custom metaclasses aren't always important, but they can be.</p>
------------------------------------------------------------------ <br><h3> Answer 69426577 Delta: </h3><p>look this:</p>
<pre class="lang-py prettyprint-override"><code>Python 3.10.0rc2 (tags/v3.10.0rc2:839d789, Sep  7 2021, 18:51:45) [MSC v.1929 64 bit (AMD64)] on win32
Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.
&gt;&gt;&gt; class Object:
...     pass
... 
&gt;&gt;&gt; class Meta(type):
...     test = 'Worked!!!'
...     def __repr__(self):
...             return 'This is &quot;Meta&quot; metaclass'
... 
&gt;&gt;&gt; class ObjectWithMetaClass(metaclass=Meta):
...     pass
... 
&gt;&gt;&gt; Object or type(Object())
&lt;class '__main__.Object'&gt;
&gt;&gt;&gt; ObjectWithMetaClass or type(ObjectWithMetaClass())
This is &quot;Meta&quot; metaclass
&gt;&gt;&gt; Object.test
AttributeError: ...
&gt;&gt;&gt; ObjectWithMetaClass.test
'Worked!!!'
&gt;&gt;&gt; type(Object)
&lt;class 'type'&gt;
&gt;&gt;&gt; type(ObjectWithMetaClass)
&lt;class '__main__.Meta'&gt;
&gt;&gt;&gt; type(type(ObjectWithMetaClass))
&lt;class 'type'&gt;
&gt;&gt;&gt; Object.__bases__
(&lt;class 'object'&gt;,)
&gt;&gt;&gt; ObjectWithMetaClass.__bases__
(&lt;class 'object'&gt;,)
&gt;&gt;&gt; type(ObjectWithMetaClass).__bases__
(&lt;class 'type'&gt;,)
&gt;&gt;&gt; Object.__mro__
(&lt;class '__main__.Object'&gt;, &lt;class 'object'&gt;)
&gt;&gt;&gt; ObjectWithMetaClass.__mro__
(This is &quot;Meta&quot; metaclass, &lt;class 'object'&gt;)
&gt;&gt;&gt; 
</code></pre>
<p>In other words, when an object was not created (type of object), we looking MetaClass.</p>
------------------------------------------------------------------ <br><h3> Answer 75418816 user3197067: </h3><p>i want to add a little on why <code>type.__new__()</code> over <code>type()</code></p>
<p>first, take a look at following classes</p>
<pre><code>In [1]: class MyMeta(type):
   ...:     def __new__(cls, cls_name, bases, attrs):
   ...:         print(cls, cls_name, bases, attrs)
   ...:         return super().__new__(cls, cls_name, bases, attrs)
   ...:

In [2]: class AClass(metaclass=MyMeta):
   ...:     pass
   ...:
&lt;class '__main__.MyMeta'&gt; AClass () {'__module__': '__main__', '__qualname__': 'AClass'}

In [3]: class BClass:
   ...:     pass
   ...:

In [4]: AClass.__class__
Out[4]: __main__.MyMeta

In [5]: BClass.__class__
Out[5]: type

In [6]: class SubAClass(AClass):
   ...:     pass
   ...:
&lt;class '__main__.MyMeta'&gt; SubAClass (&lt;class '__main__.AClass'&gt;,) {'__module__': '__main__', '__qualname__': 'SubAClass'}
</code></pre>
<ol>
<li><p><code>type.__new__</code> just assigned <code>MyMeta</code> to <code>AClass.__class__</code>.</p>
<p>how? <code>type.__new__</code> would take the first parameter cls, which</p>
<p>is MyMeta, and execute <code>AClass.__class__ = MyMeta</code>.</p>
<p>when we tried to create SubAClass a subclass of AClass, Python would</p>
<p>take a look at the metaclass we designated to be used to create SubAClass</p>
<p>and in this case, we did not pass a metaclass for SubAClass, so Python got a None for metaclass.</p>
<p>then Python would try to pick up the metaclass of the first base class of SubAClass, apparently it got <code>MyMeta</code>.</p>
</li>
<li><p>if you called <code>type()</code> instead of <code>type.__new__</code>, then we</p>
<p>would have <code>AClass.__class__</code> to be <code>type</code>. why?</p>
<p><code>type()</code> still calls <code>type.__new__</code> but passes <code>type</code> as the first parameter implicitly.</p>
<p>that means AClass would be equivalent of BClass, both of them have type</p>
<p>as their <code>__class__</code> attr</p>
</li>
</ol>
<h2>how the searching of metaclass works in C code?</h2>
<p>it works pretty much like what we've just mentioned</p>
<p>the function <code>builtin___build_class__</code> would be called when you defined a class</p>
<p>and code is just so straightforward</p>
<pre><code>static PyObject *
builtin___build_class__(PyObject *self, PyObject *const *args, Py_ssize_t nargs,
                        PyObject *kwnames){

    if (meta == NULL) {
        /* if there are no bases, use type: */
        if (PyTuple_GET_SIZE(bases) == 0) {
            meta = (PyObject *) (&amp;PyType_Type);
        }
        /* else get the type of the first base */
        else {
            PyObject *base0 = PyTuple_GET_ITEM(bases, 0);
            meta = (PyObject *)Py_TYPE(base0);
        }
        Py_INCREF(meta);
        isclass = 1;  /* meta is really a class */
    }

    PyObject *margs[3] = {name, bases, ns};
    cls = PyObject_VectorcallDict(meta, margs, 3, mkw);
}
</code></pre>
<p>basically, <code>meta = (PyObject *)Py_TYPE(base0);</code> is everything we want to know</p>
<p>it can be translated to be
<code>meta = Py_TYPE(AClass) = MyMeta = AClass.__class__</code></p>
------------------------------------------------------------------ <br><h3> Answer 75343419 Neha Sharma: </h3><p>In Python or in any other language we have a type for every variable or object we declare. For getting type of anything(variable,object,etc.) in Python we can use type() function.</p>
<p>Bypassing the metaclass keyword in the class definition we can customize the class creation process.</p>
<pre><code>class meta(type):
    pass
class baseclass(metaclass=meta): # This is Mestaclass
    pass
class derivedclass(baseclass):
    pass
print(type(meta))
print(type(baseclass))
print(type(derivedclass))
</code></pre>
<p>When defining a new class if no metaclass is defined the default type metaclass is used. If a given metaclass is not the object(instance) of type(), in that situation it is used directly as a metaclass.</p>
