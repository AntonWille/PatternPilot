 <h2> Title: What is the best way to delete a value from an array in Perl? </h2> <h3> user21246, question_id: 174292 </h3>Score: 89, Tags: {arrays,perl} <br><p>The array has lots of data and I need to delete two elements. </p>

<p>Below is the code snippet I am using,</p>

<pre><code>my @array = (1,2,3,4,5,5,6,5,4,9);
my $element_omitted = 5;
@array = grep { $_ != $element_omitted } @array;
</code></pre>
<h4> Comment 53270058 Medlock Perlman: </h4>This deletes three elements.<br><h4> Comment 76555915 taiko: </h4>needed top remove all non-file item form directory listing and                     &quot;   array = grep { -f $_ } array   &quot; worked like a charm for me :)<br>------------------------------------------------------------------ <br><h3> Answer 174313 SquareCog: </h3><p>Use splice if you already know the index of the element you want to delete.</p>

<p>Grep works if you are searching.</p>

<p>If you need to do a lot of these, you will get much better performance if you keep your array in sorted order, since you can then do binary search to find the necessary index.</p>

<p>If it makes sense in your context, you may want to consider using a "magic value" for deleted records, rather then deleting them, to save on data movement -- set deleted elements to undef, for example.  Naturally, this has its own issues (if you need to know the number of "live" elements, you need to keep track of it separately, etc), but may be worth the trouble depending on your application.</p>

<p><strong>Edit</strong> Actually now that I take a second look -- don't use the grep code above. It would be more efficient to find the index of the element you want to delete, then use splice to delete it (the code you have accumulates all the non-matching results..)</p>

<pre><code>my $index = 0;
$index++ until $arr[$index] eq 'foo';
splice(@arr, $index, 1);
</code></pre>

<p>That will delete the first occurrence.
Deleting all occurrences is very similar, except you will want to get all indexes in one pass:</p>

<pre><code>my @del_indexes = grep { $arr[$_] eq 'foo' } 0..$#arr;
</code></pre>

<p>The rest is left as an excercise for the reader -- remember that the array changes as you splice it!</p>

<p><strong>Edit2</strong> John Siracusa correctly pointed out I had a bug in my example.. fixed, sorry about that.</p>
<h4> Comment 24195634 Amir.F: </h4>if the string is not found, the loop will get stuck, so do my $index = 0;     my $count = scalar @arr;     $index++ until $arr[$index] eq &#39;foo&#39; or $index==$count;     splice(@arr, $index, 1);<br><h4> Comment 71620711 Reflective: </h4>or <code>my ($index) = grep { $arr[$_] eq &#39;foo&#39; } 0..$#arr; if (defined $index) {splice(@arr, $index, 1);  }</code> - for the first match<br>------------------------------------------------------------------ <br><h3> Answer 174298 spoulson: </h3><p><a href="http://www.perlmonks.org/?node=perlfunc%3Asplice" rel="noreferrer">splice</a> will remove array element(s) by index.  Use grep, as in your example, to search and remove.</p>
<h4> Comment 59026 user21246: </h4>Thanks spoulson. I donno the indices that I have to delete and so I had to resort to grep.<br>------------------------------------------------------------------ <br><h3> Answer 57323341 Chetan: </h3><p>You can simply do this:</p>

<pre><code>my $input_Color = 'Green';
my @array = qw(Red Blue Green Yellow Black);
@array = grep {!/$input_Color/} @array;
print "@array";
</code></pre>
------------------------------------------------------------------ <br><h3> Answer 174353 tvanfosson: </h3><p>Is this something you are going to be doing a lot?  If so, you may want to consider a different data structure.  Grep is going to search the entire array every time and for a large array could be quite costly.  If speed is an issue then you may want to consider using a Hash instead.</p>

<p>In your example, the key would be the number and the value would be the count of elements of that number.</p>
------------------------------------------------------------------ <br><h3> Answer 14191738 dean: </h3><p>if you change</p>

<pre><code>my @del_indexes = grep { $arr[$_] eq 'foo' } 0..$#arr;
</code></pre>

<p>to </p>

<pre><code>my @del_indexes = reverse(grep { $arr[$_] eq 'foo' } 0..$#arr);
</code></pre>

<p>This avoids the array renumbering issue by removing elements from the back of the array first.
Putting a splice() in a foreach loop cleans up @arr. Relatively simple and readable...</p>

<pre><code>foreach $item (@del_indexes) {
   splice (@arr,$item,1);
}
</code></pre>
------------------------------------------------------------------ <br><h3> Answer 47399712 oryan_dunn: </h3><p>You could use array slicing instead of splicing.  Grep to return the indices you want keep and use slicing:</p>
<pre><code>my @arr = ...;
# run through each item.
my @indicesToKeep = grep { $arr[$_] ne 'foo' } 0..$#arr;
@arr = @arr[@indicesToKeep];
</code></pre>
<h4> Comment 83145492 Keve: </h4>I particularly like the logic and elegance of this approach.<br><h4> Comment 105011390 soger: </h4>Yes indeed, you can even write it as a one-liner like: <code>@arr = @arr[grep ...]</code> which I particularly like. I&#39;m not sure how efficient it is, but I&#39;m gonna start using it because it can&#39;t be worse than the other solutions.<br>------------------------------------------------------------------ <br><h3> Answer 36719021 Federico: </h3><p>The best I found was a combination of "undef" and "grep":</p>

<pre><code>foreach $index ( @list_of_indexes_to_be_skiped ) {
      undef($array[$index]);
}
@array = grep { defined($_) } @array;
</code></pre>

<p>That does the trick!
Federico</p>
<h4> Comment 76127242 Deanna: </h4>@BoontaweeHome, the <code>grep</code> at the end then removes them.<br><h4> Comment 116167462 brian d foy: </h4>If you already know the index, just use <code>splice</code>.<br><h4> Comment 63082928 Boontawee Home: </h4>undef set the element value to null. The total elements (size) still the same.<br>------------------------------------------------------------------ <br><h3> Answer 174860 Axeman: </h3><h2>I think your solution is the simplest and most maintainable.</h2>

<p>The rest of the post documents the difficulty of turning tests on elements into <code>splice</code> offsets. Thus, making it a more <em>complete</em> answer. </p>

<p>Look at the <strong><em>gyrations</em></strong> you have to go through to have an efficient (i.e. one-pass) algorithm to turn tests on list items into indexes. And it's not that intuitive at all. </p>

<pre><code>sub array_remove ( \@&amp; ) { 
    my ( $arr_ref, $test_block ) = @_;
    my $sp_start  = 0;
    my $sp_len    = 0;
    for ( my $inx = 0; $inx &lt;= $#$arr_ref; $inx++ ) {
        local $_ = $arr_ref-&gt;[$inx];
        next unless $test_block-&gt;( $_ );
        if ( $sp_len &gt; 0 &amp;&amp; $inx &gt; $sp_start + $sp_len ) {
            splice( @$arr_ref, $sp_start, $sp_len );
            $inx    = $inx - $sp_len;
            $sp_len = 0;
        }
        $sp_start = $inx if ++$sp_len == 1;
    }
    splice( @$arr_ref, $sp_start, $sp_len ) if $sp_len &gt; 0;
    return;
}
</code></pre>
<h4> Comment 63870 Axeman: </h4>Somebody deleted my comment that you clearly did not read the text.<br><h4> Comment 62341 Randal Schwartz: </h4>A simple &quot;grep&quot; is going to be a lot easier to understand and more efficient than that.<br>------------------------------------------------------------------ <br><h3> Answer 11906012 Tom Lime: </h3><p>Delete all occurrences of 'something' if array.</p>

<p><strong>Based on SquareCog answer's:</strong></p>

<pre><code>my @arr = ('1','2','3','4','3','2', '3','4','3');
my @dix = grep { $arr[$_] eq '4' } 0..$#arr;
my $o = 0;
for (@dix) {
    splice(@arr, $_-$o, 1);
    $o++;
}
print join("\n", @arr);
</code></pre>

<p>Each time we remove index from <code>@arr</code>, the next correct index to delete will be <code>$_-current_loop_step</code>.</p>
------------------------------------------------------------------ <br><h3> Answer 23017956 Rich: </h3><p>You can use the non-capturing group and a pipe delim list of items to remove.</p>

<pre><code>
perl -le '@ar=(1 .. 20);@x=(8,10,3,17);$x=join("|",@x);@ar=grep{!/^(?:$x)$/o} @ar;print "@ar"'
</code></pre>
------------------------------------------------------------------ <br><h3> Answer 15381061 BBT: </h3><p>A similar code I once wrote to remove strings not starting with SB.1 from an array of strings</p>

<pre><code>my @adoSymbols=('SB.1000','RT.10000','PC.10000');
##Remove items from an array from backward
for(my $i=$#adoSymbols;$i&gt;=0;$i--) {  
    unless ($adoSymbols[$i] =~ m/^SB\.1/) {splice(@adoSymbols,$i,1);}
}
</code></pre>
------------------------------------------------------------------ <br><h3> Answer 14766395 Ariel Monaco: </h3><p>I use:</p>

<pre><code>delete $array[$index];
</code></pre>

<p>Perldoc <a href="http://perldoc.perl.org/functions/delete.html" rel="nofollow"><strong>delete</strong></a>.</p>
<h4> Comment 21143454 D&#233;j&#224; vu: </h4><i>delete</i> on array value is likely to be deprecated (see your doc)<br><h4> Comment 37992592 Rooster: </h4>this just deletes the value stored at that array index.  at least in my version of perl, (5.14)<br><h4> Comment 79284280 mivk: </h4>This does NOT really delete what you think. It only deletes the value, making it <code>undef</code>. Besides, from the doc linked by ring&#248; : &quot;WARNING: Calling delete on array values is strongly discouraged. The notion of deleting or checking the existence of Perl array elements is not conceptually coherent, and can lead to surprising behavior.&quot; (the previous paragraph in the doc has all the gory details).<br><h4> Comment 135666434 Ariel Monaco: </h4>my original answer is from 10 years ago<br>------------------------------------------------------------------ <br><h3> Answer 54716603 Gilles Maisonneuve: </h3><p>Just to be sure I have benchmarked grep and map solutions, first searching for indexes of matched elements (those to remove) and then directly removing the elements by grep without searching for the indexes.
I appears that the first solution proposed by Sam when asking his question was already the fastest.</p>

<pre><code>    use Benchmark;
    my @A=qw(A B C A D E A F G H A I J K L A M N);
    my @M1; my @G; my @M2;
    my @Ashrunk;
    timethese( 1000000, {
      'map1' =&gt; sub {
          my $i=0;
          @M1 = map { $i++; $_ eq 'A' ? $i-1 : ();} @A;
      },
      'map2' =&gt; sub {
          my $i=0;
          @M2 = map { $A[$_] eq 'A' ? $_ : () ;} 0..$#A;
      },
      'grep' =&gt; sub {
          @G = grep { $A[$_] eq 'A' } 0..$#A;
      },
      'grem' =&gt; sub {
          @Ashrunk = grep { $_ ne 'A' } @A;
      },
    });
</code></pre>

<p>The result is:</p>

<pre><code>Benchmark: timing 1000000 iterations of grem, grep, map1, map2...
  grem:  4 wallclock secs ( 3.37 usr +  0.00 sys =  3.37 CPU) @ 296823.98/s (n=1000000)
  grep:  3 wallclock secs ( 2.95 usr +  0.00 sys =  2.95 CPU) @ 339213.03/s (n=1000000)
  map1:  4 wallclock secs ( 4.01 usr +  0.00 sys =  4.01 CPU) @ 249438.76/s (n=1000000)
  map2:  2 wallclock secs ( 3.67 usr +  0.00 sys =  3.67 CPU) @ 272702.48/s (n=1000000)
M1 = 0 3 6 10 15
M2 = 0 3 6 10 15
G = 0 3 6 10 15
Ashrunk = B C D E F G H I J K L M N
</code></pre>

<p>As shown by elapsed times, it's useless to try to implement a remove
function using either grep or map defined indexes. Just grep-remove directly.</p>

<p>Before testing I was thinking "map1" would be the most efficient... I should more often rely on Benchmark I guess. ;-)</p>
------------------------------------------------------------------ <br><h3> Answer 174334 Powerlord: </h3><p>If you know the array index, you can <a href="http://perldoc.perl.org/functions/delete.html" rel="nofollow noreferrer">delete()</a> it.  The difference between splice() and delete() is that delete() does not renumber the remaining elements of the array.</p>
<h4> Comment 59528 Powerlord: </h4>I actually meant renumber, which according to Perldoc, splice() does.<br>------------------------------------------------------------------ <br><h3> Answer 67238432 Jacques: </h3><p>This works well too:</p>
<pre><code>my @array = (1,2,3,4,5,5,6,5,4,9);
my $element_omitted = 5;
for( my $i = 0; $i &lt; scalar( @array ); $i++ )
{
    splice( @array, $i ), $i-- if( $array[$i] == $element_omitted );
}
say &quot;@array&quot;; # 1 2 3 4 6 4 9
</code></pre>
