 <h2> Title: Why are Perl 5&#39;s function prototypes bad? </h2> <h3> Alnitak, question_id: 297034 </h3>Score: 122, Tags: {perl,function,prototype} <br><p>In <a href="https://stackoverflow.com/questions/204467/is-there-a-perl-function-to-turn-a-string-into-a-regexp-to-use-that-string-as-p">another Stack&nbsp;Overflow question</a> <a href="https://stackoverflow.com/users/4727/leon-timmermans">Leon Timmermans</a> asserted:</p>

<blockquote>
  <p>I would advice you not to use prototypes. They have their uses, but not for most cases and definitely not in this one.</p>
</blockquote>

<p>Why might this be true (or otherwise)? I almost always supply prototypes for my Perl functions, and I've never before seen anyone else say anything bad about using them.</p>
<h4> Comment 16502656 tchrist: </h4>May I please recommend that you read the article, <a href="http://www.perlmonks.org/?node_id=861966" rel="nofollow noreferrer">“Perl Prototypes Considered Harmful”</a>?<br><h4> Comment 143783 Paul Tomblin: </h4>I&#39;m curious too.  The only time I don&#39;t use them is when I&#39;m calling with a variable number of arguments.<br>------------------------------------------------------------------ <br><h3> Answer 297265 Michael Carman: </h3><p>Prototypes aren't bad if used correctly. The difficulty is that Perl's prototypes don't work the way people often expect them to. People with a background in other programming languages tend to expect prototypes to provide a mechanism for checking that function calls are correct: that is, that they have the right number and type of arguments. Perl's prototypes are not well-suited for this task. It's the <em>misuse</em> that's bad. Perl's prototypes have a singular and very different purpose:</p>

<p><strong>Prototypes allow you to define functions that behave like built-in functions.</strong></p>

<ul>
<li>Parentheses are optional.</li>
<li>Context is imposed on the arguments.</li>
</ul>

<p>For example, you could define a function like this:</p>

<pre><code>sub mypush(\@@) { ... }
</code></pre>

<p>and call it as</p>

<pre><code>mypush @array, 1, 2, 3;
</code></pre>

<p>without needing to write the <code>\</code> to take a reference to the array.</p>

<p>In a nutshell, prototypes let you create your own syntactic sugar. For example the Moose framework uses them to emulate a more typical OO syntax.</p>

<p>This is very useful but prototypes are very limited:</p>

<ul>
<li>They have to be visible at compile-time.</li>
<li>They can be bypassed.</li>
<li>Propagating context to arguments can cause unexpected behavior.</li>
<li>They can make it difficult to call functions using anything other than the
strictly prescribed form.</li>
</ul>

<p>See <a href="http://perldoc.perl.org/perlsub.html#Prototypes" rel="noreferrer">Prototypes</a> in perlsub for all the gory details.</p>
<h4> Comment 61214898 Peter Mortensen: </h4>So they are a misnomer, then?<br><h4> Comment 16502682 tchrist: </h4><a href="http://www.perlmonks.org/?node_id=861966" rel="nofollow noreferrer">Far More Than Everything You Ever Wanted to Know about Perl Prototypes</a>.<br><h4> Comment 145704 Alnitak: </h4>I&#39;ve accepted this answer because I feel it best answers the question - prototypes aren&#39;t intrinsically bad, it&#39;s just how you use them.<br><h4> Comment 687337 Kent Fredric: </h4>Moose prototypes on the otherhand, are /awesome/ <a href="http://p3rl.org/MooseX::Declare" rel="nofollow noreferrer">p3rl.org/MooseX::Declare</a> <a href="http://p3rl.org/MooseX::Method::Signatures" rel="nofollow noreferrer">p3rl.org/MooseX::Method::Signatures</a><br>------------------------------------------------------------------ <br><h3> Answer 297095 cjm: </h3><p>The problem is that Perl's function prototypes don't do what people think they do.  Their purpose is to allow you to write functions that will be parsed like Perl's built-in functions.</p>

<p>First of all, method calls completely ignore prototypes.  If you're doing OO programming, it doesn't matter what prototype your methods have.  (So they shouldn't have any prototype.)</p>

<p>Second, prototypes aren't strictly enforced.  If you call a subroutine with <code>&amp;function(...)</code>, the prototype is ignored.  So they don't really provide any type safety.</p>

<p>Third, they're spooky action-at-a-distance.  (Especially the <code>$</code> prototype, which causes the corresponding parameter to be evaluated in scalar context, instead of the default list context.)</p>

<p>In particular, they make it hard to pass parameters from arrays.  For example:</p>

<pre><code>my @array = qw(a b c);

foo(@array);
foo(@array[0..1]);
foo($array[0], $array[1], $array[2]);

sub foo ($;$$) { print "@_\n" }

foo(@array);
foo(@array[0..1]);
foo($array[0], $array[1], $array[2]);
</code></pre>

<p>prints:</p>

<pre><code>a b c
a b
a b c
3
b
a b c
</code></pre>

<p>along with 3 warnings about <code>main::foo() called too early to check prototype</code> (if warnings are enabled).  The problem is that an array (or array slice) evaluated in scalar context returns the length of the array.</p>

<p>If you need to write a function that acts like a built-in, use a prototype.  Otherwise, don't use prototypes.</p>

<p>Note:  Perl 6 will have completely revamped and very useful prototypes.  This answer applies only to Perl 5.</p>
<h4> Comment 13613670 pilcrow: </h4>Correction:  array slicing returns a <i>list</i>, so an array slice in a scalar context returns the final element of the list.  Your second-to-last invocation of <code>foo()</code> prints 2 because that is the final element in your two element slice.  Change to <code>my @array = qw(foo bar baz)</code> and you&#39;ll see the difference.  (As an aside, this is why I don&#39;t initialize arrays/lists to 0- or 1-based numeric sequences in throw-away, demonstrative code.  Confusion between indices, counts, and elements in contexts has bitten me more than once.  Silly but true.)<br><h4> Comment 143855 friedo: </h4>There are better ways to validate arguments, such as the Params::Validate module: <a href="http://search.cpan.org/~drolsky/Params-Validate-0.91/lib/Params/Validate.pm" rel="nofollow noreferrer">search.cpan.org/~drolsky/Params-Validate-0.91/lib/Params/&hellip;</a><br><h4> Comment 143810 Jonathan Leffler: </h4>No; the general consensus is that Perl function prototypes provide essentially no benefit.  You may as well not bother with them, at least in Perl 5.  Perl 6 might be a different (better) story.<br><h4> Comment 42604826 Flimm: </h4>@pilcrow: I edited the answer to use <code>a b c</code> to make your point clearer.<br><h4> Comment 143788 Paul Tomblin: </h4>But they still provide a useful check that your caller and the sub are using the same number of arguments, so what&#39;s wrong with that?<br><h4> Comment 143799 Alnitak: </h4>that&#39;s sort of the point of my question - I never use the old &amp;func syntax, so the prototype does provide useful function parameter checking.<br>------------------------------------------------------------------ <br><h3> Answer 299467 Leon Timmermans: </h3><p>I agree with the above two posters. In general, using <code>$</code> should be avoided. Prototypes are only useful when using block arguments (<code>&amp;</code>), globs (<code>*</code>), or reference prototypes (<code>\@</code>, <code>\$</code>, <code>\%</code>, <code>\*</code>)</p>
<h4> Comment 52839930 The Sidhekin: </h4>In general, perhaps, but I&#39;d like to mention two exceptions: First, the <code>($)</code> prototype creates a named unary operator, which can be useful (certainly Perl finds them useful; I have too, on occasion).  Second, when overriding built-ins (whether through import or using CORE::GLOBAL::), you should in general stick to whatever prototype the built-in had, even if that includes a <code>$</code>, or you might surprise the programmer (yourself, even) with list context where the built-in would otherwise provide scalar context.<br>------------------------------------------------------------------ <br><h3> Answer 36825170 brian d foy: </h3><p>Some people, looking at a Perl subroutine prototype, thinks it means something that it doesn't:</p>

<pre><code>sub some_sub ($$) { ... }
</code></pre>

<p>To Perl, that means that the parser expects two arguments. It's Perl's way of letting you create subroutines that behave like built-ins, all of which know what to expect from the succeeding code. You can read about prototypes in <a href="http://perldoc.perl.org/perlsub.html#Prototypes" rel="noreferrer">perlsub</a></p>

<p>Without reading the documentation, people guess that the prototypes refer to run time argument checking or something similar that they've seen in other languages. As with most things people guess about Perl, they turn out to be wrong.</p>

<p>However, starting with Perl v5.20, Perl has a feature, experimental as I write this, that gives something more like what users expect and what. Perl's <a href="http://www.effectiveperlprogramming.com/2015/04/use-v5-20-subroutine-signatures/" rel="noreferrer">subroutine signatures</a> does run time argument counting, variable assigning, and default setting:</p>

<pre><code>use v5.20;
use feature qw(signatures);
no warnings qw(experimental::signatures);

animals( 'Buster', 'Nikki', 'Godzilla' );

sub animals ($cat, $dog, $lizard = 'Default reptile') { 
    say "The cat is $cat";
    say "The dog is $dog";
    say "The lizard is $lizard";
    }
</code></pre>

<p>This is the feature you probably want if you're considering prototypes.</p>
