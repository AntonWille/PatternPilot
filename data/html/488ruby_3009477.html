 <h2> Title: What is Ruby&#39;s double-colon `::`? </h2> <h4> Meltemi, question_id: 3009477 </h4>Score: 488, Tags: {ruby,syntax,operators} <br><p>What is this double-colon <code>::</code>? E.g. <code>Foo::Bar</code>.</p>

<p>I found a <a href="http://marcricblog.blogspot.com/2007/11/ruby-double-colon.html" rel="noreferrer">definition</a>: </p>

<blockquote>
  <p>The <code>::</code> is a unary operator that allows: constants, instance methods and class methods defined within a class or module, to be accessed from anywhere outside the class or module.</p>
</blockquote>

<p>What good is scope (private, protected) if you can just use <code>::</code> to expose anything?</p>
<h4> Erdős-Bacon, Id: 133429945 Score: 2: </h4>The future is here, and I regret to inform my fellow googlers, <a href="https://webapps.stackexchange.com/questions/166839/search-for-special-characters-symbolhound-com-is-down-alternative">symbolhound.com is now defunct</a>.<br><h4> jacobq, Id: 17946663 Score: 1: </h4>Possible duplicate? <a href="http://stackoverflow.com/questions/2276905/what-does-mean-in-ruby" title="what does mean in ruby">stackoverflow.com/questions/2276905/what-does-mean-in-ruby</a><br><h4> 1dolinski, Id: 21540951 Score: 0: </h4>as well as <a href="http://stackoverflow.com/questions/3597096/what-does-myclass-ruby-scope-operator-do" title="what does myclass ruby scope operator do">stackoverflow.com/questions/3597096/&hellip;</a><br>------------------------------------------------------------------ <br><h3> mipadi, Id: 3009565, Score: 447: </h3><p><code>::</code> is basically a namespace resolution operator. It allows you to access items in modules, or class-level items in classes. For example, say you had this setup:</p>

<pre><code>module SomeModule
    module InnerModule
        class MyClass
            CONSTANT = 4
        end
    end
end
</code></pre>

<p>You could access <code>CONSTANT</code> from outside the module as <code>SomeModule::InnerModule::MyClass::CONSTANT</code>.</p>

<p>It doesn't affect instance methods defined on a class, since you access those with a different syntax (the dot <code>.</code>).</p>

<p>Relevant note: If you want to go back to the top-level namespace, do this: ::SomeModule – <a href="https://stackoverflow.com/users/146764/benjamin-oakes">Benjamin Oakes</a></p>
<h4> Benjamin Oakes, Comment 3077486 Score: 171: </h4>Relevant note:  If you want to go back to the top-level namespace, do this:  <code>::SomeModule</code><br><h4> Benjamin Oakes, Comment 5682828 Score: 8: </h4>@Jo Yes.  It can be helpful if you want to make sure you&#39;re referring to a constant at the top level namespace or a constant with the same name in another module (e.g. ::SomeOtherModule::ClassMethods).<br><h4> Jo Liss, Comment 5663849 Score: 7: </h4>@Benjamin The leading colons are implied, unless I happen to have a SomeModule inside another module and I want to get the top-level one instead, correct?<br><h4> Jerry Fernholz, Comment 3075656 Score: 6: </h4>In C#, for instance, yes.  On the other hand C++ (and Ruby) use <code>::</code> for namespace resolution such as <code>std::cout &lt;&lt; &quot;Hello World!&quot;;</code><br><h4> lkahtz, Comment 11636892 Score: 2: </h4>This is very much like scope operand of C++<br><h4> OscarRyz, Comment 3075597 Score: 1: </h4>would it be like <code>SomeModule.InnerModle.MyClass.CONSTANT</code> in &quot;other&quot; languages ?<br><h4> Andrew Marshall, Comment 14445554 Score: 1: </h4>Private methods can never be accessed with <code>.</code> from outside the class, that&#39;s why they&#39;re <i>private</i>, after all.<br><h4> Ascendant, Comment 115025957 Score: 0: </h4>What about the <code>::</code> used in class definitions? For example <code>class Devise::RegistrationsController &lt; DeviseController</code>?<br><h4> Yuri Ghensev, Comment 75894925 Score: 0: </h4>It is also possible to access instance methods with <code>::</code>, e.g.: <code>MyClass::new::instance_method</code><br><h4> Ahmad, Comment 84399802 Score: 0: </h4>How about accessing methods inside a module, not a class?<br><h4> Erik  Reppen, Comment 26087579 Score: 0: </h4>I assume instance was intended instead of private?<br><h4> Eric Platon, Comment 58549088 Score: 0: </h4>Note that <code>::</code> has another use, pretty rare and probably to avoid. From the <a href="http://ruby-doc.org/core-2.0.0/doc/syntax/calling_methods_rdoc.html" rel="nofollow noreferrer">docs</a>: &quot;You may also use :: to designate a receiver, but this is rarely used due to the potential for confusion with :: for namespaces.&quot;<br><h4> mc9, Comment 41762562 Score: 0: </h4>@ErikReppen Yes, I think the author meant instance methods, rather than private methods.<br>------------------------------------------------------------------ <br><h3> Nader, Id: 5318496, Score: 136: </h3><p>This simple example illustrates it:</p>

<pre><code>MR_COUNT = 0        # constant defined on main Object class
module Foo
  MR_COUNT = 0
  ::MR_COUNT = 1    # set global count to 1
  MR_COUNT = 2      # set local count to 2
end

puts MR_COUNT       # this is the global constant: 1
puts Foo::MR_COUNT  # this is the local constant: 2
</code></pre>

<p>Taken from <a href="http://www.tutorialspoint.com/ruby/ruby_operators.htm" rel="noreferrer">http://www.tutorialspoint.com/ruby/ruby_operators.htm</a></p>
<h4> BookOfGreg, Comment 32995468 Score: 3: </h4>@NullVoxPopuli Generally modifying constants is a really bad thing but if you for instance want to modify a constant in a badly written gem and do not want to fork it, it could be done by using <a href="http://apidock.com/ruby/Module/remove_const" rel="nofollow noreferrer">.send(:remove_const)</a> to the module that defines it, then redefining the constant.<br><h4> NullVoxPopuli, Comment 24042441 Score: 0: </h4>this is what causes the warning though. Is there a way to evade the warning?<br>------------------------------------------------------------------ <br><h3> mikej, Id: 3009586, Score: 87: </h3><p><code>::</code> Lets you access a constant, module, or class defined inside another class or module. It is used to provide namespaces so that method and class names don't conflict with other classes by different authors.</p>

<p>When you see <code>ActiveRecord::Base</code> in Rails it means that Rails has something like</p>

<pre><code>module ActiveRecord
  class Base
  end
end
</code></pre>

<p>i.e. a class called <code>Base</code> inside a module <code>ActiveRecord</code> which is then referenced as <code>ActiveRecord::Base</code> (you can find this in the Rails source in activerecord-n.n.n/lib/active_record/base.rb)</p>

<p>A common use of :: is to access constants defined in modules e.g.</p>

<pre><code>module Math
  PI = 3.141 # ...
end

puts Math::PI
</code></pre>

<p>The <code>::</code> operator does not allow you to bypass visibility of methods marked private or protected.</p>
<h4> Charlie Parker, Comment 31163326 Score: 10: </h4>So if one has <code>class MyClass &lt; ActiveRecord::Base</code>, does that mean that MyClass only inherits methods from the class base and not anything inside the ActiveRecord module?<br><h4> mikej, Comment 47122138 Score: 5: </h4>@Jonah there are some cases where it would be ambiguous. e.g. consider <code>class Foo; Baz = 42; def self.Baz; &quot;Baz method!&quot;; end; end</code> (perfectly valid) <code>Foo::Baz # =&gt; 42</code> and <code>Foo.Baz # =&gt; &quot;Baz method!&quot;</code>. Note that <code>Foo::Baz()</code> (with parentheses) would also call the method though.<br><h4> Jonah, Comment 47451753 Score: 4: </h4>So the use case it solves it the ability to have class constant and a class method that have the exact same name?  That doesn&#39;t seem like a strong argument in favor of the feature.  Personally I&#39;d much rather lose that ability (seems like trouble, anyway), lose the double-colon, and use &quot;.&quot; for namespacing too.... Maybe there are additional use-cases it solves?<br><h4> Jonah, Comment 47067118 Score: 3: </h4>Why use the special double-colon for this namespace resolution rather than using the &quot;.&quot; for this too?  Context and capitalization would prevent confusion of meaning even if we were using the &quot;.&quot;, wouldn&#39;t it?<br>------------------------------------------------------------------ <br><h3> yfeldblum, Id: 3009591, Score: 34: </h3><blockquote>
  <p>What good is scope (private, protected) if you can just use :: to expose anything?</p>
</blockquote>

<p>In Ruby, everything is exposed and everything can be modified from anywhere else.</p>

<p>If you're worried about the fact that classes can be changed from outside the "class definition", then Ruby probably isn't for you.</p>

<p>On the other hand, if you're frustrated by Java's classes being locked down, then Ruby is probably what you're looking for.</p>
<h4> yfeldblum, Comment 3077529 Score: 4: </h4>Correct, there&#39;s <code>instance_eval</code>. But there&#39;s also <code>instance_variable_get</code> and <code>instance_variable_set</code>. Ruby is just too dynamic for constraints.<br><h4> Andrew Grimm, Comment 3076725 Score: 1: </h4>I&#39;ve heard some rubyists say that instance variables aren&#39;t exposed, that even <code>attr_accessor</code> merely makes methods that modify the variable. (Then again there&#39;s <code>instance_eval</code>)<br>------------------------------------------------------------------ <br><h3> Daniel Viglione, Id: 55027491, Score: 29: </h3><p>Surprisingly, all 10 answers here say the same thing. The '::' is a namespace resolution operator, and yes it is true. But there is one gotcha that you have to realize about the namespace resolution operator when it comes to the <strong>constant lookup algorithm</strong>. As Matz delineates in his book, 'The Ruby Programming Language', constant lookup has multiple steps. First, it searches a constant in the <strong>lexical scope</strong> where the constant is referenced. If it does not find the constant within the lexical scope, it then searches the <strong>inheritance hierarchy</strong>. Because of this constant lookup algorithm, below we get the expected results:</p>

<pre><code>module A
  module B
      PI = 3.14
      module C
        class E
          PI = 3.15
        end
        class F &lt; E
          def get_pi
            puts PI
          end
        end
      end
  end
end
f = A::B::C::F.new
f.get_pi
&gt; 3.14
</code></pre>

<p>While F inherits from E, the B module is within the lexical scope of F. Consequently, F instances will refer to the constant PI defined in the module B. Now if module B did not define PI, then F instances will refer to the PI constant defined in the superclass E.</p>

<p>But what if we were to use '::' rather than nesting modules? Would we get the same result? No!</p>

<p>By using the namespace resolution operator when defining nested modules, the nested modules and classes are no longer within the lexical scope of their outer modules. As you can see below, PI defined in A::B is not in the lexical scope of A::B::C::D and thus we get uninitialized constant when trying to refer to PI in the get_pi instance method:</p>

<pre><code>module A
end

module A::B
  PI = 3.14
end

module A::B::C
  class D
    def get_pi
      puts PI
    end
  end
end
d = A::B::C::D.new
d.get_pi
NameError: uninitialized constant A::B::C::D::PI
Did you mean?  A::B::PI
</code></pre>
<h4> Burak Kaymakci, Comment 123938141 Score: 4: </h4>This should be higher in the order of answers.<br><h4> Ev Dolzhenko, Comment 136682003 Score: 0: </h4>Yeah, the last bit is used as an interview question too. Nice one.<br>------------------------------------------------------------------ <br><h3> Yuri Ghensev, Id: 44448980, Score: 22: </h3><p>Adding to previous answers, it is valid Ruby to use <code>::</code> to access instance methods. All the following are valid:</p>

<pre><code>MyClass::new::instance_method
MyClass::new.instance_method
MyClass.new::instance_method
MyClass.new.instance_method
</code></pre>

<p><sub>As per best practices I believe only the last one is recommended.</sub></p>
------------------------------------------------------------------ <br><h3> Francisco Soto, Id: 3009597, Score: 12: </h3><p>No, it is not to access every method, it is a "resolution" operator, that is, you use it to resolve the scope (or location you can say) of a constant/static symbol.</p>

<p>For example in the first of your line, Rails use it to find the Base class inside the ActiveRecord.Module, in your second one it is used to locate the class method (static) of the Routes class, etc, etc.</p>

<p>It is not used to expose anything, its used to "locate" stuff around your scopes.</p>

<p><a href="http://en.wikipedia.org/wiki/Scope_resolution_operator" rel="noreferrer">http://en.wikipedia.org/wiki/Scope_resolution_operator</a></p>
<h4> Meltemi, Comment 3076249 Score: 0: </h4>by &quot;(static)&quot; do you mean &quot;(draw)&quot;?!?<br>------------------------------------------------------------------ <br><h3> Pankhuri, Id: 18159770, Score: 6: </h3><p>Ruby on rails uses <code>::</code> for namespace resolution.</p>

<pre><code>class User &lt; ActiveRecord::Base

  VIDEOS_COUNT = 10
  Languages = { "English" =&gt; "en", "Spanish" =&gt; "es", "Mandarin Chinese" =&gt; "cn"}

end
</code></pre>

<p>To use it :   </p>

<pre><code>User::VIDEOS_COUNT
User::Languages
User::Languages.values_at("Spanish") =&gt; "en"
</code></pre>

<p><strong>Also, other usage is : When using nested routes</strong></p>

<p><code>OmniauthCallbacksController</code> is defined under users.</p>

<p>And routed as: </p>

<pre><code>devise_for :users, controllers: {omniauth_callbacks: "users/omniauth_callbacks"}


class Users::OmniauthCallbacksController &lt; Devise::OmniauthCallbacksController

end
</code></pre>
------------------------------------------------------------------ <br><h3> Mongus Pong, Id: 3009554, Score: 5: </h3><p>It is all about preventing definitions from clashing with other code linked in to your project.  It means you can keep things separate. </p>

<p>For example you can have one method called "run" in your code and you will still be able to call your method rather than the "run" method that has been defined in some other library that you have linked in. </p>
------------------------------------------------------------------ <br><h3> Francesca Rodricks, Id: 29506416, Score: 4: </h3><pre><code>module Amimal
      module Herbivorous
            EATER="plants" 
      end
end

Amimal::Herbivorous::EATER =&gt; "plants"
</code></pre>

<p>:: Is used to create a scope . In order to access Constant EATER from 2 modules we need to scope the modules to reach up to the constant </p>
------------------------------------------------------------------ <br><h3> Aaquib Jawed, Id: 69187488, Score: 4: </h3><p>In simple it is a namespace,
now namespace is container for modules, classes, function and other. and it also help to solve the problem name conflict.
and in ruby you can access namespace by module like</p>
<pre class="lang-rb prettyprint-override"><code>module A
  class Article
     def Base
     end
  module B
  end
end
</code></pre>
<p>so to access the class Article we use A::Article.
and in some cases you see that
A::Article&lt;Application::Base
this mean that the Article class of module A inherit the Base class from Application module.</p>
------------------------------------------------------------------ <br><h3> bubbaspaarx, Id: 71575008, Score: 1: </h3><p>Reviving this thread a little.
Can we create a 'ruby' name for this operator ::
Surprised that we haven't already since we have splats, spreads, hash rockets etc.</p>
<p>Surely we can come up with something more fun than 'double colon' or 'unary operator'</p>
<p>Thinking</p>
<ul>
<li>quad dot</li>
<li>four eyes</li>
<li>tetra dot</li>
<li>Nibble (half a byte - 4 bits)</li>
</ul>
<h4> nathas, Comment 130067082 Score: 0: </h4>I&#39;ve always heard it called a scope resolution operator. See <a href="https://www.geeksforgeeks.org/scope-resolution-operator-in-c/" rel="nofollow noreferrer">geeksforgeeks.org/scope-resolution-operator-in-c</a><br><h4> bubbaspaarx, Comment 130074705 Score: 0: </h4>That&#39;s actually not bad.  We internally call it the tetra dot now. But scope resolution is essentially what it does I guess.<br>