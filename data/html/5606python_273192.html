 <h2> Title: How do I create a directory, and any missing parent directories? </h2> <h4> Parand, question_id: 273192 </h4>Score: 5606, Tags: {python,exception,path,directory,operating-system} <br><p>How do I create a directory at a given path, and also create any missing parent directories along that path? For example, the Bash command <code>mkdir -p /path/to/nested/directory</code> does this.</p>
<h4> Brian Hawkins, Id: 2969634 Score: 41: </h4>In general you might need to account for the case where there&#39;s no directory in the filename.  On my machine dirname(&#39;foo.txt&#39;) gives &#39;&#39;, which doesn&#39;t exist and causes makedirs() to fail.<br><h4> Thamme Gowda, Id: 67724774 Score: 14: </h4>In case you came here to create parent directories of file path string <code>p</code>, here is my code snippet: <code>os.makedirs(p[:p.rindex(os.path.sep)], exist_ok=True)</code><br><h4> miracle173, Id: 33149166 Score: 9: </h4>if the path exists one has not only to check if it is a directory and not a regular file or another object (many answers check this) it is also necessary to check if it is writable (I did not find an answer that checked this)<br>------------------------------------------------------------------ <br><h3> Blair Conrad, Id: 273227, Score: 7019: </h3><p>On Python ≥ 3.5, use <a href="https://docs.python.org/library/pathlib.html#pathlib.Path.mkdir" rel="noreferrer"><code>pathlib.Path.mkdir</code></a>:</p>

<pre><code>from pathlib import Path
Path("/my/directory").mkdir(parents=True, exist_ok=True)
</code></pre>

<p>For older versions of Python, I see two answers with good qualities, each with a small flaw, so I will give my take on it:</p>

<p>Try <a href="https://docs.python.org/library/os.path.html#os.path.exists" rel="noreferrer"><code>os.path.exists</code></a>, and consider <a href="https://docs.python.org/library/os.html#os.makedirs" rel="noreferrer"><code>os.makedirs</code></a> for the creation.</p>

<pre><code>import os
if not os.path.exists(directory):
    os.makedirs(directory)
</code></pre>

<p>As noted in comments and elsewhere, there's a race condition &ndash; if the directory is created between the <code>os.path.exists</code> and the <code>os.makedirs</code> calls, the <code>os.makedirs</code> will fail with an <code>OSError</code>. Unfortunately, blanket-catching <code>OSError</code> and continuing is not foolproof, as it will ignore a failure to create the directory due to other factors, such as insufficient permissions, full disk, etc.</p>

<p>One option would be to trap the <code>OSError</code> and examine the embedded error code (see <a href="https://stackoverflow.com/questions/273698/is-there-a-cross-platform-way-of-getting-information-from-pythons-oserror">Is there a cross-platform way of getting information from Python’s OSError</a>):</p>

<pre><code>import os, errno

try:
    os.makedirs(directory)
except OSError as e:
    if e.errno != errno.EEXIST:
        raise
</code></pre>

<p>Alternatively, there could be a second <code>os.path.exists</code>, but suppose another created the directory after the first check, then removed it before the second one &ndash; we could still be fooled. </p>

<p>Depending on the application, the danger of concurrent operations may be more or less than the danger posed by other factors such as file permissions. The developer would have to know more about the particular application being developed and its expected environment before choosing an implementation.</p>

<p>Modern versions of Python improve this code quite a bit, both by exposing <a href="https://docs.python.org/3.3/library/exceptions.html?#FileExistsError" rel="noreferrer"><code>FileExistsError</code></a> (in 3.3+)...</p>

<pre><code>try:
    os.makedirs("path/to/directory")
except FileExistsError:
    # directory already exists
    pass
</code></pre>

<p>...and by allowing <a href="https://docs.python.org/3.2/library/os.html#os.makedirs" rel="noreferrer">a keyword argument to <code>os.makedirs</code> called <code>exist_ok</code></a> (in 3.2+).</p>

<pre><code>os.makedirs("path/to/directory", exist_ok=True)  # succeeds even if directory exists.
</code></pre>
<h4> Andrew, Comment 10226673 Score: 38: </h4>Remember that os.path.exists() isn&#39;t free. If the normal case is that the directory will be there, then the case where it isn&#39;t should be handled as an exception. In other words, try to open and write to your file, catch the OSError exception and, based on errno, do your makedir() and re-try or re-raise. This creates duplication of code unless you wrap the writing in a local method.<br><h4> Asclepius, Comment 20864661 Score: 27: </h4><code>os.path.exists</code> also returns <code>True</code> for a file. I have posted an answer to address this.<br><h4> Bobble, Comment 23938267 Score: 18: </h4>As commenters to other answers here have noted, the <code>exists_ok</code> parameter to <code>os.makedirs()</code> can be used to cover how prior existence of the path is handled, since Python 3.2.<br><h4> Blair Conrad, Comment 126884 Score: 12: </h4>The race condition is a good point, but the approach in <a href="http://stackoverflow.com/questions/273192/#273208">stackoverflow.com/questions/273192/#273208</a>, will mask a failure to create the directory. Don&#39;t feel bad for voting down - you don&#39;t like the answer. It&#39;s what votes are for.<br><h4> drevicko, Comment 25439821 Score: 9: </h4><code>os.mkdirs()</code> can create unintended folders if a path separator is accidentally left out, the current folder is not as expected, a path element contains the path separator. If you use <code>os.mkdir()</code> these bugs will raise an exception, alerting you to their existence.<br><h4> do-me, Comment 124247265 Score: 0: </h4>If you want to create the directory in your current working directory leave out the first slash <code>Path(&quot;my_directory&quot;).mkdir(parents=True, exist_ok=True)</code>.<br>------------------------------------------------------------------ <br><h3> Asclepius, Id: 14364249, Score: 1529: </h3><h2>Python 3.5+:</h2>
<pre><code>import pathlib
pathlib.Path('/my/directory').mkdir(parents=True, exist_ok=True) 
</code></pre>
<p><a href="https://docs.python.org/library/pathlib.html#pathlib.Path.mkdir" rel="noreferrer"><code>pathlib.Path.mkdir</code></a> as used above recursively creates the directory and does not raise an exception if the directory already exists. If you don't need or want the parents to be created, skip the <code>parents</code> argument.</p>
<h2>Python 3.2+:</h2>
<p><strong>Using <code>pathlib</code>:</strong></p>
<p>If you can, install the current <code>pathlib</code> backport named <a href="https://pypi.python.org/pypi/pathlib2/" rel="noreferrer"><code>pathlib2</code></a>. Do not install the older unmaintained backport named <a href="https://pypi.python.org/pypi/pathlib/" rel="noreferrer"><code>pathlib</code></a>. Next, refer to the Python 3.5+ section above and use it the same.</p>
<p>If using Python 3.4, even though it comes with <code>pathlib</code>, it is missing the useful <code>exist_ok</code> option. The backport is intended to offer a newer and superior implementation of <code>mkdir</code> which includes this missing option.</p>
<p><strong>Using <code>os</code>:</strong></p>
<pre><code>import os
os.makedirs(path, exist_ok=True)
</code></pre>
<p><a href="https://docs.python.org/library/os.html#os.makedirs" rel="noreferrer"><code>os.makedirs</code></a> as used above recursively creates the directory and does not raise an exception if the directory already exists. It has the optional <code>exist_ok</code> argument only if using Python 3.2+, with a default value of <code>False</code>. This argument does not exist in Python 2.x up to 2.7. As such, there is no need for manual exception handling as with Python 2.7.</p>
<h2>Python 2.7+:</h2>
<p><strong>Using <code>pathlib</code>:</strong></p>
<p>If you can, install the current <code>pathlib</code> backport named <a href="https://pypi.python.org/pypi/pathlib2/" rel="noreferrer"><code>pathlib2</code></a>. Do not install the older unmaintained backport named <a href="https://pypi.python.org/pypi/pathlib/" rel="noreferrer"><code>pathlib</code></a>. Next, refer to the Python 3.5+ section above and use it the same.</p>
<p><strong>Using <code>os</code>:</strong></p>
<pre><code>import os
try: 
    os.makedirs(path)
except OSError:
    if not os.path.isdir(path):
        raise
</code></pre>
<p>While a naive solution may first use <a href="https://docs.python.org/2/library/os.path.html#os.path.isdir" rel="noreferrer" title="os.path.isdir"><code>os.path.isdir</code></a> followed by <a href="https://docs.python.org/2/library/os.html#os.makedirs" rel="noreferrer" title="os.makedirs"><code>os.makedirs</code></a>, the solution above reverses the order of the two operations. In doing so, it prevents a common race condition having to do with a duplicated attempt at creating the directory, and also disambiguates files from directories.</p>
<p>Note that capturing the exception and using <code>errno</code> is of limited usefulness because <code>OSError: [Errno 17] File exists</code>, i.e. <code>errno.EEXIST</code>, is raised for both files and directories. It is more reliable simply to check if the directory exists.</p>
<h2>Alternative:</h2>
<p><a href="https://docs.python.org/distutils/apiref.html#distutils.dir_util.mkpath" rel="noreferrer"><code>mkpath</code></a> creates the nested directory, and does nothing if the directory already exists. This works in both Python 2 and 3. Note however that <a href="https://docs.python.org/3/library/distutils.html#module-distutils" rel="noreferrer"><code>distutils</code></a> has been deprecated, and is scheduled for removal in Python 3.12.</p>
<pre><code>import distutils.dir_util
distutils.dir_util.mkpath(path)
</code></pre>
<p>Per <a href="http://bugs.python.org/issue10948" rel="noreferrer">Bug 10948</a>, a severe limitation of this alternative is that it works only once per python process for a given path. In other words, if you use it to create a directory, then delete the directory from inside or outside Python, then use <code>mkpath</code> again to recreate the same directory, <code>mkpath</code> will simply silently use its invalid cached info of having previously created the directory, and will not actually make the directory again. In contrast, <code>os.makedirs</code> doesn't rely on any such cache. This limitation may be okay for some applications.</p>
<hr />
<p>With regard to the directory's <em>mode</em>, please refer to the documentation if you care about it.</p>
<h4> Charles L., Comment 23214713 Score: 17: </h4>This answer covers pretty much every special case as far as I can tell.  I plan on wrapping this in a &quot;if not os.path.isdir()&quot; though since I expect the directory to exist almost every time and I can avoid the exception that way.<br><h4> jpmc26, Comment 35809050 Score: 7: </h4>@CharlesL. An exception is probably cheaper than the disk IO of the check, if your reason is performance.<br><h4> SleepyCal, Comment 57106172 Score: 6: </h4>This is the wrong answer, as it introduces a potential FS race cond. See answer from Aaron Hall.<br><h4> farmir, Comment 61330983 Score: 6: </h4>as @sleepycal has said, this suffers from a similar race condition as the accepted answer. If between raising the error and checking <code>os.path.isdir</code> someone else deletes the folder, you will raise the wrong, outdated, and confusing error that folder exists.<br><h4> kwarunek, Comment 40595318 Score: 2: </h4>@jpmc26 but makedirs does additional stat, umask, lstat when only checking to throw OSError.<br><h4> penguin359, Comment 56817797 Score: 0: </h4>@CharesL Anytime there&#39;s a directory separator, os.makedirs() starts off with a stat() so a pre-check with os.path.isdir() is just extra effort.<br><h4> nealmcb, Comment 80699694 Score: 0: </h4>The concern about race conditions noted by @sleepycal is addressed in the comments on Heikki Toivonen&#39;s answer for many (most) use cases, including mine. If you&#39;re worried that someone else is going to remove the directory, you&#39;re still going to need to check that before using it later on. Creating multiple places where you check for what you&#39;ll need later just adds complications.<br><h4> smci, Comment 95009226 Score: 0: </h4>On Windows, what about permissions errors when parent directory is owned by Administrator, or else a special directory e.g. <code>C:\Program Files or ...(x86)</code> or <code>Documents and Settings</code>, and hence creating directory fails? Does this code propagate the exact permissions error?<br><h4> Asclepius, Comment 95025820 Score: 0: </h4>@smci It doesn&#39;t seem so, but at least on Linux the available permissions can then be checked. I don&#39;t know about Windows.<br><h4> fitzl, Comment 95040494 Score: 0: </h4>Note that <code>NotADirectoryError: [Errno 20] Not a directory: ...</code> <i>is</i> raised by <code>pathlib.Path(&#39;&#47;my&#47;directory&#39;).mkdir(parents=True, exist_ok=True)</code> in cases where a file exists matching the proposed name of a directory in the path, e.g., if <code>my</code> is a file.<br>------------------------------------------------------------------ <br><h3> Heikki Toivonen, Id: 5032238, Score: 657: </h3><p>Using try except and the right error code from errno module gets rid of the race condition and is cross-platform:</p>

<pre><code>import os
import errno

def make_sure_path_exists(path):
    try:
        os.makedirs(path)
    except OSError as exception:
        if exception.errno != errno.EEXIST:
            raise
</code></pre>

<p>In other words, we try to create the directories, but if they already exist we ignore the error. On the other hand, any other error gets reported. For example, if you create dir 'a' beforehand and remove all permissions from it, you will get an <code>OSError</code> raised with <code>errno.EACCES</code> (Permission denied, error 13).</p>
<h4> Navin, Comment 20709813 Score: 194: </h4>Note that the above code is equivalent to <code>os.makedirs(path,exist_ok=True)</code><br><h4> Asclepius, Comment 20865058 Score: 60: </h4>@Navin The <code>exist_ok</code> parameter was introduced in Python 3.2.  It is not present in Python 2.x.  I will incorporate it into my answer.<br><h4> jpmc26, Comment 35809094 Score: 28: </h4>@HeikkiToivonen Technically speaking, if another program is modifying the directories and files at the same time your program is, your entire program is one giant race condition. What&#39;s to stop another program from just deleting this directory after the code creates it and before you actually put files in it?<br><h4> Heikki Toivonen, Comment 13553061 Score: 26: </h4>The accepted answer is actually dangerous because it has a race-condition. It is simpler, though, so if you are unaware of the race-condition, or think it won&#39;t apply to you, that would be your obvious first pick.<br><h4> Asclepius, Comment 19972619 Score: 18: </h4>Raising the exception only when <code>exception.errno != errno.EEXIST</code> will unintentionally ignore the case when path exists but is a non-directory object such as a file. The exception should ideally be raised if the path is a non-directory object.<br><h4> isaaclw, Comment 13012230 Score: 2: </h4>What&#39;s the common reason <i>against</i> this? ie: why do people prefer the if statement to the try/except? Is it that try/except is more dangerous if you miss the error?<br><h4> Cl&#233;ment, Comment 75557024 Score: 2: </h4>Downvoted. The source code of <code>mkdirs</code> actually warns <i>against</i> checking for EEXIST: <a href="https://github.com/python/cpython/blob/e304e33c16e060932d1e2cc8a030d42b02b429b5/Lib/os.py#L195" rel="nofollow noreferrer">github.com/python/cpython/blob/&hellip;</a><br><h4> Davis Herring, Comment 80025279 Score: 1: </h4>@jpmc26: It&#39;s not that there are no race conditions; it&#39;s that your program doesn&#39;t contain two <i>different</i> places where you might detect what (due to races) is really the same condition.<br><h4> gerrit, Comment 62381702 Score: 1: </h4>In Python 3.3 and above, you can use <code>FileExistsError</code>.<br><h4> jpmc26, Comment 80025676 Score: 0: </h4>@DavisHerring What you say isn&#39;t exactly true. An existence check occurs any time you access the directory or its contents. So if you create the directory and then open a file in it, you&#39;re still vulnerable to the same race condition. The answer is good; it&#39;s just still not safe if another program is modifying stuff, which is what Heikki (not the answer) asserted.<br><h4> Davis Herring, Comment 80025922 Score: 0: </h4>@jpmc26: The races are materially worse the other way: with <code>if not path.exists(...)</code> a concurrent <code>mkdir</code> can give you an exception (despite the check).  More broadly put, the check doesn&#39;t protect you from having to deal with any race condition, so it&#39;s strictly inferior to include it.<br><h4> Davis Herring, Comment 80026903 Score: 0: </h4>@jpmc26: It prevents the <code>mkdir</code> race (in that you have two clear cases and obvious code paths to deal with them).  Contention doesn&#39;t have to be a &quot;battle&quot;: it&#39;s easily useful to have several programs create different parts of a directory.<br><h4> rtkaleta, Comment 76791976 Score: 0: </h4>@Cl&#233;ment You&#39;re looking at Python 3.x source code, the answer given above applies to Python 2.7: <a href="https://github.com/python/cpython/blob/2.7/Lib/os.py#L153" rel="nofollow noreferrer">github.com/python/cpython/blob/2.7/Lib/os.py#L153</a><br>------------------------------------------------------------------ <br><h3> Aly Niichi, Id: 35262209, Score: 9: </h3><p>I saw <a href="https://stackoverflow.com/a/5032238/3051142">Heikki Toivonen</a> and <a href="https://stackoverflow.com/a/14364249">A-B-B</a>'s answers and thought of this variation.</p>

<pre><code>import os
import errno

def make_sure_path_exists(path):
    try:
        os.makedirs(path)
    except OSError as exception:
        if exception.errno != errno.EEXIST or not os.path.isdir(path):
            raise
</code></pre>
------------------------------------------------------------------ <br><h3> hiro protagonist, Id: 41147087, Score: 138: </h3><p>Starting from Python 3.5, <a href="https://docs.python.org/3/library/pathlib.html#pathlib.Path.mkdir" rel="noreferrer"><code>pathlib.Path.mkdir</code></a> has an <code>exist_ok</code> flag:</p>
<pre><code>from pathlib import Path
path = Path('/my/directory/filename.txt')
path.parent.mkdir(parents=True, exist_ok=True) 
# path.parent ~ os.path.dirname(path)
</code></pre>
<p>This recursively creates the directory and does not raise an exception if the directory already exists.</p>
<p>(just as <a href="https://docs.python.org/3/library/os.html?highlight=makedirs#os.makedirs" rel="noreferrer"><code>os.makedirs</code></a> got an <code>exist_ok</code> flag starting from python 3.2 e.g <code>os.makedirs(path, exist_ok=True)</code>)</p>
<hr />
<p>Note: when i posted this answer none of the other answers mentioned <code>exist_ok</code>...</p>
<h4> lam vu Nguyen, Comment 133798020 Score: 0: </h4>one note: it will be &#39;[Errno 17] File exists&#39; error if foldername and filename are the same in a location, even an exist_ok flag<br>------------------------------------------------------------------ <br><h3> crimsonstone, Id: 444023, Score: 130: </h3><p>I would personally recommend that you use <code>os.path.isdir()</code> to test instead of <code>os.path.exists()</code>.</p>
<pre><code>&gt;&gt;&gt; os.path.exists('/tmp/dirname')
True
&gt;&gt;&gt; os.path.exists('/tmp/dirname/filename.etc')
True
&gt;&gt;&gt; os.path.isdir('/tmp/dirname/filename.etc')
False
&gt;&gt;&gt; os.path.isdir('/tmp/fakedirname')
False
</code></pre>
<p>If you have:</p>
<pre><code>&gt;&gt;&gt; directory = raw_input(&quot;:: &quot;)
</code></pre>
<p>And a foolish user input:</p>
<pre><code>:: /tmp/dirname/filename.etc
</code></pre>
<p>... You're going to end up with a directory named <code>filename.etc</code> when you pass that argument to <code>os.makedirs()</code> if you test with <code>os.path.exists()</code>.</p>
------------------------------------------------------------------ <br><h3> Douglas Mayle, Id: 273208, Score: 110: </h3><p>Check <a href="https://docs.python.org/3/library/os.html#os.makedirs" rel="noreferrer"><code>os.makedirs</code></a>:  (It makes sure the complete path exists.)<br>
 To handle the fact the directory might exist, catch <code>OSError</code>.
(If <code>exist_ok</code> is <code>False</code> (the default), an <code>OSError</code> is raised if the target directory already exists.)</p>

<pre><code>import os
try:
    os.makedirs('./path/to/somewhere')
except OSError:
    pass
</code></pre>
<h4> Blair Conrad, Comment 126666 Score: 25: </h4>with the try/except, you will mask errors in directory creation, in the case when the directory didn&#39;t exist but for some reason you can&#39;t make it<br>------------------------------------------------------------------ <br><h3> gone, Id: 273206, Score: 84: </h3><p>Try the <a href="https://docs.python.org/2/library/os.path.html#os.path.exists" rel="noreferrer" title="os.path.exists"><code>os.path.exists</code></a> function</p>

<pre><code>if not os.path.exists(dir):
    os.mkdir(dir)
</code></pre>
<h4> Ryan M, Comment 134203893 Score: 1: </h4>This doesn&#39;t create parent directories.  From the <code>os.mkdir</code> docs: <i>&quot;If a parent directory in the path does not exist, <code>FileNotFoundError</code> is raised.&quot;</i><br>------------------------------------------------------------------ <br><h3> Russia Must Remove Putin, Id: 28100757, Score: 62: </h3><h2>Insights on the specifics of this situation</h2>
<p>You give a particular file at a certain path and you pull the directory from the file path. Then after making sure you have the directory, you attempt to open a file for reading. To comment on this code:</p>
<blockquote>
<pre><code>filename = &quot;/my/directory/filename.txt&quot;
dir = os.path.dirname(filename)
</code></pre>
</blockquote>
<p>We want to avoid overwriting the builtin function, <code>dir</code>. Also, <code>filepath</code> or perhaps <code>fullfilepath</code> is probably a better semantic name than <code>filename</code> so this would be better written:</p>
<pre><code>import os
filepath = '/my/directory/filename.txt'
directory = os.path.dirname(filepath)
</code></pre>
<p>Your end goal is to open this file, you initially state, for writing, but you're essentially approaching this goal (based on your code) like this, which opens the file for <strong>reading</strong>:</p>
<blockquote>
<pre><code>if not os.path.exists(directory):
    os.makedirs(directory)
f = file(filename)
</code></pre>
</blockquote>
<h2>Assuming opening for reading</h2>
<p>Why would you make a directory for a file that you expect to be there and be able to read?</p>
<p>Just attempt to open the file.</p>
<pre><code>with open(filepath) as my_file:
    do_stuff(my_file)
</code></pre>
<p>If the directory or file isn't there, you'll get an <code>IOError</code> with an associated error number: <code>errno.ENOENT</code> will point to the correct error number regardless of your platform. You can catch it if you want, for example:</p>
<pre><code>import errno
try:
    with open(filepath) as my_file:
        do_stuff(my_file)
except IOError as error:
    if error.errno == errno.ENOENT:
        print 'ignoring error because directory or file is not there'
    else:
        raise
</code></pre>
<h2>Assuming we're opening for writing</h2>
<p>This is <em>probably</em> what you're wanting.</p>
<p>In this case, we probably aren't facing any race conditions. So just do as you were, but note that for writing, you need to open with the <code>w</code> mode (or <code>a</code> to append). It's also a Python best practice to use the context manager for opening files.</p>
<pre><code>import os
if not os.path.exists(directory):
    os.makedirs(directory)
with open(filepath, 'w') as my_file:
    do_stuff(my_file)
</code></pre>
<p>However, say we have several Python processes that attempt to put all their data into the same directory. Then we may have contention over creation of the directory. In that case it's best to wrap the <code>makedirs</code> call in a try-except block.</p>
<pre><code>import os
import errno
if not os.path.exists(directory):
    try:
        os.makedirs(directory)
    except OSError as error:
        if error.errno != errno.EEXIST:
            raise
with open(filepath, 'w') as my_file:
    do_stuff(my_file)
</code></pre>
------------------------------------------------------------------ <br><h3> Ali Afshar, Id: 273679, Score: 44: </h3><p>I have put the following down. It's not totally foolproof though.</p>

<pre><code>import os

dirname = 'create/me'

try:
    os.makedirs(dirname)
except OSError:
    if os.path.exists(dirname):
        # We are nearly safe
        pass
    else:
        # There was an error on creation, so make sure we know about it
        raise
</code></pre>

<p>Now as I say, this is not really foolproof, because we have the possiblity of failing to create the directory, and another process creating it during that period.</p>
------------------------------------------------------------------ <br><h3> Russia Must Remove Putin, Id: 28100717, Score: 35: </h3><blockquote>
  <p><strong>Check if a directory exists and create it if necessary?</strong></p>
</blockquote>

<p>The direct answer to this is, assuming a simple situation where you don't expect other users or processes to be messing with your directory:</p>

<pre><code>if not os.path.exists(d):
    os.makedirs(d)
</code></pre>

<p><strong>or</strong> if making the directory is subject to race conditions (i.e. if after checking the path exists, something else may have already made it) do this:</p>

<pre><code>import errno
try:
    os.makedirs(d)
except OSError as exception:
    if exception.errno != errno.EEXIST:
        raise
</code></pre>

<p>But perhaps an even better approach is to sidestep the resource contention issue, by using temporary directories via <a href="https://docs.python.org/library/tempfile.html#tempfile.mkdtemp" rel="noreferrer" title="tempfile.mkdtemp"><code>tempfile</code></a>:</p>

<pre><code>import tempfile

d = tempfile.mkdtemp()
</code></pre>

<p>Here's the essentials from the online doc:</p>

<blockquote>
<pre><code>mkdtemp(suffix='', prefix='tmp', dir=None)
    User-callable function to create and return a unique temporary
    directory.  The return value is the pathname of the directory.

    The directory is readable, writable, and searchable only by the
    creating user.

    Caller is responsible for deleting the directory when done with it.
</code></pre>
</blockquote>

<h2>New in Python 3.5: <code>pathlib.Path</code> with <code>exist_ok</code></h2>

<p>There's a new <code>Path</code> object (as of 3.4) with lots of methods one would want to use with paths - one of which is <code>mkdir</code>.</p>

<p>(For context, I'm tracking my weekly rep with a script. Here's the relevant parts of code from the script that allow me to avoid hitting Stack Overflow more than once a day for the same data.)</p>

<p>First the relevant imports:</p>

<pre><code>from pathlib import Path
import tempfile
</code></pre>

<p>We don't have to deal with <code>os.path.join</code> now - just join path parts with a <code>/</code>:</p>

<pre><code>directory = Path(tempfile.gettempdir()) / 'sodata'
</code></pre>

<p>Then I idempotently ensure the directory exists - the <code>exist_ok</code> argument shows up in Python 3.5:</p>

<pre><code>directory.mkdir(exist_ok=True)
</code></pre>

<p>Here's the relevant part of the <a href="https://docs.python.org/3/library/pathlib.html#pathlib.Path.mkdir" rel="noreferrer">documentation</a>:</p>

<blockquote>
  <p>If <code>exist_ok</code> is true, <code>FileExistsError</code> exceptions will be ignored (same behavior as the <code>POSIX mkdir -p</code> command), but only if the last path component is not an existing non-directory file.</p>
</blockquote>

<p>Here's a little more of the script - in my case, I'm not subject to a race condition, I only have one process that expects the directory (or contained files) to be there, and I don't have anything trying to remove the directory. </p>

<pre><code>todays_file = directory / str(datetime.datetime.utcnow().date())
if todays_file.exists():
    logger.info("todays_file exists: " + str(todays_file))
    df = pd.read_json(str(todays_file))
</code></pre>

<p><code>Path</code> objects have to be coerced to <code>str</code> before other APIs that expect <code>str</code> paths can use them.</p>

<p>Perhaps Pandas should be updated to accept instances of the abstract base class, <code>os.PathLike</code>.</p>
------------------------------------------------------------------ <br><h3> Simone, Id: 71466038, Score: 33: </h3><p>fastest safest way to do it is:
it will create if not exists and skip if exists:</p>
<pre class="lang-py prettyprint-override"><code>from pathlib import Path
Path(&quot;path/with/childs/.../&quot;).mkdir(parents=True, exist_ok=True)
</code></pre>
------------------------------------------------------------------ <br><h3> Devil, Id: 71029280, Score: 31: </h3><pre><code>import os
directory = &quot;./out_dir/subdir1/subdir2&quot;
if not os.path.exists(directory):
    os.makedirs(directory)
</code></pre>
------------------------------------------------------------------ <br><h3> tashuhka, Id: 36289129, Score: 26: </h3><p>For a one-liner solution, you can use <a href="https://github.com/ipython/ipython/blob/b70b3f21749ca969088fdb54edcc36bb8a2267b9/IPython/utils/path.py#L423-L438" rel="noreferrer"><code>IPython.utils.path.ensure_dir_exists()</code></a>:</p>
<pre><code>from IPython.utils.path import ensure_dir_exists
ensure_dir_exists(dir)
</code></pre>
<p>From the <a href="https://ipython.org/ipython-doc/3/api/generated/IPython.utils.path.html#IPython.utils.path.ensure_dir_exists" rel="noreferrer">documentation</a>: <em>Ensure that a directory exists. If it doesn’t exist, try to create it and protect against a race condition if another process is doing the same.</em></p>
<p>IPython is an extension package, not part of the standard library.</p>
------------------------------------------------------------------ <br><h3> Antti Haapala -- Слава Україні, Id: 28997083, Score: 27: </h3><p>In Python 3.4 you can also use the <a href="https://docs.python.org/3/library/pathlib.html">brand new <code>pathlib</code> module</a>:</p>

<pre><code>from pathlib import Path
path = Path("/my/directory/filename.txt")
try:
    if not path.parent.exists():
        path.parent.mkdir(parents=True)
except OSError:
    # handle error; you can also catch specific errors like
    # FileExistsError and so on.
</code></pre>
------------------------------------------------------------------ <br><h3> euccas, Id: 41453417, Score: 26: </h3><p>In <strong>Python3</strong>, <code>os.makedirs</code> supports setting <code>exist_ok</code>. The default setting is <code>False</code>, which means an <code>OSError</code> will be raised if the target directory already exists. By setting <code>exist_ok</code> to <code>True</code>, <code>OSError</code> (directory exists) will be ignored and the directory will not be created.</p>

<pre><code>os.makedirs(path,exist_ok=True)
</code></pre>

<p>In <strong>Python2</strong>, <code>os.makedirs</code> doesn't support setting <code>exist_ok</code>. You can use the approach in <a href="https://stackoverflow.com/a/5032238/3109254">heikki-toivonen's answer</a>:</p>

<pre><code>import os
import errno

def make_sure_path_exists(path):
    try:
        os.makedirs(path)
    except OSError as exception:
        if exception.errno != errno.EEXIST:
            raise
</code></pre>
------------------------------------------------------------------ <br><h3> Dominykas Mostauskis, Id: 68821616, Score: 11: </h3><p>In case you're writing a file to a variable path, you can use this on the file's path to make sure that the parent directories are created.</p>
<pre><code>from pathlib import Path

path_to_file = Path(&quot;zero/or/more/directories/file.ext&quot;)
parent_directory_of_file = path_to_file.parent
parent_directory_of_file.mkdir(parents=True, exist_ok=True)
</code></pre>
<p>Works even if <code>path_to_file</code> is <code>file.ext</code> (zero directories deep).</p>
<p>See <a href="https://docs.python.org/3/library/pathlib.html#pathlib.PurePath.parent" rel="noreferrer">pathlib.PurePath.parent</a> and <a href="https://docs.python.org/3/library/pathlib.html#pathlib.Path.mkdir" rel="noreferrer">pathlib.Path.mkdir</a>.</p>
------------------------------------------------------------------ <br><h3> kavadias, Id: 24740135, Score: 21: </h3><p>The <a href="https://docs.python.org/2/library/os.html#files-and-directories" rel="noreferrer">relevant Python documentation</a> suggests the use of the <a href="https://docs.python.org/2/library/os.html#files-and-directories" rel="noreferrer">EAFP coding style (Easier to Ask for Forgiveness than Permission)</a>. This means that the code</p>

<pre><code>try:
    os.makedirs(path)
except OSError as exception:
    if exception.errno != errno.EEXIST:
        raise
    else:
        print "\nBE CAREFUL! Directory %s already exists." % path
</code></pre>

<p>is better than the alternative</p>

<pre><code>if not os.path.exists(path):
    os.makedirs(path)
else:
    print "\nBE CAREFUL! Directory %s already exists." % path
</code></pre>

<p>The documentation suggests this exactly because of the race condition discussed in this question. In addition, as others mention here, there is a performance advantage in querying once instead of twice the OS. Finally, the argument placed forward, potentially, in favour of the second code in some cases --when the developer knows the environment the application is running-- can only be advocated in the special case that the program has set up a private environment for itself (and other instances of the same program).</p>

<p>Even in that case, this is a bad practice and can lead to long useless debugging. For example, the fact we set the permissions for a directory should not leave us with the impression permissions are set appropriately for our purposes. A parent directory could be mounted with other permissions. In general, a program should always work correctly and the programmer should not expect one specific environment.</p>
------------------------------------------------------------------ <br><h3> Dennis Golomazov, Id: 39479473, Score: 13: </h3><p>You can use <a href="https://docs.python.org/2/distutils/apiref.html#distutils.dir_util.mkpath" rel="noreferrer"><code>mkpath</code></a></p>

<pre><code># Create a directory and any missing ancestor directories. 
# If the directory already exists, do nothing.

from distutils.dir_util import mkpath
mkpath("test")    
</code></pre>

<p>Note that it will create the ancestor directories as well. </p>

<p>It works for Python 2 and 3.</p>
------------------------------------------------------------------ <br><h3> Victoria Stuart, Id: 47842472, Score: 14: </h3><p>I found this Q/A after I was puzzled by some of the failures and errors I was getting while working with directories in Python. I am working in Python 3 (v.3.5 in an Anaconda virtual environment on an Arch Linux x86_64 system).</p>
<p>Consider this directory structure:</p>
<pre><code>└── output/         ## dir
   ├── corpus       ## file
   ├── corpus2/     ## dir
   └── subdir/      ## dir
</code></pre>
<p>Here are my experiments/notes, which provides clarification:</p>
<pre><code># ----------------------------------------------------------------------------
# [1] https://stackoverflow.com/questions/273192/how-can-i-create-a-directory-if-it-does-not-exist

import pathlib

&quot;&quot;&quot; Notes:
        1.  Include a trailing slash at the end of the directory path
            (&quot;Method 1,&quot; below).
        2.  If a subdirectory in your intended path matches an existing file
            with same name, you will get the following error:
            &quot;NotADirectoryError: [Errno 20] Not a directory:&quot; ...
&quot;&quot;&quot;
# Uncomment and try each of these &quot;out_dir&quot; paths, singly:

# ----------------------------------------------------------------------------
# METHOD 1:
# Re-running does not overwrite existing directories and files; no errors.

# out_dir = 'output/corpus3'                ## no error but no dir created (missing tailing /)
# out_dir = 'output/corpus3/'               ## works
# out_dir = 'output/corpus3/doc1'           ## no error but no dir created (missing tailing /)
# out_dir = 'output/corpus3/doc1/'          ## works
# out_dir = 'output/corpus3/doc1/doc.txt'   ## no error but no file created (os.makedirs creates dir, not files!  ;-)
# out_dir = 'output/corpus2/tfidf/'         ## fails with &quot;Errno 20&quot; (existing file named &quot;corpus2&quot;)
# out_dir = 'output/corpus3/tfidf/'         ## works
# out_dir = 'output/corpus3/a/b/c/d/'       ## works

# [2] https://docs.python.org/3/library/os.html#os.makedirs

# Uncomment these to run &quot;Method 1&quot;:

#directory = os.path.dirname(out_dir)
#os.makedirs(directory, mode=0o777, exist_ok=True)

# ----------------------------------------------------------------------------
# METHOD 2:
# Re-running does not overwrite existing directories and files; no errors.

# out_dir = 'output/corpus3'                ## works
# out_dir = 'output/corpus3/'               ## works
# out_dir = 'output/corpus3/doc1'           ## works
# out_dir = 'output/corpus3/doc1/'          ## works
# out_dir = 'output/corpus3/doc1/doc.txt'   ## no error but creates a .../doc.txt./ dir
# out_dir = 'output/corpus2/tfidf/'         ## fails with &quot;Errno 20&quot; (existing file named &quot;corpus2&quot;)
# out_dir = 'output/corpus3/tfidf/'         ## works
# out_dir = 'output/corpus3/a/b/c/d/'       ## works

# Uncomment these to run &quot;Method 2&quot;:

#import os, errno
#try:
#       os.makedirs(out_dir)
#except OSError as e:
#       if e.errno != errno.EEXIST:
#               raise
# ----------------------------------------------------------------------------
</code></pre>
<p>Conclusion: in my opinion, &quot;Method 2&quot; is more robust.</p>
<p>[1] <a href="https://stackoverflow.com/questions/273192/how-can-i-create-a-directory-if-it-does-not-exist">How can I safely create a nested directory?</a></p>
<p>[2] <a href="https://docs.python.org/3/library/os.html#os.makedirs" rel="nofollow noreferrer">https://docs.python.org/3/library/os.html#os.makedirs</a></p>
<h4> S&#246;ren, Comment 128498015 Score: 0: </h4>The reason your method 1 doesn&#39;t work is the call to os.dirname. Without it, method 1 works as expected.<br>------------------------------------------------------------------ <br><h3> Geoff Paul Bremner, Id: 52282050, Score: 10: </h3><p>Why not use subprocess module if running on a machine that supports command 
<code>mkdir</code> with <code>-p</code> option ? 
Works on python 2.7 and python 3.6</p>

<pre><code>from subprocess import call
call(['mkdir', '-p', 'path1/path2/path3'])
</code></pre>

<p>Should do the trick on most systems.</p>

<p>In situations where portability doesn't matter (ex, using docker) the solution is a clean 2 lines. You also don't have to add logic to check if directories exist or not. Finally, it is safe to re-run without any side effects</p>

<p>If you need error handling:</p>

<pre><code>from subprocess import check_call
try:
    check_call(['mkdir', '-p', 'path1/path2/path3'])
except:
    handle...
</code></pre>
------------------------------------------------------------------ <br><h3> Hussam Kurd, Id: 56203876, Score: 10: </h3><p>You have to set the full path before creating the directory:</p>

<pre><code>import os,sys,inspect
import pathlib

currentdir = os.path.dirname(os.path.abspath(inspect.getfile(inspect.currentframe())))
your_folder = currentdir + "/" + "your_folder"

if not os.path.exists(your_folder):
   pathlib.Path(your_folder).mkdir(parents=True, exist_ok=True)
</code></pre>

<p>This works for me and hopefully, it will works for you as well</p>
------------------------------------------------------------------ <br><h3> SyntaxNavigator, Id: 76142478, Score: 10: </h3><p>You can pass the exist_ok=True parameter to the os.makedirs() function to suppress the error in case the directory already exists:</p>
<pre><code>import os

# Create directory /path/to/nested/directory if it doesn't already exist
os.makedirs('/path/to/nested/directory', exist_ok=True)
</code></pre>
<h4> Adam Jaamour, Comment 136593639 Score: 0: </h4>Very clean/concise solution that does not require if statements!<br>------------------------------------------------------------------ <br><h3> Michael Strobel, Id: 42127930, Score: 9: </h3><p>I use <code>os.path.exists()</code>, <a href="http://pastebin.com/vnVk2rY5" rel="noreferrer">here</a> is a Python 3 script that can be used to check if a directory exists, create one if it does not exist, and delete it if it does exist (if desired).</p>

<p>It prompts users for input of the directory and can be easily modified.</p>
<h4> Ryan M, Comment 134203877 Score: 0: </h4>If you created this script, please include it in the answer <i>here</i>.  Links can become invalid if the linked page changes.<br>------------------------------------------------------------------ <br><h3> Manivannan Murugavel, Id: 49851755, Score: 8: </h3><p>Use this command check and create dir</p>

<pre><code> if not os.path.isdir(test_img_dir):
     os.mkdir(test_img_dir)
</code></pre>
<h4> Ryan M, Comment 134203871 Score: 0: </h4>This doesn&#39;t create parent directories.  From the <code>os.mkdir</code> docs: <i>&quot;If a parent directory in the path does not exist, <code>FileNotFoundError</code> is raised.&quot;</i><br>------------------------------------------------------------------ <br><h3> Steffi Keran Rani J, Id: 50078422, Score: 8: </h3><p>Call the function <code>create_dir()</code> at the entry point of your program/project.</p>

<pre><code>import os

def create_dir(directory):
    if not os.path.exists(directory):
        print('Creating Directory '+directory)
        os.makedirs(directory)

create_dir('Project directory')
</code></pre>
------------------------------------------------------------------ <br><h3> korakot, Id: 64474894, Score: 3: </h3><p>This may not exactly answer the question. But I guess your real intention is to create a file and its parent directories, given its content all in 1 command.</p>
<p>You can do that with <code>fastcore</code> extension to pathlib: <code>path.mk_write(data)</code></p>
<pre class="lang-py prettyprint-override"><code>from fastcore.utils import Path
Path('/dir/to/file.txt').mk_write('Hello World')
</code></pre>
<p>See more in <a href="https://fastcore.fast.ai/xtras.html#Path.mk_write" rel="nofollow noreferrer">fastcore documentation</a></p>
