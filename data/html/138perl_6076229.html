 <h2> Title: Escaping a forward slash in a regular expression </h2> <h3> Zerobu, question_id: 6076229 </h3>Score: 138, Tags: {regex,perl,escaping} <br><p>My question is a simple one, and it is about regular expression escaping. Do you have to escape a forward slash <code>/</code> in a regular expression? And how would you go about doing it?</p>
<h4> Comment 7037986 Gumbo: </h4>What language/regular expression implementation do you use?<br><h4> Comment 96189172 Turbo: </h4>Interestingly enough, I was looking for this question for Javascript. But then my IDE said I was using an unnecessary escape. So <code>myStr.replace(&#47;[&#47;:.-]+&#47;gi, &#39;_&#39;)</code> is valid to my surprise. I thought I was going to need <code>&#47;[\&#47;:.-]+&#47;gi</code>. I can&#39;t decide if this is cool or confusing.<br>------------------------------------------------------------------ <br><h3> Answer 6076269 CrayonViolent: </h3><p>What context/language?  Some languages use <code>/</code> as the pattern delimiter, so yes, you need to escape it, depending on which language/context.  You escape it by putting a backward slash in front of it: <code>\/</code> For some languages (like PHP) you can use other characters as the delimiter and therefore you don't need to escape it. But AFAIK in all languages, the only special significance the <code>/</code> has is it may be the designated pattern delimiter. </p>
------------------------------------------------------------------ <br><h3> Answer 6076567 DavidO: </h3><p>Here are a few options:</p>

<ul>
<li><p>In Perl, you can choose alternate delimiters.  You're not confined to <code>m//</code>.  You could choose another, such as <code>m{}</code>.  Then escaping isn't necessary.  As a matter of fact, Damian Conway in "Perl Best Practices" asserts that <code>m{}</code> is the only alternate delimiter that ought to be used, and this is reinforced by Perl::Critic (on CPAN).  While you can get away with using a variety of alternate delimiter characters, <code>//</code> and <code>{}</code> seem to be the clearest to decipher later on.  However, if either of those choices result in too much escaping, choose whichever one lends itself best to legibility.  Common examples are <code>m(...)</code>, <code>m[...]</code>, and <code>m!...!</code>.</p></li>
<li><p>In cases where you either cannot or prefer not to use alternate delimiters, you can escape the forward slashes with a backslash:  <code>m/\/[^/]+$/</code> for example (using an alternate delimiter that could become <code>m{/[^/]+$}</code>, which may read more clearly).  Escaping the slash with a backslash is common enough to have earned a name and a wikipedia page: <a href="https://en.wikipedia.org/wiki/Leaning_toothpick_syndrome" rel="noreferrer">Leaning Toothpick Syndrome</a>.  In regular expressions where there's just a single instance, escaping a slash might not rise to the level of being considered a hindrance to legibility, but if it starts to get out of hand, and if your language permits alternate delimiters as Perl does, that would be the preferred solution.</p></li>
</ul>
<h4> Comment 106666867 user3012857: </h4>In the page linked by lukeuser (thank you) there is also the Escape Sequence \Q...\E . This worked for me.<br><h4> Comment 52716979 DavidO: </h4>@CMCDragonkai <code>perl -pi -e &quot;s{chdir .*}{chdir $ROBOT_PATH}g&quot; startup_scripts&#47;supervisord.conf</code> ... but this is probably better: <code>perl -pi -e &#39;s&#47;chdir .*&#47;chdir $ENV{ROBOT_PATH}&#47;g&#39; startup_scripts&#47;supervisord.conf</code> because it avoids shell interpolation.<br><h4> Comment 29556803 CMCDragonkai: </h4>Can you give an example? I have this: <code>perl -pi -e &quot;s&#47;chdir .*&#47;chdir $ROBOT_PATH&#47;g&quot; startup_scripts&#47;supervisord.conf</code> And I&#39;m getting conflicts with forward slashes.<br><h4> Comment 89137212 lukeuser: </h4>An alternative to escaping the literal <code>&#47;</code> character is to use regex functionality of specifying a character by its ASCII encoding, in hex or octal. Perl accepts the octal form <code>\57</code> (source <a href="https://www.regular-expressions.info/refcharacters.html" rel="nofollow noreferrer">regular-expressions.info/refcharacters.html</a>)<br><h4> Comment 42721582 Mashmagar: </h4>Note that you use an <code>s</code>, not an <code>m</code>, when doing a replace (aka substitute) with regular expressions. <a href="http://www.perlfect.com/articles/regex.shtml" rel="nofollow noreferrer">perlfect.com/articles/regex.shtml</a><br>------------------------------------------------------------------ <br><h3> Answer 6076511 Corey: </h3><p>Use the backslash <code>\</code> or choose a different delimiter, ie <code>m#.\d#</code> instead of <code>/.\d/</code>
"In Perl, you can change the / regular expression delimiter to almost any other special character if you preceed it with the letter m (for match);"</p>
------------------------------------------------------------------ <br><h3> Answer 6076274 fvox: </h3><p>If the delimiter is /, you will need to escape.</p>
------------------------------------------------------------------ <br><h3> Answer 58154839 ShrapNull: </h3><p>If you are using C#, you do not need to escape it.</p>
<h4> Comment 102692677 Toto: </h4>May be, but here they are using perl.<br>------------------------------------------------------------------ <br><h3> Answer 59012611 Dr.Bit: </h3><p>For java, you don't need to.</p>

<pre><code>eg: "^(.*)/\\*LOG:(\\d+)\\*/(.*)$" ==&gt; ^(.*)/\*LOG:(\d+)\*/(.*)$
</code></pre>

<p>If you put \ in front of /. IDE will tell you "Redundant Character Escape "\/" in ReGex"</p>
