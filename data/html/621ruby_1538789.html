 <h2> Title: How to sum array of numbers in Ruby? </h2> <h4> brainfck, question_id: 1538789 </h4>Score: 621, Tags: {ruby,arrays,math,sum} <br><p>I have an array of integers.</p>

<p>For example:</p>

<pre><code>array = [123,321,12389]
</code></pre>

<p>Is there any nice way to get the sum of them?</p>

<p>I know, that </p>

<pre><code>sum = 0
array.each { |a| sum+=a }
</code></pre>

<p>would work.</p>
<h4> dawg, Id: 76762593 Score: 40: </h4>Please note that Ruby 2.4+ has <code>array.sum</code><br><h4> steenslag, Id: 100107847 Score: 2: </h4>@Lori hmm ? <a href="https://docs.ruby-lang.org/en/2.6.0/Array.html#method-i-sum" rel="nofollow noreferrer">link</a><br><h4> Lori, Id: 100119566 Score: 2: </h4>Sorry. At that time I mistakenly believed I was using 2.6 because of a rbenv slip-up on my part.<br><h4> Lori, Id: 95452063 Score: 1: </h4>Ruby 2.6 does not have it. Ruby giveth, Ruby taketh away, it seems.<br><h4> Joshua Pinter, Id: 117553365 Score: 0: </h4>If you need to supply a default value for when the <code>Array</code> is empty, like if you want to return a <code>Money</code> object instead of an <code>Integer</code>, you can do something like <code>array.sum( 0.to_money( &quot;USD&quot; ) )</code>.<br>------------------------------------------------------------------ <br><h3> zenazn, Id: 1538801, Score: 646: </h3><p>Try this:</p>
<pre><code>array.inject(0){ |sum, x| sum + x }
</code></pre>
<p><a href="https://ruby-doc.org/core/Enumerable.html#method-i-inject" rel="nofollow noreferrer">See Ruby's Enumerable Documentation</a></p>
<p>(note: the <code>0</code> base case is needed so that <code>0</code> will be returned on an empty array instead of <code>nil</code>)</p>
<h4> Peter, Comment 1398846 Score: 327: </h4>jorney&#39;s <code>array.inject(:+)</code> is more efficient.<br><h4> Kamil Szot, Comment 17329257 Score: 37: </h4>In rails <code>array.sum</code> might give you sum of the array values.<br><h4> Boris Stitnicky, Comment 22499187 Score: 33: </h4>In most cases, I prefer to use <code>reduce</code>, which is an alias of <code>inject</code> (as in <code>array.reduce( :+ )</code>).<br><h4> Kamil Szot, Comment 17329240 Score: 4: </h4><code>array.inject(:+)</code> seems to cause <b>trouble</b> in Ruby 1.8.6 Exceptions &quot; LocalJumpError : no block given&quot; might pop up.<br><h4> yurisich, Comment 26125563 Score: 3: </h4>@Boris Also, Rubycop will warn you for using <code>inject</code> rather than <code>reduce</code>.<br>------------------------------------------------------------------ <br><h3> jomey, Id: 1538949, Score: 861: </h3><p><strong>For ruby &gt;= 2.4</strong> you can use <a href="https://apidock.com/ruby/Array/sum" rel="noreferrer">sum</a>:</p>
<p><code>array.sum</code></p>
<p><strong>For ruby &lt; 2.4</strong> you can use <a href="https://apidock.com/ruby/Enumerable/inject" rel="noreferrer">inject</a>:</p>
<pre><code>array.inject(0, :+)
</code></pre>
<p>Note: the <code>0</code> base case is needed otherwise <code>nil</code> will be returned on empty arrays:</p>
<pre><code>&gt; [].inject(:+)
nil
&gt; [].inject(0, :+)
0
</code></pre>
<h4> johnf, Comment 9287289 Score: 101: </h4><code>array.map(&amp;:price).inject(0, :+)</code> is a bit safer. It makes sure that if you have an empty list you get <b>0</b> instead of <b>nil</b>.<br><h4> Pablo Cantero, Comment 6665716 Score: 6: </h4>How can I use this way to sum a attribute from object. My array [product1, product2] I want to sum product1.price + product2.price. Is it possible using array.inject(:+)?<br><h4> everett1992, Comment 22474841 Score: 11: </h4>using array.map(...).inject(...) is inefficient, you will iterate through all data twice. Try  <code>array.inject(0) { |sum, product| sum += product.price }</code><br><h4> markquezada, Comment 8856984 Score: 7: </h4>You can use a similar trick with the map method: array.map(&amp;:price).inject(:+)<br><h4> Cameron Martin, Comment 39593252 Score: 5: </h4>@everett1992 and as it turns out, not even an optimisation at all. Doing it in two stages is consistently faster for me. <a href="https://gist.github.com/cameron-martin/b907ec43a9d8b9303bdc" rel="nofollow noreferrer">gist.github.com/cameron-martin/b907ec43a9d8b9303bdc</a><br><h4> Cameron Martin, Comment 39592802 Score: 1: </h4>@everett1992 In most cases, this is probably a premature optimisation.<br><h4> Diego Basch, Comment 8166850 Score: 1: </h4>Pablo: You can do: array.map{|p| p.price}.inject(+:)<br><h4> Cadoiz, Comment 135369176 Score: 0: </h4>@everett1992 <code>inject</code> handles forwarding the result itself. you should write <code>sum + product.price</code> instead of <code>sum += product.price</code>. If you really want to build an object by yourself (e.g. some array), you should consider <a href="https://apidock.com/ruby/Enumerable/each_with_object" rel="nofollow noreferrer"><code>each_with_object</code></a><br><h4> Cadoiz, Comment 135369214 Score: 0: </h4>@PabloCantero for ruby &gt;= 2.4, <a href="https://apidock.com/ruby/Array/sum" rel="nofollow noreferrer">sum</a> works like this: <code>array.sum(&amp;:price)</code> (you can also use the pretzel-colon like Johnf suggested with <code>.map</code>. In rails btw <a href="https://apidock.com/rails/ActiveRecord/Calculations/ClassMethods/sum" rel="nofollow noreferrer">the <code>sum</code> method already exists like forever</a>.<br>------------------------------------------------------------------ <br><h3> Evan, Id: 13883189, Score: 305: </h3><pre><code>array.reduce(0, :+)
</code></pre>

<p>While equivalent to <code>array.inject(0, :+)</code>, the term <strong>reduce</strong> is entering a more common vernacular with the rise of <a href="http://en.wikipedia.org/wiki/MapReduce">MapReduce programming models</a>.</p>

<p><strong>inject</strong>, <strong>reduce</strong>, <strong>fold</strong>, <strong>accumulate</strong>, and <strong>compress</strong> are all synonymous as a class of <a href="http://en.wikipedia.org/wiki/Reduce_%28higher-order_function%29">folding functions</a>. I find consistency across your code base most important, but since various communities tend to prefer one word over another, it’s nonetheless useful to know the alternatives.</p>

<p>To emphasize the map-reduce verbiage, here’s a version that is a little bit more forgiving on what ends up in that array.</p>

<pre><code>array.map(&amp;:to_i).reduce(0, :+)
</code></pre>

<p>Some additional relevant reading:</p>

<ul>
<li><a href="http://ruby-doc.org/core-1.9.3/Enumerable.html#method-i-inject">http://ruby-doc.org/core-1.9.3/Enumerable.html#method-i-inject</a></li>
<li><a href="http://en.wikipedia.org/wiki/MapReduce">http://en.wikipedia.org/wiki/MapReduce</a></li>
<li><a href="http://en.wikipedia.org/wiki/Fold_(higher-order_function)">http://en.wikipedia.org/wiki/Fold_(higher-order_function)</a></li>
</ul>
<h4> everett1992, Comment 22474887 Score: 12: </h4>I agree, <code>reduce</code> tells me more of what the function does, but <code>inject</code> does sound much cooler.<br><h4> acjay, Comment 47359987 Score: 1: </h4>The one comment I would make is that <code>reduce</code> and <code>map</code> as higher-order functions predate MapReduce. The inspiration runs the other way. And in the MapReduce sense, it&#39;s a somewhat different operation than a simple functional reduce, having implications for how different machines communicate.<br><h4> Fernando Pelliccioni, Comment 64508353 Score: 1: </h4>Ken Iverson introduced the operator / called &quot;reduction operator&quot; in the programming language APL.  Source: Iverson, Kenneth. 1962. A Programming Language. Wiley.  Another source: &quot;Notation as a Tool of Thought&quot;, 1979 ACM Turing Award Lecture, Kenneth E. Iverson, <a href="http://dl.acm.org/ft_gateway.cfm?id=1283935&amp;type=pdf" rel="nofollow noreferrer">dl.acm.org/ft_gateway.cfm?id=1283935&amp;type=pdf</a><br>------------------------------------------------------------------ <br><h3> Mike Woodhouse, Id: 1539087, Score: 118: </h3><p>Alternatively (just for comparison), if you have Rails installed (actually just ActiveSupport):</p>

<pre><code>require 'activesupport'
array.sum
</code></pre>
<h4> dcashman, Comment 12498792 Score: 13: </h4>Newer versions of activesupport don&#39;t actually load all extensions by default.  You&#39;ll want to either require just the sum module: <code>require &#39;active_support&#47;core_ext&#47;enumerable.rb&#39;</code>, or require all of active support: <code>require &#39;active_support&#47;all&#39;</code>.  More about it here: <a href="http://edgeguides.rubyonrails.org/active_support_core_extensions.html" rel="nofollow noreferrer">API Docs</a><br><h4> user229044, Comment 58388418 Score: 2: </h4>Never mind that <code>activesupport</code> is a <i>massive</i> dependency to drag into a project to go from <code>array.inject(:+)</code> to <code>array.sum</code>.<br><h4> Per Lundberg, Comment 63875265 Score: 1: </h4>Nitpick to an otherwise good comment: it should be <code>require &#39;active_support&#47;core_ext&#47;enumerable&#39;</code> without the <code>.rb</code> suffix, since that&#39;s added implicitly.<br>------------------------------------------------------------------ <br><h3> jrhicks, Id: 1539643, Score: 97: </h3><p>For Ruby >=2.4.0 you can use <code>sum</code> from Enumerables.</p>

<pre><code>[1, 2, 3, 4].sum
</code></pre>

<p>It is dangerous to mokeypatch base classes.  If you like danger and using an older version of Ruby, you could add <code>#sum</code> to the <code>Array</code> class:</p>

<pre><code>class Array
  def sum
    inject(0) { |sum, x| sum + x }
  end
end
</code></pre>
<h4> user3467349, Comment 67002914 Score: 19: </h4>Monkeypatching base classes is not nice.<br><h4> Peter H. Boling, Comment 73513342 Score: 2: </h4>The point he is making is that you don&#39;t need to do the Monkey Patch for Ruby &gt;= 2.4, and that monkey patching is dangerous, and that you can now sum enumerables natively, but there is also a way to backport the functionality.<br><h4> Cary Swoveland, Comment 87428137 Score: 0: </h4>As noted, <a href="http://ruby-doc.org/core-2.4.0/Enumerable.html#method-i-sum" rel="nofollow noreferrer">Enumerable#sum</a> (and <a href="http://ruby-doc.org/core-2.4.0/Array.html#method-i-sum" rel="nofollow noreferrer">Array#sum</a>) were introduced in Ruby v2.4. Importantly, they do not have the same behavior as your <code>Array#sum</code>; namely, they take an optional argument and an optional block. Defining <code>Array#sum</code> as you have would result in an exception being raised wherever <code>sum</code> appeared in the code with an argument or block.<br><h4> Joshua Pinter, Comment 117553374 Score: 0: </h4>If you need to supply a default value for when the <code>Array</code> is empty, like if you want to return a <code>Money</code> object instead of an <code>Integer</code>, you can do something like <code>array.sum( 0.to_money( &quot;USD&quot; ) )</code>.<br>------------------------------------------------------------------ <br><h3> Eli Sadoff, Id: 41455793, Score: 51: </h3><h1>New for Ruby 2.4.0</h1>

<p>You can use the aptly named method <code>Enumerable#sum</code>. It has a lot of advantages over <code>inject(:+)</code> but there are some important notes to read at the end as well. </p>

<h2>Examples</h2>

<h3>Ranges</h3>

<pre><code>(1..100).sum
#=&gt; 5050
</code></pre>

<h3>Arrays</h3>

<pre><code>[1, 2, 4, 9, 2, 3].sum
#=&gt; 21

[1.9, 6.3, 20.3, 49.2].sum
#=&gt; 77.7
</code></pre>

<h2>Important note</h2>

<p>This method is not equivalent to <code>#inject(:+)</code>. For example </p>

<pre><code>%w(a b c).inject(:+)
#=&gt; "abc"
%w(a b c).sum
#=&gt; TypeError: String can't be coerced into Integer
</code></pre>

<p>Also,</p>

<pre><code>(1..1000000000).sum
#=&gt; 500000000500000000 (execution time: less than 1s)
(1..1000000000).inject(:+)
#=&gt; 500000000500000000 (execution time: upwards of a minute)
</code></pre>

<p>See <a href="https://stackoverflow.com/a/41449844/5021321">this answer</a> for more information on why <code>sum</code> is like this.</p>
<h4> Cadoiz, Comment 135369265 Score: 0: </h4>This answer is deprecated. In ruby2.6.6 for example, you <b>can</b> do <code>%w(a b c).sum # =&gt; &quot;abc&quot;</code><br><h4> Kelsey Hannan, Comment 136663042 Score: 0: </h4>Note that if you are doing math, an <code>Array</code> of <code>Float</code> or <code>BigDecimal</code> called by <code>.sum</code> will convert them back to <code>Integer</code>, breaking your math!  You need to call <code>foo.sum.to_f</code> to preserve the Float.<br><h4> Joshua Pinter, Comment 117553386 Score: 0: </h4>If you need to supply a default value for when the <code>Array</code> is empty, like if you want to return a <code>Money</code> object instead of an <code>Integer</code>, you can do something like <code>array.sum( 0.to_money( &quot;USD&quot; ) )</code>.<br>------------------------------------------------------------------ <br><h3> typo, Id: 37720876, Score: 22: </h3><p>Ruby 2.4+ / Rails - <code>array.sum</code> i.e. <code>[1, 2, 3].sum # =&gt; 6</code></p>

<p>Ruby pre 2.4 - <code>array.inject(:+)</code> or <code>array.reduce(:+)</code></p>

<p>*Note: The <code>#sum</code> method is a new addition to 2.4 for <code>enumerable</code> so you will now be able to use <code>array.sum</code> in pure ruby, not just Rails.</p>
------------------------------------------------------------------ <br><h3> HashFail, Id: 17836792, Score: 19: </h3><p>Just for the sake of diversity, you can also do this if your array is not an array of numbers, but rather an array of objects that have properties that are numbers (e.g. amount):</p>

<pre><code>array.inject(0){|sum,x| sum + x.amount}
</code></pre>
<h4> HashFail, Comment 33245453 Score: 4: </h4>In a way, yes. However, using <code>map</code> then <code>inject</code> requires you to loop through the array twice: once to create a new array, the other to sum the members. This method is slightly more verbose, but also more efficient.<br><h4> Richard Jones, Comment 33209319 Score: 3: </h4>This is equivalent to doing: <code>array.map(&amp;:amount).inject(0, :+)</code>. See other answers.<br><h4> Cadoiz, Comment 135369392 Score: 1: </h4>@RichardJones or just <code>array.sum(&amp;:amount)</code> as of today (using ruby &gt;= 2.4 or rails).<br><h4> rmcsharry, Comment 100296297 Score: 0: </h4>Apparently it is not more efficient, see <a href="https://gist.github.com/cameron-martin/b907ec43a9d8b9303bdc" rel="nofollow noreferrer">gist.github.com/cameron-martin/b907ec43a9d8b9303bdc</a> - credit to the comments in this answer: <a href="https://stackoverflow.com/a/1538949/1028679">stackoverflow.com/a/1538949/1028679</a><br>------------------------------------------------------------------ <br><h3> Vova, Id: 6442884, Score: 18: </h3><p>ruby 1.8.7 way is the following:</p>

<pre><code>array.inject(0, &amp;:+) 
</code></pre>
<h4> Andrew Grimm, Comment 37465079 Score: 0: </h4>If you read my 2011 comment, and it&#39;s still relevant as you&#39;re using 1.8.6, please upgrade!<br>------------------------------------------------------------------ <br><h3> Santhosh, Id: 41222471, Score: 6: </h3><p>Ruby 2.4.0 is released, and it has an <a href="http://ruby-doc.org/core-2.4.0/Enumerable.html#method-i-sum" rel="noreferrer">Enumerable#sum</a> method. So you can do</p>

<pre><code>array.sum
</code></pre>

<p>Examples from the docs:</p>

<pre><code>{ 1 =&gt; 10, 2 =&gt; 20 }.sum {|k, v| k * v }  #=&gt; 50
(1..10).sum                               #=&gt; 55
(1..10).sum {|v| v * 2 }                  #=&gt; 110
</code></pre>
------------------------------------------------------------------ <br><h3> grosser, Id: 4841853, Score: 4: </h3><p>Also allows for <code>[1,2].sum{|x| x * 2 } == 6</code>:</p>

<pre><code># http://madeofcode.com/posts/74-ruby-core-extension-array-sum
class Array
  def sum(method = nil, &amp;block)
    if block_given?
      raise ArgumentError, "You cannot pass a block and a method!" if method
      inject(0) { |sum, i| sum + yield(i) }
    elsif method
      inject(0) { |sum, i| sum + i.send(method) }
    else
      inject(0) { |sum, i| sum + i }
    end
  end
end
</code></pre>
------------------------------------------------------------------ <br><h3> thedudecodes, Id: 50147045, Score: 4: </h3><p>for array with nil values we can do compact and then inject the sum
ex-</p>

<pre><code>a = [1,2,3,4,5,12,23.45,nil,23,nil]
puts a.compact.inject(:+)
</code></pre>
------------------------------------------------------------------ <br><h3> raj_acharya, Id: 48562114, Score: 2: </h3><p><strong>Method 1:</strong></p>

<pre><code>    [1] pry(main)&gt; [1,2,3,4].sum
    =&gt; 10
    [2] pry(main)&gt; [].sum
    =&gt; 0
    [3] pry(main)&gt; [1,2,3,5,nil].sum
    TypeError: nil can't be coerced into Integer
</code></pre>

<p><strong>Method 2:</strong> </p>

<pre><code>   [24] pry(main)&gt; [].inject(:+)
   =&gt; nil
   [25] pry(main)&gt; [].inject(0, :+)
   =&gt; 0
   [4] pry(main)&gt; [1,2,3,4,5].inject(0, :+)
   =&gt; 15
   [5] pry(main)&gt; [1,2,3,4,nil].inject(0, :+)
   TypeError: nil can't be coerced into Integer
   from (pry):5:in `+'
</code></pre>

<p><strong>Method 3:</strong></p>

<pre><code>   [6] pry(main)&gt; [1,2,3].reduce(:+)
   =&gt; 6
   [9] pry(main)&gt; [].reduce(:+)
   =&gt; nil
   [7] pry(main)&gt; [1,2,nil].reduce(:+)
   TypeError: nil can't be coerced into Integer
   from (pry):7:in `+'
</code></pre>

<p><strong>Method 4:</strong>
       When Array contains an nil and empty values, by default if you use any above functions reduce, sum, inject everything will through the  </p>

<blockquote>
  <p>TypeError: nil can't be coerced into Integer</p>
</blockquote>

<p>You can overcome this by,</p>

<pre><code>   [16] pry(main)&gt; sum = 0 
   =&gt; 0
   [17] pry(main)&gt; [1,2,3,4,nil, ''].each{|a| sum+= a.to_i }
   =&gt; [1, 2, 3, 4, nil, ""]
   [18] pry(main)&gt; sum
   =&gt; 10
</code></pre>

<p><strong>Method 6:</strong>
      <strong>eval</strong></p>

<p>Evaluates the Ruby expression(s) in string.</p>

<pre><code>  [26] pry(main)&gt; a = [1,3,4,5]
  =&gt; [1, 3, 4, 5]
  [27] pry(main)&gt; eval a.join '+'
  =&gt; 13
  [30] pry(main)&gt; a = [1,3,4,5, nil]
  =&gt; [1, 3, 4, 5, nil]
  [31] pry(main)&gt; eval a.join '+'
  SyntaxError: (eval):1: syntax error, unexpected end-of-input
  1+3+4+5+
</code></pre>
<h4> Cadoiz, Comment 135369365 Score: 0: </h4><code>reduce</code> and <code>inject</code> are literally the same thing. If you really want to build an object by yourself, you should consider <a href="https://apidock.com/ruby/Enumerable/each_with_object" rel="nofollow noreferrer"><code>each_with_object</code></a> instead of <code>each</code> (Method 4). Suggestion: <code>[1,2,3,4,nil, &#39;&#39;].each_with_object(0) {|a| sum+= a.to_i }</code><br>------------------------------------------------------------------ <br><h3> Ulysse BN, Id: 40833501, Score: 1: </h3><p>If you feel golfy, you can do</p>
<pre><code>eval [123,321,12389]*?+
</code></pre>
<p>This will create a string &quot;123+321+12389&quot; and then use function eval to do the sum. This is <strong>only for golfing purpose</strong>, you should not use it in proper code.</p>
------------------------------------------------------------------ <br><h3> Prabhakar, Id: 27445759, Score: -1: </h3><p>You can also do it in easy way</p>

<pre><code>def sum(numbers)
  return 0 if numbers.length &lt; 1
  result = 0
  numbers.each { |num| result += num }
  result
end
</code></pre>
<h4> user229044, Comment 111729599 Score: 1: </h4>This is very non-idiomatic Ruby, it looks like Ruby written by a C programmer. In Ruby, <code>inject</code> or <code>sum</code> are preferred.<br>------------------------------------------------------------------ <br><h3> shabdar, Id: 31597244, Score: -10: </h3><p>You can use <em>.map</em> and <em>.sum</em> like:</p>

<pre><code>array.map { |e| e }.sum
</code></pre>
<h4> Arnold Roa, Comment 55910422 Score: 3: </h4>What is the point of do a map returning same element? this is exactly the same than <code>array.sum</code><br>