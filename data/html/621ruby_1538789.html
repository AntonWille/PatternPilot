 <h2> Title: How to sum array of numbers in Ruby? </h2> <h3> brainfck, question_id: 1538789 </h3>Score: 621, Tags: {ruby,arrays,math,sum} <br><p>I have an array of integers.</p>

<p>For example:</p>

<pre><code>array = [123,321,12389]
</code></pre>

<p>Is there any nice way to get the sum of them?</p>

<p>I know, that </p>

<pre><code>sum = 0
array.each { |a| sum+=a }
</code></pre>

<p>would work.</p>
<h4> Comment 76762593 dawg: </h4>Please note that Ruby 2.4+ has <code>array.sum</code><br><h4> Comment 100107847 steenslag: </h4>@Lori hmm ? <a href="https://docs.ruby-lang.org/en/2.6.0/Array.html#method-i-sum" rel="nofollow noreferrer">link</a><br><h4> Comment 100119566 Lori: </h4>Sorry. At that time I mistakenly believed I was using 2.6 because of a rbenv slip-up on my part.<br><h4> Comment 95452063 Lori: </h4>Ruby 2.6 does not have it. Ruby giveth, Ruby taketh away, it seems.<br><h4> Comment 117553365 Joshua Pinter: </h4>If you need to supply a default value for when the <code>Array</code> is empty, like if you want to return a <code>Money</code> object instead of an <code>Integer</code>, you can do something like <code>array.sum( 0.to_money( &quot;USD&quot; ) )</code>.<br>------------------------------------------------------------------ <br><h3> Answer 1538801 zenazn: </h3><p>Try this:</p>
<pre><code>array.inject(0){ |sum, x| sum + x }
</code></pre>
<p><a href="https://ruby-doc.org/core/Enumerable.html#method-i-inject" rel="nofollow noreferrer">See Ruby's Enumerable Documentation</a></p>
<p>(note: the <code>0</code> base case is needed so that <code>0</code> will be returned on an empty array instead of <code>nil</code>)</p>
<h4> Comment 1398846 Peter: </h4>jorney&#39;s <code>array.inject(:+)</code> is more efficient.<br><h4> Comment 17329257 Kamil Szot: </h4>In rails <code>array.sum</code> might give you sum of the array values.<br><h4> Comment 22499187 Boris Stitnicky: </h4>In most cases, I prefer to use <code>reduce</code>, which is an alias of <code>inject</code> (as in <code>array.reduce( :+ )</code>).<br><h4> Comment 17329240 Kamil Szot: </h4><code>array.inject(:+)</code> seems to cause <b>trouble</b> in Ruby 1.8.6 Exceptions &quot; LocalJumpError : no block given&quot; might pop up.<br><h4> Comment 26125563 yurisich: </h4>@Boris Also, Rubycop will warn you for using <code>inject</code> rather than <code>reduce</code>.<br>------------------------------------------------------------------ <br><h3> Answer 1538949 jomey: </h3><p><strong>For ruby &gt;= 2.4</strong> you can use <a href="https://apidock.com/ruby/Array/sum" rel="noreferrer">sum</a>:</p>
<p><code>array.sum</code></p>
<p><strong>For ruby &lt; 2.4</strong> you can use <a href="https://apidock.com/ruby/Enumerable/inject" rel="noreferrer">inject</a>:</p>
<pre><code>array.inject(0, :+)
</code></pre>
<p>Note: the <code>0</code> base case is needed otherwise <code>nil</code> will be returned on empty arrays:</p>
<pre><code>&gt; [].inject(:+)
nil
&gt; [].inject(0, :+)
0
</code></pre>
<h4> Comment 9287289 johnf: </h4><code>array.map(&amp;:price).inject(0, :+)</code> is a bit safer. It makes sure that if you have an empty list you get <b>0</b> instead of <b>nil</b>.<br><h4> Comment 6665716 Pablo Cantero: </h4>How can I use this way to sum a attribute from object. My array [product1, product2] I want to sum product1.price + product2.price. Is it possible using array.inject(:+)?<br><h4> Comment 22474841 everett1992: </h4>using array.map(...).inject(...) is inefficient, you will iterate through all data twice. Try  <code>array.inject(0) { |sum, product| sum += product.price }</code><br><h4> Comment 8856984 markquezada: </h4>You can use a similar trick with the map method: array.map(&amp;:price).inject(:+)<br><h4> Comment 39593252 Cameron Martin: </h4>@everett1992 and as it turns out, not even an optimisation at all. Doing it in two stages is consistently faster for me. <a href="https://gist.github.com/cameron-martin/b907ec43a9d8b9303bdc" rel="nofollow noreferrer">gist.github.com/cameron-martin/b907ec43a9d8b9303bdc</a><br><h4> Comment 39592802 Cameron Martin: </h4>@everett1992 In most cases, this is probably a premature optimisation.<br><h4> Comment 8166850 Diego Basch: </h4>Pablo: You can do: array.map{|p| p.price}.inject(+:)<br><h4> Comment 135369176 Cadoiz: </h4>@everett1992 <code>inject</code> handles forwarding the result itself. you should write <code>sum + product.price</code> instead of <code>sum += product.price</code>. If you really want to build an object by yourself (e.g. some array), you should consider <a href="https://apidock.com/ruby/Enumerable/each_with_object" rel="nofollow noreferrer"><code>each_with_object</code></a><br><h4> Comment 135369214 Cadoiz: </h4>@PabloCantero for ruby &gt;= 2.4, <a href="https://apidock.com/ruby/Array/sum" rel="nofollow noreferrer">sum</a> works like this: <code>array.sum(&amp;:price)</code> (you can also use the pretzel-colon like Johnf suggested with <code>.map</code>. In rails btw <a href="https://apidock.com/rails/ActiveRecord/Calculations/ClassMethods/sum" rel="nofollow noreferrer">the <code>sum</code> method already exists like forever</a>.<br>------------------------------------------------------------------ <br><h3> Answer 13883189 Evan: </h3><pre><code>array.reduce(0, :+)
</code></pre>

<p>While equivalent to <code>array.inject(0, :+)</code>, the term <strong>reduce</strong> is entering a more common vernacular with the rise of <a href="http://en.wikipedia.org/wiki/MapReduce">MapReduce programming models</a>.</p>

<p><strong>inject</strong>, <strong>reduce</strong>, <strong>fold</strong>, <strong>accumulate</strong>, and <strong>compress</strong> are all synonymous as a class of <a href="http://en.wikipedia.org/wiki/Reduce_%28higher-order_function%29">folding functions</a>. I find consistency across your code base most important, but since various communities tend to prefer one word over another, it’s nonetheless useful to know the alternatives.</p>

<p>To emphasize the map-reduce verbiage, here’s a version that is a little bit more forgiving on what ends up in that array.</p>

<pre><code>array.map(&amp;:to_i).reduce(0, :+)
</code></pre>

<p>Some additional relevant reading:</p>

<ul>
<li><a href="http://ruby-doc.org/core-1.9.3/Enumerable.html#method-i-inject">http://ruby-doc.org/core-1.9.3/Enumerable.html#method-i-inject</a></li>
<li><a href="http://en.wikipedia.org/wiki/MapReduce">http://en.wikipedia.org/wiki/MapReduce</a></li>
<li><a href="http://en.wikipedia.org/wiki/Fold_(higher-order_function)">http://en.wikipedia.org/wiki/Fold_(higher-order_function)</a></li>
</ul>
<h4> Comment 22474887 everett1992: </h4>I agree, <code>reduce</code> tells me more of what the function does, but <code>inject</code> does sound much cooler.<br><h4> Comment 47359987 acjay: </h4>The one comment I would make is that <code>reduce</code> and <code>map</code> as higher-order functions predate MapReduce. The inspiration runs the other way. And in the MapReduce sense, it&#39;s a somewhat different operation than a simple functional reduce, having implications for how different machines communicate.<br><h4> Comment 64508353 Fernando Pelliccioni: </h4>Ken Iverson introduced the operator / called &quot;reduction operator&quot; in the programming language APL.  Source: Iverson, Kenneth. 1962. A Programming Language. Wiley.  Another source: &quot;Notation as a Tool of Thought&quot;, 1979 ACM Turing Award Lecture, Kenneth E. Iverson, <a href="http://dl.acm.org/ft_gateway.cfm?id=1283935&amp;type=pdf" rel="nofollow noreferrer">dl.acm.org/ft_gateway.cfm?id=1283935&amp;type=pdf</a><br>------------------------------------------------------------------ <br><h3> Answer 1539087 Mike Woodhouse: </h3><p>Alternatively (just for comparison), if you have Rails installed (actually just ActiveSupport):</p>

<pre><code>require 'activesupport'
array.sum
</code></pre>
<h4> Comment 12498792 dcashman: </h4>Newer versions of activesupport don&#39;t actually load all extensions by default.  You&#39;ll want to either require just the sum module: <code>require &#39;active_support&#47;core_ext&#47;enumerable.rb&#39;</code>, or require all of active support: <code>require &#39;active_support&#47;all&#39;</code>.  More about it here: <a href="http://edgeguides.rubyonrails.org/active_support_core_extensions.html" rel="nofollow noreferrer">API Docs</a><br><h4> Comment 58388418 user229044: </h4>Never mind that <code>activesupport</code> is a <i>massive</i> dependency to drag into a project to go from <code>array.inject(:+)</code> to <code>array.sum</code>.<br><h4> Comment 63875265 Per Lundberg: </h4>Nitpick to an otherwise good comment: it should be <code>require &#39;active_support&#47;core_ext&#47;enumerable&#39;</code> without the <code>.rb</code> suffix, since that&#39;s added implicitly.<br>------------------------------------------------------------------ <br><h3> Answer 1539643 jrhicks: </h3><p>For Ruby >=2.4.0 you can use <code>sum</code> from Enumerables.</p>

<pre><code>[1, 2, 3, 4].sum
</code></pre>

<p>It is dangerous to mokeypatch base classes.  If you like danger and using an older version of Ruby, you could add <code>#sum</code> to the <code>Array</code> class:</p>

<pre><code>class Array
  def sum
    inject(0) { |sum, x| sum + x }
  end
end
</code></pre>
<h4> Comment 67002914 user3467349: </h4>Monkeypatching base classes is not nice.<br><h4> Comment 73513342 Peter H. Boling: </h4>The point he is making is that you don&#39;t need to do the Monkey Patch for Ruby &gt;= 2.4, and that monkey patching is dangerous, and that you can now sum enumerables natively, but there is also a way to backport the functionality.<br><h4> Comment 87428137 Cary Swoveland: </h4>As noted, <a href="http://ruby-doc.org/core-2.4.0/Enumerable.html#method-i-sum" rel="nofollow noreferrer">Enumerable#sum</a> (and <a href="http://ruby-doc.org/core-2.4.0/Array.html#method-i-sum" rel="nofollow noreferrer">Array#sum</a>) were introduced in Ruby v2.4. Importantly, they do not have the same behavior as your <code>Array#sum</code>; namely, they take an optional argument and an optional block. Defining <code>Array#sum</code> as you have would result in an exception being raised wherever <code>sum</code> appeared in the code with an argument or block.<br><h4> Comment 117553374 Joshua Pinter: </h4>If you need to supply a default value for when the <code>Array</code> is empty, like if you want to return a <code>Money</code> object instead of an <code>Integer</code>, you can do something like <code>array.sum( 0.to_money( &quot;USD&quot; ) )</code>.<br>------------------------------------------------------------------ <br><h3> Answer 41455793 Eli Sadoff: </h3><h1>New for Ruby 2.4.0</h1>

<p>You can use the aptly named method <code>Enumerable#sum</code>. It has a lot of advantages over <code>inject(:+)</code> but there are some important notes to read at the end as well. </p>

<h2>Examples</h2>

<h3>Ranges</h3>

<pre><code>(1..100).sum
#=&gt; 5050
</code></pre>

<h3>Arrays</h3>

<pre><code>[1, 2, 4, 9, 2, 3].sum
#=&gt; 21

[1.9, 6.3, 20.3, 49.2].sum
#=&gt; 77.7
</code></pre>

<h2>Important note</h2>

<p>This method is not equivalent to <code>#inject(:+)</code>. For example </p>

<pre><code>%w(a b c).inject(:+)
#=&gt; "abc"
%w(a b c).sum
#=&gt; TypeError: String can't be coerced into Integer
</code></pre>

<p>Also,</p>

<pre><code>(1..1000000000).sum
#=&gt; 500000000500000000 (execution time: less than 1s)
(1..1000000000).inject(:+)
#=&gt; 500000000500000000 (execution time: upwards of a minute)
</code></pre>

<p>See <a href="https://stackoverflow.com/a/41449844/5021321">this answer</a> for more information on why <code>sum</code> is like this.</p>
<h4> Comment 135369265 Cadoiz: </h4>This answer is deprecated. In ruby2.6.6 for example, you <b>can</b> do <code>%w(a b c).sum # =&gt; &quot;abc&quot;</code><br><h4> Comment 136663042 Kelsey Hannan: </h4>Note that if you are doing math, an <code>Array</code> of <code>Float</code> or <code>BigDecimal</code> called by <code>.sum</code> will convert them back to <code>Integer</code>, breaking your math!  You need to call <code>foo.sum.to_f</code> to preserve the Float.<br><h4> Comment 117553386 Joshua Pinter: </h4>If you need to supply a default value for when the <code>Array</code> is empty, like if you want to return a <code>Money</code> object instead of an <code>Integer</code>, you can do something like <code>array.sum( 0.to_money( &quot;USD&quot; ) )</code>.<br>------------------------------------------------------------------ <br><h3> Answer 37720876 typo: </h3><p>Ruby 2.4+ / Rails - <code>array.sum</code> i.e. <code>[1, 2, 3].sum # =&gt; 6</code></p>

<p>Ruby pre 2.4 - <code>array.inject(:+)</code> or <code>array.reduce(:+)</code></p>

<p>*Note: The <code>#sum</code> method is a new addition to 2.4 for <code>enumerable</code> so you will now be able to use <code>array.sum</code> in pure ruby, not just Rails.</p>
------------------------------------------------------------------ <br><h3> Answer 17836792 HashFail: </h3><p>Just for the sake of diversity, you can also do this if your array is not an array of numbers, but rather an array of objects that have properties that are numbers (e.g. amount):</p>

<pre><code>array.inject(0){|sum,x| sum + x.amount}
</code></pre>
<h4> Comment 33245453 HashFail: </h4>In a way, yes. However, using <code>map</code> then <code>inject</code> requires you to loop through the array twice: once to create a new array, the other to sum the members. This method is slightly more verbose, but also more efficient.<br><h4> Comment 33209319 Richard Jones: </h4>This is equivalent to doing: <code>array.map(&amp;:amount).inject(0, :+)</code>. See other answers.<br><h4> Comment 135369392 Cadoiz: </h4>@RichardJones or just <code>array.sum(&amp;:amount)</code> as of today (using ruby &gt;= 2.4 or rails).<br><h4> Comment 100296297 rmcsharry: </h4>Apparently it is not more efficient, see <a href="https://gist.github.com/cameron-martin/b907ec43a9d8b9303bdc" rel="nofollow noreferrer">gist.github.com/cameron-martin/b907ec43a9d8b9303bdc</a> - credit to the comments in this answer: <a href="https://stackoverflow.com/a/1538949/1028679">stackoverflow.com/a/1538949/1028679</a><br>------------------------------------------------------------------ <br><h3> Answer 6442884 Vova: </h3><p>ruby 1.8.7 way is the following:</p>

<pre><code>array.inject(0, &amp;:+) 
</code></pre>
<h4> Comment 37465079 Andrew Grimm: </h4>If you read my 2011 comment, and it&#39;s still relevant as you&#39;re using 1.8.6, please upgrade!<br>------------------------------------------------------------------ <br><h3> Answer 41222471 Santhosh: </h3><p>Ruby 2.4.0 is released, and it has an <a href="http://ruby-doc.org/core-2.4.0/Enumerable.html#method-i-sum" rel="noreferrer">Enumerable#sum</a> method. So you can do</p>

<pre><code>array.sum
</code></pre>

<p>Examples from the docs:</p>

<pre><code>{ 1 =&gt; 10, 2 =&gt; 20 }.sum {|k, v| k * v }  #=&gt; 50
(1..10).sum                               #=&gt; 55
(1..10).sum {|v| v * 2 }                  #=&gt; 110
</code></pre>
------------------------------------------------------------------ <br><h3> Answer 4841853 grosser: </h3><p>Also allows for <code>[1,2].sum{|x| x * 2 } == 6</code>:</p>

<pre><code># http://madeofcode.com/posts/74-ruby-core-extension-array-sum
class Array
  def sum(method = nil, &amp;block)
    if block_given?
      raise ArgumentError, "You cannot pass a block and a method!" if method
      inject(0) { |sum, i| sum + yield(i) }
    elsif method
      inject(0) { |sum, i| sum + i.send(method) }
    else
      inject(0) { |sum, i| sum + i }
    end
  end
end
</code></pre>
------------------------------------------------------------------ <br><h3> Answer 50147045 thedudecodes: </h3><p>for array with nil values we can do compact and then inject the sum
ex-</p>

<pre><code>a = [1,2,3,4,5,12,23.45,nil,23,nil]
puts a.compact.inject(:+)
</code></pre>
------------------------------------------------------------------ <br><h3> Answer 48562114 raj_acharya: </h3><p><strong>Method 1:</strong></p>

<pre><code>    [1] pry(main)&gt; [1,2,3,4].sum
    =&gt; 10
    [2] pry(main)&gt; [].sum
    =&gt; 0
    [3] pry(main)&gt; [1,2,3,5,nil].sum
    TypeError: nil can't be coerced into Integer
</code></pre>

<p><strong>Method 2:</strong> </p>

<pre><code>   [24] pry(main)&gt; [].inject(:+)
   =&gt; nil
   [25] pry(main)&gt; [].inject(0, :+)
   =&gt; 0
   [4] pry(main)&gt; [1,2,3,4,5].inject(0, :+)
   =&gt; 15
   [5] pry(main)&gt; [1,2,3,4,nil].inject(0, :+)
   TypeError: nil can't be coerced into Integer
   from (pry):5:in `+'
</code></pre>

<p><strong>Method 3:</strong></p>

<pre><code>   [6] pry(main)&gt; [1,2,3].reduce(:+)
   =&gt; 6
   [9] pry(main)&gt; [].reduce(:+)
   =&gt; nil
   [7] pry(main)&gt; [1,2,nil].reduce(:+)
   TypeError: nil can't be coerced into Integer
   from (pry):7:in `+'
</code></pre>

<p><strong>Method 4:</strong>
       When Array contains an nil and empty values, by default if you use any above functions reduce, sum, inject everything will through the  </p>

<blockquote>
  <p>TypeError: nil can't be coerced into Integer</p>
</blockquote>

<p>You can overcome this by,</p>

<pre><code>   [16] pry(main)&gt; sum = 0 
   =&gt; 0
   [17] pry(main)&gt; [1,2,3,4,nil, ''].each{|a| sum+= a.to_i }
   =&gt; [1, 2, 3, 4, nil, ""]
   [18] pry(main)&gt; sum
   =&gt; 10
</code></pre>

<p><strong>Method 6:</strong>
      <strong>eval</strong></p>

<p>Evaluates the Ruby expression(s) in string.</p>

<pre><code>  [26] pry(main)&gt; a = [1,3,4,5]
  =&gt; [1, 3, 4, 5]
  [27] pry(main)&gt; eval a.join '+'
  =&gt; 13
  [30] pry(main)&gt; a = [1,3,4,5, nil]
  =&gt; [1, 3, 4, 5, nil]
  [31] pry(main)&gt; eval a.join '+'
  SyntaxError: (eval):1: syntax error, unexpected end-of-input
  1+3+4+5+
</code></pre>
<h4> Comment 135369365 Cadoiz: </h4><code>reduce</code> and <code>inject</code> are literally the same thing. If you really want to build an object by yourself, you should consider <a href="https://apidock.com/ruby/Enumerable/each_with_object" rel="nofollow noreferrer"><code>each_with_object</code></a> instead of <code>each</code> (Method 4). Suggestion: <code>[1,2,3,4,nil, &#39;&#39;].each_with_object(0) {|a| sum+= a.to_i }</code><br>------------------------------------------------------------------ <br><h3> Answer 40833501 Ulysse BN: </h3><p>If you feel golfy, you can do</p>
<pre><code>eval [123,321,12389]*?+
</code></pre>
<p>This will create a string &quot;123+321+12389&quot; and then use function eval to do the sum. This is <strong>only for golfing purpose</strong>, you should not use it in proper code.</p>
------------------------------------------------------------------ <br><h3> Answer 27445759 Prabhakar: </h3><p>You can also do it in easy way</p>

<pre><code>def sum(numbers)
  return 0 if numbers.length &lt; 1
  result = 0
  numbers.each { |num| result += num }
  result
end
</code></pre>
<h4> Comment 111729599 user229044: </h4>This is very non-idiomatic Ruby, it looks like Ruby written by a C programmer. In Ruby, <code>inject</code> or <code>sum</code> are preferred.<br>------------------------------------------------------------------ <br><h3> Answer 31597244 shabdar: </h3><p>You can use <em>.map</em> and <em>.sum</em> like:</p>

<pre><code>array.map { |e| e }.sum
</code></pre>
<h4> Comment 55910422 Arnold Roa: </h4>What is the point of do a map returning same element? this is exactly the same than <code>array.sum</code><br>