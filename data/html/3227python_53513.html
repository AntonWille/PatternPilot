 <h2> Title: How do I check if a list is empty? </h2> <h4> Ray, question_id: 53513 </h4>Score: 3227, Tags: {python,list} <br><p>For example, if passed the following:</p>

<pre><code>a = []
</code></pre>

<p>How do I check to see if <code>a</code> is empty?</p>
------------------------------------------------------------------ <br><h3> Vineet Jain, Id: 45898755, Score: 8: </h3><p>Simply use is_empty() or make function like:- </p>

<pre><code>def is_empty(any_structure):
    if any_structure:
        print('Structure is not empty.')
        return True
    else:
        print('Structure is empty.')
        return False  
</code></pre>

<p>It can be used for any data_structure like a list,tuples, dictionary and many more. By these, you can call it many times using just <code>is_empty(any_structure)</code>. </p>
<h4> Davis Herring, Comment 79587122 Score: 4: </h4>Why do we want a variation on <code>bool</code> that (also) prints messages to standard output?<br><h4> Davis Herring, Comment 79586681 Score: 3: </h4>The name <code>is_empty</code> suggests that it returns something.  But if it did, that something would just be <code>bool(any_structure)</code>, which you should use instead (<i>when</i> you need a <code>bool</code> at all).<br><h4> Vineet Jain, Comment 79587585 Score: 0: </h4>@DavisHerring We always  have two choice first is to print using function other is using return <code>bool</code> variable. Choice is yours. I write both so you can choose between them.<br>------------------------------------------------------------------ <br><h3> Russia Must Remove Putin, Id: 45778282, Score: 367: </h3><blockquote>
  <h2>Best way to check if a list is empty</h2>
  
  <p>For example, if passed the following:</p>

<pre><code>a = []
</code></pre>
  
  <p>How do I check to see if a is empty?</p>
</blockquote>

<h2>Short Answer:</h2>

<p>Place the list in a boolean context (for example, with an <code>if</code> or <code>while</code> statement). It will test <code>False</code> if it is empty, and <code>True</code> otherwise. For example:</p>

<pre><code>if not a:                           # do this!
    print('a is an empty list')
</code></pre>

<h2>PEP 8</h2>

<p><a href="https://www.python.org/dev/peps/pep-0008/#programming-recommendations" rel="noreferrer">PEP 8</a>, the official Python style guide for Python code in Python's standard library, asserts:</p>

<blockquote>
  <p>For sequences, (strings, lists, tuples), use the fact that empty sequences are false.</p>

<pre><code>Yes: if not seq:
     if seq:

No: if len(seq):
    if not len(seq):
</code></pre>
</blockquote>

<p>We should expect that standard library code should be as performant and correct as possible. But why is that the case, and why do we need this guidance?</p>

<h2>Explanation</h2>

<p>I frequently see code like this from experienced programmers new to Python:</p>

<pre><code>if len(a) == 0:                     # Don't do this!
    print('a is an empty list')
</code></pre>

<p>And users of lazy languages may be tempted to do this:</p>

<pre><code>if a == []:                         # Don't do this!
    print('a is an empty list')
</code></pre>

<p>These are correct in their respective other languages. And this is even semantically correct in Python. </p>

<p>But we consider it un-Pythonic because Python supports these semantics directly in the list object's interface via boolean coercion.</p>

<p>From the <a href="https://docs.python.org/3/library/stdtypes.html#truth-value-testing" rel="noreferrer">docs</a> (and note specifically the inclusion of the empty list, <code>[]</code>):</p>

<blockquote>
  <p>By default, an object is considered true unless its class defines
  either a <code>__bool__()</code> method that returns <code>False</code> or a <code>__len__()</code> method
  that returns zero, when called with the object. Here are most of the built-in objects considered false:</p>
  
  <ul>
  <li>constants defined to be false: <code>None</code> and <code>False</code>.</li>
  <li>zero of any numeric type: <code>0</code>, <code>0.0</code>, <code>0j</code>, <code>Decimal(0)</code>, <code>Fraction(0, 1)</code></li>
  <li>empty sequences and collections: <code>''</code>, <code>()</code>, <code>[]</code>, <code>{}</code>, <code>set()</code>, <code>range(0)</code></li>
  </ul>
</blockquote>

<p>And the datamodel documentation:</p>

<blockquote>
  <p><a href="https://docs.python.org/3/reference/datamodel.html#object.__bool__" rel="noreferrer"><code>object.__bool__(self)</code></a></p>
  
  <p>Called to implement truth value testing and the built-in operation <code>bool()</code>; should return <code>False</code> or <code>True</code>. When this method is not defined,
  <code>__len__()</code> is called, if it is defined, and the object is considered true if its result is nonzero. If a class defines neither <code>__len__()</code>
  nor <code>__bool__()</code>, all its instances are considered true.</p>
</blockquote>

<p>and </p>

<blockquote>
  <p><a href="https://docs.python.org/3/reference/datamodel.html#object.__len__" rel="noreferrer"><code>object.__len__(self)</code></a></p>
  
  <p>Called to implement the built-in function <code>len()</code>. Should return the length of the object, an integer >= 0. Also, an object that doesn’t define a <code>__bool__()</code> method and whose <code>__len__()</code> method returns zero is considered to be false in a Boolean context.</p>
</blockquote>

<p>So instead of this:</p>

<pre><code>if len(a) == 0:                     # Don't do this!
    print('a is an empty list')
</code></pre>

<p>or this:</p>

<pre><code>if a == []:                     # Don't do this!
    print('a is an empty list')
</code></pre>

<p>Do this:</p>

<pre><code>if not a:
    print('a is an empty list')
</code></pre>

<h2>Doing what's Pythonic usually pays off in performance:</h2>

<p>Does it pay off? (Note that less time to perform an equivalent operation is better:)</p>

<pre><code>&gt;&gt;&gt; import timeit
&gt;&gt;&gt; min(timeit.repeat(lambda: len([]) == 0, repeat=100))
0.13775854044661884
&gt;&gt;&gt; min(timeit.repeat(lambda: [] == [], repeat=100))
0.0984637276455409
&gt;&gt;&gt; min(timeit.repeat(lambda: not [], repeat=100))
0.07878462291455435
</code></pre>

<p>For scale, here's the cost of calling the function and constructing and returning an empty list, which you might subtract from the costs of the emptiness checks used above:</p>

<pre><code>&gt;&gt;&gt; min(timeit.repeat(lambda: [], repeat=100))
0.07074015751817342
</code></pre>

<p>We see that <em>either</em> checking for length with the builtin function <code>len</code> compared to <code>0</code> <em>or</em> checking against an empty list is <strong>much</strong> less performant than using the builtin syntax of the language as documented.</p>

<p>Why?</p>

<p>For the <code>len(a) == 0</code> check:</p>

<p>First Python has to check the globals to see if <code>len</code> is shadowed. </p>

<p>Then it must call the function, load <code>0</code>, and do the equality comparison in Python (instead of with C):</p>

<pre><code>&gt;&gt;&gt; import dis
&gt;&gt;&gt; dis.dis(lambda: len([]) == 0)
  1           0 LOAD_GLOBAL              0 (len)
              2 BUILD_LIST               0
              4 CALL_FUNCTION            1
              6 LOAD_CONST               1 (0)
              8 COMPARE_OP               2 (==)
             10 RETURN_VALUE
</code></pre>

<p>And for the <code>[] == []</code> it has to build an unnecessary list and then, again, do the comparison operation in Python's virtual machine (as opposed to C)</p>

<pre><code>&gt;&gt;&gt; dis.dis(lambda: [] == [])
  1           0 BUILD_LIST               0
              2 BUILD_LIST               0
              4 COMPARE_OP               2 (==)
              6 RETURN_VALUE
</code></pre>

<p>The "Pythonic" way is a much simpler and faster check since the length of the list is cached in the object instance header:</p>

<pre><code>&gt;&gt;&gt; dis.dis(lambda: not [])
  1           0 BUILD_LIST               0
              2 UNARY_NOT
              4 RETURN_VALUE
</code></pre>

<h2>Evidence from the C source and documentation</h2>

<blockquote>
  <p><a href="https://docs.python.org/2/c-api/structures.html#c.PyVarObject" rel="noreferrer"><code>PyVarObject</code></a></p>
  
  <p>This is an extension of <code>PyObject</code> that adds the <code>ob_size</code> field. This is only used for objects that have some notion of length. This type does not often appear in the Python/C API. It corresponds to the fields defined by the expansion of the <code>PyObject_VAR_HEAD</code> macro.</p>
</blockquote>

<p>From the c source in <a href="https://github.com/python/cpython/blob/master/Include/listobject.h" rel="noreferrer">Include/listobject.h</a>:</p>

<pre><code>typedef struct {
    PyObject_VAR_HEAD
    /* Vector of pointers to list elements.  list[0] is ob_item[0], etc. */
    PyObject **ob_item;

    /* ob_item contains space for 'allocated' elements.  The number
     * currently in use is ob_size.
     * Invariants:
     *     0 &lt;= ob_size &lt;= allocated
     *     len(list) == ob_size
</code></pre>

<h2>Response to comments:</h2>

<blockquote>
  <p>I would point out that this is also true for the non-empty case though its pretty ugly as with <code>l=[]</code> then <code>%timeit len(l) != 0</code> 90.6 ns ± 8.3 ns, <code>%timeit l != []</code> 55.6 ns ± 3.09, <code>%timeit not not l</code> 38.5 ns ± 0.372. But there is no way anyone is going to enjoy <code>not not l</code> despite triple the speed. It looks ridiculous. But the speed wins out<br>
  I suppose the problem is testing with timeit since just <code>if l:</code> is sufficient but surprisingly <code>%timeit bool(l)</code> yields 101 ns ± 2.64 ns. Interesting there is no way to coerce to bool without this penalty. <code>%timeit l</code> is useless since no conversion would occur.</p>
</blockquote>

<p>IPython magic, <code>%timeit</code>, is not entirely useless here:</p>

<pre><code>In [1]: l = []                                                                  

In [2]: %timeit l                                                               
20 ns ± 0.155 ns per loop (mean ± std. dev. of 7 runs, 100000000 loops each)

In [3]: %timeit not l                                                           
24.4 ns ± 1.58 ns per loop (mean ± std. dev. of 7 runs, 10000000 loops each)

In [4]: %timeit not not l                                                       
30.1 ns ± 2.16 ns per loop (mean ± std. dev. of 7 runs, 10000000 loops each)
</code></pre>

<p>We can see there's a bit of linear cost for each additional <code>not</code> here. We want to see the costs, <em>ceteris paribus</em>, that is, all else equal - where all else is minimized as far as possible:</p>

<pre class="lang-py prettyprint-override"><code>In [5]: %timeit if l: pass                                                      
22.6 ns ± 0.963 ns per loop (mean ± std. dev. of 7 runs, 10000000 loops each)

In [6]: %timeit if not l: pass                                                  
24.4 ns ± 0.796 ns per loop (mean ± std. dev. of 7 runs, 10000000 loops each)

In [7]: %timeit if not not l: pass                                              
23.4 ns ± 0.793 ns per loop (mean ± std. dev. of 7 runs, 10000000 loops each)
</code></pre>

<p>Now let's look at the case for an unempty list:</p>

<pre class="lang-py prettyprint-override"><code>In [8]: l = [1]                                                                 

In [9]: %timeit if l: pass                                                      
23.7 ns ± 1.06 ns per loop (mean ± std. dev. of 7 runs, 10000000 loops each)

In [10]: %timeit if not l: pass                                                 
23.6 ns ± 1.64 ns per loop (mean ± std. dev. of 7 runs, 10000000 loops each)

In [11]: %timeit if not not l: pass                                             
26.3 ns ± 1 ns per loop (mean ± std. dev. of 7 runs, 10000000 loops each)
</code></pre>

<p>What we can see here is that it makes little difference whether you pass in an actual <code>bool</code> to the condition check or the list itself, and if anything, giving the list, as is, is faster.</p>

<p>Python is written in C; it uses its logic at the C level. Anything you write in Python will be slower. And it will likely be orders of magnitude slower unless you're using the mechanisms built into Python directly.</p>
<h4> ClementWalter, Comment 114705322 Score: 10: </h4>Best answer so far, thanks! Pointing out the true logic of python with magicmethods and &quot;Python is written in C; it uses its logic at the C level. Anything you write in Python will be slower. And it will likely be orders of magnitude slower&quot; is key. otherwise one falls down into &quot;preferences&quot; and never ends up with a proper conclusion.<br><h4> Ice Bear, Comment 115572066 Score: 2: </h4>Great! This is the best answer! To anyone reading from 2020(it&#39;s December so it&#39;s almost 2021) and in the future. Doing <code>if l</code> is the &quot;Pythonic&quot; way and BEST way, as this guy explains it very well and also provided some sample code of the time performance calculated for every suggested answer which are   <code>if len(a) == 0</code>, <code>if [] == []</code>  and  <code>if a</code> So clearly this (<code>if a</code>) is much faster &amp; the one that must be practiced!<br><h4> Gregory Morse, Comment 104401412 Score: 1: </h4>I would point out that this is also true for the non-empty case though its pretty ugly as with <code>l=[]</code> then <code>%timeit len(l) != 0</code> 90.6 ns &#177; 8.3 ns, <code>%timeit l != []</code> 55.6 ns &#177; 3.09, <code>%timeit not not l</code> 38.5 ns &#177; 0.372.  But there is no way anyone is going to enjoy <code>not not l</code> despite triple the speed.  It looks ridiculous.  But the speed wins out<br><h4> Gregory Morse, Comment 104402158 Score: 1: </h4>I suppose the problem is testing with timeit since just <code>if l:</code> is sufficient but surprisingly <code>%timeit bool(l)</code> yields 101 ns &#177; 2.64 ns.  Interesting there is no way to coerce to bool without this penalty.  <code>%timeit l</code> is useless since no conversion would occur.<br><h4> 12431234123412341234123, Comment 122427579 Score: 0: </h4>You still don&#39;t explain why you should use <code>if ls</code> over <code>if len(ls)</code>. In 99%, i don&#39;t care about this small performance difference and prefer readability. <code>if len(ls)</code> is easier to read, more explicit and it trows an error when something is used that isn&#39;t some kind of list, this is why <code>if len(ls)</code> makes more sense. By the way i only get a about 15% performance difference between <code>not len([])</code> and <code>not []</code>.<br><h4> Russia Must Remove Putin, Comment 122435509 Score: 0: </h4>The idea is to use <code>if len(my_list) ...</code> because it fails when <code>my_list</code> isn&#39;t an object that supports <code>__len__</code>, to aid with troubleshooting typing issues? I suggest, instead, use a static type analysis engine like mypy.<br><h4> PieterNuyts, Comment 129459912 Score: 0: </h4>I get that it&#39;s more efficient (thanks for clearly explaining that), but imho it&#39;s less robust.  If something went wrong and <code>a</code> was e.g. <code>False</code> or 0, your code would wrongly say it was an empty list, and continue silently with that assumption (probably failing at some later and hard-to-debug point).  <code>if len(a) == 0</code> would just fail with an error that pointed directly at where the problem was.  Programming is often a tradeoff between efficiency and robustness, and sometimes choosing for efficiency is the right choice.  But I wouldn&#39;t plainly state that <code>if not a</code> is <i>always</i> the best option.<br>------------------------------------------------------------------ <br><h3> Patrick, Id: 53522, Score: 7115: </h3><pre><code>if not a:
    print(&quot;List is empty&quot;)
</code></pre>
<p>Using the <a href="https://docs.python.org/library/stdtypes.html#truth-value-testing" rel="noreferrer">implicit booleanness</a> of the empty <code>list</code> is quite Pythonic.</p>
<h4> Mr.WorshipMe, Comment 97265985 Score: 124: </h4>This method doesn&#39;t work on numpy arrays.. so I think if len(a) == 0 is preferable both in terms of &quot;duck typing&quot; and implicitness.<br><h4> James McMahon, Comment 10110919 Score: 1533: </h4>Playing devil&#39;s advocate. I don&#39;t understand why this idiom is considered pythonic. &#39;Explicit is better then implicit&#39;, correct? This check doesn&#39;t seem very explicit about what is is checking.<br><h4> andrew cooke, Comment 14108516 Score: 283: </h4>@JamesMcMahon - it&#39;s a trade-off between explicitness and type flexibility.  generally, &quot;being explicit&quot; means not doing &quot;magical&quot; things.  on the other hand, &quot;duck typing&quot; means working with more general interfaces, rather than explicitly checking for types.  so something like <code>if a == []</code> is forcing a particular type (<code>() == []</code> is <code>False</code>).  here, general consensus seems to be that duck typing wins out (in effect, saying that <code>__nonzero__</code> is the interface for testing emptiness <a href="http://docs.python.org/reference/datamodel.html#object.__nonzero__" rel="nofollow noreferrer">docs.python.org/reference/datamodel.html#object.__nonzero__</a>)<br><h4> Edwin Rodr&#237;guez, Comment 107969415 Score: 107: </h4>Coming from a language that claims to be some sort of poetry, this mechanism is pure garbage. Semantically, being empty is very different to not being<br><h4> Brennen Sprimont, Comment 98030070 Score: 13: </h4>@sleblanc I&#39;ve never seen a null terminated array in c outside of implementing a string, the common case is not to null terminate. &quot;comparing its length to zero is utterly inefficient&quot; is incorrect, there is no c implementation in existence where this would cost more than a couple cycles. Comparing the length of an array to 0 to determine emptiness is standard practice in c and almost all c influenced languages (c++, java, c#, etc).<br><h4> sleblanc, Comment 98039455 Score: 7: </h4>@BrennenSprimont, If it&#39;s not null-terminated, then you already know the length, whether it is stored in a separate variable or your array is wrapped in some container that tracks the length. C++, Java, C# have such containers and implement some &quot;length&quot; method efficiently. C has <i>no such thing</i>, you have to roll your own. Statically allocated C arrays are just pointers to a memory space that is guaranteed to have enough space to store the amount of data you have requested. There is nothing built into C that will let you know how much you have filled that space already.<br><h4> David Moreau, Comment 117556826 Score: 4: </h4>I find it interesting that the question asks about checking if an empty list was passed and many are adamant that the solution needs to not differentiate between an empty list being passed and None being passed. Or 0 being passed. Without knowing what other possible values could be passed and whether they each represent a different case that needs to be handled, we can&#39;t assume that a broader test is appropriate.<br><h4> yuvalm2, Comment 112347800 Score: 3: </h4>That is implicit, and therefore unpythonic, as &quot;explicit is better than implicit&quot;.<br><h4> Theo, Comment 107462853 Score: 2: </h4>When using Numpy and according to its documentation, you should use:array.size &gt; 0 Else you would have the following message. <code>DeprecationWarning: The truth value of an empty array is ambiguous. Returning False, but in future this will result in an error. Use array.size &gt; 0 to check that an array is not empty.</code><br><h4> Albert Chen, Comment 118097180 Score: 2: </h4>Mr.WorshipMe is right. This method is not totally correct. [0] is not empty, but np.array([0]) is empty. [1] is not empty, np.array([1]) is not empty. weird.<br><h4> user2357112, Comment 109561328 Score: 2: </h4>@Mr.WorshipMe: <code>if len(a) == 0</code> doesn&#39;t work for NumPy arrays either, because it fails for shapes like <code>(5, 0)</code>. A 5-by-0 array is empty, but has length 5. The check for a NumPy array would be <code>a.size == 0</code> (or <code>not a.size</code>), which doesn&#39;t work for a list.<br><h4> dzieciou, Comment 109835224 Score: 2: </h4>It will print that <code>a</code> is empty for  <code>a = None</code> considered empty, because <code>not bool(None) == True</code>.<br><h4> user8331407, Comment 119086717 Score: 1: </h4>This example with a list <code>myList = [1, 2, 4, 4, 1, 4, 2, 6, 2, 9] for element in myList:        if element not in newList:              newList.append(element) print(&quot;The list with unique elements only:&quot;) print(myList) print(newList) </code><br><h4> MrWonderful, Comment 113823601 Score: 1: </h4>@ThunderPhoenix - One could also just use &#39;if len(a):&#39; since a value &gt;zero will evaluate to True... ;-)<br><h4> Mark Ransom, Comment 125607256 Score: 0: </h4>@sleblanc he&#39;s right.  In Python everything is an object, and the standard sequence objects (list, tuple, string, etc.) keep track of their length so they don&#39;t need to count like C&#39;s <code>strlen</code> does.<br><h4> George V. Reilly, Comment 123387508 Score: 0: </h4>@sleblanc, <code>len</code> is not <code>strlen</code>. <code>len</code>  is a constant-time operation in Python. It stores the length of a sequence; it does not have to compute the length. <a href="https://wiki.python.org/moin/TimeComplexity" rel="nofollow noreferrer">wiki.python.org/moin/TimeComplexity</a><br><h4> Mark Ransom, Comment 125607135 Score: 0: </h4>@EdwinRodr&#237;guez in Python there&#39;s a distinct difference between not existing and empty, but most of the time your code doesn&#39;t care.  If it does you can use <code>if a is None</code>.<br><h4> Ash Singh, Comment 112677517 Score: 0: </h4><code>if bool([]) #False</code>  <code>if bool([1,2,3]) #True</code> Just using <code>bool(list_name)</code> is the easiest way I feel.<br><h4> Mark Ransom, Comment 125640779 Score: 0: </h4>@sleblanc no need to be insulting.  The question is about Python, and a Python list is exactly what I said it was and has no similarity to a linked list in C; it&#39;s more like a dynamically allocated array with an extra variable to track the length.  You&#39;re right that getting the length of a linked list in C would be wildly inefficient, especially when all you need to do to see if the list is empty is look to see if the head pointer is null.  Perhaps it&#39;s best that the other comment was deleted.<br><h4> Mark Ransom, Comment 125665960 Score: 0: </h4>@sleblanc you&#39;re the one making assumptions - you assume I saw the parts of a conversation that were deleted.  Given the context of the comments right now, I don&#39;t think what I said was out of line.  I stand by the truth of it.<br><h4> Ice Bear, Comment 115571423 Score: 0: </h4>It&#39;s great that someone brought up that this is not applicable for a numpy array, but let&#39;s focus on the question <code>How do I check if a list is empty?</code>. We just want to check if the list is empty or not. I think this answer is good &amp; pretty much pythonic and I completely agree with sleblanc.<br><h4> Ice Bear, Comment 115571527 Score: 0: </h4>Thinking of it python has already had our backs it gives us already the truth value of  sequences like , strings, lists,tuples as stated answer below. So we can just use it <code>DIRECTLY</code> and don&#39;t have to get the <code>len()</code> of it to check if it&#39;s <code>EMPTY</code><br><h4> Timo, Comment 116625000 Score: 0: </h4>@andrewcooke I conclude that here duck type is used because it is general and does not check for a type.<br><h4> DaHoC, Comment 120099688 Score: 0: </h4>In case you want a boolean variable, you can use something like: <code>is_list_element_present: bool = bool(my_list)  # Empty lists are &quot;falsy&quot;</code><br><h4> ThunderPhoenix, Comment 108241611 Score: 0: </h4>We can use <code>if(len(a) == 0):</code> too<br><h4> Inherited Geek, Comment 101736787 Score: 0: </h4>Another similar way:   <code>print (bool(not a)) </code><br><h4> Mr Matrix, Comment 104400375 Score: 0: </h4>If you are using this on a custom object i.e. &quot;if not customObject&quot; then make sure you implement the <a href="https://docs.python.org/3/reference/datamodel.html#object.__len__" rel="nofollow noreferrer">len</a> method in your custom object class definition else it will evaluate to False even on an empty object.<br><h4> michael_teter, Comment 126823879 Score: 0: </h4>This is a bad design (the language and the example) because it conflates an empty structure with a non-existent structure.  The two are not the same.  As a silly analogy, a person holding an empty plate has no food, but has an empty plate.  A person holding nothing has no food, but does not have an empty plate.<br><h4> Azhar Uddin Sheikh, Comment 126841167 Score: 0: </h4>It&#39;s done by concept of `truthy-falsy&#39; values<br><h4> jeroent, Comment 134409879 Score: 0: </h4>The tricky thing here is that it suggests you are dealing with a boolean here. It suggests that the inverse test <code>if a: print(&quot;non-empty&quot;)</code> is also dealing with a boolean. So far, it works. But be careful when using boolean operators: <code>False and [3,4]</code> gives False whereas <code>True and [3,4]</code> gives [3,4]<br><h4> tsturzl, Comment 136635043 Score: 0: </h4>@sleblanc in C sizeof is usually a compile time operation, it certainly is not O(n) runtime. C will only know type and therefore size at compile time, arrays in C are static. So telling the size of an array should have very little runtime overhead and run in constant time. So I&#39;m not really sure why you&#39;d deref the head of the array like that, especially since in a given circumstance null could be a totally valid value unless you&#39;re explicitly null terminating the array. If you&#39;re creating a dynamic array you&#39;ve already screwed up if you aren&#39;t tracking the size in another variable.<br><h4> tsturzl, Comment 136674934 Score: 0: </h4>@sleblanc I also cannot help but feel like what you&#39;re saying is completely off topic. You suddenly bring up how to check in a null terminated array is empty in C. I don&#39;t know where the idea that in C you somehow have to iterate the entire array to find it&#39;s length comes from. If you fail to terminate or fail to track the size, you&#39;re cooked anyways. If you null terminate sure maybe you count to null, that&#39;s your design choice. You can&#39;t find the end, you will just run past the end of the array. This is in regards to your comment to MarkRansom where you were being incredibly arrogant.<br><h4> sleblanc, Comment 136792419 Score: 0: </h4>@tsturzl, what are you on about?<br><h4> tsturzl, Comment 136843733 Score: 0: </h4>@sleblanc what are you on about? How were any of your comments relevant or constructive?<br><h4> sleblanc, Comment 136858787 Score: 0: </h4>@tsturzl, are you on a crusade? Those comments were posted years ago, and half of the conversation has been purged. The person deleted their account perhaps? Anyhow, this is irrelevant.<br>------------------------------------------------------------------ <br><h3> Harley Holcombe, Id: 53752, Score: 1496: </h3><p>The Pythonic way to do it is from the <a href="https://www.python.org/dev/peps/pep-0008" rel="noreferrer">PEP 8 style guide</a>.</p>
<blockquote>
<p>For sequences, (strings, lists, tuples), use the fact that empty sequences are false:</p>
<pre class="lang-python prettyprint-override"><code># Correct:
if not seq:
if seq:

# Wrong:
if len(seq):
if not len(seq):
</code></pre>
</blockquote>
<h4> BallpointBen, Comment 87575673 Score: 127: </h4>The second way seems better if you wish to signal that <code>seq</code> is expected to be some sort of list-like object.<br><h4> axolotl, Comment 89646190 Score: 21: </h4>@BallpointBen which, Pythonism advocates would say, should be implicit in the way the variable is named, as much as possible<br><h4> Mr.WorshipMe, Comment 97266044 Score: 20: </h4>numpy broke this idiom... seq = numpy.array([1,2,3]) followed by if not seq raises an exception &quot;ValueError: The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()&quot;<br><h4> aafulei, Comment 102607780 Score: 19: </h4>Despite all Pythonic advocates, I am with @BallpointBen in that if you mistakenly wrote <code>seq = [0]</code> as <code>seq = 0</code>, <code>len(seq)</code> will help you catch the error. To err is human. So is a programmer.<br><h4> user3064538, Comment 94930642 Score: 14: </h4>@BallpointBen try using Python&#39;s <a href="https://docs.python.org/3/library/typing.html" rel="nofollow noreferrer">type hinting</a> for signaling what a variable should be. It was introduced in 3.5.<br><h4> Harley Holcombe, Comment 103378238 Score: 2: </h4>@jeronimo: I believe that is an lxml-specific warning.<br><h4> Vulwsztyn, Comment 130368677 Score: 1: </h4>I&#39;m getting <code>The truth value of an array with more than one element is ambiguous</code> while using <code>if seq</code><br><h4> ShadowRanger, Comment 131405746 Score: 1: </h4>@Mr.WorshipMe: <code>numpy</code> breaks all kinds of rules that built-in Python types obey. Python&#39;s general rule is that collections are falsy if empty, true otherwise, numeric types are falsy if <code>0</code>, true otherwise, <code>None</code> is falsy, and everything else is true. Saying &quot;The idiom is bad because third-party libraries broke the rules&quot; is going to break <i>every</i> idiom. If your code isn&#39;t intended to work with <code>numpy</code> arrays, just built-in collections, this is the correct way to do it. The only completely correct <code>numpy</code> solutions (<code>if not array.size:</code>) won&#39;t work on any built-in anyway.<br><h4> mouselabs, Comment 110735364 Score: 1: </h4>@aafulei Polluting the source code with signals to help the programmer avoid coding errors is a fool&#39;s errand. Inelegantly imposing this misplaced concern on the source code results in code that is harder to read and follow, which over the life of the code leads to the introduction of more bugs, not fewer. Tests exist to address  the concern of (continuously) ensuring correctness and to keep that concern separated from any others. I am a Python newbie btw, there is nothing Pythonic about these statements, they reflect basic SRP principles that can and should be expressed in any given language.<br><h4> not-just-yeti, Comment 127078140 Score: 1: </h4>@Mr.WorshipMe I agree that numpy breaks the paradigm, so boolean-ness is a bad habit to use, since it doesn&#39;t extend to all iterables.  BUT others shouldn&#39;t think that the error-message you cite gives the general solution for sequences, since <code>any( [0,False,&quot;&quot;,[]] )</code> returns <code>False</code> even though there are four items in the list.<br><h4> jeronimo, Comment 103334803 Score: 1: </h4>I just got this message in using Python 3.6.4: &quot;FutureWarning: The behavior of this method will change in future versions. Use specific &#39;len(elem)&#39; or &#39;elem is not None&#39; test instead.&quot; so I guess this clearly defines the preference<br>------------------------------------------------------------------ <br><h3> Jabba, Id: 7302987, Score: 1099: </h3><p>I prefer it explicitly:</p>

<pre><code>if len(li) == 0:
    print('the list is empty')
</code></pre>

<p>This way it's 100% clear that <code>li</code> is a sequence (list) and we want to test its size. My problem with <code>if not li: ...</code> is that it gives the false impression that <code>li</code> is a boolean variable.</p>
<h4> Carl Smith, Comment 25526905 Score: 135: </h4>Checking if the length of a list is equal to zero, rather than just checking if the list is false, is ugly and unpythonic. Anyone familiar with Python will not think <code>li</code> is a bool at all, and wont care. If it&#39;s important, you should add a comment, not more code.<br><h4> abarnert, Comment 42997508 Score: 48: </h4>Anyway, the reason this is bad (and that violating idioms in a language with strong idioms like Python is bad in general) is that it signals to the reader that you&#39;re specifically checking the length for some reason (e.g., because you want <code>None</code> or <code>0</code> to raise an exception rather than passing). So, when you do it for no reason, that&#39;s misleading—and it also means that when your code <i>does</i> need to make the distinction, the distinction is invisible because you&#39;ve &quot;cried wolf&quot; all over the rest of the source.<br><h4> augurar, Comment 43983143 Score: 33: </h4>I think this is just needlessly lengthening the code.  Otherwise, why not be even more &quot;explicit&quot; with <code>if bool(len(li) == 0) is True:</code>?<br><h4> John B, Comment 37683654 Score: 33: </h4>This seems like an unnecessarily precise test, which is often slower and is always less readable IMHO.  Instead of checking the size of something empty, why not just check if it&#39;s empty?<br><h4> ralokt, Comment 55374771 Score: 17: </h4>@Jabba it will be <b>O(1)</b> in many cases (those where you work with the built-in data types), but you just can&#39;t rely on that. You might be working with a custom data type that doesn&#39;t have this property. You might also decide to add this custom data type later, after you already wrote this code.<br><h4> Shiania White, Comment 111770978 Score: 14: </h4>@augurar: Addressing the idea that this is just making it needlessly more explicit, it&#39;s worth noting that <code>if bool(len(li) == 0) is True</code> does exactly the same thing as <code>if len(li) == 0</code>, and so there is no value in adding that additional code. However, <code>if len(li) == 0</code> certainly does do something different than <code>if li</code>. I think it&#39;s reasonable to argue that people should not code things in such a way that the latter comparison produces different results. However, the latter comparison <b>can</b> produce different results, where the former <b>cannot</b>, so I don&#39;t think this is a good argument.<br><h4> Jabba, Comment 115594384 Score: 11: </h4>@StackOffended The time complexity of <code>len</code> on list is O(1) and not O(n) as you might think. See <a href="https://stackoverflow.com/questions/1115313/cost-of-len-function">here</a> for more info.<br><h4> BallpointBen, Comment 87575650 Score: 11: </h4>What if you <i>do</i> want to raise an exception for types without a <code>__len__</code>? This is perfect in that case.<br><h4> jamylak, Comment 84684822 Score: 10: </h4>This is anti PEP 8<br><h4> yo&#39;, Comment 70258589 Score: 9: </h4>It is very bad to grab the length only to check for emptiness. This is not good in any way.<br><h4> Johan, Comment 88741184 Score: 6: </h4>If it is unclear <code>li</code> is a list, maybe you shouldn&#39;t have named it <code>li</code>. I think there are very few good variable names with only 2 letters. What about <code>cars</code> or <code>evasive_manoeuvres</code>? Booleans on the other hand should have an <code>is</code> or <code>has</code> or other verb in the name, compare <code>if is_evasive_manoeuvre:</code> and <code>if evasive_maoeuvres</code>. It is clear to me which is a bool and which is a collection.<br><h4> Shiania White, Comment 111770843 Score: 6: </h4>In my opinion, <code>not X</code> resolves to <code>True</code> for too many possible cases of <code>X</code>. Most notably, both the empty list and <code>None</code>. While a case where the value is either the empty list or <code>None</code> probably <b>should</b> not occur, I&#39;m not confident that it <b>will</b> not occur. Especially when other people use parts of my code. Even though it&#39;s anti-PEP 8, I still prefer this approach.<br><h4> Jabba, Comment 115647548 Score: 5: </h4>@IceBear Use whichever you want. After 8 years I still prefer <code>len(a)</code>.<br><h4> mcp, Comment 134041396 Score: 5: </h4>Everybody here is out of line. This is clean, explicit, readable code. The minor addition of code lends clarity.<br><h4> Benjamin Crawford Ctrl-Alt-Tut, Comment 117673123 Score: 4: </h4>As a developer who&#39;s come from C/C++, this especially hurts my brain and at first I found the first comment in this thread to be absurd. &quot;Checking if the list is false&quot;??? What&#39;s that all about. How is that at all clear to the programmer? I would expect something like <code>not None</code> to return <code>True</code> - that makes sense. But a list object? It has a type! It&#39;s not nothing. It&#39;s just a property of Python that (almost) all built-in types offer a pleasant boolean evaluation which makes sense in the context of the type and that needs to be respected to be a successful Pythonista.<br><h4> dzieciou, Comment 109835454 Score: 4: </h4>At least it won&#39;t say  that <code>a</code> is empty for <code>a == None</code>, while <code>not a</code> would evaluate to <code>True</code> for <code>a == None</code>.<br><h4> 12431234123412341234123, Comment 122427382 Score: 1: </h4>@abarnert It SHOULD generate a error when you pass <code>None</code>, <code>False</code>, <code>0</code> or any other type that isn&#39;t some kind of list.<br><h4> Ice Bear, Comment 115599288 Score: 1: </h4>oh that&#39;s great! that supports your argument, but I guess after 8 years of this topic doing <code>if a</code> would still be recommended &amp; pythonic.<br><h4> 12431234123412341234123, Comment 122427262 Score: 0: </h4>I would argue that <code>if not len(ls)</code> is probably better. But <code>if len(li) == 0:</code> is definitely better (more explicit, easier to read and it raises an error when using the wrong type) than <code>if not ls</code>. PEP 8 is anti-pythonic in this regard.<br><h4> Hedwin Bonnavaud, Comment 123890784 Score: 0: </h4>if empty(list): looks like a good trade of between simplicity and explicity to me<br><h4> Ali Hassan, Comment 126216111 Score: 0: </h4>list_a=[1,2] if not(len(list_a)&gt;0):     print(&quot;List is empty&quot;) else:      print(&quot;List not is empty&quot;)<br><h4> Armstrongest, Comment 99585109 Score: 0: </h4>It&#39;s like showing your friend a container full of 0 oranges. It&#39;s not a container of oranges... and if it doesn&#39;t <code>contain</code> anything... then it could be argued to be a container at all. It only becomes a container containing contents once contents are contained. (x_x)<br><h4> Ice Bear, Comment 115571922 Score: 0: </h4>@ShianiaWhite incorrect, this is a terrible way to check if a <code>len</code> of a list is empty or not. There is no need to calculate for <code>len</code> of a sequence to check its emptiness, python has already have our backs, it easily gives as the truth value of a sequence.. so doing <code>if l</code> is pretty much the best thing. Imagine almost a million size of a sequence, would we want to still waste our lives to get the <code>len</code>? Patrick&#39;s answer is the best one.<br>------------------------------------------------------------------ <br><h3> Mike, Id: 9381545, Score: 423: </h3><p><sub>This is the first google hit for &quot;python test empty array&quot; and similar queries, and other people are generalizing the question beyond just lists, so here's a caveat for a different type of sequence that a lot of people use.</sub></p>
<h1>Other methods don't work for NumPy arrays</h1>
<p>You need to be careful with NumPy arrays, because other methods that work fine for <code>list</code>s or other standard containers fail for NumPy arrays.  I explain why below, but in short, the <a href="http://www.scipy.org/scipylib/faq.html#what-is-the-preferred-way-to-check-for-an-empty-zero-element-array" rel="noreferrer">preferred method</a> is to use <code>size</code>.</p>
<h2>The &quot;pythonic&quot; way doesn't work: Part 1</h2>
<p>The &quot;pythonic&quot; way fails with NumPy arrays because NumPy tries to cast the array to an array of <code>bool</code>s, and <code>if x</code> tries to evaluate all of those <code>bool</code>s at once for some kind of aggregate truth value.  But this doesn't make any sense, so you get a <code>ValueError</code>:</p>
<pre><code>&gt;&gt;&gt; x = numpy.array([0,1])
&gt;&gt;&gt; if x: print(&quot;x&quot;)
ValueError: The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()
</code></pre>
<h2>The &quot;pythonic&quot; way doesn't work: Part 2</h2>
<p>But at least the case above tells you that it failed.  If you happen to have a NumPy array with exactly one element, the <code>if</code> statement will &quot;work&quot;, in the sense that you don't get an error.  However, if that one element happens to be <code>0</code> (or <code>0.0</code>, or <code>False</code>, ...), the <code>if</code> statement will incorrectly result in <code>False</code>:</p>
<pre><code>&gt;&gt;&gt; x = numpy.array([0,])
&gt;&gt;&gt; if x: print(&quot;x&quot;)
... else: print(&quot;No x&quot;)
No x
</code></pre>
<p>But clearly <code>x</code> exists and is not empty!  This result is not what you wanted.</p>
<h2>Using <code>len</code> can give unexpected results</h2>
<p>For example,</p>
<pre><code>len( numpy.zeros((1,0)) )
</code></pre>
<p>returns 1, even though the array has zero elements.</p>
<h2>The numpythonic way</h2>
<p>As explained in the <a href="http://www.scipy.org/scipylib/faq.html#what-is-the-preferred-way-to-check-for-an-empty-zero-element-array" rel="noreferrer">SciPy FAQ</a>, the correct method in all cases where you know you have a NumPy array is to use <code>if x.size</code>:</p>
<pre><code>&gt;&gt;&gt; x = numpy.array([0,1])
&gt;&gt;&gt; if x.size: print(&quot;x&quot;)
x

&gt;&gt;&gt; x = numpy.array([0,])
&gt;&gt;&gt; if x.size: print(&quot;x&quot;)
... else: print(&quot;No x&quot;)
x

&gt;&gt;&gt; x = numpy.zeros((1,0))
&gt;&gt;&gt; if x.size: print(&quot;x&quot;)
... else: print(&quot;No x&quot;)
No x
</code></pre>
<p>If you're not sure whether it might be a <code>list</code>, a NumPy array, or something else, you could combine this approach with <a href="https://stackoverflow.com/a/10835703/1194883">the answer @dubiousjim gives</a> to make sure the right test is used for each type.  Not very &quot;pythonic&quot;, but it turns out that NumPy intentionally broke pythonicity in at least this sense.</p>
<p>If you need to do more than just check if the input is empty, and you're using other NumPy features like indexing or math operations, it's probably more efficient (and certainly more common) to force the input <em>to be</em> a NumPy array.  There are a few nice functions for doing this quickly — most importantly <a href="https://docs.scipy.org/doc/numpy-dev/reference/generated/numpy.asarray.html" rel="noreferrer"><code>numpy.asarray</code></a>.  This takes your input, does nothing if it's already an array, or wraps your input into an array if it's a list, tuple, etc., and optionally converts it to your chosen <code>dtype</code>.  So it's very quick whenever it can be, and it ensures that you just get to assume the input is a NumPy array.  We usually even just use the same name, as the conversion to an array won't make it back outside of the current <a href="http://python-textbok.readthedocs.io/en/1.0/Variables_and_Scope.html" rel="noreferrer">scope</a>:</p>
<pre><code>x = numpy.asarray(x, dtype=numpy.double)
</code></pre>
<p>This will make the <code>x.size</code> check work in all cases I see on this page.</p>
<h4> Gareth Latty, Comment 45413117 Score: 91: </h4>It&#39;s worth noting that this isn&#39;t a flaw in Python, but rather an intentional break of contract by <code>numpy</code> - <code>numpy</code> is a library with a very specific use case, and it has a different &#39;natural&#39; definition of what truthiness on an array is to the Python standard for containers. It makes sense to optimise for that case, in the way that <code>pathlib</code> uses <code>&#47;</code> to concatenate paths instead of <code>+</code> - it&#39;s non-standard, but makes sense in context.<br><h4> peterhil, Comment 79333832 Score: 34: </h4>@ppperry Yes, the original question was not about Numpy arrays, but when working with those and possibly duck typed arguments, this question becomes very relevant.<br><h4> Dalton, Comment 52145716 Score: 30: </h4>I don&#39;t know, for me, if a method called len(x) doesn&#39;t return the array length because assumptions, it&#39;s name is bad designed.<br><h4> pppery, Comment 77808000 Score: 15: </h4>This question has nothing to do with numpy arrays<br><h4> Mike, Comment 45414155 Score: 14: </h4>Agreed.  My point is just that it&#39;s important to remember that numpy has made the choice to break duck typing for both the very common <code>if x</code> and <code>len(x)</code> idioms -- and sometimes that breakage can be very hard to detect and debug.<br><h4> Mike, Comment 59514068 Score: 3: </h4>@pydsigner I agree with your conclusion, but I&#39;ll quibble with your logic -- particularly your last sentence.  <code>numpy.zeros((1,0))</code> is definitely not an array containing one (empty) array; it is just a single array containing no elements.  Numpy arrays are not nested.  When you run <code>tolist</code> you do get a list containing one (empty) list -- but that&#39;s a different beast entirely.  On the other hand, it appears that <code>len</code> just gives the size of the first dimension of an array.  This isn&#39;t <i>wrong</i>; it&#39;s just a choice (though one I would not have made).<br><h4> pydsigner, Comment 59504980 Score: 1: </h4>@Dalton I disagree on this interpretation of <code>len()</code> on numpy arrays. If you convert <code>numpy.zeros((1,0))</code> to a list, you get <code>[[]]</code>, which is boolean true. The numpy array isn&#39;t empty because it contains one (empty) array.<br><h4> Mike, Comment 92025653 Score: 1: </h4>@plugwash This was brought up above, so I&#39;ll just reiterate that everything else about numpy — from its C code to other aspects of its high-level interface — says that an array is definitely <i>not</i> a nested type of object; it is a single multi-dimensional object.  That is, <code>numpy.zeros((1,0))</code> is not supposed to be considered an array containing another array (that just happens to be empty).  Instead, it&#39;s supposed to be considered a single two-dimensional array containing no elements.  And as a result, you need to remain aware of the distinction whenever you test for an empty array.<br><h4> Mike, Comment 127593279 Score: 1: </h4>@BahaeElHmimdi That&#39;s a really bad &quot;solution&quot; because you actually make a copy of the data just to check its length.  For more realistic examples, that can be a <i>lot</i> of data that you just don&#39;t need to copy.  Another problem is that you have to know that you&#39;re dealing with a numpy array to do that extra step of converting to <code>list</code>.  But if you already know that, you should just use the correct method: <code>if x.size</code>, which doesn&#39;t copy any data; it just checks a single pre-existing integer.  And if you&#39;re unsure, it&#39;s far better to use dubiousjim&#39;s approach.<br><h4> pydsigner, Comment 59516282 Score: 1: </h4>@Mike While the str() of a 1x0 array is <code>[]</code>, running <code>for sub in numpy.zeros((1,0)): print sub</code> will output <code>[]</code> as the inner array rather than printing nothing. A quirk of array representation should not determine how we view the construct.<br><h4> Mike, Comment 59518120 Score: 1: </h4>I&#39;m not sure I get your point.  If you <code>print(type(sub))</code> in your example you get <code>&lt;class &#39;numpy.ndarray&#39;&gt;</code> -- not <code>list</code>.  Anyway, that&#39;s beside the point because it just means they&#39;ve implemented iteration.  There&#39;s no quirk about this: from their python-level interface, to the C API implementation, right down to their layout in memory, numpy arrays are multi-dimensional arrays, not nested arrays or lists.  You can slice them to extract sub-arrays, but that&#39;s got nothing to do with nesting.<br><h4> Bas Swinckels, Comment 81349799 Score: 1: </h4>The <i>nympythonic</i> way in case you also want to make your code work if a list is given is to first force any possible input to a numpy array using <a href="https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/numpy.asarray.html" rel="nofollow noreferrer">asarray</a>. After that, you can proceed as in your answer without worrying about other formats.<br><h4> Jonatan &#214;str&#246;m, Comment 110982206 Score: 1: </h4>If <code>len(zeros((1,0))</code> returned <code>0</code> then <code>len(zeros((2,2))</code> should return 4. There is the <code>size</code> method for that. If <code>array.shape</code> is <code>(2,3,4)</code> then <code>array[1].shape</code> is <code>(3,4)</code>, meaning that the first dimension works as a container for the trailing dimensions, etc, just like a nested list. So the expected result of <code>len(array)</code> for sure is <code>array.shape[0]</code>. And <code>zeros((1,0))</code> contains something: it contains 1 trailing dimension with extent 0.<br><h4> Mike, Comment 132277027 Score: 1: </h4>@skan Right, that&#39;s why I said &quot;the correct method in all cases <i>where you know you have a NumPy array</i> is to use <code>if x.size</code>&quot; (emphasis added), and then said &quot;If you&#39;re not sure whether it might be a <code>list</code>, a NumPy array, or something else, you could combine this approach with <a href="https://stackoverflow.com/a/10835703/1194883">the answer @dubiousjim gives</a>...&quot;<br><h4> skan, Comment 132254796 Score: 0: </h4>If I have an empty list  mylist = []  then   mylist.size doesn&#39;t work.<br><h4> Bahae El Hmimdi, Comment 127579904 Score: 0: </h4>there is symple solution len(list( numpy.zeros((1,0))) ) instead of len( numpy.zeros((1,0)) )<br><h4> Marco Sulla, Comment 106557407 Score: 0: </h4>@GarethLatty: not at all. The <code>&#47;</code> can be applied only between a  <code>Path</code> and a <code>str</code> or a path-like object. And this is <b>very</b> pythonic, since Python is a strong typed language. Furthermore, <code>+</code> seems more a concatenation between strings, and this is <b>not</b> the behavior of joining paths (try, for example, <code>Path(&quot;a&quot;) &#47; &quot;b&#47;&quot;</code>). Lastly, is <i>much</i> more elegant to join paths with <code>&#47;</code>.  On the contrary, <code>numpy</code> implemented operators between cats and dogs. This way, they completely broken any Python contract.<br><h4> Marco Sulla, Comment 106557452 Score: 0: </h4>@GarethLatty: for example, ff I want to create a function that can accept any iterable, and I have to use <code>bool()</code> or <code>len()</code>, I&#39;m forced to check if the iterable is an <code>ndarray</code> and threat it in a different way. So where is gone Duck Typing? The duck was eaten by <code>numpy</code>, hungry to attract Matlab users :-D<br><h4> Mike, Comment 81357809 Score: 0: </h4>@BasSwinckels Good point.  I&#39;m guessing it&#39;s not always worth the effort if the <i>only</i> thing you want to do is check if the input is empty, but certainly that&#39;s what we usually do when we want to actually do things with the input.  I&#39;ll add that to my answer.  Thanks.<br><h4> plugwash, Comment 91992693 Score: 0: </h4>&quot;len( numpy.zeros((1,0)) ) returns 1, even though the array has zero elements.&quot; It&#39;s IMO not terribly different from a list containing an empty list. both have a len of 1 and result in a single iteration when you loop over them.<br>------------------------------------------------------------------ <br><h3> Peter Hoffmann, Id: 53525, Score: 180: </h3><p>An empty list is itself considered false in true value testing (see <a href="https://docs.python.org/2/library/stdtypes.html#truth-value-testing" rel="noreferrer">python documentation</a>):</p>
<pre><code>a = []
if a:
     print(&quot;not empty&quot;)
</code></pre>
<p>To <a href="https://stackoverflow.com/questions/53513/how-do-i-check-if-a-list-is-empty/53530#53530">Daren Thomas's answer</a>:</p>
<blockquote>
<p>EDIT: Another point against testing
the empty list as False: What about
polymorphism? You shouldn't depend on
a list being a list. It should just
quack like a duck - how are you going
to get your duckCollection to quack
''False'' when it has no elements?</p>
</blockquote>
<p>Your duckCollection should implement <code>__nonzero__</code> or <code>__len__</code> so the if a: will work without problems.</p>
<h4> augurar, Comment 103275473 Score: 7: </h4>@information_interchange If you want to explicitly check the truthiness of a value, use <code>bool()</code>.  <code>bool([]) == False</code> will evaluate to <code>True</code> as expected.<br><h4> information_interchange, Comment 103089428 Score: 2: </h4>Strange how <code>[] == False</code> will evaluate to False though<br><h4> Paul, Comment 128178341 Score: 1: </h4>@information_interchange It really isn&#39;t.  Consider that if <code>[] == False</code> evaluated to <code>True</code> then, for consistency, so should <code>0 == False</code> and <code>&#39;&#39; == False</code>, or even <code>&#39;&#39; == []</code>.  Note that there&#39;s s distinction between truthiness in a boolean context and testing equality.  IMHO Clojure does this right: only False and nil are falsy.  Python&#39;s rule are reasonable.  PHP used to have evil rules (haven&#39;t used that for a very long time, don&#39;t know now).<br>------------------------------------------------------------------ <br><h3> abarnert, Id: 27262598, Score: 122: </h3><p><a href="https://stackoverflow.com/a/53522/908494">Patrick's (accepted) answer</a> is right: <code>if not a:</code> is the right way to do it. <a href="https://stackoverflow.com/a/53752/908494">Harley Holcombe's answer</a> is right that this is in the PEP 8 style guide. But what none of the answers explain is why it's a good idea to follow the idiom—even if you personally find it's not explicit enough or confusing to Ruby users or whatever.</p>

<p>Python code, and the Python community, has very strong idioms. Following those idioms makes your code easier to read for anyone experienced in Python. And when you violate those idioms, that's a strong signal.</p>

<p>It's true that <code>if not a:</code> doesn't distinguish empty lists from <code>None</code>, or numeric 0, or empty tuples, or empty user-created collection types, or empty user-created not-quite-collection types, or single-element NumPy array acting as scalars with falsey values, etc. And sometimes it's important to be explicit about that. And in that case, you know <em>what</em> you want to be explicit about, so you can test for exactly that. For example, <code>if not a and a is not None:</code> means "anything falsey except None", while <code>if len(a) != 0:</code> means "only empty sequences—and anything besides a sequence is an error here", and so on. Besides testing for exactly what you want to test, this also signals to the reader that this test is important.</p>

<p>But when you don't have anything to be explicit about, anything other than <code>if not a:</code> is misleading the reader. You're signaling something as important when it isn't. (You may also be making the code less flexible, or slower, or whatever, but that's all less important.) And if you <em>habitually</em> mislead the reader like this, then when you <em>do</em> need to make a distinction, it's going to pass unnoticed because you've been "crying wolf" all over your code.</p>
<h4> joel, Comment 110409405 Score: 3: </h4>&quot;And when you violate those idioms, that&#39;s a strong signal.&quot; It can be a strong signal that you&#39;re simply working with code written by someone new to python, which is a lot of people<br><h4> Rick Moritz, Comment 136838999 Score: 0: </h4>I was about to rebut &quot;Following those idioms makes your code easier to read for anyone experienced in Python.&quot; - Yes, but clean code is accessible to an even larger audience. Thanks @joel for picking that up as well, on the following sentence :)<br>------------------------------------------------------------------ <br><h3> George V. Reilly, Id: 61918, Score: 76: </h3><p><a href="http://books.google.com/books?id=vpTAq4dnmuAC&amp;pg=RA1-PA479&amp;lpg=RA1-PA479&amp;dq=Python+len+big+O&amp;source=web&amp;ots=AOM6A1K9Fy&amp;sig=iQo8mV6Xf9KdzuNSa-Jkr8wDEuw&amp;hl=en&amp;sa=X&amp;oi=book_result&amp;resnum=4&amp;ct=result" rel="noreferrer"><code>len()</code> is an O(1) operation</a> for Python lists, strings, dicts, and sets. Python internally keeps track of the number of elements in these containers.</p>

<p>JavaScript <a href="http://www.isolani.co.uk/blog/javascript/TruthyFalsyAndTypeCasting" rel="noreferrer">has a similar notion of truthy/falsy</a>.</p>
------------------------------------------------------------------ <br><h3> MrWonderful, Id: 32978062, Score: 107: </h3><h1>Why check at all?</h1>
<p>No one seems to have addressed questioning your <em>need</em> to test the list in the first place.  Because you provided no additional context, I can imagine that you may not need to do this check in the first place, but are unfamiliar with list processing in Python.</p>
<p>I would argue that the <em>most Pythonic</em> way is to not check at all, but rather to just process the list.  That way it will do the right thing whether empty or full.</p>
<pre><code>a = []

for item in a:
    # &lt;Do something with item&gt;

# &lt;The rest of code&gt;
</code></pre>
<p>This has the benefit of handling any contents of <strong>a</strong>, while not requiring a specific check for emptiness.  If <strong>a</strong> is empty, the dependent block will not execute and the interpreter will fall through to the next line.</p>
<p>If you do actually need to check the array for emptiness:</p>
<pre><code>a = []

if not a:
    # &lt;React to empty list&gt;

# &lt;The rest of code&gt;
</code></pre>
<p>is sufficient.</p>
<h4> MrWonderful, Comment 100121866 Score: 12: </h4>@DJK -  Nope, I think you’re still missing it.  Presumably you want to DO something with a list, if you have one.  What would you do differently if it were empty?  Return early?  What if it isn’t empty? process it?  The point is, still, that you <i>probably</i> don’t need to check for an empty list, just iterate over it and <i>do whatever you were going to do</i> with the elements.  If there are no elements, you fall through.  If there are elements, you process them as you need to.  The point is NOT to use the example FOR an empty-check but rather to NOT check at all, just process the list.<br><h4> Amarth G&#251;l, Comment 84165087 Score: 7: </h4>The thing is, check if the list is empty is quite important, at least for me. Have you considered if there&#39;s some script inside <code>&lt;rest of code&gt;</code> that might use the result from the <code>for</code> loop? Or directly use some values in <code>a</code>?  Indeed, if the script is designed to run with strictly controlled input, the check might be a little unnecessary. But in most cases, the input varies, and have a check is usually better.<br><h4> PieterNuyts, Comment 129460048 Score: 3: </h4>Good answer, but <code>!a</code> is a syntax error.  It should be <code>not a</code>.<br><h4> MrWonderful, Comment 84694253 Score: 2: </h4>Respectfully, no.  What I considered was someone who didn’t know enough about Python to know that “if &lt;list&gt;:” was the correct answer, asked how to check for an empty list.  Then I notice a LOT of answers that offered differing opinions, but none seemed to address the original need.  That is what I tried to do with my answer—have them examine the need before continuing.  I believe I suggested as much in my answer, explicitly.<br><h4> MrWonderful, Comment 87968450 Score: 1: </h4>@AmarthG&#251;l - How might one <i>get</i> the results from the for loop to the script inside &lt;rest of code&gt; to be processed?  In a list, perhaps? Or maybe a dict?  If so, the same logic applies.  I&#39;m not understanding how <i>variable input</i> could have any effect within any kind of reasonably designed code, where processing an empty list would be a bad idea.<br><h4> DJK, Comment 100085207 Score: 1: </h4>No you’ve created an O(n) problem on a check. your only considering a good outcome on an empty list. The answer works but in my opinion it’s sub optimal<br><h4> MrWonderful, Comment 130464977 Score: 0: </h4>@PieterNuyts - Indeed it is.  Fixed &amp; thank you!<br><h4> user8395964, Comment 134046566 Score: 0: </h4>Why check - when the list changes (is appended or popped from) within the block, it seems to not update in the condition check... I was running with AREPL VSCode extension, with Python 3.11<br><h4> MrWonderful, Comment 134121615 Score: 0: </h4>@user8395964 - Indeed, iterating over a list while modifying it is not considered &#39;best practice&#39;, or even &#39;acceptable practice&#39; where I&#39;ve worked in the past.  See <a href="https://stackoverflow.com/questions/1637807/modifying-list-while-iterating" title="modifying list while iterating">stackoverflow.com/questions/1637807/&hellip;</a> for details.<br><h4> user8395964, Comment 134128501 Score: 0: </h4>i suppose then that the DSA algorithms (bfs, etc) don&#39;t care about best practices lol<br><h4> MrWonderful, Comment 134196257 Score: 0: </h4>@user8395964 - I&#39;m afraid I&#39;m not understanding your point.  Is there a problem with the DSA algorithms that you are attempting to debug?  Is your question about iterating over a list being modified?  The OP&#39;s question is how to check for an empty list and my answer is meant to be sufficient for all users, likely including you, as the last statement is &quot;If you do actually need to check the array for emptiness...&quot;, which should cover your case and any others.  Otherwise, please include an example.  Thanks.<br><h4> DJK, Comment 100048132 Score: 0: </h4>A bit old but if you were just checking if the list was empty, for a non empty list your code repeats the process over and over when OP is simply looking for a check operation. Just imagine a worse case scenario for that code as n approaches infinity....<br><h4> MrWonderful, Comment 100083932 Score: 0: </h4>@DJK I believe you may have missed the point, but for an empty list, the code falls through.  For a non-empty list, you just process each element as you need to.  The point was “in most cases, no check for empty is necessary.”  This is doubly so because the OP didn’t know that “if a_list:” was the correct answer, therefore was potentially a novice python developer.<br>------------------------------------------------------------------ <br><h3> dubiousjim, Id: 10835703, Score: 53: </h3><p>I had written:</p>

<pre><code>if isinstance(a, (list, some, other, types, i, accept)) and not a:
    do_stuff
</code></pre>

<p>which was voted -1. I'm not sure if that's because readers objected to the strategy or thought the answer wasn't helpful as presented. I'll pretend it was the latter, since---whatever counts as "pythonic"---this is the correct strategy. Unless you've already ruled out, or are prepared to handle cases where <code>a</code> is, for example, <code>False</code>, you need a test more restrictive than just <code>if not a:</code>. You could use something like this:</p>

<pre><code>if isinstance(a, numpy.ndarray) and not a.size:
    do_stuff
elif isinstance(a, collections.Sized) and not a:
    do_stuff
</code></pre>

<p>the first test is in response to @Mike's answer, above. The third line could also be replaced with:</p>

<pre><code>elif isinstance(a, (list, tuple)) and not a:
</code></pre>

<p>if you only want to accept instances of particular types (and their subtypes), or with:</p>

<pre><code>elif isinstance(a, (list, tuple)) and not len(a):
</code></pre>

<p>You can get away without the explicit type check, but only if the surrounding context already assures you that <code>a</code> is a value of the types you're prepared to handle, or if you're sure that types you're not prepared to handle are going to raise errors (e.g., a <code>TypeError</code> if you call <code>len</code> on a value for which it's undefined) that you're prepared to handle. In general, the "pythonic" conventions seem to go this last way. Squeeze it like a duck and let it raise a DuckError if it doesn't know how to quack. You still have to <em>think</em> about what type assumptions you're making, though, and whether the cases you're not prepared to handle properly really are going to error out in the right places. The Numpy arrays are a good example where just blindly relying on <code>len</code> or the boolean typecast may not do precisely what you're expecting.</p>
<h4> Gareth Latty, Comment 45413332 Score: 14: </h4>The reason people don&#39;t like this is because it&#39;s entirely unnessesary in most cases. Python is a duck-typed language, and this level of defensive coding actively hinders that. The idea behind Python&#39;s type system is that things should work as long as the object passed in functions in the way it needs to. By doing explicit type checks you are forcing the caller to use specific types, going against the very grain of the language. While occasionally such things are necessary (excluding strings from being treated as sequences), such cases are rare and almost always best as blacklists.<br><h4> abarnert, Comment 42997564 Score: 3: </h4>It&#39;s pretty rare that you&#39;re going to have an exhaustive list of 6 types that you want to accept and not be flexible for any other types. When you need that kind of thing, you probably want an ABC. In this case, it would probably be one of the stdlib ABCs, like <code>collections.abc.Sized</code> or <code>collections.abc.Sequence</code>, but it might be one you write yourself and <code>register(list)</code> on. If you actually do have code where it&#39;s important to distinguish empty from other falsey, and also to distinguish lists and tuples from any other sequences, then this is correct—but I don&#39;t believe you have such code.<br><h4> dubiousjim, Comment 50878522 Score: 2: </h4>There are some automatic coercions for <code>==</code> though. Off the top of my head, I can&#39;t identify any for <code>[]</code>. <code>[] == ()</code> for instance returns <code>False</code>. But for example <code>frozenset()==set()</code> returns <code>True</code>. So it&#39;s worth at least giving some thought to whether some undesired type might be coerced to <code>[]</code> (or vice versa) when doing <code>a == []</code>.<br><h4> Tim, Comment 100462683 Score: 1: </h4>@Boris Type hints help static type checkers (like mypy) to check for type correctness but do not perform runtime type checking.<br><h4> RemcoGerlich, Comment 50877301 Score: 1: </h4>If you really want to check that the value is exactly <code>[]</code> and not something falsy of another type, then surely <code>if a == []:</code> is called for, rather than mucking about with isinstance.<br><h4> user3064538, Comment 98813188 Score: 0: </h4>Instead of manually checking types you should use <a href="https://docs.python.org/library/typing.html" rel="nofollow noreferrer">type hinting</a> (introduced in 3.5).<br><h4> MrWonderful, Comment 92466798 Score: 0: </h4>@RemcoGerlich - isinstance() is still preferable as opposed to constructing an empty list to compare against.  Also, as another pointed out, the equality operator may invoke implicit conversion of some types, which may be undesirable.  There is no reason to ever code &quot;a == []&quot; and that code would definitely be flagged as a defect in any code review I&#39;ve participated in.  Using the appropriate tool as provided by the language should not be considered &quot;mucking about,&quot; but rather &quot;good programming technique.&quot;<br><h4> craq, Comment 134044160 Score: 0: </h4>Is there a reason to prefer <code>.size</code> over <code>.ndim &gt; 0</code>? I just hit a case where <code>a=np.array(None)</code>. <code>a.size</code> is 1, but <code>a.ndim</code> is 0. <code>for _ in a:</code> gives &quot;TypeError: iteration over a 0-d array&quot;<br><h4> JWCS, Comment 135470730 Score: 0: </h4>The proper way to have runtime typechecking is thus to use <a href="https://github.com/beartype/beartype" rel="nofollow noreferrer">beartype</a><br>------------------------------------------------------------------ <br><h3> Sнаđошƒаӽ, Id: 34558732, Score: 38: </h3><p>From <a href="https://docs.python.org/3.5/library/stdtypes.html#truth-value-testing">documentation</a> on truth value testing:</p>

<p>All values other than what is listed here are considered <code>True</code></p>

<ul>
<li><code>None</code></li>
<li><code>False</code></li>
<li>zero of any numeric type, for example, <code>0</code>, <code>0.0</code>, <code>0j</code>.</li>
<li>any empty sequence, for example, <code>''</code>, <code>()</code>, <code>[]</code>.</li>
<li>any empty mapping, for example, <code>{}</code>.</li>
<li>instances of user-defined classes, if the class defines a <code>__bool__()</code> or <code>__len__()</code> method, when that method returns the integer zero or bool value <code>False</code>.</li>
</ul>

<p>As can be seen, empty list <code>[]</code> is <em>falsy</em>, so doing what would be done to a boolean value sounds most efficient:</p>

<pre><code>if not a:
    print('"a" is empty!')
</code></pre>
<h4> Sнаđошƒаӽ, Comment 91201325 Score: 0: </h4>@DJ_Stuffy_K assert what in unit testing, an empty list? Just use <code>assert(not myList)</code>. If you also want to assert the object is a <code>list</code>, you can use <a href="https://docs.python.org/3/library/unittest.html#unittest.TestCase.assertIsInstance" rel="nofollow noreferrer"><code>assertIsInstance()</code></a>.<br>------------------------------------------------------------------ <br><h3> verix, Id: 53533, Score: 37: </h3><p>I prefer the following:</p>

<pre><code>if a == []:
   print "The list is empty."
</code></pre>
<h4> Carl Meyer, Comment 1498 Score: 52: </h4>This is going to be slower, as you instantiate an extra empty list unnecessarily.<br><h4> devsnd, Comment 18207909 Score: 43: </h4>this is less readable than <code>if not a:</code> and breaks more easily. Please don&#39;t do it.<br><h4> scubbo, Comment 112303048 Score: 8: </h4>&quot;breaks more easily&quot; citation needed? <code>if not a</code> breaks when a is <code>None</code> - you may <i>desire</i> the same behaviour for <code>None</code> and <code>[]</code>, but if you <i>explicitly</i> want to check for an empty list, <code>if not a</code> doesn&#39;t do that.<br><h4> AboodXD, Comment 118801976 Score: 1: </h4>@scubbo if you really want to explicitly check whether it&#39;s an empty list or not, consider using <code>isinstance(a, list) and not a</code> instead.<br><h4> A Star, Comment 97140071 Score: 0: </h4>There is a good point made earlier <code>() == []</code> is also equal to false. Although I like how this implementation reads the <code>if not a:</code> covers all cases, if you are definitely expecting a list then your example should be sufficient.<br>------------------------------------------------------------------ <br><h3> Taufiq Rahman, Id: 40846473, Score: 37: </h3><p>Here are a few ways you can check if a list is empty:</p>

<pre><code>a = [] #the list
</code></pre>

<p><strong>1)</strong> The pretty simple pythonic way:</p>

<pre><code>if not a:
    print("a is empty")
</code></pre>

<p>In Python, <strong>empty containers</strong> such as lists,tuples,sets,dicts,variables etc are seen as <code>False</code>. One could simply treat the list as a predicate (<em>returning a Boolean value</em>). And  a <code>True</code> value would indicate that it's non-empty.</p>

<p><strong>2)</strong> A much explicit way: using the <code>len()</code> to find the length and check if it equals to <code>0</code>:</p>

<pre><code>if len(a) == 0:
    print("a is empty")
</code></pre>

<p><strong>3)</strong> Or comparing it to an anonymous empty list:</p>

<pre><code>if a == []:
    print("a is empty")
</code></pre>

<p><strong>4)</strong> Another yet <em>silly</em> way to do is using <code>exception</code> and <code>iter()</code>:</p>

<pre><code>try:
    next(iter(a))
    # list has elements
except StopIteration:
    print("Error: a is empty")
</code></pre>
------------------------------------------------------------------ <br><h3> Vikrant, Id: 54612063, Score: 32: </h3><p>Method 1 (preferred):</p>
<pre><code>if not a:
   print (&quot;Empty&quot;)
</code></pre>
<p>Method 2:</p>
<pre><code>if len(a) == 0:
   print(&quot;Empty&quot;)
</code></pre>
<p>Method 3:</p>
<pre><code>if a == []:
  print (&quot;Empty&quot;)
</code></pre>
------------------------------------------------------------------ <br><h3> Sunil Lulla, Id: 39469420, Score: 25: </h3><p>You can even try using <code>bool()</code> like this. Although it is less readable surely it's a concise way to perform this.</p>
<pre><code>    a = [1,2,3];
    print bool(a); # it will return True
    a = [];
    print bool(a); # it will return False
</code></pre>
<p>I love this way for the checking list is empty or not.</p>
<p>Very handy and useful.</p>
<h4> Galen Long, Comment 72575979 Score: 8: </h4>For those (like me) who didn&#39;t know, <code>bool()</code> converts a Python variable into a boolean so you can <a href="http://stackoverflow.com/a/24868176/6157047">store the truthiness or falsiness</a> of a value without having to use an if-statement. I think it&#39;s less readable than simply using a conditional like the accepted answer, but I&#39;m sure there are other good use cases for it.<br><h4> Lars P, Comment 113397201 Score: 1: </h4>The downside happens when <code>a is None</code>.  This is often acceptable, just good to be aware of.<br><h4> qneill, Comment 82718489 Score: 0: </h4>This is usable in an expression and is more terse.<br>------------------------------------------------------------------ <br><h3> Andy Jazz, Id: 53926417, Score: 19: </h3><p>To check whether a list is empty or not you can use two following ways. But remember, we should avoid the way of explicitly checking for a type of sequence (it's a <strong>less Pythonic</strong> way):</p>
<pre><code>def enquiry(list1):
    return len(list1) == 0
</code></pre>
<hr />
<pre><code>list1 = []

if enquiry(list1):
    print(&quot;The list isn't empty&quot;)
else:
    print(&quot;The list is Empty&quot;)

# Result: &quot;The list is Empty&quot;.
</code></pre>
<p>The second way is a <strong>more Pythonic</strong> one. This method is an implicit way of checking and much more preferable than the previous one.</p>
<pre><code>def enquiry(list1):
    return not list1
</code></pre>
<hr />
<pre><code>list1 = []

if enquiry(list1):
    print(&quot;The list is Empty&quot;)
else:
    print(&quot;The list isn't empty&quot;)

# Result: &quot;The list is Empty&quot;
</code></pre>
<h4> Alexis Drakopoulos, Comment 116706522 Score: 2: </h4>Note the second one may not work with other common array type objects such as numpy arrays.<br><h4> David Frick, Comment 112178766 Score: 1: </h4>Upvoted for also showing how to check if it is not empty! This helps cover the opposite but equally important use case<br>------------------------------------------------------------------ <br><h3> Tagar, Id: 36610301, Score: 18: </h3><pre><code>def list_test (L):
    if   L is None  : print('list is None')
    elif not L      : print('list is empty')
    else: print('list has %d elements' % len(L))

list_test(None)
list_test([])
list_test([1,2,3])
</code></pre>

<p>It is sometimes good to test for <code>None</code> and for emptiness separately as those are two different states. The code above produces the following output:</p>

<pre><code>list is None 
list is empty 
list has 3 elements
</code></pre>

<p>Although it's worth nothing that <code>None</code> is falsy. So if you don't want to separate test for <code>None</code>-ness, you don't have to do that. </p>

<pre><code>def list_test2 (L):
    if not L      : print('list is empty')
    else: print('list has %d elements' % len(L))

list_test2(None)
list_test2([])
list_test2([1,2,3])
</code></pre>

<p>produces expected</p>

<pre><code>list is empty
list is empty
list has 3 elements
</code></pre>
<h4> HighExodus, Comment 114898464 Score: 1: </h4>IMHO, this is this best answer. It addresses the nuances with respect to <code>None</code> and <code>[]</code> (an empty list) when testing.<br>------------------------------------------------------------------ <br><h3> Rahul, Id: 49109480, Score: 15: </h3><p>If you want to check if a list is empty:</p>

<pre><code>l = []
if l:
    # do your stuff.
</code></pre>

<p>If you want to check whether all the values in list is empty. However it will be <code>True</code> for an empty list:</p>

<pre><code>l = ["", False, 0, '', [], {}, ()]
if all(bool(x) for x in l):
    # do your stuff.
</code></pre>

<p>If you want to use both cases together:</p>

<pre><code>def empty_list(lst):
    if len(lst) == 0:
        return False
    else:
        return all(bool(x) for x in l)
</code></pre>

<p>Now you can use:</p>

<pre><code>if empty_list(lst):
    # do your stuff.
</code></pre>
<h4> gberger, Comment 85237493 Score: 2: </h4>all(bool(x) for x in l) is True for an empty list<br>------------------------------------------------------------------ <br><h3> HackerBoss, Id: 52772082, Score: 15: </h3><p>Many answers have been given, and a lot of them are pretty good. I just wanted to add that the check</p>

<pre><code>not a
</code></pre>

<p>will also pass for <code>None</code> and other types of empty structures. If you truly want to check for an empty list, you can do this:</p>

<pre><code>if isinstance(a, list) and len(a)==0:
    print("Received an empty list")
</code></pre>
<h4> ElmoVanKielmo, Comment 96543381 Score: 9: </h4>@SvenKr&#252;ger nope. Operator <code>and</code> is lazy in Python. Nothing after <code>and</code> is going to be executed if condition before <code>and</code> is False.<br><h4> Sven-Eric Kr&#252;ger, Comment 95082839 Score: 0: </h4>It is possible this throws an exception, if <code>a</code> is not a list and <code>a</code> has no method <code>__len__</code> implemented. I would recommend: <code>if isinstance(obj, list): if len(obj) == 0:  print &#39;...&#39;</code><br>------------------------------------------------------------------ <br><h3> Andrey Topoleov, Id: 53127845, Score: 14: </h3><pre><code>print('not empty' if a else 'empty')
</code></pre>
<p>a little more practical:</p>
<pre><code>a.pop() if a else None
</code></pre>
<p>and the shortest version:</p>
<pre><code>if a: a.pop() 
</code></pre>
------------------------------------------------------------------ <br><h3> AndreyS Scherbakov, Id: 43083496, Score: 11: </h3><p>Being inspired by <a href="https://stackoverflow.com/questions/53513/how-do-i-check-if-a-list-is-empty/10835703#10835703">dubiousjim's solution</a>, I propose to use an additional general check of whether is it something iterable:</p>
<pre><code>import collections
def is_empty(a):
    return not a and isinstance(a, collections.Iterable)
</code></pre>
<p>Note: a string is considered to be iterable—add <code>and not isinstance(a,(str,unicode))</code> if you want the empty string to be excluded</p>
<p>Test:</p>
<pre><code>&gt;&gt;&gt; is_empty('sss')
False
&gt;&gt;&gt; is_empty(555)
False
&gt;&gt;&gt; is_empty(0)
False
&gt;&gt;&gt; is_empty('')
True
&gt;&gt;&gt; is_empty([3])
False
&gt;&gt;&gt; is_empty([])
True
&gt;&gt;&gt; is_empty({})
True
&gt;&gt;&gt; is_empty(())
True
</code></pre>
<h4> pppery, Comment 77097923 Score: 2: </h4>Overbroad; this is just asking whether a list is empty, not whether something is an empty iterable.<br><h4> Davis Herring, Comment 79586705 Score: 1: </h4>If I wasn&#39;t happy with <code>if a:</code>, it would be because I wanted an exception if <code>a</code> wasn&#39;t some sort of container.  (Being an <i>iterable</i> also allows iterators, which can&#39;t usefully be tested for emptiness.)<br>------------------------------------------------------------------ <br><h3> l. zhang, Id: 54065002, Score: 11: </h3><p>We could use a simple <em>if else</em>:</p>
<pre class="lang-py prettyprint-override"><code>item_list=[]
if len(item_list) == 0:
    print(&quot;list is empty&quot;)
else:
    print(&quot;list is not empty&quot;)
</code></pre>
<h4> MrWonderful, Comment 98456366 Score: 5: </h4>-1 - To avoid confusion, don&#39;t use a reserved words for variable names or you may get surprising behavior next time you try to call, for instance &quot;list()&quot;... something like &quot;TypeError: &#39;list&#39; object is not callable&quot; or some such.<br>------------------------------------------------------------------ <br><h3> Trect, Id: 53169502, Score: 7: </h3><p>From python3 onwards you can use</p>

<pre><code>a == []
</code></pre>

<p>to check if the list is empty</p>

<p>EDIT : This works with python2.7 too.. </p>

<p>I am not sure why there are so many complicated answers.
It's pretty clear and straightforward</p>
<h4> MrWonderful, Comment 98455913 Score: 4: </h4>This is not pythonic nor a complete example.  Also, It instantiates an empty list every time it is encountered.  Don&#39;t do this.<br><h4> Trect, Comment 108029872 Score: 2: </h4>@MrWonderful it does not instantiate an empty list every time. It just verifies if the existing list <code>a</code> is empty or not.<br><h4> Trect, Comment 108029896 Score: 2: </h4>@MrWonderful I don&#39;t get what makes it <code>pythonic</code><br><h4> GD- Ganesh Deshmukh, Comment 94791501 Score: 2: </h4>please give more explanation about how it is working without writing &quot;if&quot;?<br><h4> Trect, Comment 108029957 Score: 1: </h4>@ganeshdeshmukh if you use <code>a==[]</code> it will print true on the python terminal if a is empty. Else it will print False. You can use this inside a if condition also as <code>if(a==[])</code><br><h4> Sreenikethan I, Comment 125204221 Score: 0: </h4>@Trect Doesn&#39;t the expression <code>[]</code> instantiate a new (empty) list every time?<br><h4> Ihtisham Khattak, Comment 124638528 Score: 0: </h4>listData = [] You can also check list using <code>if</code> condition if not a:     print(&#39;Empty List&#39;)<br>------------------------------------------------------------------ <br><h3> Ashiq Imran, Id: 52771578, Score: 8: </h3><p>Simple way is checking the length is equal zero.</p>

<pre><code>if len(a) == 0:
    print("a is empty")
</code></pre>
------------------------------------------------------------------ <br><h3> figs_and_nuts, Id: 50362360, Score: 6: </h3><p>The truth value of an empty list is <code>False</code> whereas for a non-empty list it is <code>True</code>.</p>
------------------------------------------------------------------ <br><h3> Vedran Šego, Id: 55833259, Score: 6: </h3><p>What brought me here is a special use-case: I actually wanted a <em>function</em> to tell me if a list is empty or not. I wanted to avoid writing my own function or using a lambda-expression here (because it seemed like it should be simple enough):</p>

<pre><code>foo = itertools.takewhile(is_not_empty, (f(x) for x in itertools.count(1)))
</code></pre>

<p>And, of course, there is a very natural way to do it:</p>

<pre><code>foo = itertools.takewhile(bool, (f(x) for x in itertools.count(1)))
</code></pre>

<p>Of course, do <strong>not</strong> use <code>bool</code> in <code>if</code> (i.e., <code>if bool(L):</code>) because it's implied. But, for the cases when "is not empty" is explicitly needed as a function, <code>bool</code> is the best choice.</p>
