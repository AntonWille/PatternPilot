 <h2> Title: How can I call a shell command in my Perl script? </h2> <h4> Yang, question_id: 3200801, created_at: 2010-07-08 05:07:09+00:00 </h4>Score: 86, Tags: {perl} <br><p>What would be an example of how I can call a shell command, say '<code>ls -a</code>' in a Perl script and the way to retrieve the output of the command as well?</p>
<hr><h3> ✔️ Answer by fire.eagle, Id: 3200810, Score: 107, created_at: 2010-07-08 05:11:34+00:00 </h3><p><a href="http://www.perlmonks.org/?node_id=78523" rel="noreferrer">How to run a shell script from a Perl program</a></p>

<blockquote>
  <p><strong>1. Using system <code>system($command, @arguments);</code></strong></p>
  
  <p>For example: </p>

<pre><code>system("sh", "script.sh", "--help" );

system("sh script.sh --help");
</code></pre>
  
  <p>System will execute the $command with
  @arguments and return to your script when finished. You may check $!
  for certain errors passed to the OS by the external application. Read
  the documentation for system for the nuances of how various
  invocations are slightly different.</p>
  
  <p><strong>2. Using <code>exec</code></strong> </p>
  
  <p>This is very similar to the use of <a href="http://perldoc.perl.org/functions/system.html" rel="noreferrer">system</a>, but it will
  terminate your script upon execution. Again, read the documentation
  for <a href="http://perldoc.perl.org/functions/exec.html" rel="noreferrer">exec</a> for more.</p>
  
  <p><strong>3. Using backticks or <code>qx//</code></strong> </p>

<pre><code>my $output = `script.sh --option`;

my $output = qx/script.sh --option/;
</code></pre>
  
  <p>The backtick operator and it's equivalent <code>qx//</code>, excute the command and options inside the operator and return that commands output to STDOUT when it finishes. </p>
  
  <p>There are also ways to run external applications through creative use of <a href="http://perldoc.perl.org/functions/open.html" rel="noreferrer">open</a>, but this is advanced use; read the documentation for more.</p>
</blockquote>
<h4> Comment by yerlilbilgin, Score: 0, Id: 87639162, created_at: 2018-05-12 23:21:39+00:00 </h4>for the qx/ or backtick one add 2&gt;&amp;1 to capture also stderr.<h4> Comment by Tyler, Score: 5, Id: 83173741, created_at: 2018-01-04 16:20:28+00:00 </h4>That is called a backtick ` ... for programming anyway, when used in foreign languages it is an accent. A tilde (notice the &quot;e&quot; at the end, rather than &quot;a&quot;) is the squiggly line; which in Perl is used for pattern matching and smart matching.<h4> Comment by ANjaNA, Score: 1, Id: 63460321, created_at: 2016-06-24 08:08:56+00:00 </h4>system() gives u output in run time.<h4> Comment by PMat, Score: 1, Id: 75549625, created_at: 2017-05-30 19:53:02+00:00 </h4>I don&#39;t think tilda ` works with latest perl(5.24.0)<hr><h3>  Answer by sjy, Id: 21153038, Score: 30, created_at: 2014-01-16 03:52:12+00:00 </h3><p>From <a href="http://www.perlhowto.com/executing_external_commands" rel="noreferrer">Perl HowTo</a>, the most common ways to execute external commands from Perl are:</p>

<ul>
<li><code>my $files = `ls -la`</code> — captures the output of the command in <code>$files</code></li>
<li><code>system "touch ~/foo"</code> — if you don't want to capture the command's output</li>
<li><code>exec "vim ~/foo"</code> — if you don't want to return to the script after executing the command</li>
<li><code>open(my $file, '|-', "grep foo"); print $file "foo\nbar"</code> — if you want to pipe input into the command</li>
</ul>
<hr><h3>  Answer by user376314, Id: 3201234, Score: 18, created_at: 2010-07-08 06:45:37+00:00 </h3><h2>Examples</h2>
<ol>
<li><code>`ls -l`;</code></li>
<li><code>system(&quot;ls -l&quot;);</code></li>
<li><code>exec(&quot;ls -l&quot;);</code></li>
</ol>
<h4> Comment by K.L., Score: 7, Id: 36370100, created_at: 2014-05-15 09:45:15+00:00 </h4>You should explain what are the differences between these methods. Also, I believe not all of them solve the problem that OP has (calling exec does not return to the perl script AFAIR)<h4> Comment by scragar, Score: 1, Id: 39554020, created_at: 2014-08-18 15:19:27+00:00 </h4>@K.L. You are correct, without some nasty hacks exec will exit the perl script with the same exit code as the passed command.<hr><h3>  Answer by Grant McLean, Id: 3216683, Score: 13, created_at: 2010-07-09 21:28:23+00:00 </h3><p>As you become more experienced with using Perl, you'll find that there are fewer and fewer occasions when you need to run shell commands.  For example, one way to get a list of files is to use Perl's built-in <a href="http://perldoc.perl.org/functions/glob.html" rel="noreferrer">glob</a> function.  If you want the list in sorted order you could combine it with the built-in <a href="http://perldoc.perl.org/functions/sort.html" rel="noreferrer">sort</a> function.  If you want details about each file, you can use the <a href="http://perldoc.perl.org/functions/stat.html" rel="noreferrer">stat</a> function.  Here's an example:</p>

<pre><code>#!/usr/bin/perl

use strict;
use warnings;

foreach my $file ( sort glob('/home/grant/*') ) {
    my($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,$atime,$mtime,$ctime,$blksize,$blocks)
        = stat($file);
    printf("%-40s %8u bytes\n", $file, $size);
}
</code></pre>
<h4> Comment by M_M, Score: 1, Id: 108857905, created_at: 2020-05-01 09:10:56+00:00 </h4>Obviously this answer doesn&#39;t apply to commands other than <code>ls</code>, but in the case that the user was actually going to call <code>ls</code>, this answer deserves recognition for answering the user&#39;s intention rather than their actual question.<hr><h3>  Answer by Jonathan Leffler, Id: 3200858, Score: 12, created_at: 2010-07-08 05:27:24+00:00 </h3><p>Look at the <a href="http://perldoc.perl.org/functions/open.html" rel="noreferrer">open</a> function in Perl - especially the variants using a '|' (pipe) in the arguments.  Done correctly, you'll get a file handle that you can use to read the output of the command.  The back tick operators also do this.</p>

<p>You might also want to review whether Perl has access to the C functions that the command itself uses.  For example, for <code>ls -a</code>, you could use the <a href="http://perldoc.perl.org/functions/opendir.html" rel="noreferrer">opendir</a> function, and then read the file names with the <a href="http://perldoc.perl.org/functions/readdir.html" rel="noreferrer">readdir</a> function, and finally close the directory with (surprise) the <a href="http://perldoc.perl.org/functions/closedir.html" rel="noreferrer">closedir</a> function.  This has a number of benefits - precision probably being more important than speed.  Using these functions, you can get the correct data even if the file names contain odd characters like newline.</p>
<hr><h3>  Answer by thegeek, Id: 3201000, Score: 6, created_at: 2010-07-08 05:57:17+00:00 </h3><p>There are a lot of ways you can call a shell command from a Perl script, such as:</p>

<ol>
<li>back tick
       <code>ls</code> which captures the output and gives back to you.</li>
<li>system
       system('ls');</li>
<li>open</li>
</ol>

<p>Refer #17 here: <a href="http://www.thegeekstuff.com/2010/01/20-killer-perl-programming-tips-for-beginners-on-unix-linux-os/" rel="nofollow noreferrer">Perl programming tips</a></p>
<hr><h3>  Answer by miedwar, Id: 3204931, Score: 1, created_at: 2010-07-08 14:59:57+00:00 </h3><p>You might want to look into <a href="http://search.cpan.org/~dapm/perl-5.10.1/lib/IPC/Open2.pm" rel="nofollow noreferrer">open2</a> and <a href="http://search.cpan.org/~dapm/perl-5.10.1/lib/IPC/Open3.pm" rel="nofollow noreferrer">open3</a> in case you need bidirectional communication.</p>
<hr><h3>  Answer by Ulisses, Id: 69905356, Score: 1, created_at: 2021-11-09 21:28:52+00:00 </h3><p>I have been using system and qq to run linux programs inside perl. And it has worked well.</p>
<pre><code>#!/usr/bin/perl   # A hashbang line in perl
    
use strict;       # It can save you a lot of time and headache
use warnings;     # It helps you find typing mistakes

# my keyword in Perl declares the listed variable

my $adduser = '/usr/sbin/adduser';
my $edquota = '/usr/sbin/edquota';
my $chage = '/usr/bin/chage';
my $quota = '/usr/bin/quota';
my $nomeinteiro;
my $username;
my $home;


# system() function executes a system shell command
# qq() can be used in place of double quotes

system qq($adduser --home $home --gecos &quot;$fullname&quot; $username);
system qq($edquota -p john $username);
system qq($chage -E \$(date -d +180days +%Y-%m-%d) $username);
system qq($chage -l $username);
system qq($quota -s $username);

</code></pre>
<h4> Comment by holydragon, Score: 0, Id: 123609838, created_at: 2021-11-11 10:35:09+00:00 </h4>The answer would be more useful if you can add some explanation along with the code.<h4> Comment by Ulisses, Score: 0, Id: 123648444, created_at: 2021-11-12 20:10:21+00:00 </h4>Thanks for the review. now I put more comments to get a better understanding.