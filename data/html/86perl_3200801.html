 <h2> Title: How can I call a shell command in my Perl script? </h2> <h3> Yang, question_id: 3200801 </h3>Score: 86, Tags: {perl} <br><p>What would be an example of how I can call a shell command, say '<code>ls -a</code>' in a Perl script and the way to retrieve the output of the command as well?</p>
------------------------------------------------------------------ <br><h3> Answer 3200810 fire.eagle: </h3><p><a href="http://www.perlmonks.org/?node_id=78523" rel="noreferrer">How to run a shell script from a Perl program</a></p>

<blockquote>
  <p><strong>1. Using system <code>system($command, @arguments);</code></strong></p>
  
  <p>For example: </p>

<pre><code>system("sh", "script.sh", "--help" );

system("sh script.sh --help");
</code></pre>
  
  <p>System will execute the $command with
  @arguments and return to your script when finished. You may check $!
  for certain errors passed to the OS by the external application. Read
  the documentation for system for the nuances of how various
  invocations are slightly different.</p>
  
  <p><strong>2. Using <code>exec</code></strong> </p>
  
  <p>This is very similar to the use of <a href="http://perldoc.perl.org/functions/system.html" rel="noreferrer">system</a>, but it will
  terminate your script upon execution. Again, read the documentation
  for <a href="http://perldoc.perl.org/functions/exec.html" rel="noreferrer">exec</a> for more.</p>
  
  <p><strong>3. Using backticks or <code>qx//</code></strong> </p>

<pre><code>my $output = `script.sh --option`;

my $output = qx/script.sh --option/;
</code></pre>
  
  <p>The backtick operator and it's equivalent <code>qx//</code>, excute the command and options inside the operator and return that commands output to STDOUT when it finishes. </p>
  
  <p>There are also ways to run external applications through creative use of <a href="http://perldoc.perl.org/functions/open.html" rel="noreferrer">open</a>, but this is advanced use; read the documentation for more.</p>
</blockquote>
<h4> Comment 83173741 Tyler: </h4>That is called a backtick ` ... for programming anyway, when used in foreign languages it is an accent. A tilde (notice the &quot;e&quot; at the end, rather than &quot;a&quot;) is the squiggly line; which in Perl is used for pattern matching and smart matching.<br><h4> Comment 63460321 ANjaNA: </h4>system() gives u output in run time.<br><h4> Comment 75549625 PMat: </h4>I don&#39;t think tilda ` works with latest perl(5.24.0)<br><h4> Comment 87639162 yerlilbilgin: </h4>for the qx/ or backtick one add 2&gt;&amp;1 to capture also stderr.<br>------------------------------------------------------------------ <br><h3> Answer 21153038 sjy: </h3><p>From <a href="http://www.perlhowto.com/executing_external_commands" rel="noreferrer">Perl HowTo</a>, the most common ways to execute external commands from Perl are:</p>

<ul>
<li><code>my $files = `ls -la`</code> — captures the output of the command in <code>$files</code></li>
<li><code>system "touch ~/foo"</code> — if you don't want to capture the command's output</li>
<li><code>exec "vim ~/foo"</code> — if you don't want to return to the script after executing the command</li>
<li><code>open(my $file, '|-', "grep foo"); print $file "foo\nbar"</code> — if you want to pipe input into the command</li>
</ul>
------------------------------------------------------------------ <br><h3> Answer 3201234 user376314: </h3><h2>Examples</h2>
<ol>
<li><code>`ls -l`;</code></li>
<li><code>system(&quot;ls -l&quot;);</code></li>
<li><code>exec(&quot;ls -l&quot;);</code></li>
</ol>
<h4> Comment 36370100 K.L.: </h4>You should explain what are the differences between these methods. Also, I believe not all of them solve the problem that OP has (calling exec does not return to the perl script AFAIR)<br><h4> Comment 39554020 scragar: </h4>@K.L. You are correct, without some nasty hacks exec will exit the perl script with the same exit code as the passed command.<br>------------------------------------------------------------------ <br><h3> Answer 3200858 Jonathan Leffler: </h3><p>Look at the <a href="http://perldoc.perl.org/functions/open.html" rel="noreferrer">open</a> function in Perl - especially the variants using a '|' (pipe) in the arguments.  Done correctly, you'll get a file handle that you can use to read the output of the command.  The back tick operators also do this.</p>

<p>You might also want to review whether Perl has access to the C functions that the command itself uses.  For example, for <code>ls -a</code>, you could use the <a href="http://perldoc.perl.org/functions/opendir.html" rel="noreferrer">opendir</a> function, and then read the file names with the <a href="http://perldoc.perl.org/functions/readdir.html" rel="noreferrer">readdir</a> function, and finally close the directory with (surprise) the <a href="http://perldoc.perl.org/functions/closedir.html" rel="noreferrer">closedir</a> function.  This has a number of benefits - precision probably being more important than speed.  Using these functions, you can get the correct data even if the file names contain odd characters like newline.</p>
------------------------------------------------------------------ <br><h3> Answer 3216683 Grant McLean: </h3><p>As you become more experienced with using Perl, you'll find that there are fewer and fewer occasions when you need to run shell commands.  For example, one way to get a list of files is to use Perl's built-in <a href="http://perldoc.perl.org/functions/glob.html" rel="noreferrer">glob</a> function.  If you want the list in sorted order you could combine it with the built-in <a href="http://perldoc.perl.org/functions/sort.html" rel="noreferrer">sort</a> function.  If you want details about each file, you can use the <a href="http://perldoc.perl.org/functions/stat.html" rel="noreferrer">stat</a> function.  Here's an example:</p>

<pre><code>#!/usr/bin/perl

use strict;
use warnings;

foreach my $file ( sort glob('/home/grant/*') ) {
    my($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,$atime,$mtime,$ctime,$blksize,$blocks)
        = stat($file);
    printf("%-40s %8u bytes\n", $file, $size);
}
</code></pre>
<h4> Comment 108857905 M_M: </h4>Obviously this answer doesn&#39;t apply to commands other than <code>ls</code>, but in the case that the user was actually going to call <code>ls</code>, this answer deserves recognition for answering the user&#39;s intention rather than their actual question.<br>------------------------------------------------------------------ <br><h3> Answer 3201000 thegeek: </h3><p>There are a lot of ways you can call a shell command from a Perl script, such as:</p>

<ol>
<li>back tick
       <code>ls</code> which captures the output and gives back to you.</li>
<li>system
       system('ls');</li>
<li>open</li>
</ol>

<p>Refer #17 here: <a href="http://www.thegeekstuff.com/2010/01/20-killer-perl-programming-tips-for-beginners-on-unix-linux-os/" rel="nofollow noreferrer">Perl programming tips</a></p>
------------------------------------------------------------------ <br><h3> Answer 3204931 miedwar: </h3><p>You might want to look into <a href="http://search.cpan.org/~dapm/perl-5.10.1/lib/IPC/Open2.pm" rel="nofollow noreferrer">open2</a> and <a href="http://search.cpan.org/~dapm/perl-5.10.1/lib/IPC/Open3.pm" rel="nofollow noreferrer">open3</a> in case you need bidirectional communication.</p>
------------------------------------------------------------------ <br><h3> Answer 69905356 Ulisses: </h3><p>I have been using system and qq to run linux programs inside perl. And it has worked well.</p>
<pre><code>#!/usr/bin/perl   # A hashbang line in perl
    
use strict;       # It can save you a lot of time and headache
use warnings;     # It helps you find typing mistakes

# my keyword in Perl declares the listed variable

my $adduser = '/usr/sbin/adduser';
my $edquota = '/usr/sbin/edquota';
my $chage = '/usr/bin/chage';
my $quota = '/usr/bin/quota';
my $nomeinteiro;
my $username;
my $home;


# system() function executes a system shell command
# qq() can be used in place of double quotes

system qq($adduser --home $home --gecos &quot;$fullname&quot; $username);
system qq($edquota -p john $username);
system qq($chage -E \$(date -d +180days +%Y-%m-%d) $username);
system qq($chage -l $username);
system qq($quota -s $username);

</code></pre>
<h4> Comment 123609838 holydragon: </h4>The answer would be more useful if you can add some explanation along with the code.<br><h4> Comment 123648444 Ulisses: </h4>Thanks for the review. now I put more comments to get a better understanding.<br>