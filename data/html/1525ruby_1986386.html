 <h2> Title: How to check if a value exists in an array in Ruby </h2> <h3> user211662, question_id: 1986386 </h3>Score: 1525, Tags: {ruby,arrays} <br><p>I have a value <code>'Dog'</code> and an array <code>['Cat', 'Dog', 'Bird']</code>. </p>

<p>How do I check if it exists in the array without looping through it? Is there a simple way of checking if the value exists, nothing more?</p>
<h4> Comment 58146672 Jwan622: </h4>use the <a href="http://ruby-doc.org/core-2.2.0/Array.html#method-i-include-3F" rel="nofollow noreferrer">.include? method</a>. It returns a boolean which is what you want. In your case just type: [&#39;Cat&#39;, &#39;Dog&#39;, &#39;Bird&#39;].include(&#39;Dog&#39;) and it should return the boolean true.<br><h4> Comment 77447969 Tim M.: </h4>You can&#39;t really do it totally &quot;without looping through it&quot;. It&#39;s logically impossible, the computer just can&#39;t know for sure whether the array contains the element without looping through the elements to check if any of them are the one it is searching for. Unless it&#39;s empty, of course. Then I guess you don&#39;t need a loop.<br><h4> Comment 106865755 the Tin Man: </h4>See the benchmarks below for tests of the difference of the various ways to find an element in an Array and a Set. <a href="https://stackoverflow.com/a/60404934/128421">stackoverflow.com/a/60404934/128421</a><br><h4> Comment 74421723 aqfaridi: </h4>dont use <a href="https://apidock.com/ruby/Array/include%3F" rel="nofollow noreferrer">include?</a>  method if you want to check multiples times for different value to be present in array or not because include? each time will iterate over array taking O(n) operation to search each time, Instead make a hash <code>hash = arr.map {|x| [x,true]}.to_h</code>, now check whether <code>hash.has_key? &#39;Dog&#39; </code>returns true or not<br>------------------------------------------------------------------ <br><h3> Answer 1986398 Brian Campbell: </h3><p>You're looking for <a href="http://ruby-doc.org/core-2.3.1/Array.html#method-i-include-3F" rel="noreferrer"><code>include?</code></a>:</p>

<pre><code>&gt;&gt; ['Cat', 'Dog', 'Bird'].include? 'Dog'
=&gt; true
</code></pre>
<h4> Comment 28516351 Henley Wing Chiu: </h4>Sometimes I wish it was &quot;contains&quot; not include. I always get it mixed up with includes.<br><h4> Comment 19225340 scarver2: </h4>Alternate syntax: <code>%w(Cat Dog Bird).include? &#39;Dog&#39;</code><br><h4> Comment 30829092 Boris Stitnicky: </h4>Let me just note that internally, <code>#include?</code> still does perform looping. The coder is saved from writing the loop explicitly, though. I have added an answer that performs the task truly without looping.<br><h4> Comment 36599303 user1115652: </h4>@HenleyChiu I which it was called <code>[ &#39;Dog&#39;, &#39;Bird&#39;, &#39;Cat&#39; ].has? &#39;Dog&#39;</code><br><h4> Comment 66179036 Brian Campbell: </h4>@AlfonsoVergara Yes, any solution for an array must do some sort of looping internally; there is no way to test for membership of an array without looping. If you don&#39;t want to do any looping even internally, you need to use a different data structure, such as a perfect hash table with fixed sized keys. Given  that there&#39;s no way to test for membership in an array without looping internally, I interpreted the question to mean &quot;without having to write the loop explicitly myself&quot;<br><h4> Comment 57657759 Kunok: </h4>@HenleyChiu Good thing about Ruby is that you can create your own methods on any class. So just find (core ruby) class you like, and add method (exact same as include?) to it and then you will be able to use it that way on any object you want.<br><h4> Comment 54285841 Pierre Michard: </h4>@nus Alternate syntax <code>%w(Cat Dog Bird).has? &#39;Dog&#39;</code><br><h4> Comment 97076576 Abhishta Gatya: </h4>is there any difference in <code>include? &#39;Dog&#39;</code> and <code>include?(&#39;Dog&#39;)</code> ?<br><h4> Comment 66163023 Al V: </h4>@BrainCampbell doesn&#39;t the include? method iterate the array?<br><h4> Comment 69587167 Satadru Biswas: </h4>Will this not match any contiguous substring of Dog, Cat and Bird?<br><h4> Comment 77447126 Tim M.: </h4>@SatadruBiswas nope. Just if it contains the full string.<br>------------------------------------------------------------------ <br><h3> Answer 10601055 Marc-Andr&#233; Lafortune: </h3><p>There is an <a href="https://apidock.com/rails/Object/in%3F" rel="noreferrer"><code>in?</code> method</a> in <code>ActiveSupport</code> (part of Rails) since v3.1, as pointed out by @campeterson. So within Rails, or if you <code>require 'active_support'</code>, you can write:</p>
<pre><code>'Unicorn'.in?(['Cat', 'Dog', 'Bird']) # =&gt; false
</code></pre>
<p>OTOH, there is no <code>in</code> operator or <code>#in?</code> method in Ruby itself, even though it has been proposed before, <a href="http://bugs.ruby-lang.org/issues/3845" rel="noreferrer">in particular by Yusuke Endoh</a> a top notch member of ruby-core.</p>
<p>As pointed out by others, the reverse method <a href="http://www.ruby-doc.org/core-1.9.3/Array.html#method-i-include-3F" rel="noreferrer"><code>include?</code></a> exists, for all <code>Enumerable</code>s including <code>Array</code>, <code>Hash</code>, <code>Set</code>, <code>Range</code>:</p>
<pre><code>['Cat', 'Dog', 'Bird'].include?('Unicorn') # =&gt; false
</code></pre>
<hr />
<p>Note that if you have many values in your array, they will all be checked one after the other (i.e. <code>O(n)</code>), while that lookup for a hash will be constant time (i.e <code>O(1)</code>). So if you array is constant, for example, it is a good idea to use a <a href="http://ruby-doc.org/stdlib-2.2.2/libdoc/set/rdoc/Set.html" rel="noreferrer">Set</a> instead. E.g:</p>
<pre><code>require 'set'
ALLOWED_METHODS = Set[:to_s, :to_i, :upcase, :downcase
                       # etc
                     ]

def foo(what)
  raise &quot;Not allowed&quot; unless ALLOWED_METHODS.include?(what.to_sym)
  bar.send(what)
end
</code></pre>
<p>A <a href="http://pastie.org/3913273" rel="noreferrer">quick test</a> reveals that calling <code>include?</code> on a 10 element <code>Set</code> is about 3.5x faster  than calling it on the equivalent <code>Array</code> (if the element is not found).</p>
<p>A final closing note: be wary when using <code>include?</code> on a <code>Range</code>, there are subtleties, so refer to <a href="http://ruby-doc.org/core-1.9.3/Range.html#method-i-include-3F" rel="noreferrer">the doc</a> and compare with <a href="http://ruby-doc.org/core-1.9.3/Range.html#method-i-cover-3F" rel="noreferrer"><code>cover?</code></a>...</p>
<h4> Comment 26962347 campeterson: </h4>While Ruby doesn&#39;t include <code>#in?</code> in it&#39;s core, if you are using Rails, it is available. <a href="http://api.rubyonrails.org/classes/Object.html#method-i-in-3F" rel="nofollow noreferrer">api.rubyonrails.org/classes/Object.html#method-i-in-3F</a> (I know  this is a Ruby, not a Rails question, but it may help anyone looking to use <code>#in?</code> in Rails. Looks like it was added in Rails 3.1 <a href="http://apidock.com/rails/Object/in%3F" rel="nofollow noreferrer">apidock.com/rails/Object/in%3F</a><br><h4> Comment 118667446 lindes: </h4>Thank you, specifically, for including commentary on the fact that the questioners original point of figuring out if something is in an array &quot;without looping through it&quot; is impossible, even if the loop may be hidden away behind an easy method call like <code>Array#include?</code> -- and how to <i>actually</i> avoid such (using <code>Set</code>), should that be important.  This answer gets my up-vote, even though I might have left the bit about <code>in?</code> as an aside at the end.<br>------------------------------------------------------------------ <br><h3> Answer 1986405 schmitzelburger: </h3><p>Try</p>

<pre><code>['Cat', 'Dog', 'Bird'].include?('Dog')
</code></pre>
------------------------------------------------------------------ <br><h3> Answer 10672159 Xiaofan Hu: </h3><p>If you want to check by a block, you could try <code>any?</code> or <code>all?</code>.  </p>

<pre><code>%w{ant bear cat}.any? {|word| word.length &gt;= 3}   #=&gt; true  
%w{ant bear cat}.any? {|word| word.length &gt;= 4}   #=&gt; true  
[ nil, true, 99 ].any?                            #=&gt; true  
</code></pre>

<p>See <a href="http://ruby-doc.org/core-1.9.3/Enumerable.html" rel="noreferrer">Enumerable</a> for more information.</p>

<p>My inspiration came from "<a href="https://stackoverflow.com/questions/10342653/evaluate-if-array-has-any-items-in-ruby/10342734#10342734">evaluate if array has any items in ruby</a>"</p>
<h4> Comment 15113483 thanikkal: </h4>Very useful if you want check any/all of those string is included in another string/constant<br>------------------------------------------------------------------ <br><h3> Answer 41325300 akuhn: </h3><p>Ruby has eleven methods to find elements in an array.</p>

<p>The preferred one is <code>include?</code> or, for repeated access, creat a Set and then call <code>include?</code> or <code>member?</code>.</p>

<p>Here are all of them:</p>

<pre><code>array.include?(element) # preferred method
array.member?(element)
array.to_set.include?(element)
array.to_set.member?(element)
array.index(element) &gt; 0
array.find_index(element) &gt; 0
array.index { |each| each == element } &gt; 0
array.find_index { |each| each == element } &gt; 0
array.any? { |each| each == element }
array.find { |each| each == element } != nil
array.detect { |each| each == element } != nil
</code></pre>

<p>They all return a <code>true</code>ish value if the element is present. </p>

<p><code>include?</code> is the preferred method. It uses a C-language <code>for</code> loop internally that breaks when an element matches the internal <code>rb_equal_opt/rb_equal</code> functions. It cannot get much more efficient unless you create a Set for repeated membership checks.</p>

<pre><code>VALUE
rb_ary_includes(VALUE ary, VALUE item)
{
  long i;
  VALUE e;

  for (i=0; i&lt;RARRAY_LEN(ary); i++) {
    e = RARRAY_AREF(ary, i);
    switch (rb_equal_opt(e, item)) {
      case Qundef:
        if (rb_equal(e, item)) return Qtrue;
        break;
      case Qtrue:
        return Qtrue;
    }
  }
  return Qfalse;
}
</code></pre>

<p><code>member?</code> is not redefined in the <code>Array</code> class and uses an unoptimized implementation from the <code>Enumerable</code> module that literally enumerates through all elements:</p>

<pre><code>static VALUE
member_i(RB_BLOCK_CALL_FUNC_ARGLIST(iter, args))
{
  struct MEMO *memo = MEMO_CAST(args);

  if (rb_equal(rb_enum_values_pack(argc, argv), memo-&gt;v1)) {
    MEMO_V2_SET(memo, Qtrue);
    rb_iter_break();
  }
  return Qnil;
}

static VALUE
enum_member(VALUE obj, VALUE val)
{
  struct MEMO *memo = MEMO_NEW(val, Qfalse, 0);

  rb_block_call(obj, id_each, 0, 0, member_i, (VALUE)memo);
  return memo-&gt;v2;
}
</code></pre>

<p>Translated to Ruby code this does about the following:</p>

<pre><code>def member?(value)
  memo = [value, false, 0]
  each_with_object(memo) do |each, memo|
    if each == memo[0]
      memo[1] = true 
      break
    end
  memo[1]
end
</code></pre>

<p>Both <code>include?</code> and <code>member?</code> have O(n) time complexity since the both search the array for the first occurrence of the expected value. </p>

<p>We can use a Set to get O(1) access time at the cost of having to create a Hash representation of the array first. If you repeatedly check membership on the same array this initial investment can pay off quickly. <code>Set</code> is not implemented in C but as plain Ruby class, still the O(1) access time of the underlying <code>@hash</code> makes this worthwhile.</p>

<p>Here is the implementation of the Set class:</p>

<pre><code>module Enumerable
  def to_set(klass = Set, *args, &amp;block)
    klass.new(self, *args, &amp;block)
  end
end

class Set
  def initialize(enum = nil, &amp;block) # :yields: o
    @hash ||= Hash.new
    enum.nil? and return
    if block
      do_with_enum(enum) { |o| add(block[o]) }
    else
      merge(enum)
    end
  end

  def merge(enum)
    if enum.instance_of?(self.class)
      @hash.update(enum.instance_variable_get(:@hash))
    else
      do_with_enum(enum) { |o| add(o) }
    end
    self
  end

  def add(o)
    @hash[o] = true
    self
  end

  def include?(o)
    @hash.include?(o)
  end
  alias member? include?

  ...
end
</code></pre>

<p>As you can see the Set class just creates an internal <code>@hash</code> instance, maps all objects to <code>true</code> and then checks membership using <code>Hash#include?</code> which is implemented with O(1) access time in the Hash class.</p>

<p>I won't discuss the other seven methods as they are all less efficient.</p>

<p>There are actually even more methods with O(n) complexity beyond the 11 listed above, but I decided to not list them since they scan the entire array rather than breaking at the first match. </p>

<p>Don't use these:</p>

<pre><code># bad examples
array.grep(element).any? 
array.select { |each| each == element }.size &gt; 0
...
</code></pre>
<h4> Comment 90116329 Cary Swoveland: </h4>How brazen to say that Ruby has exactly 11 ways to do anything! No sooner than you say that someone will point out that you missed #12, then #13, and so on. To make my point I will suggest other ways, but first let me question the <code>11</code> ways you have enumerated. First, you can hardly count <code>index</code> and <code>find_index</code> (or <code>find</code> and <code>detect</code>) as separate methods, as they are just different names for the same method.  Secondly, all the expressions that end with <code>&gt; 0</code> are incorrect, which I&#39;m sure was an oversight. (cont.)<br><h4> Comment 90116407 Cary Swoveland: </h4>...<code>arr.index(e)</code>, for example, returns <code>0</code> if <code>arr[0] == e</code>. You will recall <code>arr.index(e)</code> returns <code>nil</code> if <code>e</code> is not present. <code>index</code> cannot be used, however, if  one is searching for <code>nil</code> in <code>arr</code>. (Same problem with <code>rindex</code>, which is not listed.). Converting the array to a set and then employ set methods is a bit of stretch. Why not then convert to a hash (with keys from the array and arbitrary values), then use hash methods? Even if converting to a set is OK, there are other set methods that could be used, such as <code>!arr.to_set.add?(e)</code>. (cont.)<br><h4> Comment 106029035 the Tin Man: </h4>I&#39;d highly recommend using a <a href="https://ruby-doc.org/stdlib-2.7.0/libdoc/set/rdoc/Set.html" rel="nofollow noreferrer">Set</a> if the criteria is that no duplicates are allowed, and knowing whether a particular element exists in the list. Set is SOooo much faster. Arrays really shouldn&#39;t be used when searching is needed; They&#39;re better used as a queue where things are temporarily stored to be processed in order. Hash and Set are better for looking to see if something exists.<br><h4> Comment 125307050 not2qubit: </h4><code>some_array.exclude?(&#39;some_string&#39;)</code> is also useful.<br><h4> Comment 90116528 Cary Swoveland: </h4>...As promised, here are are a few more methods that could be used: <code>arr.count(e) &gt; 0</code>, <code>arr != arr.dup.delete(e) </code>, <code>arr != arr - [e]</code> and <code>arr &amp; [e] == [e]</code>. One could also employ <code>select</code> and <code>reject</code>.<br>------------------------------------------------------------------ <br><h3> Answer 1986404 DigitalRoss: </h3><p>Use <code>Enumerable#include</code>:</p>

<pre><code>a = %w/Cat Dog Bird/

a.include? 'Dog'
</code></pre>

<p>Or, if a number of tests are done,<sup>1</sup> you can get rid of the loop (that even <code>include?</code> has) and go from <em>O(n)</em> to <em>O(1)</em> with:</p>

<pre><code>h = Hash[[a, a].transpose]
h['Dog']
</code></pre>

<p><hr>
<sup>1. I hope this is obvious but to head off objections: yes, for just a few lookups, the Hash[] and transpose ops dominate the profile and are each <em>O(n)</em> themselves.</sup></p>
------------------------------------------------------------------ <br><h3> Answer 17028531 Boris Stitnicky: </h3><p>Several answers suggest <code>Array#include?</code>, but there is one important caveat: Looking at the source, even <code>Array#include?</code> does perform looping:</p>

<pre><code>rb_ary_includes(VALUE ary, VALUE item)
{
    long i;

    for (i=0; i&lt;RARRAY_LEN(ary); i++) {
        if (rb_equal(RARRAY_AREF(ary, i), item)) {
            return Qtrue;
        }
    }
    return Qfalse;
}
</code></pre>

<p>The way to test the word presence without looping is by constructing a <em>trie</em> for your array. There are many trie implementations out there (google "ruby trie"). I will use <code>rambling-trie</code> in this example: </p>

<pre><code>a = %w/cat dog bird/

require 'rambling-trie' # if necessary, gem install rambling-trie
trie = Rambling::Trie.create { |trie| a.each do |e| trie &lt;&lt; e end }
</code></pre>

<p>And now we are ready to test the presence of various words in your array without looping over it, in <code>O(log n)</code> time, with same syntactic simplicity as <code>Array#include?</code>, using sublinear <code>Trie#include?</code>:</p>

<pre><code>trie.include? 'bird' #=&gt; true
trie.include? 'duck' #=&gt; false
</code></pre>
<h4> Comment 30832997 Brian Campbell: </h4>Note that this does actually include a loop; anything that&#39;s not O(1) includes some kind of loop. It just happens to be a loop over the characters of the input string. Also note than an answer already mentioned <code>Set#include?</code> for people who are concerned about efficiency; coupled with using symbols instead of strings, it can be O(1) average case (if you use strings, then just computing the hash is O(n) where n is the length of the string). Or if you want to use third party libraries, you can use a perfect hash which is O(1) worst case.<br><h4> Comment 32928837 speakingcode: </h4>The cost of creating and maintaining the trie is just as much. If you are doing many search operations on the array, then the memory and time cost of populating a trie and maintaining it is worth it, but for single, or even hundreds or thousands of checks, O(n) is perfectly suitable. Another option that doesn&#39;t require adding dependencies would be to sort the array or maintain it in sorted order, in which case a binary search O(lg n) operation can be used to check inclusion.<br><h4> Comment 30804875 tckmn: </h4><code>a.each do ... end</code> Umm... not sure how that&#39;s not a loop<br><h4> Comment 32698913 Uri Agassi: </h4>AFAIK, <code>Set</code> uses hashes to index its members, so actually <code>Set#include?</code> <i>should</i> be of complexity O(1) for a well-distributed <code>Set</code> (more specifically O(input-size) for the hashing, and O(log(n/bucket-number)) for the searching)<br><h4> Comment 30829041 Boris Stitnicky: </h4>That loop is performed only once, when the trie is constructed. It is a constant term that does not influence the algorithmic complexity. Bluntly, the algorithm <i>has to</i> loop through the array at least <i>once</i> to know what words are there at all. Once the trie is constructed, it can be used many times to check for the presence of a word with roughly logarithmic complexity.<br><h4> Comment 32932043 Boris Stitnicky: </h4>@speakingcode, you may be right from the pragmatic point of view. But the OP asks to &quot;check if the value exists, nothing more, without looping&quot;. When I wrote this answer, there were many pragmatic solutions here, but none that would actually meet the asker&#39;s literal requirement. Your observation that BSTs are related to tries is correct, but for strings, trie is the right tool for the job, <a href="https://en.wikipedia.org/wiki/Trie#Algorithms" rel="nofollow noreferrer">even Wikipedia knows that much</a>. Complexity of constructing and maintaing a well-implemented trie is surprisinly favorable.<br><h4> Comment 129425923 Chris: </h4>Opinion, but maybe: <code>a.each_with_object(Rambling::Trie.create) { |w, t| t &lt;&lt; w }</code> to set up your trie?<br><h4> Comment 30836097 Boris Stitnicky: </h4>Nice comment. I have not noticed <code>Set#include</code> and I am not aware (yet) about how is it implemented. I have also not analyzed the code of <code>rambling-trie</code> which I have randomly chosen for my example, so I cannot guarantee that its implementation is not flawed. In any case, with a well-implemented trie complexity should be about O(log n). Complexity O(1) is theoretically not possible, but can be achieved pragmatically for <code>n</code> smaller than certain finite number, which is hardware-dependent.<br>------------------------------------------------------------------ <br><h3> Answer 23941897 Kimmo Lehto: </h3><p>If you don't want to loop, there's no way to do it with Arrays. You should use a Set instead.</p>

<pre><code>require 'set'
s = Set.new
100.times{|i| s &lt;&lt; "foo#{i}"}
s.include?("foo99")
 =&gt; true
[1,2,3,4,5,6,7,8].to_set.include?(4) 
  =&gt; true
</code></pre>

<p>Sets work internally like Hashes, so Ruby doesn't need to loop through the collection to find items, since as the name implies, it generates hashes of the keys and creates a memory map so that each hash points to a certain point in memory. The previous example done with a Hash:</p>

<pre><code>fake_array = {}
100.times{|i| fake_array["foo#{i}"] = 1}
fake_array.has_key?("foo99")
  =&gt; true
</code></pre>

<p>The downside is that Sets and Hash keys can only include unique items and if you add a lot of items, Ruby will have to rehash the whole thing after certain number of items to build a new map that suits a larger keyspace. For more about this, I recommend you watch "<a href="https://www.youtube.com/watch?v=NMwyWBtSiGM" rel="nofollow noreferrer">MountainWest RubyConf 2014 - Big O in a Homemade Hash by Nathan Long</a>".</p>

<p>Here's a benchmark:</p>

<pre><code>require 'benchmark'
require 'set'

array = []
set   = Set.new

10_000.times do |i|
  array &lt;&lt; "foo#{i}"
  set   &lt;&lt; "foo#{i}"
end

Benchmark.bm do |x|
  x.report("array") { 10_000.times { array.include?("foo9999") } }
  x.report("set  ") { 10_000.times { set.include?("foo9999")   } }
end
</code></pre>

<p>And the results:</p>

<pre><code>      user     system      total        real
array  7.020000   0.000000   7.020000 (  7.031525)
set    0.010000   0.000000   0.010000 (  0.004816)
</code></pre>
<h4> Comment 106029173 the Tin Man: </h4><code>include?</code> stops at the first hit but if that hit is at the end of the list.... Any solution that relies on an Array for storage will have degrading performance as the list grows, especially when having to find an element at the end of the list. Hash and Set don&#39;t have that problem, nor would an ordered list and a binary-search.<br><h4> Comment 39087648 Kimmo Lehto: </h4>@aenw doesn&#39;t <code>include?</code> stop at first hit?<br><h4> Comment 39156049 aenw: </h4>you&#39;re absolutely right.  I&#39;m so used to using detect that I&#39;d forgotten that about include.  thanks for your comment - it ensured that I refreshed my knowledge.<br><h4> Comment 38722086 aenw: </h4>If you use detect, then you can at least reduce the looping.  detect will stop at the first item &#39;detected&#39; (the block passed for the item evaluates to true).  In addition, you can tell detect what to do if nothing is detected (you can pass in a lambda).<br><h4> Comment 106117257 Kimmo Lehto: </h4>That is pretty much what this answer was about in the first place :)<br>------------------------------------------------------------------ <br><h3> Answer 19142964 Zack Xu: </h3><p>This is another way to do this: use the <code>Array#index</code> method.</p>

<p>It returns the index of the first occurrence of the element in the array.</p>

<p>For example:</p>

<pre><code>a = ['cat','dog','horse']
if a.index('dog')
    puts "dog exists in the array"
end
</code></pre>

<p><code>index()</code> can also take a block:</p>

<p>For example:</p>

<pre><code>a = ['cat','dog','horse']
puts a.index {|x| x.match /o/}
</code></pre>

<p>This returns the index of the first word in the array that contains the letter 'o'.</p>
<h4> Comment 57559584 the Tin Man: </h4><code>index</code> still iterates over the array, it just returns the value of the element.<br>------------------------------------------------------------------ <br><h3> Answer 69766150 H&#224; Tiến Đạt: </h3><p><strong>Check exists</strong></p>
<p>Use <code>include?</code></p>
<p>Example:</p>
<pre><code>arr = [1, 2, 3]
arr.include?(1) -&gt; true
arr.include?(4) -&gt; false
</code></pre>
<p><strong>Check does not exist</strong></p>
<p>Use <code>exclude?</code></p>
<p>Example:</p>
<pre><code>arr = %w(vietnam china japan)
arr.exclude?('usa') -&gt; true
arr.exclude?('china') -&gt; false
</code></pre>
<h4> Comment 125306980 not2qubit: </h4><code>*.include?(&quot;some-string&quot;)</code> also works for <i>exact</i> string matches of an array item.<br>------------------------------------------------------------------ <br><h3> Answer 41325331 akuhn: </h3><p>Fun fact, </p>

<p>You can use <code>*</code> to check array membership in a <code>case</code> expressions. </p>

<pre><code>case element
when *array 
  ...
else
  ...
end
</code></pre>

<p>Notice the little <code>*</code> in the when clause, this checks for membership in the array. </p>

<p>All the usual magic behavior of the splat operator applies, so for example if <code>array</code> is not actually an array but a single element it will match that element.</p>
<h4> Comment 90720161 Cary Swoveland: </h4>Good to know..!<br><h4> Comment 106273398 the Tin Man: </h4>It&#39;d also be a slow first check in a case statement, so I&#39;d use it in the last <code>when</code> possible so other, faster checks, get weeded out quickly.<br>------------------------------------------------------------------ <br><h3> Answer 36935586 sumit: </h3><p>There are multiple ways to accomplish this. A few of them are as follows:</p>

<pre><code>a = [1,2,3,4,5]

2.in? a  #=&gt; true

8.in? a #=&gt; false

a.member? 1 #=&gt; true

a.member? 8 #=&gt; false
</code></pre>
<h4> Comment 64195452 Tom Lord: </h4>Note that <code>Object#in?</code> was only added to Rails (i.e. <code>ActiveSupport</code>) v3.1+. It is not available in core Ruby.<br>------------------------------------------------------------------ <br><h3> Answer 22916211 Daniel Antonio Nu&#241;ez Carhuayo: </h3><p>You can try:</p>

<p>Example: if Cat and Dog exist in the array:</p>

<pre><code>(['Cat','Dog','Bird'] &amp; ['Cat','Dog'] ).size == 2   #or replace 2 with ['Cat','Dog].size
</code></pre>

<p>Instead of:</p>

<pre><code>['Cat','Dog','Bird'].member?('Cat') and ['Cat','Dog','Bird'].include?('Dog')
</code></pre>

<p>Note: <code>member?</code> and <code>include?</code> are the same.</p>

<p>This can do the work in one line!</p>
------------------------------------------------------------------ <br><h3> Answer 23091602 user3245240: </h3><p>This will tell you not only that it exists but also how many times it appears:</p>

<pre><code> a = ['Cat', 'Dog', 'Bird']
 a.count("Dog")
 #=&gt; 1
</code></pre>
<h4> Comment 38816232 Zaz: </h4>There&#39;s no sense in using this unless you want to know how many times it appears, though, as <code>.any?</code> will return as soon as it finds the first matching element, <code>.count</code> will always process the entire array.<br><h4> Comment 106029280 the Tin Man: </h4>While this technically will tell whether something exists, it&#39;s also <i>NOT</i> the right way to do it if you care about speed.<br>------------------------------------------------------------------ <br><h3> Answer 43687751 aqfaridi: </h3><p>If you need to check multiples times for any key, convert <code>arr</code> to <code>hash</code>, and now check in O(1) </p>

<pre><code>arr = ['Cat', 'Dog', 'Bird']
hash = arr.map {|x| [x,true]}.to_h
 =&gt; {"Cat"=&gt;true, "Dog"=&gt;true, "Bird"=&gt;true}
hash["Dog"]
 =&gt; true
hash["Insect"]
 =&gt; false
</code></pre>

<p><strong>Performance of <a href="https://apidock.com/ruby/Hash/has_key%3F" rel="nofollow noreferrer">Hash#has_key?</a> versus <a href="https://apidock.com/ruby/Array/include%3F" rel="nofollow noreferrer">Array#include?</a></strong></p>

<pre>
Parameter              Hash#has_key?                 Array#include 

Time Complexity         O(1) operation                O(n) operation 

Access Type             Accesses Hash[key] if it      Iterates through each element
                        returns any value then        of the array till it
                        true is returned to the       finds the value in Array
                        Hash#has_key? call
                        call    
</pre>

<p>For single time check using <code>include?</code> is fine</p>
<h4> Comment 74421859 aqfaridi: </h4>yes, i did but now i have pre-computed answer to check whether any element exist in array or not. Now, next time when i search for other word, it will take O(1) for query, right although pre-computation will take O(n). Actually i have used include? in my application inside loop for checking whether particular element exist in the array or not, it ruins the performance, it checked in ruby-prof, that was the bottleneck<br><h4> Comment 75677719 Rambatino: </h4>....but O(n) space and also, no it&#39;s O(n) time, because as @chris72205 rightly points out, you have to iterate through your array first. O(1) + O(n) = O(n). So in fact, this is way worse than include?<br><h4> Comment 74421750 chrisjacob: </h4>Are you not still looping through the array to convert it to a hash?<br><h4> Comment 106029343 the Tin Man: </h4>Converting an array to a hash is costly, but using an array for searching is the wrong structure. Arrays are better as queues where order might be important; Hashes and Sets are better when inclusion/existence/uniqueness are important. Start with the right container and the problem is moot.<br><h4> Comment 75678218 aqfaridi: </h4>Dude i was just saying dont use include inside loop, for single time check using include is fine. So please read the use case first, its better if you need to check multiple times inside loop.<br>------------------------------------------------------------------ <br><h3> Answer 17961387 davissp14: </h3><p>For what it's worth, The <a href="http://ruby-doc.org/core-2.0/Array.html" rel="nofollow noreferrer">Ruby docs</a> are an amazing resource for these kinds of questions.</p>

<p>I would also take note of the length of the array you're searching through. The <code>include?</code> method will run a linear search with O(n) complexity which can get pretty ugly depending on the size of the array. </p>

<p>If you're working with a large (sorted) array, I would consider writing a <a href="http://en.wikipedia.org/wiki/Binary_search_algorithm" rel="nofollow noreferrer">binary search algorithm</a> which shouldn't be too difficult and has a worst case of O(log n). </p>

<p>Or if you're using Ruby 2.0, you can take advantage of <code>bsearch</code>.</p>
<h4> Comment 57559694 the Tin Man: </h4>A binary search assumes the array is sorted (or ordered in some form) which can be costly for large arrays, often negating the advantage.<br><h4> Comment 90719440 davissp14: </h4>@CarySwoveland it should be more or less implied that the elements within a sorted array are comparable.<br><h4> Comment 90116584 Cary Swoveland: </h4>A binary search also requires all pairs of elements to be comparable with <code>&lt;=&gt;</code>, which is not always the case. Suppose, for example, the elements of the array were hashes.<br>------------------------------------------------------------------ <br><h3> Answer 21900925 xlembouras: </h3><p>If we want to not use <code>include?</code> this also works:</p>

<pre><code>['cat','dog','horse'].select{ |x| x == 'dog' }.any?
</code></pre>
<h4> Comment 42129210 maikonas: </h4>any? also accepts blocks:          [&#39;cat&#39;,&#39;dog&#39;,&#39;horse&#39;].any? { |x| x == &#39;dog&#39; }<br>------------------------------------------------------------------ <br><h3> Answer 25384313 ajahongir: </h3><p>How about this way?</p>

<pre class="lang-rb prettyprint-override"><code>['Cat', 'Dog', 'Bird'].index('Dog')
</code></pre>
<h4> Comment 57559527 the Tin Man: </h4>It&#39;s still going to iterate over the array just to find the element. Then it has to return the index of that element.<br>------------------------------------------------------------------ <br><h3> Answer 40845772 Rahul Patel: </h3><pre><code>['Cat', 'Dog', 'Bird'].detect { |x| x == 'Dog'}
=&gt; "Dog"
!['Cat', 'Dog', 'Bird'].detect { |x| x == 'Dog'}.nil?
=&gt; true
</code></pre>
<h4> Comment 90115897 Cary Swoveland: </h4><code>[&#39;Cat&#39;, nil, &#39;Dog&#39;].detect { |x| x == nil } #=&gt; nil</code>. Was <code>nil</code> found?<br>------------------------------------------------------------------ <br><h3> Answer 12897444 walt_die: </h3><p>There's the other way around this.</p>

<p>Suppose the array is <code>[ :edit, :update, :create, :show ]</code>, well perhaps the entire <em>seven deadly/restful sins</em>.</p>

<p>And further toy with the idea of <em>pulling</em> a valid action from some string:</p>

<pre><code>"my brother would like me to update his profile"
</code></pre>

<p>Then:</p>

<pre><code>[ :edit, :update, :create, :show ].select{|v| v if "my brother would like me to update his profile".downcase =~ /[,|.| |]#{v.to_s}[,|.| |]/}
</code></pre>
<h4> Comment 75496027 bkDJ: </h4>Your regex, <code>&#47;[,|.| |]#{v.to_s}[,|.| |]&#47;</code>, makes me think you wanted to find &#39;the name of the action surrounded by one of: comma, period, space, or nothing at all&#39;, but there are some subtle bugs. <code>&quot;|update|&quot;</code> would return <code>[:update]</code> and <code>&quot;update&quot;</code> would return <code>[]</code>. Character classes (<code>[...]</code>) don&#39;t use pipes (<code>|</code>) to separate characters. Even if we change them to groups (<code>(...)</code>), you can&#39;t match an empty character. So the regex you probably wanted is <code>&#47;(,|\.| |^)#{v.to_s}(,|\.| |$)&#47;</code><br><h4> Comment 77626063 bkDJ: </h4>&quot;the regex is ok (checked rubular.com)&quot;. It is not ok. Your regex will not match a keyword at the beginning or end of a string (e.g. &quot;update my brother&#39;s profile&quot;). If you don&#39;t want to match the beginning or end, then your regex is still not ok because the character class to either side of the keyword should be <code>&#47;[,. ]&#47;</code><br><h4> Comment 106029611 the Tin Man: </h4>As @bkDJ says, the regex is wrong. <a href="https://rubular.com/r/4EG04rANz6KET6" rel="nofollow noreferrer">rubular.com/r/4EG04rANz6KET6</a><br><h4> Comment 75669449 walt_die: </h4>the regex is ok (checked rubular.com)   - and @Rambatino: the why would be like Amazon Echo for instance ;) You could say: &quot;please add chicken to my shopping list&quot; (and - well - then you&#39;d have to add the :add to the array, but I reckon you get the gist of it ;)<br>------------------------------------------------------------------ <br><h3> Answer 54790703 Jon Schneider: </h3><p>If you're trying to do this in a <a href="https://github.com/seattlerb/minitest" rel="nofollow noreferrer">MiniTest</a> unit test, you can use <a href="https://www.rubydoc.info/github/test-unit/test-unit/Test%2FUnit%2FAssertions:assert_include" rel="nofollow noreferrer"><code>assert_includes</code></a>. Example:</p>

<pre><code>pets = ['Cat', 'Dog', 'Bird']
assert_includes(pets, 'Dog')      # -&gt; passes
assert_includes(pets, 'Zebra')    # -&gt; fails 
</code></pre>
------------------------------------------------------------------ <br><h3> Answer 60404934 the Tin Man: </h3><p>I always find it interesting to run some benchmarks to see the relative speed of the various ways of doing something.</p>

<p>Finding an array element at the start, middle or end will affect any linear searches but barely affect a search against a Set.</p>

<p>Converting an Array to a Set is going to cause a hit in processing time, so create the Set from an Array once, or start with a Set from the very beginning.</p>

<p>Here's the benchmark code:</p>

<pre><code># frozen_string_literal: true

require 'fruity'
require 'set'

ARRAY = (1..20_000).to_a
SET = ARRAY.to_set

DIVIDER = '-' * 20

def array_include?(elem)
  ARRAY.include?(elem)
end

def array_member?(elem)
  ARRAY.member?(elem)
end

def array_index(elem)
  ARRAY.index(elem) &gt;= 0
end

def array_find_index(elem)
  ARRAY.find_index(elem) &gt;= 0
end

def array_index_each(elem)
  ARRAY.index { |each| each == elem } &gt;= 0
end

def array_find_index_each(elem)
  ARRAY.find_index { |each| each == elem } &gt;= 0
end

def array_any_each(elem)
  ARRAY.any? { |each| each == elem }
end

def array_find_each(elem)
  ARRAY.find { |each| each == elem } != nil
end

def array_detect_each(elem)
  ARRAY.detect { |each| each == elem } != nil
end

def set_include?(elem)
  SET.include?(elem)
end

def set_member?(elem)
  SET.member?(elem)
end

puts format('Ruby v.%s', RUBY_VERSION)

{
  'First' =&gt; ARRAY.first,
  'Middle' =&gt; (ARRAY.size / 2).to_i,
  'Last' =&gt; ARRAY.last
}.each do |k, element|
  puts DIVIDER, k, DIVIDER

  compare do
    _array_include?        { array_include?(element)        }
    _array_member?         { array_member?(element)         }
    _array_index           { array_index(element)           }
    _array_find_index      { array_find_index(element)      }
    _array_index_each      { array_index_each(element)      }
    _array_find_index_each { array_find_index_each(element) }
    _array_any_each        { array_any_each(element)        }
    _array_find_each       { array_find_each(element)       }
    _array_detect_each     { array_detect_each(element)     }
  end
end

puts '', DIVIDER, 'Sets vs. Array.include?', DIVIDER
{
  'First' =&gt; ARRAY.first,
  'Middle' =&gt; (ARRAY.size / 2).to_i,
  'Last' =&gt; ARRAY.last
}.each do |k, element|
  puts DIVIDER, k, DIVIDER

  compare do
    _array_include? { array_include?(element) }
    _set_include?   { set_include?(element)   }
    _set_member?    { set_member?(element)    }
  end
end

</code></pre>

<p>Which, when run on my Mac OS laptop, results in:</p>

<pre><code>Ruby v.2.7.0
--------------------
First
--------------------
Running each test 65536 times. Test will take about 5 seconds.
_array_include? is similar to _array_index
_array_index is similar to _array_find_index
_array_find_index is faster than _array_any_each by 2x ± 1.0
_array_any_each is similar to _array_index_each
_array_index_each is similar to _array_find_index_each
_array_find_index_each is faster than _array_member? by 4x ± 1.0
_array_member? is faster than _array_detect_each by 2x ± 1.0
_array_detect_each is similar to _array_find_each
--------------------
Middle
--------------------
Running each test 32 times. Test will take about 2 seconds.
_array_include? is similar to _array_find_index
_array_find_index is similar to _array_index
_array_index is faster than _array_member? by 2x ± 0.1
_array_member? is faster than _array_index_each by 2x ± 0.1
_array_index_each is similar to _array_find_index_each
_array_find_index_each is similar to _array_any_each
_array_any_each is faster than _array_detect_each by 30.000000000000004% ± 10.0%
_array_detect_each is similar to _array_find_each
--------------------
Last
--------------------
Running each test 16 times. Test will take about 2 seconds.
_array_include? is faster than _array_find_index by 10.000000000000009% ± 10.0%
_array_find_index is similar to _array_index
_array_index is faster than _array_member? by 3x ± 0.1
_array_member? is faster than _array_find_index_each by 2x ± 0.1
_array_find_index_each is similar to _array_index_each
_array_index_each is similar to _array_any_each
_array_any_each is faster than _array_detect_each by 30.000000000000004% ± 10.0%
_array_detect_each is similar to _array_find_each

--------------------
Sets vs. Array.include?
--------------------
--------------------
First
--------------------
Running each test 65536 times. Test will take about 1 second.
_array_include? is similar to _set_include?
_set_include? is similar to _set_member?
--------------------
Middle
--------------------
Running each test 65536 times. Test will take about 2 minutes.
_set_member? is similar to _set_include?
_set_include? is faster than _array_include? by 1400x ± 1000.0
--------------------
Last
--------------------
Running each test 65536 times. Test will take about 4 minutes.
_set_member? is similar to _set_include?
_set_include? is faster than _array_include? by 3000x ± 1000.0
</code></pre>

<p>Basically the results tell me to use a Set for everything if I'm going to search for inclusion unless I can guarantee that the first element is the one I want, which isn't very likely. There's some overhead when inserting elements into a hash, but the search times are so much faster I don't think that should ever be a consideration. Again, if you need to search it, don't use an Array, use a Set. (Or a Hash.)</p>

<p>The smaller the Array, the faster the Array methods will run, but they're still not going to keep up, though in small arrays the difference might be tiny.</p>

<p>"First", "Middle" and "Last" reflect the use of <code>first</code>, <code>size / 2</code> and <code>last</code> for <code>ARRAY</code> for the element being searched for. That element will be used when searching the <code>ARRAY</code> and <code>SET</code> variables.</p>

<p>Minor changes were made for the methods that were comparing to <code>&gt; 0</code> because the test should be <code>&gt;= 0</code> for <code>index</code> type tests.</p>

<p>More information about Fruity and its methodology is available in its <a href="https://github.com/marcandre/fruity" rel="nofollow noreferrer">README</a>.</p>
------------------------------------------------------------------ <br><h3> Answer 23671088 mgidea: </h3><p>if you don't want to use <code>include?</code> you can first wrap the element in an array and then check whether the wrapped element is equal to the intersection of the array and the wrapped element.  This will return a boolean value based on equality.</p>

<pre><code>def in_array?(array, item)
    item = [item] unless item.is_a?(Array)
    item == array &amp; item
end
</code></pre>
------------------------------------------------------------------ <br><h3> Answer 54233378 Abhishek kumar: </h3><blockquote>
  <p>it has many ways to find a element in any array but the simplest way is 'in ?' method.</p>
</blockquote>

<pre><code>example:
arr = [1,2,3,4]
number = 1
puts "yes #{number} is present in arr" if number.in? arr
</code></pre>
<h4> Comment 100088818 Patrick: </h4>Note: As described in <a href="https://stackoverflow.com/a/10601055/3017719">this answer</a>, the method <code>in?</code> requires <code>ActiveSupport</code> to be imported: <code>require active_support</code>.<br><h4> Comment 106273495 the Tin Man: </h4>It doesn&#39;t require all of ActiveSupport if you use the <a href="https://edgeguides.rubyonrails.org/active_support_core_extensions.html" rel="nofollow noreferrer">core extensions</a>.<br>------------------------------------------------------------------ <br><h3> Answer 55440604 gitb: </h3><p>If you want to return the value not just true or false, use</p>

<pre><code>array.find{|x| x == 'Dog'}
</code></pre>

<p>This will return 'Dog' if it exists in the list, otherwise nil.</p>
<h4> Comment 100202426 mahemoff: </h4>Or use <code>array.any?{|x| x == &#39;Dog&#39;}</code> if you <i>do</i> want true/false (not the value), but also want to compare against a block like this.<br>------------------------------------------------------------------ <br><h3> Answer 34605942 Wand Maker: </h3><p>Here is one more way to do this:</p>

<pre><code>arr = ['Cat', 'Dog', 'Bird']
e = 'Dog'

present = arr.size != (arr - [e]).size
</code></pre>
<h4> Comment 68920279 jibberia: </h4>This is a horrendously inefficient way to do this! I&#39;m not downvoting because it&#39;s not technically incorrect, and somebody might learn something about Ruby from reading it, but there are many better answers above.<br><h4> Comment 90116657 Cary Swoveland: </h4>Conehead, you can simplify to <code>arr != arr - [e]</code>. <code>arr &amp; [e] == [e]</code> is another way along the same lines.<br><h4> Comment 90126369 Wand Maker: </h4>@CarySwoveland Do not make fun of a wizard&#39;s hat ;-)<br><h4> Comment 90128298 Cary Swoveland: </h4>I was referring to the wizard’s head, not hat, with the greatest of respect.<br>------------------------------------------------------------------ <br><h3> Answer 40857783 Matthew Maurice: </h3><pre><code>array = [ 'Cat', 'Dog', 'Bird' ]
array.include?("Dog")
</code></pre>
------------------------------------------------------------------ <br><h3> Answer 74259669 Ritesh Choudhary: </h3><p>Try below</p>
<pre><code>(['Cat', 'Dog', 'Bird'] &amp; ['Dog']).any?
</code></pre>
