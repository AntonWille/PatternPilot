 <h2> Title: How to map/collect with index in Ruby? </h2> <h3> Misha Moroshko, question_id: 4697557 </h3>Score: 502, Tags: {ruby,arrays,indexing} <br><p>What is the easiest way to convert </p>

<pre><code>[x1, x2, x3, ... , xN]
</code></pre>

<p>to</p>

<pre><code>[[x1, 2], [x2, 3], [x3, 4], ... , [xN, N+1]]
</code></pre>
------------------------------------------------------------------ <br><h3> Answer 4697573 sepp2k: </h3><p>If you're using ruby 1.8.7 or 1.9, you can use the fact that iterator methods like <code>each_with_index</code>, when called without a block, return an <code>Enumerator</code> object, which you can call <code>Enumerable</code> methods like <code>map</code> on. So you can do:</p>

<pre><code>arr.each_with_index.map { |x,i| [x, i+2] }
</code></pre>

<p>In 1.8.6 you can do:</p>

<pre><code>require 'enumerator'
arr.enum_for(:each_with_index).map { |x,i| [x, i+2] }
</code></pre>
<h4> Comment 5183474 Phrogz: </h4>IMO this is simpler and better-reading in 1.8.7+: <code>arr.map.with_index{ |o,i| [o,i+2] }</code><br><h4> Comment 5183496 sepp2k: </h4>@Phrogz: <code>map.with_index</code> doesn&#39;t work in 1.8.7 (<code>map</code> returns an array when called without a block in 1.8).<br><h4> Comment 26083944 Ash Blue: </h4>Important to note this doesn&#39;t work with .map! if you want to directly affect the array you&#39;re looping on.<br><h4> Comment 5183407 sepp2k: </h4>@Misha: <code>map</code> is a method of <code>Enumerable</code> as always. <code>each_with_index</code>, when called without a block, returns an <code>Enumerator</code> object (in 1.8.7+), which mixes in <code>Enumerable</code>, so you can call <code>map</code>, <code>select</code>, <code>reject</code> etc. on it just like on an array, hash, range etc.<br><h4> Comment 67485789 Ekkstein: </h4>x and i is not descriptive enough for the purpose of answering general questions. It might serve you as your personal convention, but I am not certain i refers to index.<br><h4> Comment 18310536 jtzero: </h4>only semi related, this also has some good info on enumerator: <a href="http://www.ruby-forum.com/topic/199584" rel="nofollow noreferrer">ruby-forum.com/topic/199584</a><br><h4> Comment 5183389 Misha Moroshko: </h4>Thanks! Could you give me a pointer to documentation for <code>.each_with_index.map</code> ?<br><h4> Comment 5183393 Misha Moroshko: </h4>In this case <code>map</code> is a function of what ?<br><h4> Comment 5183532 Phrogz: </h4>Oops; good to know. I moved from 1.8.6 to 1.9 and have never seen the use of 1.8.7 since. My apologies to those who use 1.8.7.<br>------------------------------------------------------------------ <br><h3> Answer 11280903 tokland: </h3><p>Ruby has <a href="http://ruby-doc.org/core-2.2.3/Enumerator.html#method-i-with_index" rel="noreferrer">Enumerator#with_index(offset = 0)</a>, so first convert the array to an enumerator using <a href="http://ruby-doc.org/core-2.3.1/Object.html#method-i-to_enum" rel="noreferrer">Object#to_enum</a> or <a href="http://ruby-doc.org/core-2.2.3/Array.html#method-i-map" rel="noreferrer">Array#map</a>:</p>

<pre><code>[:a, :b, :c].map.with_index(2).to_a
#=&gt; [[:a, 2], [:b, 3], [:c, 4]]
</code></pre>
<h4> Comment 33488744 Connor: </h4>I believe this is the better answer, because it will work with map! <code>foo = [&#39;d&#39;] * 5; foo.map!.with_index { |x,i| x * i }; foo #=&gt; [&quot;&quot;, &quot;d&quot;, &quot;dd&quot;, &quot;ddd&quot;, &quot;dddd&quot;]</code><br>------------------------------------------------------------------ <br><h3> Answer 26335283 fruqi: </h3><p>In ruby 1.9.3 there is a chainable method called <code>with_index</code> which can be chained to map.</p>

<p>For example:</p>

<pre><code>array.map.with_index { |item, index| ... }
</code></pre>
------------------------------------------------------------------ <br><h3> Answer 8074701 Andrew Grimm: </h3><p>Over the top obfuscation:</p>

<pre><code>arr = ('a'..'g').to_a
indexes = arr.each_index.map(&amp;2.method(:+))
arr.zip(indexes)
</code></pre>
<h4> Comment 15282308 David J.: </h4>Andrew must have great job security! :)<br>------------------------------------------------------------------ <br><h3> Answer 33395577 yburyug: </h3><p>I have always enjoyed the syntax of this style:</p>

<pre><code>a = [1, 2, 3, 4]
a.each_with_index.map { |el, index| el + index }
# =&gt; [1, 3, 5, 7]
</code></pre>

<p>Invoking <code>each_with_index</code> gets you an enumerator you can easily map over with your index available.</p>
<h4> Comment 62617684 Andrey Deineko: </h4>how is this different form <a href="http://stackoverflow.com/a/4697573/1772830">the answer, given almost 5 years before yours</a>?<br>------------------------------------------------------------------ <br><h3> Answer 4697657 Phrogz: </h3><p>Here are two more options for 1.8.6 (or 1.9) without using enumerator:</p>

<pre><code># Fun with functional
arr = ('a'..'g').to_a
arr.zip( (2..(arr.length+2)).to_a )
#=&gt; [["a", 2], ["b", 3], ["c", 4], ["d", 5], ["e", 6], ["f", 7], ["g", 8]]

# The simplest
n = 1
arr.map{ |c| [c, n+=1 ] }
#=&gt; [["a", 2], ["b", 3], ["c", 4], ["d", 5], ["e", 6], ["f", 7], ["g", 8]]
</code></pre>
------------------------------------------------------------------ <br><h3> Answer 23552543 Automatico: </h3><p>A fun, but useless way to do this:</p>

<pre><code>az  = ('a'..'z').to_a
azz = az.map{|e| [e, az.index(e)+2]}
</code></pre>
<h4> Comment 72656439 Automatico: </h4>As I write <code>A fun, but useless way</code>. <code>+2</code> is to create the output the OP asks for<br><h4> Comment 40251043 Automatico: </h4>Why the hate? It is a functioning way of doing this AND I even say that is is a silly way to achieve the results.<br><h4> Comment 72653324 rogerdpack: </h4>the call to #index means this is now an O(N^2) loop also why the +2 ? :)<br><h4> Comment 123187348 David Ljung Madison Stellar: </h4>Fun and useless is different from &quot;really inefficient and poor programming practice&quot;<br>------------------------------------------------------------------ <br><h3> Answer 14177486 Nikolay Bobrovskiy: </h3><pre><code>a = [1, 2, 3]
p [a, (2...a.size+2).to_a].transpose
</code></pre>
------------------------------------------------------------------ <br><h3> Answer 15270938 Mo Wad: </h3><pre><code>module Enumerable
  def map_with_index(&amp;block)
    i = 0
    self.map { |val|
      val = block.call(val, i)
      i += 1
      val
    }
  end
end

["foo", "bar"].map_with_index {|item, index| [item, index] } =&gt; [["foo", 0], ["bar", 1]]
</code></pre>
<h4> Comment 72653366 rogerdpack: </h4>This might be an easier way to go for 1.8.6 and 1.8.7 (yes some of us still use it) instead of having to use weirder stuff like <code>each_with_index.map</code> etc. and even those of us on newer versions might prefer it to having to use map.with_index FWIW :)<br>------------------------------------------------------------------ <br><h3> Answer 20207527 grandinero: </h3><p>I often do this:</p>

<pre><code>arr = ["a", "b", "c"]

(0...arr.length).map do |int|
  [arr[int], int + 2]
end

#=&gt; [["a", 2], ["b", 3], ["c", 4]]
</code></pre>

<p>Instead of directly iterating over the elements of the array, you're iterating over a range of integers and using them as the indices to retrieve the elements of the array.</p>
<h4> Comment 42862888 nathanvda: </h4>If you read the other answers, I hope you now realise there are better approaches. So not sure why you needed to add this.<br><h4> Comment 75139205 Camille Goudeseune: </h4>If Andrew Grimm&#39;s answer deserves ten votes, then this one deserves at least one!<br>