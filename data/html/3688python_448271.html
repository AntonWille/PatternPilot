 <h2> Title: What is __init__.py for? </h2> <h4> Mat, question_id: 448271 </h4>Score: 3688, Tags: {python,module,package,python-packaging} <br><p>What is <a href="https://docs.python.org/3/tutorial/modules.html#packages" rel="noreferrer"><code>__init__.py</code></a> for in a Python source directory?</p>
<h4> Chau Pham, Id: 116458237 Score: 25: </h4>Package without <code>__init__</code> is <i>namespace package</i>, not a <i>regular package</i>. <b>It&#39;s not the same thing</b> as @methane pointed out with <a href="https://dev.to/methane/don-t-omit-init-py-3hga" rel="nofollow noreferrer">an example here</a>.<br><h4> Jun, Id: 122147412 Score: 4: </h4>@Rainning A namespace package is not fundamentally different from a regular package. It is just a different way of creating packages. Once a namespace package is created, there is no functional difference between it and a regular package.<br><h4> Jun, Id: 122173739 Score: 4: </h4>@Rainning maybe you didn&#39;t realize that explanation I added above comes from pep420 verbatim<br><h4> NeoZoom.lua, Id: 122174093 Score: 1: </h4>@Jun711: Did you read the link I provided? What I don&#39;t agree with is a comment high-voted but actually wrong. You&#39;re recommending people learning python to think that <code>__init__.py</code> was useless and can be completely ignored (you said &quot;no longer needed&quot;).<br>------------------------------------------------------------------ <br><h3> Loki, Id: 448279, Score: 2008: </h3><p>It used to be a required part of a package (<a href="https://docs.python.org/3/reference/import.html#regular-packages" rel="noreferrer">old, pre-3.3 "regular package"</a>, not <a href="https://docs.python.org/3/reference/import.html#namespace-packages" rel="noreferrer">newer 3.3+ "namespace package"</a>).</p>

<p><a href="https://docs.python.org/3/reference/import.html#regular-packages" rel="noreferrer">Here's the documentation.</a></p>

<blockquote>
  <p>Python defines two types of packages, regular packages and namespace packages. Regular packages are traditional packages as they existed in Python 3.2 and earlier. A regular package is typically implemented as a directory containing an <code>__init__.py</code> file. When a regular package is imported, this <code>__init__.py</code> file is implicitly executed, and the objects it defines are bound to names in the package’s namespace. The <code>__init__.py</code> file can contain the same Python code that any other module can contain, and Python will add some additional attributes to the module when it is imported.</p>
</blockquote>

<p>But just click the link, it contains an example, more information, and an explanation of namespace packages, the kind of packages without <code>__init__.py</code>.</p>
<h4> Two-Bit Alchemist, Comment 33811376 Score: 250: </h4>@CarlG Try this. Make a directory called &#39;datetime&#39; and in it make two blank files, the init.py file (with underscores) and datetime.py. Now open an interpreter, import sys, and issue <code>sys.path.insert(0, &#39;&#47;path&#47;to&#47;datetime&#39;)</code>, replacing that path with the path to whatever directory you just made. Now try something like <code>from datetime import datetime;datetime.now()</code>. You should get an AttributeError (because it is importing your blank file now). If you were to repeat these steps without creating the blank init file, this would not happen. That&#39;s what it&#39;s intended to prevent.<br><h4> Carl G, Comment 32184425 Score: 235: </h4>What does this mean: &quot;this is done to prevent directories with a common name, such as string, from unintentionally hiding valid modules that occur later on the module search path&quot;?<br><h4> Two-Bit Alchemist, Comment 33811146 Score: 126: </h4>@CarlG Python searches a <a href="http://docs.python.org/2/tutorial/modules.html#the-module-search-path" rel="nofollow noreferrer">list of directories</a> to resolve names in, e.g., import statements. Because these can be any directory, and arbitrary ones can be added by the end user, the developers have to worry about directories that happen to share a name with a valid Python module, such as &#39;string&#39; in the docs example. To alleviate this, it ignores directories which do not contain a file named _ _ init _ _.py (no spaces), even if it is blank.<br><h4> Jo&#227;o Vitor Barbosa, Comment 127566891 Score: 1: </h4>All I get is <code>ImportError: attempted relative import with no known parent package</code>.  My structure:  /PyToHtml           <b>init</b>.py           pytohtml.py           test.py  where <code>test.py</code> has: <code>from .pytohtml import HTML</code><br>------------------------------------------------------------------ <br><h3> caritos, Id: 4116384, Score: 1256: </h3><p>Files named <code>__init__.py</code> are used to mark directories on disk as Python package directories.
If you have the files</p>
<pre><code>mydir/spam/__init__.py
mydir/spam/module.py
</code></pre>
<p>and <code>mydir</code> is on your path, you can import the code in <code>module.py</code> as</p>
<pre><code>import spam.module
</code></pre>
<p>or</p>
<pre><code>from spam import module
</code></pre>
<p>If you remove the <code>__init__.py</code> file, Python will no longer look for submodules inside that directory, so attempts to import the module will fail.</p>
<p>The <code>__init__.py</code> file is usually empty, but can be used to export selected portions of the package under more convenient name, hold convenience functions, etc.
Given the example above, the contents of the init module can be accessed as</p>
<pre><code>import spam
</code></pre>
<p>This answer is based on <a href="https://web.archive.org/web/20200721150953/http://effbot.org/pyfaq/what-is-init-py-used-for.htm" rel="noreferrer">this webpage</a>.</p>
<h4> Rob_before_edits, Comment 67915529 Score: 175: </h4>Update:  The file <code>__init__.py</code> was required under Python 2.X and is still required under Python 2.7.12 (I tested it) but it is no longer required from (allegedly) Python 3.3 onwards, and is not required under Python 3.4.3 (I tested it).  See <a href="http://stackoverflow.com/questions/37139786/">stackoverflow.com/questions/37139786</a> for more details.<br><h4> alper, Comment 123028490 Score: 2: </h4>Why do you have <code>import spam</code> inside` <b>init</b>.py`,  what&#39;s its help<br><h4> robertspierre, Comment 136572626 Score: 0: </h4>@alper if you declare a variable <code>a</code> inside inside <code>spam</code>&#39;s <code>__init__py</code>, you can access it with <code>import spam</code> and then <code>spam.a</code>.<br><h4> Diego Cuadros, Comment 127249773 Score: 0: </h4>@alper he doesn&#39;t have <code>import spam</code> inside <code>__init__.py</code>, he has it inside main.py or whatever file needs to import the contents of <code>spam</code>. You can treat <code>spam</code> as an object you import and use functions defined within <code>spam&#47;__init__.py</code><br>------------------------------------------------------------------ <br><h3> Nathan Gould, Id: 18979314, Score: 672: </h3><p>In addition to labeling a directory as a Python package and defining <code>__all__</code>, <strong><code>__init__.py</code> allows you to define any variable at the package level.</strong> Doing so is often convenient if a package defines something that will be imported frequently, in an API-like fashion. This pattern promotes adherence to the Pythonic "flat is better than nested" philosophy.</p>

<h2>An example</h2>

<p>Here is an example from one of my projects, in which I frequently import a <code>sessionmaker</code> called <code>Session</code> to interact with my database. I wrote a "database" package with a few modules:</p>

<pre><code>database/
    __init__.py
    schema.py
    insertions.py
    queries.py
</code></pre>

<p>My <code>__init__.py</code> contains the following code:</p>

<pre><code>import os

from sqlalchemy.orm import sessionmaker
from sqlalchemy import create_engine

engine = create_engine(os.environ['DATABASE_URL'])
Session = sessionmaker(bind=engine)
</code></pre>

<p>Since I define <code>Session</code> here, I can start a new session using the syntax below. This code would be the same executed from inside or outside of the "database" package directory.</p>

<pre><code>from database import Session
session = Session()
</code></pre>

<p>Of course, this is a small convenience -- the alternative would be to define <code>Session</code> in a new file like "create_session.py" in my database package, and start new sessions using:</p>

<pre><code>from database.create_session import Session
session = Session()
</code></pre>

<h2>Further reading</h2>

<p>There is a pretty interesting reddit thread covering appropriate uses of <code>__init__.py</code> here:</p>

<p><a href="http://www.reddit.com/r/Python/comments/1bbbwk/whats_your_opinion_on_what_to_include_in_init_py/">http://www.reddit.com/r/Python/comments/1bbbwk/whats_your_opinion_on_what_to_include_in_init_py/</a></p>

<p>The majority opinion seems to be that <code>__init__.py</code> files should be very thin to avoid violating the "explicit is better than implicit" philosophy.</p>
<h4> Nathan Gould, Comment 53342747 Score: 19: </h4>@ArtOfWarfare, you can use <code>__all__ = [...]</code> to limit what gets imported with <code>import *</code>. But aside from that, yes, you&#39;re left with a messy top-level namespace.<br><h4> ArtOfWarfare, Comment 53336476 Score: 8: </h4><code>engine</code>, <code>sessionmaker</code>, <code>create_engine</code>, and <code>os</code> can all also be imported from <code>database</code> now... seems like you&#39;ve made a mess of that namespace.<br><h4> Mathieu Rollet, Comment 121053693 Score: 4: </h4>@NathanGould you could also use single leading underscore variables which are not imported by <code>import *</code> by default. Eg: <code>import os as _os</code> and use <code>_os</code> inside the <code>__init__.py</code> module in place of <code>os</code>.<br><h4> J&#252;rgen A. Erhard, Comment 131375306 Score: 1: </h4>Also, you should <i>NEVER</i> do &quot;import *&quot;.<br>------------------------------------------------------------------ <br><h3> Can Berk G&#252;der, Id: 448311, Score: 186: </h3><p>The <code>__init__.py</code> file makes Python treat directories containing it as modules. </p>

<p>Furthermore, this is the first file to be loaded in a module, so you can use it to execute code that you want to run each time a module is loaded, or specify the submodules to be exported.</p>
<h4> Moses, Comment 111459012 Score: 24: </h4>I think the <b>init</b>.py makes Python treat directories as <i>packages</i> and not <i>modules</i>. See <a href="https://docs.python.org/3/tutorial/modules.html" rel="nofollow noreferrer">docs.python.org/3/tutorial/modules.html</a><br><h4> JacKeown, Comment 113750497 Score: 14: </h4>&quot;all packages are modules, but not all modules are packages&quot; -- weird, but true.<br>------------------------------------------------------------------ <br><h3> flycee, Id: 29509611, Score: 531: </h3><p>There are 2 main reasons for <code>__init__.py</code></p>
<ol>
<li><p>For convenience: the other users will not need to know your functions' exact location in your package hierarchy (<a href="https://docs.python.org/3/reference/import.html#submodules" rel="noreferrer">documentation</a>).</p>
<pre><code>your_package/
  __init__.py
  file1.py
  file2.py
    ...
  fileN.py
</code></pre>
<pre><code># in __init__.py
from .file1 import *
from .file2 import *
...
from .fileN import *
</code></pre>
<pre><code># in file1.py
def add():
    pass
</code></pre>
<p>then others can call add() by</p>
<pre><code> from your_package import add
</code></pre>
<p>without knowing file1's inside functions, like</p>
<pre><code> from your_package.file1 import add
</code></pre>
</li>
<li><p>If you want something to be initialized; for example, logging (which should be put in the top level):</p>
<pre><code> import logging.config
 logging.config.dictConfig(Your_logging_config)
</code></pre>
</li>
</ol>
<h4> aerin, Comment 84965615 Score: 21: </h4>oh, before reading your answer, I thought calling a function explicitly from its location is a good practice.<br><h4> Tobias Sette, Comment 104793388 Score: 11: </h4>@Aerin it would be better do not consider short statements (or, in this case, subjective conclusions) to be always true. Importing from <code>__init__.py</code> may be useful sometimes, but not all times.<br><h4> pm1359, Comment 119470858 Score: 2: </h4>what has to be inside <b>init</b>.py?<br><h4> Ben L, Comment 131261928 Score: 1: </h4><code>from something import * </code> is always a bad idea. I prefer to use <code>import something</code> then use  <code>something.someaction</code> to call the specific someaction.   In this way, you know exactly &#39;someaction&#39; is from &#39;something&#39; package. Avoid messing the namespace.<br>------------------------------------------------------------------ <br><h3> zeekvfu, Id: 39991978, Score: 138: </h3><p>Since Python 3.3, <code>__init__.py</code> is no longer required to define directories as importable Python packages.</p>

<p>Check <a href="https://docs.python.org/3/whatsnew/3.3.html#pep-420-implicit-namespace-packages" rel="noreferrer">PEP 420: Implicit Namespace Packages</a>:</p>

<blockquote>
  <p>Native support for package directories that don’t require <code>__init__.py</code> marker files and can automatically span multiple path segments (inspired by various third party approaches to namespace packages, as described in <a href="https://www.python.org/dev/peps/pep-0420/" rel="noreferrer">PEP 420</a>)</p>
</blockquote>

<p>Here's the test:  </p>

<pre><code>$ mkdir -p /tmp/test_init
$ touch /tmp/test_init/module.py /tmp/test_init/__init__.py
$ tree -at /tmp/test_init
/tmp/test_init
├── module.py
└── __init__.py
$ python3

&gt;&gt;&gt; import sys
&gt;&gt;&gt; sys.path.insert(0, '/tmp')
&gt;&gt;&gt; from test_init import module
&gt;&gt;&gt; import test_init.module

$ rm -f /tmp/test_init/__init__.py
$ tree -at /tmp/test_init
/tmp/test_init
└── module.py
$ python3

&gt;&gt;&gt; import sys
&gt;&gt;&gt; sys.path.insert(0, '/tmp')
&gt;&gt;&gt; from test_init import module
&gt;&gt;&gt; import test_init.module
</code></pre>

<p>references:<br>
<a href="https://docs.python.org/3/whatsnew/3.3.html#pep-420-implicit-namespace-packages" rel="noreferrer">https://docs.python.org/3/whatsnew/3.3.html#pep-420-implicit-namespace-packages</a><br>
<a href="https://www.python.org/dev/peps/pep-0420/" rel="noreferrer">https://www.python.org/dev/peps/pep-0420/</a><br>
<a href="https://stackoverflow.com/questions/37139786/is-init-py-not-required-for-packages-in-python-3">Is __init__.py not required for packages in Python 3?</a>  </p>
<h4> methane, Comment 97793175 Score: 10: </h4>It is &quot;namespace&quot; package.  Don&#39;t use it for regular package.<br><h4> methane, Comment 102897587 Score: 7: </h4>@RobertLugg See <a href="https://dev.to/methane/don-t-omit-init-py-3hga" rel="nofollow noreferrer">dev.to/methane/don-t-omit-init-py-3hga</a><br><h4> Robert Lugg, Comment 102858108 Score: 2: </h4>@methan, could you elaborate on your comment?<br>------------------------------------------------------------------ <br><h3> Xantium, Id: 50307979, Score: 116: </h3><p>Although Python works without an <code>__init__.py</code> file you should still include one.</p>
<p>It specifies that the directory should be treated as a package, so therefore include it (even if it is empty).</p>
<p><strong>There is also a case where you may actually use an <code>__init__.py</code> file:</strong></p>
<p><em>Imagine you had the following file structure:</em></p>
<pre><code>main_methods 
    |- methods.py
</code></pre>
<p>And <code>methods.py</code> contained this:</p>
<pre><code>def foo():
    return 'foo'
</code></pre>
<p>To use <code>foo()</code> you would need one of the following:</p>
<pre><code>from main_methods.methods import foo # Call with foo()
from main_methods import methods # Call with methods.foo()
import main_methods.methods # Call with main_methods.methods.foo()
</code></pre>
<p>Maybe there you need (or want) to keep <code>methods.py</code> inside <code>main_methods</code> (runtimes/dependencies for example) but you only want to import <code>main_methods</code>.</p>
<hr />
<p>If you changed the name of <code>methods.py</code> to <code>__init__.py</code> then you could use <code>foo()</code> by just importing <code>main_methods</code>:</p>
<pre><code>import main_methods
print(main_methods.foo()) # Prints 'foo'
</code></pre>
<p>This works because <code>__init__.py</code> is treated as part of the package.</p>
<hr />
<p>Some Python packages actually do this.  An example is with <a href="https://docs.python.org/3/library/json.html" rel="noreferrer">JSON</a>, where running <code>import json</code> is actually importing <code>__init__.py</code> from the <code>json</code> package (<a href="https://github.com/python/cpython/tree/3.6/Lib/json" rel="noreferrer">see the package file structure here</a>):</p>
<blockquote>
<p><strong>Source code:</strong> <code>Lib/json/__init__.py</code></p>
</blockquote>
------------------------------------------------------------------ <br><h3> Marcus Thornton, Id: 21019300, Score: 74: </h3><p>In Python the definition of package is very simple. Like Java the hierarchical structure and the directory structure are the same. But you have to have <code>__init__.py</code> in a package. I will explain the <code>__init__.py</code> file with the example below:</p>

<pre><code>package_x/
|--  __init__.py
|--    subPackage_a/
|------  __init__.py
|------  module_m1.py
|--    subPackage_b/
|------  __init__.py
|------  module_n1.py
|------  module_n2.py
|------  module_n3.py
</code></pre>

<p><code>__init__.py</code> can be empty, as long as it exists. It indicates that the directory should be regarded as a package. Of course, <code>__init__.py</code> can also set the appropriate content.</p>

<p>If we add a function in module_n1:</p>

<pre><code>def function_X():
    print "function_X in module_n1"
    return
</code></pre>

<p>After running:</p>

<pre><code>&gt;&gt;&gt;from package_x.subPackage_b.module_n1 import function_X
&gt;&gt;&gt;function_X()

function_X in module_n1 
</code></pre>

<p>Then we followed the hierarchy package and called module_n1 the function. We can use <code>__init__.py</code> in subPackage_b like this:</p>

<pre><code>__all__ = ['module_n2', 'module_n3']
</code></pre>

<p>After running: </p>

<pre><code>&gt;&gt;&gt;from package_x.subPackage_b import * 
&gt;&gt;&gt;module_n1.function_X()

Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
ImportError: No module named module_n1
</code></pre>

<p>Hence using * importing, module package is subject to <code>__init__.py</code> content.</p>
<h4> technazi, Comment 102024090 Score: 0: </h4>How will my setup.py look to do the same import through the packaged library?  <code>from package_x.subPackage_b.module_n1 import function_X</code><br><h4> soMuchToLearnAndShare, Comment 107141867 Score: 0: </h4>so the key take away here is <i>&quot;using * importing, module package is subject to <b>init</b>.py content&quot;</i><br>------------------------------------------------------------------ <br><h3> B.Mr.W., Id: 27757676, Score: 53: </h3><p><code>__init__.py</code> will treat the directory it is in as a loadable module.</p>

<p>For people who prefer reading code, I put <a href="https://stackoverflow.com/users/2588818/two-bit-alchemist">Two-Bit Alchemist's</a> comment here.</p>

<pre><code>$ find /tmp/mydir/
/tmp/mydir/
/tmp/mydir//spam
/tmp/mydir//spam/__init__.py
/tmp/mydir//spam/module.py
$ cd ~
$ python
&gt;&gt;&gt; import sys
&gt;&gt;&gt; sys.path.insert(0, '/tmp/mydir')
&gt;&gt;&gt; from spam import module
&gt;&gt;&gt; module.myfun(3)
9
&gt;&gt;&gt; exit()
$ 
$ rm /tmp/mydir/spam/__init__.py*
$ 
$ python
&gt;&gt;&gt; import sys
&gt;&gt;&gt; sys.path.insert(0, '/tmp/mydir')
&gt;&gt;&gt; from spam import module
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
ImportError: No module named spam
&gt;&gt;&gt; 
</code></pre>
------------------------------------------------------------------ <br><h3> Epitaph, Id: 448292, Score: 44: </h3><p>It facilitates importing other python files. When you placed this file in a directory (say stuff)containing other py files, then you can do something like import stuff.other.</p>

<pre><code>root\
    stuff\
         other.py

    morestuff\
         another.py
</code></pre>

<p>Without this <code>__init__.py</code> inside the directory stuff, you couldn't import other.py, because Python doesn't know where the source code for stuff is and unable to recognize it as a package. </p>
------------------------------------------------------------------ <br><h3> Alec, Id: 56301295, Score: 19: </h3><p>An <code>__init__.py</code> file makes imports easy. When an <code>__init__.py</code> is present within a package, function <code>a()</code> can be imported from file <code>b.py</code> like so:</p>

<pre><code>from b import a
</code></pre>

<p>Without it, however, you can't import directly. You have to amend the system path:</p>

<pre><code>import sys
sys.path.insert(0, 'path/to/b.py')

from b import a
</code></pre>
------------------------------------------------------------------ <br><h3> joel, Id: 62985979, Score: 7: </h3><p>One thing __init__.py allows is converting a module to a package without breaking the API or creating extraneous nested namespaces or private modules*. This helps when I want to extend a namespace.</p>
<p>If I have a file util.py containing</p>
<pre><code>def foo():
    ...
</code></pre>
<p>then users will access <code>foo</code> with</p>
<pre><code>from util import foo
</code></pre>
<p>If I then want to add utility functions for database interaction, and I want them to have their own namespace under <code>util</code>, I'll need a new directory**, and to keep API compatibility (so that <code>from util import foo</code> still works), I'll call it util/. I <em>could</em> move util.py into util/ like so,</p>
<pre class="lang-none prettyprint-override"><code>util/
  __init__.py
  util.py
  db.py
</code></pre>
<p>and in util/__init__.py do</p>
<pre><code>from util import *
</code></pre>
<p>but this is redundant. Instead of having a util/util.py file, we can just put the util.py contents in __init__.py and the user can now</p>
<pre><code>from util import foo
from util.db import check_schema
</code></pre>
<p>I think this nicely highlights how a <code>util</code> package's __init__.py acts in a similar way to a <code>util</code> module</p>
<p>* this is hinted at in the other answers, but I want to highlight it here<br />
** short of employing import gymnastics. Note it won't work to create a new package with the same name as the file, see <a href="https://stackoverflow.com/q/6393861/5986907">this</a></p>
<h4> Mark, Comment 113841759 Score: 0: </h4>Don&#39;t you mean <code>from util import check_schema</code> since you already did in __init __.py <code>from util import *</code><br><h4> joel, Comment 113841913 Score: 0: </h4>@Mark no, <code>from util import *</code> would be in util/__init__.py, and so wouldn&#39;t import <code>db</code> it would import the contents of util/util.py. I&#39;ll clarify the answer<br>------------------------------------------------------------------ <br><h3> jayprakash, Id: 71742178, Score: 0: </h3><p><code>__init__.py</code> : It is a Python file found in a package directory, it is invoked when the package or a module in the package is imported. You can use this to execute package initialization code, i.e. whenever the package is imported the python statements are executed first before the other modules in this folder gets executed. It is similar to main function of c or Java program, but this exists in the Python package module (folder) rather than in the core Python file.
also it has access to global variables defined in this <code>__init__.py</code> file as when the module is imported into Python file.</p>
<p>for eg.<br />
I have a <code>__init__.py</code> file in a folder called <code>pymodlib</code>, this file contains the following statements:</p>
<pre><code>print(f'Invoking __init__.py for {__name__}')
pystructures = ['for_loop', 'while__loop', 'ifCondition']
</code></pre>
<p>When I import this package <code>pymodlib</code> in my solution module or notebook or python console:<br />
These two statements get executed while importing.
So in the log or console you would see the following output:</p>
<pre><code>&gt;&gt;&gt; import pymodlib
Invoking __init__.py for pymodlib
</code></pre>
<p>in the next statement of python console: I can access the global variable:</p>
<pre><code>&gt;&gt; pymodlib.pystructures
</code></pre>
<p>it gives the following output:</p>
<pre><code>['for_loop', 'while__loop', 'ifCondition']
</code></pre>
<p>Now, from Python 3.3 onwards the use of this file has been optional to make folder a Python module. So you can skip from including it in the python module folder.</p>
------------------------------------------------------------------ <br><h3> RedMattis, Id: 72981281, Score: 0: </h3><p>If you're using Python 2 and want to load siblings of your file you can simply add the parent folder of your file to your system paths of the session. It will behave about the same as if your current file was an init file.</p>
<pre><code>import os
import sys
dir_path = os.path.dirname(__file__)
sys.path.insert(0, dir_path)
</code></pre>
<p>After that regular imports relative to the file's directory will work just fine. E.g.</p>
<pre><code>import cheese
from vehicle_parts import *
# etc.
</code></pre>
<p>Generally you want to use a proper <strong>init</strong>.py file instead though, but when dealing with legacy code you might be stuck with f.ex. a library hard-coded to load a particular file and nothing but. For those cases this is an alternative.</p>
