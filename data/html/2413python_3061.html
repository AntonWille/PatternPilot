 <h2> Title: Calling a function of a module by using its name (a string) </h2> <h4> ricree, question_id: 3061 </h4>Score: 2413, Tags: {python,object,reflection} <br><p>How do I call a function, using a string with the function's name? For example:</p>
<pre><code>import foo
func_name = &quot;bar&quot;
call(foo, func_name)  # calls foo.bar()
</code></pre>
<h4> Nearoo, Id: 123977389 Score: 24: </h4>FYI: the language feature of accessing fields, classes and methods by dynamic names is called <a href="https://en.wikipedia.org/wiki/Reflective_programming" rel="nofollow noreferrer">reflection</a>. Might make future searches easier.<br><h4> WMRamadan, Id: 122445392 Score: 9: </h4>Using eval would probably bring up some security concerns!<br>------------------------------------------------------------------ <br><h3> trubliphone, Id: 9272378, Score: 43: </h3><p>For what it's worth, if you needed to pass the function (or class) name and app name as a string, then you could do this:</p>

<pre><code>myFnName  = "MyFn"
myAppName = "MyApp"
app = sys.modules[myAppName]
fn  = getattr(app,myFnName)
</code></pre>
<h4> lony, Comment 80163376 Score: 2: </h4>Just a bit more generic is <code>handler = getattr(sys.modules[__name__], myFnName)</code><br><h4> J&#252;rgen K., Comment 122077103 Score: 1: </h4>how does it work if function is a class function?<br>------------------------------------------------------------------ <br><h3> Patrick Johnmeyer, Id: 3071, Score: 2899: </h3><p>Given a module <code>foo</code> with method <code>bar</code>:</p>
<pre><code>import foo
bar = getattr(foo, 'bar')
result = bar()
</code></pre>
<p><a href="https://docs.python.org/library/functions.html#getattr" rel="noreferrer"><code>getattr</code></a> can similarly be used on class instance bound methods, module-level methods, class methods... the list goes on.</p>
<h4> NuSkooler, Comment 49930520 Score: 7: </h4>See also the answer provided by @sastanin if you only care for example about your local/current module&#39;s functions.<br><h4> Ben Hoyt, Comment 69699187 Score: 24: </h4>@akki Yes, if you&#39;re <i>in</i> the <code>foo</code> module you can use <code>globals()</code> to do this: <code>methodToCall = globals()[&#39;bar&#39;]</code><br><h4> Shaun, Comment 37017015 Score: 21: </h4>hasattr or getattr can be used to determine if a function is defined.  I had a database mapping (eventType and handling functionName) and I wanted to make sure I never &quot;forgot&quot; to define an event handler in my python<br><h4> Blairg23, Comment 37627178 Score: 15: </h4>This works if you already know the module name. However, if you want the user to provide the module name as a string, this won&#39;t work.<br><h4> geekofalltrades, Comment 39510577 Score: 13: </h4>If you need to avoid a NoneType is not callable exception, you could also employ the three-argument form of getattr: getattr(foo, &#39;bar&#39;, lambda: None). I apologize for the formatting; the stackexchange android app is apparently terrible.<br><h4> Patrick Johnmeyer, Comment 81488346 Score: 4: </h4>@KeatsKelleher since we do not know the use case, only the question, all I can say reliably is that there are many use cases in which your point applies, and some which they do not. It is common and reasonable to do things like this in rules engines, DSLs, in-app scripting, etc., in which the code you are writing exists to run other code. There are probably numerous other &quot;good&quot; times to do this that I&#39;m not thinking of right now. So, <i>should</i> we do this? The answer, as with most language features in most languages, is &quot;it depends.&quot;<br><h4> KeatsKelleher, Comment 81488519 Score: 2: </h4>@PatrickJohnmeyer I never exclude patterns/paradigms entirely... This is why I asked a question instead of making a blanket statement. There are a lot of negative repercussions for using this pattern overzealously... which (at least in my experience) is common.<br><h4> azmeuk, Comment 52358701 Score: 2: </h4>This does not work with functions that use a decorator. getattr returns the outer function<br><h4> tuned, Comment 52455643 Score: 2: </h4>Note: cool +1, this made me understand once more that in Python everything is an object. Consequently, it works also with variables, you can access a module&#39;s variables as any other object&#39;s variables.<br><h4> Robert Parcus, Comment 54869282 Score: 1: </h4>If you have deep structures, the following syntax might be useful: from functools import reduce reduce(getattr, &quot;a.b.c.d.e.f.g&quot;.split(&#39;.&#39;), deepStructure)<br><h4> akki, Comment 66400024 Score: 1: </h4>This is a very helpful answer, buy I couldn&#39;t work it out when the module foo is the current module itself. Does anybody know how to do that?<br><h4> KeatsKelleher, Comment 80708617 Score: 1: </h4>You CAN do this, but SHOULD you? How will you find all instances of your function call when your code base gets large? There&#39;s nothing to grep for, and no IDE is going to find that reference. That makes this sort of dynamic call really troublesome. Isn&#39;t it nicer to your colleagues to be explicit, anyway? Less code doesn&#39;t doesn&#39;t always mean more readable.<br><h4> Momooo, Comment 104825053 Score: 1: </h4>In case, if the module itself is a string and one has to convert from str to class in this case &quot;foo&quot; is a string but it has to be called, then checkout this link  <a href="https://blender.stackexchange.com/questions/36781/calling-a-method-from-a-string" title="calling a method from a string">blender.stackexchange.com/questions/36781/&hellip;</a>  PS: I know it&#39;s doesn&#39;t belong in the context of the asked question, I thought someone might benefit from this comment.<br><h4> Patrick Johnmeyer, Comment 116835087 Score: 1: </h4>@conol you can, using something like <code>m = __import__(&#39;foo&#39;)</code>, where <code>m</code> is now the name used for module &quot;foo&quot;. You would then do <code>method_to_call = getattr(m, &#39;bar&#39;)</code>. Calling <code>__import__</code> directly is rarely the right answer, but it is possible. <a href="https://stackoverflow.com/a/4605/363">stackoverflow.com/a/4605/363</a><br><h4> alper, Comment 125651476 Score: 0: </h4>What should I do to detect local function within the module itself?<br><h4> Naveen, Comment 121612422 Score: 0: </h4>If we want the method with parameter in that case how to do<br><h4> conol, Comment 116473648 Score: 0: </h4>can we get this foo also from string?<br>------------------------------------------------------------------ <br><h3> sastanin, Id: 834451, Score: 764: </h3><ul>
<li><p>Using <a href="http://docs.python.org/library/functions.html#locals" rel="noreferrer"><code>locals()</code></a>, which returns a dictionary with the current local symbol table:</p>
<pre><code>locals()[&quot;myfunction&quot;]()
</code></pre>
</li>
<li><p>Using <a href="http://docs.python.org/library/functions.html#globals" rel="noreferrer"><code>globals()</code></a>, which returns a dictionary with the global symbol table:</p>
<pre><code>globals()[&quot;myfunction&quot;]()
</code></pre>
</li>
</ul>
<h4> Joelmob, Comment 41248071 Score: 94: </h4>This method with globals/locals is good if the method you need to call is defined in the same module you are calling from.<br><h4> David Stein, Comment 71058921 Score: 2: </h4>I&#39;ve got a reason for you (actually what led me here):  Module A has a function F that needs to call a function by name.  Module B imports Module A, and invokes function F with a request to call Function G, which is defined in Module B.  This call fails because, apparently, function F only runs with the globals that are defined in Module F - so globals()[&#39;G&#39;] = None.<br><h4> Nick T, Comment 44688282 Score: 1: </h4>@Joelmob is there any other way to get an object by string out of the root namespace?<br><h4> Joelmob, Comment 44710555 Score: 1: </h4>@NickT I am only aware of these methods, I don&#39;t think there are any others that fill same function as these, at least I can&#39;t think of a reason why there should be more.<br>------------------------------------------------------------------ <br><h3> HS., Id: 4605, Score: 472: </h3><p>Based on <a href="https://stackoverflow.com/a/3071/365102">Patrick's solution</a>, to get the module dynamically as well, import it using:</p>
<pre><code>module = __import__('foo')
func = getattr(module, 'bar')
func()
</code></pre>
<h4> hoffmaje, Comment 13509643 Score: 104: </h4>I do not understand that last comment. __import__ has its own right and the next sentence in the mentioned docs says: &quot;Direct use of __import__() is rare, except in cases where you want to import a module whose name is only known at runtime&quot;. So: +1 for the given answer.<br><h4> glarrain, Comment 26441697 Score: 65: </h4>Use <code>importlib.import_module</code>. The official docs say about <code>__import__</code>: &quot;This is an advanced function that is not needed in everyday Python programming, unlike importlib.import_module().&quot; <a href="http://docs.python.org/2/library/functions.html#__import__" rel="nofollow noreferrer">docs.python.org/2/library/functions.html#__import__</a><br><h4> Xiong Chiamiov, Comment 27731542 Score: 10: </h4>@glarrain As long as you&#39;re ok with only support 2.7 and up.<br><h4> Xiong Chiamiov, Comment 80145532 Score: 10: </h4>@cowlinator Yes, 3.6 is part of &quot;2.7 and up&quot;, both in strict versioning semantics and in release dates (it came about six years later).  It also didn&#39;t exist for three years after my comment. ;)  In the 3.x branch, the module has been around since 3.1.  2.7 and 3.1 are now pretty ancient; you&#39;ll still find servers hanging around that only support 2.6, but it&#39;s probably worth having importlib be the standard advice nowadays.<br><h4> cowlinator, Comment 80139805 Score: 4: </h4>@Xiong Chaimiov, <code>importlib.import_module</code> is supported in 3.6 .  See <a href="https://docs.python.org/3.6/library/importlib.html#importlib.import_module" rel="nofollow noreferrer">docs.python.org/3.6/library/&hellip;</a><br><h4> Conner M., Comment 121930875 Score: 0: </h4>For module paths using dot format, e.g. <code>foo.bar.module</code>, <code>__input__</code> only imports the base module <code>foo</code>, whereas <code>importlib.import_module</code> returns <code>foo.bar.module</code>. Using &#39;foo/bar/module<code>, </code>__import__` returns expected module.<br>------------------------------------------------------------------ <br><h3> Sourcegeek, Id: 12025554, Score: 164: </h3><p>Just a simple contribution. If the class that we need to instance is in the same file, we can use something like this:</p>

<pre><code># Get class from globals and create an instance
m = globals()['our_class']()

# Get the function (from the instance) that we need to call
func = getattr(m, 'function_name')

# Call it
func()
</code></pre>

<p>For example:</p>

<pre><code>class A:
    def __init__(self):
        pass

    def sampleFunc(self, arg):
        print('you called sampleFunc({})'.format(arg))

m = globals()['A']()
func = getattr(m, 'sampleFunc')
func('sample arg')

# Sample, all on one line
getattr(globals()['A'](), 'sampleFunc')('sample arg')
</code></pre>

<p>And, if not a class:</p>

<pre><code>def sampleFunc(arg):
    print('you called sampleFunc({})'.format(arg))

globals()['sampleFunc']('sample arg')
</code></pre>
<h4> J&#252;rgen K., Comment 122077126 Score: 2: </h4>What if you call this function inside a class function?<br>------------------------------------------------------------------ <br><h3> ferrouswheel, Id: 19393328, Score: 158: </h3><p>Given a string, with a complete python path to a function, this is how I went about getting the result of said function:</p>

<pre><code>import importlib
function_string = 'mypackage.mymodule.myfunc'
mod_name, func_name = function_string.rsplit('.',1)
mod = importlib.import_module(mod_name)
func = getattr(mod, func_name)
result = func()
</code></pre>
<h4> SdSaati, Comment 105844335 Score: 5: </h4>I think this was the best answer.<br><h4> Pankaj Bhambhani, Comment 56367809 Score: 4: </h4>This helped me. Its a lightweight version of <code>__import__</code> function.<br>------------------------------------------------------------------ <br><h3> user3946687, Id: 40219576, Score: 88: </h3><p>The best answer according to the <a href="https://docs.python.org/3/faq/programming.html#how-do-i-use-strings-to-call-functions-methods" rel="noreferrer">Python programming FAQ</a> would be:</p>

<pre><code>functions = {'myfoo': foo.bar}

mystring = 'myfoo'
if mystring in functions:
    functions[mystring]()
</code></pre>

<blockquote>
  <p>The primary advantage of this technique is that the strings do not need to match the names of the functions. This is also the primary technique used to emulate a case construct</p>
</blockquote>
------------------------------------------------------------------ <br><h3> 00500005, Id: 22959509, Score: 72: </h3><p>The answer (I hope) no one ever wanted</p>

<p>Eval like behavior</p>

<pre><code>getattr(locals().get("foo") or globals().get("foo"), "bar")()
</code></pre>

<p>Why not add auto-importing</p>

<pre><code>getattr(
    locals().get("foo") or 
    globals().get("foo") or
    __import__("foo"), 
"bar")()
</code></pre>

<p>In case we have extra dictionaries we want to check</p>

<pre><code>getattr(next((x for x in (f("foo") for f in 
                          [locals().get, globals().get, 
                           self.__dict__.get, __import__]) 
              if x)),
"bar")()
</code></pre>

<p>We need to go deeper</p>

<pre><code>getattr(next((x for x in (f("foo") for f in 
              ([locals().get, globals().get, self.__dict__.get] +
               [d.get for d in (list(dd.values()) for dd in 
                                [locals(),globals(),self.__dict__]
                                if isinstance(dd,dict))
                if isinstance(d,dict)] + 
               [__import__])) 
        if x)),
"bar")()
</code></pre>
<h4> pevinkinel, Comment 109526912 Score: 26: </h4>this could be improved by recursively scanning the directory tree and auto-mounting usb drives<br><h4> ArjunSahlot, Comment 117393363 Score: 1: </h4>This is definitely the answer I wanted. Perfect.<br>------------------------------------------------------------------ <br><h3> tvt173, Id: 41024742, Score: 47: </h3><p>Try this. While this still uses eval, it only uses it to <em>summon the function from the current context</em>. Then, you have the real function to use as you wish.</p>

<p>The main benefit for me from this is that you will get any eval-related errors at the point of summoning the function. Then you will get <em>only</em> the function-related errors when you call.</p>

<pre><code>def say_hello(name):
    print 'Hello {}!'.format(name)

# get the function by name
method_name = 'say_hello'
method = eval(method_name)

# call it like a regular function later
args = ['friend']
kwargs = {}
method(*args, **kwargs)
</code></pre>
<h4> tvt173, Comment 70230560 Score: 7: </h4>Sure, you must be mindful of the context you are using it in, whether this will be appropriate or not, given those risks.<br><h4> red777, Comment 90632633 Score: 6: </h4>A function should not be responsible for validating it&#39;s parameters - that&#39;s the job of a different function. Saying that it&#39;s risky to use eval with a string is saying that use of every function is risky.<br><h4> iankit, Comment 70003544 Score: 3: </h4>This would be risky. string can have anything and eval would end up eval-ling it without any consideration.<br><h4> moi, Comment 95190576 Score: 3: </h4>You should never use <code>eval</code> unless strictly necessary. <code>getattr(__module__, method_name)</code> is a much better choice in this context.<br>------------------------------------------------------------------ <br><h3> Serjik, Id: 55363812, Score: 21: </h3><p>As this question <a href="https://stackoverflow.com/questions/16642145/how-to-dynamically-call-methods-within-a-class-using-method-name-assignment-to-a">How to dynamically call methods within a class using method-name assignment to a variable [duplicate]</a> marked as a duplicate as this one, I am posting a related answer here:</p>

<p>The scenario is, a method in a class want to call another method on the same class dynamically, I have added some details to original example which offers some wider scenario and clarity:</p>

<pre><code>class MyClass:
    def __init__(self, i):
        self.i = i

    def get(self):
        func = getattr(MyClass, 'function{}'.format(self.i))
        func(self, 12)   # This one will work
        # self.func(12)    # But this does NOT work.


    def function1(self, p1):
        print('function1: {}'.format(p1))
        # do other stuff

    def function2(self, p1):
        print('function2: {}'.format(p1))
        # do other stuff


if __name__ == "__main__":
    class1 = MyClass(1)
    class1.get()
    class2 = MyClass(2)
    class2.get()
</code></pre>

<blockquote>
  <p>Output (Python 3.7.x)</p>
  
  <p>function1: 12 </p>
  
  <p>function2: 12</p>
</blockquote>
<h4> drascom, Comment 127594723 Score: 2: </h4>best answer. the point is using class name instead of &quot;self&quot; in getattr command.i was trying to use like  getattr(self, key)() and it was giving error like int is not callable but when i changed it to &quot; getattr(HomeScreen, key)(self)&quot; it is working now. &quot;HomeScreen&quot; is class name by the way..thanks...<br><h4> M M, Comment 126960048 Score: 1: </h4>Great answer, thank you :)  I was trying the same approach, but failed not knowing that I have to include &quot;self&quot; in the actual function call again. Do you have an explanation as to why this is necessary?<br><h4> Serjik, Comment 127108409 Score: 1: </h4>My best guess: obj.method in Python actually calls method(self, ...), in case of getattr this synthetic sugar could not be applied by Python interpreter.<br>------------------------------------------------------------------ <br><h3> Natdrip, Id: 14072943, Score: 18: </h3><p>none of what was suggested helped me. I did discover this though.</p>

<pre><code>&lt;object&gt;.__getattribute__(&lt;string name&gt;)(&lt;params&gt;)
</code></pre>

<p>I am using python 2.66 </p>

<p>Hope this helps</p>
<h4> V13, Comment 64698455 Score: 23: </h4>In what aspect is this better than getattr() ?<br><h4> Aran-Fey, Comment 92791680 Score: 23: </h4>Can people who don&#39;t know python please stop upvoting this junk? Use <a href="https://docs.python.org/3/library/functions.html#getattr" rel="nofollow noreferrer"><code>getattr</code></a> instead.<br><h4> ioaniatr, Comment 90389189 Score: 1: </h4>Exactly what i wanted. Works like a charm! Perfect!!  <code>self.__getattribute__(&#39;title&#39;)</code> is equal to <code>self.title</code><br><h4> ioaniatr, Comment 90715409 Score: 0: </h4><code>self.__getattribute__(&#39;title&#39;)</code> doesn&#39;t work in any cases(don&#39;t know why) afterall, but <code>func = getattr(self, &#39;title&#39;); func();</code> does. So, maybe is better to use <code>getattr()</code> instead<br>------------------------------------------------------------------ <br><h3> Lukas, Id: 62937980, Score: 17: </h3><p>Although getattr() is elegant (and about 7x faster) method, you can get return value from the function (local, class method, module) with eval as elegant as <code>x = eval('foo.bar')()</code>. And when you implement some error handling then quite securely (the same principle can be used for getattr). Example with module import and class:</p>
<pre><code># import module, call module function, pass parameters and print retured value with eval():
import random
bar = 'random.randint'
randint = eval(bar)(0,100)
print(randint) # will print random int from &lt;0;100)

# also class method returning (or not) value(s) can be used with eval: 
class Say:
    def say(something='nothing'):
        return something

bar = 'Say.say'
print(eval(bar)('nice to meet you too')) # will print 'nice to meet you' 
</code></pre>
<p>When module or class does not exist (typo or anything better) then NameError is raised. When function does not exist, then AttributeError is raised. This can be used to handle errors:</p>
<pre><code># try/except block can be used to catch both errors
try:
    eval('Say.talk')() # raises AttributeError because function does not exist
    eval('Says.say')() # raises NameError because the class does not exist
    # or the same with getattr:
    getattr(Say, 'talk')() # raises AttributeError
    getattr(Says, 'say')() # raises NameError
except AttributeError:
    # do domething or just...
    print('Function does not exist')
except NameError:
    # do domething or just...
    print('Module does not exist')
</code></pre>
------------------------------------------------------------------ <br><h3> Aliakbar Ahmadi, Id: 68283436, Score: 17: </h3><p>In python3, you can use the <code>__getattribute__</code> method. See following example with a list method name string:</p>
<pre><code>func_name = 'reverse'

l = [1, 2, 3, 4]
print(l)
&gt;&gt; [1, 2, 3, 4]

l.__getattribute__(func_name)()
print(l)
&gt;&gt; [4, 3, 2, 1]
</code></pre>
<h4> Lecdi, Comment 126533334 Score: 2: </h4>This is a duplicate of <a href="https://stackoverflow.com/a/14072943/16768672">this answer</a>, and is also not the best practice for the same reasons: just use <code>getattr(obj, attr)</code> instead.<br>------------------------------------------------------------------ <br><h3> U13-Forward, Id: 69249811, Score: 11: </h3><p>Nobody mentioned <code>operator.attrgetter</code> yet:</p>
<pre><code>&gt;&gt;&gt; from operator import attrgetter
&gt;&gt;&gt; l = [1, 2, 3]
&gt;&gt;&gt; attrgetter('reverse')(l)()
&gt;&gt;&gt; l
[3, 2, 1]
&gt;&gt;&gt; 
</code></pre>
------------------------------------------------------------------ <br><h3> 정도유, Id: 62672406, Score: 8: </h3><p><code>getattr</code> calls method by name from an object.
But this object should be parent of calling class.
The parent class can be got by <code>super(self.__class__, self)</code></p>
<pre class="lang-py prettyprint-override"><code>class Base:
    def call_base(func):
        &quot;&quot;&quot;This does not work&quot;&quot;&quot;
        def new_func(self, *args, **kwargs):
            name = func.__name__
            getattr(super(self.__class__, self), name)(*args, **kwargs)
        return new_func

    def f(self, *args):
        print(f&quot;BASE method invoked.&quot;)

    def g(self, *args):
        print(f&quot;BASE method invoked.&quot;)

class Inherit(Base):
    @Base.call_base
    def f(self, *args):
        &quot;&quot;&quot;function body will be ignored by the decorator.&quot;&quot;&quot;
        pass

    @Base.call_base
    def g(self, *args):
        &quot;&quot;&quot;function body will be ignored by the decorator.&quot;&quot;&quot;
        pass

Inherit().f() # The goal is to print &quot;BASE method invoked.&quot;
</code></pre>
------------------------------------------------------------------ <br><h3> Bowen 404, Id: 67982516, Score: 3: </h3><p>i'm facing the similar problem before, which is to convert a string to a function. <strong>but i can't use <code>eval()</code> or <code>ast.literal_eval()</code>, because i don't want to execute this code immediately.</strong></p>
<p>e.g. i have a string <code>&quot;foo.bar&quot;</code>, and i want to assign it to <code>x</code> as a function name instead of a string, which means i can call the function by <code>x()</code> <strong>ON DEMAND</strong>.</p>
<p>here's my code:</p>
<pre class="lang-py prettyprint-override"><code>str_to_convert = &quot;foo.bar&quot;
exec(f&quot;x = {str_to_convert}&quot;)
x()
</code></pre>
<p>as for your question, you only need to add your module name <code>foo</code> and <code>.</code> before <code>{}</code> as follows:</p>
<pre class="lang-py prettyprint-override"><code>str_to_convert = &quot;bar&quot;
exec(f&quot;x = foo.{str_to_convert}&quot;)
x()
</code></pre>
<p><strong>WARNING!!! either <code>eval()</code> or <code>exec()</code> is a dangerous method, you should confirm the safety.</strong>
<strong>WARNING!!! either <code>eval()</code> or <code>exec()</code> is a dangerous method, you should confirm the safety.</strong>
<strong>WARNING!!! either <code>eval()</code> or <code>exec()</code> is a dangerous method, you should confirm the safety.</strong></p>
<h4> Lecdi, Comment 126533372 Score: 1: </h4><code>eval()</code> can be used here instead of <code>exec()</code>, and would probably make the code marginally more readable: just use <code>x = eval(str_to_convert)</code> instead for the same result.<br><h4> Bowen 404, Comment 126555450 Score: 0: </h4>@Lecdi yes, you&#39;re right! and this also makes the variable visable to the following codes. thanks!<br><h4> Bowen 404, Comment 126555653 Score: 0: </h4>@Lecdi but exec could let me define a series of variables with different names, like exec(f&quot;x{i} = {i}&quot;), which eval cannot do.<br>------------------------------------------------------------------ <br><h3> Number File, Id: 57696855, Score: -16: </h3><p>This is a simple answer, this will allow you to clear the screen for example. There are two examples below, with eval and exec, that will print 0 at the top after cleaning (if you're using Windows, change <code>clear</code> to <code>cls</code>, Linux and Mac users leave as is for example) or just execute it, respectively.</p>

<pre><code>eval("os.system(\"clear\")")
exec("os.system(\"clear\")")
</code></pre>
<h4> Jean-Fran&#231;ois Fabre, Comment 111315256 Score: 13: </h4>this code snippet contains the worst 2 security flaws, nested. Some kind of a record.<br><h4> Tuncay G&#246;nc&#252;oğlu, Comment 103975447 Score: 5: </h4>This is not what op asks.<br><h4> InSync, Comment 136480186 Score: 0: </h4>This must have been posted at the wrong question. Please, just delete it.<br>