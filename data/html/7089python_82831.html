 <h2> Title: How do I check whether a file exists without exceptions? </h2> <h3> spence91, question_id: 82831 </h3>Score: 7089, Tags: {python,file,file-exists} <br><p>How do I check whether a file exists or not, without using the <a href="https://docs.python.org/3.6/reference/compound_stmts.html#try" rel="noreferrer"><code>try</code></a> statement?</p>
<h4> Comment 136642016 masterxilo: </h4>Note: your program will not be 100% robust if it cannot handle the case where a file already exists or doesn&#39;t exist at the time you actually try to open or create it respectively. The filesystem is concurrently accessible to multiple programs, so the existance-check you did prior to these actions might already be outdated by the time your program acts on it.<br>------------------------------------------------------------------ <br><h3> Answer 82852 rslite: </h3><p>If the reason you're checking is so you can do something like <code>if file_exists: open_it()</code>, it's safer to use a <code>try</code> around the attempt to open it. Checking and then opening risks the file being deleted or moved or something between when you check and when you try to open it.</p>
<p>If you're not planning to open the file immediately, you can use <a href="https://docs.python.org/library/os.path.html#os.path.isfile" rel="nofollow noreferrer"><code>os.path.isfile</code></a></p>
<blockquote>
<p>Return <code>True</code> if path is an existing regular file. This follows symbolic links, so both <a href="https://docs.python.org/library/os.path.html#os.path.islink" rel="nofollow noreferrer">islink()</a> and <a href="https://docs.python.org/library/os.path.html#os.path.isfile" rel="nofollow noreferrer">isfile()</a> can be true for the same path.</p>
</blockquote>
<pre><code>import os.path
os.path.isfile(fname)
</code></pre>
<p>if you need to be sure it's a file.</p>
<p>Starting with Python 3.4, the <a href="https://docs.python.org/3/library/pathlib.html#pathlib.Path.is_file" rel="nofollow noreferrer"><code>pathlib</code> module</a> offers an object-oriented approach (backported to <code>pathlib2</code> in Python 2.7):</p>
<pre><code>from pathlib import Path

my_file = Path(&quot;/path/to/file&quot;)
if my_file.is_file():
    # file exists
</code></pre>
<p>To check a directory, do:</p>
<pre><code>if my_file.is_dir():
    # directory exists
</code></pre>
<p>To check whether a <code>Path</code> object exists independently of whether is it a file or directory, use <code>exists()</code>:</p>
<pre><code>if my_file.exists():
    # path exists
</code></pre>
<p>You can also use <code>resolve(strict=True)</code> in a <code>try</code> block:</p>
<pre><code>try:
    my_abs_path = my_file.resolve(strict=True)
except FileNotFoundError:
    # doesn't exist
else:
    # exists
</code></pre>
<h4> Comment 134530905 Arkane: </h4>@DmitriiMalygin: this is already mentioned in a comment above by scottclowe (second comment of this anwser at the time I am writing).<br><h4> Comment 114796916 hagello: </h4>@kyrill: Opening a file for appending is not the same as opening it for writing and seeking to the end: When you have concurrent writers, they will overwrite each other without <code>&#39;a&#39;</code>.<br><h4> Comment 88883675 makapuf: </h4>concerning the first remark (use &quot;try&quot; if check before open) unfortunately this will not work if you want to open for appending being sure it exists before since &#39;a&#39; mode will create if not exists.<br><h4> Comment 98506078 kyrill: </h4>@makapuf You can open it for &quot;updating&quot; (<code>open(&#39;file&#39;, &#39;r+&#39;)</code>) and then seek to the end.<br><h4> Comment 97556574 scottclowe: </h4>Note that <code>FileNotFoundError</code> was introduced in Python 3. If you also need to support Python 2.7 as well as Python 3, you can use <code>IOError</code> instead (which <code>FileNotFoundError</code> subclasses) <a href="https://stackoverflow.com/a/21368457/1960959">stackoverflow.com/a/21368457/1960959</a><br><h4> Comment 119272759 user207421: </h4>@makapuf So? The intention is to write to the file, appending if it already exists, creating it if it doesn&#39;t. Your objection doesn&#39;t make sense.<br><h4> Comment 110888699 theX: </h4>Wait, so <code>pathlib2</code> &lt; <code>pathlib</code>? <code>pathlib</code> is for python3, right? I&#39;ve been using <code>pathlib2</code> thinking it was superior.<br><h4> Comment 135263450 carl.anderson: </h4>A common mistake is to check for <code>Path(foo).exists</code>, which is <i>always</i> true (because <code>exists</code> is a function and lazy-evaluates to <code>True</code> when put in a conditional this way).  You probably meant to do this: <code>Path(foo).exists()</code>.<br><h4> Comment 122701426 Nesha25: </h4>@theX yes, the packages are very confusingly named.<br><h4> Comment 134501435 Dmitrii Malygin: </h4>Be aware that the FileNotFoundError exception was added in Python 3. If you require compatibility with both Python 2.7 and Python 3, you can utilize the IOError exception instead, as it is a superclass of FileNotFoundError.<br>------------------------------------------------------------------ <br><h3> Answer 82846 PierreBdR: </h3><p>Use <a href="https://docs.python.org/3/library/os.path.html#os.path.exists" rel="noreferrer"><code>os.path.exists</code></a> to check both files and directories:</p>
<pre><code>import os.path
os.path.exists(file_path)
</code></pre>
<p>Use <a href="https://docs.python.org/3/library/os.path.html#os.path.isfile" rel="noreferrer"><code>os.path.isfile</code></a> to check only files (note: follows <a href="https://en.wikipedia.org/wiki/Symbolic_link" rel="noreferrer">symbolic links</a>):</p>
<pre><code>os.path.isfile(file_path)
</code></pre>
------------------------------------------------------------------ <br><h3> Answer 84173 bortzmeyer: </h3><p>Unlike <a href="https://docs.python.org/library/os.path.html#os.path.isfile" rel="noreferrer"><code>isfile()</code></a>, <a href="https://docs.python.org/library/os.path.html#os.path.exists" rel="noreferrer"><code>exists()</code></a> will return <code>True</code> for directories. So depending on if you want only plain files or also directories, you'll use <code>isfile()</code> or <code>exists()</code>. Here is some simple <a href="https://en.wikipedia.org/wiki/Read-eval-print_loop" rel="noreferrer">REPL</a> output:</p>
<pre><code>&gt;&gt;&gt; os.path.isfile(&quot;/etc/password.txt&quot;)
True
&gt;&gt;&gt; os.path.isfile(&quot;/etc&quot;)
False
&gt;&gt;&gt; os.path.isfile(&quot;/does/not/exist&quot;)
False
&gt;&gt;&gt; os.path.exists(&quot;/etc/password.txt&quot;)
True
&gt;&gt;&gt; os.path.exists(&quot;/etc&quot;)
True
&gt;&gt;&gt; os.path.exists(&quot;/does/not/exist&quot;)
False
</code></pre>
------------------------------------------------------------------ <br><h3> Answer 8876254 Yugal Jindle: </h3><p>Use <a href="https://docs.python.org/3.3/library/os.path.html?highlight=os.path#os.path.isfile" rel="noreferrer"><code>os.path.isfile()</code></a> with <a href="https://docs.python.org/3.3/library/os.html?highlight=os.access#os.access" rel="noreferrer"><code>os.access()</code></a>:</p>

<pre><code>import os

PATH = './file.txt'
if os.path.isfile(PATH) and os.access(PATH, os.R_OK):
    print("File exists and is readable")
else:
    print("Either the file is missing or not readable")
</code></pre>
<h4> Comment 22632456 wim: </h4>having multiple conditions, some of which are superfluous, is <i>less</i> clear and explicit.<br><h4> Comment 85496312 user207421: </h4>It is also redundant. If the file doesn&#39;t exist, <code>os.access()</code> will return false.<br><h4> Comment 90959980 Jester: </h4>since you <code>import os</code>, you do not need to <code>import os.path</code> again as it is already part of <code>os</code>. You just need to import <code>os.path</code> if you are only going to use functions from <code>os.path</code> and not from <code>os</code> itself, to import a smaller thing, but as you use <code>os.access</code> and <code>os.R_OK</code>, the second import is not needed.<br><h4> Comment 89712919 e-info128: </h4>@EJP In linux files can exist but not accesible.<br><h4> Comment 110863476 Martin Meeser: </h4>Checking if the user has access rights to read the file is very professional. Often data is on local drive during dev, and on network share in prod. Then this might lead to such a situation. Also, the code is perfectly clear and readable and explicit.<br>------------------------------------------------------------------ <br><h3> Answer 82836 Paul: </h3><pre><code>import os

if os.path.isfile(filepath):
   print(&quot;File exists&quot;)
</code></pre>
------------------------------------------------------------------ <br><h3> Answer 82841 benefactual: </h3><pre><code>import os
os.path.exists(path) # Returns whether the path (directory or file) exists or not
os.path.isfile(path) # Returns whether the file exists or not
</code></pre>
<h4> Comment 107948750 Homunculus Reticulli: </h4>Generally, not good practise to name variables the same as method names.<br>------------------------------------------------------------------ <br><h3> Answer 44661513 CristiFati: </h3><p>Although almost every possible way has been listed in (at least one of) the existing answers (e.g. <em>Python 3.4</em> specific stuff was added), I'll try to group everything together.</p>
<p><strong>Note</strong>: every piece of <em>Python</em> standard library code that I'm going to post, belongs to version <strong>3.5.3</strong>.</p>
<p><strong>Problem statement</strong>:</p>
<ol>
<li><p>Check file (arguable: also folder (&quot;special&quot; file) ?) existence</p>
</li>
<li><p>Don't use <em><strong>try</strong></em> / <em><strong>except</strong></em> / <em><strong>else</strong></em> / <em><strong>finally</strong></em> blocks</p>
</li>
</ol>
<p><strong>Possible solutions</strong>:</p>
<h4>1. <a href="https://docs.python.org/library/os.path.html#os.path.exists" rel="noreferrer">[Python.Docs]: os.path.exists(path)</a></h4>
<p>Also check other function family members like <em><strong>os.path.isfile</strong></em>, <em>os.path.isdir</em>, <em>os.path.lexists</em> for slightly different behaviors:</p>
<blockquote>
<p>Return <code>True</code> if <em>path</em> refers to an existing path or an open file descriptor. Returns <code>False</code> for broken symbolic links. On some platforms, this function may return <code>False</code> if permission is not granted to execute <a href="https://docs.python.org/library/os.html#os.stat" rel="noreferrer">os.stat()</a> on the requested file, even if the <em>path</em> physically exists.</p>
</blockquote>
<p>All good, but if following the import tree:</p>
<ul>
<li><p><em>os.path</em> - <em>posixpath.py</em> (<em>ntpath.py</em>)</p>
<ul>
<li><p><em>genericpath.py</em> - line <em>~20+</em></p>
<pre class="lang-py prettyprint-override"><code>def exists(path):
    &quot;&quot;&quot;Test whether a path exists.  Returns False for broken symbolic links&quot;&quot;&quot;
    try:
        st = os.stat(path)
    except os.error:
        return False
    return True
</code></pre>
</li>
</ul>
</li>
</ul>
<p>it's just a <em><strong>try</strong></em> / <em><strong>except</strong></em> block around <a href="https://docs.python.org/library/os.html#os.stat" rel="noreferrer">[Python.Docs]: os.stat(path, *, dir_fd=None, follow_symlinks=True)</a>. So, your code is <em><strong>try</strong></em> / <em><strong>except</strong></em> free, but lower in the framestack there's (at least) <strong>one</strong> such block. This also applies to other functions (<strong>including</strong> <em>os.path.isfile</em>).</p>
<h5>1.1. <a href="https://docs.python.org/library/pathlib.html#pathlib.Path.is_file" rel="noreferrer">[Python.Docs]: pathlib - Path.is_file()</a></h5>
<ul>
<li><p>It's a fancier (and more <a href="https://en.wiktionary.org/wiki/Pythonic#Adjective" rel="noreferrer">[Wiktionary]: Pythonic</a>) way of handling paths, <strong>but</strong></p>
</li>
<li><p>Under the hood, it does <strong>exactly</strong> the same thing (<em>pathlib.py</em> - line <em>~1330</em>):</p>
<pre class="lang-py prettyprint-override"><code>def is_file(self):
    &quot;&quot;&quot;
    Whether this path is a regular file (also True for symlinks pointing
        to regular files).
    &quot;&quot;&quot;
    try:
        return S_ISREG(self.stat().st_mode)
    except OSError as e:
        if e.errno not in (ENOENT, ENOTDIR):
            raise
        # Path doesn't exist or is a broken symlink
        # (see https://bitbucket.org/pitrou/pathlib/issue/12/)
        return False
</code></pre>
</li>
</ul>
<h4>2. <a href="https://docs.python.org/reference/datamodel.html#context-managers" rel="noreferrer">[Python.Docs]: With Statement Context Managers</a></h4>
<p>Either:</p>
<ul>
<li><p>Create one:</p>
<pre class="lang-py prettyprint-override"><code>class Swallow:  # Dummy example
    swallowed_exceptions = (FileNotFoundError,)

    def __enter__(self):
        print(&quot;Entering...&quot;)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        print(&quot;Exiting:&quot;, exc_type, exc_value, exc_traceback)
        # Only swallow FileNotFoundError (not e.g. TypeError - if the user passes a wrong argument like None or float or ...)
        return exc_type in Swallow.swallowed_exceptions
</code></pre>
<ul>
<li><p>And its usage - I'll replicate the <em>os.path.isfile</em> behavior (note that this is just for demonstrating purposes, do <strong>not</strong> attempt to write such code for <em>production</em>):</p>
<pre class="lang-py prettyprint-override"><code>import os
import stat


def isfile_seaman(path):  # Dummy func
    result = False
    with Swallow():
        result = stat.S_ISREG(os.stat(path).st_mode)
    return result
</code></pre>
</li>
</ul>
</li>
<li><p>Use <a href="https://docs.python.org/library/contextlib.html#contextlib.suppress" rel="noreferrer">[Python.Docs]: contextlib.suppress(*exceptions)</a> - which was <strong>specifically</strong> designed for selectively suppressing exceptions</p>
</li>
</ul>
<p><br>But, they seem to be wrappers over <em><strong>try</strong></em> / <em><strong>except</strong></em> / <em><strong>else</strong></em> / <em><strong>finally</strong></em> blocks, as <a href="https://docs.python.org/reference/compound_stmts.html#with" rel="noreferrer">[Python.Docs]: Compound statements - The with statement</a> states:</p>
<blockquote>
<p>This allows common <a href="https://docs.python.org/reference/compound_stmts.html#try" rel="noreferrer">try</a>...<a href="https://docs.python.org/reference/compound_stmts.html#except" rel="noreferrer">except</a>...<a href="https://docs.python.org/reference/compound_stmts.html#finally" rel="noreferrer">finally</a> usage patterns to be encapsulated for convenient reuse.</p>
</blockquote>
<h4>3. Filesystem traversal functions</h4>
<p>Search the results for matching item(s):</p>
<ol>
<li><p><a href="https://docs.python.org/library/os.html#os.listdir" rel="noreferrer">[Python.Docs]: os.listdir(path='.')</a> (or <a href="https://docs.python.org/library/os.html#os.scandir" rel="noreferrer">[Python.Docs]: os.scandir(path='.')</a> on <em>Python v<strong>3.5</strong></em>+, backport: <a href="https://pypi.org/project/scandir" rel="noreferrer">[PyPI]: scandir</a>)</p>
<ul>
<li><p>Under the hood, both use:</p>
<ul>
<li><p><em>Nix</em>: <a href="http://man7.org/linux/man-pages/man3/opendir.3.html" rel="noreferrer">[Man7]: OPENDIR(3)</a> / <a href="http://man7.org/linux/man-pages/man3/readdir.3.html" rel="noreferrer">[Man7]: READDIR(3)</a> / <a href="http://man7.org/linux/man-pages/man3/closedir.3.html" rel="noreferrer">[Man7]: CLOSEDIR(3)</a></p>
</li>
<li><p><em>Win</em>: <a href="https://learn.microsoft.com/en-gb/windows/desktop/api/fileapi/nf-fileapi-findfirstfilew" rel="noreferrer">[MS.Learn]: FindFirstFileW function (fileapi.h)</a> / <a href="https://learn.microsoft.com/en-gb/windows/desktop/api/fileapi/nf-fileapi-findnextfilew" rel="noreferrer">[MS.Learn]: FindNextFileW function (fileapi.h)</a> / <a href="https://learn.microsoft.com/en-gb/windows/desktop/api/fileapi/nf-fileapi-findclose" rel="noreferrer">[MS.Learn]: FindClose function (fileapi.h)</a></p>
</li>
</ul>
<p>via <a href="https://github.com/python/cpython/blob/main/Modules/posixmodule.c" rel="noreferrer">[GitHub]: python/cpython - (main) cpython/Modules/posixmodule.c</a></p>
</li>
</ul>
<blockquote>
<p>Using <a href="https://docs.python.org/library/os.html#os.scandir" rel="noreferrer">scandir()</a> instead of <a href="https://docs.python.org/library/os.html#os.listdir" rel="noreferrer">listdir()</a> can significantly increase the performance of code that also needs file type or file attribute information, because <a href="https://docs.python.org/library/os.html#os.DirEntry" rel="noreferrer">os.DirEntry</a> objects expose this information if the operating system provides it when scanning a directory. All <a href="https://docs.python.org/library/os.html#os.DirEntry" rel="noreferrer">os.DirEntry</a> methods may perform a system call, but <a href="https://docs.python.org/library/os.html#os.DirEntry.is_dir" rel="noreferrer">is_dir()</a> and <a href="https://docs.python.org/library/os.html#os.DirEntry.is_file" rel="noreferrer">is_file()</a> usually only require a system call for symbolic links; <a href="https://docs.python.org/library/os.html#os.DirEntry.stat" rel="noreferrer">os.DirEntry.stat()</a> always requires a system call on Unix, but only requires one for symbolic links on Windows.</p>
</blockquote>
</li>
<li><p><a href="https://docs.python.org/library/os.html#os.walk" rel="noreferrer">[Python.Docs]: os.walk(top, topdown=True, onerror=None, followlinks=False)</a></p>
<ul>
<li>Uses <em>os.listdir</em> (<em>os.scandir</em> when available)</li>
</ul>
</li>
<li><p><a href="https://docs.python.org/library/glob.html#glob.iglob" rel="noreferrer">[Python.Docs]: glob.iglob(pathname, *, root_dir=None, dir_fd=None, recursive=False, include_hidden=False)</a> (or its predecessor: <em>glob.glob</em>)</p>
<ul>
<li>Doesn't seem a traversing function <em>per se</em> (at least in some cases), but it still uses <em>os.listdir</em></li>
</ul>
</li>
</ol>
<p><br>Since these iterate over folders, (in most of the cases) they are inefficient for our problem (there are exceptions, like non wildcarded globbing - as @ShadowRanger pointed out), so I'm not going to insist on them. Not to mention that in some cases, filename processing might be required.</p>
<h4>4. <a href="https://docs.python.org/library/os.html#os.access" rel="noreferrer">[Python.Docs]: os.access(path, mode, *, dir_fd=None, effective_ids=False, follow_symlinks=True)</a></h4>
<p>Its behavior is close to <em>os.path.exists</em> (actually it's wider, mainly because of the 2<sup>nd</sup> argument).</p>
<ul>
<li><p><strong>User permissions</strong> might restrict the file &quot;visibility&quot; as the <em>doc</em> states:</p>
<blockquote>
<p>... test if the invoking user has the specified access to <em>path</em>. <em>mode</em> should be <a href="https://docs.python.org/library/os.html#os.F_OK" rel="noreferrer">F_OK</a> to test the existence of path...</p>
</blockquote>
</li>
<li><p><strong>Security considerations</strong>:</p>
<blockquote>
<p>Using <a href="https://docs.python.org/library/os.html#os.access" rel="noreferrer">access()</a> to check if a user is authorized to e.g. open a file before actually doing so using <a href="https://docs.python.org/library/functions.html#open" rel="noreferrer">open()</a> creates a security hole, because the user might exploit the short time interval between checking and opening the file to manipulate it.</p>
</blockquote>
</li>
</ul>
<pre class="lang-py prettyprint-override"><code>os.access(&quot;/tmp&quot;, os.F_OK)
</code></pre>
<p>Since I also work in <em>C</em>, I use this method as well because under the hood, it calls <strong>native <em>API</em>s</strong> (again, via &quot;<em>${PYTHON_SRC_DIR}/Modules/posixmodule.c</em>&quot;), but it also opens a gate for possible <strong>user errors</strong>, and it's not as <em>Python</em>ic as other variants. So, don't use it unless you know what you're doing:</p>
<ul>
<li><p><em>Nix</em>: <a href="http://man7.org/linux/man-pages/man2/access.2.html" rel="noreferrer">[Man7]: ACCESS(2)</a></p>
<blockquote>
<p>Warning: Using these calls to check if a user is authorized to, for example, open a file before actually doing so using <a href="https://man7.org/linux/man-pages/man2/open.2.html" rel="noreferrer">open(2)</a> creates a security hole, because the user might exploit the short time interval between checking and opening the file to manipulate it. <strong>For this reason, the use of this system call should be avoided</strong>.</p>
</blockquote>
</li>
<li><p><em>Win</em>: <a href="https://learn.microsoft.com/en-gb/windows/desktop/api/fileapi/nf-fileapi-getfileattributesw" rel="noreferrer">[MS.Learn]: GetFileAttributesW function (fileapi.h)</a></p>
</li>
</ul>
<p>As seen, <strong>this approach is highly discouraged</strong> (especially on <em>Nix</em>).</p>
<p><strong>Note</strong>: calling native <em>API</em>s is also possible via <a href="https://docs.python.org/library/ctypes.html#module-ctypes" rel="noreferrer">[Python.Docs]: ctypes - A foreign function library for Python</a>, but in most cases it's more complicated. Before working with <em>CTypes</em>, check <a href="https://stackoverflow.com/a/58611011/4788546">[SO]: C function called from Python via ctypes returns incorrect value (@CristiFati's answer)</a> out.</p>
<p>(<em><strong>Win</strong></em> specific): since <em>vcruntime###.dll</em> (<em>msvcr###.dll</em> for older <em>VStudio</em> versions - I'm going to refer to it as <em><strong>UCRT</strong></em>) exports a <a href="https://learn.microsoft.com/en-us/cpp/c-runtime-library/reference/access-waccess" rel="noreferrer">[MS.Learn]: _access, _waccess</a> function family as well, here's an example (note that the recommended <a href="https://docs.python.org/library/msvcrt.html" rel="noreferrer">[Python.Docs]: msvcrt - Useful routines from the MS VC++ runtime</a> doesn't export them):</p>
<blockquote>
<pre><code>Python 3.5.3 (v3.5.3:1880cb95a742, Jan 16 2017, 16:02:32) [MSC v.1900 64 bit (AMD64)] on win32
Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.
&gt;&gt;&gt; import ctypes as cts, os
&gt;&gt;&gt; cts.CDLL(&quot;msvcrt&quot;)._waccess(u&quot;C:\\Windows\\Temp&quot;, os.F_OK)
0
&gt;&gt;&gt; cts.CDLL(&quot;msvcrt&quot;)._waccess(u&quot;C:\\Windows\\Temp.notexist&quot;, os.F_OK)
-1
</code></pre>
</blockquote>
<p><strong>Notes</strong>:</p>
<ul>
<li><p>Although it's not a good practice, I'm using <em>os.F_OK</em> in the call, but that's just for clarity (its value is <strong>0</strong>)</p>
</li>
<li><p>I'm using <em>_waccess</em> so that the same code works on <em>Python 3</em> and <em>Python 2</em> (in spite of <a href="https://en.wikipedia.org/wiki/Unicode" rel="noreferrer">[Wikipedia]: Unicode</a> related differences between them - <a href="https://stackoverflow.com/a/59521873/4788546">[SO]: Passing utf-16 string to a Windows function (@CristiFati's answer)</a>)</p>
</li>
<li><p>Although this targets a very specific area, <strong>it was not mentioned in any of the previous answers</strong></p>
</li>
</ul>
<p><br>The <em>Linux</em> (<em>Ubuntu</em> (<a href="https://en.wikipedia.org/wiki/Ubuntu_version_history" rel="noreferrer">[Wikipedia]: Ubuntu version history</a>) <em>16 x86_64</em> (<em>pc064</em>)) counterpart as well:</p>
<blockquote>
<pre><code>Python 3.5.2 (default, Nov 17 2016, 17:05:23)
[GCC 5.4.0 20160609] on linux
Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.
&gt;&gt;&gt; import ctypes as cts, os
&gt;&gt;&gt; cts.CDLL(&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;).access(b&quot;/tmp&quot;, os.F_OK)
0
&gt;&gt;&gt; cts.CDLL(&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;).access(b&quot;/tmp.notexist&quot;, os.F_OK)
-1
</code></pre>
</blockquote>
<p><strong>Notes</strong>:</p>
<ul>
<li><p>Instead hardcoding <em>libc.so</em> (<em>LibC</em>)'s path (&quot;<em>/lib/x86_64-linux-gnu/libc.so.6</em>&quot;) which may (and most likely, will) vary across systems, <em>None</em> (or the empty string) can be passed to <em>CDLL</em> constructor (<strong><code>ctypes.CDLL(None).access(b&quot;/tmp&quot;, os.F_OK)</code></strong>). According to <a href="http://man7.org/linux/man-pages/man3/dlopen.3.html" rel="noreferrer">[Man7]: DLOPEN(3)</a>:</p>
<blockquote>
<p>If <em>filename</em> is NULL, then the returned handle is for the main
program.  When given to <a href="https://man7.org/linux/man-pages/man3/dlsym.3.html" rel="noreferrer">dlsym(3)</a>, this handle causes a search for a
symbol in the main program, followed by all shared objects loaded at
program startup, and then all shared objects loaded by <strong>dlopen</strong>() with
the flag <strong>RTLD_GLOBAL</strong>.</p>
</blockquote>
</li>
<li><p>Main (current) program (<em>python</em>) is linked against <em>LibC</em>, so its symbols (including <em>access</em>) will be loaded</p>
</li>
<li><p>This has to be handled with care, since functions like <em>main</em>, <em>Py_Main</em> and (all the) others are available; calling them could have disastrous effects (on the current program)</p>
</li>
<li><p>This doesn't also apply to <em>Windows</em> (but that's not such a big deal, since <em>UCRT</em> is located in &quot;<em>%SystemRoot%\System32</em>&quot; which is in <em>%PATH%</em> by default). I wanted to take things further and replicate this behavior on <em>Windows</em> (and submit a patch), but as it turns out, <a href="https://learn.microsoft.com/en-gb/windows/desktop/api/libloaderapi/nf-libloaderapi-getprocaddress" rel="noreferrer">[MS.Learn]: GetProcAddress function (libloaderapi.h)</a> only &quot;sees&quot; <strong>exported</strong> symbols, so unless someone declares the functions in the main executable as <code>__declspec(dllexport)</code> (why on Earth the common person would do that?), the main program is loadable, but it is pretty much unusable</p>
</li>
</ul>
<h4>5. 3<sup>rd</sup>-party modules with filesystem capabilities</h4>
<p>Most likely, will rely on one of the ways above (maybe with slight customizations). <br>One example would be (again, <em>Win</em> specific) <a href="https://github.com/mhammond/pywin32" rel="noreferrer">[GitHub]: mhammond/pywin32 - Python for Windows (pywin32) Extensions</a>, which is a <em>Python</em> wrapper over <em>WinAPI</em>s.</p>
<p>But, since this is more like a workaround, I'm stopping here.</p>
<h4>6. <em>SysAdmin</em> approach</h4>
<p>I consider this a (lame) workaround (<em>gainarie</em>): use <em>Python</em> as a wrapper to execute shell commands:</p>
<ul>
<li><p><em>Win</em>:</p>
<blockquote>
<pre><code>(py35x64_test) [cfati@CFATI-5510-0:e:\Work\Dev\StackOverflow\q000082831]&gt; &quot;e:\Work\Dev\VEnvs\py35x64_test\Scripts\python.exe&quot; -c &quot;import os; print(os.system('dir /b \&quot;C:\\Windows\\Temp\&quot; &gt; nul 2&gt;&amp;1'))&quot;
0

(py35x64_test) [cfati@CFATI-5510-0:e:\Work\Dev\StackOverflow\q000082831]&gt; &quot;e:\Work\Dev\VEnvs\py35x64_test\Scripts\python.exe&quot; -c &quot;import os; print(os.system('dir /b \&quot;C:\\Windows\\Temp.notexist\&quot; &gt; nul 2&gt;&amp;1'))&quot;
1
</code></pre>
</blockquote>
</li>
<li><p><em>Nix</em> (<a href="https://en.wikipedia.org/wiki/Unix-like" rel="noreferrer">[Wikipedia]: Unix-like</a>) - <em>Ubuntu</em>:</p>
<blockquote>
<pre><code>[cfati@cfati-5510-0:/mnt/e/Work/Dev/StackOverflow/q000082831]&gt; python3 -c &quot;import os; print(os.system('ls \&quot;/tmp\&quot; &gt; /dev/null 2&gt;&amp;1'))&quot;
0
[cfati@cfati-5510-0:/mnt/e/Work/Dev/StackOverflow/q000082831]&gt; python3 -c &quot;import os; print(os.system('ls \&quot;/tmp.notexist\&quot; &gt; /dev/null 2&gt;&amp;1'))&quot;
512
</code></pre>
</blockquote>
</li>
</ul>
<h4>Bottom line:</h4>
<ul>
<li><p><strong>Do</strong> use <em><strong>try</strong></em> / <em><strong>except</strong></em> / <em><strong>else</strong></em> / <em><strong>finally</strong></em> blocks, because they can prevent you running into a series of nasty problems</p>
</li>
<li><p>A possible counterexample that I can think of, is performance: such blocks are costly, so try not to place them in code that it's supposed to run hundreds of thousands times per second (but since (in most cases) it involves disk access, it won't be the case)</p>
</li>
</ul>
<h4> Comment 81719320 CristiFati: </h4>@sk8asd123: Kind of hard to doo it in a comment: generally, it&#39;s best to use constants with functions that they come together with. That applies when working with multiple modules that define the same constant, because some might not be up to date, and it&#39;s best for the functions and constants to be in sync. When working with <i>ctypes</i> (calling the functions directly) I should have defined the constant (from <i>MSDN</i>), or not use a constant at all. It&#39;s just a guideline that I use, in 99.9% it probably makes no difference (functionally).<br><h4> Comment 82076526 ShadowRanger: </h4>@CristiFati: As of 3.6, <a href="https://docs.python.org/3/whatsnew/3.6.html#optimizations" rel="nofollow noreferrer"><code>glob.iglob</code> (and <code>glob.glob</code> as well) are based on <code>os.scandir</code></a>, so it&#39;s lazy now; to get the first hit in a directory of 10M files, you only scan until you reach the first hit. And even pre-3.6, if you use <code>glob</code> methods w/o any wildcards, the function is smart: It knows you can only have one hit, so <a href="https://github.com/python/cpython/blob/3ae41554c69b807659fab815ad5675bed5ae237/Lib/glob.py#L41" rel="nofollow noreferrer">it simplifies the globbing to just <code>os.path.isdir</code> or <code>os.path.lexists</code></a> (depending on whether path ends in <code>&#47;</code>).<br><h4> Comment 82076809 ShadowRanger: </h4>That second part of my comment (non-wildcarded globbing doesn&#39;t actually iterate the folder, and never has) does mean it&#39;s a perfectly efficient solution to the problem (slower than directly calling <code>os.path.isdir</code> or <code>os.path.lexist</code> since it&#39;s a bunch of Python level function calls and string operations before it decides the efficient path is viable, but no additional system call or I/O work, which is orders of magnitude slower).<br>------------------------------------------------------------------ <br><h3> Answer 21641213 Cody Piersall: </h3><p><strong>Python 3.4+</strong> has an object-oriented path module: <a href="https://docs.python.org/3/library/pathlib.html" rel="noreferrer"><strong>pathlib</strong></a>.  Using this new module, you can check whether a file exists like this:</p>
<pre><code>import pathlib
p = pathlib.Path('path/to/file')
if p.is_file():  # or p.is_dir() to see if it is a directory
    # do stuff
</code></pre>
<p>You can (and usually should) still use a <code>try/except</code> block when opening files:</p>
<pre><code>try:
    with p.open() as f:
        # do awesome stuff
except OSError:
    print('Well darn.')
</code></pre>
<p>The pathlib module has lots of cool stuff in it: convenient globbing, checking file's owner, easier path joining, etc.  It's worth checking out.  If you're on an older Python (version 2.6 or later), you can still install pathlib with pip:</p>
<pre><code># installs pathlib2 on older Python versions
# the original third-party module, pathlib, is no longer maintained.
pip install pathlib2
</code></pre>
<p>Then import it as follows:</p>
<pre><code># Older Python versions
import pathlib2 as pathlib
</code></pre>
<h4> Comment 113717510 Ryan Haining: </h4>You can use <a href="https://docs.python.org/3/library/pathlib.html#pathlib.Path.exists" rel="nofollow noreferrer"><code>pathlib.Path.exists</code></a>, which covers more cases than <code>is_file</code><br>------------------------------------------------------------------ <br><h3> Answer 17344732 Val Neekman: </h3><p>This is the simplest way to check if a file exists. Just <strong>because</strong> the file existed when you checked doesn't <strong>guarantee</strong> that it will be there when you need to open it.</p>

<pre><code>import os
fname = "foo.txt"
if os.path.isfile(fname):
    print("file does exist at this time")
else:
    print("no such file exists at this time")
</code></pre>
<h4> Comment 42691489 Isaac Supeene: </h4>As long as you intend to access the file, the race condition <i>does exist</i>, regardless of how your program is constructed.  Your program cannot guarantee that another process on the computer has not modified the file.  It&#39;s what Eric Lippert refers to as an <a href="http://blogs.msdn.com/b/ericlippert/archive/2008/09/10/vexing-exceptions.aspx" rel="nofollow noreferrer">exogenous exception</a>.  You cannot avoid it by checking for the file&#39;s existence beforehand.<br><h4> Comment 90101673 Val Neekman: </h4>@IsaacSupeene Best practice is to make the window of (file) operation as small as possible followed by a proper exception handling<br><h4> Comment 121938857 Anders Lind&#233;n: </h4>The best would be to open the file, using try+catch and there is no time window.<br>------------------------------------------------------------------ <br><h3> Answer 31932925 Russia Must Remove Putin: </h3><blockquote>
  <h2>How do I check whether a file exists, using Python, without using a try statement?</h2>
</blockquote>

<p>Now available since Python 3.4, import and instantiate a <code>Path</code> object with the file name, and check the <code>is_file</code> method (note that this returns True for symlinks pointing to regular files as well):</p>

<pre><code>&gt;&gt;&gt; from pathlib import Path
&gt;&gt;&gt; Path('/').is_file()
False
&gt;&gt;&gt; Path('/initrd.img').is_file()
True
&gt;&gt;&gt; Path('/doesnotexist').is_file()
False
</code></pre>

<p>If you're on Python 2, you can backport the pathlib module from pypi, <a href="https://pypi.python.org/pypi/pathlib2/" rel="noreferrer"><code>pathlib2</code></a>, or otherwise check <code>isfile</code> from the <code>os.path</code> module:</p>

<pre><code>&gt;&gt;&gt; import os
&gt;&gt;&gt; os.path.isfile('/')
False
&gt;&gt;&gt; os.path.isfile('/initrd.img')
True
&gt;&gt;&gt; os.path.isfile('/doesnotexist')
False
</code></pre>

<p>Now the above is probably the best pragmatic direct answer here, but there's the possibility of a race condition (depending on what you're trying to accomplish), and the fact that the underlying implementation uses a <code>try</code>, but Python uses <code>try</code> everywhere in its implementation. </p>

<p>Because Python uses <code>try</code> everywhere, there's really no reason to avoid an implementation that uses it.</p>

<p>But the rest of this answer attempts to consider these caveats.</p>

<h2>Longer, much more pedantic answer</h2>

<p>Available since Python 3.4, use the new <code>Path</code> object in <code>pathlib</code>. Note that <code>.exists</code> is not quite right, because directories are not files (except in the unix sense that <em>everything</em> is a file).</p>

<pre><code>&gt;&gt;&gt; from pathlib import Path
&gt;&gt;&gt; root = Path('/')
&gt;&gt;&gt; root.exists()
True
</code></pre>

<p>So we need to use <code>is_file</code>:</p>

<pre><code>&gt;&gt;&gt; root.is_file()
False
</code></pre>

<p>Here's the help on <code>is_file</code>:</p>

<pre><code>is_file(self)
    Whether this path is a regular file (also True for symlinks pointing
    to regular files).
</code></pre>

<p>So let's get a file that we know is a file:</p>

<pre><code>&gt;&gt;&gt; import tempfile
&gt;&gt;&gt; file = tempfile.NamedTemporaryFile()
&gt;&gt;&gt; filepathobj = Path(file.name)
&gt;&gt;&gt; filepathobj.is_file()
True
&gt;&gt;&gt; filepathobj.exists()
True
</code></pre>

<p>By default, <code>NamedTemporaryFile</code> deletes the file when closed (and will automatically close when no more references exist to it).</p>

<pre><code>&gt;&gt;&gt; del file
&gt;&gt;&gt; filepathobj.exists()
False
&gt;&gt;&gt; filepathobj.is_file()
False
</code></pre>

<p>If you dig into <a href="https://github.com/python/cpython/blob/master/Lib/pathlib.py#L1318" rel="noreferrer">the implementation</a>, though, you'll see that <code>is_file</code> uses <code>try</code>:</p>

<pre><code>def is_file(self):
    """
    Whether this path is a regular file (also True for symlinks pointing
    to regular files).
    """
    try:
        return S_ISREG(self.stat().st_mode)
    except OSError as e:
        if e.errno not in (ENOENT, ENOTDIR):
            raise
        # Path doesn't exist or is a broken symlink
        # (see https://bitbucket.org/pitrou/pathlib/issue/12/)
        return False
</code></pre>

<h2>Race Conditions: Why we like try</h2>

<p>We like <code>try</code> because it avoids race conditions. With <code>try</code>, you simply attempt to read your file, expecting it to be there, and if not, you catch the exception and perform whatever fallback behavior makes sense.</p>

<p>If you want to check that a file exists before you attempt to read it, and you might be deleting it and then you might be using multiple threads or processes, or another program knows about that file and could delete it - you risk the chance of a <strong>race condition</strong> if you check it exists, because you are then <em>racing</em> to open it before its <em>condition</em> (its existence) changes. </p>

<p>Race conditions are very hard to debug because there's a very small window in which they can cause your program to fail.</p>

<p>But if this is your motivation, you <em>can</em> get the value of a <code>try</code> statement by using the <code>suppress</code> context manager.</p>

<h2>Avoiding race conditions without a try statement: <code>suppress</code></h2>

<p>Python 3.4 gives us the <a href="https://docs.python.org/3/library/contextlib.html#contextlib.suppress" rel="noreferrer"><code>suppress</code></a> context manager (previously the <a href="https://bugs.python.org/issue19266" rel="noreferrer"><code>ignore</code></a> context manager), which does semantically exactly the same thing in fewer lines, while also (at least superficially) meeting the original ask to avoid a <code>try</code> statement:</p>

<pre><code>from contextlib import suppress
from pathlib import Path
</code></pre>

<p>Usage:</p>

<pre><code>&gt;&gt;&gt; with suppress(OSError), Path('doesnotexist').open() as f:
...     for line in f:
...         print(line)
... 
&gt;&gt;&gt;
&gt;&gt;&gt; with suppress(OSError):
...     Path('doesnotexist').unlink()
... 
&gt;&gt;&gt; 
</code></pre>

<p>For earlier Pythons, you could roll your own <code>suppress</code>, but without a <code>try</code> will be more verbose than with. I do believe <strong>this actually is the only answer that doesn't use <code>try</code> at any level in the Python</strong> that can be applied to prior to Python 3.4 because it uses a context manager instead:</p>

<pre><code>class suppress(object):
    def __init__(self, *exceptions):
        self.exceptions = exceptions
    def __enter__(self):
        return self
    def __exit__(self, exc_type, exc_value, traceback):
        if exc_type is not None:
            return issubclass(exc_type, self.exceptions)
</code></pre>

<p>Perhaps easier with a try:</p>

<pre><code>from contextlib import contextmanager

@contextmanager
def suppress(*exceptions):
    try:
        yield
    except exceptions:
        pass
</code></pre>

<h2>Other options that don't meet the ask for "without try":</h2>

<p><strong>isfile</strong></p>

<pre><code>import os
os.path.isfile(path)
</code></pre>

<p>from the <a href="https://docs.python.org/library/os.path.html#os.path.isfile" rel="noreferrer">docs</a>:</p>

<blockquote>
  <p><code>os.path.isfile(path)</code></p>
  
  <p>Return True if path is an existing regular file. This follows symbolic
  links, so both <code>islink()</code> and <code>isfile()</code> can be true for the same path.</p>
</blockquote>

<p>But if you examine the <a href="https://hg.python.org/cpython/file/tip/Lib/genericpath.py#l25" rel="noreferrer">source</a> of this function, you'll see it actually does use a try statement:</p>

<blockquote>
<pre><code># This follows symbolic links, so both islink() and isdir() can be true
# for the same path on systems that support symlinks
def isfile(path):
    """Test whether a path is a regular file"""
    try:
        st = os.stat(path)
    except os.error:
        return False
    return stat.S_ISREG(st.st_mode)
</code></pre>
</blockquote>

<pre><code>&gt;&gt;&gt; OSError is os.error
True
</code></pre>

<p>All it's doing is using the given path to see if it can get stats on it,  catching <code>OSError</code> and then checking if it's a file if it didn't raise the exception.</p>

<p>If you intend to do something with the file, I would suggest directly attempting it with a try-except to avoid a race condition:</p>

<pre><code>try:
    with open(path) as f:
        f.read()
except OSError:
    pass
</code></pre>

<p><strong>os.access</strong></p>

<p>Available for Unix and Windows is <code>os.access</code>, but to use you must pass flags, and it does not differentiate between files and directories. This is more used to test if the real invoking user has access in an elevated privilege environment:</p>

<pre><code>import os
os.access(path, os.F_OK)
</code></pre>

<p>It also suffers from the same race condition problems as <code>isfile</code>. From the <a href="https://docs.python.org/2/library/os.html#os.access" rel="noreferrer">docs</a>:</p>

<blockquote>
  <p>Note:
  Using access() to check if a user is authorized to e.g. open a file
  before actually doing so using open() creates a security hole, because
  the user might exploit the short time interval between checking and
  opening the file to manipulate it. It’s preferable to use EAFP
  techniques. For example:</p>

<pre><code>if os.access("myfile", os.R_OK):
    with open("myfile") as fp:
        return fp.read()
return "some default data"
</code></pre>
  
  <p>is better written as:</p>

<pre><code>try:
    fp = open("myfile")
except IOError as e:
    if e.errno == errno.EACCES:
        return "some default data"
    # Not a permission error.
    raise
else:
    with fp:
        return fp.read()
</code></pre>
</blockquote>

<p>Avoid using <code>os.access</code>. It is a low level function that has more opportunities for user error than the higher level objects and functions discussed above.</p>

<h3>Criticism of another answer:</h3>

<p>Another answer says this about <code>os.access</code>:</p>

<blockquote>
  <p>Personally, I prefer this one because under the hood, it calls native APIs (via "${PYTHON_SRC_DIR}/Modules/posixmodule.c"), but it also opens a gate for possible user errors, and it's not as Pythonic as other variants:</p>
</blockquote>

<p>This answer says it prefers a non-Pythonic, error-prone method, with no justification. It seems to encourage users to use low-level APIs without understanding them. </p>

<p>It also creates a context manager which, by unconditionally returning <code>True</code>, allows all Exceptions (including <code>KeyboardInterrupt</code> and <code>SystemExit</code>!) to pass silently, which is a good way to hide bugs.</p>

<p>This seems to encourage users to adopt poor practices.</p>
------------------------------------------------------------------ <br><h3> Answer 1671095 pkoch: </h3><p>Prefer the try statement. It's considered better style and avoids race conditions.</p>
<p>Don't take my word for it. There's plenty of support for this theory. Here's a couple:</p>
<ul>
<li>Style: Section &quot;Handling unusual conditions&quot; of <a href="http://allendowney.com/sd/notes/notes11.txt" rel="noreferrer">these course notes for <em>Software Design</em></a> (2007)</li>
<li><a href="https://developer.apple.com/library/mac/#documentation/security/conceptual/SecureCodingGuide/Articles/RaceConditions.html#//apple_ref/doc/uid/TP40002585-SW8" rel="noreferrer">Avoiding Race Conditions</a></li>
</ul>
<h4> Comment 53489212 jstine: </h4>The cited Avoiding Race Conditions (apple dev support) link does not support your answer.  It concerns only using temporary files that contain sensitive information on poorly designed operating systems that don&#39;t properly sandbox temporary files / directories via restricted permissions.  Using <code>try...except</code> doesn&#39;t help resolve <i>that</i> problem anyway.<br><h4> Comment 52854966 BlueTrin: </h4>Please add better sources to support your statement.<br><h4> Comment 134597322 Ben Farmer: </h4>But one typically opens files with context managers, and plenty of packages don&#39;t seem to implement them with terribly good exceptions. E.g. xarray just throws a super generic &quot;ValueError&quot; with some confusing message about the backend if you try to open say a folder instead of a netcdf file. Catching a ValueError here could mask all sorts of other problems.<br><h4> Comment 99194383 Camion: </h4>The problem with this method, is that if you have an important piece of code depending on the file not existing, putting it in the <code>except:</code> clause will make that an exception arising in this part of your code will raise a confusing message (second error raised during the processing of the first one.)<br>------------------------------------------------------------------ <br><h3> Answer 30444116 incalite: </h3><p>Use:</p>
<pre><code>import os
#Your path here e.g. &quot;C:\Program Files\text.txt&quot;
#For access purposes: &quot;C:\\Program Files\\text.txt&quot;
if os.path.exists(&quot;C:\...&quot;):
    print &quot;File found!&quot;
else:
    print &quot;File not found!&quot;
</code></pre>
<p>Importing <code>os</code> makes it easier to navigate and perform standard actions with your operating system.</p>
<p>For reference, also see <em><a href="/q/82831">How do I check whether a file exists without exceptions?</a></em>.</p>
<p>If you need high-level operations, use <code>shutil</code>.</p>
<h4> Comment 51457641 Chris Johnson: </h4>This answer is wrong. <code>os.path.exists</code> returns true for things that aren&#39;t files, such as directories. This gives false positives. See the other answers that recommend <code>os.path.isfile</code>.<br>------------------------------------------------------------------ <br><h3> Answer 39932496 Tom Fuller: </h3><p>Testing for files and folders with <code>os.path.isfile()</code>, <code>os.path.isdir()</code> and <code>os.path.exists()</code></p>

<p>Assuming that the "path" is a valid path, this table shows what is returned by each function for files and folders:</p>

<p><a href="https://i.stack.imgur.com/tOs9p.png"><img src="https://i.stack.imgur.com/tOs9p.png" alt="enter image description here"></a></p>

<p>You can also test if a file is a certain type of file using <code>os.path.splitext()</code> to get the extension (if you don't already know it)</p>

<pre><code>&gt;&gt;&gt; import os
&gt;&gt;&gt; path = "path to a word document"
&gt;&gt;&gt; os.path.isfile(path)
True
&gt;&gt;&gt; os.path.splitext(path)[1] == ".docx" # test if the extension is .docx
True
</code></pre>
------------------------------------------------------------------ <br><h3> Answer 65857751 Memin: </h3><p><strong>TL;DR</strong> <br>
The answer is: use the <strong><code>pathlib</code></strong> module</p>
<hr />
<p><strong>Pathlib</strong> is probably the most modern and convenient way for almost all of the file operations. For the existence of a <strong>file</strong> or a <strong>folder</strong> a single line of code is enough. If file is not exists, it will <em><strong>not</strong></em> throw any exception.</p>
<pre><code>from pathlib import Path

if Path(&quot;myfile.txt&quot;).exists(): # works for both file and folders
    # do your cool stuff...
</code></pre>
<p>The <code>pathlib</code> module was introduced in Python 3.4, so you need to have Python 3.4+. This library makes your life much easier while working with files and folders, and it is pretty to use. Here is more documentation about it: <em><a href="https://docs.python.org/3/library/pathlib.html" rel="noreferrer">pathlib — Object-oriented filesystem paths</a></em>.</p>
<p>BTW, if you are going to reuse the path, then it is better to assign it to a variable.</p>
<p>So it will become:</p>
<pre><code>from pathlib import Path

p = Path(&quot;loc/of/myfile.txt&quot;)
if p.exists(): # works for both file and folders
    # do stuffs...
#reuse 'p' if needed.
</code></pre>
<h4> Comment 120427207 bravhek: </h4>Be aware that this returns True if the file is not present but path to file exists. If you are really interested in asking whether the file exists or not you should be using p.is_file()<br><h4> Comment 133573685 starriet: </h4>@bravhek I think your comment is confusing. What do you mean by &#39;path to file&#39;? If you mean &#39;path to dir&#39;, and if the directory exists, then of course it works as it should. The OP said <code>p.exists()</code> works for both files and folders.<br><h4> Comment 133597974 Bravhek: </h4>@starriet, The question is about the existence of the file, however p.exists() will return a false positive when the folder containing the checked file exists but the file itself doesn&#39;t.<br><h4> Comment 133601620 Memin: </h4>@Bravhek, can you please give an example to better highlight the issue, I may also update my answer accordingly, to better inform the users. Thank you.<br><h4> Comment 133606828 Bravhek: </h4>@Memin, suppose you want to check if the file &quot;myfile.txt&quot;, exists in folder &quot;c:\temp&quot;. if you declare fpath = Path(r&quot;c:\temp\myfile.txt&quot;), and then check for fpath.exists(), it will return True  but the file does not exists! (false positive)...  in contrast fpath.is_file() will return false, wich is the desired output.<br><h4> Comment 133610242 Memin: </h4>@Bravhek I&#39;m not sure if I&#39;ve understood this correctly. I tried creating a temporary file inside the &#39;/tmp&#39; directory using the example code at <a href="https://onecompiler.com/python/3z2ntw9r9" rel="nofollow noreferrer">onecompiler.com/python/3z2ntw9r9</a>, and when I checked for the existence of the file, it returned True as expected. Similarly, when I searched for a file that did not exist, it returned False as expected. Could you please provide some sample code that I can use to test your explanation? Thank you.<br>------------------------------------------------------------------ <br><h3> Answer 35602588 KaiBuxe: </h3><p>In 2016 the best way is still using <code>os.path.isfile</code>:</p>

<pre><code>&gt;&gt;&gt; os.path.isfile('/path/to/some/file.txt')
</code></pre>

<p>Or in Python 3 you can use <code>pathlib</code>:</p>

<pre><code>import pathlib
path = pathlib.Path('/path/to/some/file.txt')
if path.is_file():
    ...
</code></pre>
<h4> Comment 58931770 KaiBuxe: </h4><code>pathlib</code> is python&#39;s OOP solution for paths. You can do a lot more with it. If you just need to check existance, the advantage is not so big.<br>------------------------------------------------------------------ <br><h3> Answer 18994918 chad: </h3><p>It doesn't seem like there's a meaningful functional difference between try/except and <code>isfile()</code>, so you should use which one makes sense.</p>
<p>If you want to read a file, if it exists, do</p>
<pre><code>try:
    f = open(filepath)
except IOError:
    print 'Oh dear.'
</code></pre>
<p>But if you just wanted to rename a file if it exists, and therefore don't need to open it, do</p>
<pre><code>if os.path.isfile(filepath):
    os.rename(filepath, filepath + '.old')
</code></pre>
<p>If you want to write to a file, if it doesn't exist, do</p>
<pre><code># Python 2
if not os.path.isfile(filepath):
    f = open(filepath, 'w')

# Python 3: x opens for exclusive creation, failing if the file already exists
try:
    f = open(filepath, 'wx')
except IOError:
    print 'file already exists'
</code></pre>
<p>If you need file locking, that's a different matter.</p>
<h4> Comment 52254047 spectras: </h4>On your third example, I create a link named <code>filepath</code> with the right timing, and <i>BAM</i>, you overwrite the target file. You should do <code>open(filepath, &#39;wx&#39;)</code> in a <code>try...except</code> block to avoid the issue.<br><h4> Comment 51457606 Chris Johnson: </h4>This answer is wrong. <code>os.path.exists</code> returns true for things that aren&#39;t files, such as directories. This gives false positives. See the other answers that recommend <code>os.path.isfile</code>.<br><h4> Comment 62338288 Tom Myddeltyn: </h4>In your second example, at least in Windows, you will get an <code>OSError</code> if <code>filepath + &#39;.old&#39;</code> already exists: &quot;On Windows, if dst already exists, OSError will be raised even if it is a file; there may be no way to implement an atomic rename when dst names an existing file.&quot;<br><h4> Comment 82076110 ShadowRanger: </h4>@TomMyddeltyn: <a href="https://docs.python.org/3/library/os.html#os.replace" rel="nofollow noreferrer">As of Python 3.3, <code>os.replace</code></a> portably performs silent replacement of the destination file (it&#39;s identical to <code>os.rename</code>&#39;s Linux behavior) (it only errors if the destination name exists and is a directory). So you&#39;re stuck on 2.x, but Py3 users have had a good option for several years now.<br><h4> Comment 82076178 ShadowRanger: </h4>On the <code>rename</code> example: It should still be done with <code>try</code>/<code>except</code>. <code>os.rename</code> (or <code>os.replace</code> on modern Python) is atomic; making it check then rename introduces an unnecessary race and additional system calls. Just do <code>try: os.replace(filepath, filepath + &#39;.old&#39;) except OSError: pass</code><br>------------------------------------------------------------------ <br><h3> Answer 4799818 philberndt: </h3><p>You could try this (safer):</p>

<pre><code>try:
    # http://effbot.org/zone/python-with-statement.htm
    # 'with' is safer to open a file
    with open('whatever.txt') as fh:
        # Do something with 'fh'
except IOError as e:
    print("({})".format(e))
</code></pre>

<p>The ouput would be:</p>

<blockquote>
  <p>([Errno 2] No such file or directory:
  'whatever.txt')</p>
</blockquote>

<p>Then, depending on the result, your program can just keep running from there or you can code to stop it if you want.</p>
<h4> Comment 35567418 rrs: </h4>The original question asked for a solution that does not use <code>try</code><br><h4> Comment 58626101 Chris Johnson: </h4>This answer misses the point of the OP.  Checking is a file exists is not the same as checking if you can open it.  There will be cases where a file does exist but for a variety of reasons, you can&#39;t open it.<br>------------------------------------------------------------------ <br><h3> Answer 47629576 Wizard: </h3><p>Date: 2017-12-04</p>
<p>Every possible solution has been listed in other answers.</p>
<p>An intuitive and arguable way to check if a file exists is the following:</p>
<pre><code>import os

os.path.isfile('~/file.md')  # Returns True if exists, else False

# Additionally, check a directory
os.path.isdir('~/folder')  # Returns True if the folder exists, else False

# Check either a directory or a file
os.path.exists('~/file')
</code></pre>
<p>I made an exhaustive cheat sheet for your reference:</p>
<pre><code># os.path methods in exhaustive cheat sheet
{'definition': ['dirname',
               'basename',
               'abspath',
               'relpath',
               'commonpath',
               'normpath',
               'realpath'],
'operation': ['split', 'splitdrive', 'splitext',
               'join', 'normcase'],
'compare': ['samefile', 'sameopenfile', 'samestat'],
'condition': ['isdir',
              'isfile',
              'exists',
              'lexists'
              'islink',
              'isabs',
              'ismount',],
 'expand': ['expanduser',
            'expandvars'],
 'stat': ['getatime', 'getctime', 'getmtime',
          'getsize']}
</code></pre>
------------------------------------------------------------------ <br><h3> Answer 27661444 Zizouz212: </h3><p>Although I always recommend using <code>try</code> and <code>except</code> statements, here are a few possibilities for you (my personal favourite is using <code>os.access</code>):</p>

<ol>
<li><p>Try opening the file:</p>

<p>Opening the file will always verify the existence of the file. You can make a function just like so:</p>

<pre><code>def File_Existence(filepath):
    f = open(filepath)
    return True
</code></pre>

<p>If it's False, it will stop execution with an unhanded IOError
or OSError in later versions of Python. To catch the exception,
you have to use a try except clause. Of course, you can always
use a <code>try</code> except` statement like so (thanks to <a href="https://stackoverflow.com/users/3256073/hsandt">hsandt</a>
for making me think):</p>

<pre><code>def File_Existence(filepath):
    try:
        f = open(filepath)
    except IOError, OSError: # Note OSError is for later versions of Python
        return False

    return True
</code></pre></li>
<li><p>Use <code>os.path.exists(path)</code>:</p>

<p>This will check the existence of what you specify. However, it checks for files <em>and</em> directories so beware about how you use it.</p>

<pre><code>import os.path
&gt;&gt;&gt; os.path.exists("this/is/a/directory")
True
&gt;&gt;&gt; os.path.exists("this/is/a/file.txt")
True
&gt;&gt;&gt; os.path.exists("not/a/directory")
False
</code></pre></li>
<li><p>Use <code>os.access(path, mode)</code>:</p>

<p>This will check whether you have access to the file. It will check for permissions. Based on the os.py documentation, typing in <code>os.F_OK</code>, it will check the existence of the path. However, using this will create a security hole, as someone can attack your file using the time between checking the permissions and opening the file. You should instead go directly to opening the file instead of checking its permissions. (<a href="https://docs.python.org/2/glossary.html#term-eafp" rel="noreferrer">EAFP</a> vs <a href="https://docs.python.org/2/glossary.html#term-lbyl" rel="noreferrer">LBYP</a>). If you're not going to open the file afterwards, and only checking its existence, then you can use this.</p>

<p>Anyway, here:</p>

<pre><code>&gt;&gt;&gt; import os
&gt;&gt;&gt; os.access("/is/a/file.txt", os.F_OK)
True
</code></pre></li>
</ol>

<p>I should also mention that there are two ways that you will not be able to verify the existence of a file. Either the issue will be <code>permission denied</code> or <code>no such file or directory</code>. If you catch an <code>IOError</code>, set the <code>IOError as e</code> (like my first option), and then type in <code>print(e.args)</code> so that you can hopefully determine your issue. I hope it helps! :)</p>
------------------------------------------------------------------ <br><h3> Answer 26335110 bergercookie: </h3><p>If the file is for opening you could use one of the following techniques:</p>
<pre><code>with open('somefile', 'xt') as f: # Using the x-flag, Python 3.3 and above
    f.write('Hello\n')

if not os.path.exists('somefile'): 
    with open('somefile', 'wt') as f:
        f.write(&quot;Hello\n&quot;)
else:
    print('File already exists!')
</code></pre>
<hr />
<p>Note: This finds either a file <strong>or</strong> a directory with the given name.</p>
<h4> Comment 51457614 Chris Johnson: </h4>This answer is wrong. <code>os.path.exists</code> returns true for things that aren&#39;t files, such as directories. This gives false positives. See the other answers that recommend <code>os.path.isfile</code>.<br><h4> Comment 87874004 Zorglub29: </h4>got the false positive problem also.<br><h4> Comment 91198420 JayRizzo: </h4><a href="https://docs.python.org/3/library/os.path.html#os.path.exists" rel="nofollow noreferrer">docs.python.org/3/library/os.path.html#os.path.exists</a>  <b>To the above statement from chris</b> &gt;&gt;os.path.exists(path) &gt; Return True if path refers to an existing path or an open file descriptor. Returns False for broken symbolic links. On some platforms, this function may return False if permission is not granted to execute os.stat() on the requested file, even if the path physically exists.  Changed in version 3.3: path can now be an integer: True is returned if it is an open file descriptor, False otherwise.  Changed in version 3.6: Accepts a path-like object.<br>------------------------------------------------------------------ <br><h3> Answer 83012 zgoda: </h3><p>Additionally, <code>os.access()</code>:</p>

<pre><code>if os.access("myfile", os.R_OK):
    with open("myfile") as fp:
        return fp.read()
</code></pre>

<p>Being <code>R_OK</code>, <code>W_OK</code>, and <code>X_OK</code> the flags to test for permissions (<a href="https://docs.python.org/3/library/os.html#os.access" rel="noreferrer">doc</a>).</p>
------------------------------------------------------------------ <br><h3> Answer 29909391 Pedro Lobito: </h3><pre><code>if os.path.isfile(path_to_file):
    try:
        open(path_to_file)
            pass
    except IOError as e:
        print &quot;Unable to open file&quot;
</code></pre>
<blockquote>
<p>Raising exceptions is considered to be an acceptable, and Pythonic,
approach for flow control in your program. Consider handling missing
files with IOErrors. In this situation, an IOError exception will be
raised if the file exists but the user does not have read permissions.</p>
</blockquote>
<p>Source: <em><a href="http://www.pfinn.net/python-check-if-file-exists.html" rel="nofollow noreferrer">Using Python: How To Check If A File Exists</a></em></p>
<h4> Comment 58626329 Chris Johnson: </h4>The OP asked how to check if a file exists.  It&#39;s possible for a file to exist but for you to not be able to open it.  Therefore using opening a file as a proxy for checking if the file exists is not correct: will have false negatives.<br>------------------------------------------------------------------ <br><h3> Answer 21688350 Chris: </h3><p>You can write Brian's suggestion without the <code>try:</code>.</p>

<pre><code>from contextlib import suppress

with suppress(IOError), open('filename'):
    process()
</code></pre>

<p><code>suppress</code> is part of Python 3.4. In older releases you can quickly write your own suppress:</p>

<pre><code>from contextlib import contextmanager

@contextmanager
def suppress(*exceptions):
    try:
        yield
    except exceptions:
        pass
</code></pre>
------------------------------------------------------------------ <br><h3> Answer 49092615 Ali Hallaji: </h3><h2>Check file or directory exists</h2>
<p>You can follow these three ways:</p>
<h3>1. Using isfile()</h3>
<p>Note 1: The <code>os.path.isfile</code> used only for files</p>
<pre><code>import os.path
os.path.isfile(filename) # True if file exists
os.path.isfile(dirname) # False if directory exists
</code></pre>
<h3>2. Using <em>exists</em></h3>
<p>Note 2: The <code>os.path.exists</code> is used for both files and directories</p>
<pre><code>import os.path
os.path.exists(filename) # True if file exists
os.path.exists(dirname) # True if directory exists
</code></pre>
<h3>3. The <code>pathlib.Path</code> method (included in Python 3+, installable with pip for Python 2)</h3>
<pre><code>from pathlib import Path
Path(filename).exists()
</code></pre>
------------------------------------------------------------------ <br><h3> Answer 45605450 durjoy: </h3><p>If you imported NumPy already for other purposes then there is no need to import other libraries like <code>pathlib</code>, <code>os</code>, <code>paths</code>, etc.</p>

<pre><code>import numpy as np
np.DataSource().exists("path/to/your/file")
</code></pre>

<p>This will return true or false based on its existence.</p>
------------------------------------------------------------------ <br><h3> Answer 32288118 Love and peace - Joe Codeswell: </h3><p>Here's a one-line Python command for the Linux command line environment. I find this <em>very handy</em> since I'm not such a hot Bash guy.</p>
<pre><code>python -c &quot;import os.path; print os.path.isfile('/path_to/file.xxx')&quot;
</code></pre>
<h4> Comment 53594747 flotzilla: </h4>One-line check in bash: <code>[ -f &quot;${file}&quot; ] &amp;&amp; echo &quot;file found&quot; || echo &quot;file not found&quot;</code> (which is the same as <code>if [ ... ]; then ...; else ...; fi</code>).<br><h4> Comment 123212165 ruohola: </h4>Python would be a completely wrong tool for this job on the command line.<br><h4> Comment 130577707 Peter Mortensen: </h4><a href="https://stackoverflow.com/questions/6167127/how-to-put-multiple-statements-in-one-line/6167353#6167353">On one-liners</a> in Python: <i>&quot;...which makes Python close to useless for command-line one-liner programs ... You can get away with a sequence of simple statements, separated by semi-colon ... as soon as you add a construct that introduces an indented block (like if), you need the line break...&quot;</i><br><h4> Comment 123251163 Love and peace - Joe Codeswell: </h4>Hi @ruohola  :)  I disagree.<br>------------------------------------------------------------------ <br><h3> Answer 37050053 Mike McKerns: </h3><p>I'm the author of a package that's been around for about 10 years, and it has a function that addresses this question directly. Basically, if you are on a non-Windows system, it uses <code>Popen</code> to access <code>find</code>.  However, if you are on Windows, it replicates <code>find</code> with an efficient filesystem walker.</p>

<p>The code itself does not use a <code>try</code> block… except in determining the operating system and thus steering you to the "Unix"-style <code>find</code> or the hand-buillt <code>find</code>. Timing tests showed that the <code>try</code> was faster in determining the OS, so I did use one there (but nowhere else).</p>

<pre><code>&gt;&gt;&gt; import pox
&gt;&gt;&gt; pox.find('*python*', type='file', root=pox.homedir(), recurse=False)
['/Users/mmckerns/.python']
</code></pre>

<p>And the doc…</p>

<pre><code>&gt;&gt;&gt; print pox.find.__doc__
find(patterns[,root,recurse,type]); Get path to a file or directory

    patterns: name or partial name string of items to search for
    root: path string of top-level directory to search
    recurse: if True, recurse down from root directory
    type: item filter; one of {None, file, dir, link, socket, block, char}
    verbose: if True, be a little verbose about the search

    On some OS, recursion can be specified by recursion depth (an integer).
    patterns can be specified with basic pattern matching. Additionally,
    multiple patterns can be specified by splitting patterns with a ';'
    For example:
        &gt;&gt;&gt; find('pox*', root='..')
        ['/Users/foo/pox/pox', '/Users/foo/pox/scripts/pox_launcher.py']

        &gt;&gt;&gt; find('*shutils*;*init*')
        ['/Users/foo/pox/pox/shutils.py', '/Users/foo/pox/pox/__init__.py']

&gt;&gt;&gt;
</code></pre>

<p>The implementation, if you care to look, is here:
<a href="https://github.com/uqfoundation/pox/blob/89f90fb308f285ca7a62eabe2c38acb87e89dad9/pox/shutils.py#L190" rel="noreferrer">https://github.com/uqfoundation/pox/blob/89f90fb308f285ca7a62eabe2c38acb87e89dad9/pox/shutils.py#L190</a></p>
------------------------------------------------------------------ <br><h3> Answer 38793323 Marcel Wilson: </h3><p>Adding one more slight variation which isn't exactly reflected in the other answers.</p>

<p>This will handle the case of the <code>file_path</code> being <code>None</code> or empty string.</p>

<p></p>

<pre><code>def file_exists(file_path):
    if not file_path:
        return False
    elif not os.path.isfile(file_path):
        return False
    else:
        return True
</code></pre>

<p>Adding a variant based on suggestion from Shahbaz
</p>

<pre><code>def file_exists(file_path):
    if not file_path:
        return False
    else:
        return os.path.isfile(file_path)
</code></pre>

<p>Adding a variant based on suggestion from Peter Wood
</p>

<pre><code>def file_exists(file_path):
    return file_path and os.path.isfile(file_path):
</code></pre>
<h4> Comment 73574012 Peter Wood: </h4><code>return file_path and os.path.isfile(file_path)</code><br><h4> Comment 70155028 Shahbaz: </h4><code>if (x) return true; else return false;</code> is really just <code>return x</code>. Your last four lines can become <code>return os.path.isfile(file_path)</code>. While we&#39;re at it, the whole function can be simplified as <code>return file_path and os.path.isfile(file_path)</code>.<br><h4> Comment 70187191 Shahbaz: </h4>True. In this case however, <code>x</code> is <code>os.path.isfile(..)</code> so it&#39;s already bool.<br><h4> Comment 70187302 Marcel Wilson: </h4><code>os.path.isfile(None)</code> raises an exception which is why I added the if check.  I could probably just wrap it in a try/except instead but I felt it was more explicit this way.<br><h4> Comment 70187119 Marcel Wilson: </h4>You have to be careful with <code>return x</code> in the case of <code>if (x)</code>.  Python will consider an empty string False in which case we would be returning an empty string instead of a bool.  The purpose of this function is to always return bool.<br>------------------------------------------------------------------ <br><h3> Answer 31824912 Khaled.K: </h3><pre><code>import os.path

def isReadableFile(file_path, file_name):
    full_path = file_path + "/" + file_name
    try:
        if not os.path.exists(file_path):
            print "File path is invalid."
            return False
        elif not os.path.isfile(full_path):
            print "File does not exist."
            return False
        elif not os.access(full_path, os.R_OK):
            print "File cannot be read."
            return False
        else:
            print "File can be read."
            return True
    except IOError as ex:
        print "I/O error({0}): {1}".format(ex.errno, ex.strerror)
    except Error as ex:
        print "Error({0}): {1}".format(ex.errno, ex.strerror)
    return False
#------------------------------------------------------

path = "/usr/khaled/documents/puzzles"
fileName = "puzzle_1.txt"

isReadableFile(path, fileName)
</code></pre>
<h4> Comment 51718773 Khaled.K: </h4>@j6m8 yes, <code>isReadableFile(path,fileName)</code> will return <code>True</code> if the file is reachable and readable by the process\program\thread<br>------------------------------------------------------------------ <br><h3> Answer 40926284 Taufiq Rahman: </h3><blockquote>
  <p><strong>How do I check whether a file exists, without using the try statement?</strong></p>
</blockquote>

<p>In 2016, this is still arguably the easiest way to check if both a file exists and if it is a file:</p>

<pre><code>import os
os.path.isfile('./file.txt')    # Returns True if exists, else False
</code></pre>

<p><code>isfile</code> is actually just a helper method that internally uses <code>os.stat</code> and <code>stat.S_ISREG(mode)</code> underneath. This <code>os.stat</code> is a lower-level method that will provide you with detailed information about files, directories, sockets, buffers, and more. <a href="https://docs.python.org/2/library/os.html#os.stat" rel="noreferrer">More about os.stat here</a></p>

<p><strong>Note:</strong> However, this approach will not lock the file in any way and therefore your code can become vulnerable to "<strong>time of check to time of use</strong>" (<em>TOCTTOU</em>) bugs.</p>

<p>So raising exceptions is considered to be an acceptable, and Pythonic, approach for flow control in your program. And one should consider handling missing files with IOErrors, rather than <code>if</code> statements (<em>just an advice</em>).</p>
------------------------------------------------------------------ <br><h3> Answer 27581592 Pradip Das: </h3><p>You can use the "OS" library of Python:</p>

<pre><code>&gt;&gt;&gt; import os
&gt;&gt;&gt; os.path.exists("C:\\Users\\####\\Desktop\\test.txt") 
True
&gt;&gt;&gt; os.path.exists("C:\\Users\\####\\Desktop\\test.tx")
False
</code></pre>
<h4> Comment 51457619 Chris Johnson: </h4>This answer is wrong. <code>os.path.exists</code> returns true for things that aren&#39;t files, such as directories. This gives false positives. See the other answers that recommend <code>os.path.isfile</code>.<br><h4> Comment 51476676 Pradip Das: </h4>@Chris Johnson , os.path.exists() function checks whether a path exists in system. PATH may be a DIRECTORY or FILE. It will work fine on both the cases. Please try with some example<br><h4> Comment 60866588 Debosmit Ray: </h4>So, this answer works. Great. <b>Iff</b> the path isn&#39;t that of a file. Is that what the question was about? No.<br><h4> Comment 79066785 starturtle: </h4>It depends. If the goal of determining the existence of a &quot;file&quot; is to find out whether the path already exists (and is therefore not a path where new data can be stored without deleting other information), then <code>exists</code> is fine. If the goal is to determine whether it&#39;s safe to open a presumably existing file, then the criticism is justified and exists is not precise enough. Sadly, the OP doesn&#39;t specify which is the desired goal (and probably won&#39;t do so any more).<br>------------------------------------------------------------------ <br><h3> Answer 59923701 Gopinath: </h3><p><strong>exists()</strong> and <strong>is_file()</strong> methods of '<strong>Path</strong>' object can be used for checking if a given path exists and is a file.</p>

<p><strong>Python 3 program to check if a file exists:</strong></p>

<pre><code># File name:  check-if-file-exists.py

from pathlib import Path

filePath = Path(input("Enter path of the file to be found: "))

if filePath.exists() and filePath.is_file():
    print("Success: File exists")
else:
    print("Error: File does not exist")
</code></pre>

<p><strong>Output:</strong></p>

<blockquote>
  <p><strong>$ python3 check-if-file-exists.py</strong>  </p>
  
  <p>Enter path of the file to be found: <strong><em>/Users/macuser1/stack-overflow/index.html</em></strong> </p>
  
  <p>Success: <strong><em>File exists</em></strong></p>
  
  <p><strong>$ python3 check-if-file-exists.py</strong>  </p>
  
  <p>Enter path of the file to be found: <strong><em>hghjg jghj</em></strong></p>
  
  <p>Error: <strong><em>File does not exist</em></strong></p>
</blockquote>
------------------------------------------------------------------ <br><h3> Answer 61754517 Devbrat Shukla: </h3><p>Use <a href="https://www.geeksforgeeks.org/python-os-path-exists-method/" rel="noreferrer">os.path.exists()</a> to check whether file exists or not:</p>
<pre><code>def fileAtLocation(filename,path):
    return os.path.exists(path + filename)
 

filename=&quot;dummy.txt&quot;
path = &quot;/home/ie/SachinSaga/scripts/subscription_unit_reader_file/&quot;


if fileAtLocation(filename,path):
   print('file found at location..')
else:
   print('file not found at location..')
</code></pre>
<h4> Comment 113369560 Yash Nag: </h4>Any clarification on why this answer is downvoted? Is os.path.exists() not a solution?<br><h4> Comment 113421412 pho: </h4>@YashNag <a href="https://stackoverflow.com/a/84173/843953">from another answer</a>: Unlike <code>isfile()</code>, <code>exists()</code> will return True for directories.<br><h4> Comment 122286474 tdelaney: </h4>@GlennMaynard - No, you check for file existence because you want to do something with the file (maybe read it, maybe create one). Having a like-named directory is a problem. You usually want to test both to avoid bugs.<br><h4> Comment 116945628 Glenn Maynard: </h4>This is usually what you want, not isfile, since the question &quot;does a file exist&quot; is usually really asking whether a path exists, not whether it&#39;s a file.  Please stop downvoting useful information.<br><h4> Comment 117717952 Ceisc: </h4>Why are you replacing spaces in the filename? You could now be checking whether a different file exists than the one being asked about. Why are you calling str() on it? If it&#39;s not already a string defining the file there&#39;s probably something very wrong with how the function is being called.<br><h4> Comment 128482504 Devbrat Shukla: </h4>Thank you @GlennMaynard for explaining :)<br>------------------------------------------------------------------ <br><h3> Answer 7201731 Jesvin Jose: </h3><pre><code>import os
path = /path/to/dir

root,dirs,files = os.walk(path).next()
if myfile in files:
   print "yes it exists"
</code></pre>

<p>This is helpful when checking for several files. Or you want to do a set intersection/ subtraction with an existing list.</p>
<h4> Comment 76056413 Chris Johnson: </h4>This is wrong on two counts: (1) <code>os.walk</code> find all files under a directory tree -- if the user wants to check for <code>.&#47;FILE</code>, it&#39;s unlikely he&#39;d want to treat <code>.&#47;some&#47;sub&#47;folder&#47;FILE</code> as a match, which your solution does; and (2) your solution is very inefficient compared to a simple <code>os.path.isfile()</code> call in the case where there are many files below the current directory.  In the case where no matching filename-without-path exists within the tree, your code will enumerate every single file in the tree before returning false.<br>------------------------------------------------------------------ <br><h3> Answer 26433646 Hanson: </h3><p>To check if a file exists, </p>

<pre><code>from sys import argv

from os.path import exists
script, filename = argv
target = open(filename)
print "file exists: %r" % exists(filename)
</code></pre>
<h4> Comment 52212681 Pavel Chernikov: </h4>Exists doesn&#39;t differentiate between a file and a directory. os.path.isfile is a better way of checking whether file exists.<br>------------------------------------------------------------------ <br><h3> Answer 23826292 Zaheer: </h3><p>You can use the following open method to check if a file exists + readable:</p>

<pre><code>file = open(inputFile, 'r')
file.close()
</code></pre>
<h4> Comment 106682929 Sam Dolan: </h4>This definitely throws an exception if the file isn&#39;t there....<br><h4> Comment 130577229 Peter Mortensen: </h4>The question was <i>&quot;How do I check whether a file exists without exceptions?&quot;</i>.<br>------------------------------------------------------------------ <br><h3> Answer 37702905 iPhynx: </h3><p>You can use os.listdir to check if a file is in a certain directory.</p>

<pre><code>import os
if 'file.ext' in os.listdir('dirpath'):
    #code
</code></pre>
<h4> Comment 70248533 Jean-Fran&#231;ois Fabre: </h4>won&#39;t work in windows since filesystem isn&#39;t case sensitive. And very uneffective because it scans the whole directory.<br>------------------------------------------------------------------ <br><h3> Answer 53084404 Vimal Maheedharan: </h3><p>Use:</p>
<pre><code>import os

# For testing purposes the arguments defaulted to the current folder and file.
# returns True if file found
def file_exists(FOLDER_PATH='../', FILE_NAME=__file__):
    return os.path.isdir(FOLDER_PATH) \
        and os.path.isfile(os.path.join(FOLDER_PATH, FILE_NAME))
</code></pre>
<p>It is basically a folder check, and then a file check with the proper directory separator using <em><a href="https://docs.python.org/3.8/library/os.path.html#os.path.join" rel="nofollow noreferrer">os.path.join</a></em>.</p>
------------------------------------------------------------------ <br><h3> Answer 66993660 IsraelW: </h3><p>Another possible option is to check whether the filename is in the directory using os.listdir():</p>
<pre class="lang-py prettyprint-override"><code>import os
if 'foo.txt' in os.listdir():
    # Do things
</code></pre>
<p>This will return true if it is and false if not.</p>
<h4> Comment 129191832 Niccolo M.: </h4>This could fail if the OS is case-insensitive, as in MS-Windows, because the actual file name could be &#39;Foo.TXT&#39;. Using pathlib solves this problem (because it compares Path objects using the OS conventions) : <code>if Path(&#39;foo.txt&#39;) in Path().iterdir()</code>.<br>------------------------------------------------------------------ <br><h3> Answer 73083229 Ban_Midou: </h3><p>This is how I found a list of files (in these images) in one folder and searched it in a folder (with subfolders):</p>
<pre><code># This script concatenates JavaScript files into a unified JavaScript file to reduce server round-trips

import os
import string
import math
import ntpath
import sys

#import pyodbc

import gzip
import shutil

import hashlib

# BUF_SIZE is totally arbitrary, change for your app!
BUF_SIZE = 65536  # Let’s read stuff in 64 kilobyte chunks

# Iterate over all JavaScript files in the folder and combine them
filenames = []
shortfilenames = []

imgfilenames = []
imgshortfilenames = []

# Get a unified path so we can stop dancing with user paths.
# Determine where files are on this machine (%TEMP% directory and application installation directory)
if '.exe' in sys.argv[0]: # if getattr(sys, 'frozen', False):
    RootPath = os.path.abspath(os.path.join(__file__, &quot;..\\&quot;))

elif __file__:
    RootPath = os.path.abspath(os.path.join(__file__, &quot;..\\&quot;))

print (&quot;\n storage of image files RootPath: %s\n&quot; %RootPath)

FolderPath = &quot;D:\\TFS-FARM1\\StoneSoup_STS\\SDLC\\Build\\Code\\StoneSoup_Refactor\\StoneSoupUI\\Images&quot;
print (&quot;\n storage of image files in folder to search: %s\n&quot; %FolderPath)

for root, directories, filenames2 in os.walk(FolderPath):
    for filename in filenames2:
        fullname = os.path.join(root, filename)
        filenames.append(fullname)
        shortfilenames.append(filename)

for i, fname in enumerate(shortfilenames):
        print(&quot;%s - %s&quot; % (i+1, fname))

for root, directories, filenames2 in os.walk(RootPath):
    for filename in filenames2:
        fullname = os.path.join(root, filename)
        imgfilenames.append(fullname)
        imgshortfilenames.append(filename)

for i, fname in enumerate(imgshortfilenames):
        print(&quot;%s - %s&quot; % (i+1, fname))

for i, fname in enumerate(imgshortfilenames):
        if fname in shortfilenames:
            print(&quot;%s - %s exists&quot; % (i+1, fname))
        else:
            print(&quot;%s - %s ABSENT&quot; % (i+1, fname))
</code></pre>
