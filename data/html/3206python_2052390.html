 <h2> Title: Manually raising (throwing) an exception in Python </h2> <h4> TIMEX, question_id: 2052390 </h4>Score: 3206, Tags: {python,exception} <br><p>How do I raise an exception in Python so that it can later be caught via an <code>except</code> block?</p>
------------------------------------------------------------------ <br><h3> Russia Must Remove Putin, Id: 24065533, Score: 4185: </h3><blockquote>
<h2>How do I manually throw/raise an exception in Python?</h2>
</blockquote>
<p><a href="https://docs.python.org/3/library/exceptions.html#exception-hierarchy" rel="noreferrer">Use the most specific Exception constructor that semantically fits your issue</a>.</p>
<p>Be specific in your message, e.g.:</p>
<pre><code>raise ValueError('A very specific bad thing happened.')
</code></pre>
<h2>Don't raise generic exceptions</h2>
<p>Avoid raising a generic <code>Exception</code>. To catch it, you'll have to catch all other more specific exceptions that subclass it.</p>
<h3>Problem 1: Hiding bugs</h3>
<pre><code>raise Exception('I know Python!') # Don't! If you catch, likely to hide bugs.
</code></pre>
<p>For example:</p>
<pre><code>def demo_bad_catch():
    try:
        raise ValueError('Represents a hidden bug, do not catch this')
        raise Exception('This is the exception you expect to handle')
    except Exception as error:
        print('Caught this error: ' + repr(error))

&gt;&gt;&gt; demo_bad_catch()
Caught this error: ValueError('Represents a hidden bug, do not catch this',)
</code></pre>
<h3>Problem 2: Won't catch</h3>
<p>And more specific catches won't catch the general exception:</p>
<pre><code>def demo_no_catch():
    try:
        raise Exception('general exceptions not caught by specific handling')
    except ValueError as e:
        print('we will not catch exception: Exception')
 

&gt;&gt;&gt; demo_no_catch()
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
  File &quot;&lt;stdin&gt;&quot;, line 3, in demo_no_catch
Exception: general exceptions not caught by specific handling
</code></pre>
<h2>Best Practices: <code>raise</code> statement</h2>
<p><a href="https://docs.python.org/3/library/exceptions.html#exception-hierarchy" rel="noreferrer">Instead, use the most specific Exception constructor that semantically fits your issue</a>.</p>
<pre><code>raise ValueError('A very specific bad thing happened')
</code></pre>
<p>which also handily allows an arbitrary number of arguments to be passed to the constructor:</p>
<pre><code>raise ValueError('A very specific bad thing happened', 'foo', 'bar', 'baz') 
</code></pre>
<p>These arguments are accessed by the <code>args</code> attribute on the <code>Exception</code> object. For example:</p>
<pre><code>try:
    some_code_that_may_raise_our_value_error()
except ValueError as err:
    print(err.args)
</code></pre>
<p>prints</p>
<pre><code>('message', 'foo', 'bar', 'baz')    
</code></pre>
<p>In Python 2.5, an actual <code>message</code> attribute was added to <code>BaseException</code> in favor of encouraging users to subclass Exceptions and stop using <code>args</code>, but <a href="http://www.python.org/dev/peps/pep-0352/#retracted-ideas" rel="noreferrer">the introduction of <code>message</code> and the original deprecation of args has been retracted</a>.</p>
<h2>Best Practices: <code>except</code> clause</h2>
<p>When inside an except clause, you might want to, for example, log that a specific type of error happened, and then re-raise. The best way to do this while preserving the stack trace is to use a bare raise statement. For example:</p>
<pre><code>logger = logging.getLogger(__name__)

try:
    do_something_in_app_that_breaks_easily()
except AppError as error:
    logger.error(error)
    raise                 # just this!
    # raise AppError      # Don't do this, you'll lose the stack trace!
</code></pre>
<h3>Don't modify your errors... but if you insist.</h3>
<p>You can preserve the stacktrace (and error value) with <code>sys.exc_info()</code>, but <strong>this is way more error prone</strong> and <strong>has compatibility problems between Python 2 and 3</strong>, prefer to use a bare <code>raise</code> to re-raise.</p>
<p>To explain - the <code>sys.exc_info()</code> returns the type, value, and traceback.</p>
<pre><code>type, value, traceback = sys.exc_info()
</code></pre>
<p>This is the syntax in Python 2 - note this is not compatible with Python 3:</p>
<pre><code>raise AppError, error, sys.exc_info()[2] # avoid this.
# Equivalently, as error *is* the second object:
raise sys.exc_info()[0], sys.exc_info()[1], sys.exc_info()[2]
</code></pre>
<p>If you want to, you can modify what happens with your new raise - e.g. setting new <code>args</code> for the instance:</p>
<pre><code>def error():
    raise ValueError('oops!')

def catch_error_modify_message():
    try:
        error()
    except ValueError:
        error_type, error_instance, traceback = sys.exc_info()
        error_instance.args = (error_instance.args[0] + ' &lt;modification&gt;',)
        raise error_type, error_instance, traceback
</code></pre>
<p>And we have preserved the whole traceback while modifying the args. Note that this is <strong>not a best practice</strong> and it is <strong>invalid syntax</strong> in Python 3 (making keeping compatibility much harder to work around).</p>
<pre><code>&gt;&gt;&gt; catch_error_modify_message()
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
  File &quot;&lt;stdin&gt;&quot;, line 3, in catch_error_modify_message
  File &quot;&lt;stdin&gt;&quot;, line 2, in error
ValueError: oops! &lt;modification&gt;
</code></pre>
<p>In <a href="https://docs.python.org/3/reference/simple_stmts.html#the-raise-statement" rel="noreferrer">Python 3</a>:</p>
<pre><code>raise error.with_traceback(sys.exc_info()[2])
</code></pre>
<p>Again: avoid manually manipulating tracebacks. It's <a href="https://docs.python.org/2/reference/simple_stmts.html#the-raise-statement" rel="noreferrer">less efficient</a> and more error prone. And if you're using threading and <code>sys.exc_info</code> you may even get the wrong traceback (especially if you're using exception handling for control flow - which I'd personally tend to avoid.)</p>
<h3>Python 3, Exception chaining</h3>
<p>In Python 3, you can chain Exceptions, which preserve tracebacks:</p>
<pre><code>raise RuntimeError('specific message') from error
</code></pre>
<p>Be aware:</p>
<ul>
<li>this <em>does</em> allow changing the error type raised, and</li>
<li>this is <em>not</em> compatible with Python 2.</li>
</ul>
<h3>Deprecated Methods:</h3>
<p>These can easily hide and even get into production code. You want to raise an exception, and doing them will raise an exception, <strong>but not the one intended!</strong></p>
<p><a href="http://www.python.org/dev/peps/pep-3109/" rel="noreferrer">Valid in Python 2, but not in Python 3</a> is the following:</p>
<pre><code>raise ValueError, 'message' # Don't do this, it's deprecated!
</code></pre>
<p>Only <a href="https://docs.python.org/2/whatsnew/2.5.html#pep-352-exceptions-as-new-style-classes" rel="noreferrer">valid in much older versions of Python</a> (2.4 and lower), you may still see people raising strings:</p>
<pre><code>raise 'message' # really really wrong. don't do this.
</code></pre>
<p>In all modern versions, this will actually raise a <code>TypeError</code>, because you're not raising a <code>BaseException</code> type. If you're not checking for the right exception and don't have a reviewer that's aware of the issue, it could get into production.</p>
<h2>Example Usage</h2>
<p>I raise Exceptions to warn consumers of my API if they're using it incorrectly:</p>
<pre><code>def api_func(foo):
    '''foo should be either 'baz' or 'bar'. returns something very useful.'''
    if foo not in _ALLOWED_ARGS:
        raise ValueError('{foo} wrong, use &quot;baz&quot; or &quot;bar&quot;'.format(foo=repr(foo)))
</code></pre>
<h2>Create your own error types when apropos</h2>
<blockquote>
<p><strong>&quot;I want to make an error on purpose, so that it would go into the except&quot;</strong></p>
</blockquote>
<p>You can create your own error types, if you want to indicate something specific is wrong with your application, just subclass the appropriate point in the exception hierarchy:</p>
<pre><code>class MyAppLookupError(LookupError):
    '''raise this when there's a lookup error for my app'''
</code></pre>
<p>and usage:</p>
<pre><code>if important_key not in resource_dict and not ok_to_be_missing:
    raise MyAppLookupError('resource is missing, and that is not ok.')
</code></pre>
<h4> Russia Must Remove Putin, Comment 116231941 Score: 1: </h4>@SharathBJ you&#39;re raising a <code>ValueError</code> and reporting it as the type, <code>Exception</code>, and that&#39;s an unnecessary loss of precision. <code>repr(e)</code> will at least report the type for you.<br><h4> Russia Must Remove Putin, Comment 116815348 Score: 1: </h4>@GabrielStaples here&#39;s the docs on instantiation args: <a href="https://docs.python.org/3/library/exceptions.html#BaseException.args" rel="nofollow noreferrer">docs.python.org/3/library/exceptions.html#BaseException.args</a><br><h4> prayagupa, Comment 133249224 Score: 0: </h4>you can also chain the previous error with <code>raise Exception(&quot;Error happened&quot;, exp)</code><br><h4> Gabriel Staples, Comment 116816759 Score: 0: </h4>@AaronHall, ah, I see. I didn&#39;t realize the exception type, such as <code>TypeError</code>, was a call to a class constructor! Makes sense now. The message is therefore a common constructor arg for error-type classes.<br><h4> kevinarpe, Comment 122985807 Score: 0: </h4>@AaronHall This is a great answer!  Can you please add some notes for Py2 &amp; 3 about re-raise the same exception?  What is the difference between <code>raise</code> and <code>raise ex</code>?  I <i>think</i>: <code>raise</code> will preserve the original stack trace, but <code>raise ex</code> will reset/rewrite the stack trace.  I don&#39;t know if there is diff behaviour between Py2 &amp; 3.<br><h4> Sharath BJ, Comment 116224511 Score: 0: </h4>try:         raise ValueError(&#39;error&#39;)     except ValueError as e:         print(&#39;we will catch exception: Exception&#39;,str(e))             #is the best solution<br><h4> rleir, Comment 126677579 Score: 0: </h4>@RussiaMustRemovePutin Yes, and in 2022 this is more true than ever.<br><h4> Gabriel Staples, Comment 116812755 Score: 0: </h4>Where&#39;s the official documentation that shows you can pass in a message when raising an exception? ex: <code>raise TypeError(&quot;my message&quot;)</code><br>------------------------------------------------------------------ <br><h3> Gabriel Hurley, Id: 2052396, Score: 578: </h3><blockquote>
<p><em><strong>Don't do this</strong></em>. Raising a bare <code>Exception</code> is absolutely <strong>not</strong> the right thing to do; see <a href="https://stackoverflow.com/a/24065533">Aaron Hall's excellent answer</a> instead.</p>
</blockquote>
<p>It can't get much more Pythonic than this:</p>
<pre><code>raise Exception(&quot;I know Python!&quot;)
</code></pre>
<p>Replace <code>Exception</code> with the specific type of exception you want to throw.</p>
<p>See <a href="http://docs.python.org/reference/simple_stmts.html#the-raise-statement" rel="noreferrer">the raise statement documentation</a> for Python if you'd like more information.</p>
<h4> Dawood ibn Kareem, Comment 44534806 Score: 115: </h4>No please!  This removes the potential to be specific about what you catch.  It is ENTIRELY the wrong way to do it.  Take a look at Aaron Hall&#39;s excellent answer instead of this one.  It&#39;s times like this I wish I could give more than one downvote per answer.<br><h4> Dawood ibn Kareem, Comment 45390735 Score: 50: </h4>@PeterR It&#39;s equally terrible that it has so few downvotes.  To ANYBODY reading this answer, DO NOT DO THIS EVER!  The correct answer is Aaron Hall&#39;s one.<br><h4> Dinei, Comment 72021729 Score: 18: </h4>@CharlieParker There is. It&#39;s the first part of <a href="http://stackoverflow.com/a/24065533">Aaron Hall&#39;s answer</a>.<br><h4> Daniel F., Comment 86636939 Score: 13: </h4>@codeforester maybe it&#39;s because it&#39;s answering the question.<br><h4> ctpenrose, Comment 92714420 Score: 13: </h4>This answer is still here because many experienced developers disagree with use of specialized exception classes.   I wish I could downvote comments.<br><h4> Charlie Parker, Comment 67641550 Score: 10: </h4>I think there should be a more detailed explanation on why this is wrong or so bad.<br><h4> codeforester, Comment 80658365 Score: 9: </h4>Why can&#39;t this answer be flagged for deletion?  It has got 93 downvotes already!<br><h4> pooya13, Comment 117631034 Score: 7: </h4>This is Python. A lot of times you are writing a 20 line script for some quick work that can only go wrong one way and raising a generic exception with an informative message is the best tool for the job.<br><h4> Andrew, Comment 124670709 Score: 4: </h4>Why the fury against using a bare exception? It is useful to have custom exception classes, but it isn&#39;t that big of a deal for basic/small projects or scripts. It&#39;s not like a code vulnerability...<br><h4> Duloren, Comment 125926733 Score: 4: </h4>The answer answers the question. Period. People are confused about &quot;how to use the language&quot; and &quot;best practices&quot;.<br><h4> F.D.Castel, Comment 137081065 Score: 0: </h4>Wow... &quot;ENTIRELY the wrong way&quot;... &quot;DO NOT DO THIS EVER!&quot;... Kids these days.<br><h4> Nick Koprowicz, Comment 126231925 Score: 0: </h4>As someone just experimenting in Jupyter, this is good enough. In this setting, it wouldn&#39;t be worth the time to google all the possible exceptions and see which category the one I&#39;m trying to catch falls into.<br><h4> jsta, Comment 125177403 Score: 0: </h4>There&#39;s a list of more specific exception types at: <a href="https://docs.python.org/3/library/exceptions.html#exception-hierarchy" rel="nofollow noreferrer">docs.python.org/3/library/exceptions.html#exception-hierarch&zwnj;&#8203;y</a><br><h4> alper, Comment 119496760 Score: 0: </h4>When I only do <code>raise Exception(&quot;I know python!&quot;)</code> I cannot print its trace<br><h4> Lucas Basquerotto, Comment 121607409 Score: 0: </h4>I agree with @ctpenrose here. In most cases, when you catch an exception is already too late to recover it in a proper way (unless you catch it very close from where it actually happened). In most cases what you <b>really</b> want is a detailed description of the error. A generic exception is fine here (or some especialized exception for these cases in which you just want to show a message, with the stacktrace). Rarely I catch an exception to just log and do nothing else like in the case Aaron posted as a bad practice of Exception (and in these cases, I probably want to catch all exceptions).<br>------------------------------------------------------------------ <br><h3> N Randhawa, Id: 40493467, Score: 101: </h3><p>In Python 3 there are four different syntaxes for raising exceptions:</p>
<ol>
<li>raise exception</li>
<li>raise exception (args)</li>
<li>raise</li>
<li>raise exception (args) from original_exception</li>
</ol>
<h3>1. Raise exception vs. 2. raise exception (args)</h3>
<p>If you use <code>raise exception (args)</code> to raise an exception then the <code>args</code> will be printed when you print the exception object - as shown in the example below.</p>
<pre><code># Raise exception (args)
try:
    raise ValueError(&quot;I have raised an Exception&quot;)
except ValueError as exp:
    print(&quot;Error&quot;, exp)     # Output -&gt; Error I have raised an Exception


# Raise exception
try:
    raise ValueError
except ValueError as exp:
    print(&quot;Error&quot;, exp)     # Output -&gt; Error
</code></pre>
<h3>3. Statement <em>raise</em></h3>
<p>The <code>raise</code> statement without any arguments re-raises the last exception.</p>
<p>This is useful if you need to perform some actions after catching the exception and then want to re-raise it. But if there wasn't any exception before, the <code>raise</code> statement raises  a <code>TypeError</code> Exception.</p>
<pre><code>def somefunction():
    print(&quot;some cleaning&quot;)

a = 10
b = 0
result = None

try:
    result = a / b
    print(result)

except Exception:            # Output -&gt;
    somefunction()           # Some cleaning
    raise                    # Traceback (most recent call last):
                             # File &quot;python&quot;, line 9, in &lt;module&gt;
                             # ZeroDivisionError: division by zero
</code></pre>
<h3>4. Raise exception (args) from original_exception</h3>
<p>This statement is used to create exception chaining in which an exception that is raised in response to another exception can contain the details of the original exception - as shown in the example below.</p>
<pre><code>class MyCustomException(Exception):
    pass

a = 10
b = 0
reuslt = None
try:
    try:
        result = a / b

    except ZeroDivisionError as exp:
        print(&quot;ZeroDivisionError -- &quot;,exp)
        raise MyCustomException(&quot;Zero Division &quot;) from exp

except MyCustomException as exp:
    print(&quot;MyException&quot;,exp)
    print(exp.__cause__)
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>ZeroDivisionError --  division by zero
MyException Zero Division
division by zero
</code></pre>
<h4> Gloweye, Comment 100159342 Score: 15: </h4>Please note that PEP8 prefers <code>exception(args)</code> over <code>exception (args)</code><br><h4> cg909, Comment 107973733 Score: 11: </h4>There is also <code>raise exception(args) from None</code> to say that the currently active exception was handled and is no longer of interest. Otherwise if you raise an exception inside an <code>except</code> block and it isn&#39;t handled, tracebacks for both exceptions will be shown separated by the message “During handling of the above exception, another exception occurred”<br>------------------------------------------------------------------ <br><h3> Evgeni Sergeev, Id: 30317038, Score: 45: </h3><p>For the common case where you need to throw an exception in response to some unexpected conditions, and that you never intend to catch, but simply to fail fast to enable you to debug from there if it ever happens — the most logical one seems to be <code>AssertionError</code>:</p>

<pre><code>if 0 &lt; distance &lt;= RADIUS:
    #Do something.
elif RADIUS &lt; distance:
    #Do something.
else:
    raise AssertionError("Unexpected value of 'distance'!", distance)
</code></pre>
<h4> Two-Bit Alchemist, Comment 53088786 Score: 28: </h4>This is a better case for <code>ValueError</code> than <code>AssertionError</code> because there&#39;s no problem with an assertion (because none is being made here) -- the problem is with a value. If you really want an <code>AssertionError</code> in this case, write <code>assert distance &gt; 0, &#39;Distance must be positive&#39;</code>. But you shouldn&#39;t error check that way because assertions can be turned off (<code>python -O</code>).<br><h4> Evgeni Sergeev, Comment 53092753 Score: 2: </h4>@Two-BitAlchemist Assertions can be turned off, yes, but then you shouldn&#39;t use them to error check at all?<br><h4> Evgeni Sergeev, Comment 53092744 Score: 1: </h4>@Two-BitAlchemist Good point. The idea was lost in simplification, when I wrote the simple example above. In many similar cases it&#39;s a condition that isn&#39;t associated with a particular value. Rather, the meaning is &quot;control flow should never get here&quot;.<br><h4> Evgeni Sergeev, Comment 53217549 Score: 1: </h4>@Two-BitAlchemist For me the role of assertions isn&#39;t error-checking per se (which is what testing is for), but they set up fences within the code that certain bugs can&#39;t get through. So it becomes easier to track down and isolate the bugs, which will inevitably occur. This is just good habits that take little effort, while testing takes a lot of effort and a lot of time.<br><h4> Daerdemandt, Comment 66233464 Score: 0: </h4>The error could be reproduced if pseudo-const RADIUS is somehow set to negative too.<br><h4> Two-Bit Alchemist, Comment 53120741 Score: 0: </h4>Well it depends. I wouldn&#39;t let that be my only error checking in a program I intended to distribute. On the other hand, I could make a program just for my co-workers and tell them they use it at their own risk if they run it with <code>-O</code>.<br><h4> Jonathan Hartley, Comment 53524724 Score: 0: </h4>&quot;testing takes a lot of effort and a lot of time&quot; - true, but not as much as the time and effort it saves.<br>------------------------------------------------------------------ <br><h3> Anant Prakash, Id: 43092920, Score: 22: </h3><p><em>Read the existing answers first, this is just an addendum.</em></p>
<p>Notice that you can raise exceptions with or without arguments.</p>
<p>Example:</p>
<pre><code>raise SystemExit
</code></pre>
<p>exits the program, but you might want to know what happened. So you can use this.</p>
<pre><code>raise SystemExit(&quot;program exited&quot;)
</code></pre>
<p>This will print &quot;program exited&quot; to standard error before closing the program.</p>
<h4> burny, Comment 102741734 Score: 4: </h4>Isn&#39;t this against the OOP paradigm? I assume, the first case throws the class reference and the second one an instance of SystemExit. Wouldn&#39;t <code>raise SystemExit()</code> be the better choice? Why does the first one even work?<br><h4> ptim, Comment 121421046 Score: 0: </h4><a href="https://www.python.org/dev/peps/pep-3109/" rel="nofollow noreferrer">python.org/dev/peps/pep-3109</a> discusses this<br>------------------------------------------------------------------ <br><h3> Rehan Haider, Id: 54902334, Score: 5: </h3><p>Another way to throw an exception is using <a href="https://docs.python.org/3/reference/simple_stmts.html#the-assert-statement" rel="nofollow noreferrer"><code>assert</code></a>. You can use <em>assert</em> to verify a condition is being fulfilled. If not, then it will raise <code>AssertionError</code>. For more details have a look <a href="https://www.programiz.com/python-programming/assert-statement" rel="nofollow noreferrer">here</a>.</p>
<pre><code>def avg(marks):
    assert len(marks) != 0, &quot;List is empty.&quot;
    return sum(marks)/len(marks)

mark2 = [55,88,78,90,79]
print(&quot;Average of mark2:&quot;, avg(mark2))

mark1 = []
print(&quot;Average of mark1:&quot;, avg(mark1))
</code></pre>
<h4> cowbert, Comment 113263163 Score: 6: </h4>not foolproof since asserts in CPython are ignored when the interpreter is inovked with optimizations (-O) flag; if you want to really control program flow &quot;hey this condition shouldn&#39;t happen but abend if it is true&quot;, manually <code>raise AssertionError()</code><br><h4> qwr, Comment 136502261 Score: 0: </h4>Asserts are for <i>debugging</i>. If it is a possible user input, raise a ValueError.<br>------------------------------------------------------------------ <br><h3> markemus, Id: 53597619, Score: 5: </h3><p>Just to note: there are times when you <em>do</em> want to handle generic exceptions. If you're processing a bunch of files and logging your errors, you might want to catch any error that occurs for a file, log it, and continue processing the rest of the files. In that case, a</p>
<pre><code>try:
    foo()
except Exception as e:
    print(e) # Print out handled error
</code></pre>
<p>block is a good way to do it. You'll still want to <code>raise</code> specific exceptions so you know what they mean, though.</p>
------------------------------------------------------------------ <br><h3> LuisAFK, Id: 67890877, Score: 2: </h3><p>You might also want to raise <strong>custom exceptions</strong>. For example, if you're writing a library, it's a very good practice to make a base exception class for your module, and then have custom sub-exceptions to be more specific.</p>
<p>You can achieve that like this:</p>
<pre><code>class MyModuleBaseClass(Exception):
    pass

class MoreSpecificException(MyModuleBaseClass):
    pass


# To raise custom exceptions, you can just
# use the raise keyword
raise MoreSpecificException
raise MoreSpecificException('message')
</code></pre>
<p>If you're not interested in having a custom base class, you can just inherit your custom exception classes from an ordinary exception class like <code>Exception</code>, <code>TypeError</code>, <code>ValueError</code>, etc.</p>
------------------------------------------------------------------ <br><h3> U13-Forward, Id: 69147909, Score: 1: </h3><p>If you don't care about <em>which</em> error to raise, you could use <code>assert</code> to raise an <code>AssertionError</code>:</p>
<pre><code>&gt;&gt;&gt; assert False, &quot;Manually raised error&quot;
Traceback (most recent call last):
  File &quot;&lt;pyshell#24&gt;&quot;, line 1, in &lt;module&gt;
    assert False, &quot;Manually raised error&quot;
AssertionError: Manually raised error
&gt;&gt;&gt; 
</code></pre>
<p>The <code>assert</code> keyword raises an <code>AssertionError</code> if the condition is <code>False</code>. In this case, we specified <code>False</code> directly, so it raises the error, but to have it have a text we want it to raise to, we add a comma and specify the error text we want. In this case, I wrote <code>Manually raised error</code> and this raises it with that text.</p>
<h4> qwr, Comment 136502255 Score: 0: </h4>asserts will be disabled when the interpreter is run with optimizations, so should not be used for control flow. see comments on Rehan Haider&#39;s answer<br>------------------------------------------------------------------ <br><h3> Grasshopper, Id: 60946432, Score: 0: </h3><p>You should learn the <em>raise</em> statement of Python for that.</p>
<p>It should be kept inside the try block.</p>
<p>Example -</p>
<pre><code>try:
    raise TypeError            # Replace TypeError by any other error if you want
except TypeError:
    print('TypeError raised')
</code></pre>
<h4> Brian, Comment 113991028 Score: 1: </h4>Can you give a reason for why your example is good? I&#39;ve read all the answers to this one, and I&#39;m genuinely curious.<br><h4> qwr, Comment 136502267 Score: 0: </h4>It&#39;s not good to blanket try/except an error unless you have a good reason to.<br>------------------------------------------------------------------ <br><h3> error 1044, Id: 70278544, Score: -3: </h3><p>If you don’t care about the raised exception, do:</p>
<pre><code>def crash(): return 0/0
</code></pre>
<p>It does not allow you to throw a specific message to your user but will crash the python interpriter.</p>
<p>For the more advanced python users who have used python may think that the expression will be evaluated at compile time (python is compiled) but the python compiler wont evaluate the expression at run time.
If we look at what tthe <code>dis</code> dissasembely module for python shows, we can see the bytecode.</p>
<pre><code>              2 LOAD_CONST               1 (0)
              4 LOAD_CONST               1 (0)
              6 BINARY_OP               11 (/)
</code></pre>
<p>So essentialy python will push the constant 0 onto the stack and another 0 then run a binary operator, to divide.</p>
<p>Although this function is quite useless, and should never be used in production code, it can still crash the python interpriter.</p>
