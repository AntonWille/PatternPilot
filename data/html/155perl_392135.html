 <h2> Title: What exactly does Perl&#39;s &quot;bless&quot; do? </h2> <h3> user47145, question_id: 392135 </h3>Score: 155, Tags: {perl} <br><p>I understand one uses the "bless" keyword in Perl inside a class's "new" method:</p>

<pre><code>sub new {
    my $self = bless { };
    return $self;
}    
</code></pre>

<p>But what exactly is "bless" doing to that hash reference ? </p>
<h4> Comment 79912872 Jon Skeet: </h4>See <a href="http://www.perl.com/pub/a/1999/09/refererents.html" rel="nofollow noreferrer">&quot;Bless My Referents&quot;</a> back from 1999. Looks pretty detailed. (The <a href="http://perldoc.perl.org/functions/bless.html" rel="nofollow noreferrer">Perl manual entry</a> doesn&#39;t have a great deal to say on it, unfortunately.)<br>------------------------------------------------------------------ <br><h3> Answer 392146 Gordon Wilson: </h3><p>In general, <code>bless</code> associates an object with a class.</p>

<pre><code>package MyClass;
my $object = { };
bless $object, "MyClass";
</code></pre>

<p>Now when you invoke a method on <code>$object</code>, Perl know which package to search for the method.</p>

<p>If the second argument is omitted, as in your example, the current package/class is used.</p>

<p>For the sake of clarity, your example might be written as follows:</p>

<pre><code>sub new { 
  my $class = shift; 
  my $self = { }; 
  bless $self, $class; 
} 
</code></pre>

<p>EDIT: See <a href="https://stackoverflow.com/users/11260/kixx">kixx</a>'s good <a href="https://stackoverflow.com/questions/392135/what-exactly-does-perls-bless-do#392194">answer</a> for a little more detail.</p>
------------------------------------------------------------------ <br><h3> Answer 392194 kixx: </h3><p><code>bless</code> associates a reference with a package. </p>

<p>It doesn't matter what the reference is to, it can be to a hash (most common case), to an array (not so common), to a scalar (usually this indicates an <a href="https://perldoc.perl.org/perlobj.html#Inside-Out-objects" rel="noreferrer">inside-out object</a>), to a regular expression, subroutine or TYPEGLOB (see the book <a href="https://www.goodreads.com/book/show/86378.Object_Oriented_Perl" rel="noreferrer">Object Oriented Perl: A Comprehensive Guide to Concepts and Programming Techniques by Damian Conway</a> for useful examples) or even a reference to a file or directory handle (least common case).</p>

<p>The effect <code>bless</code>-ing has is that it allows you to apply special syntax to the blessed reference. </p>

<p>For example, if a blessed reference is stored in <code>$obj</code> (associated by <code>bless</code> with package "Class"), then <code>$obj-&gt;foo(@args)</code> will call a subroutine <code>foo</code> and pass as first argument the reference <code>$obj</code> followed by the rest of the arguments (<code>@args</code>). The subroutine should be defined in package "Class". If there is no subroutine <code>foo</code> in package "Class", a list of other packages (taken form the array <code>@ISA</code> in the package "Class") will be searched and the first subroutine <code>foo</code> found will be called.</p>
<h4> Comment 7702794 ikegami: </h4>@Blessed Geek, It&#39;s not theoretical minutiae. The difference has practical applications.<br><h4> Comment 220689 converter42: </h4>Your initial statement is incorrect. Yes, bless takes a reference as its first argument, but it is the referent variable that is blessed, not the reference itself. $ perl -le &#39;sub Somepackage::foo {42}; %h=(); $h=\%h; bless $h, &quot;Somepackage&quot;; $j = \%h; print $j-&gt;UNIVERSAL::can(&quot;foo&quot;)-&gt;()&#39; 42<br><h4> Comment 44206374 ruffin: </h4>Old perlfoundation.org link for &quot;inside-out object&quot; is, at best, behind a login wall now. <a href="https://web.archive.org/web/20071024192241/http://www.perlfoundation.org/perl5/index.cgi?inside_out_object" rel="nofollow noreferrer">Archive.org link of the original is here</a>.<br><h4> Comment 3455016 Blessed Geek: </h4>Kixx&#39;s explanation is comprehensive. We should not bother with converter&#39;s picking on theoretical minutiae.<br><h4> Comment 68832973 Rhubbarb: </h4>Perhaps this will serve in place of the broken link @harmic commented on: <a href="http://perldoc.perl.org/perlobj.html#Inside-Out-objects" rel="nofollow noreferrer">perldoc.perl.org/perlobj.html#Inside-Out-objects</a><br><h4> Comment 68520117 harmic: </h4>Even the archive.org link doesn&#39;t work any more &quot;due to robots.txt&quot;.<br>------------------------------------------------------------------ <br><h3> Answer 392143 chaos: </h3><p>Short version: it's marking that hash as attached to the current package namespace (so that that package provides its class implementation).</p>
------------------------------------------------------------------ <br><h3> Answer 37613876 linuxtestside: </h3><p>This function tells the entity referenced by REF that it is now an object in the CLASSNAME package, or the current package if CLASSNAME is omitted. Use of the two-argument form of bless is recommended.</p>

<p><strong>Example</strong>: </p>

<pre><code>bless REF, CLASSNAME
bless REF
</code></pre>

<p><strong>Return Value</strong></p>

<p>This function returns the reference to an object blessed into CLASSNAME.</p>

<p><strong>Example</strong>:</p>

<p>Following is the example code showing its basic usage, the object reference is created by blessing a reference to the package's class âˆ’</p>

<pre><code>#!/usr/bin/perl

package Person;
sub new
{
    my $class = shift;
    my $self = {
        _firstName =&gt; shift,
        _lastName  =&gt; shift,
        _ssn       =&gt; shift,
    };
    # Print all the values just for clarification.
    print "First Name is $self-&gt;{_firstName}\n";
    print "Last Name is $self-&gt;{_lastName}\n";
    print "SSN is $self-&gt;{_ssn}\n";
    bless $self, $class;
    return $self;
}
</code></pre>
------------------------------------------------------------------ <br><h3> Answer 39175417 Dmytro: </h3><p>I will try to provide an answer here since the ones here didn't quite click for me at the time I was initially writing this(warning, this answer is fairly poorly structured, feel free to skip over the parts that are not particularly useful to you).</p>
<p>Perl's bless function associates the specified reference with a package name string, and making the arrow operator of the blessed reference look for the method in the package associated with the reference, and if it does not find it, it continues looking using the <code>@ISA</code> array if there is one(this is beyond the scope of this post).</p>
<p>Why would we need this?</p>
<p>Let's begin by expressing an example in JavaScript:</p>
<pre class="lang-js prettyprint-override"><code>(() =&gt; {
    //'use strict'; // uncomment to fix the bug mentioned below.

    class Animal {
        constructor(args) {
            console.log(this);
            this.name = args.name;
            this.sound = args.sound;
        }
    }

    /* This is left for historical reasons, 
     *    modern JavaScript engines no longer allow you to
     *    call class constructors without using new.
     * 
     * var animal = Animal({
     *     'name': 'Jeff',
     *     'sound': 'bark'
     * }); 
     * console.log(animal.name + ', ' + animal.sound); // seems good
     * console.log(window.name); // my window's name is Jeff?
     */

    // as of recently, Animal constructor cannot be called without using the new operator.
    var animal = new Animal({
        'name': 'Jeff',   
        'sound': 'bark'
    });

    console.log(animal.name + ', ' + animal.sound); // still fine.
    console.log(&quot;window's name: &quot; + window.name); // undefined
})();
</code></pre>
<p>Now let's look at the desugared version of the class construct:</p>
<pre class="lang-js prettyprint-override"><code>(() =&gt; {
    // 'use strict'; // uncomment to fix bug.

    var Animal = function(args) {
        this.name = args.name;
        this.sound = args.sound;
        return this; // implicit context hashmap
    };
    
    /** 
     *  The bug left for historical reasons,
     *      should still work now in modern web developer consoles.
     *      
     *  var animal = Animal({
     *      'name': 'Jeff',
     *      'sound': 'Bark'
     *  });
     *  console.log(animal.name + ', ' + animal.sound); // seems good
     *  console.log(&quot;The window's name is: &quot; + window.name); // my window's name is Jeff?
     */
  
    // the new operator causes the &quot;this&quot; inside methods to refer to the animal
    // rather than the global scope, so the bug mentioned above does not occur.
    var animal = new Animal({
        'name': 'Jeff',
        'sound': 'bark'
    });
    console.log(animal.sound);    
    console.log(window.name); // the name has not been changed by the constructor.
})();
</code></pre>
<p>The Animal's constructor function takes an Object of properties and returns an Animal with those properties, or if you forgot to put the new keyword, it will return the whole global context(which is <code>window</code> inside the browser developer console).</p>
<p>Perl has no &quot;this&quot; nor &quot;new&quot; nor &quot;class&quot;, but it can still have a function that behaves similarly. We won't have a constructor nor a prototype, but we will be able to create new animals and modify their individual properties.</p>
<pre class="lang-perl prettyprint-override"><code># immediatly invoked subroutine execution(IIFE).
(sub {
    my $Animal = (sub {
        return {
            'name' =&gt; $_[0]{'name'},
            'sound' =&gt; $_[0]{'sound'}
        };
    });

    my $animal = $Animal-&gt;({
        'name' =&gt; 'Jeff',
        'sound' =&gt; 'bark'
    });

    print $animal-&gt;{sound};
})-&gt;();
</code></pre>
<p>Now, we have a problem: What if we want the animal to perform the sounds by themselves rather than having to print what their voice is directly. That is, we want a function performSound that prints the animal's own sound.</p>
<p>One way to do this is by giving each instance of an Animal  its own performSound subroutine reference.</p>
<pre class="lang-perl prettyprint-override"><code># self contained scope 
(sub {
    my $Animal = (sub {
        $name = $_[0]{'name'};
        $sound = $_[0]{'sound'};
    
        return {
            'name' =&gt; $name,
            'sound' =&gt; $sound,
            'performSound' =&gt; sub {
                print $sound . &quot;\n&quot;;
            }
        };
    });

    my $animal = $Animal-&gt;({
        'name' =&gt; 'Jeff',
        'sound' =&gt; 'bark'
    });

    $animal-&gt;{'performSound'}();
})-&gt;();
</code></pre>
<p>This is usually not what we want because performSound is put as a completely new subroutine reference for each animal that is constructed. Constructing 10000 animals would potentially allocate 10000 performSound subroutines. We want to have a single subroutine performSound that is used by all Animal instances that look up their own sound and print it.</p>
<pre class="lang-js prettyprint-override"><code>(() =&gt; {
    'use strict';

    /* a function that creates an Animal constructor which can be used to create animals */
    var Animal = (() =&gt; {
        /* function is important, as fat arrow does not have &quot;this&quot; and will not be bound to Animal. */
        var InnerAnimal = function(args) {
            this.name = args.name;
            this.sound = args.sound;
        };
        /* defined once and all animals use the same single function call */
        InnerAnimal.prototype.performSound = function() {
            console.log(this.name);
        };
        
        return InnerAnimal;
    })();
 
    var animal = new Animal({
        'sound': 'bark',
        'name': 'Jeff'
    });
    animal.performSound(); // Jeff
})();
</code></pre>
<p>Here is where the parallel to Perl kinda stops.</p>
<p>JavaScript's new operator is not optional, without it, &quot;this&quot; inside object methods contaminates the global scope:</p>
<pre class="lang-js prettyprint-override"><code>(() =&gt; {
    // uncommenting this prevents unintentional
    //     contamination of the global scope, and throws a TypeError instead.
    // 'use strict'; 

    var Person = function() {
        this.name = &quot;Sam&quot;;
    };
//    var wrong = Person(); // oops! we have overwritten window.name or global.main.
//    console.log(window.name); // my window's name is Sam?
    var correct = new Person; // person's name is actually stored in the person now.    
})();
</code></pre>
<p>We want to have one function for each Animal that looks up that animal's own sound rather than hardcoding it at construction.</p>
<p>Blessing lets us use the package's subroutines rather than having to attach a subroutine ref to each object, it also makes <code>ref</code> refer to the more meaningful package name(such as <code>Animal</code>) as the name for the what the object is rather than a boring <code>HASH</code> or whatever other referent you chose to bless:</p>
<pre class="lang-perl prettyprint-override"><code>package Animal;
sub new {
    my $packageRef = $_[0];
    my $name = $_[1]-&gt;{'name'};
    my $sound = $_[1]-&gt;{'sound'};

    my $this = {
        'name' =&gt; $name,
        'sound' =&gt; $sound
    };   
    
    bless($this, $packageRef);
    return $this;
}

# all animals use the same performSound to look up their sound.
sub performSound {
    my $this = shift;
    my $sound = $this-&gt;{'sound'};
    print $sound . &quot;\n&quot;;
}

package main;
my $animal = Animal-&gt;new({
    'name' =&gt; 'Cat',
    'sound' =&gt; 'meow'
});

print(&quot;The animal's ref is: &quot; . ref($animal) . &quot;\n&quot;);
$animal-&gt;performSound();
</code></pre>
<p><strong>Summary/TL;DR</strong>:</p>
<ol>
<li><p>Perl has no &quot;this&quot;, &quot;class&quot;, nor &quot;new&quot;.</p>
</li>
<li><p>Blessing an object to a package gives that object a reference to the package.</p>
</li>
<li><p>Using the arrow operator to invoke a method of a blessed referent(<code>$blessedObject-&gt;method(...arguments)</code>) is often the same as calling <code>Package::method($blessedObject, ...arguments)</code>, but if method is not found, it will continue looking using the <code>@ISA</code> of the package which is beyond the scope of this post.</p>
</li>
<li><p>You can in fact create new classes at runtime, as long as you either violate strict 'refs' or use eval, here's a demonstration of how it can be done:</p>
</li>
</ol>
<pre class="lang-perl prettyprint-override"><code>#!/usr/bin/perl

use warnings;
use strict;

print('Enter the name for the class(eg Greeter): $ ');
my $class_name = &lt;&gt;;
chomp $class_name;

print('Enter the name of the method(eg greet): $ ');
my $method_name = &lt;&gt;;
chomp $method_name;

no strict 'refs';
# The line below violates strict 'refs'.
*{$class_name . '::new'} = sub {
    my $self = bless {}, $_[0];
    return $self;
}; 
use strict 'refs';

no strict 'refs';
# The line below violates strict 'refs'
*{$class_name . '::' . $method_name} = sub {
    print(&quot;Hello, World!\n&quot;);
};
use strict 'refs';

my $instance = ($class_name)-&gt;new();
$instance-&gt;$method_name();
</code></pre>
<p><strong>Why the confusion?</strong>:</p>
<p>One reason why bless is confusing is because there are effectively three ways of calling a package</p>
<ol>
<li>Through <code>A::a()</code>, as a package subroutine.</li>
<li>Through <code>A-&gt;a()</code>, as a package subroutine, but that gets <code>__PACKAGE__</code> passed as the first argument implicitly before the other arguments.</li>
<li>Through <code>$a-&gt;a()</code> with a blessed <code>$a</code> into <code>A</code>.</li>
</ol>
<p>The code below illustrates this:</p>
<pre class="lang-perl prettyprint-override"><code># | Illustrates catching 3 distinct ways of calling a package's member.
package Test;

sub new {        
    return bless {}, __PACKAGE__;
}

sub runTest {
    if (ref($_[0]) eq __PACKAGE__) {
        # | $_[0] is the blessed reference.
        # | Despite being called with &quot;-&gt;&quot;, $_[1] is NOT &quot;Test&quot;(__PACKAGE__).
        print(&quot;Test::runTest was called through a blessed reference call(\$instance-&gt;runTest().\n&quot;);
    } elsif ($_[0] eq __PACKAGE__) {
        # | $_[0] is &quot;Test&quot;(__PACKAGE__), but we can't determine for sure whether it was -&gt; or ::.
        print(&quot;Test::runTest was called through Test-&gt;runTest() or through Test::runTest() with 'Test' as the first argument.\n&quot;);
    } else {
        # | $_[0] is neither a blessed reference nor &quot;Test&quot;(__PACKAGE__), so it can't be an arrow call.
        print &quot;Test::runTest was called through Test::runTest()\n&quot;;
    }
}

package main;

my $test = Test-&gt;new();
$test-&gt;runTest();
Test-&gt;runTest();
Test::runTest();
Test::runTest('Test'); # &lt;- Same as &quot;Test-&gt;runTest();&quot;
Test::runTest($test); # &lt;- Same as &quot;$test-&gt;runTest();&quot;
</code></pre>
<p>Another reason is that unlike JavaScript, Python, which can have multiple classes with different name but different definitions/methods/properties, Perl classes have unique(<code>ref $obj</code>), as there can only be one package with a specific name at any given time, and @ISA takes a bit to get used to.</p>
<p>My final reason is that packages are less tangible than classes in other scripting languages where you can store a reference to the class itself inside a variable through the assignment operator, whereas in Perl not only can you not store references to the class(you can only refer to packages through their name strings), but trying to refer to a package through a name stored inside a variable (eg String[$method]) seems impossible without violating strict 'refs' or using eval.</p>
<p>Anyway hopefully somebody will find this post useful.</p>
<hr />
<blockquote>
<p>Note: this is a fairly old attempt at an answer, I have tried to clean up the amount of naive and embarassing/pointless/distracting statements, and adding more useful examples to help understand the concept, but it is still far from  what I would like it to be(it is still fairly frustrating to re-read).
I leave it as I still believe it may be of use to someone.</p>
<p>Please take it with a gain of salt, I apologize for any headache called by the poorly laid out structure of the answer.</p>
</blockquote>
<h4> Comment 103352700 DavidO: </h4>It is not impossible to create new classes at runtime.  <code>my $o = bless {}, $anything;</code> will bless an object into the <code>$anything</code> class. Similarly, <code>{no strict &#39;refs&#39;; *{$anything . &#39;::somesub&#39;} = sub {my $self = shift; return $self-&gt;{count}++};</code> will create a method named &#39;somesub&#39; in the class named in <code>$anything</code>. This is all possible at runtime. &quot;Possible&quot;, however, doesn&#39;t make it a great practice to wield in every-day code. But it is useful in building object overlay systems such as Moose or Moo.<br><h4> Comment 103837899 Dmytro: </h4>interesting, so you are saying I can bless a referent into a class whose name is decided at runtime. Seems interesting, and does void my <code>unfortunately it makes it impossible(to my understanding) to create &quot;new classes&quot; at runtime</code> claim. I guess my concern ultimately boiled down to it being significantly less intuitive to manipulate/introspect the package system at runtime, but so far I have failed showing anything it inherently cannot do. Package system seem to support all the tools needed to add/remove/inspect/modify itself at runtime.<br><h4> Comment 103846581 DavidO: </h4>This is correct; you can manipulate Perl&#39;s symbol table programatically, and therefore can manipulate Perl&#39;s packages, and a package&#39;s members at runtime, even without having declared &quot;package Foo&quot; anywhere. Symbol table inspection and manipulation at runtime, AUTOLOAD semantics, subroutine attributes, tieing of variables to classes... there are many ways to get under the hood. Some of them are useful for autogenerating APIs, validation tools, autodocumenting APIs; we can&#39;t predict all the use cases. Shooting oneself in the foot is also a possible outcome of such trickery.<br>------------------------------------------------------------------ <br><h3> Answer 58970744 zdim: </h3><p>What specifically distinguishes a <code>bless</code>-ed referent internally is that the <code>SV</code>  for the reference (stored in the scalar) picks up an additional <code>FLAGS</code> value (<code>OBJECT</code>), and also a <code>STASH</code> which carries the package name (with a few other differences)</p>
<pre><code>perl -MDevel::Peek -wE'
    package Pack  { sub func { return { a=&gt;1 } } }; 
    package Class { sub new  { return bless { A=&gt;10 } } }; 
    $vp  = Pack::func(); print Dump $vp;   say&quot;---&quot;; 
    $obj = Class-&gt;new;   print Dump $obj'
</code></pre>
<p>Prints, with the same (and irrelevant for this) parts suppressed</p>
<pre><code>SV = IV(0x12d5530) at 0x12d5540
  REFCNT = 1
  FLAGS = (ROK)
  RV = 0x12a5a68
  SV = PVHV(0x12ab980) at 0x12a5a68
    REFCNT = 1
    FLAGS = (SHAREKEYS)
    ...
      SV = IV(0x12a5ce0) at 0x12a5cf0
      REFCNT = 1
      FLAGS = (IOK,pIOK)
      IV = 1
---
SV = IV(0x12cb8b8) at 0x12cb8c8
  REFCNT = 1
  FLAGS = (PADMY,ROK)
  RV = 0x12c26b0
  SV = PVHV(0x12aba00) at 0x12c26b0
    REFCNT = 1
    FLAGS = (OBJECT,SHAREKEYS)         &lt;--
    STASH = 0x12d5300   &quot;Class&quot;        &lt;--
    ...
      SV = IV(0x12c26b8) at 0x12c26c8
      REFCNT = 1
      FLAGS = (IOK,pIOK)
      IV = 10
</code></pre>
<p>With that it is known to the interpreter that</p>
<ul>
<li><p>this is an object</p>
</li>
<li><p>what package it belongs to</p>
</li>
</ul>
<p>and this informs its use.</p>
<p>For example, when dereferencing on that variable is encountered (<code>$obj-&gt;name</code>), a sub with that name is sought in the package (or hierarchy), the object is passed as the first argument, etc.</p>
------------------------------------------------------------------ <br><h3> Answer 30051119 Steven Koch: </h3><p>I Following this thought to guide the development object-oriented Perl.</p>

<p>Bless associate any data structure reference with a class. Given how Perl creates the inheritance structure (in a kind of tree) it is easy to take advantage of the object model to create Objects for composition.</p>

<p>For this association we called object, to develop always have in mind that the internal state of the object and class behaviours are separated. And you can bless/allow any data reference to use any package/class behaviours.
Since the package can understand "the emotional" state of the object.</p>
<h4> Comment 48216859 Steven Koch: </h4>Here are same announces with how Perl works with namespaces of packages and how work with states registered in your namespace. Because this exist pragmas like use namespace::clean. But try to keep things simpler possible.<br>------------------------------------------------------------------ <br><h3> Answer 76002687 Amlan Samuel Warman: </h3><p><code>bless($obj,'PackageName')</code> is a Perl builtin function to give <code>$obj</code> access to all <code>'PackageName'</code> subs</p>
<p>For example:</p>
<pre><code>use JSON;

#-- create json data
$data = {foo=&gt;&quot;bar&quot;};

#-- lets print stringify using JSON
print JSON::encode_json($data);
    # will print: {&quot;foo&quot;:&quot;bar&quot;}

#-- let create object
$obj = { &quot;xxx&quot; =&gt; &quot;yyy&quot; };

#-- let try bless obj with JSON
bless($obj,'JSON');

#-- $obj still has &quot;xxx&quot;
print $obj-&gt;{xxx};
    #will print yyy

#-- see above JSON has sub encode_json, now in $obj has all JSON subs
#-- include encode_json lest try:

print $obj-&gt;encode_json($data);

   #-- error: Usage: JSON::XS::encode_json(scalar)
   # why ?

   # because $obj-&gt;encode_json is same as:
   
   # JSON::encode_json($obj,$data)

   # using $obj-&gt;mysub is set $obj as FIRST ARGUMENT of PackageName::mysub 
   # and this encode_json try to stringify $obj that already 
   # have all subs of package JSON
</code></pre>
------------------------------------------------------------------ <br><h3> Answer 6367564 Bimlesh Sharma: </h3><p>For example, if you can be confident that any Bug object is going to be a blessed hash, you can (finally!) fill in the missing code in the Bug::print_me method:</p>

<pre><code> package Bug;
 sub print_me
 {
     my ($self) = @_;
     print "ID: $self-&gt;{id}\n";
     print "$self-&gt;{descr}\n";
     print "(Note: problem is fatal)\n" if $self-&gt;{type} eq "fatal";
 }
</code></pre>

<p>Now, whenever the print_me method is called via a reference to any hash that's been blessed into the Bug class, the $self variable extracts the reference that was passed as the first argument and then the print statements access the various entries of the blessed hash. </p>
<h4> Comment 27873499 Anderson Green: </h4>@darch From which source was this answer plagiarized?<br>