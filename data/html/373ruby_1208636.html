 <h2> Title: Rails :include vs. :joins </h2> <h4> Rob Cameron, question_id: 1208636 </h4>Score: 373, Tags: {ruby-on-rails,ruby,database,join,rails-activerecord} <br><p>This is more of a "why do things work this way" question rather than a "I don't know how to do this" question...</p>

<p>So the gospel on pulling associated records that you know you're going to use is to use <code>:include</code> because you'll get a join and avoid a whole bunch of extra queries:</p>

<pre><code>Post.all(:include =&gt; :comments)
</code></pre>

<p>However when you look at the logs, there's no join happening:</p>

<pre><code>Post Load (3.7ms)   SELECT * FROM "posts"
Comment Load (0.2ms)   SELECT "comments.*" FROM "comments" 
                       WHERE ("comments".post_id IN (1,2,3,4)) 
                       ORDER BY created_at asc) 
</code></pre>

<p>It <em>is</em> taking a shortcut because it pulls all of the comments at once, but it's still not a join (which is what all the documentation seems to say). The only way I can get a join is to use <code>:joins</code> instead of <code>:include</code>:</p>

<pre><code>Post.all(:joins =&gt; :comments)
</code></pre>

<p>And the logs show:</p>

<pre><code>Post Load (6.0ms)  SELECT "posts".* FROM "posts" 
                   INNER JOIN "comments" ON "posts".id = "comments".post_id
</code></pre>

<p>Am I missing something? I have an app with half a dozen associations and on one screen I display data from all of them. Seems like it would be better to have one join-ed query instead of 6 individuals. I know that performance-wise it's not always better to do a join rather than individual queries (in fact if you're going by time spent, it looks like the two individual queries above are faster than the join), but after all the docs I've been reading I'm surprised to see <code>:include</code> not working as advertised.</p>

<p>Maybe Rails <em>is</em> cognizant of the performance issue and doesn't join except in certain cases?</p>
<h4> Allison, Id: 123763204 Score: 0: </h4>This Scout engineering blog post is a nice reference: <a href="https://scoutapm.com/blog/activerecord-includes-vs-joins-vs-preload-vs-eager_load-when-and-where" rel="nofollow noreferrer">scoutapm.com/blog/&hellip;</a><br><h4> onebree, Id: 49540531 Score: 3: </h4>if you were using an older version of Rails, please state that via tags or in your question body. Otherwise, if you are using Rails 4 NOW, it is <code>includes</code> (for anyone reading this)<br><h4> Dave Powers, Id: 126048390 Score: 0: </h4>Also there is now <code>:preload</code> and <code>:eager_load</code>: <a href="https://www.bigbinary.com/blog/preload-vs-eager-load-vs-joins-vs-includes" rel="nofollow noreferrer">bigbinary.com/blog/preload-vs-eager-load-vs-joins-vs-include&zwnj;&#8203;s</a><br>------------------------------------------------------------------ <br><h3> Greg Campbell, Id: 1208723, Score: 185: </h3><p>It appears that the <code>:include</code> functionality was changed with Rails 2.1.  Rails used to do the join in all cases, but for performance reasons it was changed to use multiple queries in some circumstances.  <a href="http://akitaonrails.com/2008/5/26/rolling-with-rails-2-1-the-first-full-tutorial-part-2" rel="noreferrer">This blog post</a> by Fabio Akita has some good information on the change (see the section entitled "Optimized Eager Loading").</p>
<h4> Sam Saffron, Comment 1036283 Score: 2: </h4>See: <a href="http://samsaffron.com/archive/2008/03/15/You+should+be+very+careful+when+using+ActiveRecord+eager+loading" rel="nofollow noreferrer">samsaffron.com/archive/2008/03/15/&hellip;</a><br><h4> Jonathan Swartz, Comment 29966016 Score: 0: </h4>This is very helpful, thanks. I wish though that there was a way to force Rails to do the join even without a &#39;where&#39; that requires it. In some cases, you know the join will be more efficient and will not incur the risk of duplication.<br><h4> Dave Powers, Comment 126048342 Score: 0: </h4>@JonathanSwartz This is now supported with <a href="https://www.bigbinary.com/blog/preload-vs-eager-load-vs-joins-vs-includes#eager-load" rel="nofollow noreferrer">Eager load</a>.<br>------------------------------------------------------------------ <br><h3> Prem, Id: 10129946, Score: 121: </h3><p><code>.joins</code> will just joins the tables and brings selected fields in return. if you call associations on joins query result, it will fire database queries again</p>

<p><code>:includes</code> will eager load the included associations and add them in memory. <code>:includes</code> loads all the included tables attributes. If you call associations on include query result, it will not fire any queries</p>
------------------------------------------------------------------ <br><h3> holden, Id: 1491465, Score: 79: </h3><p>The difference between joins and include is that using the include statement generates a much larger SQL query loading into memory all the attributes from the other table(s).</p>

<p>For example, if you have a table full of comments and you use a :joins => users to pull in all the user information for sorting purposes, etc it will work fine and take less time than :include, but say you want to display the comment along with the users name, email, etc.  To get the information using :joins, it will have to make separate SQL queries for each user it fetches, whereas if you used :include this information is ready for use.</p>

<p>Great example:</p>

<p><a href="http://railscasts.com/episodes/181-include-vs-joins" rel="noreferrer">http://railscasts.com/episodes/181-include-vs-joins</a></p>
------------------------------------------------------------------ <br><h3> Aaditi Jain, Id: 27078083, Score: 70: </h3><p>I was recently reading more on difference between <code>:joins</code> and <code>:includes</code> in rails. Here is an explaination of what I understood (with examples :))</p>
<p>Consider this scenario:</p>
<ul>
<li><p>A User has_many comments and a comment belongs_to a User.</p>
</li>
<li><p>The User model has the following attributes: Name(string), Age(integer). The Comment model has the following attributes:Content, user_id. For a comment a user_id can be null.</p>
</li>
</ul>
<h2><strong>Joins:</strong></h2>
<p>:joins performs a <strong>inner join</strong> between two tables. Thus</p>
<pre><code>Comment.joins(:user)

#=&gt; &lt;ActiveRecord::Relation [#&lt;Comment id: 1, content: &quot;Hi I am Aaditi.This is my first   comment!&quot;, user_id: 1, created_at: &quot;2014-11-12 18:29:24&quot;, updated_at: &quot;2014-11-12 18:29:24&quot;&gt;, 
     #&lt;Comment id: 2, content: &quot;Hi I am Ankita.This is my first comment!&quot;, user_id: 2, created_at: &quot;2014-11-12 18:29:29&quot;, updated_at: &quot;2014-11-12 18:29:29&quot;&gt;,    
     #&lt;Comment id: 3, content: &quot;Hi I am John.This is my first comment!&quot;, user_id: 3, created_at: &quot;2014-11-12 18:30:25&quot;, updated_at: &quot;2014-11-12 18:30:25&quot;&gt;]&gt;
</code></pre>
<p>will fetch <strong>all records where user_id (of comments table) is equal to user.id (users table).</strong> Thus if you do</p>
<pre><code>Comment.joins(:user).where(&quot;comments.user_id is null&quot;)

#=&gt; &lt;ActiveRecord::Relation []&gt;
</code></pre>
<p>You will get a empty array as shown.</p>
<p>Moreover joins does not load the joined table in memory. Thus if you do</p>
<pre><code>comment_1 = Comment.joins(:user).first

comment_1.user.age
#=&gt; User Load (0.0ms)  SELECT &quot;users&quot;.* FROM &quot;users&quot; WHERE &quot;users&quot;.&quot;id&quot; = ? ORDER BY &quot;users&quot;.&quot;id&quot; ASC LIMIT 1 [[&quot;id&quot;, 1]]
#=&gt; 24
</code></pre>
<p>As you see, <code>comment_1.user.age</code> will fire a database query again in the background to get the results</p>
<h2><strong>Includes:</strong></h2>
<p>:includes performs a <strong>left outer join</strong> between the two tables. Thus</p>
<pre><code>Comment.includes(:user)

#=&gt;&lt;ActiveRecord::Relation [#&lt;Comment id: 1, content: &quot;Hi I am Aaditi.This is my first comment!&quot;, user_id: 1, created_at: &quot;2014-11-12 18:29:24&quot;, updated_at: &quot;2014-11-12 18:29:24&quot;&gt;,
   #&lt;Comment id: 2, content: &quot;Hi I am Ankita.This is my first comment!&quot;, user_id: 2, created_at: &quot;2014-11-12 18:29:29&quot;, updated_at: &quot;2014-11-12 18:29:29&quot;&gt;,
   #&lt;Comment id: 3, content: &quot;Hi I am John.This is my first comment!&quot;, user_id: 3, created_at: &quot;2014-11-12 18:30:25&quot;, updated_at: &quot;2014-11-12 18:30:25&quot;&gt;,    
   #&lt;Comment id: 4, content: &quot;Hi This is an anonymous comment!&quot;, user_id: nil, created_at: &quot;2014-11-12 18:31:02&quot;, updated_at: &quot;2014-11-12 18:31:02&quot;&gt;]&gt;
</code></pre>
<p>will result in <strong>a joined table with all the records from comments table.</strong> Thus if you do</p>
<pre><code>Comment.includes(:user).where(&quot;comment.user_id is null&quot;)
#=&gt; #&lt;ActiveRecord::Relation [#&lt;Comment id: 4, content: &quot;Hi This is an anonymous comment!&quot;, user_id: nil, created_at: &quot;2014-11-12 18:31:02&quot;, updated_at: &quot;2014-11-12 18:31:02&quot;&gt;]&gt;
</code></pre>
<p>it will fetch records where comments.user_id is nil as shown.</p>
<p>Moreover includes loads both the tables in the memory. Thus if you do</p>
<pre><code>comment_1 = Comment.includes(:user).first

comment_1.user.age
#=&gt; 24
</code></pre>
<p>As you can notice comment_1.user.age simply loads the result from memory without firing a database query in the background.</p>
<h4> Aaditi Jain, Comment 56573180 Score: 0: </h4>@HunterStevens: Yes it is<br>------------------------------------------------------------------ <br><h3> Brian Maltzan, Id: 4315729, Score: 56: </h3><p>In addition to a performance considerations, there's a functional difference too.
When you join comments, you are asking for posts that have comments- an inner join by default.
When you include comments, you are asking for all posts- an outer join.</p>
------------------------------------------------------------------ <br><h3> Kevin Choubacha, Id: 34602041, Score: 15: </h3><p><em>tl;dr</em></p>

<p>I contrast them in two ways:</p>

<p><strong>joins</strong> - For conditional selection of records.</p>

<p><strong>includes</strong> - When using an association on each member of a result set.</p>

<p><em>Longer version</em></p>

<p>Joins is meant to filter the result set coming from the database. You use it to do set operations on your table. Think of this as a where clause that performs set theory.</p>

<p><code>Post.joins(:comments)</code></p>

<p>is the same as</p>

<p><code>Post.where('id in (select post_id from comments)')</code></p>

<p>Except that if there are more than one comment you will get duplicate posts back with the joins. But every post will be a post that has comments. You can correct this with distinct:</p>

<pre><code>Post.joins(:comments).count
=&gt; 10
Post.joins(:comments).distinct.count
=&gt; 2
</code></pre>

<p>In contract, the <code>includes</code> method will simply make sure that there are no additional database queries when referencing the relation (so that we don't make n + 1 queries)</p>

<pre><code>Post.includes(:comments).count
=&gt; 4 # includes posts without comments so the count might be higher.
</code></pre>

<p>The moral is, use <code>joins</code> when you want to do conditional set operations and use <code>includes</code> when you are going to be using a relation on each member of a collection.</p>
<h4> Ben Hull, Comment 94396654 Score: 0: </h4>That <code>distinct</code> gets me every time. Thank you!<br>------------------------------------------------------------------ <br><h3> user3412661, Id: 22508895, Score: 4: </h3><p>.joins works as database join and it joins two or more table and fetch selected data from backend(database).</p>

<p>.includes work as left join of database. It loaded all the records of left side, does not have relevance of right hand side model. It is used to eager loading because it load all associated object in memory. If we call associations on include query result then it does not fire a query on database, It simply return data from memory because it have already loaded data in memory.</p>
------------------------------------------------------------------ <br><h3> Thorin, Id: 30137056, Score: 0: </h3><p>'joins' just used to join tables and when you called associations on joins then it will again fire query (it mean many query will fire)</p>

<pre><code>lets suppose you have tow model, User and Organisation
User has_many organisations
suppose you have 10 organisation for a user 
@records= User.joins(:organisations).where("organisations.user_id = 1")
QUERY will be 
 select * from users INNER JOIN organisations ON organisations.user_id = users.id where organisations.user_id = 1

it will return all records of organisation related to user
and @records.map{|u|u.organisation.name}
it run QUERY like 
select * from organisations where organisations.id = x then time(hwo many organisation you have)
</code></pre>

<p>total number of SQL is 11 in this case</p>

<p>But with
'includes' will eager load the included associations and add them in memory(load all associations on first load) and not fire query again</p>

<p>when you get records with includes like 
@records= User.includes(:organisations).where("organisations.user_id = 1")
then query will be </p>

<pre><code>select * from users INNER JOIN organisations ON organisations.user_id = users.id where organisations.user_id = 1
and 


 select * from organisations where organisations.id IN(IDS of organisation(1, to 10)) if 10 organisation
and when you run this 
</code></pre>

<p>@records.map{|u|u.organisation.name}
    no query will fire</p>
