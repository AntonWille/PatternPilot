 <h2> Title: How can I delete a newline if it is the last character in a file? </h2> <h4> Todd Partridge &#39;Gen2ly&#39;, question_id: 1654021, created_at: 2009-10-31 10:42:19+00:00 </h4>Score: 180, Tags: {linux,perl,shell,awk,sed} <br><p>I have some files that I'd like to delete the last newline if it is the last character in a file.  <code>od -c</code> shows me that the command I run does write the file with a trailing new line:</p>

<pre><code>0013600   n   t  &gt;  \n
</code></pre>

<p>I've tried a few tricks with sed but the best I could think of isn't doing the trick:</p>

<pre><code>sed -e '$s/\(.*\)\n$/\1/' abc
</code></pre>

<p>Any ideas how to do this?</p>
<h4> Comment by Cory Mawhorter, Score: 10, Id: 46889866, created_at: 2015-03-30 17:18:38+00:00 </h4>@ThomasPadron-McCarthy &quot;In computing, for every good reason there is to do something there exists a good reason not to do it and visa versa.&quot;  -Jesus -- &quot;you shouldn&#39;t do that&quot; is a horrible answer no matter the question.  The correct format is:  [how to do it] but [why it <i>may</i> be bad idea]. #sacrilege<h4> Comment by Thomas Padron-McCarthy, Score: 10, Id: 1525513, created_at: 2009-10-31 11:06:25+00:00 </h4>Can you elaborate on why you want to do this? Text files are <i>supposed</i> to end with an end-of-line, unless they are entirely empty. It seems strange to me that you&#39;d want to have such a truncated file?<h4> Comment by Dennis Williamson, Score: 4, Id: 1525467, created_at: 2009-10-31 10:47:36+00:00 </h4>newline is only one character for unix newlines. DOS newlines are two characters. Of course, literal &quot;\n&quot; is two characters. Which are you actually looking for?<h4> Comment by pavium, Score: 3, Id: 1525470, created_at: 2009-10-31 10:49:12+00:00 </h4>Although the representation might be <code>\n</code>, in linux is is <i>one</i> character<h4> Comment by pavium, Score: 0, Id: 1525535, created_at: 2009-10-31 11:15:28+00:00 </h4>The usual reason for doing <i>something</i> like this is to delete a trailing comma from the last line of a CSV file. Sed works well, but newlines have to be treated differently.<h4> Comment by Todd Partridge &#39;Gen2ly&#39;, Score: 0, Id: 1525604, created_at: 2009-10-31 11:39:39+00:00 </h4>Yeah this is for Linux so thanks for correcting that newline is just one character.  Fixed in post.<h4> Comment by tchrist, Score: 0, Id: 24954116, created_at: 2013-06-20 21:41:44+00:00 </h4>Please never delete the final newline in a file of newline-terminated lines. It screws up all kinds of things.<h4> Comment by wisbucky, Score: 0, Id: 91046522, created_at: 2018-08-27 22:41:28+00:00 </h4>One reason to remove the trailing newline is if you&#39;re piping the string to somewhere else, and you can&#39;t have a trailing newline.<hr><h3> ✔️ Answer by pavium, Id: 1654042, Score: 241, created_at: 2009-10-31 10:55:12+00:00 </h3><pre><code>perl -pe 'chomp if eof' filename &gt;filename2
</code></pre>

<p>or, to edit the file in place:</p>

<pre><code>perl -pi -e 'chomp if eof' filename
</code></pre>

<p><sup>[Editor's note: <code>-pi -e</code> was originally <code>-pie</code>, but, as noted by several commenters and explained by @hvd, the latter doesn't work.]</sup></p>

<p>This was described as a 'perl blasphemy' on the awk website I saw.</p>

<p>But, in a test, it worked.</p>
<h4> Comment by Ether, Score: 14, Id: 1526426, created_at: 2009-10-31 17:11:51+00:00 </h4>The funny thing about blasphemy and heresy is it&#39;s usually hated because it&#39;s correct. :)<h4> Comment by Sinan &#220;n&#252;r, Score: 11, Id: 1525541, created_at: 2009-10-31 11:17:05+00:00 </h4>You can make it safer by using <code>chomp</code>. And it beats slurping the file.<h4> Comment by Romuald Brunet, Score: 8, Id: 15921955, created_at: 2012-08-14 10:26:02+00:00 </h4>Small correction: you can use <code>perl -pi -e &#39;chomp if eof&#39; filename</code>, to edit a file in-place instead of creating a temporary file<h4> Comment by aditsu quit because SE is EVIL, Score: 8, Id: 23355289, created_at: 2013-05-01 01:29:21+00:00 </h4><code>perl -pie &#39;chomp if eof&#39; filename</code> -&gt; Can&#39;t open perl script &quot;chomp if eof&quot;: No such file or directory; <code>perl -pi -e &#39;chomp if eof&#39; filename</code> -&gt; works<h4> Comment by Todd Partridge &#39;Gen2ly&#39;, Score: 6, Id: 1525866, created_at: 2009-10-31 13:27:51+00:00 </h4>Blasphemy though it is, it works very well. perl -i -pe &#39;chomp if eof&#39; filename. Thank you.<h4> Comment by user743382, Score: 3, Id: 47139019, created_at: 2015-04-07 11:02:32+00:00 </h4>@KyleStrand I don&#39;t know about the &quot;blasphemy&quot; part other than perhaps the mere fact of recommending perl could be considered blasphemy on an awk website, but the reason <code>-pie</code> and <code>-pi -e</code> don&#39;t work the same way is that the <code>-i</code> option takes an optional argument. <code>-pie</code> uses <code>e</code> as the argument to <code>-i</code>, specifying the backup suffix, and then interprets <code>&#39;chomp if eof&#39;</code> as a filename, since it isn&#39;t preceded by an <code>-e</code> option. <code>-pi -e</code> omits the argument for <code>-i</code>, and allows <code>-e</code> to be treated as an option.<h4> Comment by pkaeding, Score: 2, Id: 86711170, created_at: 2018-04-16 00:37:47+00:00 </h4>isn&#39;t all of Perl blasphemy? ;)<h4> Comment by Heath Borders, Score: 1, Id: 104547052, created_at: 2019-12-03 16:24:02+00:00 </h4><code>cat foo | perl -pe &#39;chomp if eof&#39;</code> removes the newline from <code>foo</code>, but <code>git status</code> still reports a diff. Maybe the file was <code>\r\n</code> and <code>perl</code> just removes the <code>\n</code>?<h4> Comment by Olumide, Score: 1, Id: 15261153, created_at: 2012-07-18 13:07:59+00:00 </h4>Its not pretty but it works. Give it up for the swiss army chainsaw.<h4> Comment by Kyle Strand, Score: 1, Id: 46643231, created_at: 2015-03-23 17:55:03+00:00 </h4>Why is <code>-pie</code> &quot;blasphemy,&quot; and why doesn&#39;t it behave the same as <code>-pi -e</code>? Anyone know?<h4> Comment by Nathan majicvr.com, Score: 0, Id: 110574386, created_at: 2020-06-23 00:17:25+00:00 </h4>@Ether <a href="http://www.paulgraham.com/say.html" rel="nofollow noreferrer">A fun read</a> about that<h4> Comment by m13r, Score: 0, Id: 74314384, created_at: 2017-04-26 11:46:34+00:00 </h4>This also turns <code>\r\n</code> to <code>\n</code><hr><h3>  Answer by mklement0, Id: 12148703, Score: 68, created_at: 2012-08-27 19:55:51+00:00 </h3><p>You can take advantage of the fact that <strong>shell <a href="http://pubs.opengroup.org/onlinepubs/009695399/utilities/xcu_chap02.html#tag_02_06_03" rel="noreferrer">command substitutions</a> remove trailing newline characters</strong>:</p>
<p>Simple form that works in bash, ksh, zsh:</p>
<pre><code>printf %s &quot;$(&lt; in.txt)&quot; &gt; out.txt
</code></pre>
<p>Portable (POSIX-compliant) alternative (slightly less efficient):</p>
<pre><code>printf %s &quot;$(cat in.txt)&quot; &gt; out.txt
</code></pre>
<p>Note:</p>
<ul>
<li><strong>If <code>in.txt</code> ends with <em>multiple</em> newline characters, the command substitution removes <em>all</em> of them</strong>.<sup>Thanks, <a href="https://stackoverflow.com/users/1944384/sparhawk">Sparhawk</a></sup> (It doesn't remove whitespace characters other than trailing newlines.)</li>
<li>Since this approach <strong>reads the entire input file into memory</strong>, it is only advisable for smaller files.</li>
<li><code>printf %s</code> ensures that no newline is appended to the output (it is the POSIX-compliant alternative to the nonstandard <code>echo -n</code>; see <a href="http://pubs.opengroup.org/onlinepubs/009696799/utilities/echo.html" rel="noreferrer">http://pubs.opengroup.org/onlinepubs/009696799/utilities/echo.html</a> and <a href="https://unix.stackexchange.com/a/65819">https://unix.stackexchange.com/a/65819</a>)</li>
</ul>
<hr />
<p>A <strong>guide to the other answers</strong>:</p>
<ul>
<li><p>If <strong>Perl</strong> is available, go for the <a href="https://stackoverflow.com/a/1654042/45375">accepted answer</a> - it is <strong>simple and memory-efficient</strong> (doesn't read the whole input file at once).</p>
</li>
<li><p>Otherwise, consider <a href="https://stackoverflow.com/a/1654115/45375">ghostdog74's <strong>Awk</strong> answer</a> - it's <strong>obscure, but also memory-efficient</strong>; a <strong>more readable equivalent</strong> (POSIX-compliant) is:</p>
</li>
<li><p><code>awk 'NR &gt; 1 { print prev } { prev=$0 } END { ORS=&quot;&quot;; print }' in.txt</code></p>
</li>
<li><p>Printing is delayed by one line so that the final line can be handled in the <code>END</code> block, where it is printed without a trailing <code>\n</code> due to setting the output-record separator (<code>OFS</code>) to an empty string.</p>
</li>
<li><p>If you want a <strong>verbose, but fast and robust solution that <em>truly edits in-place</em></strong> (as opposed to creating a temp. file that then replaces the original), consider <a href="https://stackoverflow.com/a/1658873/45375">jrockway's <strong>Perl script</strong></a>.</p>
</li>
</ul>
<hr><h3>  Answer by Thor, Id: 12579554, Score: 57, created_at: 2012-09-25 09:02:49+00:00 </h3><p>You can do this with <code>head</code> from GNU coreutils, it supports arguments that are relative to the end of the file. So to leave off the last byte use:</p>
<pre><code>head -c -1
</code></pre>
<p>To test for an ending newline you can use <code>tail</code> and <code>wc</code>. The following example saves the result to a temporary file and subsequently overwrites the original:</p>
<pre class="lang-sh prettyprint-override"><code>if [[ $(tail -c1 file | wc -l) == 1 ]]; then
  head -c -1 file &gt; file.tmp
  mv file.tmp file
fi
</code></pre>
<p>You could also use <code>sponge</code> from <code>moreutils</code> to do &quot;in-place&quot; editing:</p>
<pre class="lang-sh prettyprint-override"><code>[[ $(tail -c1 file | wc -l) == 1 ]] &amp;&amp; head -c -1 file | sponge file
</code></pre>
<hr />
<p>You can also make a general reusable function by stuffing this in your <code>.bashrc</code> file:</p>
<pre class="lang-sh prettyprint-override"><code># Example:  remove-last-newline &lt; multiline.txt
function remove-last-newline(){
    local file=$(mktemp)
    cat &gt; $file
    if [[ $(tail -c1 $file | wc -l) == 1 ]]; then
        head -c -1 $file &gt; $file.tmp
        mv $file.tmp $file
    fi
    cat $file
}
</code></pre>
<h3>Update</h3>
<p>As noted by <em>KarlWilbur</em> in the comments and used in <a href="https://stackoverflow.com/a/40569742/1331399"><em>Sorentar's</em> answer</a>, <code>truncate --size=-1</code> can replace <code>head -c-1</code> and supports in-place editing.</p>
<h4> Comment by Dakkaron, Score: 4, Id: 52997193, created_at: 2015-09-14 17:58:43+00:00 </h4>Best solution of all so far. Uses a standard tool that really every Linux distribution has, and is concise and clear, without any sed or perl wizardry.<h4> Comment by wisbucky, Score: 4, Id: 91044729, created_at: 2018-08-27 20:59:36+00:00 </h4>Note that <code>head -c -1</code> will remove the last character regardless if it is a newline or not, that&#39;s why you have to check whether the last character is a newline before you remove it.<h4> Comment by Karl Wilbur, Score: 3, Id: 82516641, created_at: 2017-12-12 16:56:31+00:00 </h4>Nice solution. One change is that I think I&#39;d use <code>truncate --size=-1</code> instead of <code>head -c -1</code> since it just resizes the input file rather than reading in the input file, writing it out to another file, then replacing the original with the output file.<h4> Comment by Edward Falk, Score: 1, Id: 107323408, created_at: 2020-03-12 20:03:58+00:00 </h4>Unfortunately does not work on Mac. I suspect it doesn&#39;t work on any BSD variant.<hr><h3>  Answer by Dennis Williamson, Id: 1654049, Score: 20, created_at: 2009-10-31 10:59:42+00:00 </h3><pre><code>head -n -1 abc &gt; newfile
tail -n 1 abc | tr -d '\n' &gt;&gt; newfile
</code></pre>

<p><s> Edit 2: </s></p>

<p><s>Here is an <code>awk</code> version <em>(corrected)</em> that doesn't accumulate a potentially huge array:</s></p>

<p><s>    awk '{if (line) print line; line=$0} END {printf $0}' abc</s></p>
<h4> Comment by rudimeier, Score: 2, Id: 22971582, created_at: 2013-04-18 18:10:35+00:00 </h4>Using -c instead of -n for head and tail should be even faster.<h4> Comment by ChrisV, Score: 1, Id: 34877100, created_at: 2014-04-04 11:09:20+00:00 </h4>For me, head -n -1 abc removed the last actual line of the file, leaving a trailing newline; head -c -1 abc seemed to work better<h4> Comment by BCoates, Score: 0, Id: 11344111, created_at: 2012-01-28 03:21:53+00:00 </h4>you can make the output a pipe with process substitution: <code>head -n -1 abc | cat &lt;(tail -n 1 abc | tr -d &#39;\n&#39;) | ...</code><h4> Comment by michael, Score: 0, Id: 93055002, created_at: 2018-10-31 08:06:36+00:00 </h4>just another variant on the &quot;one liner&quot; with <code>cat</code> examples show in the comments (no pipe necessary, using only process substitution, feel free to change the <code>head</code> or <code>tail</code> options as necessary): <code>cat &lt;(head -n -1 abc) &lt;(tail -n 1 abc | tr -d &#39;\n&#39;)</code><h4> Comment by Dennis Williamson, Score: 0, Id: 11348884, created_at: 2012-01-28 14:42:41+00:00 </h4>@BCoates: That doesn&#39;t do the same thing. Yours only gives the last line (without a newline). The OP wants the <i>whole</i> file with only the last newline removed. Your pipeline would work like this: <code>head -n -1 ifscomma &amp;&amp; cat &lt;(tail -n 1 ifscomma | tr -d &#39;\n&#39;)</code> or <code>head -n -1 ifscomma | cat - &lt;(tail -n 1 ifscomma | tr -d &#39;\n&#39;)</code>. In the latter one, the hyphen causes <code>cat</code> to concatenate what comes across the pipe with the output of the process substitution. Otherwise, the output of <code>head</code> would be ignored.<h4> Comment by Dennis Williamson, Score: 0, Id: 11354105, created_at: 2012-01-28 23:20:43+00:00 </h4>I forgot to edit the name of the file in my previous comment to change it from the test file I was using to the sample name &quot;abc&quot;: <code>s&#47;ifscomma&#47;abc&#47;g</code><h4> Comment by hese, Score: 0, Id: 13338381, created_at: 2012-04-27 15:23:51+00:00 </h4>This worked faster than the perl command on a 1MB file for me.  Great thanks!<h4> Comment by Todd Partridge &#39;Gen2ly&#39;, Score: 0, Id: 1525863, created_at: 2009-10-31 13:27:04+00:00 </h4>Good original way to think about it.  Thanks Dennis.<h4> Comment by Dennis Williamson, Score: 0, Id: 1527797, created_at: 2009-11-01 01:49:42+00:00 </h4>You are correct. I defer to your <code>awk</code> version. It takes <i>two</i> offsets (and a different test) and I only used one. However, you could use <code>printf</code> instead of <code>ORS</code>.<hr><h3>  Answer by ghostdog74, Id: 1654115, Score: 11, created_at: 2009-10-31 11:21:08+00:00 </h3><p>gawk</p>
<pre><code>awk '{q=p;p=$0}NR&gt;1{print q}END{ORS = &quot;&quot;; print p}' file
</code></pre>
<h4> Comment by Yevhen Pavliuk, Score: 1, Id: 23534790, created_at: 2013-05-07 08:35:04+00:00 </h4><code>awk &#39;{ prev_line = line; line = $0; } NR &gt; 1 { print prev_line; } END { ORS = &quot;&quot;; print line; }&#39; file</code> this should be easier to read.<h4> Comment by user8017719, Score: 0, Id: 68372775, created_at: 2016-11-12 21:58:07+00:00 </h4>How about: <code>awk &#39;NR&gt;1 {print p} {p=$0} END {printf $0}&#39; file</code>.<h4> Comment by Robin A. Meade, Score: 0, Id: 103054143, created_at: 2019-10-11 23:42:51+00:00 </h4>@sorontar The first argument to <code>printf</code> is the <i>format</i> argument. Thus if the input file had something that could be interpreted as a format specifier like <code>%d</code>, you&#39;d get an error. A fix would be to change it to <code>printf &quot;%s&quot; $0</code><h4> Comment by Todd Partridge &#39;Gen2ly&#39;, Score: 0, Id: 1525891, created_at: 2009-10-31 13:35:09+00:00 </h4>Still looks like a lot of characters to me... learning it slowly :).  Does the job though.  Thanks ghostdog.<hr><h3>  Answer by user8017719, Id: 40569742, Score: 9, created_at: 2016-11-13 01:55:16+00:00 </h3><p>A fast solution is using the gnu utility <code>truncate</code>:</p>

<pre><code>[ -z $(tail -c1 file) ] &amp;&amp; truncate -s-1 file
</code></pre>

<p>The test will be true if the file does have a trailing new line.</p>

<p>The removal is very fast, truly in place, no new file is needed and the search is also reading from the end just one byte (<code>tail -c1</code>).</p>
<h4> Comment by michael, Score: 2, Id: 93055268, created_at: 2018-10-31 08:17:12+00:00 </h4>it&#39;s just missing the trailing filename in the example, i.e., <code>[ -z $(tail -c1 filename) ] &amp;&amp; truncate -s -1 filename</code> (also, in reply to the other comment, the <code>truncate</code> command does not work with stdin, a filename is required)<h4> Comment by Brian Hannay, Score: 1, Id: 88225920, created_at: 2018-05-30 15:10:32+00:00 </h4>truncate: missing file operand<hr><h3>  Answer by anotheral, Id: 37823116, Score: 8, created_at: 2016-06-14 22:24:09+00:00 </h3><p>A very simple method for single-line files, requiring GNU echo from coreutils:</p>

<pre><code>/bin/echo -n $(cat $file)
</code></pre>
<h4> Comment by Thor, Score: 0, Id: 79821312, created_at: 2017-09-26 16:57:34+00:00 </h4>Also seems to work for multi-line files it the <code>$(...)</code> is  quoted<h4> Comment by user4401178, Score: 0, Id: 65413108, created_at: 2016-08-19 05:17:59+00:00 </h4>This is a decent way if it&#39;s not too expensive (repetitive).<h4> Comment by Chris Stryczynski, Score: 0, Id: 77357966, created_at: 2017-07-19 15:42:04+00:00 </h4>This has issues when <code>\n</code> is present. As it gets converted to a new line.<h4> Comment by michael, Score: 0, Id: 93055463, created_at: 2018-10-31 08:24:02+00:00 </h4>definitely need to quote that... <code>&#47;bin&#47;echo -n &quot;$(cat infile)&quot;</code>  Also, I&#39;m not sure what the max len of <code>echo</code> or the shell would be across os/shell versions/distros (I was just googling this &amp; it was a rabbit hole), so I&#39;m not sure how portable (or performant) it actually would be for anything other than small files -- but for small files, great.<hr><h3>  Answer by jrockway, Id: 1658873, Score: 7, created_at: 2009-11-02 00:12:36+00:00 </h3><p>If you want to do it right, you need something like this:</p>

<pre><code>use autodie qw(open sysseek sysread truncate);

my $file = shift;
open my $fh, '+&gt;&gt;', $file;
my $pos = tell $fh;
sysseek $fh, $pos - 1, 0;
sysread $fh, my $buf, 1 or die 'No data to read?';

if($buf eq "\n"){
    truncate $fh, $pos - 1;
}
</code></pre>

<p>We open the file for reading and appending; opening for appending means that we are already <code>seek</code>ed to the end of the file.  We then get the numerical position of the end of the file with <code>tell</code>.  We use that number to seek back one character, and then we read that one character.  If it's a newline, we truncate the file to the character before that newline, otherwise, we do nothing.</p>

<p>This runs in constant time and constant space for any input, and doesn't require any more disk space, either.</p>
<h4> Comment by ysth, Score: 2, Id: 1531661, created_at: 2009-11-02 04:47:44+00:00 </h4>but that has the disadvantage of not reseting ownership/permissions for the file...err, wait...<h4> Comment by mklement0, Score: 1, Id: 47194782, created_at: 2015-04-08 16:12:59+00:00 </h4>Verbose, but both fast and robust - seems to be the only <i>true</i> in-place file-editing answer here (and since it may not be obvious to everyone: this is a <i>Perl</i> script).<hr><h3>  Answer by steveha, Id: 1663283, Score: 6, created_at: 2009-11-02 19:49:40+00:00 </h3><p>Here is a nice, tidy Python solution.  I made no attempt to be terse here.</p>

<p>This modifies the file in-place, rather than making a copy of the file and stripping the newline from the last line of the copy.  If the file is large, this will be much faster than the Perl solution that was chosen as the best answer.</p>

<p>It truncates a file by two bytes if the last two bytes are CR/LF, or by one byte if the last byte is LF.  It does not attempt to modify the file if the last byte(s) are not (CR)LF.  It handles errors.  Tested in Python 2.6.</p>

<p>Put this in a file called "striplast" and <code>chmod +x striplast</code>.</p>

<pre><code>#!/usr/bin/python

# strip newline from last line of a file


import sys

def trunc(filename, new_len):
    try:
        # open with mode "append" so we have permission to modify
        # cannot open with mode "write" because that clobbers the file!
        f = open(filename, "ab")
        f.truncate(new_len)
        f.close()
    except IOError:
        print "cannot write to file:", filename
        sys.exit(2)

# get input argument
if len(sys.argv) == 2:
    filename = sys.argv[1]
else:
    filename = "--help"  # wrong number of arguments so print help

if filename == "--help" or filename == "-h" or filename == "/?":
    print "Usage: %s &lt;filename&gt;" % sys.argv[0]
    print "Strips a newline off the last line of a file."
    sys.exit(1)


try:
    # must have mode "b" (binary) to allow f.seek() with negative offset
    f = open(filename, "rb")
except IOError:
    print "file does not exist:", filename
    sys.exit(2)


SEEK_EOF = 2
f.seek(-2, SEEK_EOF)  # seek to two bytes before end of file

end_pos = f.tell()

line = f.read()
f.close()

if line.endswith("\r\n"):
    trunc(filename, end_pos)
elif line.endswith("\n"):
    trunc(filename, end_pos + 1)
</code></pre>

<p>P.S. In the spirit of "Perl golf", here's my shortest Python solution.  It slurps the whole file from standard input into memory, strips all newlines off the end, and writes the result to standard output.  Not as terse as the Perl; you just can't beat Perl for little tricky fast stuff like this.</p>

<p>Remove the "\n" from the call to <code>.rstrip()</code> and it will strip all white space from the end of the file, including multiple blank lines.</p>

<p>Put this into "slurp_and_chomp.py" and then run <code>python slurp_and_chomp.py &lt; inputfile &gt; outputfile</code>.</p>

<pre><code>import sys

sys.stdout.write(sys.stdin.read().rstrip("\n"))
</code></pre>
<h4> Comment by Denis Barmenkov, Score: 0, Id: 20760831, created_at: 2013-02-11 20:06:54+00:00 </h4>os.path.isfile() will tell you about file presence. Using try/except might catch a lot of different errors :)<hr><h3>  Answer by ysth, Id: 1656218, Score: 5, created_at: 2009-11-01 02:27:34+00:00 </h3><p>Yet another perl WTDI:</p>

<pre><code>perl -i -p0777we's/\n\z//' filename
</code></pre>
<hr><h3>  Answer by Sinan &#220;n&#252;r, Id: 1654040, Score: 3, created_at: 2009-10-31 10:54:49+00:00 </h3><pre>
$  perl -e 'local $/; $_ = &lt;>; s/\n$//; print' a-text-file.txt
</pre>

<p>See also <a href="https://stackoverflow.com/questions/1164925/match-any-character-including-newlines-in-sed">Match any character (including newlines) in sed</a>.</p>
<h4> Comment by Todd Partridge &#39;Gen2ly&#39;, Score: 0, Id: 1525623, created_at: 2009-10-31 11:47:22+00:00 </h4>This works good too, probably less blasphemous than paviums&#39;s.<h4> Comment by Dennis Williamson, Score: 1, Id: 1525502, created_at: 2009-10-31 11:03:41+00:00 </h4>That takes out all the newlines. Equivalent to <code>tr -d &#39;\n&#39;</code><h4> Comment by Rob Kennedy, Score: 0, Id: 1530149, created_at: 2009-11-01 20:45:12+00:00 </h4>Sinan, although Linux and Unix might define text files to end with a newline, Windows poses no such requirement. Notepad, for example, will write only the characters you type without adding anything extra at the end. C compilers might require a source file to end with a line break, but C source files aren&#39;t &quot;just&quot; text files, so they can have extra requirements.<h4> Comment by ysth, Score: 0, Id: 1531672, created_at: 2009-11-02 04:53:38+00:00 </h4>in that vein, most javascript/css minifiers will remove trailing newlines, and yet produce text files.<h4> Comment by Sinan &#220;n&#252;r, Score: 0, Id: 1532664, created_at: 2009-11-02 10:12:10+00:00 </h4>@Rob Kennedy and @ysth: There is an interesting argument there as to why such files are not actually text files and such.<hr><h3>  Answer by Vijay, Id: 15568555, Score: 3, created_at: 2013-03-22 10:54:29+00:00 </h3><pre><code>perl -pi -e 's/\n$// if(eof)' your_file
</code></pre>
<h4> Comment by mklement0, Score: 0, Id: 47193830, created_at: 2015-04-08 15:48:28+00:00 </h4>Effectively the same as the accepted answer, but arguably clearer in concept to non-Perl users. Note that there&#39;s no need for the <code>g</code> or the parentheses around <code>eof</code>: <code>perl -pi -e &#39;s&#47;\n$&#47;&#47; if eof&#39; your_file</code>.<hr><h3>  Answer by cpit, Id: 2759611, Score: 2, created_at: 2010-05-03 16:39:49+00:00 </h3><p>Using dd:</p>

<pre><code>file='/path/to/file'
[[ "$(tail -c 1 "${file}" | tr -dc '\n' | wc -c)" -eq 1 ]] &amp;&amp; \
    printf "" | dd  of="${file}" seek=$(($(stat -f "%z" "${file}") - 1)) bs=1 count=1
    #printf "" | dd  of="${file}" seek=$(($(wc -c &lt; "${file}") - 1)) bs=1 count=1
</code></pre>
<hr><h3>  Answer by LoranceStinson, Id: 2759674, Score: 2, created_at: 2010-05-03 16:50:30+00:00 </h3><p>Assuming Unix file type and you only want the last newline this works.</p>

<pre><code>sed -e '${/^$/d}'
</code></pre>

<p>It will not work on multiple newlines...</p>

<p><strong>*</strong> <em>Works only if the last line is a blank line.</em></p>
<h4> Comment by wisbucky, Score: 0, Id: 91046482, created_at: 2018-08-27 22:38:45+00:00 </h4>Here&#39;s a <code>sed</code> solution that works even for a non-blank last line: <a href="https://stackoverflow.com/a/52047796">stackoverflow.com/a/52047796</a><hr><h3>  Answer by wisbucky, Id: 52047796, Score: 2, created_at: 2018-08-27 22:36:32+00:00 </h3><p>This is a good solution if you need it to work with pipes/redirection instead of reading/output from or to a file. This works with single or multiple lines. It works whether there is a trailing newline or not.</p>

<pre><code># with trailing newline
echo -en 'foo\nbar\n' | sed '$s/$//' | head -c -1

# still works without trailing newline
echo -en 'foo\nbar' | sed '$s/$//' | head -c -1

# read from a file
sed '$s/$//' myfile.txt | head -c -1
</code></pre>

<p>Details:</p>

<ul>
<li><code>head -c -1</code> truncates the last character of the string, regardless of what the character is. So if the string does not end with a newline, then you would be losing a character.</li>
<li>So to address that problem, we add another command that will add a trailing newline if there isn't one: <code>sed '$s/$//'</code> . The first <code>$</code> means only apply the command to the last line. <code>s/$//</code> means substitute the "end of the line" with "nothing", which is basically doing nothing. But it has a side effect of adding a trailing newline is there isn't one.</li>
</ul>

<p>Note: Mac's default <code>head</code> does not support the <code>-c</code> option. You can do <code>brew install coreutils</code> and use <code>ghead</code> instead.</p>
<hr><h3>  Answer by Nicholas Wilson, Id: 10107400, Score: 1, created_at: 2012-04-11 13:55:09+00:00 </h3><p>Yet another answer FTR (and my favourite!): echo/cat the thing you want to strip and capture the output through backticks. The final newline will be stripped. For example:</p>

<pre><code># Sadly, outputs newline, and we have to feed the newline to sed to be portable
echo thingy | sed -e 's/thing/sill/'

# No newline! Happy.
out=`echo thingy | sed -e 's/thing/sill/'`
printf %s "$out"

# Similarly for files:
file=`cat file_ending_in_newline`
printf %s "$file" &gt; file_no_newline
</code></pre>
<h4> Comment by technosaurus, Score: 1, Id: 28170286, created_at: 2013-09-27 20:50:40+00:00 </h4>I found the cat-printf combo out by accident (was trying to get the opposite behavior).  Note that this will remove <i>ALL</i> trailing newlines, not just the last.<hr><h3>  Answer by peak, Id: 37302409, Score: 1, created_at: 2016-05-18 14:21:24+00:00 </h3><p>ruby:</p>

<pre><code>ruby -ne 'print $stdin.eof ? $_.strip : $_'
</code></pre>

<p>or:</p>

<pre><code>ruby -ane 'q=p;p=$_;puts q if $.&gt;1;END{print p.strip!}'
</code></pre>
<hr><h3>  Answer by Oleg Mazko, Id: 39142246, Score: 1, created_at: 2016-08-25 10:02:33+00:00 </h3><p>POSIX SED:</p>

<p><a href="http://sed.js.org/?gist=82a50915abacbaf9d36801d5ad3d9665" rel="nofollow">'${/^$/d}'</a></p>

<pre><code>$ - match last line


{ COMMANDS } - A group of commands may be enclosed between { and } characters. This is particularly useful when you want a group of commands to be triggered by a single address (or address-range) match.
</code></pre>
<h4> Comment by wisbucky, Score: 0, Id: 91045078, created_at: 2018-08-27 21:16:05+00:00 </h4>I think this will only remove it if the last line is blank. It will not remove the trailing newline if the last line is not blank. For example, <code>echo -en &#39;a\nb\n&#39; | sed &#39;${&#47;^$&#47;d}&#39;</code> will not remove anything. <code>echo -en &#39;a\nb\n\n&#39; | sed &#39;${&#47;^$&#47;d}&#39;</code> will remove since the entire last line is blank.<hr><h3>  Answer by dlamblin, Id: 1656988, Score: 0, created_at: 2009-11-01 11:57:11+00:00 </h3><p>The only time I've wanted to do this is for code golf, and then I've just copied my code out of the file and pasted it into an <code>echo -n 'content'&gt;file</code> statement.</p>
<h4> Comment by mklement0, Score: 0, Id: 16254136, created_at: 2012-08-27 19:58:23+00:00 </h4>Halfway there; complete approach <a href="http://stackoverflow.com/a/12148703/45375">here</a>.<hr><h3>  Answer by ghostdog74, Id: 2482346, Score: 0, created_at: 2010-03-20 07:47:47+00:00 </h3><pre><code>sed ':a;/^\n*$/{$d;N;};/\n$/ba' file
</code></pre>
<h4> Comment by mklement0, Score: 0, Id: 47193715, created_at: 2015-04-08 15:45:36+00:00 </h4>Works, but removes <i>all</i> trailing newlines.<hr><h3>  Answer by cadrian, Id: 11154296, Score: 0, created_at: 2012-06-22 10:17:19+00:00 </h3><p>I had a similar problem, but was working with a windows file and need to keep those CRLF -- my solution on linux:</p>

<pre><code>sed 's/\r//g' orig | awk '{if (NR&gt;1) printf("\r\n"); printf("%s",$0)}' &gt; tweaked
</code></pre>
<hr><h3>  Answer by NeronLeVelu, Id: 19769053, Score: 0, created_at: 2013-11-04 13:46:57+00:00 </h3><pre><code>sed -n "1 x;1 !H
$ {x;s/\n*$//p;}
" YourFile
</code></pre>

<p>Should remove any last occurence of \n in file. Not working on huge file (due to sed buffer limitation)</p>
<hr><h3>  Answer by lenny, Id: 72138792, Score: 0, created_at: 2022-05-06 08:56:27+00:00 </h3><p>Here's a simple solution that uses sed.
Your versions of sed needs to support the <code>-z</code> option.</p>
<pre><code>       -z, --null-data

              separate lines by NUL characters
</code></pre>
<p>It can either be used in a pipe or used to edit the file in place with the <code>-i</code> option</p>
<pre><code>sed -ze 's/\n$//' file
</code></pre>
