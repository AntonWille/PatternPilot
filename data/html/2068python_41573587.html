 <h2> Title: What is the difference between venv, pyvenv, pyenv, virtualenv, virtualenvwrapper, pipenv, etc? </h2> <h3> Flimm, question_id: 41573587 </h3>Score: 2068, Tags: {python,virtualenv,virtualenvwrapper,pyenv,python-venv} <br><p>Python 3.3 includes in its standard library the new package <code>venv</code>. What does it do, and how does it differ from all the other packages that match the regex <code>(py)?(v|virtual|pip)?env</code>?</p>
<h4> Comment 70352081 Flimm: </h4>And to preempt the close votes, I felt this was a more general question than <a href="http://stackoverflow.com/questions/29950300/what-is-the-relationship-between-virtualenv-and-pyenv" title="what is the relationship between virtualenv and pyenv">stackoverflow.com/questions/29950300/&hellip;</a> , and so I didn&#39;t feel comfortable editing that question or posting an overly general answer on that post.<br><h4> Comment 81650317 michael: </h4>This guide is both useful &amp; constantly updated as python continues to add more &amp; more &quot;one &amp; only one obvious way&quot; to do things:  <a href="http://docs.python-guide.org/en/latest/dev/virtualenvs/" rel="nofollow noreferrer">docs.python-guide.org/en/latest/dev/virtualenvs</a><br><h4> Comment 100398527 SwimBikeRun: </h4>I burned an entire day wasting time with pipenv. Bottom line, it’s overmarketed. Venv and virtualenv if you need py2 are the proper tools. Conda (miniconda if you don’t need the full stack) is also very good. Very good writeup: <a href="https://chriswarrick.com/blog/2018/07/17/pipenv-promises-a-lot-delivers-very-little/" rel="nofollow noreferrer">chriswarrick.com/blog/2018/07/17/&hellip;</a><br><h4> Comment 113616108 EntangledLoops: </h4>I think the accepted answer below has some unfortunate bias against <code>venv</code>, which is the correct tool to use going forward for Python 3. It should really be first on the list, followed by <code>virtualenv</code>. <a href="https://docs.python.org/3/library/venv.html" rel="nofollow noreferrer">docs.python.org/3/library/venv.html</a><br><h4> Comment 84018269 Kermit: </h4>As of 3.6 I found it easier to get virtualenv working in comparison to pyenv on macOS (I&#39;m a pyNoob)<br><h4> Comment 120660998 user5359531: </h4>avoid all of these problems and just use <code>conda</code> (Miniconda). Its better than all the solutions listed here and makes them all obselete. As a bonus, it works with more than just Python, you can install a wide variety of software with it, not just Python packages. It includes an installation of <code>pip</code> so all your <code>pip install</code>&#39;s will continue to work as normal. With <code>conda</code> you can install an entire app software stack such as specific versions of Django, Gunicorn, Celery, PostgreSQL, RabbitMQ, nginx, Java, R, etc. all at the same time.<br><h4> Comment 102849118 offchan: </h4>I don&#39;t want to be overwhelmed so I use Anaconda<br><h4> Comment 84271014 Flimm: </h4>@HashRocketSyntax <code>virtualenv</code> and <code>pyenv</code> do not perform the same function, and are not alternatives to each other. See my answer.<br><h4> Comment 129162865 Rich Lysakowski PhD: </h4>I use conda whenever possible, because it offers a much smaller &quot;confusion surface&quot;, i.e., number of py-pip packages to understand and contend with.  I always install pip inside my conda environments and then let conda manage and index all the pip packages that do not (yet) have conda-formatted packages.  I try to ignore all the pip-xxx and pyenv-xxx variants... the endless variations make my head spin.  I wish all Python package developers would go the final mile and instead learn to build conda packages from pip-formatted packages, to help make the Python package confusion surface smaller.<br><h4> Comment 126484810 odigity: </h4>Not as up-to-date as needed for our purposes here, unfortunately:  <a href="https://github.com/realpython/python-guide/issues/529" rel="nofollow noreferrer">github.com/realpython/python-guide/issues/529</a><br><h4> Comment 126485010 odigity: </h4>Would be nice to see <code>pip-tools</code> added to this guide.<br>------------------------------------------------------------------ <br><h3> Answer 41573588 Flimm: </h3><p><strong>This is my personal recommendation for beginners:</strong> start by learning <a href="https://pypi.org/project/virtualenv/" rel="noreferrer"><code>virtualenv</code></a> and <a href="https://pypi.org/project/pip/" rel="noreferrer"><code>pip</code></a>, tools which work with both Python 2 and 3 and in a variety of situations, and pick up other tools once you start needing them.</p>
<p>Now on to answer the question: what is the difference between these similarly named things: venv, virtualenv, etc?</p>
<h1>PyPI packages not in the standard library:</h1>
<ul>
<li><p><strong><a href="https://pypi.python.org/pypi/virtualenv" rel="noreferrer"><code>virtualenv</code></a></strong> is a very popular tool that creates isolated Python environments for Python libraries. If you're not familiar with this tool, I highly recommend learning it, as it is a very useful tool.</p>
<p>It works by installing a bunch of files in a directory (eg: <code>env/</code>), and then modifying the <code>PATH</code> environment variable to prefix it with a custom <code>bin</code> directory (eg: <code>env/bin/</code>). An exact copy of the <code>python</code> or <code>python3</code> binary is placed in this directory, but Python is programmed to look for libraries relative to its path first, in the environment directory. It's not part of Python's standard library, but is officially blessed by the PyPA (Python Packaging Authority). Once activated, you can install packages in the virtual environment using <code>pip</code>.</p>
</li>
<li><p><strong><a href="https://github.com/pyenv/pyenv" rel="noreferrer"><code>pyenv</code></a></strong> is used to isolate Python versions. For example, you may want to test your code against Python 2.7, 3.6, 3.7 and 3.8, so you'll need a way to switch between them. Once activated, it prefixes the <code>PATH</code> environment variable with <code>~/.pyenv/shims</code>, where there are special files matching the Python commands (<code>python</code>, <code>pip</code>). These are not copies of the Python-shipped commands; they are special scripts that decide on the fly which version of Python to run based on the <code>PYENV_VERSION</code> environment variable, or the <code>.python-version</code> file, or the <code>~/.pyenv/version</code> file. <code>pyenv</code> also makes the process of downloading and installing multiple Python versions easier, using the command <code>pyenv install</code>.</p>
</li>
<li><p><strong><a href="https://github.com/pyenv/pyenv-virtualenv" rel="noreferrer"><code>pyenv-virtualenv</code></a></strong> is a plugin for <code>pyenv</code> by the same author as <code>pyenv</code>, to allow you to use <code>pyenv</code> and <code>virtualenv</code> at the same time conveniently. However, if you're using Python 3.3 or later, <code>pyenv-virtualenv</code> will try to run <code>python -m venv</code> if it is available, instead of <code>virtualenv</code>. You can use <code>virtualenv</code> and <code>pyenv</code> together without <code>pyenv-virtualenv</code>, if you don't want the convenience features.</p>
</li>
<li><p><strong><a href="https://pypi.python.org/pypi/virtualenvwrapper" rel="noreferrer"><code>virtualenvwrapper</code></a></strong> is a set of extensions to <code>virtualenv</code> (see <a href="http://virtualenvwrapper.readthedocs.io/en/latest/" rel="noreferrer">docs</a>). It gives you commands like <code>mkvirtualenv</code>, <code>lssitepackages</code>, and especially <code>workon</code> for switching between different <code>virtualenv</code> directories. This tool is especially useful if you want multiple <code>virtualenv</code> directories.</p>
</li>
<li><p><strong><a href="https://github.com/pyenv/pyenv-virtualenvwrapper" rel="noreferrer"><code>pyenv-virtualenvwrapper</code></a></strong> is a plugin for <code>pyenv</code> by the same author as <code>pyenv</code>, to conveniently integrate <code>virtualenvwrapper</code> into <code>pyenv</code>.</p>
</li>
<li><p><strong><a href="https://pypi.python.org/pypi/pipenv" rel="noreferrer"><code>pipenv</code></a></strong> aims to combine <code>Pipfile</code>, <code>pip</code> and <code>virtualenv</code> into one command on the command-line. The <code>virtualenv</code> directory typically gets placed in <code>~/.local/share/virtualenvs/XXX</code>, with <code>XXX</code> being a hash of the path of the project directory. This is different from <code>virtualenv</code>, where the directory is typically in the current working directory. <code>pipenv</code> is meant to be used when developing Python applications (as opposed to libraries). There are alternatives to <code>pipenv</code>, such as <code>poetry</code>, which I won't list here since this question is only about the packages that are similarly named.</p>
</li>
</ul>
<h1>Standard library:</h1>
<ul>
<li><p><strong><code>pyvenv</code></strong> (not to be confused with <strong><a href="https://github.com/pyenv/pyenv" rel="noreferrer"><code>pyenv</code></a></strong> in the previous section) is a script shipped with Python 3.3 to 3.7. It was <a href="https://docs.python.org/3/whatsnew/3.8.html#api-and-feature-removals" rel="noreferrer">removed from Python 3.8</a> as it had problems (not to mention the confusing name). Running <code>python3 -m venv</code> has exactly the same effect as <code>pyvenv</code>.</p>
</li>
<li><p><strong><a href="https://docs.python.org/3/library/venv.html" rel="noreferrer"><code>venv</code></a></strong> is a package shipped with Python 3, which you can run using <code>python3 -m venv</code> (although for some reason some distros separate it out into a separate distro package, such as <code>python3-venv</code> on Ubuntu/Debian). It serves the same purpose as <code>virtualenv</code>, but only has a subset of its features (<a href="https://virtualenv.pypa.io/en/latest/" rel="noreferrer">see a comparison here</a>). <code>virtualenv</code> continues to be more popular than <code>venv</code>, especially since the former supports both Python 2 and 3.</p>
</li>
</ul>
<h4> Comment 73726593 Jerry101: </h4>This is very helpful! So why are there 8 tangled things instead of 1? (“There should be one – and preferably only one – obvious way to do it.” -- The Zen of Python)<br><h4> Comment 74964971 Magnus Lind Oxlund: </h4>@Jerry101, the introduction of venv is in part a response to that mess. If you want to help improve the situation, I suggest you use venv and encourage others to do the same.<br><h4> Comment 75397366 Kris: </h4>&quot;the introduction of venv is in part a response to that mess&quot; How come when there are too many things that do &#39;something like X&#39;, people always think they can improve that mess by making an other thing that does &#39;something like X&#39;. Its kind of funny actually. We are now 4 years later... so may be pertinent to ask, did <code>venv</code> actually solve that problem?<br><h4> Comment 75504467 Magnus Lind Oxlund: </h4>The only two tools on the list that truly cover what is arguably the same territory are virtualenv and venv, so the characterization that we&#39;re dealing with a mess caused by several competing tools is not very precise.  The list does, however, consist of several virtual environment-related tools, all with similar-sounding names. That can be confusing, especially to users who are just learning about them.  Did venv improve the situation? It did offer a more light-weight alternative to other virtual environment tools, benefiting from native modifications and a spot in the standard library. …<br><h4> Comment 135759907 Kris: </h4>@KarlKnechtel Well... ideally when there are n tools doing X... especially in an open-source world... it would be better to try and effect change on (one of) those tools to make them (it) better than make yet another tool that is inevitably just going to be broken in another way. But yeah... working with other people to try to fix what already exists can be hard.<br><h4> Comment 131802750 t3chb0t: </h4>@Kris <i>We are now 4 years later... so may be pertinent to ask, did venv actually solve that problem?</i> - it didn&#39;t as it still requires some magic batches to <i>activate</i> an environment. I should be able to use an environment without these kind of workarounds. That&#39;s why I never use any environments, but clone the entire python installation an use this as this is the only way to run scripts and not having to care about how do I properly activate anything. As long as <i>activation</i> is necessery, the issue is not solved.<br><h4> Comment 120443809 azec-pdx: </h4>@MagnusLindOxlund - I feel the pain, but I would argue that clusterization of the tools listed in the answer is further possible to those that let you manage: (1) Python virtual environments, (2)Python packages, (3) Python versions and (4) Convenience tools that make (1) and (2) more user-friendly.  I am curious if there is equivalent question/answer on StackOverflow that discusses <code>pip</code> vs. <code>pipx</code> vs. <code>poetry</code> vs. <code>setuptools</code> ... etc.<br><h4> Comment 131846114 E. K&#246;rner: </h4>@t3chb0t How? And how can you ensure a clean &quot;environment&quot; (python binaries + site-packages + .local)? This seems even more effort than simply using the <code>venv</code> module. In the case of duplicating your python environment, you can use a slim python docker image and install all dependencies <i>globally</i>. The startup is a bit more involved for simply running a script but at least python and the dependencies are encapsulated. This is also good for reproducibility etc.<br><h4> Comment 131847577 t3chb0t: </h4>@E.K&#246;rner I clone the entire python installation folder and use this as an environment. I then run scripts by simply calling <code>some\path\python.exe myapp.py</code> and it automatically picks everything up without any activation magic. I don&#39;t like venv, it&#39;s also voodoo. Having a clean installation with the required packages is much eaiser to use than relying on yet another environment framework.<br><h4> Comment 132149839 toolforger: </h4>@t3chb0t I fear no solution will satisfy you, as you somehow have to select what version of Python and libraries you want.<br><h4> Comment 134277371 Johan: </h4>@Flimm would it make sense to compare the use of these different softwares for handling environments with the user of different <a href="https://unix.stackexchange.com/q/743501/530603">container</a> softwares i.e. Docker and Podman?<br><h4> Comment 135720239 Karl Knechtel: </h4>@Kris &quot;How come when there are too many things that do &#39;something like X&#39;, people always think they can improve that mess by making an other thing that does &#39;something like X&#39;.&quot; - well... what <b>other</b> attempts are possible? It&#39;s not as if you can <b>prevent others</b> from using N-1 of the existing tools.<br>------------------------------------------------------------------ <br><h3> Answer 47559925 Rian Rizvi: </h3><p>I would just avoid the use of <code>virtualenv</code> after Python3.3+ and instead use the standard shipped library <code>venv</code>. To create a new virtual environment you would type:</p>
<pre><code>$ python3 -m venv &lt;MYVENV&gt;  
</code></pre>
<p><code>virtualenv</code> tries to copy the Python binary into the virtual environment's bin directory. However it does not update library file links embedded into that binary, so if you build Python from source into a non-system directory with relative path names, the Python binary breaks. Since this is how you make a copy distributable Python, it is a big flaw. BTW to inspect embedded library file links on OS X, use <code>otool</code>. For example from within your virtual environment, type:</p>
<pre><code>$ otool -L bin/python
python:
    @executable_path/../Python (compatibility version 3.4.0, current version 3.4.0)
    /usr/lib/libSystem.B.dylib (compatibility version 1.0.0, current version 1238.0.0)
</code></pre>
<p>Consequently I would avoid <code>virtualenvwrapper</code> and <code>pipenv</code>. <code>pyvenv</code> is deprecated. <code>pyenv</code> seems to be used often where <code>virtualenv</code> is used but I would stay away from it also since I think <code>venv</code> also does what <code>pyenv</code> is built for.</p>
<p><code>venv</code> creates virtual environments in the shell that are <strong>fresh</strong> and <strong>sandboxed</strong>, with <strong>user-installable libraries</strong>, and it's <strong>multi-python safe</strong>.</p>
<p><strong>Fresh</strong>: because virtual environments only start with the standard libraries that ship with python, you have to install any other libraries all over again with <code>pip install</code> while the virtual environment is active.</p>
<p><strong>Sandboxed</strong>: because none of these new library installs are visible outside the virtual environment, so you can delete the whole environment and start again without worrying about impacting your base python install.</p>
<p><strong>User-installable libraries</strong>: because the virtual environment's target folder is created without <code>sudo</code> in some directory you already own, so you won't need <code>sudo</code> permissions to install libraries into it.</p>
<p><strong>multi-python safe</strong>: because when virtual environments activate, the shell only sees the python version (3.4, 3.5 etc.) that was used to build that virtual environment.</p>
<p><code>pyenv</code> is similar to <code>venv</code> in that it lets you manage multiple python environments. However with <code>pyenv</code> you can't conveniently rollback library installs to some start state and you will likely need <code>admin</code> privileges at some point to update libraries. So I think it is also best to use <code>venv</code>.</p>
<p>In the last couple of years I have found many problems in build systems (emacs packages, python standalone application builders, installers...) that ultimately come down to issues with <code>virtualenv</code>. I think python will be a better platform when we eliminate this additional option and only use <code>venv</code>.</p>
<p>EDIT: Tweet of the BDFL,</p>
<blockquote>
<p>I use venv (in the stdlib) and a bunch of shell aliases to quickly switch.</p>
<p>— Guido van Rossum (@gvanrossum) <a href="https://twitter.com/gvanrossum/status/1319328122618048514" rel="noreferrer">October 22, 2020</a></p>
</blockquote>
<h4> Comment 120443853 azec-pdx: </h4>Great answer @RiazRizvi and it provides many insights in parallel to accepted answer. However, I would argue that <code>pyenv</code> still has it&#39;s place under the sun despite <code>venv</code> getting traction for virtual environments. The classic reason I can think of still using <code>pyenv</code> right now in my workflows is that highest Python runtime that AWS Lambda supports is 3.8 and Python 3.9 being out I want other non-Lambda projects to be 3.9 based. So I still need <code>pyenv</code> to switch between versions. Using <code>pyenv-virtualenv</code> allows users to use both <code>pyenv</code> and <code>venv</code> (not `virtualenv) together.<br><h4> Comment 124002375 soMuchToLearnAndShare: </h4>@riaz rizvi Multi python safe: how do you creat virtual environment for different python versions? I thought it always defaults to the python (system wide installed) version that is used to create the venv<br><h4> Comment 124019632 Rian Rizvi: </h4>somuchtolearnandshare - make the explicit call to the python you want to use - <code>$ path&#47;to&#47;python3x -m venv &lt;MYVENVx&gt; </code> or <code>$ path&#47;to&#47;python3y -m venv &lt;MYVENVy&gt; </code> then when you activate the environment you will activate the python that was used to create the environment<br><h4> Comment 124729688 Rian Rizvi: </h4>Conda is a wrapper around virtualenv, so all the drawbacks to virtualenv apply to Conda. However Conda does verify the packages they support, so while it only provides a subset of all Python packages, for data science especially, they have most of what you need. I would say for Windows only users who tend to be weak on the command line, Conda is a safe bet, especially data scientists. But if you want full clarity of your environment, to deploy solutions to customers for example, and you want full access to all the latest packages, stick with pip which has as much support as Python proper.<br><h4> Comment 123973631 user32882: </h4>what&#39;s wrong with <code>virtualenvwrapper</code>?<br><h4> Comment 124640643 Rich Lysakowski PhD: </h4>@Edison , I use conda directly most of the time, unless I am being lazy (then I might use Anaconda Navigator).  If I have damaged a conda environment inadvertently by using pip interleaved with conda installation commands, then I will use conda to rollback to an earlier conda environment revision (see conda list --revisions) or use conda to remove the environment after exporting the environment.yaml file.  I use Spyder, JupyterLab, VSCode, and PyCharm (in that order depending on the simplicity of what I am working on).  Simpler is better.  VSCode + plugins is a good full function IDE.<br><h4> Comment 124671053 Edison: </h4>@RichLysakowskiPhD Thanks. Why do you have Spyder/PyCharm? Is there something VSCode cannot do? p.s. Why do people want to use full-blown version of Anaconda? Why would someone choose Anaconda over Miniconda? Mamba is full C++ rewrite of Conda so apparently we should be using that. What do you think? What&#39;s your opinion on JupyterLab vs Colab? Stick with JupyterLab unless you need GPU/TPU? But I like the idea of everything in the cloud. Easy access, sharing etc.<br><h4> Comment 124422536 Rich Lysakowski PhD: </h4>Avoid ALL pip virtual environments whenever possible. Use conda instead. Conda provides a unified approach. It is maintained by teams of professional open source developers and has a reputable company providing funding and a commercially supported version. The teams that maintain pip, venv, virtualenv, pipenv, and many other pip variants have limited resources by comparison. The pip virtual environment plurality is frustrating for beginners. Use pip virtual environments and their (too) many variants as a last resort when conda packages do not exist.<br><h4> Comment 124627779 Edison: </h4>@RichLysakowskiPhD Do you recommend anaconda, miniconda or even better yet, mamba? And not that it matters, but I&#39;m curious, what IDE and text editor do you use? Would you consider VS Code with extensions to be an IDE now or still just a text editor? Or do you do everything in colab/jupyterlab? Peace.<br>------------------------------------------------------------------ <br><h3> Answer 59923461 F1Linux: </h3><h2>UPDATE 2020-08-25:</h2>
<p><em><strong>Added below &quot;<em><strong>Conclusion</strong></em>&quot; paragraph</strong></em></p>
<p>I've went down the <code>pipenv</code> rabbit hole (<em>it's a deep and dark hole indeed...</em>) and <em><strong>since the last answer is over 2 years ago</strong></em>, felt it was useful to update the discussion with the latest developments on the Python virtual envelopes topic I've found.</p>
<h2>DISCLAIMER:</h2>
<p><em>This answer is <strong>NOT</strong> about continuing the raging debate about the merits of <em><strong>pipenv</strong></em> <em>versus</em> <em><strong>venv</strong></em> as envelope solutions- <em>I make no endorsement of either</em>. It's about <em><strong>PyPA</strong></em> endorsing conflicting standards and how future development of <em><strong>virtualenv</strong></em> promises to negate making an <em><strong>either/or</strong></em> choice between them at all. I focused on these two tools precisely because they are the anointed ones by <em><strong>PyPA</strong></em>.</em></p>
<hr />
<h2>venv</h2>
<p>As the OP notes, <em><strong>venv</strong></em> is a tool for virtualizing environments. <em><strong>NOT</strong></em> a third party solution, but native tool. <em><strong>PyPA</strong></em> endorses <em><strong>venv</strong></em> for creating <strong>VIRTUAL ENVELOPES</strong>: &quot;<a href="https://docs.python.org/3/library/venv.html" rel="nofollow noreferrer">Changed in version 3.5: The use of venv is now recommended for creating virtual environments</a>&quot;.</p>
<h2>pipenv</h2>
<p><em><strong>pipenv</strong></em>- like <em><strong>venv</strong></em> - can be used to create virtual envelopes but additionally rolls-in package management and <a href="https://pipenv-fork.readthedocs.io/en/latest/advanced.html#detection-of-security-vulnerabilities" rel="nofollow noreferrer">vulnerability checking</a> functionality. Instead of using <code>requirements.txt</code>, <code>pipenv</code> delivers package management via <a href="https://github.com/pypa/pipfile" rel="nofollow noreferrer">Pipfile</a>.  As <a href="https://packaging.python.org/guides/tool-recommendations/" rel="nofollow noreferrer"><em><strong>PyPA</strong></em> endorses pipenv for <strong>PACKAGE MANAGEMENT</strong></a>, that would seem to imply <code>pipfile</code> is to supplant <code>requirements.txt</code>.</p>
<p><strong>HOWEVER</strong>: <em><strong>pipenv</strong></em> uses <em><strong>virtualenv</strong></em> as its tool for creating virtual envelopes, <strong>NOT</strong> <em><strong>venv</strong></em> which is endorsed by <em><strong>PyPA</strong></em> as the go-to tool for creating virtual envelopes.</p>
<h2>Conflicting Standards:</h2>
<p>So if settling on a virtual envelope solution wasn't difficult enough, we now have <em><strong>PyPA</strong></em> endorsing two different tools which use different virtual envelope solutions. The raging Github debate on <em><strong>venv vs virtualenv</strong></em> which highlights this conflict can be found <a href="https://github.com/pypa/pipenv/issues/15" rel="nofollow noreferrer">here</a>.</p>
<h2>Conflict Resolution:</h2>
<p>The Github debate referenced in above link has steered <em><strong>virtualenv</strong></em> development in the direction of accommodating <em><strong>venv</strong></em> in <a href="https://github.com/pypa/virtualenv/issues/1366" rel="nofollow noreferrer">future releases</a>:</p>
<blockquote>
<p>prefer built-in venv: if the target python has venv we'll create the
environment using that (and then perform subsequent operations on that
to facilitate other guarantees we offer)</p>
</blockquote>
<hr />
<h2>Conclusion:</h2>
<p>So it looks like there will be some future convergence between the two rival virtual envelope solutions, but as of now <em><strong>pipenv</strong></em>- which uses <code>virtualenv</code> - varies materially from <code>venv</code>.</p>
<p>Given <a href="https://realpython.com/pipenv-guide/#problems-that-pipenv-solves" rel="nofollow noreferrer">the problems <em><strong>pipenv</strong></em> solves</a> and the fact that <em><strong>PyPA</strong></em> has given its blessing, it <em><strong>appears</strong></em> to have a bright future. And if <em><strong>virtualenv</strong></em> delivers on its proposed development objectives, choosing a virtual envelope solution should no longer be a case of either <em><strong>pipenv</strong></em> OR <em><strong>venv</strong></em>.</p>
<h2>Update 2020-08-25:</h2>
<p>An oft repeated criticism of <em><strong>Pipenv</strong></em> I saw when producing this analysis was that it was not actively maintained. Indeed, what's the point of using a solution whose future could be seen questionable due to lack of continuous development? After a dry spell of about 18 months, <em><strong>Pipenv</strong></em> is once again being actively developed. Indeed, large and material updates have since been <a href="https://pipenv.pypa.io/en/latest/changelog/" rel="nofollow noreferrer">released</a>.</p>
<h4> Comment 120268224 naught101: </h4>And what about pyenv? This is a good answer, because it looks at future directions, but it&#39;s not clear how it interacts with pyenv or conda or other environment mamagers<br><h4> Comment 136701467 Rich Lysakowski PhD: </h4>@icedwater I think you meant to say &quot;Anaconda&quot; provides an excellent paid service.  &quot;conda&quot; is the environment and package manager that is free and open source maintained by the open source community.   &quot;Anaconda&quot; offers their FREE Python distro to non-commercial or SME users and also offers the paid Python distro &amp; services for enterprises.    And now Mamba foundation provides Mamba-forge, which is a much faster 100% conda command-compatible command line tool written in C++ that gives better reporting on its progress than either conda or venv.<br><h4> Comment 136577862 icedwater: </h4>@RichLysakowskiPhD conda provides an excellent paid service on top of the foundation built by unpaid volunteers. Recommend conda if you wish, it is good at what it does, but I&#39;d recommend being comfortable without it as well in case one needs to switch away for whatever reason.<br><h4> Comment 127166858 Flimm: </h4>@naught101 <code>pyenv</code> is not an alternative to <code>virtualenv</code>. And neither of those things are alternatives to <code>pipenv</code>. They do different things. Just like Django, Python and PostgreSQL are different things.<br><h4> Comment 127185341 naught101: </h4>@Flimm: different how?<br><h4> Comment 127218890 Flimm: </h4>@naught101 See the other answers for this question post (including my own).<br>------------------------------------------------------------------ <br><h3> Answer 65854168 Lie Ryan: </h3><p>Let's start with the problems these tools want to solve:</p>
<div class="s-table-container">
<table class="s-table">
<thead>
<tr>
<th>use case</th>
<th>solution</th>
</tr>
</thead>
<tbody>
<tr>
<td>My system package manager don't have the Python versions I wanted or I want to install multiple Python versions side by side, Python 3.9.0 and Python 3.9.1, Python 3.5.3, etc</td>
<td>Then use pyenv.</td>
</tr>
<tr>
<td>I want to install and run multiple applications with different, conflicting dependencies.</td>
<td>Then use virtualenv or venv. These are almost completely interchangeable, the difference being that virtualenv supports older python versions and has a few more minor unique features, while venv is in the standard library.</td>
</tr>
<tr>
<td>I'm developing an /application/ and need to manage my dependencies, and manage the dependency resolution of the dependencies of my project.</td>
<td>Then use pipenv or poetry.</td>
</tr>
<tr>
<td>I'm developing a /library/ or a /package/ and want to specify the dependencies that my library users need to install</td>
<td>Then use setuptools.</td>
</tr>
<tr>
<td>I used virtualenv, but I don't like virtualenv folders being scattered around various project folders. I want a centralised management of the environments and some simple project management</td>
<td>Then use virtualenvwrapper. Variant: pyenv-virtualenvwrapper if you also use pyenv.</td>
</tr>
</tbody>
</table>
</div>
<p><strong>Not recommended</strong></p>
<ul>
<li><strong><a href="https://pypi.org/project/pyvenv/#history" rel="noreferrer"><code>pyvenv</code></a></strong> (!=<a href="https://pypi.org/project/pipenv/" rel="noreferrer"><code>pipenv</code></a> &amp; !=<a href="https://pypi.org/project/pyenv/#history" rel="noreferrer"><code>pyenv</code></a>). This is deprecated, use venv or virtualenv instead.</li>
</ul>
<h4> Comment 120268240 naught101: </h4>What about Conda? Would you recommend against it entirely? And what information would you use to decide between pipenv and poetry?<br><h4> Comment 124004185 Lie Ryan: </h4>pipenv/poetry used two file workflow for managing dependencies. First file specifies the logical dependency, and the second file is a dependency lock file that&#39;s automatically generated by pipenv/poetry. requirements.txt is kinda a mix of the two file, which is simpler, but not having separate lock file makes it less flexible and harder to maintain the dependency list.<br><h4> Comment 130833994 Lie Ryan: </h4>@StefanSchmidt: virtualenvwrapper is just a bunch of very simple shell script, it is built on very stable grounds as the features it depends on for the shell scripting and Python are unlikely to ever change, so it still works just fine and will likely continue to work to eternity. There&#39;s really little reason for it to change, and little need to worry about the slow pace changes in the source repository.<br><h4> Comment 124086189 Lie Ryan: </h4>@soMuchToLearnAndShare venv is available in the standard library and that&#39;s a major benefit over virtualenv. I don&#39;t want to put words over PyPA mouth, but virtualenv does have a couple extra features that venv doesn&#39;t, and it works across larger range of Python versions. If you need the additional features that virtualenv provides over venv, then you obviously should use virtualenv. If you&#39;re satisfied with your current setup with venv, then there&#39;s no reason to choose virtualenv.<br><h4> Comment 124086280 Lie Ryan: </h4>@soMuchToLearnAndShare but there&#39;s no reason to avoid virtualenv either if you don&#39;t mind the additional install. If you want to use pipenv, then it only supports virtualenv. There&#39;s no reason to avoid pipenv just because it uses virtualenv, especially as using pipenv already means that you need additional install anyway. At the end of the day, the environment directory created by virtualenv and venv are nearly identical, so your choice of virtual environment tool mostly only matter when creating the environment and not so much when using it.<br><h4> Comment 124004222 Lie Ryan: </h4>@soMuchToLearnAndShare pipenv is built on top of virtualenv/venv, so you always use them together. Pipenv adds a number of higher level features than virtualenv, namely dependency management. Virtualenv doesn&#39;t manage dependencies, all it does is provide isolated environment to install dependencies.<br><h4> Comment 124066981 soMuchToLearnAndShare: </h4>Hi @Lie Ryan, <code>HOWEVER: pipenv uses virtualenv as its tool for creating virtual envelopes, NOT venv which is endorsed by PyPA as the go-to tool for creating virtual envelopes.</code> from @F1Linux made me understand i should not use pipenv since venv is the recommended one. Am i wrong? meaning, it is better to use <code>pyenv</code>(for python version management) + <code>venv</code> + <code>requirements.txt</code> for a python application.<br><h4> Comment 124086157 Lie Ryan: </h4>pipenv and virtualenv/venv do completely different things. They are not interchangeable.<br><h4> Comment 136863802 David Leal: </h4>Interesting topic, I need to configure my new Mac to use Python for machine learning purposes. It is a mess how may options we have. I am trying to follow the recommendations from this <a href="https://opensource.com/article/19/5/python-3-default-mac" rel="nofollow noreferrer">article1</a> and this one <a href="https://opensource.com/article/19/6/python-virtual-environments-mac" rel="nofollow noreferrer">article2</a> but now I am really confused with the correct setup for the virtual environments and with the ideas from this SO question. Any good reference where to go to have it setup following best practices for mac. I would like to do it correctly from scratch.<br><h4> Comment 124422538 Rich Lysakowski PhD: </h4>Avoid ALL pip virtual environments whenever possible. Use conda instead. Conda provides a unified approach. It is maintained by teams of professional open source developers and has a reputable company providing funding and a commercially supported version. The teams that maintain pip, venv, virtualenv, pipenv, and many other pip variants have limited resources by comparison. The pip virtual environment plurality is frustrating for beginners. Use pip virtual environments and their (too) many variants as a last resort when conda packages do not exist.<br><h4> Comment 130786383 Stefan Schmidt: </h4><code>virtualenvwrapper</code> does not seem to be very actively maintained. The latest release on <a href="https://pypi.org/project/virtualenvwrapper/" rel="nofollow noreferrer">PyPi</a> currently is from early 2019, compatibility is listed for up to Python 3.6 and commits to the <a href="https://bitbucket.org/virtualenvwrapper/virtualenvwrapper/commits/" rel="nofollow noreferrer">source repository</a> are very infrequent.<br><h4> Comment 130872507 Stefan Schmidt: </h4>@LieRyan Thanks for your feedback! I gave <code>virtualenvwrapper </code> and <code>pyenv-virtualenvwrapper </code> a try. As far as I can see without doing extensive testing, despite the lack of recent updates they indeed both seem to work with Python 3.10.8.<br><h4> Comment 124002570 soMuchToLearnAndShare: </h4>@lie Ryan <code>I&#39;m developing an &#47;application&#47; and need to manage my dependencies, and manage the dependency resolution of the dependencies of my project.  Then use pipenv or poetry.</code> &gt; is this something similar to <code>requirements </code> file? What use case/problem would one use <code>venv</code> and <code>pipenv</code> together?<br>------------------------------------------------------------------ <br><h3> Answer 61981596 ArnuldOnData: </h3><p><strong>Jan 2020 Update</strong></p>
<p>@Flimm has explained all the differences very well. Generally, we want to know the difference between all tools because we want to decide what's best for us. So, the next question would be: which one to use? I suggest you choose one of the two official ways to manage virtual environments:</p>
<ul>
<li>Python Packaging now <a href="https://packaging.python.org/tutorials/managing-dependencies/" rel="noreferrer">recommends Pipenv</a></li>
<li>Python.org now <a href="https://docs.python.org/3/library/venv.html" rel="noreferrer">recommends venv</a></li>
</ul>
<h4> Comment 127471821 ArnuldOnData: </h4>I did not get you when you said with <b>venv</b> you can&#39;t install packages. I mean I can install everything available through <b>pip</b> in a virtual environment created using <b>venv</b> e.g. I have 4 different virtual environments in 4 different directories with different python and pandas versions but same jupyter lab version. All through <b>venv</b><br><h4> Comment 127166801 Flimm: </h4>Note that <code>pipenv</code> and <code>venv</code> aren&#39;t alternatives to each other, just like Django and Python aren&#39;t alternatives to each other. With <code>venv</code> alone, you can&#39;t install packages, for instance, whereas <code>pipenv</code> does offer a mechanism to install packages.<br><h4> Comment 132832654 Magnus Lind Oxlund: </h4>@Flimm <code>python -m venv foo; source foo&#47;bin&#47;activate; pip install numpy</code>. Both <code>venv</code> and <code>pip</code> are available out of the box. The comment sounds a little misleading.<br><h4> Comment 132855747 Flimm: </h4>@MagnusLindOxlund You cannot replace <code>venv</code> with <code>pip</code> in your example or vice-versa. You can&#39;t do<code>venv install numpy</code>, and you can&#39;t do <code>pip foo ; source foo&#47;bin&#47;activate</code> . So I stand by my comment that they are not alternatives to each other. Also, <code>venv</code> and <code>pip</code> are not available out of the box, say on an Ubuntu installation (even though <code>python3</code> is available out of the box). On Ubuntu, you would have to install <code>python3-venv</code> (using APT) to get <code>venv</code>, and separately you would have to install <code>python3-pip</code> to get <code>pip</code>.<br>------------------------------------------------------------------ <br><h3> Answer 64392385 mirek: </h3><ul>
<li><strong>pyenv</strong> - manages different python versions,</li>
<li><strong>all others</strong> - create virtual environment (which has isolated python
version and installed &quot;requirements&quot;),</li>
</ul>
<p><strong>pipenv</strong> want combine all, in addition to previous it installs &quot;requirements&quot; (into the active virtual environment or create its own
if none is active)</p>
<p>So maybe you will be happy with pipenv only.</p>
<p>But I use: pyenv + pyenv-virtualenvwrapper, + pipenv (pipenv for installing requirements only).</p>
<p>In Debian:</p>
<ol>
<li><p><code>apt install libffi-dev</code></p>
</li>
<li><p>install pyenv based on <a href="https://www.tecmint.com/pyenv-install-and-manage-multiple-python-versions-in-linux/" rel="noreferrer">https://www.tecmint.com/pyenv-install-and-manage-multiple-python-versions-in-linux/</a>, but..</p>
</li>
<li><p>.. but instead of pyenv-virtualenv install pyenv-virtualenvwrapper (which can be standalone library or pyenv plugin, here the 2nd option):</p>
<pre class="lang-sh prettyprint-override"><code>$ pyenv install 3.9.0

$ git clone https://github.com/pyenv/pyenv-virtualenvwrapper.git $(pyenv root)/plugins/pyenv-virtualenvwrapper
# inside ~/.bashrc add:
# export $VIRTUALENVWRAPPER_PYTHON=&quot;/usr/bin/python3&quot;
$ source ~/.bashrc

$ pyenv virtualenvwrapper
</code></pre>
</li>
</ol>
<p>Then create virtual environments for your projects (workingdir must exist):</p>
<pre><code>pyenv local 3.9.0  # to prevent 'interpreter not found' in mkvirtualenv
python -m pip install --upgrade pip setuptools wheel
mkvirtualenv &lt;venvname&gt; -p python3.9 -a &lt;workingdir&gt;
</code></pre>
<p>and switch between projects:</p>
<pre><code>workon &lt;venvname&gt;
python -m pip install --upgrade pip setuptools wheel pipenv
</code></pre>
<p>Inside a project I have the file requirements.txt, without fixing the versions inside (if some version limitation is not neccessary).
You have 2 possible tools to install them into the current virtual environment: <strong>pip-tools</strong> or <strong>pipenv</strong>. Lets say you will use pipenv:</p>
<pre><code>pipenv install -r requirements.txt
</code></pre>
<p>this will create Pipfile and Pipfile.lock files, fixed versions are in the 2nd one. If you want reinstall somewhere exactly same versions then (Pipfile.lock must be present):</p>
<pre><code>pipenv install
</code></pre>
<p>Remember that Pipfile.lock is related to some Python version and need to be recreated if you use a different one.</p>
<p>As you see I write requirements.txt. This has some problems: You must remove a removed package from Pipfile too. So writing Pipfile directly is probably better.</p>
<p>So you can see I use pipenv very poorly. Maybe if you will use it well, it can replace everything?</p>
<p><strong>EDIT 2021.01</strong>: I have changed my stack to: <code>pyenv + pyenv-virtualenvwrapper + poetry</code>. Ie. I use no apt or pip installation of virtualenv or virtualenvwrapper, and instead I install <code>pyenv</code>'s plugin <code>pyenv-virtualenvwrapper</code>. This is easier way.</p>
<p><code>Poetry</code> is great for me:</p>
<pre><code>poetry add &lt;package&gt;   # install single package
poetry remove &lt;package&gt;
poetry install   # if you remove poetry.lock poetry will re-calculate versions
</code></pre>
<h4> Comment 123617829 Yassine Sedrani: </h4>can you please elaborate on your current stack, I mean <code>pyenv + pyenv-virtualenvwrapper + poetry</code>, especially how you instruct <code>poetry</code> to use a specifique version installed via <code>pyenv</code>, and if you are disabling create virtual environment in <code>poetry</code>?<br><h4> Comment 128096267 Rich Lysakowski PhD: </h4>Sounds like a mess to understand and keep track of!  Couldn&#39;t you eliminate all the rigamarole with the conda package, using its environment and package manager features?  conda is a single tool that does the work of all three or four packages mentioned in your answer.<br>------------------------------------------------------------------ <br><h3> Answer 75387631 Ben L: </h3><p>I want to add <code>docker</code> into this list, as well as <code>conda</code> that several answer already mentioned.</p>
<p>conda is heavier than the virtual environments the title mentioned. It also give isolation on some system-python tools, such as ffmpeg or gpu drivers.</p>
<p>docker is even better, it gives you a whole new OS to play with. With a good Dockerfile and a <code>docker build</code>, <code>docker run</code> script, you have good documentation of how your environment is built, and it is easy to populate, migrate to other environment (staging, production, cloud). It helps you in the long run.</p>
<p>Another thing: PyCharm provides several options to select your virtual environment. It helps the new-comers not to worry about this thing. Recommend to use it before you know what the virtual environment is.</p>
<h4> Comment 133024824 Ben L: </h4>I think this discussion should extend to &quot;what is the best way to use different python versions in development or production environment. &quot; That is more valuable.<br><h4> Comment 133026961 Flimm: </h4>I know what you mean. Honestly, the question I asked didn&#39;t turn out to be the one that people need answering when they visit this page. Stack Overflow&#39;s system is about specific Q&amp;A, and in general I find it works quite well, but it seems to have broken down a bit in this question, which is one of my most upvoted posts.<br><h4> Comment 136863906 David Leal: </h4>@Flimm the question in fact is objective, looking for difference and similarities of different related and similar tools, and objective (but it is challenging) answer can be provided based on best practices and the specific goals and difference on each mentioned tools. If you look at the votes, the question and several answers have been well recieved by SO community.<br><h4> Comment 133024451 Flimm: </h4>The question is about things that have confusingly similar names &quot;<i>env</i>&quot;. It&#39;s not about tools like Docker or Conda.<br>------------------------------------------------------------------ <br><h3> Answer 70386868 Rich Lysakowski PhD: </h3><p>As a Python newcomer this question frustrated me endlessly and confused me for months.  Which virtual environment and package manager(s) should I invest in learning when I know that I will be using it for years to come?</p>
<p>The best article answering this vexing question is <a href="https://jakevdp.github.io/blog/2016/08/25/conda-myths-and-misconceptions/" rel="nofollow noreferrer">https://jakevdp.github.io/blog/2016/08/25/conda-myths-and-misconceptions/</a> by Jake Vanderplas. Although a few years old, it provides practical answers and the history of Python package and virtual environment managers from the trenches as these state-of-the-art was developing.</p>
<p>It was particularly frustrating for me in the data science and &quot;big data cloud computing&quot; communities, because conda is widely used as a virtual environment manager and full function package manager for Python and JavaScript, SQL, Java, HTML5, and Jupyter Notebooks.</p>
<p>So why use pip at all, when conda does everything that pip and venv variants do?</p>
<p>The answer is, &quot;because you MUST use pip if a conda package is simply not available.&quot;  Many times a required package is only available in pip format and there is no easy solution but to use pip.  You can learn to use <code>conda build</code> but if you are not the package maintainer, then you must convince the package owner to generate a conda package for each new release (or do it yourself.)</p>
<p>These pip-based packages differ along many important and practical dimensions:</p>
<ul>
<li>stability</li>
<li>maturity</li>
<li>complexity</li>
<li>active support (versus dying or dead)</li>
<li>levels of adoption near the Python ecosystem &quot;core&quot; versus &quot;on the
fringes&quot; (i.e., integrated into Python.org distro)</li>
<li>easy to figure out and use (for beginners)</li>
</ul>
<p>I will answer your question for two packages from dimension of package maturity and stability.</p>
<p>venv and virtualenv are the most mature, stability, and community support.  From the online documentation you can see that virtualenv is in version 20.x as of today.  <a href="https://virtualenv.pypa.io/en/latest/" rel="nofollow noreferrer">virtualenv</a></p>
<blockquote>
<p>virtualenv is a tool to create isolated Python environments. Since
Python 3.3, a subset of it has been integrated into the standard
library under the venv module. The venv module does not offer all
features of this library, to name just a few more prominent:</p>
<pre><code>is slower (by not having the app-data seed method),

is not as extendable,

cannot create virtual environments for arbitrarily installed python versions (and automatically discover these),

is not upgrade-able via pip,

does not have as rich programmatic API (describe virtual environments without creating them).
</code></pre>
</blockquote>
<p>virtualenvwrapper is set of scripts to help people use virtualenv (it is a &quot;wrapper&quot; that not well-maintained, its last update was in 2019.  <a href="https://pypi.org/project/virtualenvwrapper/" rel="nofollow noreferrer">virtualenvwrapper</a></p>
<p>My recommendation is to avoid ALL pip virtual environments whenever possible. Use conda instead. Conda provides a unified approach. It is maintained by teams of professional open source developers and has a reputable company providing funding and a commercially supported version. The teams that maintain pip, venv, virtualenv, pipenv, and many other pip variants have limited resources by comparison. The pip virtual environment plurality is frustrating for beginners. The pip-based virtual environment tools complexity, fragmentation, fringe and unsupported packages, and wildly inconsistent support drove me to use conda.  For data science work, my recommendation is that to use a pip-based virtual environment manager as a last resort when conda packages do not exist.</p>
<p>The differences between the venv variants still scare me because my time is limited to learn new packages.  pipenv, venv, pyvenv, pyenv, virtualenv, virtualenvwrapper, poetry, and others have dozens of differences and complexities that take days to understand.  I hate going down a path and find support for a package goes belly-up when a maintainer resigns (or gets too busy to maintain it).  I just need to get my job done.</p>
<p>In the spirit of being helpful, here are a few links to help you dive in over your head, but not get lost in Dante's Inferno (re: pip).</p>
<p><a href="https://towardsdatascience.com/virtual-environments-104c62d48c54" rel="nofollow noreferrer">A Guide to Python’s Virtual Environments</a></p>
<p>Choosing &quot;core&quot; Python packages to invest in for your career (long-term), versus getting a job done short term) is important.  However, it is a business analysis question.  Are you trying to simply get a task done, or a professional software engineer who builds scalable performant systems that require the least amount of maintenance effort over time?  IMHO, conda will take you to the latter place more easily than dealing with pip-plurality problems.  conda is still missing 1-step pip-package migration tools that make this a moot question. If we could simply convert pip packages into conda packages then pypi.org and conda-forge could be merged. Pip is necessary because conda packages are not (yet) universal.  Many Python programmers are either too lazy to create conda packages, or they only program in Python and don't need conda's language-agnostic / multi-lingual support.</p>
<p>conda has been a god-send for me, because it supports cloud software engineering and data science's need for multilingual support of JavaScript, SQL, and Jupyter Notebook extensions, and conda plays well within Docker and other cloud-native environments.  I encourage you to learn and master conda, which will enable you to side-step many complex questions that pip-based tools may never answer.</p>
<p>Keep it simple!  I need one package that does 90% of what I need and guidance and workarounds for the 10% remaining edge cases.</p>
<p>Check out the articles linked herein to learn more about pip-based virtual environments.</p>
<p>I hope this is helpful to the original poster and gives pip and conda aficionados some things to think about.</p>
<h4> Comment 135720473 Karl Knechtel: </h4>None of this actually appears to identify any concrete issues that anyone would encounter using <code>pip</code>, <code>venv</code> etc. I haven&#39;t had these tools actually annoy me in years of use.<br><h4> Comment 125517391 arntg: </h4>Quote: <code>Pip is necessary because conda packages are not (yet) universal. Many Python programmers are either too lazy to create conda packages, or they only program in Python and don&#39;t need conda&#39;s language-agnostic &#47; multi-lingual support.</code>  ---   if so - then isn&#39;t this making a strong hint why not to use conda?  Or if conda wants to be universal, then there should be a clear time soon enough for that.  So despite the many pip/virtualenv flavors then maybe better pick a winner and cancel all the rest than pick conda ... (is virtualenv[wrapper] already the winner?)<br><h4> Comment 128096428 Rich Lysakowski PhD: </h4>The motivation for conda is to have a single, unified package AND environment manager.  Reduce complexity, uncomplicate life for Pythonista who are also polyglots,  &quot;There should be one-- and preferably only one --obvious way to do it.&quot;  The Zen of Python, by Tim Peters   ... Simple is better than complex. ... There should be one-- and preferably only one --obvious way to do it. ... If the implementation is hard to explain, it&#39;s a bad idea. If the implementation is easy to explain, it may be a good idea. ... Conda is one honking great idea -- let&#39;s do more of those!<br><h4> Comment 125664731 Rich Lysakowski PhD: </h4>My answer is opinionated in favor of simplicity, i.e., using ONE tool for virtual environment, dependency, and package management for Python AND other languages.  The conda system lacks just one function/module to make this entire cloudy confusion of alternatives disappear and become moot, a module to convert any pip-only format packages into conda packages reliably.   conda is singly better supported than the fragmented cast of characters that include pipenv, virtualenv, venv, pyenv, poetry, and others.   Someone will get around to writing a functional converter soon.<br><h4> Comment 127164883 Rich Lysakowski PhD: </h4>I just found a package last week called &quot;pip2conda&quot;.  When I get around to testing it,  I will let you know if it fulfills the promise of its name.<br>