 <h2> Title: How can Perl&#39;s print add a newline by default? </h2> <h3> Mike, question_id: 2899367 </h3>Score: 108, Tags: {perl} <br><p>In Perl most of my <code>print</code> statements take the form</p>

<pre><code>print "hello." . "\n";
</code></pre>

<p>Is there a nice way to avoid keeping all the pesky "\n"s lying around?</p>

<p>I know I could make a new function such as <code>myprint</code> that automatically appends \n, but it would be nice if I could override the existing <code>print</code>.</p>
<h4> Comment 2949051 Schwern: </h4>If your answer includes $\ please make sure it comes with a list of caveats about setting global variables with invisible effect.  While its very clever and technically answers the question, its also very dangerous to hand unqualified to a newbie.<br><h4> Comment 2955902 Ether: </h4>Real-life tools have physical limitations that are reasonably well-understood by people who have lived their lives in the physical world. Software tools are bound by no such limitations, and there aren&#39;t any rules. They can do anything, and frequently behave outside expectations, especially for beginners who have not learned the boundaries of reasonable expectations yet.<br><h4> Comment 2949242 P Shved: </h4>@David, because some random hacker will google the answers here instead of perldoc, get satisfied with them, and won&#39;t even know about the caveats!<br><h4> Comment 2950957 David M: </h4>That&#39;s exactly the sort of bizarre reasoning that has resulted in my iron having a warning label that I should not iron clothes while I am wearing them.<br><h4> Comment 2956101 David M: </h4>Yet, most people agree that it&#39;s a inevitable painful lesson in the real world that a child is going to touch a hot stove.  Explain to that child all you like that stoves get hot, but a) the child will eventually touch something hot and b) that lesson will outweigh all the explaining in the world.  Perhaps I&#39;m making too much of the analog between hot stoves and special Perl variables, but no one really respects those special Perl variables until they get burned a couple of times.<br><h4> Comment 2949219 David M: </h4><code>perldoc perlvar</code> describes most of the caveats, why belabor them here?<br><h4> Comment 2959800 Schwern: </h4>@DavidM This is not &quot;irons are hot&quot; this is &quot;if you leave this iron on too long it will burn through the chord and start a fire; nobody should use this iron because it is a fire hazard&quot;. If you hand it to someone and say &quot;this is an iron, it will make your shirts smooth&quot; they&#39;ll expect it as safe as any other iron until their house burns down. Unlike burning your hand on a hot iron, the consequences of a faulty iron, like an abused global variable, are unexpected, delayed and unpredictable.<br><h4> Comment 2960198 David M: </h4>@Schwern I guess we&#39;ll agree to disagree then.  I think you&#39;re overstating the worst case of setting $\ (or probably any other special variable).  I agree that I wouldn&#39;t use $\ in this instance, but there are plenty of occasions upon which setting a special variable makes a complicated program much simpler.<br>------------------------------------------------------------------ <br><h3> Answer 2899405 Josh Kelley: </h3><p>Raku (Perl 6) has the <a href="https://docs.raku.org/language/5to6-perlfunc#index-entry-say_-_perlfunc" rel="nofollow noreferrer"><code>say</code></a> function that automatically appends <code>\n</code>.</p>
<p>You can also use <code>say</code> in Perl 5.10 or 5.12 if you add</p>
<pre><code>use feature qw(say);
</code></pre>
<p>to the beginning of your program.  Or you can use <a href="http://search.cpan.org/%7Echromatic/Modern-Perl-1.03/lib/Modern/Perl.pm" rel="nofollow noreferrer">Modern::Perl</a> to get this and other features.</p>
<p>See <a href="http://perldoc.perl.org/feature.html#The-%27say%27-feature" rel="nofollow noreferrer">perldoc feature</a> for more details.</p>
<h4> Comment 2950876 Robert P: </h4>In fact, all you have to do is <code>use 5.012;</code> or <code>use 5.010;</code> to get it if you&#39;re running those newer <code>perl</code>s.<br><h4> Comment 81823167 wobbily_col: </h4>Isn&#39;t it safe to assume that unless Perl 6 is specifically mentioned that the question  refers to Perl 5?<br>------------------------------------------------------------------ <br><h3> Answer 25101396 jaypal singh: </h3><p>You can use the <code>-l</code> option in the she-bang header:</p>
<pre><code>#!/usr/bin/perl -l

$text = &quot;hello&quot;;

print $text;
print $text;
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>hello
hello
</code></pre>
<p>See &quot;-l[octnum]&quot; in perlrun(1) for details.</p>
<h4> Comment 44213689 ruffin: </h4>Very nice. More on <code>perl</code> options, including what <code>-l</code> is doing, <a href="http://www.perl.com/pub/2004/08/09/commandline.html" rel="nofollow noreferrer">here</a>.<br>------------------------------------------------------------------ <br><h3> Answer 2899470 Schwern: </h3><p>The way you're writing your print statement is unnecessarily verbose.  There's no need to separate the newline into its own string.  This is sufficient.</p>

<pre><code>print "hello.\n";
</code></pre>

<p>This realization will probably make your coding easier in general.</p>

<p>In addition to using <code>use feature "say"</code> or <code>use 5.10.0</code> or <code>use Modern::Perl</code> to get the built in <code>say</code> feature, I'm going to pimp <a href="http://search.cpan.org/dist/perl5i" rel="noreferrer">perl5i</a> which turns on a lot of sensible missing Perl 5 features by default.</p>
------------------------------------------------------------------ <br><h3> Answer 2899417 Eric Strom: </h3><p>If Perl 5.10+ is not an option, here is a quick and dirty approximation.  It's not exactly the same, since say has some magic when its first arg is a handle, but for printing to STDOUT:</p>

<pre><code>sub say {print @_, "\n"}

say 'hello';
</code></pre>
------------------------------------------------------------------ <br><h3> Answer 2899482 David M: </h3><p>Perhaps you want to change your output record separator to linefeed with:</p>

<p><code>local $\ = "\n";</code></p>

<pre><code>$ perl -e 'print q{hello};print q{goodbye}' | od -c
0000000    h   e   l   l   o   g   o   o   d   b   y   e                
0000014
$ perl -e '$\ = qq{\n}; print q{hello};print q{goodbye}' | od -c
0000000    h   e   l   l   o  \n   g   o   o   d   b   y   e  \n        
0000016
</code></pre>

<p>Update: my answer speaks to capability rather than advisability.  I don't regard adding "\n" at the end of lines to be a "pesky" chore, but if someone really wants to avoid them, this is one way.  If I had to maintain a bit of code that uses this technique, I'd probably refactor it out pronto.</p>
<h4> Comment 2952573 tsee: </h4>No, please don&#39;t do that. While technically a correct answer, using a special variable for something as trivial as this is a maintenance burden down the road.<br><h4> Comment 12547652 redbmk: </h4>Of course you could always make it local to avoid affecting other code, but still want to make your subroutine look a little cleaner: <code>local $\ = &quot;\n&quot;;</code><br><h4> Comment 2956029 David M: </h4>@tsee I agree completely, actually.  As I edited my answer to indicate, my answer describes the capability, even if one wouldn&#39;t recommend it as a general practice.<br><h4> Comment 3041779 Chas. Owens: </h4>The real danger comes from the fact that all code will now add newlines, even code in other people&#39;s modules that weren&#39;t expecting it.  Imagine networking code that would have sent the message <code>&quot;helo\r\n&quot;</code> that now sends <code>&quot;helo\r\n\n&quot;</code>.<br><h4> Comment 14387496 djd: </h4>Using the command flag <code>-l</code> is great for command line one-liners (see <a href="http://perldoc.perl.org/perlrun.html#Command-Switches" rel="nofollow noreferrer">perldoc.perl.org/perlrun.html#Command-Switches</a>). I wouldn&#39;t recommend it in any larger program.<br>------------------------------------------------------------------ <br><h3> Answer 54205031 hofergabriel: </h3><p>Here's what I found at <a href="https://perldoc.perl.org/perlvar.html" rel="noreferrer">https://perldoc.perl.org/perlvar.html</a>:</p>

<blockquote>
  <p>$\
  The output record separator for the print operator. If defined, this value is 
  printed after the last of print's arguments. Default is undef.</p>
  
  <p>You cannot call output_record_separator() on a handle, only as a static method. 
  See IO::Handle.</p>
  
  <p>Mnemonic: you set $\ instead of adding "\n" at the end of the print. Also, it's 
  just like $/ , but it's what you get "back" from Perl.</p>
</blockquote>

<p>example: </p>

<pre><code>$\ = "\n";
print "a newline will be appended to the end of this line automatically";
</code></pre>
------------------------------------------------------------------ <br><h3> Answer 2899371 Michael Mrozek: </h3><p>In Raku (Perl 6) there is, the <a href="https://docs.raku.org/language/5to6-perlfunc#index-entry-say_-_perlfunc" rel="nofollow noreferrer"><code>say</code></a> function.</p>
------------------------------------------------------------------ <br><h3> Answer 31777816 elcaro: </h3><p>If you're stuck with pre-5.10, then the solutions provided above will not fully replicate the <code>say</code> function. For example</p>

<pre><code>sub say { print @_, "\n"; }
</code></pre>

<p>Will not work with invocations such as</p>

<pre><code>say for @arr;
</code></pre>

<p>or </p>

<pre><code>for (@arr) {
    say;
}
</code></pre>

<p>... because the above function does not act on the implicit global <code>$_</code> like <code>print</code> and the real <code>say</code> function.</p>

<p>To more closely replicate the perl 5.10+ <code>say</code> you want this function</p>

<pre><code>sub say {
    if (@_) { print @_, "\n"; }
    else { print $_, "\n"; }
}
</code></pre>

<p>Which now acts like this</p>

<pre><code>my @arr = qw( alpha beta gamma );
say @arr;
# OUTPUT
# alphabetagamma
#
say for @arr;
# OUTPUT
# alpha
# beta
# gamma
#
</code></pre>

<p>The <code>say</code> builtin in perl6 behaves a little differently. Invoking it  with <code>say @arr</code> or <code>@arr.say</code> will not just concatenate the array items, but instead prints them separated with the list separator. To replicate this in perl5 you would do this</p>

<pre><code>sub say {
    if (@_) { print join($", @_) . "\n"; }
    else { print $_ . "\n"; }
}
</code></pre>

<p><code>$"</code> is  the global list separator variable, or if you're using <code>English.pm</code> then is is <code>$LIST_SEPARATOR</code></p>

<p>It will now act more like perl6, like so</p>

<pre><code>say @arr;
# OUTPUT
# alpha beta gamma
#
</code></pre>
------------------------------------------------------------------ <br><h3> Answer 74771020 U. Windl: </h3><p>As requested:</p>
<pre class="lang-perl prettyprint-override"><code>sub myprint { print @_, &quot;\n&quot;; }
myprint &quot;foo&quot;, 3 . 'bar'
</code></pre>
<p>And what was the actual problem?</p>
<p>Maybe try understanding the language you have before trying to change it.</p>
<p>Man perlvar(1) says: &quot;<em>Within a subroutine the array @_ contains the parameters passed to that subroutine.</em>&quot;</p>
