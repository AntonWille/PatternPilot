 <h2> Title: Perl: function to trim string leading and trailing whitespace </h2> <h3> Landon Kuhn, question_id: 4597937 </h3>Score: 89, Tags: {perl} <br><p>Is there a built-in function to trim leading and trailing whitespace such that <code>trim(" hello world ") eq "hello world"</code>?</p>
<h4> Comment 5051648 Hugmeir: </h4>A bit of clarification on all the asnwers you got: <code>s&#47;^\s+|\s+$&#47;&#47;g;</code> vs <code>s&#47;^\s*&#47;&#47;; s&#47;\s*$&#47;&#47;;</code> The latter is the (ever so slightly) more idiomatic way to do this, as starting the regex engine over is actually faster than the alternation, in this case. You can read more about this on Jeffrey Friedl&#39;s Mastering Regular Expressions. (Unless this was fixed in some newer version of Perl, in which case someone please correct me!)<br><h4> Comment 5051880 Landon Kuhn: </h4>Coming from a Java and .NET background, I&#39;m almost shocked this isn&#39;t built into the language! THANKS ALL!<br><h4> Comment 5051907 Hugmeir: </h4>@landon9720, it somewhat is: Scalar::Util has trim, and is core since 5.7.3 - That&#39;s 2002!<br><h4> Comment 5056456 daxim: </h4>Hugmeir, this is wrong, <a href="http://stackoverflow.com/q/4597937#4598148">see the answer of Ether</a>.<br><h4> Comment 5051466 A. Rex: </h4>FYI: string equality in Perl is tested by the operator <code>eq</code>.<br><h4> Comment 5056559 daxim: </h4>Comparison of even more functions: <a href="http://www.illusori.co.uk/perl/2010/03/05/advanced_benchmark_analysis_1.html" rel="nofollow noreferrer">illusori.co.uk/perl/2010/03/05/&hellip;</a> <a href="http://blog.stevenlevithan.com/archives/faster-trim-javascript" rel="nofollow noreferrer">blog.stevenlevithan.com/archives/faster-trim-javascript</a><br>------------------------------------------------------------------ <br><h3> Answer 4597960 brettkelly: </h3><p>According to <a href="http://www.perlmonks.org/?node_id=2258" rel="noreferrer">this perlmonk's thread</a>:</p>

<pre><code>$string =~ s/^\s+|\s+$//g;
</code></pre>
------------------------------------------------------------------ <br><h3> Answer 4597961 Mark Byers: </h3><p>Here's one approach using a regular expression:</p>

<pre><code>$string =~ s/^\s+|\s+$//g ;     # remove both leading and trailing whitespace
</code></pre>

<p>Perl 6 will include a trim function:</p>

<pre><code>$string .= trim;
</code></pre>

<p>Source: <a href="http://en.wikipedia.org/wiki/Trim_%28programming%29#Perl" rel="noreferrer">Wikipedia</a></p>
<h4> Comment 41885043 kyle: </h4>I look this up about once a month. Too bad I can&#39;t upvote it each time.<br>------------------------------------------------------------------ <br><h3> Answer 4598148 Ether: </h3><p>This is available in <a href="https://metacpan.org/pod/String::Util" rel="noreferrer">String::Util</a> with the <code>trim</code> method:</p>

<p><sup>Editor's note: <code>String::Util</code> is not a core module, but you can install it from <a href="http://cpan.org" rel="noreferrer">CPAN</a> with <code>[sudo] cpan String::Util</code>.</sup></p>

<pre><code>use String::Util 'trim';
my $str = "  hello  ";
$str = trim($str);
print "string is now: '$str'\n";
</code></pre>

<p>prints:</p>

<blockquote>
  <p>string is now 'hello'</p>
</blockquote>

<p>However it is easy enough to do yourself:</p>

<pre><code>$str =~ s/^\s+//;
$str =~ s/\s+$//;
</code></pre>
<h4> Comment 85114317 UncleCarl: </h4>@Ether With all due respect, I really appreciate knowing that this is a non-core module. This post is talking about using a module in lieu of a fairly simple regex one-liner. If the module is core, I would be much more open to it. It is relevant in this case.<br><h4> Comment 57183046 Marki555: </h4>why should everyone use modules from CPAN? It makes consistency difficult when using perl from your linux distribution (debian, redhat, ubuntu) combined with manually installed CPAN modules. It is much better if something can be done in perl using modules which are available as packages in linux distribution<br><h4> Comment 57268153 Marki555: </h4>I know they are also from CPAN... Yes, generally I can request a new pkg for debian, but it won&#39;t help me for my installed debian stable release... that&#39;s why I prefer packages modules, but use directly CPAN if really needed.<br><h4> Comment 103526600 Erik Lievaart: </h4>I would prefer the possessive \s++ over \s+ It is slightly more efficient, because it does not use backtracking. Although admittedly, this only matters if you invoke it an insane amount of times.<br><h4> Comment 49541626 Ether: </h4>@mklement0 nor will it ever be. But this is not relevant, since everyone should be using modules from the CPAN.<br><h4> Comment 57249198 Ether: </h4>@Marki555 modules available as packages in your linux distro <i>are</i> from CPAN -- they&#39;ve just been repackaged. You can generally request a certain module to be packaged if it hasn&#39;t been done so already (the debian folks are particularly responsive and helpful).<br>------------------------------------------------------------------ <br><h3> Answer 4597964 Eugene Yarmash: </h3><p>There's no built-in <code>trim</code> function, but you can easily implement your own using a simple substitution:</p>

<pre><code>sub trim {
    (my $s = $_[0]) =~ s/^\s+|\s+$//g;
    return $s;
}
</code></pre>

<p>or using <a href="http://search.cpan.org/~jesse/perl-5.14.0/pod/perldelta.pod#Non-destructive_substitution" rel="noreferrer">non-destructive substitution</a> in Perl 5.14 and later:</p>

<pre><code>sub trim {
   return $_[0] =~ s/^\s+|\s+$//rg;
}
</code></pre>
------------------------------------------------------------------ <br><h3> Answer 4597976 Nanne: </h3><p>Complete howto in the perfaq here:
<a href="http://learn.perl.org/faq/perlfaq4.html#How-do-I-strip-blank-space-from-the-beginning-end-of-a-string-" rel="noreferrer">http://learn.perl.org/faq/perlfaq4.html#How-do-I-strip-blank-space-from-the-beginning-end-of-a-string-</a></p>
------------------------------------------------------------------ <br><h3> Answer 21292198 Flimm: </h3><p>One option is <a href="https://metacpan.org/pod/Text::Trim" rel="nofollow">Text::Trim</a>:</p>

<pre><code>use Text::Trim;
print trim("  example  ");
</code></pre>
------------------------------------------------------------------ <br><h3> Answer 27277083 Douglas: </h3><p>For those that are using Text::CSV I found this thread and then noticed within the CSV module that you could strip it out via switch:</p>

<pre><code>$csv = Text::CSV-&gt;new({allow_whitespace =&gt; 1});
</code></pre>

<p>The logic is backwards in that if you want to strip then you set to 1.  Go figure.  Hope this helps anyone.</p>
------------------------------------------------------------------ <br><h3> Answer 4597965 Dirk-Willem van Gulik: </h3><p>Apply: <code>s/^\s*//; s/\s+$//;</code> to it. Or use  <code>s/^\s+|\s+$//g</code> if you want to be fancy.</p>
------------------------------------------------------------------ <br><h3> Answer 19937741 Shaun McDonald: </h3><p>I also use a positive lookahead to trim repeating spaces inside the text: </p>

<pre><code>s/^\s+|\s(?=\s)|\s+$//g
</code></pre>
------------------------------------------------------------------ <br><h3> Answer 4597969 Philip Potter: </h3><p>No, but you can use the <code>s///</code> substitution operator and the <code>\s</code> whitespace assertion to get the same result.</p>
<h4> Comment 13417211 DarenW: </h4>That would remove spaces between words, not just at either end of the string.<br><h4> Comment 13433520 Philip Potter: </h4>@DarenW: depends how you use it.<br>