 <h2> Title: How to copy files </h2> <h4> Matt, question_id: 123198 </h4>Score: 3760, Tags: {python,file,copy,filesystems,file-copying} <br><p>How do I copy a file in Python?</p>
<h4> Yaroslav Nikitenko, Id: 130857268 Score: 3: </h4>It would be nice if you specify a reason for copy. For many applications hard linking may be a viable alternative. And people looking for such solutions may also think about this &quot;copy&quot; opportunity (like me, but my answer here was downvoted).<br>------------------------------------------------------------------ <br><h3> JCE2423, Id: 75903786, Score: 1: </h3><p>I would like to propose a different solution.</p>
<pre><code>def copy(source, destination):
   with open(source, 'rb') as file:
       myFile = file.read()
   with open(destination, 'wb') as file:
       file.write(myFile)

copy(&quot;foo.txt&quot;, &quot;bar.txt&quot;)
</code></pre>
<p>The file is opened, and it's data is written to a new file of your choosing.</p>
<h4> Tcll, Comment 134194408 Score: 0: </h4>in Linux, this is not safe towards symlinks or hardlinks, the linked file is rewritten multiple times<br>------------------------------------------------------------------ <br><h3> jezrael, Id: 30359308, Score: 2098: </h3><div class="s-table-container">
<table class="s-table">
<thead>
<tr>
<th>Function</th>
<th>Copies<br>metadata</th>
<th>Copies<br>permissions</th>
<th>Uses file object</th>
<th>Destination<br>may be directory</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://docs.python.org/3/library/shutil.html#shutil.copy" rel="noreferrer">shutil.copy</a></td>
<td>No</td>
<td>Yes</td>
<td>No</td>
<td>Yes</td>
</tr>
<tr>
<td><a href="https://docs.python.org/3/library/shutil.html#shutil.copyfile" rel="noreferrer">shutil.copyfile</a></td>
<td>No</td>
<td>No</td>
<td>No</td>
<td>No</td>
</tr>
<tr>
<td><a href="https://docs.python.org/3/library/shutil.html#shutil.copy2" rel="noreferrer">shutil.copy2</a></td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
<td>Yes</td>
</tr>
<tr>
<td><a href="https://docs.python.org/3/library/shutil.html#shutil.copyfileobj" rel="noreferrer">shutil.copyfileobj</a></td>
<td>No</td>
<td>No</td>
<td>Yes</td>
<td>No</td>
</tr>
</tbody>
</table>
</div><h4> wovano, Comment 126266541 Score: 11: </h4>Note that <a href="https://docs.python.org/3/library/shutil.html" rel="nofollow noreferrer">even the <code>shutil.copy2()</code> function cannot copy all file metadata</a>.<br>------------------------------------------------------------------ <br><h3> Swati, Id: 123212, Score: 4626: </h3><p><a href="http://docs.python.org/3/library/shutil.html" rel="noreferrer"><code>shutil</code></a> has many methods you can use. One of which is:</p>
<pre><code>import shutil

shutil.copyfile(src, dst)

# 2nd option
shutil.copy(src, dst)  # dst can be a folder; use shutil.copy2() to preserve timestamp
</code></pre>
<ul>
<li>Copy the contents of the file named <code>src</code> to a file named <code>dst</code>. Both <code>src</code> and <code>dst</code> need to be the entire filename of the files, including path.</li>
<li>The destination location must be writable; otherwise, an <code>IOError</code> exception will be raised.</li>
<li>If <code>dst</code> already exists, it will be replaced.</li>
<li>Special files such as character or block devices and pipes cannot be copied with this function.</li>
<li>With <code>copy</code>, <code>src</code> and <code>dst</code> are path names given as <code>str</code>s.</li>
</ul>
<p>Another <code>shutil</code> method to look at is <a href="https://docs.python.org/3/library/shutil.html#shutil.copy2" rel="noreferrer"><code>shutil.copy2()</code></a>. It's similar but preserves more metadata (e.g. time stamps).</p>
<p>If you use <code>os.path</code> operations, use <code>copy</code> rather than <code>copyfile</code>. <code>copyfile</code> will only accept strings.</p>
<h4> John, Comment 133447379 Score: 2: </h4>@KansaiRobot: Yes, otherwise you get an exception: <code>FileNotFoundError: Directory does not exist: foo&#47;</code><br><h4> KansaiRobot, Comment 131251333 Score: 2: </h4>does the destination folder need to exist?<br><h4> Martijn Pieters, Comment 107520948 Score: 8: </h4>In Python 3.8 this has received some significant speed boosts (~50% faster, depending on OS).<br><h4> Dimitri Lesnoff, Comment 136147774 Score: 0: </h4>It does not copy file metadata like the file owner&#39;s group on POSIX OSes (GNU/Linux, FreeBSD, ..).<br>------------------------------------------------------------------ <br><h3> unmounted, Id: 123238, Score: 968: </h3><p><a href="https://docs.python.org/2/library/shutil.html#shutil.copy2" rel="noreferrer"><code>copy2(src,dst)</code></a> is often more useful than <a href="https://docs.python.org/2/library/shutil.html#shutil.copyfile" rel="noreferrer"><code>copyfile(src,dst)</code></a> because:</p>

<ul>
<li>it allows <code>dst</code> to be a <em>directory</em> (instead of the complete target filename), in which case the <a href="https://docs.python.org/2/library/os.path.html#os.path.basename" rel="noreferrer">basename</a> of <code>src</code> is used for creating the new file;</li>
<li>it preserves the original modification and access info (mtime and atime) in the file metadata (however, this comes with a slight overhead).</li>
</ul>

<p>Here is a short example:</p>

<pre><code>import shutil
shutil.copy2('/src/dir/file.ext', '/dst/dir/newname.ext') # complete target filename given
shutil.copy2('/src/file.ext', '/dst/dir') # target filename is /dst/dir/file.ext
</code></pre>
------------------------------------------------------------------ <br><h3> kmario23, Id: 48374171, Score: 273: </h3><p>In Python, you can copy the files using</p>
<ul>
<li><strong><a href="https://docs.python.org/3/library/shutil.html" rel="noreferrer"><code>shutil</code></a></strong> module</li>
<li><strong><a href="https://docs.python.org/3/library/os.html" rel="noreferrer"><code>os</code></a></strong> module</li>
<li><strong><a href="https://docs.python.org/3/library/subprocess.html" rel="noreferrer"><code>subprocess</code></a></strong> module</li>
</ul>
<hr />
<pre><code>import os
import shutil
import subprocess
</code></pre>
<hr />
<h3>1) Copying files using <a href="https://docs.python.org/3/library/shutil.html" rel="noreferrer"><code>shutil</code></a> module</h3>
<p><strong><a href="https://docs.python.org/3/library/shutil.html#shutil.copyfile" rel="noreferrer"><code>shutil.copyfile</code></a></strong>  signature</p>
<pre><code>shutil.copyfile(src_file, dest_file, *, follow_symlinks=True)

# example    
shutil.copyfile('source.txt', 'destination.txt')
</code></pre>
<hr />
<p><strong><a href="https://docs.python.org/3/library/shutil.html#shutil.copy" rel="noreferrer"><code>shutil.copy</code></a></strong>  signature</p>
<pre><code>shutil.copy(src_file, dest_file, *, follow_symlinks=True)

# example
shutil.copy('source.txt', 'destination.txt')
</code></pre>
<hr />
<p><strong><a href="https://docs.python.org/3/library/shutil.html#shutil.copy2" rel="noreferrer"><code>shutil.copy2</code></a></strong>  signature</p>
<pre><code>shutil.copy2(src_file, dest_file, *, follow_symlinks=True)

# example
shutil.copy2('source.txt', 'destination.txt')  
</code></pre>
<hr />
<p><strong><a href="https://docs.python.org/3/library/shutil.html#shutil.copyfileobj" rel="noreferrer"><code>shutil.copyfileobj</code></a></strong>  signature</p>
<pre><code>shutil.copyfileobj(src_file_object, dest_file_object[, length])

# example
file_src = 'source.txt'  
f_src = open(file_src, 'rb')

file_dest = 'destination.txt'  
f_dest = open(file_dest, 'wb')

shutil.copyfileobj(f_src, f_dest)  
</code></pre>
<hr />
<h3>2) Copying files using <a href="https://docs.python.org/3/library/os.html" rel="noreferrer"><code>os</code></a> module</h3>
<p><strong><a href="https://docs.python.org/3/library/os.html#os.popen" rel="noreferrer"><code>os.popen</code></a></strong>  signature</p>
<pre><code>os.popen(cmd[, mode[, bufsize]])

# example
# In Unix/Linux
os.popen('cp source.txt destination.txt') 

# In Windows
os.popen('copy source.txt destination.txt')
</code></pre>
<hr />
<p><strong><a href="https://docs.python.org/3/library/os.html#os.system" rel="noreferrer"><code>os.system</code></a></strong>  signature</p>
<pre><code>os.system(command)


# In Linux/Unix
os.system('cp source.txt destination.txt')  

# In Windows
os.system('copy source.txt destination.txt')
</code></pre>
<hr />
<h3>3) Copying files using <a href="https://docs.python.org/3/library/subprocess.html" rel="noreferrer"><code>subprocess</code></a> module</h3>
<p><strong><a href="https://docs.python.org/3/library/subprocess.html#subprocess.call" rel="noreferrer"><code>subprocess.call</code></a></strong>  signature</p>
<pre><code>subprocess.call(args, *, stdin=None, stdout=None, stderr=None, shell=False)

# example (WARNING: setting `shell=True` might be a security-risk)
# In Linux/Unix
status = subprocess.call('cp source.txt destination.txt', shell=True) 

# In Windows
status = subprocess.call('copy source.txt destination.txt', shell=True)
</code></pre>
<hr />
<p><strong><a href="https://docs.python.org/3/library/subprocess.html#subprocess.check_output" rel="noreferrer"><code>subprocess.check_output</code></a></strong>  signature</p>
<pre><code>subprocess.check_output(args, *, stdin=None, stderr=None, shell=False, universal_newlines=False)

# example (WARNING: setting `shell=True` might be a security-risk)
# In Linux/Unix
status = subprocess.check_output('cp source.txt destination.txt', shell=True)

# In Windows
status = subprocess.check_output('copy source.txt destination.txt', shell=True)
</code></pre>
<hr />
<h4> Shriraj Hegde, Comment 131476174 Score: 6: </h4>Only the first example answers the question. Running shell commands isn&#39;t portable and also isn&#39;t really performing actions.<br><h4> Yaroslav Nikitenko, Comment 130097588 Score: 4: </h4>Thanks for many options you listed. IMHO, &quot;os.popen(&#39;cp source.txt destination.txt&#39;) &quot; (with its likes) is bad design. Python is a platform-independent language, and with code like this you destroy this great feature.<br>------------------------------------------------------------------ <br><h3> maxschlepzig, Id: 44996087, Score: 186: </h3><p>You can use one of the copy functions from the <a href="https://docs.python.org/3/library/shutil.html" rel="noreferrer"><code>shutil</code></a> package:</p>

<pre>
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
Function              preserves     supports          accepts     copies other
                      permissions   directory dest.   file obj    metadata  
――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
<a href="https://docs.python.org/3/library/shutil.html#shutil.copy" rel="noreferrer">shutil.copy</a>              ✔             ✔                 ☐           ☐
<a href="https://docs.python.org/3/library/shutil.html#shutil.copy2" rel="noreferrer">shutil.copy2</a>             ✔             ✔                 ☐           ✔
<a href="https://docs.python.org/3/library/shutil.html#shutil.copyfile" rel="noreferrer">shutil.copyfile</a>          ☐             ☐                 ☐           ☐
<a href="https://docs.python.org/3/library/shutil.html#shutil.copyfileobj" rel="noreferrer">shutil.copyfileobj</a>       ☐             ☐                 ✔           ☐
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
</pre>

<p>Example:</p>

<pre><code>import shutil
shutil.copy('/etc/hostname', '/var/tmp/testhostname')
</code></pre>
<h4> wim, Comment 133735426 Score: 0: </h4>What does this add over <a href="https://stackoverflow.com/a/30359308/674039">jezrael answer</a> from 2 years earlier?<br><h4> maxschlepzig, Comment 133739950 Score: 0: </h4>@wim you have to compare my answer with <a href="https://stackoverflow.com/revisions/30359308/2">jesrael&#39;s answer at the time</a> I posted mine. So i added another column, used better column headers and less distracting table layout. I also added an example for the most common case. You are not the first one who asked this and I&#39;ve answered this question several times already, but unfortunately, some moderator deleted the old comments here. After checking my old notes it even appears that you, wim, already had asked me this question in the past, and your question with my answer was deleted, too.<br><h4> maxschlepzig, Comment 133740111 Score: 0: </h4>@wim I also added links into the Python documentation. The added column contains information about directory destinations, Jezrael&#39;s answer didn&#39;t include.<br><h4> wim, Comment 133740618 Score: 0: </h4>Oh dear, that&#39;s funny that I already asked. Yes I agree that the doc links and extra column are improvements, however, it may have been better to edit them into other answer. Looks like some users subsequently did so, and now we have two answers which aren&#39;t significantly different apart from the formatting - recommend deletion?<br>------------------------------------------------------------------ <br><h3> pi., Id: 125810, Score: 108: </h3><p>Copying a file is a relatively straightforward operation as shown by the examples below, but you should instead use the <a href="https://docs.python.org/library/shutil.html" rel="noreferrer">shutil stdlib module</a> for that.</p>

<pre class="lang-py prettyprint-override"><code>def copyfileobj_example(source, dest, buffer_size=1024*1024):
    """      
    Copy a file from source to dest. source and dest
    must be file-like objects, i.e. any object with a read or
    write method, like for example StringIO.
    """
    while True:
        copy_buffer = source.read(buffer_size)
        if not copy_buffer:
            break
        dest.write(copy_buffer)
</code></pre>

<p>If you want to copy by filename you could do something like this:</p>

<pre class="lang-py prettyprint-override"><code>def copyfile_example(source, dest):
    # Beware, this example does not handle any edge cases!
    with open(source, 'rb') as src, open(dest, 'wb') as dst:
        copyfileobj_example(src, dst)
</code></pre>
------------------------------------------------------------------ <br><h3> Airsource Ltd, Id: 123226, Score: 86: </h3><p>Use the <a href="https://docs.python.org/3/library/shutil.html" rel="noreferrer">shutil module</a>.</p>
<pre><code>copyfile(src, dst)
</code></pre>
<p>Copy the contents of the file named <em>src</em> to a file named <em>dst</em>. The destination location must be writable; otherwise, an IOError exception will be raised. If <em>dst</em> already exists, it will be replaced. Special files such as character or block devices and pipes cannot be copied with this function. <em>src</em> and <em>dst</em> are path names given as strings.</p>
<p>Take a look at <a href="https://docs.python.org/3/library/filesys.html" rel="noreferrer">filesys</a> for all the file and directory handling functions available in standard Python modules.</p>
------------------------------------------------------------------ <br><h3> Noam Manos, Id: 5310215, Score: 50: </h3><p>Directory and File copy example, <a href="http://timgolden.me.uk/python/win32_how_do_i/copy-a-file.html" rel="nofollow noreferrer">from Tim Golden's <em>Python Stuff</em></a>:</p>
<pre><code>import os
import shutil
import tempfile

filename1 = tempfile.mktemp (&quot;.txt&quot;)
open (filename1, &quot;w&quot;).close ()
filename2 = filename1 + &quot;.copy&quot;
print filename1, &quot;=&gt;&quot;, filename2

shutil.copy (filename1, filename2)

if os.path.isfile (filename2): print &quot;Success&quot;

dirname1 = tempfile.mktemp (&quot;.dir&quot;)
os.mkdir (dirname1)
dirname2 = dirname1 + &quot;.copy&quot;
print dirname1, &quot;=&gt;&quot;, dirname2

shutil.copytree (dirname1, dirname2)

if os.path.isdir (dirname2): print &quot;Success&quot;
</code></pre>
------------------------------------------------------------------ <br><h3> fabda01, Id: 45694203, Score: 43: </h3><p>For small files and using only Python built-ins, you can use the following one-liner:</p>
<pre><code>with open(source, 'rb') as src, open(dest, 'wb') as dst: dst.write(src.read())
</code></pre>
<p>This is not optimal way for applications where the file is too large or when memory is critical, thus <a href="https://stackoverflow.com/a/123212/6327658">Swati's</a> answer should be preferred.</p>
<h4> Tcll, Comment 134194375 Score: 1: </h4>not safe towards symlinks or hardlinks as it copies the linked file multiple times<br>------------------------------------------------------------------ <br><h3> Wizard, Id: 48273637, Score: 33: </h3><p>Firstly, I made an exhaustive cheat sheet of the <em>shutil</em> methods for your reference.</p>
<pre><code>shutil_methods =
{'copy':['shutil.copyfileobj',
          'shutil.copyfile',
          'shutil.copymode',
          'shutil.copystat',
          'shutil.copy',
          'shutil.copy2',
          'shutil.copytree',],
 'move':['shutil.rmtree',
         'shutil.move',],
 'exception': ['exception shutil.SameFileError',
                 'exception shutil.Error'],
 'others':['shutil.disk_usage',
             'shutil.chown',
             'shutil.which',
             'shutil.ignore_patterns',]
}
</code></pre>
<p>Secondly, explaining methods of copy in examples:</p>
<ol>
<li><p><code>shutil.copyfileobj(fsrc, fdst[, length])</code> manipulate opened objects</p>
<pre class="lang-none prettyprint-override"><code>In [3]: src = '~/Documents/Head+First+SQL.pdf'
In [4]: dst = '~/desktop'
In [5]: shutil.copyfileobj(src, dst)
AttributeError: 'str' object has no attribute 'read'

# Copy the file object
In [7]: with open(src, 'rb') as f1,open(os.path.join(dst,'test.pdf'), 'wb') as f2:
    ...:      shutil.copyfileobj(f1, f2)
In [8]: os.stat(os.path.join(dst,'test.pdf'))
Out[8]: os.stat_result(st_mode=33188, st_ino=8598319475, st_dev=16777220, st_nlink=1, st_uid=501, st_gid=20, st_size=13507926, st_atime=1516067347, st_mtime=1516067335, st_ctime=1516067345)
</code></pre>
</li>
<li><p><code>shutil.copyfile(src, dst, *, follow_symlinks=True)</code>  Copy and rename</p>
<pre class="lang-none prettyprint-override"><code>In [9]: shutil.copyfile(src, dst)
IsADirectoryError: [Errno 21] Is a directory: ~/desktop'
# So dst should be a filename instead of a directory name
</code></pre>
</li>
<li><p><code>shutil.copy()</code>  Copy without preseving the metadata</p>
<pre class="lang-none prettyprint-override"><code>In [10]: shutil.copy(src, dst)
Out[10]: ~/desktop/Head+First+SQL.pdf'

# Check their metadata
In [25]: os.stat(src)
Out[25]: os.stat_result(st_mode=33188, st_ino=597749, st_dev=16777220, st_nlink=1, st_uid=501, st_gid=20, st_size=13507926, st_atime=1516066425, st_mtime=1493698739, st_ctime=1514871215)
In [26]: os.stat(os.path.join(dst, 'Head+First+SQL.pdf'))
Out[26]: os.stat_result(st_mode=33188, st_ino=8598313736, st_dev=16777220, st_nlink=1, st_uid=501, st_gid=20, st_size=13507926, st_atime=1516066427, st_mtime=1516066425, st_ctime=1516066425)
# st_atime,st_mtime,st_ctime changed
</code></pre>
</li>
<li><p><code>shutil.copy2()</code>  Copy with preserving the metadata</p>
<pre class="lang-none prettyprint-override"><code>In [30]: shutil.copy2(src, dst)
Out[30]: ~/desktop/Head+First+SQL.pdf'
In [31]: os.stat(src)
Out[31]: os.stat_result(st_mode=33188, st_ino=597749, st_dev=16777220, st_nlink=1, st_uid=501, st_gid=20, st_size=13507926, st_atime=1516067055, st_mtime=1493698739, st_ctime=1514871215)
In [32]: os.stat(os.path.join(dst, 'Head+First+SQL.pdf'))
Out[32]: os.stat_result(st_mode=33188, st_ino=8598313736, st_dev=16777220, st_nlink=1, st_uid=501, st_gid=20, st_size=13507926, st_atime=1516067063, st_mtime=1493698739, st_ctime=1516067055)
# Preserved st_mtime
</code></pre>
</li>
<li><p><code>shutil.copytree()</code></p>
<p>Recursively copy an entire directory tree rooted at src, returning the destination directory.</p>
</li>
</ol>
------------------------------------------------------------------ <br><h3> mark, Id: 27575238, Score: 20: </h3><p>You could use <code>os.system('cp nameoffilegeneratedbyprogram /otherdirectory/')</code>.</p>
<p>Or as I did it,</p>
<pre><code>os.system('cp '+ rawfile + ' rawdata.dat')
</code></pre>
<p>where <code>rawfile</code> is the name that I had generated inside the program.</p>
<p>This is a Linux-only solution.</p>
<h4> Corey Goldberg, Comment 75996534 Score: 17: </h4>this is not portable, and unnecessary since you can just use shutil.<br><h4> maxschlepzig, Comment 76966134 Score: 6: </h4>Even when <code>shutil</code> is not available - <code>subprocess.run()</code>  (without <code>shell=True</code>!) is the better alternative to <code>os.system()</code>.<br><h4> Hiadore, Comment 96976882 Score: 2: </h4>shutil is more portable<br><h4> Marcel Waldvogel, Comment 98449251 Score: 2: </h4><code>subprocess.run()</code> as suggested by @maxschlepzig is a big step forward, when calling external programs. For flexibility and security however, use the <code>[&#39;cp&#39;, rawfile, &#39;rawdata.dat&#39;]</code> form of passing the command line. (However, for copying, <code>shutil</code> and friends are recommended over calling an external program.)<br><h4> Jean-Fran&#231;ois Fabre, Comment 98471495 Score: 2: </h4>try that with filenames with spaces in it.<br>------------------------------------------------------------------ <br><h3> Marc, Id: 55851299, Score: 22: </h3><p>As of <a href="https://docs.python.org/3/library/pathlib.html#pathlib.Path.write_bytes" rel="noreferrer">Python 3.5</a> you can do the following for small files (ie: text files, small jpegs):</p>

<pre><code>from pathlib import Path

source = Path('../path/to/my/file.txt')
destination = Path('../path/where/i/want/to/store/it.txt')
destination.write_bytes(source.read_bytes())
</code></pre>

<p><code>write_bytes</code> will overwrite whatever was at the destination's location</p>
<h4> bfontaine, Comment 130759980 Score: 2: </h4>@Kevin because this loads all the content in memory.<br><h4> Kevin, Comment 130120813 Score: 0: </h4>Why only small files?<br><h4> Marc, Comment 130131121 Score: 0: </h4>@Kevin my mistake I should have written down the why when it was fresh. I&#39;ll have to review again and update this as I can&#39;t remember anymore &#175;_(ツ)_/&#175;<br>------------------------------------------------------------------ <br><h3> Ritik Banger, Id: 74699207, Score: 20: </h3><p>There are two best ways to copy file in Python.</p>
<h4>1. We can use the <a href="https://docs.python.org/3/library/shutil.html" rel="nofollow noreferrer"><code>shutil</code></a> module</h4>
<p>Code Example:</p>
<pre><code>import shutil
shutil.copyfile('/path/to/file', '/path/to/new/file')
</code></pre>
<p>There are other methods available also other than <em>copyfile</em>, like copy, copy2, etc, but <em>copyfile</em> is best in terms of performance,</p>
<h4>2. We can use the <a href="https://docs.python.org/3/library/os.html" rel="nofollow noreferrer"><code>OS</code></a> module</h4>
<p>Code Example:</p>
<pre><code>import os
os.system('cp /path/to/file /path/to/new/file')
</code></pre>
<p>Another method is by the use of a subprocess, but it is not preferable as it’s one of the call methods and is not secure.</p>
<h4> Peter Mortensen, Comment 131862859 Score: 1: </h4>Why do we need a new answer?<br><h4> Jeremy Davis, Comment 136094654 Score: 1: </h4>I think you may be confused? The python docs for os.system note: &quot;The subprocess module provides more powerful facilities for spawning new processes and retrieving their results; using that module is preferable to using this function.&quot; You note that there are potential security issues with subprocess. However, that is only true if shell=True (shell=False is default), plus those same sec issues exist when using os.system (unsanitised user input). Rather than your os.system example, this is preferable: subprocess.run([&#39;&#39;cp&#39;, dst, src]).<br><h4> Peter Mortensen, Comment 131862846 Score: 0: </h4>It ought to link to documentation (but not naked links).<br><h4> Ritik Banger, Comment 131863077 Score: 0: </h4>@PeterMortensen, added links. The answer would add value as other answers are either too broad or either too straight, this answer contains the helpful information that can be used easiy.<br>------------------------------------------------------------------ <br><h3> rassa45, Id: 30431587, Score: 13: </h3><p>For large files, I read the file line by line and read each line into an array. Then, once the array reached a certain size, append it to a new file.</p>
<pre><code>for line in open(&quot;file.txt&quot;, &quot;r&quot;):
    list.append(line)
    if len(list) == 1000000: 
        output.writelines(list)
        del list[:]
</code></pre>
<h4> maxschlepzig, Comment 98474086 Score: 3: </h4>This is awful. It does unnecessary work for no good reason. It doesn&#39;t work for arbitrary files. The copy isn&#39;t byte-identical if the input has unusual line endings on systems like Windows. Why do you think that this might be easier to understand than a call to a copy function in <code>shutil</code>? Even when ignoring <code>shutil</code>, a simple block read/write loop (using unbuffered IO) is straight forward, would be efficient and would make much more sense than this, and thus is surely easier to teach and understand.<br><h4> owns, Comment 49666020 Score: 2: </h4>this seems a little redundant since the writer should handle buffering. <code>for l in open(&#39;file.txt&#39;,&#39;r&#39;): output.write(l)</code> should work find; just setup the output stream buffer to your needs. or you can go by the bytes by looping over a try with <code>output.write(read(n)); output.flush()</code> where <code>n</code> is the number of bytes you&#39;d like to write at a time.  both of these also don&#39;t have an condition to check which is a bonus.<br><h4> rassa45, Comment 49690489 Score: 1: </h4>Yes, but I thought that maybe this could be easier to understand because it copies entire lines rather than parts of them (in case we don&#39;t know how many bytes each line is).<br><h4> owns, Comment 74541230 Score: 1: </h4>looking at the source - writelines calls write, <a href="https://hg.python.org/cpython/file/c6880edaf6f3/Modules/_io/bytesio.c" rel="nofollow noreferrer">hg.python.org/cpython/file/c6880edaf6f3/Modules/_io/bytesio.&zwnj;&#8203;c</a>.  Also, the file stream is already open, so write wouldn&#39;t need to reopen it every time.<br><h4> rassa45, Comment 68974277 Score: 0: </h4>@owns To add to this question a year later, <code>writelines()</code> has shown slightly better performance over <code>write()</code> since we don&#39;t waste time consistently opening a new filestream, and instead write new lines as one large bytefeed.<br><h4> Martijn Pieters, Comment 107520847 Score: 0: </h4>This also adds decoding / encoding overhead, and won’t work on binary data. <b>Just use <code>shutil.copyfile()</code></b>, which on 3.8 has been improved further to use native OS support for fast file copying. It easily will take less than half the time from what this answer will take.<br>------------------------------------------------------------------ <br><h3> deepdive, Id: 36396465, Score: 13: </h3><p>Use <code>subprocess.call</code> to copy the file</p>
<pre class="lang-py prettyprint-override"><code>from subprocess import call
call(&quot;cp -p &lt;file&gt; &lt;file&gt;&quot;, shell=True)
</code></pre>
<h4> Kevin Meier, Comment 66254616 Score: 22: </h4>This depends on the platform, so i would not use is.<br><h4> buhtz, Comment 73406238 Score: 10: </h4>Such a <code>call</code> is unsecure. Please refere to the subproces docu about it.<br><h4> Corey Goldberg, Comment 75996542 Score: 6: </h4>this is not portable, and unnecessary since you can just use shutil.<br><h4> Baris Demiray, Comment 76909440 Score: 5: </h4>Hmm why Python, then?<br><h4> MilkyWay90, Comment 93344753 Score: 0: </h4>Maybe detect the operating system before starting (whether it&#39;s DOS or Unix, because those are the two most used)<br>------------------------------------------------------------------ <br><h3> Sun, Id: 55309529, Score: 14: </h3><p>Use</p>
<pre><code>open(destination, 'wb').write(open(source, 'rb').read())
</code></pre>
<p>Open the source file in read mode, and write to the destination file in write mode.</p>
<h4> luckydonald, Comment 98272546 Score: 3: </h4>Isn&#39;t that missing the <code>.close()</code> on all of those <code>open(...)</code>s?<br><h4> maxschlepzig, Comment 98459790 Score: 2: </h4>Same suboptimal memory-wasting approach as <a href="https://stackoverflow.com/a/45694203/427158">yellow01&#39;s answer</a>.<br><h4> moltarze, Comment 97589672 Score: 2: </h4><b>All</b> answers need explanation, even if it is one sentence. No explanation sets bad precedent and is not helpful in understanding the program. What if a complete Python noob came along and saw this, wanted to use it, but couldn&#39;t because they don&#39;t understand it? You want to be helpful to all in your answers.<br><h4> Sun, Comment 98305549 Score: 0: </h4>No need of .close(), as we are NOT STORING the file pointer object anywhere(neither for the src file nor for the destination file).<br><h4> Marcel Waldvogel, Comment 98449340 Score: 0: </h4>AFAIK, it is undefined when the files are actually closed, @SundeepBorra. Using <code>with</code> (as in the example above) is recommended and not more complicated. Using <code>read()</code> on a raw file reads the entire file into memory, which may be too big. Use a standard function like from <code>shutil</code> so that you and whoever else is involved in the code does not need to worry about special cases. <a href="https://docs.python.org/3/library/io.html#io.BufferedReader" rel="nofollow noreferrer">docs.python.org/3/library/io.html#io.BufferedReader</a><br>------------------------------------------------------------------ <br><h3> Leonardo Wildt, Id: 65709412, Score: 9: </h3><p>In case you've come this far down. The answer is that you need the entire path and file name</p>
<pre><code>import os

shutil.copy(os.path.join(old_dir, file), os.path.join(new_dir, file))
</code></pre>
<h4> Ivelin, Comment 132890822 Score: 0: </h4>if show importing of os, you should import shutil as well<br>------------------------------------------------------------------ <br><h3> Basj, Id: 65168236, Score: 8: </h3><p>Here is a simple way to do it, without any module. It's similar to <a href="https://stackoverflow.com/questions/123198/how-do-i-copy-a-file-in-python/45694203#45694203">this answer</a>, but has the benefit to also work if it's a big file that doesn't fit in RAM:</p>
<pre><code>with open('sourcefile', 'rb') as f, open('destfile', 'wb') as g:
    while True:
        block = f.read(16*1024*1024)  # work by blocks of 16 MB
        if not block:  # end of file
            break
        g.write(block)
</code></pre>
<p>Since we're writing a new file, it does not preserve the modification time, etc.<br />
We can then use <a href="https://docs.python.org/3/library/os.html#os.utime" rel="noreferrer"><code>os.utime</code></a> for this if needed.</p>
------------------------------------------------------------------ <br><h3> R J, Id: 65535130, Score: 4: </h3><p>Similar to the accepted answer, the following code block might come in handy if you also want to make sure to create any (non-existent) folders in the path to the destination.</p>
<pre><code>from os import path, makedirs
from shutil import copyfile
makedirs(path.dirname(path.abspath(destination_path)), exist_ok=True)
copyfile(source_path, destination_path)
</code></pre>
<p>As the accepted answers notes, these lines will overwrite any file which exists at the destination path, so sometimes it might be useful to also add: <code>if not path.exists(destination_path):</code> before this code block.</p>
------------------------------------------------------------------ <br><h3> Tcll, Id: 76101623, Score: 0: </h3><p>For the answer everyone recommends, if you prefer not to use the standard modules, or have completely removed them as I've done, preferring more core C methods over poorly written python methods</p>
<p>The way shutil works is symlink/hardlink safe, but is rather slow due to <code>os.path.normpath()</code> containing a while (nt, mac) or for (posix) loop, used in testing if <code>src</code> and <code>dst</code> are the same in <code>shutil.copyfile()</code></p>
<p><em>This part is mostly unneeded if you know for certain <code>src</code> and <code>dst</code> will never be the same file, otherwise a faster C approach could potentially be used.<br>
(note that just because a module may be C doesn't inherently mean it's faster, know that what you use is actually written well before you use it)</em></p>
<p>After that initial testing, <code>copyfile()</code> runs a for loop on a dynamic tuple of <code>(src, dst)</code>, testing for special files (such as sockets or devices in posix).</p>
<p>Finally, if <code>follow_symlinks</code> is False, <code>copyfile()</code> tests if <code>src</code> is a symlink with <code>os.path.islink()</code>, which varies between <code>nt.lstat()</code> or <code>posix.lstat()</code> (<code>os.lstat()</code>) on Windows and Linux, or <code>Carbon.File.ResolveAliasFile(s, 0)[2]</code> on Mac.<br>
If that test resolves True, the core code that copies a symlink/hardlink is:</p>
<pre class="lang-py prettyprint-override"><code>        os.symlink(os.readlink(src), dst)
</code></pre>
<p>Hardlinks in posix are done with <code>posix.link()</code>, which <code>shutil.copyfile()</code> doesn't call, despite being callable through <code>os.link()</code>.<br>
(probably because the only way to check for hardlinks is to hashmap the <code>os.lstat()</code> (<code>st_ino</code> and <code>st_dev</code> specifically) of the first inode we know about, and assume that's the hardlink target)</p>
<p>Else, file copying is done via basic file buffers:</p>
<pre class="lang-py prettyprint-override"><code>       with open(src, 'rb') as fsrc:
           with open(dst, 'wb') as fdst:
               copyfileobj(fsrc, fdst)
</code></pre>
<p>(similar to other answers here)</p>
<p><code>copyfileobj()</code> is a bit special in that it's buffer safe, using a <code>length</code> argument to read the file buffer in chunks:</p>
<pre class="lang-py prettyprint-override"><code>def copyfileobj(fsrc, fdst, length=16*1024):
    &quot;&quot;&quot;copy data from file-like object fsrc to file-like object fdst&quot;&quot;&quot;
    while 1:
        buf = fsrc.read(length)
        if not buf:
            break
        fdst.write(buf)
</code></pre>
<p>Hope this answer helps shed some light on the mystery of file copying using core mechanisms in python. :)</p>
<p>Overall, shutil isn't too poorly written, especially after the second test in <code>copyfile()</code>, so it's not a horrible choice to use if you're lazy, but the initial tests will be a bit slow for a mass copy due to the minor bloat.</p>
