 <h2> Title: Why are scripting languages (e.g. Perl, Python, and Ruby) not suitable as shell languages? </h2> <h3> Muhammad Alkarouri, question_id: 3637668 </h3>Score: 353, Tags: {python,ruby,perl,bash,shell} <br><p>What are the differences between shell languages like <a href="http://www.gnu.org/software/bash/bash.html" rel="noreferrer">Bash</a> (<code>bash</code>), <a href="http://zsh.sourceforge.net/" rel="noreferrer">Z shell</a> (<code>zsh</code>), <a href="http://fishshell.com/screenshots.html" rel="noreferrer">Fish</a> (<code>fish</code>) and the scripting languages above that makes them more suitable for the shell?</p>
<p>When using the command line, the shell languages seem to be much easier. It feels for me much smoother to use bash for example than to use the shell profile in <a href="https://en.wikipedia.org/wiki/IPython" rel="noreferrer">IPython</a>, <a href="http://transneptune.net/2009/06/16/ipython-as-your-default-shell/" rel="noreferrer">despite reports to the contrary</a>. I think most will agree with me that a large portion of medium to large scale programming is easier in Python than in Bash. I use Python as the language I am most familiar with. The same goes for <a href="https://en.wikipedia.org/wiki/Perl" rel="noreferrer">Perl</a> and <a href="https://en.wikipedia.org/wiki/Ruby_%28programming_language%29" rel="noreferrer">Ruby</a>.</p>
<p>I have tried to articulate the reason, but I am unable to, aside from assuming that the treatment of strings differently in both has something to do with it.</p>
<p>The reason of this question is that I am hoping to develop a language usable in both. If you know of such a language, please post it as well.</p>
<p>As <a href="https://stackoverflow.com/users/10661/s-lott">S.Lott</a> explains, the question needs some clarification. I am asking about the features of the shell <em>language</em> versus that of scripting languages. So the comparison is not about the characteristics of various interactive (<a href="http://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop" rel="noreferrer">REPL</a>) environments such as history and command line substitution. An alternative expression for the question would be:</p>
<p>Can a programming language that is suitable for design of complex systems be at the same time able to express useful one-liners that can access the file system or control jobs? Can a programming language usefully scale up as well as scale down?</p>
------------------------------------------------------------------ <br><h3> Answer 3640403 J&#246;rg W Mittag: </h3><p>There are a couple of differences that I can think of; just thoughtstreaming here, in no particular order:</p>

<ol>
<li><p>Python &amp; Co. are designed to be good at scripting. Bash &amp; Co. are designed to be <em>only</em> good at scripting, with absolutely no compromise. IOW: Python is designed to be good both at scripting and non-scripting, Bash cares only about scripting.</p></li>
<li><p>Bash &amp; Co. are untyped, Python &amp; Co. are strongly typed, which means that the number <code>123</code>, the string <code>123</code> and the file <code>123</code> are quite different. They are, however, not <em>statically</em> typed, which means they need to have different literals for those, in order to keep them apart.<br>
Example:</p>

<pre><code>                | Ruby             | Bash    
-----------------------------------------
number          | 123              | 123
string          | '123'            | 123
regexp          | /123/            | 123
file            | File.open('123') | 123
file descriptor | IO.open('123')   | 123
URI             | URI.parse('123') | 123
command         | `123`            | 123
</code></pre></li>
<li><p>Python &amp; Co. are designed to scale <em>up</em> to 10000, 100000, maybe even 1000000 line programs, Bash &amp; Co. are designed to scale <em>down</em> to 10 <em>character</em> programs.</p></li>
<li><p>In Bash &amp; Co., files, directories, file descriptors, processes are all first-class objects, in Python, only Python objects are first-class, if you want to manipulate files, directories etc., you have to wrap them in a Python object first.</p></li>
<li><p>Shell programming is basically dataflow programming. Nobody realizes that, not even the people who write shells, but it turns out that shells are quite good at that, and general-purpose languages not so much. In the general-purpose programming world, dataflow seems to be mostly viewed as a concurrency model, not so much as a programming paradigm.</p></li>
</ol>

<p>I have the feeling that trying to address these points by bolting features or DSLs onto a general-purpose programming language doesn't work. At least, I have yet to see a convincing implementation of it. There is <strong>RuSH</strong> (Ruby shell), which tries to implement a shell in Ruby, there is <a href="http://rush.heroku.com/" rel="noreferrer"><strong>rush</strong></a>, which is an internal DSL for shell programming in Ruby, there is <a href="http://code.google.com/p/hotwire-shell/" rel="noreferrer"><strong>Hotwire</strong></a>, which is a Python shell, but IMO none of those come even close to competing with Bash, Zsh, fish and friends.</p>

<p>Actually, IMHO, the best current shell is <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/dd835506%28v=vs.85%29.aspx" rel="noreferrer"><strong>Microsoft PowerShell</strong></a>, which is very surprising considering that for several <em>decades</em> now, Microsoft has continually had the <em>worst</em> shells <em>evar</em>. I mean, <code>COMMAND.COM</code>? Really? (Unfortunately, they still have a crappy terminal. It's still the "command prompt" that has been around since, what? Windows 3.0?)</p>

<p>PowerShell was basically created by ignoring everything Microsoft has ever done (<code>COMMAND.COM</code>, <code>CMD.EXE</code>, VBScript, JScript) and instead starting from the Unix shell, then removing all backwards-compatibility cruft (like backticks for command substitution) and massaging it a bit to make it more Windows-friendly (like using the now unused backtick as an escape character instead of the backslash which is the path component separator character in Windows). After that, is when the magic happens.</p>

<p>They address <strong>problem 1 and 3</strong> from above, by basically making the opposite choice compared to Python. Python cares about large programs first, scripting second. Bash cares only about scripting. PowerShell cares about scripting first, large programs second. A defining moment for me was watching a video of an interview with Jeffrey Snover (PowerShell's lead designer), when the interviewer asked him how big of a program one could write with PowerShell and Snover answered without missing a beat: "80 characters." At that moment I realized that this is <em>finally</em> a guy at Microsoft who "gets" shell programming (probably related to the fact that PowerShell was <em>neither</em> developed by Microsoft's programming language group (i.e. lambda-calculus math nerds) nor the OS group (kernel nerds) but rather the server group (i.e. sysadmins who actually <em>use</em> shells)), and that I should probably take a serious look at PowerShell.</p>

<p><strong>Number 2</strong> is solved by having arguments be statically typed. So, you can write just <code>123</code> and PowerShell knows whether it is a string or a number or a file, because the cmdlet (which is what shell commands are called in PowerShell) declares the types of its arguments to the shell. This has pretty deep ramifications: unlike Unix, where each command is responsible for parsing its own arguments (the shell basically passes the arguments as an array of strings), argument parsing in PowerShell is done by the <em>shell</em>. The cmdlets specify all their options and flags and arguments, as well as their types and names and documentation(!) to the shell, which then can perform argument parsing, tab completion, IntelliSense, inline documentation popups etc. in one centralized place. (This is not revolutionary, and the PowerShell designers acknowledge shells like the DIGITAL Command Language (DCL) and the IBM OS/400 Command Language (CL) as prior art. For anyone who has ever used an AS/400, this should sound familiar. In OS/400, you can write a shell command and if you don't know the syntax of certain arguments, you can simply leave them out and hit <kbd>F4</kbd>, which will bring a menu (similar to an HTML form) with labelled fields, dropdown, help texts etc. This is only possible because the OS knows about all the possible arguments and their types.) In the Unix shell, this information is often duplicated three times: in the argument parsing code in the command itself, in the <code>bash-completion</code> script for tab-completion and in the manpage.</p>

<p><strong>Number 4</strong> is solved by the fact that PowerShell operates on strongly typed objects, which includes stuff like files, processes, folders and so on.</p>

<p><strong>Number 5</strong> is particularly interesting, because PowerShell is the only shell I know of, where the people who wrote it were actually <em>aware</em> of the fact that shells are essentially dataflow engines and deliberately implemented it as a dataflow engine.</p>

<p>Another nice thing about PowerShell are the naming conventions: all cmdlets are named <code>Action-Object</code> and moreover, there are also standardized names for specific actions and specific objects. (Again, this should sound familar to OS/400 users.) For example, everything which is related to receiving some information is called <code>Get-Foo</code>. And everything operating on (sub-)objects is called <code>Bar-ChildItem</code>. So, the equivalent to <code>ls</code> is <code>Get-ChildItem</code> (although PowerShell also provides builtin aliases <code>ls</code> and <code>dir</code>&nbsp;&ndash; in fact, whenever it makes sense, they provide both Unix and <code>CMD.EXE</code> aliases as well as abbreviations (<code>gci</code> in this case)).</p>

<p>But the <strong>killer feature</strong> IMO is the strongly typed object pipelines. While PowerShell is derived from the Unix shell, there is one very important distinction: in Unix, all communication (both via pipes and redirections as well as via command arguments) is done with untyped, unstructured strings. In PowerShell, it's all strongly typed, structured objects. This is so incredibly powerful that I seriously wonder why noone else has thought of it. (Well, they have, but they never became popular.) In my shell scripts, I estimate that up to one third of the commands is only there to act as an adapter between two other commands that don't agree on a common textual format. Many of those adapters go away in PowerShell, because the cmdlets exchange structured objects instead of unstructured text. And if you look <em>inside</em> the commands, then they pretty much consist of three stages: parse the textual input into an internal object representation, manipulate the objects, convert them back into text. Again, the first and third stage basically go away, because the data already comes in as objects.</p>

<p>However, the designers have taken great care to preserve the dynamicity and flexibility of shell scripting through what they call an <em>Adaptive Type System</em>. </p>

<p>Anyway, I don't want to turn this into a PowerShell commercial. There are plenty of things that are <em>not</em> so great about PowerShell, although most of those have to do either with Windows or with the specific implementation, and not so much with the concepts. (E.g. the fact that it is implemented in .NET means that the very first time you start up the shell can take up to several seconds if the .NET framework is not already in the filesystem cache due to some other application that needs it. Considering that you often use the shell for well under a second, that is completely unacceptable.)</p>

<p>The most important point I want to make is that if you want to look at existing work in scripting languages and shells, <strong>you shouldn't stop at Unix and the Ruby/Python/Perl/PHP family</strong>. For example, <a href="http://www.tcl.tk/" rel="noreferrer">Tcl</a> was already mentioned. <a href="http://en.wikipedia.org/wiki/REXX" rel="noreferrer">Rexx</a> would be another scripting language. <a href="http://www.gnu.org/software/emacs/emacs.html" rel="noreferrer">Emacs Lisp</a> would be yet another. And in the shell realm there are some of the already mentioned mainframe/midrange shells such as the OS/400 command line and DCL. Also, Plan9's rc.</p>
<h4> Comment 5023629 J&#246;rg W Mittag: </h4>13 votes in 4 months and then 84 in 20 hours? Did I get reddited or something? @Mauricio Scheffer: I skimmed through almost all the videos on Channel9, even back to when PS was still called Monad, but nothing jumped out at me, sorry. @Dave: There is a project called <a href="http://PaSh.SF.Net/" rel="nofollow noreferrer">Pash (PoSh + Bash)</a>, but that has only had one release three years ago. <a href="http://BUSH.SF.Net/" rel="nofollow noreferrer">BUSH</a> and <a href="http://FISH.SF.Net/" rel="nofollow noreferrer">FISH</a> move away from Bourne <i>syntax</i>, but they still deal in text. @codebliss: The question was about Python as a <i>shell</i> language. The interesting number here is <i>one LOC</i>.<br><h4> Comment 5023768 J&#246;rg W Mittag: </h4>@Muhammad Alkarouri: Another way to look at it: PowerShell doesn&#39;t support polymorphism or overloading. In a language with polymorphism, the language decides which procedure to execute based on the types of the arguments. (E.g. in <code>x.ToString()</code> in depends on the type of <code>x</code> <i>which</i> <code>ToString()</code> gets executed.) In PowerShell, it&#39;s exactly the dual: the language decides as what types to interpret the arguments, based on the procedure. Yet <i>another</i> interpretation is that the grammar gets built dynamically based on the argument types, so there is only way to parse the tokens.<br><h4> Comment 20889679 Joey: </h4>@Alexandru: PowerShell is (hence the name) still a shell and thus makes executing programs easy (albeit not totally painless depending on arguments that may require quoting). So you can use ImageMagick just like you would anywhere else without first having to write/find a cmdlet or a PowerShell function that wraps it. <i>But</i> a PowerShell-native implementation can be so much cooler, e.g. by passing image objects around and implementing image filters as cmdlets. I&#39;m still thinking of writing something that would allow things like <code>Load-Image foo.bmp | Apply-Blur -Radius 5 | Save-Image x.png</code>.<br><h4> Comment 5023063 Dave: </h4>This sounds amazing, so is there a PowerShell-esque implementation for UNIX/Linux that can replace bash?<br><h4> Comment 3836366 Muhammad Alkarouri: </h4>A very good answer to both sections of the question. About points 2 and 4: Is that because of static typing as such, or is it because of a casting operation? In most non-shell languages (static or dynamic) that I know of, <code>123</code> cannot define two different types. Also do you have a link explaining Powershell&#39;s Adaptive Type System? Google doesn&#39;t seem to throw at me anything I could understand.<br><h4> Comment 4444667 Mauricio Scheffer: </h4>Great answer! Do you remember the link to that interview with Jeffrey Snover?<br><h4> Comment 5026808 mjs: </h4>The Wikipedia page has some useful examples of PowerShell commands: <a href="http://en.wikipedia.org/wiki/Windows_PowerShell#Examples" rel="nofollow noreferrer">en.wikipedia.org/wiki/Windows_PowerShell#Examples</a><br><h4> Comment 5032311 Alexandru Nedelcu: </h4>@Jorg ... the power of Unix shells is that all the hard work is done by plain executables, many of which are part of POSIX or just a defacto standard (find me a Unix box without Perl, grep or awk on it). &quot;cmdlets&quot; are written on top of .NET using special conventions described only 5 years ago. What good does strong-typing do if you have to search/write a cmdlet for ImageMagick? ... and contrary to what Microsoft throws over the fence, the standard Unix tools don&#39;t get reinvented every couple of years.<br><h4> Comment 5023675 J&#246;rg W Mittag: </h4>@Muhammad Alkarouri: Basically, since PowerShell <i>knows</i> that, say, the first argument to a <code>repeat</code> loop is the number of iterations and the second argument is the code to repeat, it <i>knows</i> that in <code>repeat 123 123</code> the first <code>123</code> is a number and the second is a command. (Completely made up example.) It is basically overloading the literals based on their result type, which sounds strange at first, but is actually what happens with lambda literals in C# as well. (They get interpreted as either <code>Action&#47;Func</code> or <code>Expression</code> depending on what type of variable/parameter they are bound to.)<br><h4> Comment 24130517 michaelmeyer: </h4>&quot;Bash &amp; Co. are designed to scale down to 10 character programs&quot; &lt;- loved this one<br><h4> Comment 37363950 CMCDragonkai: </h4>Shall we port PowerShell to linux now?<br><h4> Comment 5023411 codebliss: </h4>EVE-Online uses python primarily (with a C++ backend) and must be over millions of LOC.<br><h4> Comment 37371162 J&#246;rg W Mittag: </h4>@CMCDragonkai: Too late: <a href="http://pash.sourceforge.net/" rel="nofollow noreferrer">pash.sourceforge.net</a> Also, <a href="http://sparforte.com/" rel="nofollow noreferrer">sparforte.com</a> is based on many of the same ideas in PowerShell. <a href="https://code.google.com/p/hotwire-shell/" rel="nofollow noreferrer">code.google.com/p/hotwire-shell</a> was another implementation of (some) of those ideas.<br><h4> Comment 18775764 Alex Nye: </h4>This was quite well-written to the point that I won&#39;t avoid trying PowerShell anymore.  I really enjoyed number 4, though I wish you&#39;d expanded upon it more like the rest.  But that&#39;s just because you had pulled me in as a listener.<br><h4> Comment 24135874 J&#246;rg W Mittag: </h4>@doukremt: Thanks! I didn&#39;t come up with that entirely by myself, it is inspired by a comment Jeffrey Snover (PowerShell lead architect) made in an interview. They were talking about the strong static type system of PS and the PS IDE and the fact that they wanted to design PS as a &quot;proper&quot; programming language to write large programs in, and the interviewer asked how big of a program one could write in PS. Snover replied: &quot;80 characters.&quot;<br><h4> Comment 33188442 Profpatsch: </h4>So a ten pages long Powershell infomercial is voted as best answer even though it completely misses the question asked?<br><h4> Comment 5023682 J&#246;rg W Mittag: </h4>Aah, that explains it: <a href="http://Programming.Reddit.Com/comments/eui2x/" rel="nofollow noreferrer">Programming.Reddit.Com/comments/eui2x</a><br><h4> Comment 5023717 Muhammad Alkarouri: </h4>@J&#246;rg W Mittag: you did get reddited, mea culpa. And thanks for the response to the comments.<br><h4> Comment 5958950 Samuel Katz: </h4>zomg gr8 answer +1<br><h4> Comment 5023852 Muhammad Alkarouri: </h4>@J&#246;rg W Mittag: Can it be seen as a sort of type inference?<br>------------------------------------------------------------------ <br><h3> Answer 5589163 SFEley: </h3><p>It's cultural.  The <a href="http://en.wikipedia.org/wiki/Bourne_shell" rel="noreferrer">Bourne shell</a> is almost 25 years old; it was one of the first scripting languages, and it was the first <em>good</em> solution to the central need of Unix admins.  (I.e., a 'glue' to tie all the other utilities together and to do typical Unix tasks without having to compile a damn C program every time.)  </p>

<p>By modern standards, its syntax is atrocious and its weird rules and punctuation-as-statement style (useful in the 1970s when every byte counted) make it hard for non-admins to penetrate it.  But it <em>did the job.</em>  The flaws and shortcomings were addressed by evolutionary improvements in its descendants (ksh, bash, zsh) without having to reconceive the ideas behind it.   Admins stuck to the core syntax because, weird as it was, nothing else handled the simple stuff better without getting in the way.</p>

<p>For complex stuff, Perl came along and morphed into a sort of half-admin, half-application language.  But the more complex something gets, the more it's seen as an application rather than admin work, so the business people tend to look for "programmers" rather than "admins" to do it, despite the fact that the right kind of geek tends to be both.  So that's where the focus went, and the evolutionary improvements to the application capabilities of Perl resulted in...well, Python and Ruby.  (That's an oversimplification, but Perl was one of several inspirations for both languages.)</p>

<p>Result?  Specialization.  Admins tend to think modern interpreted languages are too heavyweight for the things they're paid to do every day.  And overall, they're right.  They don't need objects.  They don't care about data structures.  They need <em>commands.</em>  They need <em>glue.</em>  Nothing else tries to do <em>commands</em> better than the Bourne shell concept (except maybe Tcl, which was already mentioned here); and Bourne is good enough.</p>

<p>Programmers -- who nowadays are having to learn about devops more and more -- look at the limitations of the Bourne shell and wonder how the hell anyone could put up with it.  But the tools they know, while they certainly lean towards the Unixish style of I/O and file operations, aren't <em>better</em> for the purpose.  I've written things like backup scripts and file renaming one-offs in Ruby, because I know it better than I know bash, but any dedicated admin could do the same thing in bash -- <em>probably</em> in fewer lines and with less overhead, but either way, it'd work just as well.</p>

<p>It's a common thing to ask "Why does everyone use <em>Y</em> when <em>Z</em> is better?" -- but evolution in technology, like evolution in everything else, tends to stop at <em>good enough.</em>  The 'better' solution doesn't win unless the difference is viewed as a deal-breaking frustration.  Bourne-type scripting might be frustrating to <em>you</em>, but for the people who use it all the time and for the jobs it was meant for, it's always done the job.</p>
<h4> Comment 37644102 Sergey Orshanskiy: </h4>I think it might serve as an inspiration for some future technology that will use, say, pipe (<code>|</code>) as the foundational concept. Much like Javascript was rebranded and revived with numerous modern languages and then <code>node.js</code>, the same might as well happen to shell scripts.<br>------------------------------------------------------------------ <br><h3> Answer 3637744 Ivo van der Wijk: </h3><p>A shell language has to be easy to use. You want to type one-time throw away commands, not small programs. I.e., you want to type</p>
<pre><code>ls -laR /usr
</code></pre>
<p>not</p>
<pre><code>shell.ls(&quot;/usr&quot;, long=True, all=True, recursive=True)
</code></pre>
<p>This (also) means shell languages don't really care if an argument is an option, a string, a number or something else.</p>
<p>Also, programming constructs in shells are an add-on, and not even always build-in. I.e. consider the combination of <strong>if</strong> and <strong>[</strong> in <a href="https://en.wikipedia.org/wiki/Bash_%28Unix_shell%29" rel="nofollow noreferrer">Bash</a> or <a href="https://en.wikipedia.org/wiki/Bourne_shell" rel="nofollow noreferrer">Bourne shell</a> (<code>sh</code>), <a href="https://linux.die.net/man/1/seq" rel="nofollow noreferrer">seq</a> for generating sequences, and so on.</p>
<p>Finally, shells have specific needs that you need less, or differently in programming. I.e., pipes, file redirection, process/job control, and so on.</p>
<h4> Comment 18112862 Ivo van der Wijk: </h4>then you&#39;re not using perl but simply executing shell commands through perl.<br><h4> Comment 5029379 Ivo van der Wijk: </h4>You&#39;ll still need to do proper quoting and balance your parens. And you&#39;re providing a trivial argument here, what about &quot;ls --sort=time -R /bin /usr&quot;, for example?<br><h4> Comment 35883338 houqp: </h4>Shameless plug, I wrote a python library that hopefully makes python easier to use: <a href="https://github.com/houqp/shell.py" rel="nofollow noreferrer">github.com/houqp/shell.py</a><br><h4> Comment 3823190 Muhammad Alkarouri: </h4>Thanks for the answer, but these differences do not seem to me to be intrinsic to the language. It is very easy to design a library so in Python you say <code>shell.ls(&#39;usr&#39;, flags=&#39;laR&#39;)</code>. Even the <code>shell</code> bit and the <code>flags=</code> bit can be removed. I agree that things like redirection and process control are optimised in shells because of their relevance there.<br><h4> Comment 17914180 intuited: </h4>Your point about running commands applies to Python but not all of the languages under consideration: for example, <code>`ls -laR &#47;usr`</code> will do it in perl.<br><h4> Comment 24402436 Xiong Chiamiov: </h4>Ruby&#39;s un-required parens mean you could write a function that&#39;s <i>almost</i> as good as in bash: <code>ls :-laR, :&#47;usr</code>.  You&#39;ve still got the commas and symbols (or strings), though.<br>------------------------------------------------------------------ <br><h3> Answer 3637769 slebetman: </h3><blockquote>
<p>If you know of such a language, please post it as well.</p>
</blockquote>
<p>Tcl is one such language. Mainly because it is designed to primarily be a shell interpreter for CAD programs. Here's one hardcore Python programmer's* experience of realising why Tcl was designed the way it was: <em><a href="http://www.yosefk.com/blog/i-cant-believe-im-praising-tcl.html" rel="nofollow noreferrer">I can't believe I'm praising Tcl</a></em></p>
<p>For me, I've written and have been using and improved Tcl shell (written in Tcl, of course) as my main Linux login shell on my homebrewed router: <a href="http://wiki.tcl.tk/16139" rel="nofollow noreferrer">Pure Tcl readline</a></p>
<p>Some of the reasons I like Tcl in general has everything to do with the similarity of its syntax to traditional shells:</p>
<ol>
<li><p>At its most basic, Tcl syntax is <code>command argument argument...</code>. There's nothing else. This is the same as <a href="https://en.wikipedia.org/wiki/Bash_%28Unix_shell%29" rel="nofollow noreferrer">Bash</a>, <a href="https://en.wikipedia.org/wiki/C_shell" rel="nofollow noreferrer">C shell</a> or even DOS shell.</p>
</li>
<li><p>A bareword is considered a string. This is again similar to traditional shells allowing you to write: <code>open myfile.txt w+</code> instead of <code>open &quot;myfile.txt&quot; &quot;w+&quot;</code>.</p>
</li>
<li><p>Because of the foundations of 1 and 2, Tcl ends up with very little extraneous syntax. You write code with less punctuation: <code>puts Hello</code> instead of <code>printf(&quot;Hello&quot;);</code>. When writing programs you don't feel the hurt so much, because you spend a lot of time thinking about what to write. When you use a shell to copy a file you don't think you just type and having to type <code>(</code> and <code>&quot;</code> and <code>,</code> and <code>)</code> and <code>;</code> again and again gets annoying very quickly.</p>
</li>
</ol>
<p><em>*Note: not me; I'm a hardcore Tcl programmer</em></p>
<h4> Comment 3825516 Muhammad Alkarouri: </h4>I did look at your code after I posted my comment, and I am going to use that. Speaking about insufficiently C-like languages, you have probably come across <a href="http://james-iry.blogspot.com/2009/05/brief-incomplete-and-mostly-wrong.html" rel="nofollow noreferrer">this</a> before.<br><h4> Comment 3823272 Muhammad Alkarouri: </h4>Now the slightly unflattering bit. Tcl is not as successful as other languages, can you say why? I remember not being happy with the <code>math</code> command, and probably OOP, but that was a long time ago.<br><h4> Comment 3823254 Muhammad Alkarouri: </h4>Very good! I forgot all about Tcl. I had a short introduction to it a long while ago, and I simply forgot that it was a perfectly good shell interface for some Cisco routers that I used a long time now. It looks like Tcl is the nearest to the sweet spot between them. I will switch to tclsh for a couple of days to see how it goes.<br><h4> Comment 7496179 J&#246;rg W Mittag: </h4>Actually, the <i>really cool</i> thing about Tcl&#39;s syntax is not so much that it is like Bash, but that it is like Lisp S-Expressions, thus allowing powerful metalinguistic abstraction and syntactic metprogramming.<br><h4> Comment 5024020 chiggsy: </h4>TCL&#39;s problems as I recall were political.<br><h4> Comment 3823441 slebetman: </h4>For the first bit, I&#39;d like to point out that tclsh is a really-really basic shell: no up-down-arrow history, no tab completion etc.. I would recommend you at least use <code>rlwrap tclsh</code> to wrap it in readline. Or even better, use my code linked above as your shell. For the second bit, I think it&#39;s because most programmers are uncomfortable with anything that doesn&#39;t look like C. Fun fact, Netscape originally implemented Tcl as the browser scripting language but management wanted something that looks like Java syntax (which is, again another C-like syntax).<br>------------------------------------------------------------------ <br><h3> Answer 3638038 Chas. Owens: </h3><p>Who says they aren't?  Take a look at <a href="https://search.cpan.org/%7Epardus/Zoidberg-0.96/man1/zoiduser.pod" rel="nofollow noreferrer"><code>Zoidberg</code></a>.  <a href="https://en.wikipedia.org/wiki/REPL" rel="nofollow noreferrer">REPLs</a> (Read Eval Print Loops) make crappy shells because every command must be syntactically correct, and running a program goes from being:</p>
<pre><code>foo arg1 arg2 arg3
</code></pre>
<p>to</p>
<pre><code>system &quot;foo&quot;, &quot;arg1&quot;, &quot;arg2&quot;, &quot;arg3&quot;
</code></pre>
<p>And don't even get me started on trying to do redirection.</p>
<p>So, you need a custom shell (rather than a REPL) that understands commands and redirection and the language you want to use to bind commands together.  I think <code>zoid</code> (the Zoidberg shell) does a pretty good job of it.</p>
<h4> Comment 11643341 Joel Berger: </h4>I have actually fixed some of the major bugs (I am the new maintainer!). Check out <a href="http://p3rl.org/zoiduser" rel="nofollow noreferrer"><code>Zoidberg</code></a> for all your Perl-based shell needs!<br><h4> Comment 4310043 Joel Berger: </h4>Going to give zoid a try. Do you know, is there any amount of a base of people using as their primary shell?<br><h4> Comment 4314837 Chas. Owens: </h4>@Joel I doubt it.  It was last updated on CPAN in 2006.  It is hard to beat <code>bash</code>.  It is ubiquitous, feature complete, and maintained.  Shells like <code>zoid</code> are fun to play with, but I always return to <code>bash</code> or <code>ksh</code>.<br><h4> Comment 4314969 Joel Berger: </h4>Yeah, I also saw that it hasn&#39;t been maintained. I wonder what kind of brushing up it might need, I would be interested using a shell with that kind of power.<br><h4> Comment 132827055 jubilatious1: </h4>Genuine question here: What&#39;s the difference between a Perl-based shell like the Zoidberg shell, and something that comes included with Raku, i.e. the <a href="https://course.raku.org/essentials/running-programs/from-repl/" rel="nofollow noreferrer">Raku REPL</a> ?<br>------------------------------------------------------------------ <br><h3> Answer 9242784 Joel Berger: </h3><p><a href="https://stackoverflow.com/questions/3637668/why-are-scripting-languages-e-g-perl-python-ruby-not-suitable-as-shell-lang/3638038#3638038">These answers</a> inspired me to take over maintenance of the Perl-based shell Zoidberg. After some fixes, it is usable again!</p>
<p>Check out the <a href="http://p3rl.org/zoiduser" rel="nofollow noreferrer">user's guide</a> or install <a href="https://metacpan.org/module/Bundle::Zoidberg" rel="nofollow noreferrer"><code>Bundle::Zoidberg</code></a> using your favorite <a href="https://en.wikipedia.org/wiki/CPAN" rel="nofollow noreferrer">CPAN</a> client.</p>
------------------------------------------------------------------ <br><h3> Answer 7200600 DigitalRoss: </h3><h2>No.</h2>

<hr>

<p><em>No, scripting languages are probably not suitable for shells.</em></p>

<hr>

<p>The problem is the dichotomy between <em>macro languages</em> and, well, everything else.</p>

<p>The shell is in a category with other legacy macro languages such as <a href="http://en.wikipedia.org/wiki/Nroff" rel="noreferrer">nroff</a> and <a href="http://en.wikipedia.org/wiki/M4_%28computer_language%29" rel="noreferrer">m4</a>. In these processors, everything is a string and the processor defines a mapping from input strings to output strings.</p>

<p>Certain boundaries are crossed in both directions in all languages, but it's usually quite clear whether a system's category is <em>macro</em> or, hmm, I'm not aware of an official term ... I will say <em>"a real language".</em></p>

<p>So sure, you <em>could</em> type in all your commands in a language like Ruby, and it might even be a second-best choice to a real shell, but it will never be a macro language. There is too much syntax to respect. It takes too many quotes.</p>

<p>But the macro language has its own issues when you start programming in it, because too many compromises had to be made to get rid of all that syntax. Strings are typed in with no quotes.  Various amounts of magic need to be re-introduced to inject the missing syntax. I did a <kbd>code-golf</kbd> in nroff once, just to be different. It was pretty strange. The source code to big implementations in macro languages is scary.</p>
<h4> Comment 8709031 Muhammad Alkarouri: </h4>Thanks a lot! That is actually the missing point, the exact response to my &quot;I have tried to articulate the reason but am unable to, aside from assuming that the treatment of strings differently in both has something to do with it.&quot;. It will be interesting to find out if any research about macro languages has been done.<br>------------------------------------------------------------------ <br><h3> Answer 4574536 rob: </h3><p>Since both are formally programming languages, what you can do in one, you can do in the other. Actually it is a design emphasis issue. Shell languages are designed for interactive use, while scripting languages aren't.  </p>

<p>The basic difference in the design is the storage of data between commands and the scope of variables. In Bash, etc. you have to jump through hoops to store a value (for example, commands like <code>set a='something'</code>), while in languages like Python you simply use an assignment statement (<code>a = 'something'</code>).  When using the values in a shell language you have to tell the language that your want the value of the variable, while in scripting languages you have to tell the language when you want the immediate value of the string.  This has effects when used interactively.</p>

<p>In a scripting language where <code>ls</code> was defined as a command</p>

<pre><code>a = some_value

ls a*b  
</code></pre>

<p>(What does <code>a</code> mean? Does this mean some_value * (whatever b is) or do you mean
           'a'anystring'b'?.   In a scripting language the default is what is stored in memory for a.)</p>

<pre><code>ls 'a*b'  Now means what the Unix ls a*b means.
</code></pre>

<p>In a Bash-like language</p>

<pre><code>set a=some_value

ls a*b   means what the Unix ls a*b means.

ls $a*b  uses an explicit recall of the value of a.
</code></pre>

<p>Scripting languages make it easy to store and recall values and hard to have a transient scope on a value. Shell languages make it possible to store and recall values, but have a trivially transient scope per command.</p>
<h4> Comment 5022252 Muhammad Alkarouri: </h4>Thanks. That is what I alluded to by &quot;the treatment of strings&quot; in my question, but you explained it better.<br>------------------------------------------------------------------ <br><h3> Answer 3637741 rogerdpack: </h3><p>I think it's a question of parsing.  Shell languages assume by default the normal <code>$ xxx</code> command means you mean a command to run. In Python and Ruby need you to do <em>system(&quot;command&quot;)</em> or what not.</p>
<p>It's not that they're unsuitable, just that nobody has really done it yet; at least I think so. <a href="http://rush.heroku.com/" rel="nofollow noreferrer">Rush</a> is an example attempt in Ruby, and Python has <a href="https://en.wikipedia.org/wiki/IPython" rel="nofollow noreferrer">IPython</a> or something like that.</p>
<h4> Comment 3823219 Muhammad Alkarouri: </h4>Thanks for the link. I have used ipython, and my first impression is that Rush looks a bit better, probably because of the fluent interface. I need to look at it a bit more.<br>------------------------------------------------------------------ <br><h3> Answer 4575203 user559914: </h3><p>Scalability <em>and</em> extensibility? <a href="https://en.wikipedia.org/wiki/Common_Lisp" rel="nofollow noreferrer">Common Lisp</a> (you can even run <a href="https://en.wikipedia.org/wiki/CLISP" rel="nofollow noreferrer">CLISP</a>, and possibly other implementations, <em>as</em> a login shell in Unix environments).</p>
------------------------------------------------------------------ <br><h3> Answer 9242414 peter: </h3><p>For the Windows users, I haven't yet felt the need for <a href="https://en.wikipedia.org/wiki/PowerShell" rel="nofollow noreferrer">PowerShell</a>, because I still use <a href="https://en.wikipedia.org/wiki/Take_Command_Console" rel="nofollow noreferrer">4NT</a> (now <a href="https://en.wikipedia.org/wiki/Take_Command_Console" rel="nofollow noreferrer">Take Command Console</a>) from <a href="https://en.wikipedia.org/wiki/Take_Command_Console" rel="nofollow noreferrer">JP Software</a>. It is a very good shell with lots of programming abilities. So it combines the best of both worlds.</p>
<p>When you take a look at, for example, <a href="https://en.wikipedia.org/wiki/Interactive_Ruby_Shell" rel="nofollow noreferrer">IRB</a> (the <a href="https://en.wikipedia.org/wiki/Ruby_%28programming_language%29" rel="nofollow noreferrer">Ruby</a> interpreter), it must be well possible to extend it with more one-liners to do daily scripted or mass file management and on the minute tasks.</p>
------------------------------------------------------------------ <br><h3> Answer 12874771 Colonel Panic: </h3><p>You beg the question. Not everyone agrees that shell languages are superior. For one, <a href="http://viewsourcecode.org/why/hacking/wearingRubySlippersToWork.html" rel="nofollow">_Why doesn't</a></p>

<blockquote>
  <p>Not long ago a friend asked me how to recursively search his PHP scripts for a string. He had a lot of big binary files and templates in those directories that could have really bogged down a plain grep. I couldn't think of a way to use grep to make this happen, so I figured using find and grep together would be my best bet.</p>

<pre><code>  find . -name "*.php" -exec grep 'search_string' {} \; -print
</code></pre>
  
  <p>Here's the above file search reworked in Ruby:</p>

<pre><code>  Dir['**/*.php'].each do |path|
    File.open( path ) do |f|
      f.grep( /search_string/ ) do |line|
        puts path, ':', line
      end
    end
  end
</code></pre>
  
  <p>Your first reaction may be, "Well, that's quite a bit wordier than the original." And I just have to shrug and let it be. "It's a lot easier to extend," I say. And it works across platforms.</p>
</blockquote>
<h4> Comment 20525218 Voo: </h4>So you just replaced a 60 char script that is reasonably easy to read if you understand the syntax with a 125 char script (ignoring the additional whitespace and newlines you&#39;ll want to make the script actually readable) that isn&#39;t any clearer. Great example of why you don&#39;t want to use python or ruby. 99.999% of all scripts are things with exact specifications (or 1off jobs) that won&#39;t ever be extended. Powershell even has a nice syntax, allows for easy extensibility and is concise for the main job of scripts.<br><h4> Comment 17915229 intuited: </h4><code>find . -name &#39;*.php&#39; | xargs -d \\n grep -l &#39;search_string&#39;</code> will be faster for non-huge files by avoiding N invocations of <code>grep</code>. :)<br><h4> Comment 33304319 Charles Duffy: </h4>@alexis, both <code>xargs</code> (unless given a contrary flag) and <code>find -exec {} +</code> (as opposed to <code>-exec {} \;</code>) will fill out each invocation to the maximum argument length allowed, so no, it&#39;s less than N (where N is the number of items found).<br><h4> Comment 20511010 Joel Berger: </h4>The question isn&#39;t about writing shell-like scripts, its about the language that the shell executes.<br><h4> Comment 37297792 Nate Symer: </h4>The ruby is probably not very cross-platform, note the forward slashes. Forward slashes don&#39;t work on Windows.<br><h4> Comment 25691157 ian: </h4>@Voo &quot;that is reasonably easy to read if you understand the syntax&quot;… and there you destroy your own argument. Aside from that, syntax not only needs to be understood, it also has to be <i>liked</i> if you&#39;re going to choose use it repeatedly when there are competitors. I don&#39;t like Powershell&#39;s syntax, all that camel casing is horrible. YMMV.<br><h4> Comment 26386541 Max Nanasy: </h4>@intuited You can also use <code>find . -name &quot;*.php&quot; -exec grep -l &#39;search_string&#39; {} +</code> to avoid N invocations of <code>grep</code> (although I think the <code>+</code> is non-portable).<br><h4> Comment 33304309 Charles Duffy: </h4>@MaxNanasy, the <code>+</code> version of -exec is, in fact, POSIX compliant.<br>