 <h2> Title: class &lt;&lt; self idiom in Ruby </h2> <h3> randombits, question_id: 2505067 </h3>Score: 1006, Tags: {ruby,metaclass,eigenclass,singleton} <br><p>What does <code>class &lt;&lt; self</code> do in <strong>Ruby</strong>?</p>
<h4> Comment 7770177 Andy: </h4>There is a very nice article about this topic written by Yehuda Katz: <a href="http://yehudakatz.com/2009/11/15/metaprogramming-in-ruby-its-all-about-the-self/" rel="nofollow noreferrer">yehudakatz.com/2009/11/15/&hellip;</a>  and Yugui: <a href="http://yugui.jp/articles/846" rel="nofollow noreferrer">yugui.jp/articles/846</a><br><h4> Comment 57888892 Saman Mohamadi: </h4>Another super nice Article here: <a href="http://www.integralist.co.uk/posts/eigenclass.html" rel="nofollow noreferrer">integralist.co.uk/posts/eigenclass.html</a><br><h4> Comment 58618942 William Entriken: </h4>I am seeing this inside of a module, does that make it different? <a href="https://github.com/ruby/rake/blob/master/lib/rake/rake_module.rb" rel="nofollow noreferrer">github.com/ruby/rake/blob/master/lib/rake/rake_module.rb</a><br><h4> Comment 74732627 Douglas G. Allen: </h4>See <a href="https://github.com/defunkt/metaid/blob/master/metaid.rb" rel="nofollow noreferrer">github.com/defunkt/metaid/blob/master/metaid.rb</a>  It goes with &quot;Seeing Metaclasses Clearly&quot; <a href="http://viewsourcecode.org/why/hacking/seeingMetaclassesClearly.html" rel="nofollow noreferrer">viewsourcecode.org/why/hacking/seeingMetaclassesClearly.html</a><br><h4> Comment 65394755 Aaron: </h4>@FullDecent It does not make a difference as everything in Ruby is an object including modules and classes.<br><h4> Comment 121558013 3limin4t0r: </h4>The ruby-doc documentation can be found <a href="https://ruby-doc.org/core-3.0.2/doc/syntax/modules_and_classes_rdoc.html#label-Singleton+Classes" rel="nofollow noreferrer">here</a>.<br>------------------------------------------------------------------ <br><h3> Answer 2505077 C. K. Young: </h3><p>First, the <code>class &lt;&lt; foo</code> syntax opens up <code>foo</code>'s singleton class (eigenclass). This allows you to specialise the behaviour of methods called on that specific object.</p>

<pre><code>a = 'foo'
class &lt;&lt; a
  def inspect
    '"bar"'
  end
end
a.inspect   # =&gt; "bar"

a = 'foo'   # new object, new singleton class
a.inspect   # =&gt; "foo"
</code></pre>

<hr>

<p>Now, to answer the question: <code>class &lt;&lt; self</code> opens up <code>self</code>'s singleton class, so that methods can be redefined for the current <code>self</code> object (which inside a class or module body is the class or module <em>itself</em>). Usually, this is used to define class/module ("static") methods:</p>

<pre><code>class String
  class &lt;&lt; self
    def value_of obj
      obj.to_s
    end
  end
end

String.value_of 42   # =&gt; "42"
</code></pre>

<p>This can also be written as a shorthand:</p>

<pre><code>class String
  def self.value_of obj
    obj.to_s
  end
end
</code></pre>

<p>Or even shorter:</p>

<pre><code>def String.value_of obj
  obj.to_s
end
</code></pre>

<hr>

<p>When inside a function definition, <code>self</code> refers to the object the function is being called with. In this case, <code>class &lt;&lt; self</code> opens the singleton class for that object; one use of that is to implement a poor man's state machine:</p>

<pre><code>class StateMachineExample
  def process obj
    process_hook obj
  end

private
  def process_state_1 obj
    # ...
    class &lt;&lt; self
      alias process_hook process_state_2
    end
  end

  def process_state_2 obj
    # ...
    class &lt;&lt; self
      alias process_hook process_state_1
    end
  end

  # Set up initial state
  alias process_hook process_state_1
end
</code></pre>

<p>So, in the example above, each instance of <code>StateMachineExample</code> has <code>process_hook</code> aliased to <code>process_state_1</code>, but note how in the latter, it can redefine <code>process_hook</code> (for <code>self</code> only, not affecting other <code>StateMachineExample</code> instances) to <code>process_state_2</code>. So, each time a caller calls the <code>process</code> method (which calls the redefinable <code>process_hook</code>), the behaviour changes depending on what state it's in.</p>
<h4> Comment 2503293 C. K. Young: </h4>@J&#246;rg: +1 for edit (I wish SO provides the ability to upvote edits; oh well). That indeed is the more common use of <code>class &lt;&lt; self</code>, to create class/module methods. I will probably expand on that use of <code>class &lt;&lt; self</code>, as that is a much more idiomatic use.<br><h4> Comment 85166711 Cary Swoveland: </h4>I find the expression, &quot;opens an object&#39;s singleton class&quot;--which I&#39;ve read many times before--vague. To my knowledge, nowhere in the Ruby docs is &quot;opening&quot; a class defined, even though we all have an idea of what it means. Does <code>class &lt;&lt; self</code> mean anything more than the value of <code>self</code> is set equal to the singleton class within the block&#39;s scope?<br><h4> Comment 22561780 Old Pro: </h4>It&#39;s really confusing to refer to <code>a</code>&#39;s <code>singleton_class</code> since <code>a</code>&#39;s class (after changing <code>inspect</code>) is a unique variant of the <code>String</code> class.  If it were changing the singleton <code>String</code> class it would affect all other <code>String</code> instances.  What&#39;s weirder still is that if you later reopen <code>String</code> to redefine <code>inspect</code> then <code>a</code> will still pick up the new changes.<br><h4> Comment 2504686 Marc-Andr&#233; Lafortune: </h4>gsub!(&quot;eigenclass&quot;, &quot;singleton class&quot;), see the upcoming method <a href="http://redmine.ruby-lang.org/repositories/revision/1?rev=27022" rel="nofollow noreferrer">redmine.ruby-lang.org/repositories/revision/1?rev=27022</a><br><h4> Comment 22562164 C. K. Young: </h4>@OldPro I still prefer the name eigenclass, as (I believe) Matz also does. But, can&#39;t please everyone, I guess.<br><h4> Comment 2504845 C. K. Young: </h4>@Marc-Andre: Wow, that was a very recent decision (capitulation? he seemed very reluctant throughout the thread) on Matz&#39;s part. Still, good that there is agreement on what to call it going forward.<br>------------------------------------------------------------------ <br><h3> Answer 35083586 Saman Mohamadi: </h3><p>I found a super simple explanation about <code>class &lt;&lt; self</code> , <code>Eigenclass</code> and different type of methods.</p>

<p>In Ruby, there are three types of methods that can be applied to a class:</p>

<ol>
<li>Instance methods</li>
<li>Singleton methods</li>
<li>Class methods</li>
</ol>

<p>Instance methods and class methods are almost similar to their homonymous in other programming languages.</p>

<pre><code>class Foo  
  def an_instance_method  
    puts "I am an instance method"  
  end  
  def self.a_class_method  
    puts "I am a class method"  
  end  
end

foo = Foo.new

def foo.a_singleton_method
  puts "I am a singletone method"
end
</code></pre>

<p>Another way of accessing an <code>Eigenclass</code>(which includes singleton methods) is with the following syntax (<code>class &lt;&lt;</code>):</p>

<pre><code>foo = Foo.new

class &lt;&lt; foo
  def a_singleton_method
    puts "I am a singleton method"
  end
end
</code></pre>

<p>now you can define a singleton method for <code>self</code> which is the class <code>Foo</code> itself in this context:</p>

<pre><code>class Foo
  class &lt;&lt; self
    def a_singleton_and_class_method
      puts "I am a singleton method for self and a class method for Foo"
    end
  end
end
</code></pre>
<h4> Comment 79720847 Damon Yuan: </h4>actually Singleton methods and Class methods are the same, both of them existing in singleton class. you can use <code>foo.singleton_class.instance_methods(false)</code> to check.<br><h4> Comment 127991994 Quentin Gibson: </h4>In the first coding snippet &quot;singleton&quot; is spelled &quot;singletone&quot;<br>------------------------------------------------------------------ <br><h3> Answer 38041660 BrunoF: </h3><p>Usually, instance methods are global methods. That means they are available in all instances of the class on which they were defined. In contrast, a singleton method is implemented on a single object.</p>
<p>Ruby stores methods in classes and all methods must be associated with a class. The object on which a singleton method is defined is not a class (it is an instance of a class). If only classes can store methods, how can an object store a singleton method? When a singleton method is created, Ruby automatically creates an anonymous class to store that method. These anonymous classes are called metaclasses, also known as singleton classes or eigenclasses. The singleton method is associated with the metaclass which, in turn, is associated with the object on which the singleton method was defined.</p>
<p>If multiple singleton methods are defined within a single object, they are all stored in the same metaclass.</p>
<pre><code>class Zen
end

z1 = Zen.new
z2 = Zen.new

class &lt;&lt; z1
  def say_hello
    puts &quot;Hello!&quot;
  end
end

z1.say_hello    # Output: Hello!
z2.say_hello    # Output: NoMethodError: undefined method `say_hello'…
</code></pre>
<p>In the above example, <code>class &lt;&lt; z1</code> changes the current self to point to the metaclass of the z1 object; then, it defines the say_hello method within the metaclass.</p>
<p>Classes are also objects (instances of the built-in class called Class). Class methods are nothing more than singleton methods associated with a class object.</p>
<pre><code>class Zabuton
  class &lt;&lt; self
    def stuff
      puts &quot;Stuffing zabuton…&quot;
    end
  end
end
</code></pre>
<p>All objects may have metaclasses. That means classes can also have metaclasses. In the above example, class &lt;&lt; self modifies self so it points to the metaclass of the Zabuton class. When a method is defined without an explicit receiver (the class/object on which the method will be defined), it is implicitly defined within the current scope, that is, the current value of self. Hence, the stuff method is defined within the metaclass of the Zabuton class. The above example is just another way to define a class method. IMHO, it's better to use the def self.my_new_clas_method syntax to define class methods, as it makes the code easier to understand. The above example was included so we understand what's happening when we come across the class &lt;&lt; self syntax.</p>
<p>Additional info can be found at <a href="http://www.zenruby.info/2016/06/ruby-classes.html" rel="noreferrer">this post about Ruby Classes</a>.</p>
<h4> Comment 117395548 Richard Logwood: </h4>after review of various sources on this question, your answer really clarified everything perfectly. Thank You!<br><h4> Comment 135170630 MDickten: </h4>I wish somebody could give a good example of how and where this mechanism is really needed. All examples I&#39;ve seen are of the foobar or puts &quot;bla&quot; kind. I can&#39;t imagine a situation where I&#39;d really <i>need</i> this. (I came across it in some old code I need to maintain and I really don&#39;t know why the original author did it this way other than to prove he knew <code>class &lt;&lt; self</code>.)<br><h4> Comment 136495569 BernardK: </h4>@MDickten Suppose you want to count the number of times a class is instantiated. You define a class-level <code>@count = 0</code> variable (outside any method). There are two ways to access it : <code>def self.count; @count; end</code> or <code>class &lt;&lt; self; attr_accessor :count; end</code>. In initialize : <code>self.class.count += 1</code>. Outside the class : <code>puts &quot;@count=#{SomeClass.count}&quot;</code>. A more sophisticated example in <a href="https://pragprog.com/titles/ruby5/programming-ruby-3-2-5th-edition/" rel="nofollow noreferrer">pragprog.com/titles/ruby5/programming-ruby-3-2-5th-edition</a><br><h4> Comment 136495708 BernardK: </h4>@MDickten This is a contrived example because <code>@@count</code> would be easier in this case. The most frequent uses I have seen is defining class methods. Instead of repeating <code>self.</code> in each def, (<code>def self.m1</code>, <code>def self.m2</code>, ...) they use the <code>class &lt;&lt; self</code> trick to change self to the singleton class of the class, then simple <code>def</code> (<code>def m1</code>, <code>def m2</code>, ...) define singleton methods (commonly called class methods) in the singleton class.<br><h4> Comment 136495936 BernardK: </h4>@MDickten See also <a href="https://dev.to/vitaliipaprotskyi/what-does-class-self-actually-do-in-ruby-2on1" rel="nofollow noreferrer">dev.to/vitaliipaprotskyi/&hellip;</a><br><h4> Comment 130901834 otavio1992: </h4>Perfect explanation. Thank you!<br>------------------------------------------------------------------ <br><h3> Answer 33673263 Evgenia Karunus: </h3><h3>What class &lt;&lt; thing does:</h3>
<pre><code>class Hi
  self #=&gt; Hi
  class &lt;&lt; self #same as 'class &lt;&lt; Hi'
    self #=&gt; #&lt;Class:Hi&gt;
    self == Hi.singleton_class #=&gt; true
  end
end
</code></pre>
<p><strong>[it makes</strong> <code>self == thing.singleton_class</code> <strong>in the context of its block]</strong>.</p>
<hr />
<h3>What is thing.singleton_class?</h3>
<pre><code>hi = String.new
def hi.a
end

hi.class.instance_methods.include? :a #=&gt; false
hi.singleton_class.instance_methods.include? :a #=&gt; true
</code></pre>
<p><code>hi</code> object inherits its <code>#methods</code> from its <code>#singleton_class.instance_methods</code> and then from its <code>#class.instance_methods</code>.<br />
Here we gave <code>hi</code>'s <strong>singleton class</strong> instance method <code>:a</code>. It could have been done with <strong>class &lt;&lt; hi</strong> instead.<br />
<code>hi</code>'s <code>#singleton_class</code> has all instance methods <code>hi</code>'s <code>#class</code> has, and possibly some more (<code>:a</code> here).</p>
<p><strong>[instance methods of thing's</strong> <code>#class</code> <strong>and</strong> <code>#singleton_class</code> <strong>can be applied directly to thing. when ruby sees thing.a, it first looks for :a method definition in thing.singleton_class.instance_methods and then in thing.class.instance_methods]</strong></p>
<hr />
<p>By the way - they call object's <strong>singleton class</strong> == <strong>metaclass</strong> == <strong>eigenclass</strong>.</p>
------------------------------------------------------------------ <br><h3> Answer 39518363 artamonovdev: </h3><p>А <strong>singleton method</strong> is a method that is defined only for a single object. </p>

<p>Example:</p>

<pre><code>class SomeClass
  class &lt;&lt; self
    def test
    end
  end
end

test_obj = SomeClass.new

def test_obj.test_2
end

class &lt;&lt; test_obj
  def test_3
  end
end

puts "Singleton's methods of SomeClass"
puts SomeClass.singleton_methods
puts '------------------------------------------'
puts "Singleton's methods of test_obj"
puts test_obj.singleton_methods
</code></pre>

<p>Singleton's methods of SomeClass</p>

<p><strong><em>test</em></strong></p>

<hr>

<p>Singleton's methods of test_obj</p>

<p><strong><em>test_2</em></strong></p>

<p><strong><em>test_3</em></strong></p>
------------------------------------------------------------------ <br><h3> Answer 43849015 Douglas G. Allen: </h3><p>In fact if you write any C extensions for your Ruby projects there is really only one way to define a Module method.</p>

<pre><code>rb_define_singleton_method
</code></pre>

<p>I know this self business just opens up all kinds of other questions so you could do better by searching each part.</p>

<p>Objects first.</p>

<pre><code>foo = Object.new
</code></pre>

<p>Can I make a method for foo?</p>

<p>Sure</p>

<pre><code>def foo.hello
 'hello'
end
</code></pre>

<p>What do I do with it?</p>

<pre><code>foo.hello
 ==&gt;"hello"
</code></pre>

<p>Just another object.</p>

<pre><code>foo.methods
</code></pre>

<p>You get all the Object methods plus your new one.</p>

<pre><code>def foo.self
 self
end

foo.self
</code></pre>

<p>Just the foo Object.</p>

<p>Try to see what happens if you make foo from other Objects like Class and Module. The examples from all the answers are nice to play with but you have to work with different ideas or concepts to really understand what is going on with the way the code is written. So now you have lots of terms to go look at.</p>

<p>Singleton,
Class,
Module,
self,
Object,
and Eigenclass was brought up but Ruby doesn't name Object Models that way. It's more like Metaclass.
Richard or __why shows you the idea here.
<a href="http://viewsourcecode.org/why/hacking/seeingMetaclassesClearly.html" rel="nofollow noreferrer">http://viewsourcecode.org/why/hacking/seeingMetaclassesClearly.html</a>
And if the blows you away then try looking up Ruby Object Model in search.
Two videos that I know of on YouTube are Dave Thomas and Peter Cooper. They try to explain that concept too. It took Dave a long time to get it so don't worry.
I'm still working on it too. Why else would I be here?
Thanks for your question.
Also take a look at the standard library. It has a Singleton Module just as an FYI.</p>

<p>This is pretty good.
<a href="https://www.youtube.com/watch?v=i4uiyWA8eFk" rel="nofollow noreferrer">https://www.youtube.com/watch?v=i4uiyWA8eFk</a></p>
