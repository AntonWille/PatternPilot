 <h2> Title: Begin, Rescue and Ensure in Ruby? </h2> <h3> Lloyd Powell, question_id: 2191632 </h3>Score: 625, Tags: {ruby-on-rails,ruby,exception,error-handling} <br><p>I've recently started programming in Ruby, and I am looking at exception handling.</p>

<p>I was wondering if <code>ensure</code> was the Ruby equivalent of <code>finally</code> in C#? Should I have:</p>

<pre><code>file = File.open("myFile.txt", "w")

begin
  file &lt;&lt; "#{content} \n"
rescue
  #handle the error here
ensure
  file.close unless file.nil?
end
</code></pre>

<p>or should I do this?</p>

<pre><code>#store the file
file = File.open("myFile.txt", "w")

begin
  file &lt;&lt; "#{content} \n"
  file.close
rescue
  #handle the error here
ensure
  file.close unless file.nil?
end
</code></pre>

<p>Does <code>ensure</code> get called no matter what, even if an exception isn't raised?</p>
<h4> Comment 92236735 Nowaker: </h4>Neither is good. As a rule, when dealing with external resources, you <b>always</b> want the resource opening` to be inside the <code>begin</code> block.<br>------------------------------------------------------------------ <br><h3> Answer 2191698 Farrel: </h3><p>If you want to ensure a file is closed you should use the block form of <code>File.open</code>:</p>

<pre><code>File.open("myFile.txt", "w") do |file|
  begin
    file &lt;&lt; "#{content} \n"
  rescue
  #handle the error here
  end
end
</code></pre>
<h4> Comment 20479852 rogerdpack: </h4>I guess if you don&#39;t want to handle the error but just raise it, and close the file handle, you don&#39;t need the begin rescue here?<br>------------------------------------------------------------------ <br><h3> Answer 2192010 J&#246;rg W Mittag: </h3><p>Yes, <code>ensure</code> ensures that the code is always evaluated. That's why it's called <code>ensure</code>. So, it is equivalent to Java's and C#'s <code>finally</code>.</p>
<p>The general flow of <code>begin</code>/<code>rescue</code>/<code>else</code>/<code>ensure</code>/<code>end</code> looks like this:</p>
<pre><code>begin
  # something which might raise an exception
rescue SomeExceptionClass =&gt; some_variable
  # code that deals with some exception
rescue SomeOtherException =&gt; some_other_variable
  # code that deals with some other exception
else
  # code that runs only if *no* exception was raised
ensure
  # ensure that this code always runs, no matter what
  # does not change the final value of the block
end
</code></pre>
<p>You can leave out <code>rescue</code>, <code>ensure</code> or <code>else</code>. You can also leave out the variables in which case you won't be able to inspect the exception in your exception handling code. (Well, you can always use the global exception variable to access the last exception that was raised, but that's a little bit hacky.) And you can leave out the exception class, in which case all exceptions that inherit from <code>StandardError</code> will be caught. (Please note that this does not mean that <em>all</em> exceptions are caught, because there are exceptions which are instances of <code>Exception</code> but not <code>StandardError</code>. Mostly very severe exceptions that compromise the integrity of the program such as <code>SystemStackError</code>, <code>NoMemoryError</code>, <code>SecurityError</code>, <code>NotImplementedError</code>, <code>LoadError</code>, <code>SyntaxError</code>, <code>ScriptError</code>, <code>Interrupt</code>, <code>SignalException</code> or <code>SystemExit</code>.)</p>
<p>Some blocks form implicit exception blocks. For example, method definitions are implicitly also exception blocks, so instead of writing</p>
<pre><code>def foo
  begin
    # ...
  rescue
    # ...
  end
end
</code></pre>
<p>you write just</p>
<pre><code>def foo
  # ...
rescue
  # ...
end
</code></pre>
<p>or</p>
<pre><code>def foo
  # ...
ensure
  # ...
end
</code></pre>
<p>The same applies to <code>class</code> definitions and <code>module</code> definitions.</p>
<p>However, in the specific case you are asking about, there is actually a much better idiom. In general, when you work with some resource which you need to clean up at the end, you do that by passing a block to a method which does all the cleanup for you. It's similar to a <code>using</code> block in C#, except that Ruby is actually powerful enough that you don't have to wait for the high priests of Microsoft to come down from the mountain and graciously change their compiler for you. In Ruby, you can just implement it yourself:</p>
<pre><code># This is what you want to do:
File.open('myFile.txt', 'w') do |file|
  file.puts content
end

# And this is how you might implement it:
def File.open(filename, mode='r', perm=nil, opt=nil)
  yield filehandle = new(filename, mode, perm, opt)
ensure
  filehandle&amp;.close
end
</code></pre>
<p>And what do you know: this is <em>already</em> available in the core library as <code>File.open</code>. But it is a general pattern that you can use in your own code as well, for implementing any kind of resource cleanup (à la <code>using</code> in C#) or transactions or whatever else you might think of.</p>
<p>The only case where this doesn't work, if acquiring and releasing the resource are distributed over different parts of the program. But if it is localized, as in your example, then you can easily use these resource blocks.</p>
<hr />
<p>BTW: in modern C#, <code>using</code> is actually superfluous, because you can implement Ruby-style resource blocks yourself:</p>
<pre class="lang-csharp prettyprint-override"><code>class File
{
    static T open&lt;T&gt;(string filename, string mode, Func&lt;File, T&gt; block)
    {
        var handle = new File(filename, mode);
        try
        {
            return block(handle);
        }
        finally
        {
            handle.Dispose();
        }
    }
}

// Usage:

File.open(&quot;myFile.txt&quot;, &quot;w&quot;, (file) =&gt;
{
    file.WriteLine(contents);
});
</code></pre>
<h4> Comment 62962704 MatzFan: </h4>+1 for &quot;Some blocks form implicit exception blocks.&quot; I&#39;d still be using &#39;begin&#39; in method defs if it wasn&#39;t for reading this - &amp; Rubocop :)<br><h4> Comment 30691155 Chris: </h4>Note that, although the <code>ensure</code> statements are executed last, they are not the return value.<br><h4> Comment 41492653 Dennis: </h4>I love seeing rich contributions like this on SO. It goes above and beyond what the OP asked such that it applies to many more developers, yet is still on topic. I learned a few things from this answer + edits. Thank you for not just writing &quot;Yes, <code>ensure</code> gets called no matter what.&quot;<br><h4> Comment 48199404 Martin Konecny: </h4>@Teddy: ensure is guaranteed to begin executing, not guaranteed to complete. Your example is overkill - a simple exception inside the ensure block will cause it to exit as well.<br><h4> Comment 44010735 Teddy: </h4>Note, that ensure is NOT guaranteed to complete. Take the case of where you have a begin/ensure/end inside of a thread, and then you call Thread.kill when the first line of the ensure block is being called. This will cause the rest of the ensure to not execute.<br><h4> Comment 52086689 Mashmagar: </h4>Please note that the C# example doesn&#39;t remove the need for <code>using</code>. The <code>open</code> method still needs to do cleanup. The example just does this the verbose (and not 100% bullet-proof) way instead of using the <code>using</code> shorthand. I recommend <code>using</code> whenever possible in place of <code>try-finally</code>.<br><h4> Comment 53650831 EdvardM: </h4>also note that there are no guarantees ensure is called. I&#39;m serious. A power outage / hardware error / os crash can happen, and if your software is critical, that needs to be  considered too.<br><h4> Comment 66554847 Casey: </h4>I don&#39;t know that it makes sense to say <code>using</code> is &quot;superfluous;&quot; its whole point is to be a nicer way of writing out the try - finally block you&#39;ve written.<br><h4> Comment 66555408 Casey: </h4>Oh.  Well this seems to me like trying to write Ruby in C# more than solving a real problem that the traditional C# model doesn&#39;t.<br><h4> Comment 107064710 ryan2johnson9: </h4>But the ensure statement can return a value if you want as in <code>def test     begin       144&#47;0     rescue StandardError =&gt;e       77     ensure       puts &quot;in ensure&quot;       return 66     end   end</code> this will return <code>66</code> not <code>77</code>, without the <code>return 66</code> the method returns <code>77</code><br><h4> Comment 48447910 Teddy: </h4>@MartinKonecny That&#39;s what I said... True though, my example is overkill.<br><h4> Comment 34246972 Automatico: </h4>Want to add that you can have a catch-all to display every exception type by doing this: <code>begin ... rescue Exception =&gt; e ... puts e.message; puts e.backtrace.inspect ... end</code>.<br><h4> Comment 66554993 J&#246;rg W Mittag: </h4>@Casey: what I&#39;m getting at is that in a sufficiently powerful language, you can write <code>using</code> as a library method, and don&#39;t need a language construct. In fact, as of C♯ 3, you <i>can</i> write <code>using</code> as a library method taking an <code>Action&lt;T&gt;</code> or <code>Func&lt;T, R&gt;</code> (where <code>T : IDisposable</code>) and centralizing the <code>try</code>/<code>catch</code> in one single place in the library. I wrote a specific <code>File.open</code> method, but you could write a more generic <code>Object.using</code> method instead, which takes the resource as an argument.<br><h4> Comment 122406669 Michael F: </h4>Note that the <code>ensure</code> statements are executed even when the method implicitly or explicitly returns (counts towards &quot;no matter what&quot;).<br><h4> Comment 133803852 gabriel: </h4>Here is a case where <code>ensure</code> is not executed  ``` class CustomException &lt; StandardError; end    begin   nil.nil rescue CustomException =&gt; e     puts &quot;custom exception&quot; ensure     puts &quot;never on earth&quot; end ```<br><h4> Comment 133815028 J&#246;rg W Mittag: </h4>@gabriel: I get <code>never on earth</code> printed to stdout and then the exception message <code>undefined method `nil&#39; for nil:NilClass (NoMethodError)</code>, just as I would expect.<br><h4> Comment 135365032 iconoclast: </h4>wow this brace style causes me physical pain<br>------------------------------------------------------------------ <br><h3> Answer 2191649 Milan Novota: </h3><p>Yes, <code>ensure</code> is called in any circumstances. For more information see "<a href="http://www.ruby-doc.org/docs/ProgrammingRuby/html/tut_exceptions.html" rel="nofollow noreferrer">Exceptions, Catch, and Throw</a>" of the Programming Ruby book and search for "ensure".</p>
------------------------------------------------------------------ <br><h3> Answer 13121490 alup: </h3><p>FYI, even if an exception is re-raised in the <code>rescue</code> section, the <code>ensure</code> block will be executed before the code execution continues to the next exception handler. For instance:</p>

<pre><code>begin
  raise "Error!!"
rescue
  puts "test1"
  raise # Reraise exception
ensure
  puts "Ensure block"
end
</code></pre>
------------------------------------------------------------------ <br><h3> Answer 21301907 kuboon: </h3><p>This is why we need <code>ensure</code>:</p>

<pre><code>def hoge
  begin
    raise
  rescue  
    raise # raise again
  ensure  
    puts 'ensure' # will be executed
  end  
  puts 'end of func' # never be executed
end  
</code></pre>
------------------------------------------------------------------ <br><h3> Answer 2191703 Chris McCauley: </h3><p>Yes, <code>ensure</code> like <code>finally</code> <b>guarantees that the block will be executed</b>. This is very useful for making sure that critical resources are protected e.g. closing a file handle on error, or releasing a mutex.</p>
<h4> Comment 92236778 Nowaker: </h4>Except in his/her case, there&#39;s no guarantee for the file to be closed, because <code>File.open</code> part is NOT inside the begin-ensure block. Only <code>file.close</code> is but it&#39;s not enough.<br>------------------------------------------------------------------ <br><h3> Answer 2191709 Aaron Qian: </h3><p>Yes, <code>ensure</code> ENSURES it is run every time, so you don't need the <code>file.close</code> in the <code>begin</code> block.</p>

<p>By the way, a good way to test is to do:</p>

<pre><code>begin
  # Raise an error here
  raise "Error!!"
rescue
  #handle the error here
ensure
  p "=========inside ensure block"
end
</code></pre>

<p>You can test to see if "=========inside ensure block" will be printed out when there is an exception.
Then you can comment out the statement that raises the error and see if the <code>ensure</code> statement is executed by seeing if anything gets printed out.</p>
