 <h2> Title: Determining type of an object in ruby </h2> <h3> Zippy Zeppoli, question_id: 15769739 </h3>Score: 476, Tags: {ruby,types} <br><p>I'll use python as an example of what I'm looking for (you can think of it as pseudocode if you don't know Python):</p>

<pre><code>&gt;&gt;&gt; a = 1
&gt;&gt;&gt; type(a)
&lt;type 'int'&gt;
</code></pre>

<p>I know in ruby I can do :</p>

<pre><code>1.9.3p194 :002 &gt; 1.class
 =&gt; Fixnum 
</code></pre>

<p>But is this the proper way to determine the type of the object?</p>
<h4> Comment 31364533 ocodo: </h4>Since we&#39;re really talking about Ruby here, Types and Classes are synonymous, there&#39;s no debate about this, all values are Objects. So for anyone simply talking about Ruby, Classes <i>are</i> Types. - ref: <a href="http://www.ruby-lang.org/en/about/" rel="nofollow noreferrer">ruby-lang.org/en/about</a><br><h4> Comment 31363253 ocodo: </h4>@J&#246;rgWMittag - in Ruby everything is an Object, so there&#39;s no primitive types as there are in Python (int, long, boolean etc.) As a result within Ruby, classes are type definitions.  This is not limited to Ruby either, the word class and type are synonymous in several other languages, and more broadly in OOP theory.<br><h4> Comment 22446120 Dave Newton: </h4>@J&#246;rgWMittag Yet AFAICR that&#39;s what ` type` does in Python, although my memory is fuzzy. You&#39;d need <code>isinstance</code>  or check for responds. But simply saying &quot;NOES!!!&quot; isn&#39;t really helpful, now, is it? Instead consider being educational.<br><h4> Comment 22447385 Dave Newton: </h4>@J&#246;rgWMittag While I&#39;m sympathetic, OP provided code to mimic in Ruby. Unless you actually <i>educate</i> the OP saying noes isn&#39;t helpful, IMO. And even if you did, it would likely be informational only, since OP defined what s/he wanted thru code.<br><h4> Comment 34494642 Kyle Strand: </h4>@J&#246;rgWMittag That essay is quite informative so far, and I&#39;ll read the rest of it when I get a chance. In particular, Cook seems to articulate quite well (and with much more background knowledge than I have) why it&#39;s incorrect to claim (as one of my professors did) that Python, Ruby, and other dynamically-typed languages &quot;aren&#39;t <i>really</i> object-oriented&quot; (what he probably meant, without realizing it, was that they weren&#39;t ADT-oriented). But Ruby isn&#39;t statically typed, so it doesn&#39;t have ADTs in the sense Cook is describing, so your objections on the basis of that distinction aren&#39;t helpful.<br><h4> Comment 38727401 nawfal: </h4>possible duplicate of <a href="http://stackoverflow.com/questions/3028243/check-if-ruby-object-is-a-boolean">Check if Ruby object is a Boolean</a><br><h4> Comment 31364259 J&#246;rg W Mittag: </h4>@Slomojo: in OO, the type of an object is the protocol it speaks. In Ruby, classed don&#39;t define protocols, they define <i>implementations</i> of protocols. Plus, they prescribe a particular data representation. But one of the basic tenets of OO is <i>representation independence</i>. Yes, in Java, C# and C++ classes are also types, but if you use classes as types you are not doing OO, you are doing ADT-oriented programming. (There&#39;s nothing wrong with that, but Ruby is OO, not ADT-oriented.) Only if you use interfaces as types are you doing OO. (That&#39;s no surprise, after all Java&#39;s interfaces are )<br><h4> Comment 31364305 J&#246;rg W Mittag: </h4>(inspired by Objective-C&#39;s protocols which in turn are inspired by Smalltalk&#39;s idea of protocols.) This is all explained clearly in <a href="http://WCook.BlogSpot.Com/" rel="nofollow noreferrer">William R. Cook</a>&#39;s paper <a href="http://CS.UTexas.Edu/~wcook/Drafts/2009/essay.pdf" rel="nofollow noreferrer"><i>On Understanding Data Abstraction, Revisited</i></a>, where, among other things, he explains the fundamental difference between classes and types.<br><h4> Comment 22415656 Arup Rakshit: </h4>yes1 in ruby this is the way <code>&lt;object name&gt;.class</code>.<br><h4> Comment 22444827 J&#246;rg W Mittag: </h4>@iAmRubuuu: No, it is not. <code>#class</code> returns the <i>class</i>, not the <i>type</i>. That&#39;s why it is <i>called</i> <code>#class</code>, after all. The OP asked about the type, not the class. Those two are completely different.<br><h4> Comment 22444846 J&#246;rg W Mittag: </h4>@DaveNewton: The OP asked about the type, not the class. Those two are completely different. <code>#class</code> returns the <i>class</i>, not the <i>type</i>.<br><h4> Comment 22486696 J&#246;rg W Mittag: </h4>@DaveNewton: In the question, the OP asks about the type, not the class. In the subject line, the OP asks about the type, not the class. In the code sample, the OP asks about the type, not the class. I don&#39;t really see how you can conclude from that that the OP asks about the class, not the type.<br><h4> Comment 22487172 Dave Newton: </h4>@J&#246;rgWMittag And you still refuse to educate the OP or provide a correct answer... Why? In any case, what do you believe Python&#39;s ` type` method returns?<br>------------------------------------------------------------------ <br><h3> Answer 15769829 tadman: </h3><p>The proper way to determine the "type" of an object, which is a wobbly term in the Ruby world, is to call <code>object.class</code>.</p>

<p>Since classes can inherit from other classes, if you want to determine if an object is "of a particular type" you might call <code>object.is_a?(ClassName)</code> to see if <code>object</code> is of type <code>ClassName</code> or derived from it.</p>

<p>Normally type checking is not done in Ruby, but instead objects are assessed based on their ability to respond to particular methods, commonly called "<a href="http://en.wikipedia.org/wiki/Duck_typing" rel="noreferrer">Duck typing</a>". In other words, if it responds to the methods you want, there's no reason to be particular about the type.</p>

<p>For example, <code>object.is_a?(String)</code> is too rigid since another class might implement methods that convert it into a string, or make it behave identically to how String behaves. <code>object.respond_to?(:to_s)</code> would be a better way to test that the object in question does what you want.</p>
<h4> Comment 27140701 Teemu Leisti: </h4>@J&#246;rg W Mittag: I disagree. &quot;Class&quot; and &quot;processor speed&quot; (to pick an example) are two completely different concepts, but &quot;class&quot; and &quot;type&quot; are closely related concepts. For instance, here&#39;s what <a href="http://en.wikipedia.org/wiki/Class_%28computer_programming%29" rel="nofollow noreferrer">the Wikipedia article on Class</a> says: &quot;In object-oriented programming, a class is a construct that is used to define a distinct type.&quot; tadman was being helpful to the questioner.<br><h4> Comment 27143877 tadman: </h4>@J&#246;rgWMittag In Ruby the closest thing to <code>typeof</code> from C, JavaScript and others is <code>class</code>. There&#39;s no formal protocol system in Ruby like there is in other languages, Objective-C being the closest Smalltalk relative with that. If you&#39;re defining &quot;type&quot; as &quot;object which responds to a particular set of methods with acceptable results&quot; then there&#39;s really no way to assert that. It&#39;s just too loose. Most of the time in Ruby when referring to an object&#39;s type, it&#39;s understood you&#39;re talking about the class. I did use the term type in quotation marks for that very reason.<br><h4> Comment 22426575 J&#246;rg W Mittag: </h4>-1. <code>#class</code> does <i>not</i> return the type of the object, it returns its <i>class</i>. The name should be a dead giveaway. Class and Type are two <i>completely</i> different concepts in OO.<br><h4> Comment 27144621 Teemu Leisti: </h4>@J&#246;rg W Mittag: I continue to assert that &quot;class&quot; and &quot;type&quot; are certainly not completely different concepts in OO, as demonstrated by the quote. (Also: how do you declare a variable in Java? By giving <i>either</i> the <i>type</i> or the <i>class</i> of the variable, followed by its name: &quot;<code>int i</code>&quot; or &quot;<code>Integer j</code>&quot;.) tadman answered the question in a way that seemed to satisfy both the questioner and the general audience, while clarifying the terminology Ruby uses. I have no interest in getting into academic hair-splitting over the finer points of object-oriented terminology, so please have the last word.<br><h4> Comment 27145684 tadman: </h4>@TeemuLeisti Most of the trouble here comes from the fact that <i>everything</i> in Ruby is an object, and so has a class, whereas in virtually every other language there&#39;s primitive <i>types</i> which are not objects and have no class, in contrast to objects which do. When there&#39;s no such thing as a pure type, and no way to formally define one, the meaning becomes especially hazy in the Ruby world. Matz is not strictly adhering to any particular school of thought here other than his own.<br><h4> Comment 86683195 Alexander Luna: </h4>@J&#246;rgWMittag I read the essay you posted and the problem is that ruby has no types or (ADTs) as mentioned in the paper. Your statement that &quot;Types&quot; and &quot;Classes&quot; are completely different is wrong in this case because in Ruby everything is a class even what you would call types. Integers, Strings, Floats, etc. are all classes in Ruby. Which is why tadman is right. The CLOSEST you can get to type checking is using the class as a reference. In Javascript, C, C++, etc. your statement would have been 100% accurate and valid because those languages do have both &quot;Classes&quot; and &quot;ADTs&quot;.<br><h4> Comment 27144018 J&#246;rg W Mittag: </h4>@TeemuLeisti: This has been well understood since at least the 1970s. See for example <i>User-defined types and procedural data structures as complementary approaches to data abstraction</i> by J. C. Reynolds in New Advances in Algorithmic Languages, INRIA, 1975 or <a href="http://www.cs.utexas.edu/~wcook/Drafts/2009/essay.pdf" rel="nofollow noreferrer"><i>On Understanding Data Abstraction, Revisited</i> by William R.Cook</a><br><h4> Comment 27143276 J&#246;rg W Mittag: </h4>@TeemuLeisti: That information is just plain wrong. Classes define <i>Representations</i>, Protocols define <i>Types</i>. The defining characteristic of Object-Orientation is that a single type can have multiple representations, i.e. that a single protocol can be provided by multiple classes. For example, in Ruby, the <code>IO</code> <i>type</i> is implemented by both the <code>IO</code> <i>class</i> and the <code>StringIO</code> <i>class</i>. The <code>Enumerable</code> <i>type</i> has a single method <code>each</code>, whereas the <code>Enumerable</code> <i>class</i> (actually <i>mixin</i>) has every method <i>except</i> <code>each</code>.<br><h4> Comment 123458202 Sean Champ: </h4>When contrasting the name of a type to any object implementing the type, imo the obj.instance_of?(name) example - such as provided below - might serve to address the question succinctly?<br><h4> Comment 135318834 Aiden Cullo: </h4>The use of the term &#39;wobbly&#39; is confusing and unclear. I think i understand what you&#39;re trying to say (ambiguous?), but it muddles your answer. Unless there is an accepted interpretation I&#39;m unaware of.<br><h4> Comment 135331780 tadman: </h4>@AidenCullo It&#39;s something that means &quot;unstable, unpredictable, not dependable&quot;, and is common use, at least in British-flavoured English.<br><h4> Comment 135332327 Aiden Cullo: </h4>@tadman it&#39;s not in the dictionary with that definition. I think it is too much of slang for SO. I can barely understand what is meant, and i&#39;m a native speaker. Think about non-native speakers, and english speakers not from britain.<br><h4> Comment 135332349 tadman: </h4>@AidenCullo You&#39;re welcome to take it up on the Stack Exchange language site but I&#39;m leaving it as-is here, as it adds flavour. That it took ten years for someone to point this out is suggesting, at least to me, that it&#39;s fine.<br>------------------------------------------------------------------ <br><h3> Answer 15770006 Arup Rakshit: </h3><p>you could also try: <a href="http://ruby-doc.org/core-2.0/Object.html#method-i-instance_of-3F"><code>instance_of?</code></a></p>

<pre><code>p 1.instance_of? Fixnum    #=&gt; True
p "1".instance_of? String  #=&gt; True
p [1,2].instance_of? Array #=&gt; True
</code></pre>
------------------------------------------------------------------ <br><h3> Answer 15769862 Stuart M: </h3><p>Oftentimes in Ruby, you don't actually care what the object's class is, per se, you just care that it responds to a certain method. This is known as <a href="http://en.wikipedia.org/wiki/Duck_typing">Duck Typing</a> and you'll see it in all sorts of Ruby codebases.</p>

<p>So in many (if not most) cases, its best to use Duck Typing using <a href="http://ruby-doc.org/core-2.0/Object.html#method-i-respond_to-3F"><code>#respond_to?(method)</code></a>:</p>

<pre><code>object.respond_to?(:to_i)
</code></pre>
<h4> Comment 110295335 R. Rinc&#243;n: </h4>@user566245 well it responds_to?(:the_question), but like you said it doesn&#39;t answer the question, just gives related information. Pretty sure answers need to answer the question.<br><h4> Comment 53336616 user566245: </h4>valid point. doesn&#39;t answer the question but hits the spirit of the question.<br>------------------------------------------------------------------ <br><h3> Answer 40980173 Douglas G. Allen: </h3><p>I would say &quot;yes&quot;.
Matz had said something like this in one of his talks,
&quot;Ruby objects have no types.&quot;
Not all of it but the part that he is trying to get across to us.
Why would anyone have said
&quot;Everything is an Object&quot; then?
To add he said &quot;Data has Types not objects&quot;.</p>
<p><a href="https://www.youtube.com/watch?v=1l3U1X3z0CE" rel="noreferrer">RubyConf 2016 - Opening Keynote by Yukihiro 'Matz' Matsumoto
</a></p>
<p>But Ruby doesn't care as much about the type of object as the class.
We use classes, not types. All data, then, has a class.</p>
<pre><code>12345.class

'my string'.class
</code></pre>
<p>Classes may also have ancestors</p>
<pre><code>Object.ancestors
</code></pre>
<p>They also have meta classes but I'll save you the details on that.</p>
<p>Once you know the class then you'll be able to lookup what methods you may use for it. That's where the &quot;data type&quot; is needed.
If you really want to get into details the look up...</p>
<p>&quot;The Ruby Object Model&quot;</p>
<p>This is the term used for how Ruby handles objects. It's all internal so you don't really see much of this but it's nice to know. But that's another topic.</p>
<p>Yes! The class is the data type. Objects have classes and data has types. So if you know about data bases then you know there are only a finite set of types.</p>
<p>text blocks
numbers</p>
<h4> Comment 75307667 Dorian: </h4>For instance, <code>Object.ancestors # =&gt; [Object, Kernel, BasicObject]</code><br>------------------------------------------------------------------ <br><h3> Answer 63079211 Fazal Ur Rehman Fazal: </h3><p>variable_name.class</p>
<p>Here variable name is &quot;a&quot;
<code>a.class</code></p>
------------------------------------------------------------------ <br><h3> Answer 71509032 shakib: </h3><p>every variable have a prop with name class. if you print it, it will tell you what type it is. so do like this:</p>
<pre><code>puts a.class
</code></pre>
