 <h2> Title: How to remove a key from Hash and get the remaining hash in Ruby/Rails? </h2> <h4> Misha Moroshko, question_id: 6227600 </h4>Score: 681, Tags: {ruby-on-rails,ruby,ruby-on-rails-3,hashmap,ruby-hash} <br><p>To add a new pair to Hash I do:</p>

<pre><code>{:a =&gt; 1, :b =&gt; 2}.merge!({:c =&gt; 3})   #=&gt; {:a =&gt; 1, :b =&gt; 2, :c =&gt; 3}
</code></pre>

<p>Is there a similar way to delete a key from Hash ?</p>

<p>This works:</p>

<pre><code>{:a =&gt; 1, :b =&gt; 2}.reject! { |k| k == :a }   #=&gt; {:b =&gt; 2}
</code></pre>

<p>but I would expect to have something like:</p>

<pre><code>{:a =&gt; 1, :b =&gt; 2}.delete!(:a)   #=&gt; {:b =&gt; 2}
</code></pre>

<p>It is important that the returning value will be the remaining hash, so I could do things like:</p>

<pre><code>foo(my_hash.reject! { |k| k == my_key })
</code></pre>

<p>in one line.</p>
<h4> dbryson, Id: 7255475 Score: 1: </h4>You can always extend (open at runtime) the built in Hash to add this custom method if you really need it.<br><h4> B Seven, Id: 114076041 Score: 0: </h4>Ruby 3 will have this. <a href="https://www.ruby-lang.org/en/news/2020/09/25/ruby-3-0-0-preview1-released/" rel="nofollow noreferrer">ruby-lang.org/en/news/2020/09/25/ruby-3-0-0-preview1-release&zwnj;&#8203;d</a><br>------------------------------------------------------------------ <br><h3> Peter Brown, Id: 11105831, Score: 886: </h3><p>For those of you who just came here to know how to delete a key/value pair from a hash, you can use:<br>
<code>hash.delete(key)</code></p>
<p>For the rest of you who came here to read a wall of text about something entirely different, you can read the rest of this answer:</p>
<p><a href="http://api.rubyonrails.org/classes/Hash.html#method-i-except" rel="noreferrer">Rails has an except/except! method</a> that returns the hash with those keys removed. If you're already using Rails, there's no sense in creating your own version of this.</p>
<pre><code>class Hash
  # Returns a hash that includes everything but the given keys.
  #   hash = { a: true, b: false, c: nil}
  #   hash.except(:c) # =&gt; { a: true, b: false}
  #   hash # =&gt; { a: true, b: false, c: nil}
  #
  # This is useful for limiting a set of parameters to everything but a few known toggles:
  #   @person.update(params[:person].except(:admin))
  def except(*keys)
    dup.except!(*keys)
  end

  # Replaces the hash without the given keys.
  #   hash = { a: true, b: false, c: nil}
  #   hash.except!(:c) # =&gt; { a: true, b: false}
  #   hash # =&gt; { a: true, b: false }
  def except!(*keys)
    keys.each { |key| delete(key) }
    self
  end
end
</code></pre>
<h4> Fryie, Comment 28161634 Score: 59: </h4>You don&#39;t have to use the full Rails stack. You can include include ActiveSupport in any Ruby application.<br><h4> GMA, Comment 61939423 Score: 13: </h4>To add to Fryie&#39;s answer, you don&#39;t even need to load all of ActiveSupport; you can just include them then <code>require &quot;active_support&#47;core_ext&#47;hash&#47;except&quot;</code><br><h4> iconoclast, Comment 109288013 Score: 2: </h4>@GMA: when your five-minutes-of-editing are up, you can always copy, delete, modify, and repost a comment.<br><h4> stevec, Comment 133083192 Score: 0: </h4><b>A nice example to try:</b> <code>User.first.as_json.except(&quot;id&quot;)</code><br><h4> GMA, Comment 61939676 Score: 0: </h4>too late to edit: I meant &quot;include the gem&quot; not &quot;include them&quot;<br>------------------------------------------------------------------ <br><h3> dbryson, Id: 6227647, Score: 255: </h3><p>Why not just use:</p>
<pre><code>hash.delete(key)
</code></pre>
<p><code>hash</code> is now the &quot;remaining hash&quot; you're looking for.</p>
<h4> MhdSyrwan, Comment 50624382 Score: 96: </h4>This doesn&#39;t return the remaining hash as mentioned in the question, it will return the value associated with the deleted key.<br><h4> David J., Comment 15487115 Score: 31: </h4>It would be more consistent with Ruby conventions if <code>delete</code> did <b>not</b> modify its parameter and if <code>delete!</code> existed and did modify its parameter.<br><h4> Jackson Ray Hamilton, Comment 79868525 Score: 4: </h4>@DavidJ. contrary to popular belief, an exclamation point does not indicate mutation, but rather &quot;unusual behavior.&quot;  I imagine there isn&#39;t a <code>delete!</code> because a key-deleting method that mutated seemed like the only &quot;expected&quot; behavior.<br><h4> Misha Moroshko, Comment 7255553 Score: 4: </h4>@dbryson: I agree that sometimes it doesn&#39;t worth it. I just wonder why there are <code>merge</code>, <code>merge!</code>, <code>delete</code>, but no <code>detele!</code>...<br><h4> michael_teter, Comment 132957367 Score: 1: </h4>This answer just wrong.  The question explicitly says &quot;It is important that the returning value will be the remaining hash&quot;.  Hash.delete() does not return the hash.  And very unfortunately, it mutates the hash.  As others note, it should have been modeled after merge and merge!.<br><h4> eggmatters, Comment 51688011 Score: 1: </h4>delete returns the key but it does also alter the hash. As to why there is no delete!, my guess is that it semantically doesn&#39;t make sense to call delete on something and not actually delete it. calling hash.delete() as opposed to hash.delete!() would be a no-op.<br><h4> Bert Goethals, Comment 7268432 Score: 1: </h4>if you realy need it as a one liner do: <code>foo(hash.delete(key) || hash)</code><br><h4> Misha Moroshko, Comment 7255276 Score: 0: </h4>I would like to do <code>foo(h.reject!{ |k| k == :a })</code>. With your suggestion, I will have to do it in two lines.<br><h4> Jezen Thomas, Comment 57810337 Score: 0: </h4>Readability win, and predictability fail. I&#39;d advise people to <i>not</i> take this approach. I upvoted the answer anyway because it was helpful.<br>------------------------------------------------------------------ <br><h3> Fabio, Id: 9027559, Score: 244: </h3><p>Oneliner plain ruby, it works only with ruby > 1.9.x:</p>

<pre><code>1.9.3p0 :002 &gt; h = {:a =&gt; 1, :b =&gt; 2}
 =&gt; {:a=&gt;1, :b=&gt;2} 
1.9.3p0 :003 &gt; h.tap { |hs| hs.delete(:a) }
 =&gt; {:b=&gt;2} 
</code></pre>

<p><a href="http://blog.moertel.com/articles/2007/02/07/ruby-1-9-gets-handy-new-method-object-tap" rel="noreferrer">Tap</a> method always return the object on which is invoked...</p>

<p>Otherwise if you have required <code>active_support/core_ext/hash</code> (which is automatically required in every Rails application) you can use one of the following methods depending on your needs:</p>

<pre><code>âžœ  ~  irb
1.9.3p125 :001 &gt; require 'active_support/core_ext/hash' =&gt; true 
1.9.3p125 :002 &gt; h = {:a =&gt; 1, :b =&gt; 2, :c =&gt; 3}
 =&gt; {:a=&gt;1, :b=&gt;2, :c=&gt;3} 
1.9.3p125 :003 &gt; h.except(:a)
 =&gt; {:b=&gt;2, :c=&gt;3} 
1.9.3p125 :004 &gt; h.slice(:a)
 =&gt; {:a=&gt;1} 
</code></pre>

<p><a href="http://as.rubyonrails.org/classes/ActiveSupport/CoreExtensions/Hash/Except.html" rel="noreferrer">except</a> uses a blacklist approach, so it removes all the keys listed as args, while <a href="http://as.rubyonrails.org/classes/ActiveSupport/CoreExtensions/Hash/Slice.html" rel="noreferrer">slice</a> uses a whitelist approach, so it removes all keys that aren't listed as arguments. There also exist the bang version of those method (<code>except!</code> and <code>slice!</code>) which modify the given hash but their return value is different both of them return an hash. It represents the removed keys for <code>slice!</code> and the keys that are kept for the <code>except!</code>:</p>

<pre><code>1.9.3p125 :011 &gt; {:a =&gt; 1, :b =&gt; 2, :c =&gt; 3}.except!(:a)
 =&gt; {:b=&gt;2, :c=&gt;3} 
1.9.3p125 :012 &gt; {:a =&gt; 1, :b =&gt; 2, :c =&gt; 3}.slice!(:a)
 =&gt; {:b=&gt;2, :c=&gt;3} 
</code></pre>
<h4> Mulan, Comment 25961551 Score: 19: </h4>+1 It&#39;s worth mentioning that this method is destructive on <code>h</code>. <code>Hash#except</code> will not modify the original hash.<br><h4> Jimbali, Comment 93452290 Score: 9: </h4>Use <code>h.dup.tap { |hs| hs.delete(:a) }</code> to avoid modifying the original hash.<br>------------------------------------------------------------------ <br><h3> techdreams, Id: 39231096, Score: 137: </h3><p>There are many ways to remove a key from a hash and get the remaining hash in Ruby.</p>

<ol>
<li><p><code>.slice</code> => It will return selected keys and not delete them from the original hash. Use <code>slice!</code> if you want to remove the keys permanently else use simple <code>slice</code>.</p>

<pre><code>2.2.2 :074 &gt; hash = {"one"=&gt;1, "two"=&gt;2, "three"=&gt;3}
 =&gt; {"one"=&gt;1, "two"=&gt;2, "three"=&gt;3} 
2.2.2 :075 &gt; hash.slice("one","two")
 =&gt; {"one"=&gt;1, "two"=&gt;2} 
2.2.2 :076 &gt; hash
 =&gt; {"one"=&gt;1, "two"=&gt;2, "three"=&gt;3} 
</code></pre></li>
<li><p><code>.delete</code> => It will delete the selected keys from the original hash(it can accept only one key and not more than one).</p>

<pre><code>2.2.2 :094 &gt; hash = {"one"=&gt;1, "two"=&gt;2, "three"=&gt;3}
 =&gt; {"one"=&gt;1, "two"=&gt;2, "three"=&gt;3} 
2.2.2 :095 &gt; hash.delete("one")
 =&gt; 1 
2.2.2 :096 &gt; hash
 =&gt; {"two"=&gt;2, "three"=&gt;3} 
</code></pre></li>
<li><p><code>.except</code> => It will return the remaining keys but not delete anything from the original hash. Use <code>except!</code> if you want to remove the keys permanently else use simple <code>except</code>. </p>

<pre><code>2.2.2 :097 &gt; hash = {"one"=&gt;1, "two"=&gt;2, "three"=&gt;3}
 =&gt; {"one"=&gt;1, "two"=&gt;2, "three"=&gt;3} 
2.2.2 :098 &gt; hash.except("one","two")
 =&gt; {"three"=&gt;3} 
2.2.2 :099 &gt; hash
 =&gt; {"one"=&gt;1, "two"=&gt;2, "three"=&gt;3}         
</code></pre></li>
<li><p><code>.delete_if</code> => In case you need to remove a key based on a value. It will obviously remove the matching keys from the original hash.</p>

<pre><code>2.2.2 :115 &gt; hash = {"one"=&gt;1, "two"=&gt;2, "three"=&gt;3, "one_again"=&gt;1}
 =&gt; {"one"=&gt;1, "two"=&gt;2, "three"=&gt;3, "one_again"=&gt;1} 
2.2.2 :116 &gt; value = 1
 =&gt; 1 
2.2.2 :117 &gt; hash.delete_if { |k,v| v == value }
 =&gt; {"two"=&gt;2, "three"=&gt;3} 
2.2.2 :118 &gt; hash
 =&gt; {"two"=&gt;2, "three"=&gt;3} 
</code></pre></li>
<li><p><code>.compact</code> => It is used to remove all <code>nil</code> values from the hash. Use <code>compact!</code> if you want to remove the <code>nil</code> values permanently else use simple <code>compact</code>. </p>

<pre><code>2.2.2 :119 &gt; hash = {"one"=&gt;1, "two"=&gt;2, "three"=&gt;3, "nothing"=&gt;nil, "no_value"=&gt;nil}
 =&gt; {"one"=&gt;1, "two"=&gt;2, "three"=&gt;3, "nothing"=&gt;nil, "no_value"=&gt;nil} 
2.2.2 :120 &gt; hash.compact
 =&gt; {"one"=&gt;1, "two"=&gt;2, "three"=&gt;3}
</code></pre></li>
</ol>

<p>Results based on Ruby 2.2.2.</p>
<h4> Madis N&#245;mme, Comment 67174635 Score: 21: </h4><code>slice</code> and <code>except</code> are added by using <code>ActiveSupport::CoreExtensions::Hash</code>. They are not part of Ruby core. They can be used by <code>require &#39;active_support&#47;core_ext&#47;hash&#39;</code><br><h4> Madis N&#245;mme, Comment 103919595 Score: 8: </h4>Since Ruby 2.5 <code>Hash#slice</code> is in the standard library. <a href="https://ruby-doc.org/core-2.5.0/Hash.html#method-i-slice" rel="nofollow noreferrer">ruby-doc.org/core-2.5.0/Hash.html#method-i-slice</a> Yay!<br>------------------------------------------------------------------ <br><h3> Yura Taras, Id: 13953919, Score: 39: </h3><p>If you want to use pure Ruby (no Rails), don't want to create extension methods (maybe you need this only in one or two places and don't want to pollute namespace with tons of methods) and don't want to edit hash in place (i.e., you're fan of functional programming like me), you can 'select':</p>

<pre><code>&gt;&gt; x = {:a =&gt; 1, :b =&gt; 2, :c =&gt; 3}
=&gt; {:a=&gt;1, :b=&gt;2, :c=&gt;3}
&gt;&gt; x.select{|x| x != :a}
=&gt; {:b=&gt;2, :c=&gt;3}
&gt;&gt; x.select{|x| ![:a, :b].include?(x)}
=&gt; {:c=&gt;3}
&gt;&gt; x
=&gt; {:a=&gt;1, :b=&gt;2, :c=&gt;3}
</code></pre>
------------------------------------------------------------------ <br><h3> Marian13, Id: 64194612, Score: 35: </h3><h2>Hash#except (Ruby 3.0+)</h2>
<p>Starting from Ruby 3.0, <a href="https://ruby-doc.org/core-3.0.0.preview1/Hash.html#method-i-except" rel="noreferrer">Hash#except</a> is a build-in method.</p>
<p>As a result, there is no more need to depend on ActiveSupport or write monkey-patches in order to use it.</p>
<pre class="lang-rb prettyprint-override"><code>h = { a: 1, b: 2, c: 3 }
p h.except(:a) #=&gt; {:b=&gt;2, :c=&gt;3}
</code></pre>
<p><strong>Sources:</strong></p>
<ul>
<li><a href="https://ruby-doc.org/core-3.0.0.preview1/Hash.html#method-i-except" rel="noreferrer">Hash#except</a> from official Ruby docs.</li>
<li><a href="https://github.com/ruby/ruby/pull/2169" rel="noreferrer">Link to the PR</a>.</li>
<li><a href="https://blog.saeloun.com/2020/09/30/ruby-adds-support-for-hash-except" rel="noreferrer">Ruby 3.0 adds Hash#except and ENV.except</a>.</li>
</ul>
<h4> MatzFan, Comment 136149516 Score: 1: </h4>SO needs a way to ensure later answers which provide the best answer because a codebase has been improved can be highlighted. It&#39;s nuts that this answer languishes at 6h place in 2023. Will raise this as a meta question.<br>------------------------------------------------------------------ <br><h3> Max Williams, Id: 6228543, Score: 30: </h3><pre><code>#in lib/core_extensions.rb
class Hash
  #pass single or array of keys, which will be removed, returning the remaining hash
  def remove!(*keys)
    keys.each{|key| self.delete(key) }
    self
  end

  #non-destructive version
  def remove(*keys)
    self.dup.remove!(*keys)
  end
end

#in config/initializers/app_environment.rb (or anywhere in config/initializers)
require 'core_extensions'
</code></pre>

<p>I've set this up so that .remove returns a copy of the hash with the keys removed, while remove! modifies the hash itself.  This is in keeping with ruby conventions.  eg, from the console</p>

<pre><code>&gt;&gt; hash = {:a =&gt; 1, :b =&gt; 2}
=&gt; {:b=&gt;2, :a=&gt;1}
&gt;&gt; hash.remove(:a)
=&gt; {:b=&gt;2}
&gt;&gt; hash
=&gt; {:b=&gt;2, :a=&gt;1}
&gt;&gt; hash.remove!(:a)
=&gt; {:b=&gt;2}
&gt;&gt; hash
=&gt; {:b=&gt;2}
&gt;&gt; hash.remove!(:a, :b)
=&gt; {}
</code></pre>
------------------------------------------------------------------ <br><h3> rewritten, Id: 7748102, Score: 27: </h3><p>You can use <code>except!</code> from the <code>facets</code> gem:</p>

<pre><code>&gt;&gt; require 'facets' # or require 'facets/hash/except'
=&gt; true
&gt;&gt; {:a =&gt; 1, :b =&gt; 2}.except(:a)
=&gt; {:b=&gt;2}
</code></pre>

<p>The original hash does not change.</p>

<p>EDIT: as Russel says, facets has some hidden issues and is not completely API-compatible with ActiveSupport. On the other side ActiveSupport is not as complete as facets. In the end, I'd use AS and let the edge cases in your code.</p>
<h4> rewritten, Comment 57025450 Score: 0: </h4>@trans ActiveSupport nowadays has a quite small footprint too, and you can require only parts of it. Just like facets, but with many more eyes on it (so I suppose it gets better reviews).<br><h4> trans, Comment 56981194 Score: 0: </h4>Just <code>require &#39;facets&#47;hash&#47;except&#39;</code> and their are no &quot;issues&quot; (not sure what issues they would be anyway other than not 100% AS API). If you are doing a Rails project using AS makes sense, if not Facets has a much smaller footprint.<br>------------------------------------------------------------------ <br><h3> Mohamad, Id: 27450644, Score: 21: </h3><p>Instead of monkey patching or needlessly including large libraries, you can use <a href="https://www.new-bamboo.co.uk/blog/2014/02/05/refinements-under-the-knife/" rel="noreferrer">refinements if you are using Ruby 2</a>:</p>

<pre><code>module HashExtensions
  refine Hash do
    def except!(*candidates)
      candidates.each { |candidate| delete(candidate) }
      self
    end

    def except(*candidates)
      dup.remove!(candidates)
    end
  end
end
</code></pre>

<p>You can use this feature without affecting other parts of your program, or having to include large external libraries.</p>

<pre><code>class FabulousCode
  using HashExtensions

  def incredible_stuff
    delightful_hash.except(:not_fabulous_key)
  end
end
</code></pre>
------------------------------------------------------------------ <br><h3> gamov, Id: 12311714, Score: 18: </h3><p>in pure Ruby:</p>

<pre><code>{:a =&gt; 1, :b =&gt; 2}.tap{|x| x.delete(:a)}   # =&gt; {:b=&gt;2}
</code></pre>
------------------------------------------------------------------ <br><h3> Nakilon, Id: 22903528, Score: 13: </h3><p>See <a href="https://stackoverflow.com/questions/1560572/ruby-delete-multiple-hash-keys">Ruby on Rails: Delete multiple hash keys</a></p>

<pre><code>hash.delete_if{ |k,| keys_to_delete.include? k }
</code></pre>
<h4> Nakilon, Comment 104467636 Score: 0: </h4>@VigneshJayavel, you are right but OP wanted the hash to be returned. <code>each</code> would return the array.<br><h4> Vignesh Jayavel, Comment 56758891 Score: 0: </h4>keys_to_delete.each {|k| hash.delete(k)} is much faster for large datasets. correct me if wrong.<br>------------------------------------------------------------------ <br><h3> Sachin Singh, Id: 66943909, Score: 4: </h3><p>Try the <code>except!</code> method.</p>
<pre><code>{:a =&gt; 1, :b =&gt; 2}.except!(:a)   #=&gt; {:b =&gt; 2}
</code></pre>
------------------------------------------------------------------ <br><h3> frenesim, Id: 52135776, Score: 5: </h3><p>It's was great if delete return the delete pair of the hash.
I'm doing this:</p>

<pre><code>hash = {a: 1, b: 2, c: 3}
{b: hash.delete(:b)} # =&gt; {:b=&gt;2}
hash  # =&gt; {:a=&gt;1, :c=&gt;3} 
</code></pre>
<h4> Narfanator, Comment 135279568 Score: 0: </h4>I found a short way to do this nicely, check my answer :)<br>------------------------------------------------------------------ <br><h3> Jibran Usman, Id: 76625404, Score: 2: </h3><p>Use <code>delete</code>, <code>except</code>, or <code>except!</code></p>
<p><code>sample_hash = {hey: 'hey', hello: 'hello'}</code></p>
<p>Delete:</p>
<pre><code>sample_hash.delete(:hey)
=&gt; 'hey'

sample_hash
=&gt; {hello: 'hello'}
</code></pre>
<p>Returns value of the key and deletes the key in the original object, returns nil if no such key</p>
<p>Except:</p>
<pre><code>sample_hash.except(:hey)
=&gt; {hello: 'hello'}

sample_hash
=&gt; {hey: 'hey', hello: 'hello'}
</code></pre>
<p>Returns the entire hash without the specified keys, but does not update the original hash</p>
<p>Except!:
<code>except!</code> is the same as except but it permanently changes the state of the original hash like all bang operated methods do</p>
<pre><code>sample_hash.except!(:hey)
=&gt; {hello: 'hello'}

sample_hash
=&gt; {hello: 'hello'}
</code></pre>
------------------------------------------------------------------ <br><h3> frediy, Id: 21076536, Score: 1: </h3><p>This is a one line way to do it, but it's not very readable. Recommend using two lines instead.</p>

<pre><code>use_remaining_hash_for_something(Proc.new { hash.delete(:key); hash }.call)
</code></pre>
<h4> Michael Kohl, Comment 31699040 Score: 1: </h4><code>Hash#except</code> and <code>Hash#except!</code> have been mentioned enough already. The <code>Proc.new</code> version is not very readable as you mention and also more complicated than <code>use_remaining_hash_for_something(begin hash.delete(:key); hash end)</code>. Maybe just delete this answer.<br><h4> frediy, Comment 31765219 Score: 1: </h4>Shortened my answer and removed what had already been said. Keeping my answer along with your comment because they answer the question and make good recommendations for use.<br>------------------------------------------------------------------ <br><h3> Ketan Mangukiya, Id: 56125066, Score: 1: </h3><p>Multiple ways to delete Key in Hash.
you can use any Method from below</p>

<pre><code>hash = {a: 1, b: 2, c: 3}
hash.except!(:a) # Will remove *a* and return HASH
hash # Output :- {b: 2, c: 3}

hash = {a: 1, b: 2, c: 3}
hash.delete(:a) # will remove *a* and return 1 if *a* not present than return nil
</code></pre>

<p>So many ways is there, you can look on Ruby doc of Hash <a href="https://docs.ruby-lang.org/en/2.0.0/Hash.html#method-i-reject" rel="nofollow noreferrer">here</a>.</p>

<p>Thank you</p>
------------------------------------------------------------------ <br><h3> Narfanator, Id: 76732922, Score: 0: </h3><p>I want to delete a list of keys, and get back the deleted &quot;slice&quot; of the hash:</p>
<p>Rails:</p>
<pre><code>hash = {a: 1, b: 2, c: 3}

def delete_slice!(hash, *keys)
  hash.slice(*keys).tap { hash.except!(*keys) }
end

delete_slice!(hash, :a, :b)
# =&gt; {a: 1, b: 2}
hash
# =&gt; {c: 3}
</code></pre>
<p>Pure Ruby:</p>
<pre><code>hash = {a: 1, b: 2, c: 3}

def delete_slice!(hash, *keys)
  hash.slice(*keys).tap { keys.each{ hash.delete _1 } }
end

delete_slice!(hash, :a, :b)
# =&gt; {a: 1, b: 2}
hash
# =&gt; {c: 3}
</code></pre>
------------------------------------------------------------------ <br><h3> fdghdfg, Id: 21515133, Score: -13: </h3><p>This would also work: <code>hash[hey] = nil</code></p>
<h4> obaqueiro, Comment 35920929 Score: 3: </h4>h = {:a =&gt; 1, :b =&gt; 2, :c =&gt; 3}; h[:a]=nil; h.each{|k,v| puts k}  Is not the same as: h = {:a =&gt; 1, :b =&gt; 2, :c =&gt; 3}; h.delete(:a); h.each{|k,v| puts k}<br><h4> Sebasti&#225;n Palma, Comment 93339599 Score: 1: </h4>To remove a key from a hash isn&#39;t the same as removing the value of a key from a hash. As this might lead people to confuse, it&#39;d be better to remove this answer.<br>