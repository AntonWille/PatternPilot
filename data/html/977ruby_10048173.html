 <h2> Title: Why is it bad style to `rescue Exception =&gt; e` in Ruby? </h2> <h3> John, question_id: 10048173 </h3>Score: 977, Tags: {ruby,exception} <br><p>Ryan Davis’s <a href="http://www.zenspider.com/ruby/quickref.html#general-tips" rel="noreferrer">Ruby QuickRef</a> says (without explanation):</p>

<blockquote>
  <p>Don’t rescue Exception. EVER. or I will stab you.</p>
</blockquote>

<p>Why not? What’s the right thing to do?</p>
------------------------------------------------------------------ <br><h3> Answer 10048406 Andrew Marshall: </h3><p><strong>TL;DR</strong>: Use <code>StandardError</code> instead for general exception catching. When the original exception is re-raised (e.g. when rescuing to log the exception only), rescuing <code>Exception</code> is probably okay.</p>
<hr />
<p><code>Exception</code> is the root of <a href="https://web.archive.org/web/20200527195436/http://rubylearning.com/images/exception.jpg" rel="noreferrer">Ruby's exception hierarchy</a>, so when you <code>rescue Exception</code> you rescue from <em>everything</em>, including subclasses such as <code>SyntaxError</code>, <code>LoadError</code>, and <code>Interrupt</code>.</p>
<p>Rescuing <code>Interrupt</code> prevents the user from using <kbd>CTRL</kbd><kbd>C</kbd> to exit the program.</p>
<p>Rescuing <code>SignalException</code> prevents the program from responding correctly to signals. It will be unkillable except by <code>kill -9</code>.</p>
<p>Rescuing <code>SyntaxError</code> means that <code>eval</code>s that fail will do so silently.</p>
<p>All of these can be shown by running this program, and trying to <kbd>CTRL</kbd><kbd>C</kbd> or <code>kill</code> it:</p>
<pre><code>loop do
  begin
    sleep 1
    eval &quot;djsakru3924r9eiuorwju3498 += 5u84fior8u8t4ruyf8ihiure&quot;
  rescue Exception
    puts &quot;I refuse to fail or be stopped!&quot;
  end
end
</code></pre>
<p>Rescuing from <code>Exception</code> isn't even the default. Doing</p>
<pre><code>begin
  # iceberg!
rescue
  # lifeboats
end
</code></pre>
<p>does not rescue from <code>Exception</code>, it rescues from <code>StandardError</code>. You should generally specify something more specific than the default <code>StandardError</code>, but rescuing from <code>Exception</code> <em>broadens</em> the scope rather than narrowing it, and can have catastrophic results and make bug-hunting extremely difficult.</p>
<hr />
<p>If you have a situation where you do want to rescue from <code>StandardError</code> and you need a variable with the exception, you can use this form:</p>
<pre><code>begin
  # iceberg!
rescue =&gt; e
  # lifeboats
end
</code></pre>
<p>which is equivalent to:</p>
<pre><code>begin
  # iceberg!
rescue StandardError =&gt; e
  # lifeboats
end
</code></pre>
<hr />
<p>One of the few common cases where it’s sane to rescue from <code>Exception</code> is for logging/reporting purposes, in which case you should immediately re-raise the exception:</p>
<pre><code>begin
  # iceberg?
rescue Exception =&gt; e
  # do some logging
  raise # not enough lifeboats ;)
end
</code></pre>
<h4> Comment 12860035 ratchet freak: </h4>so it&#39;s like catching <code>Throwable</code> in java<br><h4> Comment 27899813 Jonathan Swartz: </h4>This advice is good for a clean Ruby environment. But unfortunately a number of gems have created exceptions that directly descend from Exception. Our environment has 30 of these: e.g. OpenID::Server::EncodingError, OAuth::InvalidRequest, HTMLTokenizerSample. These are exceptions that you&#39;d very much want to catch in standard rescue blocks. Unfortunately, nothing in Ruby prevents or even discourages gems from inheriting directly from Exception -- even the naming is unintuitive.<br><h4> Comment 32440508 Nathan Long: </h4>@JonathanSwartz - I would bug the gem creators to change what their exception inherits from. Personally, I like my gems to have all exceptions descend from MyGemException, so you could rescue that if you wanted.<br><h4> Comment 27903873 Andrew Marshall: </h4>@JonathanSwartz Then rescue from those specific subclasses, not Exception. More specific is nearly always better and clearer.<br><h4> Comment 33446613 j_mcnally: </h4>You can also <code>ADAPTER_ERRORS = [::ActiveRecord::StatementInvalid, PGError, Mysql::Error,                             Mysql2::Error, ::ActiveRecord::JDBCError, SQLite3::Exception]</code> and then <code>rescue *ADAPTER_ERRORS =&gt; e</code><br><h4> Comment 23013780 Andrew Marshall: </h4>@Excalibur If you’re re-raising the exception, then it’s fine since you’re not swallowing it, but just trying to know that it happened then letting it bubble up. Usually done for logging.<br><h4> Comment 34965675 iGEL: </h4>I just found another example, why <code>rescue Exception</code> is bad: It rescued failures in our specs! There was even a <code>should_not_receive</code> in our code base, and the author apparently trusted the specs and thought, it&#39;s already implemented: But that method was in fact being called, just the failure was rescued :(<br><h4> Comment 27942299 Jonathan Swartz: </h4>Andrew - there are many times you want to catch all standard exceptions. You mentioned one yourself - if you want to add some context to the message, then rethrow or log or airbrake it.<br><h4> Comment 36415800 nroose: </h4>So, now I just need to make sure our gems don&#39;t raise Exception or some super duper custom exception that is a direct subclass of Exception!<br><h4> Comment 102265096 Sapphire_Brick: </h4><b>what does that mean &quot;evals that fail will do silently&quot;?</b> If you&#39;re ever in a situation when you have to catch so many errors, you probably are in the same situation in which you shouldn&#39;t be using <code>eval</code> <i>at all</i>.<br><h4> Comment 84999255 Lev Lukomskyi: </h4>Rescuing Exception is bad only if you don&#39;t re-raise it, otherwise, it can be a good way to log an error before crush.<br>------------------------------------------------------------------ <br><h3> Answer 10048215 Sergio Tulentsev: </h3><p>Because this captures all exceptions. It's unlikely that your program can recover from <strong>any</strong> of them. </p>

<p>You should handle only exceptions that you know how to recover from. If you don't anticipate a certain kind of exception, don't handle it, crash loudly (write details to the log), then diagnose logs and fix code.</p>

<p>Swallowing exceptions is bad, don't do this.</p>
------------------------------------------------------------------ <br><h3> Answer 10052064 Michael Slade: </h3><p>The <em>real</em> rule is: Don't throw away exceptions.  The objectivity of the author of your quote is questionable, as evidenced by the fact that it ends with</p>

<blockquote>
  <p>or I will stab you</p>
</blockquote>

<p>Of course, be aware that signals (by default) throw exceptions, and normally long-running processes are terminated through a signal, so catching Exception and not terminating on signal exceptions will make your program very hard to stop.  So don't do this:</p>

<pre><code>#! /usr/bin/ruby

while true do
  begin
    line = STDIN.gets
    # heavy processing
  rescue Exception =&gt; e
    puts "caught exception #{e}! ohnoes!"
  end
end
</code></pre>

<p>No, really, don't do it.  Don't even run that to see if it works.</p>

<p>However, say you have a threaded server and you want all exceptions to not:</p>

<ol>
<li>be ignored (the default)</li>
<li>stop the server (which happens if you say <code>thread.abort_on_exception = true</code>).  </li>
</ol>

<p>Then this is perfectly acceptable in your connection handling thread:</p>

<pre><code>begin
  # do stuff
rescue Exception =&gt; e
  myLogger.error("uncaught #{e} exception while handling connection: #{e.message}")
    myLogger.error("Stack trace: #{backtrace.map {|l| "  #{l}\n"}.join}")
end
</code></pre>

<p>The above works out to a variation of Ruby's default exception handler, with the advantage that it doesn't also kill your program.  Rails does this in its request handler.</p>

<p>Signal exceptions are raised in the main thread.  Background threads won't get them, so there is no point in trying to catch them there.</p>

<p>This is particularly useful in a production environment, where you do <em>not</em> want your program to simply stop whenever something goes wrong. Then you can take the stack dumps in your logs and add to your code to deal with specific exception further down the call chain and in a more graceful manner.</p>

<p>Note also that there is another Ruby idiom which has much the same effect:</p>

<pre><code>a = do_something rescue "something else"
</code></pre>

<p>In this line, if <code>do_something</code> raises an exception, it is caught by Ruby, thrown away, and <code>a</code> is assigned <code>"something else"</code>.</p>

<p>Generally, don't do that, except in special cases where you <em>know</em> you don't need to worry.  One example:</p>

<pre><code>debugger rescue nil
</code></pre>

<p>The <code>debugger</code> function is a rather nice way to set a breakpoint in your code, but if running outside a debugger, and Rails, it raises an exception.  Now theoretically you shouldn't be leaving debug code lying around in your program (pff! nobody does that!)  but you might want to keep it there for a while for some reason, but not continually run your debugger.</p>

<p>Note:</p>

<ol>
<li><p>If you've run someone else's program that catches signal exceptions and ignores them, (say the code above) then:</p>

<ul>
<li>in Linux, in a shell, type <code>pgrep ruby</code>, or <code>ps | grep ruby</code>, look for your offending program's PID, and then run <code>kill -9 &lt;PID&gt;</code>.   </li>
<li>in Windows, use the Task Manager (<kbd>CTRL</kbd>-<kbd>SHIFT</kbd>-<kbd>ESC</kbd>), go to the "processes" tab, find your process, right click it and select "End process".</li>
</ul></li>
<li><p>If you are working with someone else's program which is, for whatever reason, peppered with these ignore-exception blocks, then putting this at the top of the mainline is one possible cop-out:</p>

<pre><code>%W/INT QUIT TERM/.each { |sig| trap sig,"SYSTEM_DEFAULT" }
</code></pre>

<p>This causes the program to respond to the normal termination signals by immediately terminating, bypassing exception handlers,  <em>with no cleanup</em>.  So it could cause data loss or similar.  Be careful!</p></li>
<li><p>If you need to do this:</p>

<pre><code>begin
  do_something
rescue Exception =&gt; e
  critical_cleanup
  raise
end
</code></pre>

<p>you can actually do this:</p>

<pre><code>begin
  do_something
ensure
  critical_cleanup
end
</code></pre>

<p>In the second case, <code>critical cleanup</code> will be called every time, whether or not an exception is thrown.</p></li>
</ol>
<h4> Comment 18936019 Andrew Marshall: </h4>Your examples in note 3 are not equivilant, an <code>ensure</code> will run regardless of whether there&#39;s an exception raised or not, while the <code>rescue</code> will only run if an exception was raised.<br><h4> Comment 21501780 gtd: </h4>Just add another critical_cleanup call after the begin/rescue block in the first example.  I agree not the most elegant code, but obviously the second example is the elegant way of doing it, so a little inelegance is just part of the example.<br><h4> Comment 68262076 huelbois: </h4>&quot;Don&#39;t even run that to see if it works.&quot; seems a bad advice for coding... On the contrary, I would advise you to run it, to see it fail and to understand by yourself how if fails, instead of blindly believing someone else. Great answer anyway :)<br><h4> Comment 20416071 Michael Slade: </h4>They&#39;re not /exactly/ equivalent but I can&#39;t figure out how to succinctly express the equivalence in a way that isn&#39;t ugly.<br><h4> Comment 79171519 beckah: </h4>&quot;<code>The objectivity of the author of your quote is questionable</code>&quot;. The guy wrote minitest and a ton of other widely used gems. <a href="http://blog.zenspider.com/projects/" rel="nofollow noreferrer">blog.zenspider.com/projects</a><br>------------------------------------------------------------------ <br><h3> Answer 35121040 Ben Aubin: </h3><h2>TL;DR</h2>
<p>Don't <code>rescue Exception =&gt; e</code> (and not re-raise the exception) - or you <em>might</em> drive off a bridge.</p>
<hr />
<p>Let's say you are in a car (running Ruby). You recently installed a new steering wheel with the over-the-air upgrade system (which uses <code>eval</code>), but you didn't know one of the programmers messed up on syntax.</p>
<p>You are on a bridge, and realize you are going a bit towards the railing, so you turn left.</p>
<pre><code>def turn_left
  self.turn left:
end
</code></pre>
<p>oops! That's probably <em>Not Good</em>™, luckily, Ruby raises a <code>SyntaxError</code>.</p>
<p>The car should stop immediately - right?</p>
<p>Nope.</p>
<pre><code>begin
  #...
  eval self.steering_wheel
  #...
rescue Exception =&gt; e
  self.beep
  self.log &quot;Caught #{e}.&quot;, :warn
  self.log &quot;Logged Error - Continuing Process.&quot;, :info
end
</code></pre>
<blockquote>
<p><strong>beep beep</strong></p>
<p>Warning: Caught SyntaxError Exception.</p>
<p>Info: Logged Error - Continuing Process.</p>
</blockquote>
<p>You notice something is wrong, and you slam on the emergency breaks (<code>^C</code>: <code>Interrupt</code>)</p>
<blockquote>
<p><strong>beep beep</strong></p>
<p>Warning: Caught Interrupt Exception.</p>
<p>Info: Logged Error - Continuing Process.</p>
</blockquote>
<p>Yeah - that didn't help much. You're pretty close to the rail, so you put the car in park (<code>kill</code>ing: <code>SignalException</code>).</p>
<blockquote>
<p><strong>beep beep</strong></p>
<p>Warning: Caught SignalException Exception.</p>
<p>Info: Logged Error - Continuing Process.</p>
</blockquote>
<p>At the last second, you pull out the keys (<code>kill -9</code>), and the car stops, you slam forward into the steering wheel (the airbag can't inflate because you didn't gracefully stop the program - you terminated it), and the computer in the back of your car slams into the seat in front of it. A half-full can of Coke spills over the papers. The groceries in the back are crushed, and most are covered in egg yolk and milk. The car needs serious repair and cleaning. (Data Loss)</p>
<p>Hopefully you have insurance (Backups). Oh yeah - because the airbag didn't inflate, you're probably hurt (getting fired, etc).</p>
<hr />
<p>But wait! There's <del>more</del> reasons why you might want to use <code>rescue Exception =&gt; e</code>!</p>
<p>Let's say you're that car, and you want to make sure the airbag inflates if the car is exceeding its safe stopping momentum.</p>
<pre><code> begin 
    # do driving stuff
 rescue Exception =&gt; e
    self.airbags.inflate if self.exceeding_safe_stopping_momentum?
    raise
 end
</code></pre>
<p>Here's the exception to the rule: You can catch <code>Exception</code> <strong>only if you re-raise the exception</strong>. So, a better rule is to never swallow <code>Exception</code>, and always re-raise the error.</p>
<p>But adding rescue is both easy to forget in a language like Ruby, and putting a rescue statement right before re-raising an issue feels a little non-DRY. And you <strong>do not</strong> want to forget the <code>raise</code> statement. And if you do, good luck trying to find that error.</p>
<p>Thankfully, Ruby is awesome, you can just use the <code>ensure</code> keyword, which makes sure the code runs. The <code>ensure</code> keyword will run the code no matter what - if an exception is thrown, if one isn't, the only exception being if the world ends (or other unlikely events).</p>
<pre><code> begin 
    # do driving stuff
 ensure
    self.airbags.inflate if self.exceeding_safe_stopping_momentum?
 end
</code></pre>
<p>Boom! And that code should run anyways. The only reason you should use <code>rescue Exception =&gt; e</code> is if you need access to the exception, or if you only want code to run on an exception. And remember to re-raise the error. Every time.</p>
<p>Note: As @Niall pointed out, ensure <strong>always</strong> runs. This is good because sometimes your program can lie to you and not throw exceptions, even when issues occur. With critical tasks, like inflating airbags, you need to make sure it happens no matter what. Because of this, checking every time the car stops, whether an exception is thrown or not, is a good idea. Even though inflating airbags is a bit of an uncommon task in most programming contexts, this is actually pretty common with most cleanup tasks.</p>
<h4> Comment 90192268 Niall: </h4>This answer came 4 years after the perfectly understandable and correct accepted answer, and re-explained it with an absurd scenario designed more to be amusing than realistic. Sorry to be a buzzkill, but this isn&#39;t reddit - it&#39;s more important for answers to be succinct and correct than funny.  Also, the part about <code>ensure</code> as an alternative to <code>rescue Exception</code> is misleading - the example implies they are equivalent, but as stated <code>ensure</code> will happen whether there&#39;s an Exception or not, so now your airbags will inflate because you went over 5mph even though nothing went wrong.<br><h4> Comment 90321477 Ben Aubin: </h4>@Niall I updated my answer to change the misleading over 5mph check with <code>self.exceeding_safe_stopping_momentum?</code>. I also added an explainer as to why you&#39;d want to use ensure in this case. <code>rescue Exception</code> is not always wrong, but <code>ensure</code> is an often-better time to do cleanup as it occurs even if your program fails silently.<br>------------------------------------------------------------------ <br><h3> Answer 58739659 calebkm: </h3><p>This blog post explains it perfectly:
<a href="https://www.honeybadger.io/blog/ruby-exception-vs-standarderror-whats-the-difference/" rel="noreferrer">Ruby's Exception vs StandardError: What's the difference?</a></p>
<blockquote>
<h3>Why you shouldn't rescue Exception</h3>
<p>The problem with rescuing Exception
is that it actually rescues every exception that inherits from
Exception. Which is....all of them!</p>
<p>That's a problem because there are some exceptions that are used
internally by Ruby. They don't have anything to do with your app, and
swallowing them will cause bad things to happen.</p>
<p>Here are a few of the big ones:</p>
<ul>
<li><p>SignalException::Interrupt - If you rescue this, you can't exit your
app by hitting control-c.</p>
</li>
<li><p>ScriptError::SyntaxError - Swallowing syntax errors means that things
like puts(&quot;Forgot something) will fail silently.</p>
</li>
<li><p>NoMemoryError - Wanna know what happens when your program keeps
running after it uses up all the RAM? Me neither.</p>
</li>
</ul>
<pre class="lang-rb prettyprint-override"><code>begin
  do_something()
rescue Exception =&gt; e
  # Don't do this. This will swallow every single exception. Nothing gets past it. 
end
</code></pre>
<p>I'm guessing that you don't really want to swallow any of these
system-level exceptions. You only want to catch all of your
application level errors. The exceptions caused YOUR code.</p>
<p>Luckily, there's an easy way to to this.</p>
<h3>Rescue StandardError Instead</h3>
<p>All of the exceptions that you should care about inherit from StandardError. These are our old friends:</p>
<p>NoMethodError - raised when you try to invoke a method that doesn't exist</p>
<p>TypeError - caused by things like 1 + &quot;&quot;</p>
<p>RuntimeError - who could forget good old RuntimeError?</p>
<p>To rescue errors like these, you'll want to rescue StandardError. You COULD do it by writing something like this:</p>
<pre class="lang-rb prettyprint-override"><code>begin
  do_something()
rescue StandardError =&gt; e
  # Only your app's exceptions are swallowed. Things like SyntaxErrror are left alone. 
end
</code></pre>
<p>But Ruby has made it much easier for use.</p>
<p>When you don't specify an exception class at all, ruby assumes you mean StandardError. So the code below is identical to the above code:</p>
<pre class="lang-rb prettyprint-override"><code>begin
  do_something()
rescue =&gt; e
  # This is the same as rescuing StandardError
end
</code></pre>
</blockquote>
------------------------------------------------------------------ <br><h3> Answer 10050511 Russell Borogove: </h3><p>That's a specific case of the rule that you shouldn't catch <em>any</em> exception you don't know how to handle. If you don't know how to handle it, it's always better to let some other part of the system catch and handle it.</p>
