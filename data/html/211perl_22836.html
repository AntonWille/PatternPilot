 <h2> Title: How do I perform a Perl substitution on a string while keeping the original? </h2> <h4> kaybenleroll, question_id: 22836, created_at: 2008-08-22 16:47:55+00:00 </h4>Score: 211, Tags: {regex,perl,replace} <br><p>In Perl, what is a good way to perform a replacement on a string using a regular expression and store the value in a different variable, without changing the original?</p>

<p>I usually just copy the string to a new variable then bind it to the <code>s///</code> regex that does the replacement on the new string, but I was wondering if there is a better way to do this?</p>

<pre><code>$newstring = $oldstring;
$newstring =~ s/foo/bar/g;
</code></pre>
<hr><h3> ✔️ Answer by John Siracusa, Id: 22896, Score: 300, created_at: 2008-08-22 17:08:29+00:00 </h3><p>This is the idiom I've always used to get a modified copy of a string without changing the original:</p>
<pre><code>(my $newstring = $oldstring) =~ s/foo/bar/g;
</code></pre>
<p>In perl 5.14.0 or later, you can use the new <code>/r</code> <a href="https://metacpan.org/pod/release/FLORA/perl-5.14.2/pod/perl5140delta.pod#Non-destructive-substitution" rel="noreferrer">non-destructive substitution modifier</a>:</p>
<pre><code>my $newstring = $oldstring =~ s/foo/bar/gr; 
</code></pre>
<hr />
<p><strong>NOTE:</strong><br />
The above solutions work without <code>g</code> too. They also work with any other modifiers.</p>
<p><strong>SEE ALSO:</strong><br />
<a href="https://perldoc.perl.org/perlrequick" rel="noreferrer"><code>perldoc perlrequick</code>: Perl regular expressions quick start</a></p>
<h4> Comment by ysth, Score: 6, Id: 16669, created_at: 2008-09-19 06:11:32+00:00 </h4>Whether or not under use strict.  Minimal scoping of variables++<h4> Comment by ikegami, Score: 2, Id: 71941754, created_at: 2017-02-22 16:41:34+00:00 </h4>@Benoit, I believe you mean <code>s&#47;foo&#47;bar&#47; for my $newstring = $oldstring;</code> It works, but it&#39;s far weirder.<h4> Comment by Benny, Score: 0, Id: 35841021, created_at: 2014-04-30 17:11:26+00:00 </h4>I was wondering if something like <code>my $new = $_ for $old =~ s&#47;foo&#47;bar;</code> would work?<hr><h3>  Answer by Pat, Id: 24090, Score: 51, created_at: 2008-08-23 08:53:44+00:00 </h3><p>The statement:</p>

<pre><code>(my $newstring = $oldstring) =~ s/foo/bar/g;
</code></pre>

<p>Which is equivalent to:</p>

<pre><code>my $newstring = $oldstring;
$newstring =~ s/foo/bar/g;
</code></pre>

<p>Alternatively, as of Perl 5.13.2 you can use <code>/r</code> to do a non destructive substitution:</p>

<pre><code>use 5.013;
#...
my $newstring = $oldstring =~ s/foo/bar/gr;
</code></pre>
<h4> Comment by mareoraft, Score: 3, Id: 40310517, created_at: 2014-09-10 21:23:52+00:00 </h4>Did you forget the <code>g</code> in your top regex?<hr><h3>  Answer by Sam Kington, Id: 62500, Score: 26, created_at: 2008-09-15 12:49:15+00:00 </h3><p>Under <code>use strict</code>, say:</p>

<pre><code>(my $new = $original) =~ s/foo/bar/;
</code></pre>

<p>instead.</p>
<hr><h3>  Answer by Josh Millard, Id: 94557, Score: 14, created_at: 2008-09-18 17:13:55+00:00 </h3><p>The one-liner solution is more useful as a shibboleth than good code; good Perl coders will know it and understand it, but it's much less transparent and readable than the two-line copy-and-modify couplet you're starting with.</p>

<p>In other words, a good way to do this is the way you're <i>already</i> doing it.  Unnecessary concision at the cost of readability isn't a win.</p>
<h4> Comment by brian d foy, Score: 13, Id: 20969, created_at: 2008-09-20 22:27:33+00:00 </h4>You might think it&#39;s unnecessary concision, but having to type a variable name twice to use it once is twice the number of points of failure. It&#39;s perfectly readable to people who know the language, and it&#39;s even in our &lt;i&gt;Learning Perl&lt;/i&gt; course.<h4> Comment by Josh Millard, Score: 1, Id: 17100, created_at: 2008-09-19 11:12:44+00:00 </h4>The one line version, &lt;i&gt;if correctly executed&lt;/i&gt;, isn&#39;t subject, true.  But that&#39;s a separate issue.<h4> Comment by ysth, Score: 0, Id: 16671, created_at: 2008-09-19 06:13:42+00:00 </h4>Ah, but the one line version isn&#39;t subject to the error in the question of unintentionally modifying the wrong string.<hr><h3>  Answer by textral, Id: 44172761, Score: 2, created_at: 2017-05-25 05:15:51+00:00 </h3><p>Another pre-5.14 solution: <a href="http://www.perlmonks.org/?node_id=346719" rel="nofollow noreferrer">http://www.perlmonks.org/?node_id=346719</a> (see japhy's post)</p>

<p>As his approach uses <code>map</code>, it also works well for arrays, but requires cascading <code>map</code> to produce a temporary array (otherwise the original would be modified):</p>

<pre><code>my @orig = ('this', 'this sucks', 'what is this?');
my @list = map { s/this/that/; $_ } map { $_ } @orig;
# @orig unmodified
</code></pre>
<hr><h3>  Answer by Tim Kennedy, Id: 55786, Score: 1, created_at: 2008-09-11 03:51:28+00:00 </h3><p>If you write Perl with <code>use strict;</code>, then you'll find that the one line syntax isn't valid, even when declared.</p>

<p>With:</p>

<pre><code>my ($newstring = $oldstring) =~ s/foo/bar/;
</code></pre>

<p>You get:</p>

<pre><code>Can't declare scalar assignment in "my" at script.pl line 7, near ") =~"
Execution of script.pl aborted due to compilation errors.
</code></pre>

<p>Instead, the syntax that you have been using, while a line longer, is the syntactically correct way to do it with <code>use strict;</code>.   For me, using <code>use strict;</code> is just a habit now.  I do it automatically.  Everyone should.</p>

<pre><code>#!/usr/bin/env perl -wT

use strict;

my $oldstring = "foo one foo two foo three";
my $newstring = $oldstring;
$newstring =~ s/foo/bar/g;

print "$oldstring","\n";
print "$newstring","\n";
</code></pre>
<h4> Comment by glenn jackman, Score: 3, Id: 1466011, created_at: 2009-10-21 13:51:41+00:00 </h4>If you <code>use warnings;</code> instead of <code>-w</code>, you gain greater control: for instance, if you want to temporarily turn off warnings in a block of code.<hr><h3>  Answer by JoGotta, Id: 35829163, Score: 1, created_at: 2016-03-06 16:07:54+00:00 </h3><p>I hate foo and bar .. who dreamed up these non descriptive terms in programming anyway?</p>

<pre><code>my $oldstring = "replace donotreplace replace donotreplace replace donotreplace";

my $newstring = $oldstring;
$newstring =~ s/replace/newword/g; # inplace replacement

print $newstring;
%: newword donotreplace newword donotreplace newword donotreplace
</code></pre>
<h4> Comment by Jon, Score: 3, Id: 91809732, created_at: 2018-09-20 20:45:02+00:00 </h4>See... if JoGotta had used the traditional and familiar <code>foo</code> and <code>bar</code>, his answer would have been accurate. Proving, once again, customs exist for a reason and lessons are only learned the hard way.  ;)<h4> Comment by Teepeemm, Score: 2, Id: 61182432, created_at: 2016-04-22 22:31:13+00:00 </h4>How is this different from the original?  (And I think you want <code>=~ s</code>.)<h4> Comment by Pascal, Score: 2, Id: 79577577, created_at: 2017-09-19 18:55:28+00:00 </h4>Clbuttic mistake.  The actual output of that code is <code>newword donotnewword newword donotnewword newword donotnewword</code><h4> Comment by Peter Mortensen, Score: 0, Id: 118964180, created_at: 2021-04-28 16:21:53+00:00 </h4><a href="https://en.wikipedia.org/wiki/Scunthorpe_problem" rel="nofollow noreferrer">Clbuttic reference</a><h4> Comment by Peter Mortensen, Score: 0, Id: 118964611, created_at: 2021-04-28 16:38:18+00:00 </h4>Who? Wikipedia has <a href="https://en.wikipedia.org/wiki/Foobar#History_and_etymology" rel="nofollow noreferrer">part of the answer</a>. Incl.: <i>&quot;The etymology of foobar could be derived from the military slang from the World War II era FUBAR, which was bowdlerised to foobar. The word foo on its own was used earlier. ... The first known use of the terms in print in a programming context appears in a 1965 edition of MIT&#39;s Tech Engineering News.&quot;</i><hr><h3>  Answer by ngn999, Id: 67513243, Score: 1, created_at: 2021-05-13 02:40:48+00:00 </h3><p>if I just use this in oneliner, how about, <code>sprintf(&quot;%s&quot;, $oldstring)</code></p>
