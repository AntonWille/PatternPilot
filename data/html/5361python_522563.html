 <h2> Title: How to access the index value in a &#39;for&#39; loop? </h2> <h4> Joan Venge, question_id: 522563 </h4>Score: 5361, Tags: {python,loops,list} <br><p>How do I access the index while iterating over a sequence with a <code>for</code> loop?</p>
<pre class="lang-py prettyprint-override"><code>xs = [8, 23, 45]

for x in xs:
    print(&quot;item #{} = {}&quot;.format(index, x))
</code></pre>
<p>Desired output:</p>
<pre class="lang-none prettyprint-override"><code>item #1 = 8
item #2 = 23
item #3 = 45
</code></pre>
<h4> plugwash, Id: 92160350 Score: 109: </h4>Note that indexes in python start from 0, so the indexes for your example list are 0 to 4 not 1 to 5<br>------------------------------------------------------------------ <br><h3> Mike Hordecki, Id: 522578, Score: 8789: </h3><p>Use the built-in function <a href="https://docs.python.org/3/library/functions.html#enumerate" rel="noreferrer" title="enumerate"><code>enumerate()</code></a>:</p>
<pre><code>for idx, x in enumerate(xs):
    print(idx, x)
</code></pre>
<p>It is <em><a href="https://stackoverflow.com/questions/25011078/what-does-pythonic-mean">non-pythonic</a></em> to manually index via <code>for i in range(len(xs)): x = xs[i]</code> or manually manage an additional state variable.</p>
<p>Check out <a href="https://www.python.org/dev/peps/pep-0279/" rel="noreferrer" title="PEP 279">PEP 279</a> for more.</p>
<h4> clozach, Comment 86193498 Score: 143: </h4>As Aaron points out below, use start=1 if you want to get 1-5 instead of 0-4.<br><h4> ShadowRanger, Comment 113582027 Score: 25: </h4>@TheRealChx101: It&#39;s lower than the overhead of looping over a <code>range</code> and indexing each time, and lower than manually tracking and updating the index separately. <code>enumerate</code> with unpacking is heavily optimized (if the <code>tuple</code>s are unpacked to names as in the provided example, it reuses the same <code>tuple</code> each loop to avoid even the cost of freelist lookup, it has an optimized code path for when the index fits in <code>ssize_t</code> that performs cheap in-register math, bypassing Python level math operations, and it avoids indexing the <code>list</code> at the Python level, which is more expensive than you&#39;d think).<br><h4> TheRealChx101, Comment 103223013 Score: 10: </h4>Does <code>enumerate</code> not incur another overhead?<br><h4> Błotosmętek, Comment 106318992 Score: 10: </h4>@TheRealChx101 according to my tests (Python 3.6.3) the difference is negligible and sometimes even in favour of <code>enumerate</code>.<br><h4> bfris, Comment 122978535 Score: 8: </h4>@user2585501. It does: <code>for i in range(5)</code> or <code>for i in range(len(ints))</code> will do the universally common operation of iterating over an index. But if you want both the item <b><i>and</i></b> the index, <code>enumerate</code> is a <i>very</i> useful syntax. I use it all the time.<br><h4> Ferazhu, Comment 136696795 Score: 0: </h4>Regarding the &quot;unpythonic&quot;, is it also an antipattern in other c-like languages that support enumerator? Using forloop on index, taking an item by index and doing nothing else with the index?<br><h4> Dmitrii Malygin, Comment 134501457 Score: 0: </h4>The performance impact of using enumerate with unpacking is significantly lower compared to the overhead incurred by looping over a range and indexing each time, or manually tracking and updating the index separately. The enumerate function with unpacking syntax is highly optimized for efficiency.<br><h4> user2585501, Comment 122796835 Score: 0: </h4>Why does python not have a professional for loop syntax to perform this universally common operation?<br>------------------------------------------------------------------ <br><h3> Russia Must Remove Putin, Id: 28072982, Score: 1292: </h3><blockquote>
<h1>Using a for loop, how do I access the loop index, from 1 to 5 in this case?</h1>
</blockquote>
<p>Use <code>enumerate</code> to get the index with the element as you iterate:</p>
<pre><code>for index, item in enumerate(items):
    print(index, item)
</code></pre>
<p>And note that Python's indexes start at zero, so you would get 0 to 4 with the above. If you want the count, 1 to 5, do this:</p>
<pre><code>count = 0 # in case items is empty and you need it after the loop
for count, item in enumerate(items, start=1):
    print(count, item)
</code></pre>
<h1>Unidiomatic control flow</h1>
<p>What you are asking for is the Pythonic equivalent of the following, which is the algorithm most programmers of lower-level languages would use:</p>
<blockquote>
<pre><code>index = 0            # Python's indexing starts at zero
for item in items:   # Python's for loops are a &quot;for each&quot; loop 
    print(index, item)
    index += 1
</code></pre>
</blockquote>
<p>Or in languages that do not have a for-each loop:</p>
<blockquote>
<pre><code>index = 0
while index &lt; len(items):
    print(index, items[index])
    index += 1
</code></pre>
</blockquote>
<p>or sometimes more commonly (but unidiomatically) found in Python:</p>
<blockquote>
<pre><code>for index in range(len(items)):
    print(index, items[index])
</code></pre>
</blockquote>
<h1>Use the Enumerate Function</h1>
<p>Python's <a href="https://docs.python.org/2/library/functions.html#enumerate" rel="noreferrer"><code>enumerate</code> function</a> reduces the visual clutter by hiding the accounting for the indexes, and encapsulating the iterable into another iterable (an <code>enumerate</code> object) that yields a two-item tuple of the index and the item that the original iterable would provide. That looks like this:</p>
<pre><code>for index, item in enumerate(items, start=0):   # default is zero
    print(index, item)
</code></pre>
<p>This code sample is fairly well the <a href="http://python.net/%7Egoodger/projects/pycon/2007/idiomatic/handout.html#index-item-2-enumerate" rel="noreferrer">canonical</a> example of the difference between code that is idiomatic of Python and code that is not. Idiomatic code is sophisticated (but not complicated) Python, written in the way that it was intended to be used. Idiomatic code is expected by the designers of the language, which means that usually this code is not just more readable, but also more efficient.</p>
<h2>Getting a count</h2>
<p>Even if you don't need indexes as you go, but you need a count of the iterations (sometimes desirable) you can start with <code>1</code> and the final number will be your count.</p>
<pre><code>count = 0 # in case items is empty
for count, item in enumerate(items, start=1):   # default is zero
    print(item)

print('there were {0} items printed'.format(count))
</code></pre>
<p>The count seems to be more what you intend to ask for (as opposed to index) when you said you wanted from 1 to 5.</p>
<hr />
<h2>Breaking it down - a step by step explanation</h2>
<p>To break these examples down, say we have a list of items that we want to iterate over with an index:</p>
<pre><code>items = ['a', 'b', 'c', 'd', 'e']
</code></pre>
<p>Now we pass this iterable to enumerate, creating an enumerate object:</p>
<pre><code>enumerate_object = enumerate(items) # the enumerate object
</code></pre>
<p>We can pull the first item out of this iterable that we would get in a loop with the <code>next</code> function:</p>
<pre><code>iteration = next(enumerate_object) # first iteration from enumerate
print(iteration)
</code></pre>
<p>And we see we get a tuple of <code>0</code>, the first index, and <code>'a'</code>, the first item:</p>
<pre><code>(0, 'a')
</code></pre>
<p>we can use what is referred to as &quot;<a href="https://docs.python.org/2/tutorial/datastructures.html#tuples-and-sequences" rel="noreferrer">sequence unpacking</a>&quot; to extract the elements from this two-tuple:</p>
<pre><code>index, item = iteration
#   0,  'a' = (0, 'a') # essentially this.
</code></pre>
<p>and when we inspect <code>index</code>, we find it refers to the first index, 0, and <code>item</code> refers to the first item, <code>'a'</code>.</p>
<pre><code>&gt;&gt;&gt; print(index)
0
&gt;&gt;&gt; print(item)
a
</code></pre>
<h1>Conclusion</h1>
<ul>
<li>Python indexes start at zero</li>
<li>To get these indexes from an iterable as you iterate over it, use the enumerate function</li>
<li>Using enumerate in the idiomatic way (along with tuple unpacking) creates code that is more readable and maintainable:</li>
</ul>
<p>So do this:</p>
<pre><code>for index, item in enumerate(items, start=0):   # Python indexes start at zero
    print(index, item)
</code></pre>
<h4> Bergi, Comment 106763226 Score: 4: </h4>Does the &quot;<i>Getting a count</i>&quot; example work when <code>items</code> is empty?<br><h4> ShadowRanger, Comment 113582068 Score: 3: </h4>@Bergi: It won&#39;t, but you can just add <code>count = 0</code> before the loop to ensure it has a value (and it&#39;s the correct one when the loop never assigns to <code>count</code>, since by definition there were no items).<br><h4> nerak99, Comment 129621998 Score: 2: </h4>Brilliant and comprehensive answer which explains the difference between idiomatic (aka pythonic ) rather than just stating that a particular approach is unidiomatic (i.e. non-pythonic) without explanation.<br>------------------------------------------------------------------ <br><h3> A.J., Id: 23886515, Score: 261: </h3><p>It's pretty simple to start it from <code>1</code> other than <code>0</code>:</p>
<pre><code>for index, item in enumerate(iterable, start=1):
   print index, item  # Used to print in python&lt;3.x
   print(index, item) # Migrate to print() after 3.x+
   
</code></pre>
<h4> Antti Haapala -- Слава Україні, Comment 59805330 Score: 16: </h4>The question was about list indexes; since they start from 0 there is little point in starting from other number since the indexes would be wrong (yes, the OP said it wrong in the question as well). Otherwise, calling the variable that is tuple of <code>index, item</code> just <code>index</code> is very misleading, as you noted. Just use <code>for index, item in enumerate(ints)</code>.<br><h4> pushkin, Comment 93991564 Score: 2: </h4>@AnttiHaapala The reason, I presume, is that the question&#39;s expected output starts at index 1 instead 0<br><h4> hygull, Comment 83092672 Score: 1: </h4>Better is to enclose index inside parenthesis pairs as (index), it will work on both the Python versions 2 and 3.<br><h4> ShadowRanger, Comment 113582127 Score: 0: </h4>@hygull: Turning <code>index</code> into <code>(index)</code> won&#39;t change a thing on either Py2 or Py3. I feel like maybe you&#39;re thinking of the change to <code>print</code>; the only way to make that work on both Py2 and Py3 is to add <code>from __future__ import print_function</code> to the top of your file to get consistent Py3-style <code>print</code>, and change the <code>print</code> to <code>print(index, item)</code>. Or you read an earlier edit of the question when <code>index</code> was the original <code>tuple</code>, not unpacked to two names, but the parentheses still don&#39;t change anything if you fail to unpack.<br>------------------------------------------------------------------ <br><h3> David Hanak, Id: 522569, Score: 136: </h3><pre><code>for i in range(len(ints)):
   print(i, ints[i]) # print updated to print() in Python 3.x+ 
</code></pre>
<h4> saulspatz, Comment 51464678 Score: 67: </h4>Use enumerate instead<br><h4> Ben Blank, Comment 336039 Score: 11: </h4>That should probably be <code>xrange</code> for pre-3.0.<br><h4> januarvs, Comment 72718416 Score: 5: </h4>For Python 2.3 above, use enumerate built-in function since it is more Pythonic.<br><h4> chepner, Comment 79461366 Score: 4: </h4>@adg I don&#39;t see how avoid <code>enumerate</code> saves any logic; you still have to select which object to index with <code>i</code>, no?<br><h4> adg, Comment 73378874 Score: 2: </h4>Enumerate is not always better - it depends on the requirements of the application. In my current situation the relationships between the object lengths is meaningful to my application. Although I started out using enumerate, I switched to this approach to avoid having to write logic to select which object to enumerate.<br><h4> ShadowRanger, Comment 113582233 Score: 0: </h4>@Graham: Using <code>range</code> would be a premature pessimization, as <code>zip</code> (<code>itertools.izip</code> on Py2) is strictly better for that case. About the only use case for <code>range</code> I know of where there isn&#39;t a better alternative is iterating over overlapping slices of a sequence (where you need the index, but then use it to slice, so getting a value with the index isn&#39;t helpful). You could make it work without <code>range</code> (and for non-sequences) with <code>itertools.tee</code>, but it&#39;s ugly.<br><h4>   vrnvorona, Comment 134798694 Score: 0: </h4>@saulspatz, repeating some code N times is not best with enumerate though.<br><h4> naoki fujita, Comment 98695822 Score: 0: </h4>This representation is useful when I use numba or cython.<br><h4> Graham, Comment 94655101 Score: 0: </h4>@chepner If one is iterating through multiple lists, using <code>range</code> may make sense. Though <code>zip</code> is probably more Pythonic for these cases, so using <code>range</code> would still be a premature optimization, as other comments mention.<br>------------------------------------------------------------------ <br><h3> Andy Jazz, Id: 54227634, Score: 134: </h3><p><em><strong>Tested on Python 3.12</strong></em></p>
<p>Here are twelve examples of how you can access the indices with their corresponding array's elements using <em><strong>for loops</strong></em>, <em><strong>while loops</strong></em> and some <em><strong>looping functions</strong></em>. Note that array indices always start from zero by default (see <code>example 4</code> to change this).</p>
<h3>1. Looping elements with counter and <code>+=</code> operator.</h3>
<pre><code>items = [8, 23, 45, 12, 78]
counter = 0

for value in items:
    print(counter, value)
    counter += 1
</code></pre>
<hr />
<pre><code>Result:

#    0 8
#    1 23
#    2 45
#    3 12
#    4 78
</code></pre>
<h3>2. Iterating elements using <code>enumerate()</code> built-in function.</h3>
<pre><code>items = [8, 23, 45, 12, 78]

for i in enumerate(items):
    print(&quot;index/value&quot;, i)
</code></pre>
<hr />
<pre><code>Result:

#    index/value (0, 8)
#    index/value (1, 23)
#    index/value (2, 45)
#    index/value (3, 12)
#    index/value (4, 78)
</code></pre>
<h3>3. Getting list's element and its index separately.</h3>
<pre><code>items = [8, 23, 45, 12, 78]

for index, value in enumerate(items):
    print(&quot;index&quot;, index, &quot;for value&quot;, value)
</code></pre>
<hr />
<pre><code>Result:

#    index 0 for value 8
#    index 1 for value 23
#    index 2 for value 45
#    index 3 for value 12
#    index 4 for value 78
</code></pre>
<h3>4. You can change the <code>index</code> value to any increment.</h3>
<pre><code>items = [8, 23, 45, 12, 78]

for i, item in enumerate(items, start=100):
    print(i, item)
</code></pre>
<hr />
<pre><code>Result:

#    100 8
#    101 23
#    102 45
#    103 12
#    104 78
</code></pre>
<h3>5. Automatic counter incrementation with <code>range(len(...))</code> methods.</h3>
<pre><code>items = [8, 23, 45, 12, 78]

for i in range(len(items)):
    print(&quot;Index:&quot;, i, &quot;Value:&quot;, items[i])
</code></pre>
<hr />
<pre><code>Result:

#    ('Index:', 0, 'Value:', 8)
#    ('Index:', 1, 'Value:', 23)
#    ('Index:', 2, 'Value:', 45)
#    ('Index:', 3, 'Value:', 12)
#    ('Index:', 4, 'Value:', 78)
</code></pre>
<h3>6. Using <code>for</code> loop inside function.</h3>
<pre><code>items = [8, 23, 45, 12, 78]

def enum(items, start=0):
    counter = start

    for value in items:
        print(counter, value)
        counter += 1
    
enum(items)
</code></pre>
<hr />
<pre><code>Result:

#    0 8
#    1 23
#    2 45
#    3 12
#    4 78
</code></pre>
<h3>7. Of course, we can't forget about <code>while</code> loop.</h3>
<pre><code>items = [8, 23, 45, 12, 78]
counter = 0

while counter &lt; len(items):
    print(counter, items[counter])
    counter += 1
</code></pre>
<hr />
<pre><code>Result:

#    0 8
#    1 23
#    2 45
#    3 12
#    4 78
</code></pre>
<h3>8. <code>yield</code> statement returning a generator object.</h3>
<pre><code>def createGenerator():        
    items = [8, 23, 45, 12, 78]

    for (j, k) in enumerate(items):
        yield (j, k)
        

generator = createGenerator()

for i in generator:
    print(i)
</code></pre>
<hr />
<pre><code>Result:

#    (0, 8)
#    (1, 23)
#    (2, 45)
#    (3, 12)
#    (4, 78)
</code></pre>
<h3>9. Inline expression with <code>for</code> loop and <code>lambda</code>.</h3>
<pre><code>items = [8, 23, 45, 12, 78]

xerox = lambda upperBound: [(i, items[i]) for i in range(0, upperBound)]
print(xerox(5))
</code></pre>
<hr />
<pre><code>Result:

#    [(0, 8), (1, 23), (2, 45), (3, 12), (4, 78)]
</code></pre>
<h3>10. Iterate over two lists at once using Python's <code>zip()</code> function.</h3>
<pre><code>items = [8, 23, 45, 12, 78]
indices = []

for index in range(len(items)):
    indices.append(index)

for item, index in zip(items, indices):
    print(&quot;{}: {}&quot;.format(index, item))
</code></pre>
<hr />
<pre><code>Result:

#    0: 8
#    1: 23
#    2: 45
#    3: 12
#    4: 78
</code></pre>
<h3>11. Loop over 2 lists with a <code>while</code> loop and <code>iter()</code> &amp; <code>next()</code> methods.</h3>
<pre><code>items = [8, 23, 45, 12, 78]
indices = range(len(items))

iterator1 = iter(indices)
iterator2 = iter(items)
  
try:
    while True:
        i = next(iterator1)
        element = next(iterator2)
        print(i, element)
except StopIteration:
    pass
</code></pre>
<hr />
<pre><code>Result:

#    0  8
#    1  23
#    2  45
#    3  12
#    4  78
</code></pre>
<h3>12. Also, it's nice to iterate list's elements inside class' <code>Static Method</code>.</h3>
<pre><code>items = [8, 23, 45, 12, 78]

class ElementPlus:
    @staticmethod                            # decorator
    def indexForEachOfMy(iterable):
        for pair in enumerate(iterable):
            print pair

ElementPlus.indexForEachOfMy(items)
</code></pre>
<hr />
<pre><code>Result:

#    (0, 8)
#    (1, 23)
#    (2, 45)
#    (3, 12)
#    (4, 78)
</code></pre>
<h4> zomilanovic, Comment 135561669 Score: 1: </h4>Thanks for the really detailed answer showing all variations of how to achieve that.   Should be the accepted answer in my opinion!<br>------------------------------------------------------------------ <br><h3> Charitoo, Id: 45685598, Score: 66: </h3><p>As is the norm in Python, there are several ways to do this. In all examples assume: <code>lst = [1, 2, 3, 4, 5]</code></p>
<ol>
<li>Using enumerate (<em>considered most idiomatic</em>)</li>
</ol>
<hr />
<pre><code>for index, element in enumerate(lst):
    # Do the things that need doing here
</code></pre>
<p>This is also the safest option in my opinion because the chance of going into infinite recursion has been eliminated. Both the item and its index are held in variables and there is no need to write any further code to access the item.</p>
<ol start="2">
<li>Creating a variable to hold the index (<em>using <code>for</code></em>)</li>
</ol>
<hr />
<pre><code>for index in range(len(lst)):   # or xrange
    # you will have to write extra code to get the element
</code></pre>
<ol start="3">
<li>Creating a variable to hold the index (<em>using <code>while</code></em>)</li>
</ol>
<hr />
<pre><code>index = 0
while index &lt; len(lst):
    # You will have to write extra code to get the element
    index += 1  # escape infinite recursion
</code></pre>
<ol start="4">
<li>There is always another way</li>
</ol>
<hr />
<p>As explained before, there are other ways to do this that have not been explained here and they may even apply more in other situations. <em>For example</em>, using <code>itertools.chain</code> with for. It handles nested loops better than the other examples.</p>
------------------------------------------------------------------ <br><h3> Charlie Martin, Id: 522576, Score: 47: </h3><p>Old fashioned way:</p>
<pre><code>for ix in range(len(ints)):
    print(ints[ix])
</code></pre>
<p>List comprehension:</p>
<pre><code>[ (ix, ints[ix]) for ix in range(len(ints))]

&gt;&gt;&gt; ints
[1, 2, 3, 4, 5]
&gt;&gt;&gt; for ix in range(len(ints)): print ints[ix]
... 
1
2
3
4
5
&gt;&gt;&gt; [ (ix, ints[ix]) for ix in range(len(ints))]
[(0, 1), (1, 2), (2, 3), (3, 4), (4, 5)]
&gt;&gt;&gt; lc = [ (ix, ints[ix]) for ix in range(len(ints))]
&gt;&gt;&gt; for tup in lc:
...     print(tup)
... 
(0, 1)
(1, 2)
(2, 3)
(3, 4)
(4, 5)
&gt;&gt;&gt; 
</code></pre>
<h4> user6734503, Comment 90134426 Score: 5: </h4>This is <b>not</b> wrong and is used in C/C++ and others. It&#39;s considered as non-pythonic, but can also be used in python. Like simple solutions that break it down to the source :+<br><h4> user6734503, Comment 90156850 Score: 0: </h4>Some python <i>extremists</i> would say, don&#39;t do this. But I said it only to indicate that there is more than one possible way<br>------------------------------------------------------------------ <br><h3> Andriy Ivaneyko, Id: 38764000, Score: 47: </h3><h1>Accessing indexes &amp; Performance Benchmarking of approaches</h1>
<p>The fastest way to access indexes of list within loop in <strong>Python 3.7</strong> is to use the <a href="https://docs.python.org/2/library/functions.html#enumerate" rel="noreferrer">enumerate method</a> for small, medium and huge lists.</p>
<p>Please see <strong>different approaches</strong> which can be used to iterate over list and access index value and <strong>their performance metrics</strong> (which I suppose would be useful for you) in code samples below:</p>
<pre><code># Using range
def range_loop(iterable):
    for i in range(len(iterable)):
        1 + iterable[i]

# Using enumerate
def enumerate_loop(iterable):
    for i, val in enumerate(iterable):
        1 + val

# Manual indexing
def manual_indexing_loop(iterable):
    index = 0
    for item in iterable:
        1 + item
        index += 1
</code></pre>
<p>See performance metrics for each method below:</p>
<pre><code>from timeit import timeit

def measure(l, number=10000):
    print(&quot;Measure speed for list with %d items&quot; % len(l))
    print(&quot;range: &quot;, timeit(lambda :range_loop(l), number=number))
    print(&quot;enumerate: &quot;, timeit(lambda :enumerate_loop(l), number=number))
    print(&quot;manual_indexing: &quot;, timeit(lambda :manual_indexing_loop(l), number=number))

# Measure speed for list with 1000 items
measure(range(1000))
# range:  1.161622366
# enumerate:  0.5661940879999996
# manual_indexing:  0.610455682

# Measure speed for list with 100000 items
measure(range(10000))
# range:  11.794482958
# enumerate:  6.197628574000001
# manual_indexing:  6.935181098000001

# Measure speed for list with 10000000 items
measure(range(10000000), number=100)
# range:  121.416859069
# enumerate:  62.718909123
# manual_indexing:  69.59575057400002
</code></pre>
<p>As the result, using <code>enumerate</code> method is the fastest method for iteration when the index needed.</p>
<p>Adding some useful links below:</p>
<ul>
<li><p><em><a href="https://stackoverflow.com/questions/94935/what-is-the-difference-between-range-and-xrange-functions-in-python-2-x">What is the difference between range and xrange functions in Python 2.X?</a></em></p>
</li>
<li><p><em><a href="https://stackoverflow.com/questions/4852944/what-is-faster-for-loop-using-enumerate-or-for-loop-using-xrange-in-python">What is faster for loop using enumerate or for loop using xrange in Python?</a></em></p>
</li>
<li><p><em><a href="https://stackoverflow.com/questions/11990105/rangelenlist-or-enumeratelist">range(len(list)) or enumerate(list)?</a></em></p>
</li>
</ul>
<h4> user4805123, Comment 72313109 Score: 7: </h4>&quot;readability counts&quot;  The speed difference in the small &lt;1000 range is insignificant.  It is 3% slower on an already small time metric.<br><h4> Andriy Ivaneyko, Comment 110368577 Score: 2: </h4>@Georgy makes sense, on python 3.7 enumerate is total winner :)<br><h4> Georgy, Comment 99134572 Score: 0: </h4>How about updating the answer to Python 3?<br>------------------------------------------------------------------ <br><h3> Kofi, Id: 70404966, Score: 40: </h3><p>You can use <code>enumerate</code> and embed expressions inside string literals to obtain the solution.</p>
<p>This is a simple way:</p>
<pre><code>a=[4,5,6,8]
for b, val in enumerate(a):
    print('item #{} = {}'.format(b+1, val))
</code></pre>
------------------------------------------------------------------ <br><h3> rassa45, Id: 30441272, Score: 21: </h3><p>First of all, the indexes will be from 0 to 4. Programming languages start counting from 0; don't forget that or you will come across an index-out-of-bounds exception. All you need in the <em>for</em> loop is a variable counting from 0 to 4 like so:</p>
<pre><code>for x in range(0, 5):
</code></pre>
<p>Keep in mind that I wrote 0 to 5 because the loop stops one number before the maximum. :)</p>
<p>To get the value of an index, use</p>
<pre><code>list[index]
</code></pre>
------------------------------------------------------------------ <br><h3> Liam, Id: 30441543, Score: 19: </h3><p>You can do it with this code:</p>

<pre><code>ints = [8, 23, 45, 12, 78]
index = 0

for value in (ints):
    index +=1
    print index, value
</code></pre>

<p>Use this code if you need to reset the index value at the end of the loop:</p>

<pre><code>ints = [8, 23, 45, 12, 78]
index = 0

for value in (ints):
    index +=1
    print index, value
    if index &gt;= len(ints)-1:
        index = 0
</code></pre>
------------------------------------------------------------------ <br><h3> thinker007, Id: 10459739, Score: 18: </h3><p>According to this discussion: <em><a href="http://bytes.com/topic/python/answers/464012-objects-list-index" rel="nofollow noreferrer">object's list index</a></em></p>
<p>Loop counter iteration</p>
<p>The current idiom for looping over the indices makes use of the built-in <code>range</code> function:</p>
<pre><code>for i in range(len(sequence)):
    # Work with index i
</code></pre>
<p>Looping over both elements and indices can be achieved either by the old idiom or by using the new <code>zip</code> built-in function:</p>
<pre><code>for i in range(len(sequence)):
    e = sequence[i]
    # Work with index i and element e
</code></pre>
<p>or</p>
<pre><code>for i, e in zip(range(len(sequence)), sequence):
    # Work with index i and element e
</code></pre>
<p>via <em><a href="http://www.python.org/dev/peps/pep-0212/" rel="nofollow noreferrer">PEP 212 – Loop Counter Iteration</a></em>.</p>
<h4> Tadeck, Comment 22352249 Score: 24: </h4>This won&#39;t work for iterating through generators. Just use enumerate().<br><h4> TankorSmash, Comment 65275596 Score: 2: </h4>Nowadays, the current idiom is enumerate, not the range call.<br><h4> Jean-Fran&#231;ois Fabre, Comment 98219961 Score: 0: </h4>and it&#39;s the same as the older answer: <a href="https://stackoverflow.com/a/522576/6451573">stackoverflow.com/a/522576/6451573</a><br>------------------------------------------------------------------ <br><h3> Ankur Kothari, Id: 50672647, Score: 18: </h3><p>If I were to iterate <code>nums = [1, 2, 3, 4, 5]</code> I would do</p>

<pre><code>for i, num in enumerate(nums, start=1):
    print(i, num)
</code></pre>

<p>Or get the length as <code>l = len(nums)</code></p>

<pre><code>for i in range(l):
    print(i+1, nums[i])
</code></pre>
------------------------------------------------------------------ <br><h3> DrM, Id: 51863929, Score: 18: </h3><p>In your question, you write <em>"how do I access the loop index, from 1 to 5 in this case?"</em></p>

<p>However, the index for a list runs from zero.  So, then we need to know if what you actually want is the index and item for each item in a list, or whether you really want numbers starting from 1.  Fortunately, in Python, it is easy to do either or both.</p>

<p>First, to clarify, the <code>enumerate</code> function iteratively returns the index and corresponding item for each item in a list.</p>

<pre><code>alist = [1, 2, 3, 4, 5]

for n, a in enumerate(alist):
    print("%d %d" % (n, a))
</code></pre>

<p>The output for the above is then,</p>

<pre class="lang-none prettyprint-override"><code>0 1
1 2
2 3
3 4
4 5
</code></pre>

<p>Notice that the index runs from 0. This kind of indexing is common among modern programming languages including Python and C.</p>

<p>If you want your loop to span a part of the list, you can use the standard Python syntax for a part of the list. For example, to loop from the second item in a list up to but not including the last item, you could use</p>

<pre><code>for n, a in enumerate(alist[1:-1]):
    print("%d %d" % (n, a))
</code></pre>

<p>Note that once again, the output index runs from 0,</p>

<pre class="lang-none prettyprint-override"><code>0 2
1 3
2 4
</code></pre>

<p>That brings us to the <code>start=n</code> switch for <code>enumerate()</code>.  This simply offsets the index, you can equivalently simply add a number to the index inside the loop.</p>

<pre><code>for n, a in enumerate(alist, start=1):
    print("%d %d" % (n, a))
</code></pre>

<p>for which the output is</p>

<pre class="lang-none prettyprint-override"><code>1 1
2 2
3 3
4 4
5 5
</code></pre>
------------------------------------------------------------------ <br><h3> RIshu, Id: 50780432, Score: 13: </h3><p>If there is no duplicate value in the list:</p>

<pre><code>for i in ints:
    indx = ints.index(i)
    print(i, indx)
</code></pre>
<h4> user3064538, Comment 98217824 Score: 6: </h4>First option is O(n&#178;), a terrible idea. If your list is 1000 elements long, it&#39;ll take literally a 1000 times longer than using <code>enumerate</code>. You should delete this answer.<br><h4> Stam Kaly, Comment 94553173 Score: 2: </h4>Note that the first option should not be used, since it only works correctly only when each item in the sequence is unique.<br>------------------------------------------------------------------ <br><h3> Ashok Kumar Jayaraman, Id: 48665823, Score: 12: </h3><p>You can also try this:</p>

<pre><code>data = ['itemA.ABC', 'itemB.defg', 'itemC.drug', 'itemD.ashok']
x = []
for (i, item) in enumerate(data):
      a = (i, str(item).split('.'))
      x.append(a)
for index, value in x:
     print(index, value)
</code></pre>

<p>The output is </p>

<pre><code>0 ['itemA', 'ABC']
1 ['itemB', 'defg']
2 ['itemC', 'drug']
3 ['itemD', 'ashok']
</code></pre>
------------------------------------------------------------------ <br><h3> PyRsquared, Id: 50613659, Score: 8: </h3><p>You can use the <code>index</code> method:</p>
<pre><code>ints = [8, 23, 45, 12, 78]
inds = [ints.index(i) for i in ints]
</code></pre>
<p>It is highlighted in a comment that this method doesn’t work if there are duplicates in <code>ints</code>. The method below should work for any values in <code>ints</code>:</p>
<pre><code>ints = [8, 8, 8, 23, 45, 12, 78]
inds = [tup[0] for tup in enumerate(ints)]
</code></pre>
<p>Or alternatively</p>
<pre><code>ints = [8, 8, 8, 23, 45, 12, 78]
inds = [tup for tup in enumerate(ints)]
</code></pre>
<p>if you want to get both the index and the value in <code>ints</code> as a list of tuples.</p>
<p>It uses the method of <code>enumerate</code> in the selected answer to this question, but with list comprehension, making it faster with less code.</p>
------------------------------------------------------------------ <br><h3> Amar Kumar, Id: 61295753, Score: 8: </h3><p>A simple answer using a <em>while</em> loop:</p>
<pre><code>arr = [8, 23, 45, 12, 78]
i = 0
while i &lt; len(arr):
    print(&quot;Item &quot;, i + 1, &quot; = &quot;, arr[i])
    i += 1
</code></pre>
<p>Output:</p>
<pre><code>Item  1  =  8
Item  2  =  23
Item  3  =  45
Item  4  =  12
Item  5  =  78
</code></pre>
<h4> Peter Mortensen, Comment 127121025 Score: 0: </h4>Please review <i><a href="https://meta.stackoverflow.com/questions/415040">Should we edit a question to transcribe code from an image to text?</a></i> and <i><a href="https://meta.stackoverflow.com/questions/285551/">Why not upload images of code/errors when asking a question?</a></i> (e.g., <i>&quot;Images should only be used to illustrate problems that</i> <b><i>can&#39;t be made clear in any other way,</i></b> <i>such as to provide screenshots of a user interface.&quot;</i>) and take the appropriate <a href="https://stackoverflow.com/posts/61295753/edit">action</a> (it covers answers as well). Thanks in advance.<br>------------------------------------------------------------------ <br><h3> lola, Id: 49999897, Score: 6: </h3><p>To print a tuple of (index, value) in a list comprehension using a <em>for</em> loop:</p>
<pre><code>ints = [8, 23, 45, 12, 78]
print [(i,ints[i]) for i in range(len(ints))]
</code></pre>
<p>Output:</p>
<pre><code>[(0, 8), (1, 23), (2, 45), (3, 12), (4, 78)]
</code></pre>
------------------------------------------------------------------ <br><h3> Rahul, Id: 67461537, Score: 6: </h3><p>You can simply use a variable such as <code>count</code> to count the number of elements in the list:</p>
<pre><code>ints = [8, 23, 45, 12, 78]
count = 0
for i in ints:
    count = count + 1
    print('item #{} = {}'.format(count, i))
</code></pre>
------------------------------------------------------------------ <br><h3> cottontail, Id: 76948173, Score: 4: </h3><p>Yet another way to run a counter in a for loop is to use <code>itertools.count</code>.</p>
<pre class="lang-py prettyprint-override"><code>from itertools import count

my_list = ['a', 'b', 'a']
for i, item in zip(count(), my_list):
    print(i, item)
</code></pre>
<p>This is useful especially if you want the counters to be fractional numbers. In the following example, the &quot;index&quot; starts from 1.0 and is incremented by 0.5 in each iteration.</p>
<pre class="lang-py prettyprint-override"><code>my_list = ['a', 'b', 'a']

for i, item in zip(count(start=1., step=0.5), my_list):
    print(f&quot;loc={i}, item={item}&quot;)
    
# loc=1.0, item=a
# loc=1.5, item=b
# loc=2.0, item=a
</code></pre>
<p>Another method is to use <code>list.index()</code> inside a loop. However, in contrast to other answers on this page mentioning this method (<a href="https://stackoverflow.com/a/50780432/19123103">1</a>, <a href="https://stackoverflow.com/a/50613659/19123103">2</a>, <a href="https://stackoverflow.com/a/49999727/19123103">3</a>), the starting point of the index search (which is the second argument) must be passed to the <code>list.index()</code> method. This lets you achieve 2 things: (1) Doesn't expensively loop over the list from the beginning again; (2) Can find the index of all values, even duplicates.</p>
<pre class="lang-py prettyprint-override"><code>my_list = ['a', 'b', 'a']
idx = -1
for item in my_list:
    idx = my_list.index(item, idx+1)
    #                         ^^^^^   &lt;---- start the search from the next index
    print(f&quot;index={idx}, item={item}&quot;)
    
# index=0, item=a
# index=1, item=b
# index=2, item=a
</code></pre>
<p>In terms of performance, if you want all/most of the indices, <code>enumerate()</code> is the fastest option. If you were looking for only specific indices, then <code>list.index()</code> may be <em>more</em> efficient. Below are two examples where <code>list.index()</code> is more efficient.</p>
<h5>Example #1: Index of specific values</h5>
<p>Suppose you want to find all indices where a specific value appears in a list (e.g. highest value). For example, in the following case, we want to find all indices that 2 appears in. This is a one-liner using <code>enumerate()</code>. However, we can also search for the indices of 2 by using the <code>list.index()</code> method in a while-loop; as mentioned before, in each iteration, we start the index search from where we left off in the previous iteration.</p>
<pre class="lang-py prettyprint-override"><code>lst = [0, 2, 1, 2]
target = 2

result = []
pos = -1
while True:
    try:
        pos = lst.index(target, pos+1)
        result.append(pos)
    except ValueError:
        break
        
print(result)      # [1, 3]
</code></pre>
<p>In fact, in certain cases, it's much faster than <code>enumerate()</code> option that produces the same output especially if the list is long.</p>
<h5>Example #2: Index of the first number that is smaller than a target</h5>
<p>Another common exercise where index is often needed in a loop is to find the index of the first item in a list that satisfies some condition (e.g. greater/smaller than some target value). In the following example, we want to find the index of the first value that exceeds 2.5. This is a one-liner using <code>enumerate()</code> but using <code>list.index()</code> is more efficient because getting indices that won't be used as in <code>enumerate()</code> has a cost (which <code>list.index()</code> doesn't incur).</p>
<pre class="lang-py prettyprint-override"><code>my_list = [1, 2, 3, 4]
target = 2.5

for item in my_list:
    if item &gt; target:
        idx = my_list.index(item)
        break
</code></pre>
<p>or as a one-liner:</p>
<pre class="lang-py prettyprint-override"><code>idx = next(my_list.index(item) for item in my_list if item &gt; target)
</code></pre>
<p><a href="https://i.stack.imgur.com/wnyNm.png" rel="nofollow noreferrer"><img src="https://i.stack.imgur.com/wnyNm.png" alt="benchmark" /></a></p>
<hr />
<p>Code used to produce the plot of runtime speed ratios:</p>
<pre class="lang-py prettyprint-override"><code>import random
import matplotlib.pyplot as plt
import perfplot


def enumerate_1(lst, target=3):
    return [i for i, v in enumerate(lst) if v == target]


def list_index_1(lst, target=3):
    result = []
    pos = -1
    while True:
        try:
            pos = lst.index(target, pos+1)
            result.append(pos)
        except ValueError:
            break
    return result


def list_index_2(lst, target):
    for item in lst:
        if item &gt; target:
            return lst.index(item)


def enumerate_2(lst, target):
    return next(i for i, item in enumerate(lst) if item &gt; target)


setups = [lambda n: [random.randint(1, 10) for _ in range(n)], 
          lambda n: (list(range(n)), n-1.5)]
kernels_list = [[enumerate_1, list_index_1], [enumerate_2, list_index_2]]
titles = ['Get indices of a value', 'Get index that satisfies a condition']
n_range = [2**k for k in range(1,21)]
labels = ['enumerate', 'list.index']
xlabel = 'list length'

fig, axs = plt.subplots(1, 2, figsize=(10, 5), facecolor='white', dpi=60)
for i, (ax, su, ks, t) in enumerate(zip(axs, setups, kernels_list, titles)):
    plt.sca(ax)
    perfplot.plot(ks, n_range, su, None, labels, xlabel, t, relative_to=1)
    ax.xaxis.set_tick_params(labelsize=13)
plt.setp(axs, ylim=(0.7, 2.4), yticks=[i*0.25 + 0.75 for i in range(7)], 
         xlim=(1, 1100000), xscale='log', xticks=[1, 100, 10000, 1000000])
fig.tight_layout();
</code></pre>
<h4> Kelly Bundy, Comment 135684215 Score: 1: </h4>Nicely done. And index() beating enumerate() in the second scenario despite the two passes is something I&#39;ve been telling/showing people a few times, I might point them here from now on :-)<br>------------------------------------------------------------------ <br><h3> jglad, Id: 74084377, Score: 3: </h3><p>In addition to all the excellent answers above, here is a solution to this problem when working with pandas Series objects. In many cases, pandas Series have custom/unique indices (for example, unique identifier strings) that can't be accessed with the <code>enumerate()</code> function.</p>
<blockquote>
<pre><code>xs = pd.Series([8, 23, 45])

xs.index = ['G923002', 'G923004', 'G923005']

print(xs)
</code></pre>
<p>Output:</p>
<pre><code>#    G923002     8
#    G923004    23
#    G923005    45
#    dtype: int64
</code></pre>
</blockquote>
<p>We can see below that <code>enumerate()</code> doesn't give us the desired result:</p>
<blockquote>
<pre><code>for id, x in enumerate(xs):
    print(&quot;id #{} = {}&quot;.format(id, x))
</code></pre>
<p>Output:</p>
<pre><code>#    id #0 = 8
#    id #1 = 23
#    id #2 = 45
</code></pre>
</blockquote>
<p>We can access the indices of a pandas Series in a for loop using <code>.items()</code>:</p>
<blockquote>
<pre><code>for id, x in xs.items():
    print(&quot;id #{} = {}&quot;.format(id, x))
</code></pre>
<p>Output:</p>
<pre><code>#    id #G923002 = 8
#    id #G923004 = 23
#    id #G923005 = 45
</code></pre>
</blockquote>
------------------------------------------------------------------ <br><h3> Maifee Ul Asad, Id: 74320395, Score: 3: </h3><p>One-liner lovers:</p>
<pre class="lang-py prettyprint-override"><code>[index for index, datum in enumerate(data) if 'a' in datum]
</code></pre>
<p>Explaination:</p>
<pre class="lang-py prettyprint-override"><code>&gt;&gt;&gt; data = ['a','ab','bb','ba','alskdhkjl','hkjferht','lal']
&gt;&gt;&gt; data
['a', 'ab', 'bb', 'ba', 'alskdhkjl', 'hkjferht', 'lal']
&gt;&gt;&gt; [index for index, datum in enumerate(data) if 'a' in datum]
[0, 1, 3, 4, 6]
&gt;&gt;&gt; [index for index, datum in enumerate(data) if 'b' in datum]
[1, 2, 3]
&gt;&gt;&gt;
</code></pre>
<p>Points to take:</p>
<ul>
<li>Python <code>list</code> doesn't provide an index; if you are using <code>for</code></li>
<li>If you <code>enumerate</code> a <code>list</code> it will return you ANOTHER <code>list</code>
<ul>
<li>BUT that list will have a different type</li>
<li>it will wrap each and every element with an index as <code>tuple</code></li>
<li>we can access tuples as variables, separated with comma(<code>,</code>)</li>
</ul>
</li>
</ul>
<p><em>Thanks. Keep me in your prayers.</em></p>
------------------------------------------------------------------ <br><h3> Ran Turner, Id: 72542661, Score: 2: </h3><p>You can use <code>range(len(some_list))</code> and then lookup the index like this</p>
<pre><code>xs = [8, 23, 45]
for i in range(len(xs)):
    print(&quot;item #{} = {}&quot;.format(i + 1, xs[i]))
</code></pre>
<p>Or use the Python’s built-in <code>enumerate</code> function which allows you to loop over a list and retrieve the index and the value of each item in the list</p>
<pre><code>xs = [8, 23, 45]
for idx, val in enumerate(xs, start=1):
    print(&quot;item #{} = {}&quot;.format(idx, val))
</code></pre>
------------------------------------------------------------------ <br><h3> kamalesh d, Id: 72216703, Score: 0: </h3><p>It can be achieved with the following code:</p>
<pre><code>xs = [8, 23, 45]
for x, n in zip(xs, range(1, len(xs)+1)):
    print(&quot;item #{} = {}&quot;.format(n, x))
</code></pre>
<p>Here, range(1, len(xs)+1); If you expect the output to start from 1 instead of 0, you need to start the range from 1 and add 1 to the total length estimated since python starts indexing the number from 0 by default.</p>
<pre><code>Final Output:
item #1 = 8
item #2 = 23
item #3 = 45
</code></pre>
------------------------------------------------------------------ <br><h3> LunaticXXD10, Id: 70595306, Score: -5: </h3><p>A loop with a &quot;counter&quot; variable set as an initialiser that will be a parameter, in formatting the string, as the item number.</p>
<p>The <em>for</em> loop accesses the &quot;listos&quot; variable which is the list. As we access the list by &quot;i&quot;, &quot;i&quot; is formatted as the item price (or whatever it is).</p>
<pre><code>listos = [8, 23, 45, 12, 78]
counter = 1
for i in listos:
    print('Item #{} = {}'.format(counter, i))
    counter += 1
</code></pre>
<p>Output:</p>
<pre class="lang-none prettyprint-override"><code>Item #1 = 8
Item #2 = 23
Item #3 = 45
Item #4 = 12
Item #5 = 78
</code></pre>
<h4> General Grievance, Comment 124886118 Score: 1: </h4>@LunaticXXD10 In your <i>original post</i>, which you can see in the edit history, <code>counter += 1</code> was indented at the same level as the <code>for</code> loop. In that case, it would have updated per iteration of the <code>for</code> loop. Here, it updates per iteration of the <code>while</code> loop. My question on the <code>while</code> loop remains: Why is it necessary to use a while loop when counter can be updated in the <code>for</code> loop? This is plainly visible in <a href="https://stackoverflow.com/a/67461537/4294399">Rahul&#39;s answer</a>.<br><h4> Peter Mortensen, Comment 127121436 Score: 1: </h4>Re <i>&quot;...must be enough aware about programming that indentation matters&quot;</i>: Well, computers are quite literally minded.<br><h4> LunaticXXD10, Comment 124863879 Score: 0: </h4>@calculuswhiz the while loop is an important code snippet. the initialiser &quot;counter&quot; is used for item number.  About Indentation: The guy must be enough aware about programming that indentation matters. so after you do your special attribute...{copy paste} you can still edit the indentation.  <i>And the code runs very nicely and smoothly</i><br>------------------------------------------------------------------ <br><h3> Sumit Kumar, Id: 49999727, Score: -7: </h3><p>This serves the purpose well enough:</p>
<pre><code>list1 = [10, 'sumit', 43.21, 'kumar', '43', 'test', 3]
for x in list1:
    print('index:', list1.index(x), 'value:', x)
</code></pre>
<h4> Peter Szoldan, Comment 87728132 Score: 16: </h4>This will break down if there are repeated elements in the list as <code>index()</code> will search for the first occurrence of <code>x</code>, not mentioning the O( <b><i>n^2</i></b> ) time required to look up each element.<br><h4> Sumit Kumar, Comment 88444133 Score: 0: </h4>totally agreed that it won&#39;t work for duplicate elements in the list. afterall I&#39;m also learning python.<br><h4> Peter Mortensen, Comment 127119462 Score: 0: </h4>The accepted suggested edit by user <i>Raj kumar</i> resulted in the error <i>&quot;NameError: name &#39;list1&#39; is not defined&quot;</i><br>