 <h2> Title: Best way to give a variable a default value (simulate Perl ||, ||= ) </h2> <h3> Tom Auger, question_id: 5972516 </h3>Score: 164, Tags: {php,perl,operators,default-value} <br><p>I love doing this sort of thing in Perl: <code>$foo = $bar || $baz</code> to assign <code>$baz</code> to <code>$foo</code> if <code>$bar</code> is empty or undefined. You also have <code>$foo ||= $bletch</code> which will only assign <code>$bletch</code> to <code>$foo</code> if <code>$foo</code> is not defined or empty.</p>

<p>The ternary operator in this situation is tedious and tiresome. Surely there's a simple, elegant method available in PHP?</p>

<p>Or is the only answer a custom function that uses isset()? </p>
<h4> Comment 51694940 Palec: </h4>Related on <a href="https://codereview.stackexchange.com">Code Review</a>: <a href="http://codereview.stackexchange.com/q/12722/31433">codereview.stackexchange.com/q/12722/31433</a><br><h4> Comment 51694978 Palec: </h4>BTW the Perl operators with the desired functionality are <code>&#47;&#47;</code> and <code>&#47;&#47;=</code> and they exist as of Perl v5.10.0. The original <code>||</code> and <code>||=</code> test for logical value, not for definedness.<br><h4> Comment 51763564 Tom Auger: </h4>@Palec, why would a 4-year old question with 29 upvotes be identified as a duplicate of a 1-year old question with 6 upvotes (which itself was marked as a duplicate of another question?) I think there&#39;s great value in keeping this question, as the title is more generic (doesn&#39;t reference the answer ie: isset()).<br><h4> Comment 51766794 Palec: </h4>Theyâ€™re clear and exact duplicates. It admit I did not think much about which one should be the original, I was in the middle of something else, making a link between the two was the goal. Retracting my VTC.<br><h4> Comment 51766858 Palec: </h4>An exact duplicate, marked (IMO erroneously) as a duplicate of another question: <a href="http://stackoverflow.com/q/18603250/2157640">PHP shorthand for isset()?</a><br><h4> Comment 54234052 Black: </h4>your variable names are confusing me. Why you don&#39;t use &quot;x&quot; &quot;y&quot; &quot;z&quot; ...??<br><h4> Comment 54793321 Tom Auger: </h4>@EdwardBlack Actually, &quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot; and (arguably) &quot;bletch&quot; are pretty common place in the programming world - about as common as &quot;x&quot;, &quot;y&quot;, and &quot;z&quot; in the context of giving example variable / function / method names.<br>------------------------------------------------------------------ <br><h3> Answer 5972529 BoltClock: </h3><p>PHP 5.3 has a shorthand <code>?:</code> operator:</p>

<pre><code>$foo = $bar ?: $baz;
</code></pre>

<p>Which assigns <code>$bar</code> if it's not an empty value (I don't know how this would be different in PHP from Perl), otherwise <code>$baz</code>, and is the same as this in Perl and older versions of PHP:</p>

<pre><code>$foo = $bar ? $bar : $baz;
</code></pre>

<p>But PHP does not have a compound assignment operator for this (that is, no equivalent of Perl's <code>||=</code>).</p>

<p>Also, PHP will make noise if <code>$bar</code> isn't set unless you turn notices off. There is also a semantic difference between <code>isset()</code> and <code>empty()</code>. The former returns false if the variable doesn't exist, or is set to <code>NULL</code>. The latter returns true if it doesn't exist, or is set to <code>0</code>, <code>''</code>, <code>false</code> or <code>NULL</code>.</p>
<h4> Comment 6891696 Michael Berkowski: </h4>+1 For introducing me to yet another great feature of 5.3 I&#39;m missing out on in my RHEL5/PHP5.1.2 servers.<br><h4> Comment 36982354 Brad: </h4>Note that if your variable is undefined, PHP will throw notices about it.  This, unfortunately, is no replacement for <code>$var = isset($var) ? $var : &#39;default value&#39;;</code>  It says that in the answer... just pointing it out again for anyone that skims it.  :-D<br><h4> Comment 55160693 Codemonkey: </h4>Is it bad to do $var = @$var ?: &#39;default value&#39;;  If so, why?  Given that the only &quot;error&quot; could be that $var isn&#39;t set, and that we don&#39;t care if $var isn&#39;t set...<br><h4> Comment 6895089 Toto: </h4>I guess you mean <code>The first returns</code> instead of <code>The second</code> in your penultimate sentence.<br>------------------------------------------------------------------ <br><h3> Answer 36796941 jpschroeder: </h3><p>In PHP 7 we finally have a way to do this elegantly. It is called the <a href="http://php.net/manual/en/migration70.new-features.php#migration70.new-features.null-coalesce-op">Null coalescing operator</a>. You can use it like this:</p>

<pre><code>$name = $_GET['name'] ?? 'john doe';
</code></pre>

<p>This is equivalent to</p>

<pre><code>$name = isset($_GET['name']) ? $_GET['name']:'john doe';
</code></pre>
<h4> Comment 120246718 Xsmael: </h4>@Mariano yeah but how is the spaceship operator relevant here ?<br><h4> Comment 75956052 Mariano: </h4>I&#39;d argue the <a href="http://php.net/manual/en/migration70.new-features.php#migration70.new-features.spaceship-op" rel="nofollow noreferrer">spaceship operator</a> has merit too.<br><h4> Comment 88736698 HPWD: </h4>I thought Mariano was pulling our legs but nope, it&#39;s a thing <code>&lt;=&gt;</code> and pretty accurate to boot!<br><h4> Comment 109518603 VPhantom: </h4>Note that the null coalescing operator behaves differently from the conditional operator, as it is specific to a <code>null</code> value. For example, if <code>$_GET[&#39;name&#39;]</code> is set to an empty string, the first line would return an empty string, but we could return &quot;john doe&quot; by using <code>$_GET[&#39;name&#39;] ? $_GET[&#39;name&#39;] : &#39;john doe&#39;</code>.<br><h4> Comment 131133184 mickmackusa: </h4>This answer is misleading/incorrect.  See VPhantom&#39;s comment as to why this answer is harming the researcher experience.<br>------------------------------------------------------------------ <br><h3> Answer 46989164 AndreyS Scherbakov: </h3><p>In PHP earlier than 7.*, one may use ?: for an undefined variable having errors locally suppressed with an <code>@</code>:</p>

<pre><code>$foo = @$bar ?: $baz;
</code></pre>
<h4> Comment 126477737 XCS: </h4>What happens in versions later than 7.* ?<br><h4> Comment 134938649 Kimmax: </h4>@XCS Seems to work just fine<br>------------------------------------------------------------------ <br><h3> Answer 5979751 Tom Auger: </h3><p>Thanks for all the great answers!</p>

<p>For anyone else coming here for a possible alternative, here are some functions that help take the tedium out of this sort of thing.</p>

<pre><code>function set_if_defined(&amp;$var, $test){
    if (isset($test)){
        $var = $test;
        return true;
    } else {
        return false;
    }
}

function set_unless_defined(&amp;$var, $default_var){
    if (! isset($var)){
        $var = $default_var;
        return true;
    } else {
        return false;
    }
}

function select_defined(){
    $l = func_num_args();
    $a = func_get_args();
    for ($i=0; $i&lt;$l; $i++){
        if ($a[$i]) return $a[$i];
    }
}
</code></pre>

<p>Examples:</p>

<pre><code>// $foo ||= $bar;
set_unless_defined($foo, $bar);

//$foo = $baz || $bletch
$foo = select_defined($baz, $bletch);
</code></pre>

<p>I'm sure these can be improved upon.</p>
------------------------------------------------------------------ <br><h3> Answer 5972567 mario: </h3><p>A common idiom to stay compatible with older PHP versions is:</p>

<pre><code> $var = $bool   or   $var = "default";
 // If I use it, then only with excessive spaces for clarity.
</code></pre>

<p>This works for values that can be evaluated in boolean context. The advantage here is that it also gives you said debug e_notice should the variable be undefined.</p>
<h4> Comment 6891640 BoltClock: </h4>Is a notice not emitted with <code>$bool ? $bool : &quot;default&quot;</code> if <code>$bool</code> isn&#39;t defined?<br><h4> Comment 6891660 mario: </h4>Sure, that&#39;s the same. I assumed OP is referring to <code>isset($var) ? $var : DEFAULT</code>. But sounds like he wants to shun them anyway.<br>------------------------------------------------------------------ <br><h3> Answer 56657871 Bassem Shahin: </h3><p>this is another good format for the <code>isset</code> case</p>

<p><code>isset($foo) || $foo= $bar;</code></p>

<p>another simple way and will give you more control as you can add more conditions and assign to another variable in the same time</p>

<p><code>$foo = (isset($oData['foo']))?$bar['foo']:'default value';</code></p>
------------------------------------------------------------------ <br><h3> Answer 60979400 dkellner: </h3><h3>A possible solution: defaultFor( )</h3>

<p>Unless we have a factory solution (which is indeed very annoying), I'd recommend the following little helper. It does the job in most cases:</p>

<pre class="lang-php prettyprint-override"><code>
    function defaultFor(&amp;$x,$default=null) {
        if(!isset($x)) $x = $default;
    }

    //--------------------  Now you can do this: --------------

    defaultFor($a,"Jack");  // if $a is not set, it will be "Jack"
    defaultFor($x);         // no more notices for $x but keep it !isset

</code></pre>

<p>I hope this is close to what you wanted to achieve. It will not give you any notices if you use it with a nonexistent variable, and it's quite convenient. Surely it has a drawback: the default value always gets calculated beforehand so don't use it with anything heavy as a second parameter, like a file_get_contents or something. In those cases, you're better off with isseting.</p>
------------------------------------------------------------------ <br><h3> Answer 63223614 Zombo: </h3><p>I think in general doing something like this:</p>
<pre class="lang-php prettyprint-override"><code>$foo = $bar || $baz;
</code></pre>
<p>is a bad idea, unless <code>$bar</code> and <code>$baz</code> are both booleans. If they aren't:</p>
<pre class="lang-php prettyprint-override"><code>$bar = 10;
$baz = 11;
</code></pre>
<p>then the question becomes: what determines if something is true or false? Most people would probably expect zero to be false, and everything else to be true. But with some languages (for example Ruby), only <code>false</code> and <code>nil</code> are false, which means both <code>0</code> and <code>1</code> would be true. Because of this cross language ambiguity, I think it best to be explicit in these cases:</p>
<pre class="lang-php prettyprint-override"><code>if ($bar !== 0) {
   $foo = $bar;
} else {
   $foo = $baz;
}
</code></pre>
<p>or:</p>
<pre class="lang-php prettyprint-override"><code>$foo = $bar !== 0 ? $bar : $baz;
</code></pre>
