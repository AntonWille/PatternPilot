 <h2> Title: Best way to give a variable a default value (simulate Perl ||, ||= ) </h2> <h4> Tom Auger, question_id: 5972516, created_at: 2011-05-12 01:50:20+00:00 </h4>Score: 164, Tags: {php,perl,operators,default-value} <br><p>I love doing this sort of thing in Perl: <code>$foo = $bar || $baz</code> to assign <code>$baz</code> to <code>$foo</code> if <code>$bar</code> is empty or undefined. You also have <code>$foo ||= $bletch</code> which will only assign <code>$bletch</code> to <code>$foo</code> if <code>$foo</code> is not defined or empty.</p>

<p>The ternary operator in this situation is tedious and tiresome. Surely there's a simple, elegant method available in PHP?</p>

<p>Or is the only answer a custom function that uses isset()? </p>
<h4> Comment by Palec, Score: 1, Id: 51694940, created_at: 2015-08-08 01:28:41+00:00 </h4>Related on <a href="https://codereview.stackexchange.com">Code Review</a>: <a href="http://codereview.stackexchange.com/q/12722/31433">codereview.stackexchange.com/q/12722/31433</a><h4> Comment by Palec, Score: 1, Id: 51694978, created_at: 2015-08-08 01:33:14+00:00 </h4>BTW the Perl operators with the desired functionality are <code>&#47;&#47;</code> and <code>&#47;&#47;=</code> and they exist as of Perl v5.10.0. The original <code>||</code> and <code>||=</code> test for logical value, not for definedness.<h4> Comment by Tom Auger, Score: 1, Id: 51763564, created_at: 2015-08-10 17:24:39+00:00 </h4>@Palec, why would a 4-year old question with 29 upvotes be identified as a duplicate of a 1-year old question with 6 upvotes (which itself was marked as a duplicate of another question?) I think there&#39;s great value in keeping this question, as the title is more generic (doesn&#39;t reference the answer ie: isset()).<h4> Comment by Palec, Score: 0, Id: 51766794, created_at: 2015-08-10 19:09:12+00:00 </h4>They’re clear and exact duplicates. It admit I did not think much about which one should be the original, I was in the middle of something else, making a link between the two was the goal. Retracting my VTC.<h4> Comment by Palec, Score: 0, Id: 51766858, created_at: 2015-08-10 19:11:13+00:00 </h4>An exact duplicate, marked (IMO erroneously) as a duplicate of another question: <a href="http://stackoverflow.com/q/18603250/2157640">PHP shorthand for isset()?</a><h4> Comment by Black, Score: 0, Id: 54234052, created_at: 2015-10-19 13:00:09+00:00 </h4>your variable names are confusing me. Why you don&#39;t use &quot;x&quot; &quot;y&quot; &quot;z&quot; ...??<h4> Comment by Tom Auger, Score: 0, Id: 54793321, created_at: 2015-11-03 17:04:52+00:00 </h4>@EdwardBlack Actually, &quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot; and (arguably) &quot;bletch&quot; are pretty common place in the programming world - about as common as &quot;x&quot;, &quot;y&quot;, and &quot;z&quot; in the context of giving example variable / function / method names.<hr><h3>  Answer by BoltClock, Id: 5972529, Score: 237, created_at: 2011-05-12 01:52:09+00:00 </h3><p>PHP 5.3 has a shorthand <code>?:</code> operator:</p>

<pre><code>$foo = $bar ?: $baz;
</code></pre>

<p>Which assigns <code>$bar</code> if it's not an empty value (I don't know how this would be different in PHP from Perl), otherwise <code>$baz</code>, and is the same as this in Perl and older versions of PHP:</p>

<pre><code>$foo = $bar ? $bar : $baz;
</code></pre>

<p>But PHP does not have a compound assignment operator for this (that is, no equivalent of Perl's <code>||=</code>).</p>

<p>Also, PHP will make noise if <code>$bar</code> isn't set unless you turn notices off. There is also a semantic difference between <code>isset()</code> and <code>empty()</code>. The former returns false if the variable doesn't exist, or is set to <code>NULL</code>. The latter returns true if it doesn't exist, or is set to <code>0</code>, <code>''</code>, <code>false</code> or <code>NULL</code>.</p>
<h4> Comment by Codemonkey, Score: 6, Id: 55160693, created_at: 2015-11-13 14:14:08+00:00 </h4>Is it bad to do $var = @$var ?: &#39;default value&#39;;  If so, why?  Given that the only &quot;error&quot; could be that $var isn&#39;t set, and that we don&#39;t care if $var isn&#39;t set...<h4> Comment by Brad, Score: 24, Id: 36982354, created_at: 2014-06-02 15:00:00+00:00 </h4>Note that if your variable is undefined, PHP will throw notices about it.  This, unfortunately, is no replacement for <code>$var = isset($var) ? $var : &#39;default value&#39;;</code>  It says that in the answer... just pointing it out again for anyone that skims it.  :-D<h4> Comment by Michael Berkowski, Score: 2, Id: 6891696, created_at: 2011-05-12 02:10:54+00:00 </h4>+1 For introducing me to yet another great feature of 5.3 I&#39;m missing out on in my RHEL5/PHP5.1.2 servers.<h4> Comment by Toto, Score: 0, Id: 6895089, created_at: 2011-05-12 08:16:56+00:00 </h4>I guess you mean <code>The first returns</code> instead of <code>The second</code> in your penultimate sentence.<hr><h3> ✔️ Answer by jpschroeder, Id: 36796941, Score: 179, created_at: 2016-04-22 14:48:19+00:00 </h3><p>In PHP 7 we finally have a way to do this elegantly. It is called the <a href="http://php.net/manual/en/migration70.new-features.php#migration70.new-features.null-coalesce-op">Null coalescing operator</a>. You can use it like this:</p>

<pre><code>$name = $_GET['name'] ?? 'john doe';
</code></pre>

<p>This is equivalent to</p>

<pre><code>$name = isset($_GET['name']) ? $_GET['name']:'john doe';
</code></pre>
<h4> Comment by Mariano, Score: 15, Id: 75956052, created_at: 2017-06-11 05:41:55+00:00 </h4>I&#39;d argue the <a href="http://php.net/manual/en/migration70.new-features.php#migration70.new-features.spaceship-op" rel="nofollow noreferrer">spaceship operator</a> has merit too.<h4> Comment by HPWD, Score: 4, Id: 88736698, created_at: 2018-06-14 23:32:29+00:00 </h4>I thought Mariano was pulling our legs but nope, it&#39;s a thing <code>&lt;=&gt;</code> and pretty accurate to boot!<h4> Comment by VPhantom, Score: 2, Id: 109518603, created_at: 2020-05-20 18:33:00+00:00 </h4>Note that the null coalescing operator behaves differently from the conditional operator, as it is specific to a <code>null</code> value. For example, if <code>$_GET[&#39;name&#39;]</code> is set to an empty string, the first line would return an empty string, but we could return &quot;john doe&quot; by using <code>$_GET[&#39;name&#39;] ? $_GET[&#39;name&#39;] : &#39;john doe&#39;</code>.<h4> Comment by Xsmael, Score: 0, Id: 120246718, created_at: 2021-06-18 10:17:11+00:00 </h4>@Mariano yeah but how is the spaceship operator relevant here ?<h4> Comment by mickmackusa, Score: 0, Id: 131133184, created_at: 2022-11-01 13:03:47+00:00 </h4>This answer is misleading/incorrect.  See VPhantom&#39;s comment as to why this answer is harming the researcher experience.<hr><h3>  Answer by AndreyS Scherbakov, Id: 46989164, Score: 11, created_at: 2017-10-28 11:23:08+00:00 </h3><p>In PHP earlier than 7.*, one may use ?: for an undefined variable having errors locally suppressed with an <code>@</code>:</p>

<pre><code>$foo = @$bar ?: $baz;
</code></pre>
<h4> Comment by XCS, Score: 2, Id: 126477737, created_at: 2022-03-21 16:58:08+00:00 </h4>What happens in versions later than 7.* ?<h4> Comment by Kimmax, Score: 0, Id: 134938649, created_at: 2023-06-22 12:29:46+00:00 </h4>@XCS Seems to work just fine<hr><h3>  Answer by Tom Auger, Id: 5979751, Score: 8, created_at: 2011-05-12 14:40:52+00:00 </h3><p>Thanks for all the great answers!</p>

<p>For anyone else coming here for a possible alternative, here are some functions that help take the tedium out of this sort of thing.</p>

<pre><code>function set_if_defined(&amp;$var, $test){
    if (isset($test)){
        $var = $test;
        return true;
    } else {
        return false;
    }
}

function set_unless_defined(&amp;$var, $default_var){
    if (! isset($var)){
        $var = $default_var;
        return true;
    } else {
        return false;
    }
}

function select_defined(){
    $l = func_num_args();
    $a = func_get_args();
    for ($i=0; $i&lt;$l; $i++){
        if ($a[$i]) return $a[$i];
    }
}
</code></pre>

<p>Examples:</p>

<pre><code>// $foo ||= $bar;
set_unless_defined($foo, $bar);

//$foo = $baz || $bletch
$foo = select_defined($baz, $bletch);
</code></pre>

<p>I'm sure these can be improved upon.</p>
<hr><h3>  Answer by mario, Id: 5972567, Score: 7, created_at: 2011-05-12 01:59:54+00:00 </h3><p>A common idiom to stay compatible with older PHP versions is:</p>

<pre><code> $var = $bool   or   $var = "default";
 // If I use it, then only with excessive spaces for clarity.
</code></pre>

<p>This works for values that can be evaluated in boolean context. The advantage here is that it also gives you said debug e_notice should the variable be undefined.</p>
<h4> Comment by BoltClock, Score: 0, Id: 6891640, created_at: 2011-05-12 02:03:10+00:00 </h4>Is a notice not emitted with <code>$bool ? $bool : &quot;default&quot;</code> if <code>$bool</code> isn&#39;t defined?<h4> Comment by mario, Score: 0, Id: 6891660, created_at: 2011-05-12 02:05:46+00:00 </h4>Sure, that&#39;s the same. I assumed OP is referring to <code>isset($var) ? $var : DEFAULT</code>. But sounds like he wants to shun them anyway.<hr><h3>  Answer by Bassem Shahin, Id: 56657871, Score: 0, created_at: 2019-06-18 22:34:38+00:00 </h3><p>this is another good format for the <code>isset</code> case</p>

<p><code>isset($foo) || $foo= $bar;</code></p>

<p>another simple way and will give you more control as you can add more conditions and assign to another variable in the same time</p>

<p><code>$foo = (isset($oData['foo']))?$bar['foo']:'default value';</code></p>
<hr><h3>  Answer by dkellner, Id: 60979400, Score: 0, created_at: 2020-04-01 20:06:31+00:00 </h3><h3>A possible solution: defaultFor( )</h3>

<p>Unless we have a factory solution (which is indeed very annoying), I'd recommend the following little helper. It does the job in most cases:</p>

<pre class="lang-php prettyprint-override"><code>
    function defaultFor(&amp;$x,$default=null) {
        if(!isset($x)) $x = $default;
    }

    //--------------------  Now you can do this: --------------

    defaultFor($a,"Jack");  // if $a is not set, it will be "Jack"
    defaultFor($x);         // no more notices for $x but keep it !isset

</code></pre>

<p>I hope this is close to what you wanted to achieve. It will not give you any notices if you use it with a nonexistent variable, and it's quite convenient. Surely it has a drawback: the default value always gets calculated beforehand so don't use it with anything heavy as a second parameter, like a file_get_contents or something. In those cases, you're better off with isseting.</p>
<hr><h3>  Answer by Zombo, Id: 63223614, Score: 0, created_at: 2020-08-03 04:10:03+00:00 </h3><p>I think in general doing something like this:</p>
<pre class="lang-php prettyprint-override"><code>$foo = $bar || $baz;
</code></pre>
<p>is a bad idea, unless <code>$bar</code> and <code>$baz</code> are both booleans. If they aren't:</p>
<pre class="lang-php prettyprint-override"><code>$bar = 10;
$baz = 11;
</code></pre>
<p>then the question becomes: what determines if something is true or false? Most people would probably expect zero to be false, and everything else to be true. But with some languages (for example Ruby), only <code>false</code> and <code>nil</code> are false, which means both <code>0</code> and <code>1</code> would be true. Because of this cross language ambiguity, I think it best to be explicit in these cases:</p>
<pre class="lang-php prettyprint-override"><code>if ($bar !== 0) {
   $foo = $bar;
} else {
   $foo = $baz;
}
</code></pre>
<p>or:</p>
<pre class="lang-php prettyprint-override"><code>$foo = $bar !== 0 ? $bar : $baz;
</code></pre>
