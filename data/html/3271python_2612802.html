 <h2> Title: How do I clone a list so that it doesn&#39;t change unexpectedly after assignment? </h2> <h3> aF., question_id: 2612802 </h3>Score: 3271, Tags: {python,list,clone,mutable} <br><p>While using <code>new_list = my_list</code>, any modifications to <code>new_list</code> changes <code>my_list</code> every time. Why is this, and how can I clone or copy the list to prevent it?</p>
<h4> Comment 125187420 Bharel: </h4>See the <a href="https://docs.python.org/3/faq/programming.html#why-did-changing-list-y-also-change-list-x" rel="nofollow noreferrer">Python FAQ</a>.<br><h4> Comment 123683957 Andrew: </h4><code>new_list = my_list</code> just assigns the name <code>new_list</code> to the object <code>my_list</code> refers to.<br><h4> Comment 128071906 Karl Knechtel: </h4>See also: <a href="https://stackoverflow.com/questions/240178">stackoverflow.com/questions/240178</a><br><h4> Comment 128097571 jdhao: </h4>Related: <a href="https://stackoverflow.com/q/2322068/6064933">this post</a> and <a href="https://stackoverflow.com/q/15377050/6064933">this</a><br>------------------------------------------------------------------ <br><h3> Answer 2612815 Felix Kling: </h3><p><code>new_list = my_list</code> doesn't actually create a second list. The assignment just copies the reference to the list, not the actual list, so both <code>new_list</code> and <code>my_list</code> refer to the same list after the assignment.</p>
<p>To actually copy the list, you have several options:</p>
<ul>
<li><p>You can use the built-in <a href="https://docs.python.org/library/stdtypes.html#mutable-sequence-types" rel="noreferrer"><code>list.copy()</code></a> method (available since Python 3.3):</p>
<pre><code>new_list = old_list.copy()
</code></pre>
</li>
<li><p>You can slice it:</p>
<pre><code>new_list = old_list[:]
</code></pre>
<p><a href="https://en.wikipedia.org/wiki/Alex_Martelli" rel="noreferrer">Alex Martelli</a>'s opinion (at least <a href="https://www.youtube.com/watch?v=g7V89K8QfgQ" rel="noreferrer">back in 2007</a>) about this is, that <em>it is a weird syntax and it does not make sense to use it ever</em>. ;) (In his opinion, the next one is more readable).</p>
</li>
<li><p>You can use the built-in <a href="https://docs.python.org/library/stdtypes.html#list" rel="noreferrer"><code>list()</code></a> constructor:</p>
<pre><code>new_list = list(old_list)
</code></pre>
</li>
<li><p>You can use generic <a href="https://docs.python.org/library/copy.html#copy.copy" rel="noreferrer"><code>copy.copy()</code></a>:</p>
<pre><code>import copy
new_list = copy.copy(old_list)
</code></pre>
<p>This is a little slower than <code>list()</code> because it has to find out the datatype of <code>old_list</code> first.</p>
</li>
<li><p>If you need to copy the elements of the list as well, use generic <a href="https://docs.python.org/library/copy.html#copy.deepcopy" rel="noreferrer"><code>copy.deepcopy()</code></a>:</p>
<pre><code>import copy
new_list = copy.deepcopy(old_list)
</code></pre>
<p>Obviously the slowest and most memory-needing method, but sometimes unavoidable. This operates recursively; it will handle any number of levels of nested lists (or other containers).</p>
</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code>import copy

class Foo(object):
    def __init__(self, val):
         self.val = val

    def __repr__(self):
        return f'Foo({self.val!r})'

foo = Foo(1)

a = ['foo', foo]
b = a.copy()
c = a[:]
d = list(a)
e = copy.copy(a)
f = copy.deepcopy(a)

# edit orignal list and instance 
a.append('baz')
foo.val = 5

print(f'original: {a}\nlist.copy(): {b}\nslice: {c}\nlist(): {d}\ncopy: {e}\ndeepcopy: {f}')
</code></pre>
<p>Result:</p>
<pre><code>original: ['foo', Foo(5), 'baz']
list.copy(): ['foo', Foo(5)]
slice: ['foo', Foo(5)]
list(): ['foo', Foo(5)]
copy: ['foo', Foo(5)]
deepcopy: ['foo', Foo(1)]
</code></pre>
<h4> Comment 115618926 moojen: </h4>As @Georgy points out correctly in the answer below, any changes to the new_list values will also change the values in my_list. So actually the copy.deepcopy() method is the only real copy without reference to the original list and it&#39;s values.<br><h4> Comment 129605566 wjandrea: </h4>@moojen Because the list itself is mutable, and a new assignment only creates a reference. E.g. <code>x = []; y = x; y.append(1); x</code> -&gt; <code>[1]</code><br><h4> Comment 129567928 wjandrea: </h4>@moojen If <code>my_list</code> contains only immutable objects, that&#39;s a non-issue.<br><h4> Comment 129602871 moojen: </h4>@wjandrea Why copy a list of immutable objects?<br>------------------------------------------------------------------ <br><h3> Answer 2612990 cryo: </h3><p>Felix already provided an excellent answer, but I thought I'd do a speed comparison of the various methods:</p>
<ol>
<li>10.59 sec (105.9 µs/itn) -  <a href="http://docs.python.org/library/copy.html#copy.deepcopy" rel="noreferrer"><code>copy.deepcopy(old_list)</code></a></li>
<li>10.16 sec (101.6 µs/itn) - pure Python <code>Copy()</code> method copying classes with deepcopy</li>
<li>1.488 sec (14.88 µs/itn) - pure Python <code>Copy()</code> method not copying classes (only dicts/lists/tuples)</li>
<li>0.325 sec (3.25 µs/itn) - <code>for item in old_list: new_list.append(item)</code></li>
<li>0.217 sec (2.17 µs/itn) - <code>[i for i in old_list]</code> (a <a href="http://docs.python.org/tutorial/datastructures.html#list-comprehensions" rel="noreferrer">list comprehension</a>)</li>
<li>0.186 sec (1.86 µs/itn) - <a href="http://docs.python.org/library/copy.html#copy.copy" rel="noreferrer"><code>copy.copy(old_list)</code></a></li>
<li>0.075 sec (0.75 µs/itn) - <code>list(old_list)</code></li>
<li>0.053 sec (0.53 µs/itn) - <code>new_list = []; new_list.extend(old_list)</code></li>
<li>0.039 sec (0.39 µs/itn) - <code>old_list[:]</code> (<a href="http://docs.python.org/tutorial/introduction.html#lists" rel="noreferrer">list slicing</a>)</li>
</ol>
<p>So the fastest is list slicing. But be aware that <code>copy.copy()</code>, <code>list[:]</code> and <code>list(list)</code>, unlike <code>copy.deepcopy()</code> and the python version don't copy any lists, dictionaries and class instances in the list, so if the originals change, they will change in the copied list too and vice versa.</p>
<p>(Here's the script if anyone's interested or wants to raise any issues:)</p>
<pre><code>from copy import deepcopy

class old_class:
    def __init__(self):
        self.blah = 'blah'

class new_class(object):
    def __init__(self):
        self.blah = 'blah'

dignore = {str: None, unicode: None, int: None, type(None): None}

def Copy(obj, use_deepcopy=True):
    t = type(obj)

    if t in (list, tuple):
        if t == tuple:
            # Convert to a list if a tuple to
            # allow assigning to when copying
            is_tuple = True
            obj = list(obj)
        else:
            # Otherwise just do a quick slice copy
            obj = obj[:]
            is_tuple = False

        # Copy each item recursively
        for x in xrange(len(obj)):
            if type(obj[x]) in dignore:
                continue
            obj[x] = Copy(obj[x], use_deepcopy)

        if is_tuple:
            # Convert back into a tuple again
            obj = tuple(obj)

    elif t == dict:
        # Use the fast shallow dict copy() method and copy any
        # values which aren't immutable (like lists, dicts etc)
        obj = obj.copy()
        for k in obj:
            if type(obj[k]) in dignore:
                continue
            obj[k] = Copy(obj[k], use_deepcopy)

    elif t in dignore:
        # Numeric or string/unicode?
        # It's immutable, so ignore it!
        pass

    elif use_deepcopy:
        obj = deepcopy(obj)
    return obj

if __name__ == '__main__':
    import copy
    from time import time

    num_times = 100000
    L = [None, 'blah', 1, 543.4532,
         ['foo'], ('bar',), {'blah': 'blah'},
         old_class(), new_class()]

    t = time()
    for i in xrange(num_times):
        Copy(L)
    print 'Custom Copy:', time()-t

    t = time()
    for i in xrange(num_times):
        Copy(L, use_deepcopy=False)
    print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time()-t

    t = time()
    for i in xrange(num_times):
        copy.copy(L)
    print 'copy.copy:', time()-t

    t = time()
    for i in xrange(num_times):
        copy.deepcopy(L)
    print 'copy.deepcopy:', time()-t

    t = time()
    for i in xrange(num_times):
        L[:]
    print 'list slicing [:]:', time()-t

    t = time()
    for i in xrange(num_times):
        list(L)
    print 'list(L):', time()-t

    t = time()
    for i in xrange(num_times):
        [i for i in L]
    print 'list expression(L):', time()-t

    t = time()
    for i in xrange(num_times):
        a = []
        a.extend(L)
    print 'list extend:', time()-t

    t = time()
    for i in xrange(num_times):
        a = []
        for y in L:
            a.append(y)
    print 'list append:', time()-t

    t = time()
    for i in xrange(num_times):
        a = []
        a.extend(i for i in L)
    print 'generator expression extend:', time()-t
</code></pre>
<h4> Comment 130035045 Hacker: </h4>What is with <code>list.copy()</code> ?<br><h4> Comment 129567914 wjandrea: </h4>These numbers might be outdated. I tried running <a href="https://gist.github.com/wjandrea/04fefb1db77a2eb47739fa4954705013" rel="nofollow noreferrer">a modified version of the script</a> on my PC (which is even pretty old), and all the numbers are significantly lower. Notably, a list comprehension is more than 4 times faster, by my count.<br><h4> Comment 130789469 Karl Knechtel: </h4>I haven&#39;t looked into it; but my guess is that the changes to local lookup in 3.x, in addition to the change so that list comprehensions get their own scope, makes it possible to compile lookups of the iteration variable into <code>LOAD_FAST</code> and this causes the relative speedup.<br><h4> Comment 133508346 Karl Knechtel: </h4>River&#39;s answer gives more current timings: <a href="https://stackoverflow.com/a/43220129/">stackoverflow.com/a/43220129</a><br><h4> Comment 130788975 Karl Knechtel: </h4>@wjandrea the numbers are always going to be relative to each other as hardware improves, and somewhat approximate. The interesting thing is whether the <i>ratios</i> change <i>with new Python versions</i> (also keeping in mind that new Python versions, along with standard library upgrades, may create <i>new</i> methods entirely).<br><h4> Comment 130789457 wjandrea: </h4>@Karl Good point, they haven&#39;t changed positions relatively, but the ratios have changed. List comprehensions have gone from 5.6 times slower than slicing to 2.8 times, a relative speedup of 200%.<br><h4> Comment 119115083 uuu777: </h4>Does it mean that append and list comprehension are the best options?<br><h4> Comment 124242121 Klim Yadrintsev: </h4>I keep on coming back to this answer to make sure that I am using the most efficient method. What is the easiest way to test this? Or is there a database with all of the best ways to minimise run time?<br>------------------------------------------------------------------ <br><h3> Answer 17810305 anatoly techtonik: </h3><p>I've <a href="http://mail.python.org/pipermail/python-ideas/2013-July/022368.html" rel="noreferrer">been told</a> that Python 3.3+ <a href="http://bugs.python.org/issue10516" rel="noreferrer">adds the <code>list.copy()</code></a> method, which should be as fast as slicing:</p>
<pre><code>newlist = old_list.copy()
</code></pre>
<h4> Comment 91949096 CyberMew: </h4>Yes, and as per docs <a href="https://docs.python.org/3/library/stdtypes.html#mutable-sequence-types" rel="nofollow noreferrer">docs.python.org/3/library/stdtypes.html#mutable-sequence-typ&zwnj;&#8203;es</a>, <code>s.copy()</code> creates a shallow copy of <code>s</code> (same as <code>s[:]</code>).<br><h4> Comment 108624099 loved.by.Jesus: </h4>Actually it seems that currently, <code>python3.8</code>, <code>.copy()</code> is <b>slightly faster</b> than slicing. See below @AaronsHall answer.<br><h4> Comment 115053871 ShadowRanger: </h4>Of course, they&#39;re working on <a href="https://bugs.python.org/issue42454" rel="nofollow noreferrer">optimizing out the repeated builds of constant slices</a>, so in 3.10 slicing might win again. It&#39;s all pretty meaningless though; the asymptotic performance is identical, and the fixed overhead relatively small, so it doesn&#39;t really matter which approach you use.<br><h4> Comment 131171367 mtraceur: </h4>Everything @ShadowRanger said here is a great example of an important principle: semantics don&#39;t have performance, only implementations do (and if the semantics of two different ways are the same and performance matters enough, eventually optimizations will do both as efficiently as possible - but simpler semantics are easier to optimize because they have less edge cases to deal with, so you&#39;ll usually get the best optimizations sooner if you just use the operation that says what you intend in the most straightforward way).<br><h4> Comment 115053799 ShadowRanger: </h4>@loved.by.Jesus: Yeah, they <a href="https://bugs.python.org/issue26110" rel="nofollow noreferrer">added optimizations for Python level method calls in 3.7</a> that were extended to <a href="https://www.python.org/dev/peps/pep-0590/" rel="nofollow noreferrer">C extension method calls in 3.8 by PEP 590</a> that remove the overhead of creating a bound method each time you call a method, so the cost to call <code>alist.copy()</code> is now a <code>dict</code> lookup on the <code>list</code> type, then a relatively cheap no-arg function call that ultimately invokes the same thing as slicing. Slicing still has to build a <code>slice</code> object, then go through type checks and unpacking to do the same thing.<br>------------------------------------------------------------------ <br><h3> Answer 26562235 Russia Must Remove Putin: </h3><blockquote>
  <h1>What are the options to clone or copy a list in Python?</h1>
</blockquote>

<p>In Python 3, a shallow copy can be made with:</p>

<pre><code>a_copy = a_list.copy()
</code></pre>

<p>In Python 2 and 3, you can get a shallow copy with a full slice of the original:</p>

<pre><code>a_copy = a_list[:]
</code></pre>

<h2>Explanation</h2>

<p>There are two semantic ways to copy a list. A shallow copy creates a new list of the same objects, a deep copy creates a new list containing new equivalent objects.</p>

<h2>Shallow list copy</h2>

<p>A shallow copy only copies the list itself, which is a container of references to the objects in the list. If the objects contained themselves are mutable and one is changed, the change will be reflected in both lists. </p>

<p>There are different ways to do this in Python 2 and 3. The Python 2 ways will also work in Python 3.</p>

<h3>Python 2</h3>

<p>In Python 2, the idiomatic way of making a shallow copy of a list is with a complete slice of the original:</p>

<pre><code>a_copy = a_list[:]
</code></pre>

<p>You can also accomplish the same thing by passing the list through the list constructor, </p>

<pre><code>a_copy = list(a_list)
</code></pre>

<p>but using the constructor is less efficient:</p>

<pre><code>&gt;&gt;&gt; timeit
&gt;&gt;&gt; l = range(20)
&gt;&gt;&gt; min(timeit.repeat(lambda: l[:]))
0.30504298210144043
&gt;&gt;&gt; min(timeit.repeat(lambda: list(l)))
0.40698814392089844
</code></pre>

<h3>Python 3</h3>

<p>In Python 3, lists get the <code>list.copy</code> method:</p>

<pre><code>a_copy = a_list.copy()
</code></pre>

<p>In Python 3.5:</p>

<pre><code>&gt;&gt;&gt; import timeit
&gt;&gt;&gt; l = list(range(20))
&gt;&gt;&gt; min(timeit.repeat(lambda: l[:]))
0.38448613602668047
&gt;&gt;&gt; min(timeit.repeat(lambda: list(l)))
0.6309100328944623
&gt;&gt;&gt; min(timeit.repeat(lambda: l.copy()))
0.38122922903858125
</code></pre>

<h2>Making another pointer does <em>not</em> make a copy</h2>

<blockquote>
  <p><strong>Using new_list = my_list then modifies new_list every time my_list changes. Why is this?</strong></p>
</blockquote>

<p><code>my_list</code> is just a name that points to the actual list in memory. When you say <code>new_list = my_list</code> you're not making a copy, you're just adding another name that points at that original list in memory. We can have similar issues when we make copies of lists. </p>

<pre><code>&gt;&gt;&gt; l = [[], [], []]
&gt;&gt;&gt; l_copy = l[:]
&gt;&gt;&gt; l_copy
[[], [], []]
&gt;&gt;&gt; l_copy[0].append('foo')
&gt;&gt;&gt; l_copy
[['foo'], [], []]
&gt;&gt;&gt; l
[['foo'], [], []]
</code></pre>

<p>The list is just an array of pointers to the contents, so a shallow copy just copies the pointers, and so you have two different lists, but they have the same contents. To make copies of the contents, you need a deep copy.</p>

<h2>Deep copies</h2>

<p>To make a <a href="https://docs.python.org/library/copy.html" rel="noreferrer">deep copy of a list, in Python 2 or 3, use <code>deepcopy</code> in the <code>copy</code> module</a>:</p>

<pre><code>import copy
a_deep_copy = copy.deepcopy(a_list)
</code></pre>

<p>To demonstrate how this allows us to make new sub-lists:</p>

<pre><code>&gt;&gt;&gt; import copy
&gt;&gt;&gt; l
[['foo'], [], []]
&gt;&gt;&gt; l_deep_copy = copy.deepcopy(l)
&gt;&gt;&gt; l_deep_copy[0].pop()
'foo'
&gt;&gt;&gt; l_deep_copy
[[], [], []]
&gt;&gt;&gt; l
[['foo'], [], []]
</code></pre>

<p>And so we see that the deep copied list is an entirely different list from the original. You could roll your own function - but don't. You're likely to create bugs you otherwise wouldn't have by using the standard library's deepcopy function.</p>

<h2>Don't use <code>eval</code></h2>

<p>You may see this used as a way to deepcopy, but don't do it:</p>

<pre><code>problematic_deep_copy = eval(repr(a_list))
</code></pre>

<ol>
<li>It's dangerous, particularly if you're evaluating something from a source you don't trust.</li>
<li>It's not reliable, if a subelement you're copying doesn't have a representation that can be eval'd to reproduce an equivalent element.</li>
<li>It's also less performant. </li>
</ol>

<p>In 64 bit Python 2.7:</p>

<pre><code>&gt;&gt;&gt; import timeit
&gt;&gt;&gt; import copy
&gt;&gt;&gt; l = range(10)
&gt;&gt;&gt; min(timeit.repeat(lambda: copy.deepcopy(l)))
27.55826997756958
&gt;&gt;&gt; min(timeit.repeat(lambda: eval(repr(l))))
29.04534101486206
</code></pre>

<p>on 64 bit Python 3.5:</p>

<pre><code>&gt;&gt;&gt; import timeit
&gt;&gt;&gt; import copy
&gt;&gt;&gt; l = list(range(10))
&gt;&gt;&gt; min(timeit.repeat(lambda: copy.deepcopy(l)))
16.84255409205798
&gt;&gt;&gt; min(timeit.repeat(lambda: eval(repr(l))))
34.813894678023644
</code></pre>
<h4> Comment 95089106 John Locke: </h4>You don&#39;t need a deepcopy if the list is 2D. If it is a list of lists, and those lists don&#39;t have lists inside of them, you can use a for loop. Presently, I am using   <code>list_copy=[]</code> <code>for item in list:     list_copy.append(copy(item))</code> and it is much faster.<br>------------------------------------------------------------------ <br><h3> Answer 47258728 Aaditya Ura: </h3><p>Let's start from the beginning and explore this question.</p>
<p>So let's suppose you have two lists:</p>
<pre><code>list_1 = ['01', '98']
list_2 = [['01', '98']]
</code></pre>
<p>And we have to copy both lists, now starting from the first list:</p>
<p>So first let's try by setting the variable <code>copy</code> to our original list, <code>list_1</code>:</p>
<pre><code>copy = list_1
</code></pre>
<p>Now if you are thinking copy copied the <em>list_1</em>, then you are wrong. The <code>id</code> function can show us if two variables can point to the same object. Let's try this:</p>
<pre><code>print(id(copy))
print(id(list_1))
</code></pre>
<p>The output is:</p>
<pre><code>4329485320
4329485320
</code></pre>
<p>Both variables are the exact same argument. Are you surprised?</p>
<p>So as we know, Python doesn't store anything in a variable, Variables are just referencing to the object and object store the value. Here object is a <code>list</code> but we created two references to that same object by two different variable names. This means that both variables are pointing to the same object, just with different names.</p>
<p>When you do <code>copy = list_1</code>, it is actually doing:</p>
<p><a href="https://i.stack.imgur.com/vNGqw.jpg" rel="noreferrer"><img src="https://i.stack.imgur.com/vNGqw.jpg" alt="Enter image description here" /></a></p>
<p>Here in the image <em>list_1</em> and <em>copy</em> are two variable names, but the object is same for both variable which is <code>list</code>.</p>
<p>So if you try to modify copied list then it will modify the original list too because the list is only one there, you will modify that list no matter you do from the copied list or from the original list:</p>
<pre><code>copy[0] = &quot;modify&quot;

print(copy)
print(list_1)
</code></pre>
<p>Output:</p>
<pre><code>['modify', '98']
['modify', '98']
</code></pre>
<p>So it modified the original list:</p>
<p>Now let's move onto a Pythonic method for copying lists.</p>
<pre><code>copy_1 = list_1[:]
</code></pre>
<p>This method fixes the first issue we had:</p>
<pre><code>print(id(copy_1))
print(id(list_1))

4338792136
4338791432
</code></pre>
<p>So as we can see our both list having different id and it means that both variables are pointing to different objects. So what actually going on here is:</p>
<p><a href="https://i.stack.imgur.com/iitLk.jpg" rel="noreferrer"><img src="https://i.stack.imgur.com/iitLk.jpg" alt="Enter image description here" /></a></p>
<p>Now let's try to modify the list and let's see if we still face the previous problem:</p>
<pre><code>copy_1[0] = &quot;modify&quot;

print(list_1)
print(copy_1)
</code></pre>
<p>The output is:</p>
<pre><code>['01', '98']
['modify', '98']
</code></pre>
<p>As you can see, it only modified the copied list. That means it worked.</p>
<p>Do you think we're done? No. Let's try to copy our nested list.</p>
<pre><code>copy_2 = list_2[:]
</code></pre>
<p><code>list_2</code> should reference to another object which is copy of <code>list_2</code>. Let's check:</p>
<pre><code>print(id((list_2)), id(copy_2))
</code></pre>
<p>We get the output:</p>
<pre><code>4330403592 4330403528
</code></pre>
<p>Now we can assume both lists are pointing different object, so now let's try to modify it and let's see it is giving what we want:</p>
<pre><code>copy_2[0][1] = &quot;modify&quot;

print(list_2, copy_2)
</code></pre>
<p>This gives us the output:</p>
<pre><code>[['01', 'modify']] [['01', 'modify']]
</code></pre>
<p>This may seem a little bit confusing, because the same method we previously used worked. Let's try to understand this.</p>
<p>When you do:</p>
<pre><code>copy_2 = list_2[:]
</code></pre>
<p>You're only copying the outer list, not the inside list. We can use the <code>id</code> function once again to check this.</p>
<pre><code>print(id(copy_2[0]))
print(id(list_2[0]))
</code></pre>
<p>The output is:</p>
<pre><code>4329485832
4329485832
</code></pre>
<p>When we do <code>copy_2 = list_2[:]</code>, this happens:</p>
<p><a href="https://i.stack.imgur.com/3hPti.jpg" rel="noreferrer"><img src="https://i.stack.imgur.com/3hPti.jpg" alt="Enter image description here" /></a></p>
<p>It creates the copy of list, but only outer list copy, not the nested list copy. The nested list is same for both variable, so if you try to modify the nested list then it will modify the original list too as the nested list object is same for both lists.</p>
<p>What is the solution? The solution is the <code>deepcopy</code> function.</p>
<pre><code>from copy import deepcopy
deep = deepcopy(list_2)
</code></pre>
<p>Let's check this:</p>
<pre><code>print(id((list_2)), id(deep))

4322146056 4322148040
</code></pre>
<p>Both outer lists have different IDs. Let's try this on the inner nested lists.</p>
<pre><code>print(id(deep[0]))
print(id(list_2[0]))
</code></pre>
<p>The output is:</p>
<pre><code>4322145992
4322145800
</code></pre>
<p>As you can see both IDs are different, meaning we can assume that both nested lists are pointing different object now.</p>
<p>This means when you do <code>deep = deepcopy(list_2)</code> what actually happens:</p>
<p><a href="https://i.stack.imgur.com/O7yoo.jpg" rel="noreferrer"><img src="https://i.stack.imgur.com/O7yoo.jpg" alt="Enter image description here" /></a></p>
<p>Both nested lists are pointing different object and they have separate copy of nested list now.</p>
<p>Now let's try to modify the nested list and see if it solved the previous issue or not:</p>
<pre><code>deep[0][1] = &quot;modify&quot;
print(list_2, deep)
</code></pre>
<p>It outputs:</p>
<pre><code>[['01', '98']] [['01', 'modify']]
</code></pre>
<p>As you can see, it didn't modify the original nested list, it only modified the copied list.</p>
------------------------------------------------------------------ <br><h3> Answer 27091494 jack: </h3><p>There are many answers already that tell you how to make a proper copy, but none of them say why your original 'copy' failed. </p>

<p>Python doesn't store values in variables; it binds names to objects. Your original assignment took the object referred to by <code>my_list</code> and bound it to <code>new_list</code> as well. No matter which name you use there is still only one list, so changes made when referring to it as <code>my_list</code> will persist when referring to it as <code>new_list</code>. Each of the other answers to this question give you different ways of creating a new object to bind to <code>new_list</code>. </p>

<p>Each element of a list acts like a name, in that each element binds non-exclusively to an object. A shallow copy creates a new list whose elements bind to the same objects as before.</p>

<pre><code>new_list = list(my_list)  # or my_list[:], but I prefer this syntax
# is simply a shorter way of:
new_list = [element for element in my_list]
</code></pre>

<p>To take your list copy one step further, copy each object that your list refers to, and bind those element copies to a new list. </p>

<pre><code>import copy  
# each element must have __copy__ defined for this...
new_list = [copy.copy(element) for element in my_list]
</code></pre>

<p>This is not yet a deep copy, because each element of a list may refer to other objects, just like the list is bound to its elements. To recursively copy every element in the list, and then each other object referred to by each element, and so on: perform a deep copy. </p>

<pre><code>import copy
# each element must have __deepcopy__ defined for this...
new_list = copy.deepcopy(my_list)
</code></pre>

<p>See <a href="https://docs.python.org/3/library/copy.html" rel="noreferrer">the documentation</a> for more information about corner cases in copying.</p>
------------------------------------------------------------------ <br><h3> Answer 2612808 Paul Tarjan: </h3><p>Use <code>thing[:]</code></p>

<pre><code>&gt;&gt;&gt; a = [1,2]
&gt;&gt;&gt; b = a[:]
&gt;&gt;&gt; a += [3]
&gt;&gt;&gt; a
[1, 2, 3]
&gt;&gt;&gt; b
[1, 2]
&gt;&gt;&gt; 
</code></pre>
------------------------------------------------------------------ <br><h3> Answer 43220129 River: </h3><h2>Python 3.6 Timings</h2>
<p>Here are the timing results using Python 3.6.8. Keep in mind these times are relative to one another, not absolute.</p>
<p>I stuck to only doing shallow copies, and also added some new methods that weren't possible in Python 2, such as <code>list.copy()</code> (the Python 3 <a href="https://mail.python.org/pipermail/python-ideas/2013-July/022368.html" rel="noreferrer">slice equivalent</a>) and two forms of <a href="https://stackoverflow.com/questions/43190992/understanding-x-lst">list unpacking</a> (<code>*new_list, = list</code> and <code>new_list = [*list]</code>):</p>
<pre><code>METHOD                TIME TAKEN
b = [*a]               2.75180600000021
b = a * 1              3.50215399999990
b = a[:]               3.78278899999986  # Python 2 winner (see above)
b = a.copy()           4.20556500000020  # Python 3 &quot;slice equivalent&quot; (see above)
b = []; b.extend(a)    4.68069800000012
b = a[0:len(a)]        6.84498999999959
*b, = a                7.54031799999984
b = list(a)            7.75815899999997
b = [i for i in a]    18.4886440000000
b = copy.copy(a)      18.8254879999999
b = []
for item in a:
  b.append(item)      35.4729199999997
</code></pre>
<p>We can see the Python 2 winner still does well, but doesn't edge out Python 3 <code>list.copy()</code> by much, especially considering the superior readability of the latter.</p>
<p>The dark horse is the unpacking and repacking method (<code>b = [*a]</code>), which is ~25% faster than raw slicing, and more than twice as fast as the other unpacking method (<code>*b, = a</code>).</p>
<p><code>b = a * 1</code> also does surprisingly well.</p>
<p><strong>Note that these methods do <em>not</em> output equivalent results for any input other than lists.</strong> They all work for sliceable objects, a few work for any iterable, but only <code>copy.copy()</code> works for more general Python objects.</p>
<hr />
<p>Here is the testing code for interested parties (<a href="https://stackoverflow.com/questions/13047895/efficient-ways-to-duplicate-array-list-in-python">Template from here</a>):</p>
<pre><code>import timeit

COUNT = 50000000
print(&quot;Array duplicating. Tests run&quot;, COUNT, &quot;times&quot;)
setup = 'a = [0,1,2,3,4,5,6,7,8,9]; import copy'

print(&quot;b = list(a)\t\t&quot;, timeit.timeit(stmt='b = list(a)', setup=setup, number=COUNT))
print(&quot;b = copy.copy(a)\t&quot;, timeit.timeit(stmt='b = copy.copy(a)', setup=setup, number=COUNT))
print(&quot;b = a.copy()\t\t&quot;, timeit.timeit(stmt='b = a.copy()', setup=setup, number=COUNT))
print(&quot;b = a[:]\t\t&quot;, timeit.timeit(stmt='b = a[:]', setup=setup, number=COUNT))
print(&quot;b = a[0:len(a)]\t\t&quot;, timeit.timeit(stmt='b = a[0:len(a)]', setup=setup, number=COUNT))
print(&quot;*b, = a\t\t\t&quot;, timeit.timeit(stmt='*b, = a', setup=setup, number=COUNT))
print(&quot;b = []; b.extend(a)\t&quot;, timeit.timeit(stmt='b = []; b.extend(a)', setup=setup, number=COUNT))
print(&quot;b = []; for item in a: b.append(item)\t&quot;, timeit.timeit(stmt='b = []\nfor item in a:  b.append(item)', setup=setup, number=COUNT))
print(&quot;b = [i for i in a]\t&quot;, timeit.timeit(stmt='b = [i for i in a]', setup=setup, number=COUNT))
print(&quot;b = [*a]\t\t&quot;, timeit.timeit(stmt='b = [*a]', setup=setup, number=COUNT))
print(&quot;b = a * 1\t\t&quot;, timeit.timeit(stmt='b = a * 1', setup=setup, number=COUNT))
</code></pre>
<h4> Comment 106994593 SuperShoot: </h4>Can confirm still a similar story on 3.8 <code>b=[*a]</code> - the one obvious way to do it;).<br><h4> Comment 114824554 ekhumoro: </h4>Some of these timing comparisons aren&#39;t particularly meaningful when copying such tiny lists. It would be more informative to test with a range of list lengths (including some very large ones).<br><h4> Comment 119298412 Peter Mortensen: </h4>The timing numbers ought to rounded to the appropriate number of significant digits. 15 significant digits do not make any sense.<br><h4> Comment 128722434 Karl Knechtel: </h4>Is the <code>a * 1</code> method really not possible in 2.x?<br><h4> Comment 128722699 Karl Knechtel: </h4>My 3.8 timing results: all of the approaches involving named methods have improved to various degrees. <code>.append</code> in a loop has gotten much faster, but is still clearly the slowest. <code>a.copy()</code> is now in second place, and the difference fades away for fewer iterations on longer lists; I assume it has essentially the same internal logic as <code>b = [*a]</code> but must pay the overhead of method lookup. My guess is that <code>.extend</code> is similarly equivalent to the multiplication approach, and <code>list(a)</code> to the slicing approach.<br><h4> Comment 119447900 River: </h4>I&#39;ve essentially just pasted the raw output of the timing code here. Seems like your gripe is more about how <a href="https://docs.python.org/3/library/timeit.html" rel="nofollow noreferrer">timeit</a> displays timings, which I have little control over.<br>------------------------------------------------------------------ <br><h3> Answer 2612810 erisco: </h3><p>Python's idiom for doing this is <code>newList = oldList[:]</code></p>
------------------------------------------------------------------ <br><h3> Answer 31332158 AMR: </h3><p>All of the other contributors gave <strong>great</strong> answers, which work when you have a single dimension (leveled) list, however of the methods mentioned so far, only <code>copy.deepcopy()</code> works to clone/copy a list and not have it point to the nested <code>list</code> objects when you are working with multidimensional, nested lists (list of lists). While <a href="https://stackoverflow.com/users/218196/felix-kling">Felix Kling</a> refers to it in his answer, there is a little bit more to the issue and possibly a workaround using built-ins that might prove a faster alternative to <code>deepcopy</code>.</p>
<p>While <code>new_list = old_list[:]</code>, <code>copy.copy(old_list)'</code> and for Py3k <code>old_list.copy()</code> work for single-leveled lists, they revert to pointing at the <code>list</code> objects nested within the <code>old_list</code> and the <code>new_list</code>, and changes to one of the <code>list</code> objects are perpetuated in the other.</p>
<h1>Edit: New information brought to light</h1>
<blockquote>
<p>As was pointed out by both <a href="https://stackoverflow.com/users/541136/aaron-hall">Aaron Hall</a> and <a href="https://stackoverflow.com/users/4014959/pm-2ring">PM 2Ring</a> <strong>using <code>eval()</code> is not only a bad idea, it is also much slower than <code>copy.deepcopy()</code>.</strong></p>
<p>This means that for multidimensional lists, the only option is <code>copy.deepcopy()</code>. With that being said, it really isn't an option as the performance goes way south when you try to use it on a moderately sized multidimensional array.  I tried to <code>timeit</code> using a 42x42 array, not unheard of or even that large for bioinformatics applications, and I gave up on waiting for a response and just started typing my edit to this post.</p>
<p>It would seem that the only real option then is to initialize multiple lists and work on them independently. If anyone has any other suggestions, for how to handle multidimensional list copying, it would be appreciated.</p>
</blockquote>
<p>As others have stated, there  <em><strong>are significant</strong></em> performance issues using the <code>copy</code> module and <code>copy.deepcopy</code> <em><strong>for multidimensional lists</strong></em>.</p>
<h4> Comment 50671649 PM 2Ring: </h4>This won&#39;t always work, since there&#39;s no guarantee that the string returned by <code>repr()</code> is sufficient to re-create the object. Also, <code>eval()</code> is a tool of last resort; see <a href="http://nedbatchelder.com/blog/201206/eval_really_is_dangerous.html" rel="nofollow noreferrer">Eval really is dangerous</a> by SO veteran Ned Batchelder for details. So when you advocate the use <code>eval()</code> you <i>really</i> should mention that it can be dangerous.<br><h4> Comment 50675773 AMR: </h4>Fair point. Though I think that Batchelder&#39;s point is that the having the <code>eval()</code> function in Python in general is a risk. It isn&#39;t so much whether or not you make use of the function in code but that it is a security hole in Python in and of itself.  My example isn&#39;t using it with a function that receives input from <code>input()</code>, <code>sys.agrv</code>, or even a text file. It is more along the lines of initializing a blank multidimensional list once, and then just having a way of copying it in a loop instead of reinitializing at each iteration of the loop.<br><h4> Comment 50676956 AMR: </h4>As @AaronHall has pointed out, there is likely a significant performance issue to using <code>new_list = eval(repr(old_list))</code>, so besides it being a bad idea, it probably is also way too slow to work.<br>------------------------------------------------------------------ <br><h3> Answer 48980683 SCB: </h3><p>It surprises me that this hasn't been mentioned yet, so for the sake of completeness...</p>

<p>You can perform list unpacking with the "splat operator": <code>*</code>, which will also copy elements of your list.</p>

<pre><code>old_list = [1, 2, 3]

new_list = [*old_list]

new_list.append(4)
old_list == [1, 2, 3]
new_list == [1, 2, 3, 4]
</code></pre>

<p>The obvious downside to this method is that it is only available in Python 3.5+.</p>

<p>Timing wise though, this appears to perform better than other common methods.</p>

<pre><code>x = [random.random() for _ in range(1000)]

%timeit a = list(x)
%timeit a = x.copy()
%timeit a = x[:]

%timeit a = [*x]

#: 2.47 µs ± 38.1 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)
#: 2.47 µs ± 54.6 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)
#: 2.39 µs ± 58.2 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)

#: 2.22 µs ± 43.2 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)
</code></pre>
<h4> Comment 91940819 SCB: </h4>@not2qubit do you mean appending to or editing elements of the new list. In the example <code>old_list</code> and <code>new_list</code> are two different lists, editing one will not change the other (unless you’re directly mutating the elements themselves (such as list of list), none-of these methods are deep copies).<br><h4> Comment 91902477 not2qubit: </h4>How does this method behave when modifying copies?<br>------------------------------------------------------------------ <br><h3> Answer 44768652 Ravi Shankar: </h3><pre><code>new_list = my_list[:]
</code></pre>
<p><code>new_list = my_list</code></p>
<p>Try to understand this. Let's say that <em>my_list</em> is in the heap memory at location X, i.e., <em>my_list</em> is pointing to the X. Now by assigning <code>new_list = my_list</code> you're letting <em>new_list</em> point to the X. This is known as a <em>shallow copy</em>.</p>
<p>Now if you assign <code>new_list = my_list[:]</code>, you're simply copying each object of <em>my_list</em> to <em>new_list</em>. This is known as a <em>deep copy</em>.</p>
<p>The <em>other</em> ways you can do this are:</p>
<ul>
<li>
<pre><code>new_list = list(old_list)
</code></pre>
</li>
<li>
<pre><code>import copy
new_list = copy.deepcopy(old_list)
</code></pre>
</li>
</ul>
<h4> Comment 125710533 2pichar: </h4>Technically, <code>my_list[:]</code> is a shallow copy. The only way to deepcopy a list is using <code>copy.deepcopy()</code><br>------------------------------------------------------------------ <br><h3> Answer 47050612 jainashish: </h3><p>A very simple approach independent of python version was missing in already-given answers which you can use most of the time (at least I do):</p>
<pre><code>new_list = my_list * 1       # Solution 1 when you are not using nested lists
</code></pre>
<p>However, <em>if</em> <em>my_list</em> contains other containers (for example, nested lists) you must use <em>deepcopy</em> as others suggested in the answers above from the copy library. For example:</p>
<pre><code>import copy
new_list = copy.deepcopy(my_list)   # Solution 2 when you are using nested lists
</code></pre>
<p>.<strong>Bonus</strong>: If you don't want to copy elements use (AKA shallow copy):</p>
<pre><code>new_list = my_list[:]
</code></pre>
<hr>
<p>Let's understand difference between solution #1 and solution #2</p>
<pre><code>&gt;&gt;&gt; a = range(5)
&gt;&gt;&gt; b = a*1
&gt;&gt;&gt; a,b
([0, 1, 2, 3, 4], [0, 1, 2, 3, 4])
&gt;&gt;&gt; a[2] = 55
&gt;&gt;&gt; a,b
([0, 1, 55, 3, 4], [0, 1, 2, 3, 4])
</code></pre>
<p>As you can see, solution #1 worked perfectly when we were not using the nested lists. Let's check what will happen when we apply solution #1 to nested lists.</p>
<pre><code>&gt;&gt;&gt; from copy import deepcopy
&gt;&gt;&gt; a = [range(i,i+4) for i in range(3)]
&gt;&gt;&gt; a
[[0, 1, 2, 3], [1, 2, 3, 4], [2, 3, 4, 5]]
&gt;&gt;&gt; b = a*1
&gt;&gt;&gt; c = deepcopy(a)
&gt;&gt;&gt; for i in (a, b, c): print i
[[0, 1, 2, 3], [1, 2, 3, 4], [2, 3, 4, 5]]
[[0, 1, 2, 3], [1, 2, 3, 4], [2, 3, 4, 5]]
[[0, 1, 2, 3], [1, 2, 3, 4], [2, 3, 4, 5]]
&gt;&gt;&gt; a[2].append('99')
&gt;&gt;&gt; for i in (a, b, c): print i
[[0, 1, 2, 3], [1, 2, 3, 4], [2, 3, 4, 5, 99]]
[[0, 1, 2, 3], [1, 2, 3, 4], [2, 3, 4, 5, 99]]   # Solution #1 didn't work in nested list
[[0, 1, 2, 3], [1, 2, 3, 4], [2, 3, 4, 5]]       # Solution #2 - DeepCopy worked in nested list
</code></pre>
------------------------------------------------------------------ <br><h3> Answer 57838754 Corman: </h3><p>I wanted to post something a bit different than some of the other answers. Even though this is most likely not the most understandable, or fastest option, it provides a bit of an inside view of how deep copy works, as well as being another alternative option for deep copying. It doesn't really matter if my function has bugs, since the point of this is to show a way to copy objects like the question answers, but also to use this as a point to explain how deepcopy works at its core.</p>
<p>At the core of any deep copy function is way to make a shallow copy. How? Simple. Any deep copy function only duplicates the containers of immutable objects. When you deepcopy a nested list, you are only duplicating the outer lists, not the mutable objects inside of the lists. You are only duplicating the containers. The same works for classes, too. When you deepcopy a class, you deepcopy all of its mutable attributes. So, how? How come you only have to copy the containers, like lists, dicts, tuples, iters, classes, and class instances?</p>
<p>It's simple. A mutable object can't really be duplicated. It can never be changed, so it is only a single value. That means you never have to duplicate strings, numbers, bools, or any of those. But how would you duplicate the containers? Simple. You make just initialize a new container with all of the values. Deepcopy relies on recursion. It duplicates all the containers, even ones with containers inside of them, until no containers are left. A container is an immutable object.</p>
<p>Once you know that, completely duplicating an object without any references is pretty easy. Here's a function for deepcopying basic data-types (wouldn't work for custom classes but you could always add that)</p>
<pre><code>def deepcopy(x):
  immutables = (str, int, bool, float)
  mutables = (list, dict, tuple)
  if isinstance(x, immutables):
    return x
  elif isinstance(x, mutables):
    if isinstance(x, tuple):
      return tuple(deepcopy(list(x)))
    elif isinstance(x, list):
      return [deepcopy(y) for y in x]
    elif isinstance(x, dict):
      values = [deepcopy(y) for y in list(x.values())]
      keys = list(x.keys())
      return dict(zip(keys, values))
</code></pre>
<p>Python's own built-in deepcopy is based around that example. The only difference is it supports other types, and also supports user-classes by duplicating the attributes into a new duplicate class, and also blocks infinite-recursion with a reference to an object it's already seen using a memo list or dictionary. And that's really it for making deep copies. At its core, making a deep copy is just making shallow copies. I hope this answer adds something to the question.</p>
<p><strong>EXAMPLES</strong></p>
<p>Say you have this list: <code>[1, 2, 3]</code>. The immutable numbers cannot be duplicated, but the other layer can. You can duplicate it using a list comprehension: <code>[x for x in [1, 2, 3]]</code></p>
<p>Now, imagine you have this list: <code>[[1, 2], [3, 4], [5, 6]]</code>. This time, you want to make a function, which uses recursion to deep copy all layers of the list. Instead of the previous list comprehension:</p>
<pre><code>[x for x in _list]
</code></pre>
<p>It uses a new one for lists:</p>
<pre><code>[deepcopy_list(x) for x in _list]
</code></pre>
<p>And <strong>deepcopy_list</strong> looks like this:</p>
<pre><code>def deepcopy_list(x):
  if isinstance(x, (str, bool, float, int)):
    return x
  else:
    return [deepcopy_list(y) for y in x]
</code></pre>
<p>Then now you have a function which can deepcopy any list of <strong>strs, bools, floast, ints</strong> and even <strong>lists</strong> to infinitely many layers using recursion. And there you have it, deepcopying.</p>
<p><strong>TLDR</strong>: Deepcopy uses recursion to duplicate objects, and merely returns the same immutable objects as before, as immutable objects cannot be duplicated. However, it deepcopies the most inner layers of mutable objects until it reaches the outermost mutable layer of an object.</p>
------------------------------------------------------------------ <br><h3> Answer 50373643 Chris_Rands: </h3><p>Note that there are some cases where if you have defined your own custom class and you want to keep the attributes then you should use <code>copy.copy()</code> or <code>copy.deepcopy()</code> rather than the alternatives, for example in Python 3:</p>

<pre><code>import copy

class MyList(list):
    pass

lst = MyList([1,2,3])

lst.name = 'custom list'

d = {
'original': lst,
'slicecopy' : lst[:],
'lstcopy' : lst.copy(),
'copycopy': copy.copy(lst),
'deepcopy': copy.deepcopy(lst)
}


for k,v in d.items():
    print('lst: {}'.format(k), end=', ')
    try:
        name = v.name
    except AttributeError:
        name = 'NA'
    print('name: {}'.format(name))
</code></pre>

<p>Outputs:</p>

<pre><code>lst: original, name: custom list
lst: slicecopy, name: NA
lst: lstcopy, name: NA
lst: copycopy, name: custom list
lst: deepcopy, name: custom list
</code></pre>
------------------------------------------------------------------ <br><h3> Answer 60352267 Dr. Hippo: </h3><p>Remember that in Python when you do:</p>

<pre><code>    list1 = ['apples','bananas','pineapples']
    list2 = list1
</code></pre>

<p>List2 isn't storing the actual list, but a reference to list1. So when you do anything to list1, list2 changes as well. use the copy module (not default, download on pip) to make an original copy of the list(<code>copy.copy()</code> for simple lists, <code>copy.deepcopy()</code> for nested ones). This makes a copy that doesn't change with the first list.</p>
------------------------------------------------------------------ <br><h3> Answer 59011118 B.Mr.W.: </h3><p>A slight practical perspective to look into memory through id and gc. </p>

<pre><code>&gt;&gt;&gt; b = a = ['hell', 'word']
&gt;&gt;&gt; c = ['hell', 'word']

&gt;&gt;&gt; id(a), id(b), id(c)
(4424020872, 4424020872, 4423979272) 
     |           |
      -----------

&gt;&gt;&gt; id(a[0]), id(b[0]), id(c[0])
(4424018328, 4424018328, 4424018328) # all referring to same 'hell'
     |           |           |
      -----------------------

&gt;&gt;&gt; id(a[0][0]), id(b[0][0]), id(c[0][0])
(4422785208, 4422785208, 4422785208) # all referring to same 'h'
     |           |           |
      -----------------------

&gt;&gt;&gt; a[0] += 'o'
&gt;&gt;&gt; a,b,c
(['hello', 'word'], ['hello', 'word'], ['hell', 'word'])  # b changed too
&gt;&gt;&gt; id(a[0]), id(b[0]), id(c[0])
(4424018384, 4424018384, 4424018328) # augmented assignment changed a[0],b[0]
     |           |
      -----------

&gt;&gt;&gt; b = a = ['hell', 'word']
&gt;&gt;&gt; id(a[0]), id(b[0]), id(c[0])
(4424018328, 4424018328, 4424018328) # the same hell
     |           |           |
      -----------------------

&gt;&gt;&gt; import gc
&gt;&gt;&gt; gc.get_referrers(a[0]) 
[['hell', 'word'], ['hell', 'word']]  # one copy belong to a,b, the another for c
&gt;&gt;&gt; gc.get_referrers(('hell'))
[['hell', 'word'], ['hell', 'word'], ('hell', None)] # ('hello', None) 
</code></pre>
------------------------------------------------------------------ <br><h3> Answer 62192645 Roshin Raphel: </h3><p>This is because, the line <code>new_list = my_list</code> assigns a new reference to the variable <code>my_list</code> which is <code>new_list</code>
This is similar to the <code>C</code> code given below,</p>

<pre><code>int my_list[] = [1,2,3,4];
int *new_list;
new_list = my_list;
</code></pre>

<p>You should use the copy module to create a new list by</p>

<pre><code>import copy
new_list = copy.deepcopy(my_list)
</code></pre>
------------------------------------------------------------------ <br><h3> Answer 62716254 Laurent Lyaudet: </h3><p>There is another way of copying a list that was not listed until now: adding an empty list: <code>l2 = l + []</code>.</p>
<p>I tested it with Python 3.8:</p>
<pre><code>l = [1,2,3]
l2 = l + []
print(l,l2)
l[0] = 'a'
print(l,l2)
</code></pre>
<p>It is not the best answer, but it works.</p>
<h4> Comment 128722772 Karl Knechtel: </h4>This works and, in my testing, is as fast as the fastest options for longer lists, and only slightly worse than <code>b = [*a]</code> for short lists.<br>------------------------------------------------------------------ <br><h3> Answer 65972710 fjemi: </h3><p>The method to use depends on the contents of the list being copied. If the list contains nested <code>dicts</code> than deepcopy is the only method that works, otherwise most of the methods listed in the answers (slice, loop [for], copy, extend, combine, or unpack) will work and execute in similar time (except for loop and deepcopy, which preformed the worst).</p>
<h3>Script</h3>
<pre class="lang-py prettyprint-override"><code>from random import randint
from time import time
import copy

item_count = 100000

def copy_type(l1: list, l2: list):
  if l1 == l2:
    return 'shallow'
  return 'deep'

def run_time(start, end):
  run = end - start
  return int(run * 1000000)

def list_combine(data):
  l1 = [data for i in range(item_count)]
  start = time()
  l2 = [] + l1
  end = time()
  if type(data) == dict:
    l2[0]['test'].append(1)
  elif type(data) == list:
    l2.append(1)
  return {'method': 'combine', 'copy_type': copy_type(l1, l2), 
          'time_µs': run_time(start, end)}

def list_extend(data):
  l1 = [data for i in range(item_count)]
  start = time()
  l2 = []
  l2.extend(l1)
  end = time()
  if type(data) == dict:
    l2[0]['test'].append(1)
  elif type(data) == list:
    l2.append(1)
  return {'method': 'extend', 'copy_type': copy_type(l1, l2), 
          'time_µs': run_time(start, end)}

def list_unpack(data):
  l1 = [data for i in range(item_count)]
  start = time()
  l2 = [*l1]
  end = time()
  if type(data) == dict:
    l2[0]['test'].append(1)
  elif type(data) == list:
    l2.append(1)
  return {'method': 'unpack', 'copy_type': copy_type(l1, l2), 
          'time_µs': run_time(start, end)}

def list_deepcopy(data):
  l1 = [data for i in range(item_count)]
  start = time()
  l2 = copy.deepcopy(l1)
  end = time()
  if type(data) == dict:
    l2[0]['test'].append(1)
  elif type(data) == list:
    l2.append(1)
  return {'method': 'deepcopy', 'copy_type': copy_type(l1, l2), 
          'time_µs': run_time(start, end)}

def list_copy(data):
  l1 = [data for i in range(item_count)]
  start = time()
  l2 = list.copy(l1)
  end = time()
  if type(data) == dict:
    l2[0]['test'].append(1)
  elif type(data) == list:
    l2.append(1)
  return {'method': 'copy', 'copy_type': copy_type(l1, l2), 
          'time_µs': run_time(start, end)}

def list_slice(data):
  l1 = [data for i in range(item_count)]
  start = time()
  l2 = l1[:]
  end = time()
  if type(data) == dict:
    l2[0]['test'].append(1)
  elif type(data) == list:
    l2.append(1)
  return {'method': 'slice', 'copy_type': copy_type(l1, l2), 
          'time_µs': run_time(start, end)}

def list_loop(data):
  l1 = [data for i in range(item_count)]
  start = time()
  l2 = []
  for i in range(len(l1)):
    l2.append(l1[i])
  end = time()
  if type(data) == dict:
    l2[0]['test'].append(1)
  elif type(data) == list:
    l2.append(1)
  return {'method': 'loop', 'copy_type': copy_type(l1, l2), 
          'time_µs': run_time(start, end)}

def list_list(data):
  l1 = [data for i in range(item_count)]
  start = time()
  l2 = list(l1)
  end = time()
  if type(data) == dict:
    l2[0]['test'].append(1)
  elif type(data) == list:
    l2.append(1)
  return {'method': 'list()', 'copy_type': copy_type(l1, l2), 
          'time_µs': run_time(start, end)}

if __name__ == '__main__':
  list_type = [{'list[dict]': {'test': [1, 1]}}, 
          {'list[list]': [1, 1]}]
  store = []
  for data in list_type:
    key = list(data.keys())[0]
    store.append({key: [list_unpack(data[key]), list_extend(data[key]), 
                list_combine(data[key]), list_deepcopy(data[key]), 
                list_copy(data[key]), list_slice(data[key]),           
                list_loop(data[key])]})
  print(store)
</code></pre>
<h3>Results</h3>
<pre class="lang-json prettyprint-override"><code>[{&quot;list[dict]&quot;: [
  {&quot;method&quot;: &quot;unpack&quot;, &quot;copy_type&quot;: &quot;shallow&quot;, &quot;time_µs&quot;: 56149},
  {&quot;method&quot;: &quot;extend&quot;, &quot;copy_type&quot;: &quot;shallow&quot;, &quot;time_µs&quot;: 52991},
  {&quot;method&quot;: &quot;combine&quot;, &quot;copy_type&quot;: &quot;shallow&quot;, &quot;time_µs&quot;: 53726},
  {&quot;method&quot;: &quot;deepcopy&quot;, &quot;copy_type&quot;: &quot;deep&quot;, &quot;time_µs&quot;: 2702616},
  {&quot;method&quot;: &quot;copy&quot;, &quot;copy_type&quot;: &quot;shallow&quot;, &quot;time_µs&quot;: 52204},
  {&quot;method&quot;: &quot;slice&quot;, &quot;copy_type&quot;: &quot;shallow&quot;, &quot;time_µs&quot;: 52223},
  {&quot;method&quot;: &quot;loop&quot;, &quot;copy_type&quot;: &quot;shallow&quot;, &quot;time_µs&quot;: 836928}]},
{&quot;list[list]&quot;: [
  {&quot;method&quot;: &quot;unpack&quot;, &quot;copy_type&quot;: &quot;deep&quot;, &quot;time_µs&quot;: 52313},
  {&quot;method&quot;: &quot;extend&quot;, &quot;copy_type&quot;: &quot;deep&quot;, &quot;time_µs&quot;: 52550},
  {&quot;method&quot;: &quot;combine&quot;, &quot;copy_type&quot;: &quot;deep&quot;, &quot;time_µs&quot;: 53203},
  {&quot;method&quot;: &quot;deepcopy&quot;, &quot;copy_type&quot;: &quot;deep&quot;, &quot;time_µs&quot;: 2608560},
  {&quot;method&quot;: &quot;copy&quot;, &quot;copy_type&quot;: &quot;deep&quot;, &quot;time_µs&quot;: 53210},
  {&quot;method&quot;: &quot;slice&quot;, &quot;copy_type&quot;: &quot;deep&quot;, &quot;time_µs&quot;: 52937},
  {&quot;method&quot;: &quot;loop&quot;, &quot;copy_type&quot;: &quot;deep&quot;, &quot;time_µs&quot;: 834774}
]}]
</code></pre>
------------------------------------------------------------------ <br><h3> Answer 61155939 shahar_m: </h3><p>The deepcopy option is the only method that works for me:</p>

<pre><code>from copy import deepcopy

a = [   [ list(range(1, 3)) for i in range(3) ]   ]
b = deepcopy(a)
b[0][1]=[3]
print('Deep:')
print(a)
print(b)
print('-----------------------------')
a = [   [ list(range(1, 3)) for i in range(3) ]   ]
b = a*1
b[0][1]=[3]
print('*1:')
print(a)
print(b)
print('-----------------------------')
a = [   [ list(range(1, 3)) for i in range(3) ] ]
b = a[:]
b[0][1]=[3]
print('Vector copy:')
print(a)
print(b)
print('-----------------------------')
a = [   [ list(range(1, 3)) for i in range(3) ]  ]
b = list(a)
b[0][1]=[3]
print('List copy:')
print(a)
print(b)
print('-----------------------------')
a = [   [ list(range(1, 3)) for i in range(3) ]  ]
b = a.copy()
b[0][1]=[3]
print('.copy():')
print(a)
print(b)
print('-----------------------------')
a = [   [ list(range(1, 3)) for i in range(3) ]  ]
b = a
b[0][1]=[3]
print('Shallow:')
print(a)
print(b)
print('-----------------------------')
</code></pre>

<p>leads to output of:</p>

<pre><code>Deep:
[[[1, 2], [1, 2], [1, 2]]]
[[[1, 2], [3], [1, 2]]]
-----------------------------
*1:
[[[1, 2], [3], [1, 2]]]
[[[1, 2], [3], [1, 2]]]
-----------------------------
Vector copy:
[[[1, 2], [3], [1, 2]]]
[[[1, 2], [3], [1, 2]]]
-----------------------------
List copy:
[[[1, 2], [3], [1, 2]]]
[[[1, 2], [3], [1, 2]]]
-----------------------------
.copy():
[[[1, 2], [3], [1, 2]]]
[[[1, 2], [3], [1, 2]]]
-----------------------------
Shallow:
[[[1, 2], [3], [1, 2]]]
[[[1, 2], [3], [1, 2]]]
-----------------------------
</code></pre>
<h4> Comment 114764971 Jean-Fran&#231;ois Fabre: </h4>deepcopy must be used only when needed and one should be aware of what it really does.<br>------------------------------------------------------------------ <br><h3> Answer 73831052 Karl Knechtel: </h3><h2>Frame challenge: do you actually need to copy, for your application?</h2>
<p>I often see code that tries to modify a copy of the list in some iterative fashion. To construct a trivial example, suppose we had non-working (because <code>x</code> should not be modified) code like:</p>
<pre><code>x = [8, 6, 7, 5, 3, 0, 9]
y = x
for index, element in enumerate(y):
    y[index] = element * 2
# Expected result:
# x = [8, 6, 7, 5, 3, 0, 9] &lt;-- this is where the code is wrong.
# y = [16, 12, 14, 10, 6, 0, 18]
</code></pre>
<p>Naturally people will ask how to make <code>y</code> be a copy of <code>x</code>, rather than a name for the same list, so that the <code>for</code> loop will do the right thing.</p>
<p>But this is the wrong approach. Functionally, what we <em>really</em> want to do is make a <strong>new list</strong> that is <strong>based on</strong> the original.</p>
<p><strong>We don't need to make a copy first to do that, and we typically shouldn't.</strong></p>
<h3>When we need to apply logic to each element</h3>
<p>The natural tool for this is a list comprehension. This way, we write the logic that tells us how the elements in the desired result, relate to the original elements. It's simple, elegant and expressive; and we avoid the need for workarounds to modify the <code>y</code> copy in a <code>for</code> loop (since <a href="https://stackoverflow.com/questions/73251627">assigning to the iteration variable doesn't affect the list</a> - <em>for the same reason that we wanted the copy in the first place!</em>).</p>
<p>For the above example, it looks like:</p>
<pre><code>x = [8, 6, 7, 5, 3, 0, 9]
y = [element * 2 for element in x]
</code></pre>
<p>List comprehensions are quite powerful; we can also use them to filter out elements by a rule with an <code>if</code> clause, and we can chain <code>for</code> and <code>if</code> clauses (it works like the corresponding imperative code, with the same clauses <em>in the same order</em>; only the value that will ultimately end up in the result list, is moved to the front instead of being in the &quot;innermost&quot; part). If the plan was to iterate over the original while modifying the copy <a href="https://stackoverflow.com/questions/1207406/">to avoid problems</a>, there is generally a much more pleasant way to do that with a filtering list comprehension.</p>
<h3>When we need to reject or insert specific elements by position</h3>
<p>Suppose instead that we had something like</p>
<pre><code>x = [8, 6, 7, 5, 3, 0, 9]
y = x
del y[2:-2] # oops, x was changed inappropriately
</code></pre>
<p>Rather than making <code>y</code> a separate copy first in order to delete the part we don't want, we can build a list by <em>putting together</em> the parts that we <em>do</em> want. Thus:</p>
<pre><code>x = [8, 6, 7, 5, 3, 0, 9]
y = x[:2] + x[-2:]
</code></pre>
<p>Handling insertion, replacement etc. by slicing is left as an exercise. Just reason out which subsequences you want the result to contain. A special case of this is <a href="https://stackoverflow.com/questions/4280691">making a reversed copy</a> - assuming we need a new list at all (rather than just to <a href="https://stackoverflow.com/questions/3940128/">iterate in reverse</a>), we can directly create it by slicing, rather than cloning and then using <code>.reverse</code>.</p>
<hr />
<p>These approaches - like the list comprehension - also have the advantage that they create the desired result <em>as an expression</em>, rather than by procedurally modifying an existing object in-place (and <a href="https://stackoverflow.com/questions/11205254/">returning <code>None</code></a>). This is more convenient for writing code in a &quot;fluent&quot; style.</p>
------------------------------------------------------------------ <br><h3> Answer 74076026 Fellipe Sanches: </h3><p>Short and simple explanations of each copy mode:</p>
<p>A <strong>shallow copy</strong> constructs a new compound object and then (to the extent possible) inserts references into it to the objects found in the original - creating a shallow copy:</p>
<pre><code>new_list = my_list
</code></pre>
<p>A <strong>deep copy</strong> constructs a new compound object and then, recursively, inserts copies into it of the objects found in the original - creating a deep copy:</p>
<pre><code>new_list = list(my_list)
</code></pre>
<p><code>list()</code> works fine for deep copy of simple lists, like:</p>
<pre><code>my_list = [&quot;A&quot;,&quot;B&quot;,&quot;C&quot;]
</code></pre>
<p>But, for complex lists like...</p>
<pre><code>my_complex_list = [{'A' : 500, 'B' : 501},{'C' : 502}]
</code></pre>
<p>...use <code>deepcopy()</code>:</p>
<pre><code>import copy
new_complex_list = copy.deepcopy(my_complex_list)
</code></pre>
<h4> Comment 130788964 Karl Knechtel: </h4>Multiple existing answers already explain how to use <code>list</code> for copying as well as <code>copy.deepcopy</code>, what each does, and how to choose. I don&#39;t see what is added here.<br><h4> Comment 130788977 Fellipe Sanches: </h4>@KarlKnechtel a simple and straightforward answer...<br>------------------------------------------------------------------ <br><h3> Answer 75478829 Salindaw: </h3><pre><code>new_list = my_list
</code></pre>
<p>because: <strong>new_list</strong> will only be a reference to <strong>my_list</strong>, and changes made in <strong>new_list</strong> will automatically also be made in <strong>my_list</strong> and vice versa</p>
<p>There are two easy ways to copy a list</p>
<pre><code>new_list = my_list.copy()
</code></pre>
<p>or</p>
<pre><code>new_list = list(my_list)
</code></pre>
