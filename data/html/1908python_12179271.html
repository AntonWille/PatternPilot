 <h2> Title: Meaning of @classmethod and @staticmethod for beginner </h2> <h3> user1632861, question_id: 12179271 </h3>Score: 1908, Tags: {python,oop,static-methods,class-method} <br><p>What do <code>@classmethod</code> and <code>@staticmethod</code> mean in Python, and how are they different? <em>When</em> should I use them, <em>why</em> should I use them, and <em>how</em> should I use them?</p>
<p>As far as I understand, <code>@classmethod</code> tells a class that it's a method which should be inherited into subclasses, or... something. However, what's the point of that? Why not just define the class method without adding <code>@classmethod</code> or <code>@staticmethod</code> or any <code>@</code> definitions?</p>
------------------------------------------------------------------ <br><h3> Answer 12179752 Rostyslav Dzinko: </h3><p>Though <code>classmethod</code> and <code>staticmethod</code> are quite similar, there's a slight difference in usage for both entities: <code>classmethod</code> must have a reference to a class object as the first parameter, whereas <code>staticmethod</code> can have no parameters at all.</p>
<h2>Example</h2>
<pre><code>class Date(object):
    
    def __init__(self, day=0, month=0, year=0):
        self.day = day
        self.month = month
        self.year = year

    @classmethod
    def from_string(cls, date_as_string):
        day, month, year = map(int, date_as_string.split('-'))
        date1 = cls(day, month, year)
        return date1

    @staticmethod
    def is_date_valid(date_as_string):
        day, month, year = map(int, date_as_string.split('-'))
        return day &lt;= 31 and month &lt;= 12 and year &lt;= 3999

date2 = Date.from_string('11-09-2012')
is_date = Date.is_date_valid('11-09-2012')
</code></pre>
<h2>Explanation</h2>
<p>Let's assume an example of a class, dealing with date information (this will be our boilerplate):</p>
<pre><code>class Date(object):
    
    def __init__(self, day=0, month=0, year=0):
        self.day = day
        self.month = month
        self.year = year
</code></pre>
<p>This class obviously could be used to store information about certain dates (without timezone information; let's assume all dates are presented in UTC).</p>
<p>Here we have <code>__init__</code>, a typical initializer of Python class instances, which receives arguments as a typical instance method, having the first non-optional argument (<code>self</code>) that holds a reference to a newly created instance.</p>
<p><strong>Class Method</strong></p>
<p>We have some tasks that can be nicely done using <code>classmethod</code>s.</p>
<p><em>Let's assume that we want to create a lot of <code>Date</code> class instances having date information coming from an outer source encoded as a string with format 'dd-mm-yyyy'. Suppose we have to do this in different places in the source code of our project.</em></p>
<p>So what we must do here is:</p>
<ol>
<li>Parse a string to receive day, month and year as three integer variables or a 3-item tuple consisting of that variable.</li>
<li>Instantiate <code>Date</code> by passing those values to the initialization call.</li>
</ol>
<p>This will look like:</p>
<pre><code>day, month, year = map(int, string_date.split('-'))
date1 = Date(day, month, year)
</code></pre>
<p>For this purpose, C++ can implement such a feature with overloading, but Python lacks this overloading. Instead, we can use <code>classmethod</code>. Let's create another <em>constructor</em>.</p>
<pre><code>    @classmethod
    def from_string(cls, date_as_string):
        day, month, year = map(int, date_as_string.split('-'))
        date1 = cls(day, month, year)
        return date1

date2 = Date.from_string('11-09-2012')
</code></pre>
<p>Let's look more carefully at the above implementation, and review what advantages we have here:</p>
<ol>
<li>We've implemented date string parsing in one place and it's reusable now.</li>
<li>Encapsulation works fine here (if you think that you could implement string parsing as a single function elsewhere, this solution fits the OOP paradigm far better).</li>
<li><code>cls</code> is the <strong>class itself</strong>, not an instance of the class. It's pretty cool because if we inherit our <code>Date</code> class, all children will have <code>from_string</code> defined also.</li>
</ol>
<p><strong>Static method</strong></p>
<p>What about <code>staticmethod</code>? It's pretty similar to <code>classmethod</code> but doesn't take any obligatory parameters (like a class method or instance method does).</p>
<p>Let's look at the next use case.</p>
<p><em>We have a date string that we want to validate somehow. This task is also logically bound to the <code>Date</code> class we've used so far, but doesn't require instantiation of it.</em></p>
<p>Here is where <code>staticmethod</code> can be useful. Let's look at the next piece of code:</p>
<pre><code>    @staticmethod
    def is_date_valid(date_as_string):
        day, month, year = map(int, date_as_string.split('-'))
        return day &lt;= 31 and month &lt;= 12 and year &lt;= 3999

# usage:
is_date = Date.is_date_valid('11-09-2012')
</code></pre>
<p>So, as we can see from usage of <code>staticmethod</code>, we don't have any access to what the class is---it's basically just a function,  called syntactically like a method, but without access to the object and its internals (fields and other methods), which <code>classmethod</code> does have.</p>
<h4> Comment 136739756 Jean-Luc Barat: </h4><code>super(&quot;Thanks&quot;)</code><br><h4> Comment 108678155 Josh: </h4>Regarding your <code>classmethod</code> example, wouldn&#39;t you be able to do exactly what you did above by defining <code>from_string</code> as a <code>stringmethod</code> instead of as <code>classmethod</code>, and then, instead of  calling <code>cls(day, month, year)</code> you would call <code>Date(day, month, year)</code>? I suppose that the <b>only</b> benefit of using a <code>classmethod</code> here would be if you would like that method to be available to <b>subclasses</b> who may inherit and expect <code>from_string</code> to work for the inherited class right? Or did I miss anything your point?<br><h4> Comment 99424652 Bahubali Patil: </h4>The &quot;from_string&quot; method takes &quot;Date&quot; class (not Date object) as the first parameter &quot;cls&quot; and returns the constructor by calling cls(day, month, year), which is equivalent to Date(day, month, year) and returns a Date object.<br><h4> Comment 127376677 Xenty: </h4>@hafiz031 For anyone still interested in an answer to this question, any method defined inside the class before <code>__init__()</code> is still a normal <code>instancemethod</code>. The order of the functions inside the class definition does not matter. You can put the <code>__init__()</code> as the last function and everything will still work the same. Usually, I would recommend putting it as the first function though, because anyone looking at the code will be able to immediately see how an instance of your class can be created.<br><h4> Comment 116728165 Sia: </h4>@DarrylG @Josh what is a <code>stringmethod</code>? Are you guys talking about <code>staticmethod</code>? If so, I still don&#39;t understand why you can&#39;t use <code>staticmethod</code> to accomplish the same thing as @Josh suggests.<br><h4> Comment 101839397 Cryptoharf84: </h4>so can class methods be regarded as &quot;alternative constructors&quot;? I think this is the best explanation so far!<br><h4> Comment 109785984 DarrylG: </h4>@Josh--stringmethod needs an existing object to work off of so you couldn&#39;t do the same thing.  As Crypoharf84 mentions, this allows for an alternative mechanism of constructing an object.  This seems analogous to &quot;named constructors&quot; in the Dart language which provides this mechanism for the creation of multiple constructors for the same class. Different constructors allow easy API creation such as Date.from_json, Date.from_sql, Date.from_file, etc.<br><h4> Comment 133397709 NeilG: </h4>Could you include a link to the implementation of <code>classmethod</code> and <code>staticmethod</code> decorators?<br><h4> Comment 123286690 hafiz031: </h4>If some method is defined inside the class but before <code>__init__()</code> method, will it be equivalent to <code>class method</code> or <code>static method</code> or some other else?<br>------------------------------------------------------------------ <br><h3> Answer 14605349 Yaw Boakye: </h3><p>Rostyslav Dzinko's answer is very appropriate. I thought I could highlight one other reason you should choose <code>@classmethod</code> over <code>@staticmethod</code> when you are creating an additional constructor.</p>
<p>In the <a href="https://stackoverflow.com/a/12179752">example</a>, Rostyslav used the <code>@classmethod</code> <code>from_string</code> as a Factory to create <code>Date</code> objects from otherwise unacceptable parameters. The same can be done with <code>@staticmethod</code> as is shown in the code below:</p>

<pre class="lang-py prettyprint-override"><code>class Date:
  def __init__(self, month, day, year):
    self.month = month
    self.day   = day
    self.year  = year


  def display(self):
    return &quot;{0}-{1}-{2}&quot;.format(self.month, self.day, self.year)


  @staticmethod
  def millenium(month, day):
    return Date(month, day, 2000)

new_year = Date(1, 1, 2013)               # Creates a new Date object
millenium_new_year = Date.millenium(1, 1) # also creates a Date object. 

# Proof:
new_year.display()           # &quot;1-1-2013&quot;
millenium_new_year.display() # &quot;1-1-2000&quot;

isinstance(new_year, Date) # True
isinstance(millenium_new_year, Date) # True
</code></pre>
<p>Thus both <code>new_year</code> and <code>millenium_new_year</code> are instances of the <code>Date</code> class.</p>
<p>But, if you observe closely, the Factory process is hard-coded to create <code>Date</code> objects no matter what. What this means is that even if the <code>Date</code> class is subclassed, the subclasses will still create plain <code>Date</code> objects (without any properties of the subclass). See that in the example below:</p>
<pre class="lang-py prettyprint-override"><code>class DateTime(Date):
  def display(self):
      return &quot;{0}-{1}-{2} - 00:00:00PM&quot;.format(self.month, self.day, self.year)


datetime1 = DateTime(10, 10, 1990)
datetime2 = DateTime.millenium(10, 10)

isinstance(datetime1, DateTime) # True
isinstance(datetime2, DateTime) # False

datetime1.display() # returns &quot;10-10-1990 - 00:00:00PM&quot;
datetime2.display() # returns &quot;10-10-2000&quot; because it's not a DateTime object but a Date object. Check the implementation of the millenium method on the Date class for more details.
</code></pre>
<p><code>datetime2</code> is not an instance of <code>DateTime</code>? WTF? Well, that's because of the <code>@staticmethod</code> decorator used.</p>
<p>In most cases, this is undesired. If what you want is a Factory method that is aware of the class that called it, then <code>@classmethod</code> is what you need.</p>
<p>Rewriting <code>Date.millenium</code> as (that's the only part of the above code that changes):</p>
<pre class="lang-py prettyprint-override"><code>@classmethod
def millenium(cls, month, day):
    return cls(month, day, 2000)
</code></pre>
<p>ensures that the <code>class</code> is not hard-coded but rather learnt. <code>cls</code> can be any subclass. The resulting <code>object</code> will rightly be an instance of <code>cls</code>.<br />
Let's test that out:</p>
<pre class="lang-py prettyprint-override"><code>datetime1 = DateTime(10, 10, 1990)
datetime2 = DateTime.millenium(10, 10)

isinstance(datetime1, DateTime) # True
isinstance(datetime2, DateTime) # True


datetime1.display() # &quot;10-10-1990 - 00:00:00PM&quot;
datetime2.display() # &quot;10-10-2000 - 00:00:00PM&quot;
</code></pre>
<p>The reason is, as you know by now, that <code>@classmethod</code> was used instead of <code>@staticmethod</code></p>
<h4> Comment 93160887 t3chb0t: </h4>Saying that it&#39;s actually a factory method was the most helpful thing in explaining what <code>@classmethod</code> is for.<br><h4> Comment 110866338 Christabella Irwanto: </h4>This answer really clarifies the utility of <code>@classmethod</code> for factory methods that support inheritance: creating an instance of the calling class with some pre-processing etc.<br><h4> Comment 103132568 rishi jain: </h4>What is cls? As per answer above -   cls can be any subclass. The resulting object will rightly be an instance of cls. Is cls an object or method calling Date or Datetime?  Please explain.<br><h4> Comment 108481071 Sibs: </h4>@rishijain Like how self refers to the instance, cls refers to the class - e.g. cls(month, day, 2000) == DateTime(month, day, 2000)<br><h4> Comment 127914425 Sam: </h4>This is a very gooood answer! Perfectly explains the concept. I&#39;m glad to bump your rep up to 10k.<br><h4> Comment 128388168 PirateApp: </h4>why havent I seen this in Javascript, why is Python the only language that requires a separate @classmethod and @staticmethod?<br>------------------------------------------------------------------ <br><h3> Answer 12179325 Simeon Visser: </h3><p><code>@classmethod</code> means: when this method is called, we pass the class as the first argument instead of the instance of that class (as we normally do with methods). This means you can use the class and its properties inside that method rather than a particular instance.</p>

<p><code>@staticmethod</code> means:  when this method is called, we don't pass an instance of the class to it (as we normally do with methods). This means you can put a function inside a class but you can't access the instance of that class (this is useful when your method does not use the instance).</p>
------------------------------------------------------------------ <br><h3> Answer 23054064 zangw: </h3><h1>When to use each</h1>

<p><code>@staticmethod</code> function is nothing more than a function defined inside a class. It is callable without instantiating the class first. It’s definition is immutable via inheritance.</p>

<ul>
<li>Python does not have to instantiate a <strong>bound-method</strong> for object.</li>
<li>It eases the readability of the code: seeing <strong>@staticmethod</strong>, we know that the method does not depend on the state of object itself;</li>
</ul>

<p><code>@classmethod</code> function also callable without instantiating the class, but its definition follows Sub class, not Parent class, via inheritance, can be overridden by subclass. That’s because the first argument for <code>@classmethod</code> function must always be <code>cls (class)</code>.</p>

<ul>
<li><strong>Factory methods</strong>, that are used to create an instance for a class using for example some sort of pre-processing. </li>
<li><strong>Static methods calling static methods</strong>: if you split a static methods in several static methods, you shouldn't hard-code the class name but use class methods</li>
</ul>

<p><a href="http://julien.danjou.info/blog/2013/guide-python-static-class-abstract-methods" rel="noreferrer">here</a> is good link to this topic.</p>
<h4> Comment 101659212 John R Perry: </h4>Thank you for getting to the point wayyyy faster than the accepted answer.<br>------------------------------------------------------------------ <br><h3> Answer 46915275 Russia Must Remove Putin: </h3><blockquote>
<h2>Meaning of <code>@classmethod</code> and <code>@staticmethod</code>?</h2>
</blockquote>
<ul>
<li>A method is a function in an object's namespace, accessible as an attribute.</li>
<li>A regular (i.e. instance) method gets the instance (we usually call it <code>self</code>) as the implicit first argument.</li>
<li>A <em><strong>class</strong></em> method gets the class (we usually call it <code>cls</code>) as the implicit first argument.</li>
<li>A <em><strong>static</strong></em> method gets no implicit first argument (like a regular function).</li>
</ul>
<blockquote>
<p>when should I use them, why should I use them, and how should I use them?</p>
</blockquote>
<p>You don't <em>need</em> either decorator. But on the principle that you should minimize the number of arguments to functions (see Clean Coder), they are useful for doing just that.</p>
<pre><code>class Example(object):

    def regular_instance_method(self):
        &quot;&quot;&quot;A function of an instance has access to every attribute of that 
        instance, including its class (and its attributes.)
        Not accepting at least one argument is a TypeError.
        Not understanding the semantics of that argument is a user error.
        &quot;&quot;&quot;
        return some_function_f(self)

    @classmethod
    def a_class_method(cls):
        &quot;&quot;&quot;A function of a class has access to every attribute of the class.
        Not accepting at least one argument is a TypeError.
        Not understanding the semantics of that argument is a user error.
        &quot;&quot;&quot;
        return some_function_g(cls)

    @staticmethod
    def a_static_method():
        &quot;&quot;&quot;A static method has no information about instances or classes
        unless explicitly given. It just lives in the class (and thus its 
        instances') namespace.
        &quot;&quot;&quot;
        return some_function_h()
</code></pre>
<p>For both instance methods and class methods, not accepting at least one argument is a TypeError, but not understanding the semantics of that argument is a user error.</p>
<p>(Define <code>some_function</code>'s, e.g.:</p>
<pre><code>some_function_h = some_function_g = some_function_f = lambda x=None: x
</code></pre>
<p>and this will work.)</p>
<h3>dotted lookups on instances and classes:</h3>
<p>A dotted lookup on an instance is performed in this order - we look for:</p>
<ol>
<li>a data descriptor in the class namespace (like a property)</li>
<li>data in the instance <code>__dict__</code></li>
<li>a non-data descriptor in the class namespace (methods).</li>
</ol>
<p>Note, a dotted lookup on an instance is invoked like this:</p>
<pre><code>instance = Example()
instance.regular_instance_method 
</code></pre>
<p>and methods are callable attributes:</p>
<pre><code>instance.regular_instance_method()
</code></pre>
<h3>instance methods</h3>
<p>The argument, <code>self</code>, is implicitly given via the dotted lookup.</p>
<p>You must access instance methods from instances of the class.</p>
<pre><code>&gt;&gt;&gt; instance = Example()
&gt;&gt;&gt; instance.regular_instance_method()
&lt;__main__.Example object at 0x00000000399524E0&gt;
</code></pre>
<h3>class methods</h3>
<p>The argument, <code>cls</code>, is implicitly given via dotted lookup.</p>
<p>You can access this method via an instance or the class (or subclasses).</p>
<pre><code>&gt;&gt;&gt; instance.a_class_method()
&lt;class '__main__.Example'&gt;
&gt;&gt;&gt; Example.a_class_method()
&lt;class '__main__.Example'&gt;
</code></pre>
<h3>static methods</h3>
<p>No arguments are implicitly given. This method works like any function defined (for example) on a modules' namespace, except it can be looked up</p>
<pre><code>&gt;&gt;&gt; print(instance.a_static_method())
None
</code></pre>
<blockquote>
<h2>Again, when should I use them, why should I use them?</h2>
</blockquote>
<p>Each of these are progressively more restrictive in the information they pass the method versus instance methods.</p>
<p>Use them when you don't need the information.</p>
<p>This makes your functions and methods easier to reason about and to unittest.</p>
<p>Which is easier to reason about?</p>
<pre><code>def function(x, y, z): ...
</code></pre>
<p>or</p>
<pre><code>def function(y, z): ...
</code></pre>
<p>or</p>
<pre><code>def function(z): ...
</code></pre>
<p>The functions with fewer arguments are easier to reason about. They are also easier to unittest.</p>
<p>These are akin to instance, class, and static methods. Keeping in mind that when we have an instance, we also have its class, again, ask yourself, which is easier to reason about?:</p>
<pre><code>def an_instance_method(self, arg, kwarg=None):
    cls = type(self)             # Also has the class of instance!
    ...

@classmethod
def a_class_method(cls, arg, kwarg=None):
    ...

@staticmethod
def a_static_method(arg, kwarg=None):
    ...
</code></pre>
<h2>Builtin examples</h2>
<p>Here are a couple of my favorite builtin examples:</p>
<p>The <code>str.maketrans</code> static method was a function in the <code>string</code> module, but it is much more convenient for it to be accessible from the <code>str</code> namespace.</p>
<pre><code>&gt;&gt;&gt; 'abc'.translate(str.maketrans({'a': 'b'}))
'bbc'
</code></pre>
<p>The <code>dict.fromkeys</code> class method returns a new dictionary instantiated from an iterable of keys:</p>
<pre><code>&gt;&gt;&gt; dict.fromkeys('abc')
{'a': None, 'c': None, 'b': None}
</code></pre>
<p>When subclassed, we see that it gets the class information as a class method, which is very useful:</p>
<pre><code>&gt;&gt;&gt; class MyDict(dict): pass
&gt;&gt;&gt; type(MyDict.fromkeys('abc'))
&lt;class '__main__.MyDict'&gt; 
</code></pre>
<h2>My advice - Conclusion</h2>
<p>Use static methods when you don't need the class or instance arguments, but the function is related to the use of the object, and it is convenient for the function to be in the object's namespace.</p>
<p>Use class methods when you don't need instance information, but need the class information perhaps for its other class or static methods, or perhaps itself as a constructor. (You wouldn't hardcode the class so that subclasses could be used here.)</p>
<h4> Comment 92463173 TheRealFakeNews: </h4><code>Use class methods when you don&#39;t need instance information, but need the class information perhaps for its other class or static methods, or perhaps itself as a constructor. (You wouldn&#39;t hardcode the class so that subclasses could be used here.)</code> Precisely what I was looking for. The actual <i>why</i>-I-would-use-it answer.<br><h4> Comment 85809306 abalter: </h4>That was fantastically clear with just the right balance of succinct explanation and micro-examples.<br><h4> Comment 101599685 piby180: </h4>This is the best explanation. Thanks!<br>------------------------------------------------------------------ <br><h3> Answer 32134507 Krishnendu Kunti: </h3><p>One would use <code>@classmethod</code> when he/she would want to change the behaviour of the method based on which subclass is calling the method. remember we have a reference to the calling class in a class method.</p>

<p>While using static you would want the behaviour to remain unchanged across subclasses </p>

<p>Example:</p>

<pre><code>class Hero:

  @staticmethod
  def say_hello():
     print("Helllo...")

  @classmethod
  def say_class_hello(cls):
     if(cls.__name__=="HeroSon"):
        print("Hi Kido")
     elif(cls.__name__=="HeroDaughter"):
        print("Hi Princess")

class HeroSon(Hero):
  def say_son_hello(self):
     print("test  hello")



class HeroDaughter(Hero):
  def say_daughter_hello(self):
     print("test  hello daughter")


testson = HeroSon()

testson.say_class_hello() #Output: "Hi Kido"

testson.say_hello() #Outputs: "Helllo..."

testdaughter = HeroDaughter()

testdaughter.say_class_hello() #Outputs: "Hi Princess"

testdaughter.say_hello() #Outputs: "Helllo..."
</code></pre>
------------------------------------------------------------------ <br><h3> Answer 31503491 Learner: </h3><p><strong><em>A little compilation</em></strong></p>

<p><strong>@staticmethod</strong>
A way to write a method inside a class without reference to the object it is being called on. So no need to pass implicit argument like self or cls.
It is written exactly the same how written outside the class, but it is not of no use in python because if you need to encapsulate a method inside a class since this method needs to be the part of that class @staticmethod is comes handy in that case.</p>

<p><strong>@classmethod</strong>
It is important when you want to write a factory method and by this custom attribute(s) can be attached in a class. This attribute(s) can be overridden in the inherited class.</p>

<p>A comparison between these two methods can be as below</p>

<p><a href="https://i.stack.imgur.com/LUyfq.png" rel="noreferrer"><img src="https://i.stack.imgur.com/LUyfq.png" alt="Table"></a></p>
------------------------------------------------------------------ <br><h3> Answer 53270301 Ke Zhang: </h3><p><strong>@classmethod</strong></p>

<p><code>@classmethod</code> may be compared with <code>__init__</code>. 
You could think it is another <code>__init__()</code>. It is the way python realize class constructor overloading in c++. </p>

<pre><code>class C:
    def __init__(self, parameters):
        ....

    @classmethod
    def construct_from_func(cls, parameters):
        ....

obj1 = C(parameters)
obj2 = C.construct_from_func(parameters)
</code></pre>

<p>notice they both has a reference for class as first argument in definitioin while <code>__init__</code> use <code>self</code> but <code>construct_from_func</code> use <code>cls</code> conventionally.</p>

<p><strong>@staticmethod</strong></p>

<p><code>@staticmethod</code> may be compared with <code>object method</code></p>

<pre><code>class C:
    def __init__(self):
        ....

    @staticmethod
    def static_method(args):
        ....

    def normal_method(parameters):
        ....

result = C.static_method(parameters)
result = obj.normal_method(parameters)
</code></pre>
------------------------------------------------------------------ <br><h3> Answer 45264634 ayiyi: </h3><p>I'm a beginner on this site, I have read all above answers, and got the information what I want. However, I don't have the right to upvote.  So I want to get my start on StackOverflow with the answer as I understand it.</p>

<ul>
<li><code>@staticmethod</code> doesn't need self or cls as the first parameter of the method</li>
<li><code>@staticmethod</code> and <code>@classmethod</code> wrapped function could be called by instance or class variable</li>
<li><code>@staticmethod</code> decorated function impact some kind 'immutable property' that subclass inheritance can't overwrite its base class function which is wrapped by a <code>@staticmethod</code> decorator. </li>
<li><code>@classmethod</code> need cls (Class name, you could change the variable name if you want, but it's not advised) as the first parameter of function</li>
<li><code>@classmethod</code> always used by subclass manner, subclass inheritance may change the effect of base class function, i.e. <code>@classmethod</code> wrapped base class function could be overwritten by different subclasses.</li>
</ul>
------------------------------------------------------------------ <br><h3> Answer 47769405 Wizard: </h3><p>In short, @classmethod turns a normal method to a factory method.</p>

<p>Let's explore it with an example:</p>

<pre><code>class PythonBook:
    def __init__(self, name, author):
        self.name = name
        self.author = author
    def __repr__(self):
        return f'Book: {self.name}, Author: {self.author}'
</code></pre>

<p>Without a @classmethod,you should labor to create instances one by one and they are scattered.</p>

<pre><code>book1 = PythonBook('Learning Python', 'Mark Lutz')
In [20]: book1
Out[20]: Book: Learning Python, Author: Mark Lutz
book2 = PythonBook('Python Think', 'Allen B Dowey')
In [22]: book2
Out[22]: Book: Python Think, Author: Allen B Dowey
</code></pre>

<p>As for example with @classmethod</p>

<pre><code>class PythonBook:
    def __init__(self, name, author):
        self.name = name
        self.author = author
    def __repr__(self):
        return f'Book: {self.name}, Author: {self.author}'
    @classmethod
    def book1(cls):
        return cls('Learning Python', 'Mark Lutz')
    @classmethod
    def book2(cls):
        return cls('Python Think', 'Allen B Dowey')
</code></pre>

<p>Test it:</p>

<pre><code>In [31]: PythonBook.book1()
Out[31]: Book: Learning Python, Author: Mark Lutz
In [32]: PythonBook.book2()
Out[32]: Book: Python Think, Author: Allen B Dowey
</code></pre>

<p>See? Instances are successfully created inside a class definition and they are collected together.</p>

<p>In conclusion, @classmethod decorator convert a conventional method to a factory method,Using classmethods makes it possible to add as many alternative constructors as necessary.</p>
<h4> Comment 85114814 Shailyn Ortiz: </h4>you can still achieve the same outcome if you create those methods without classmethod, this is not the real difference<br>------------------------------------------------------------------ <br><h3> Answer 46014833 y durga prasad: </h3><p>Class method can modify the class state,it bound to the class and it contain cls as parameter.</p>

<p>Static method can not modify the class state,it bound to the class and it does't know class or instance</p>

<pre><code>class empDetails:
    def __init__(self,name,sal):
        self.name=name
        self.sal=sal
    @classmethod
    def increment(cls,name,none):
        return cls('yarramsetti',6000 + 500)
    @staticmethod
    def salChecking(sal):
        return sal &gt; 6000

emp1=empDetails('durga prasad',6000)
emp2=empDetails.increment('yarramsetti',100)
# output is 'durga prasad'
print emp1.name
# output put is 6000
print emp1.sal
# output is 6500,because it change the sal variable
print emp2.sal
# output is 'yarramsetti' it change the state of name variable
print emp2.name
# output is True, because ,it change the state of sal variable
print empDetails.salChecking(6500)
</code></pre>
------------------------------------------------------------------ <br><h3> Answer 41840490 boson: </h3><p>A slightly different way to think about it that might be useful for someone... A class method is used in a superclass to define how that method should behave when it's called by different child classes. A static method is used when we want to return the same thing regardless of the child class that we are calling.</p>
