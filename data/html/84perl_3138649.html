 <h2> Title: Programmatically read from STDIN or input file in Perl </h2> <h4> syker, question_id: 3138649, created_at: 2010-06-29 07:23:09+00:00 </h4>Score: 84, Tags: {perl,stdin} <br><p>What is the slickest way to programatically read from stdin or an input file (if provided) in Perl?</p>
<hr><h3> ✔️ Answer by ennuikiller, Id: 3138692, Score: 101, created_at: 2010-06-29 07:28:56+00:00 </h3><pre><code>while (&lt;&gt;) {
print;
}
</code></pre>

<p>will read either from a file specified on the command line or from stdin if no file is given</p>

<p>If you are required this loop construction in command line, then you may use <a href="http://perldoc.perl.org/perlrun.html#*-n*" rel="noreferrer"><code>-n</code></a> option:</p>

<pre><code>$ perl -ne 'print;'
</code></pre>

<p>Here you just put code between <code>{}</code> from first example into <code>''</code> in second</p>
<h4> Comment by msw, Score: 24, Id: 3224713, created_at: 2010-06-29 07:57:31+00:00 </h4>+1 +nitpick: &quot;will read from one or more files consecutively specified on the command line&quot;<h4> Comment by Axeman, Score: 5, Id: 3227553, created_at: 2010-06-29 13:54:05+00:00 </h4>...and all you need to do is write <code>@ARGV = &quot;&#47;path&#47;to&#47;some&#47;file.ext&quot;;</code> and it reads the file--so you can even program a default file on certain conditions.<h4> Comment by mivk, Score: 3, Id: 10959103, created_at: 2012-01-09 10:46:19+00:00 </h4>And if your script is very short, you can use the -n or -p options to perl, and specify your processing on the command line: <code>perl -n -e &#39;$_ = uc($_); print;&#39; yourfile</code>. With -p instead of -n, perl automatically prints $_ at the end.<h4> Comment by David Tonhofer, Score: 3, Id: 30973113, created_at: 2013-12-19 13:45:12+00:00 </h4>And of course you can &quot;slurp&quot; everything in one go: <code>my @slurp = &lt;&gt;; foreach my $line (@slurp) { ... }</code><h4> Comment by David Mertens, Score: 0, Id: 83710976, created_at: 2018-01-20 23:16:00+00:00 </h4>Is there a reason you don&#39;t name the read line with something like <code>while (my $line = &lt;&gt;) {...</code>?<hr><h3>  Answer by Ron, Id: 14899879, Score: 52, created_at: 2013-02-15 17:15:49+00:00 </h3><p>This provides a named variable to work with:</p>

<pre><code>foreach my $line ( &lt;STDIN&gt; ) {
    chomp( $line );
    print "$line\n";
}
</code></pre>

<p>To read a file, pipe it in like this:</p>

<pre><code>program.pl &lt; inputfile
</code></pre>
<h4> Comment by MikeKulls, Score: 12, Id: 30700826, created_at: 2013-12-11 23:55:00+00:00 </h4>+1 for avoiding the all too common shorthand unreadable Perl code<h4> Comment by David Mertens, Score: 7, Id: 38143777, created_at: 2014-07-07 16:12:27+00:00 </h4>-1 since foreach will slurp the whole file. Better to assign to the line in a while loop. Furthermore, Perl has built-in magical behavior for bare angle brackets, so you should have said while(my $line = &lt;&gt;). Then no redirection is necessary.<h4> Comment by tiktak, Score: 3, Id: 43354938, created_at: 2014-12-13 13:01:12+00:00 </h4>The first line should read <code>foreach my $line ( &lt;STDIN&gt; ) {</code>  I agree with @MikeKulls. It&#39;s not Perl&#39;s fault if Perl scripts are unreadable. Programmers are to blame here!<h4> Comment by MikeKulls, Score: 3, Id: 43385076, created_at: 2014-12-14 23:35:11+00:00 </h4>Rereading the question this response is incorrect because it only reads from stdin and doesn&#39;t read a file specified on the command line. ennuikiller&#39;s answer is correct although I would write it as <code>while(my $line = &lt;&gt;) { print $line; }</code>.<h4> Comment by Greg Nisbet, Score: 3, Id: 69506770, created_at: 2016-12-14 21:14:53+00:00 </h4>@MikeKulls Shouldn&#39;t that be <code>while (my $line = &lt;&gt;, defined $line) { ... }</code> or <code>while (&lt;&gt;) { my $line = $_; }</code> to avoid stopping on a blank line?<h4> Comment by MikeKulls, Score: 0, Id: 70655931, created_at: 2017-01-18 22:41:14+00:00 </h4>@GregoryNisbet good point. I would write it even more explicitly and add an explicit check for undef with a break or something along those lines.<h4> Comment by David Mertens, Score: 0, Id: 83710753, created_at: 2018-01-20 23:00:52+00:00 </h4>@MikeKulls, @GregoryNisbet, no, <code>while(my $line = &lt;&gt;)</code> has all kinds of special casing to Do What You Mean here. But as to your specific concern about blank lines, an empty line is not false: it contains <code>&quot;\n&quot;</code>, which is boolean true.<hr><h3>  Answer by el.pescado - нет войне, Id: 3138667, Score: 18, created_at: 2010-06-29 07:25:44+00:00 </h3><p>You need to use &lt;&gt; operator:</p>
<pre><code>while (&lt;&gt;) {
    print $_; # or simply &quot;print;&quot;
}
</code></pre>
<p>Which can be compacted to:</p>
<pre><code>print while (&lt;&gt;);
</code></pre>
<p>Arbitrary file:</p>
<pre><code>open my $F, &quot;&lt;file.txt&quot; or die $!;
while (&lt;$F&gt;) {
    print $_;
}
close $F;
</code></pre>
<h4> Comment by Higinio Fuentes, Score: 0, Id: 135058661, created_at: 2023-07-03 05:15:10+00:00 </h4>I&#39;m trying to run this script in Windows but no movement or error, any idea?<hr><h3>  Answer by Neil Best, Id: 21683901, Score: 17, created_at: 2014-02-10 17:25:21+00:00 </h3><p>The "slickest" way in certain situations is to take advantage of the <a href="http://perldoc.perl.org/perlrun.html#Command-Switches"><code>-n</code> switch</a>.  It implicitly wraps your code with a <code>while(&lt;&gt;)</code> loop and handles the input flexibly.</p>

<p>In <code>slickestWay.pl</code>:</p>

<pre>
#!/usr/bin/perl -n

BEGIN: {
  # do something once here
}

# implement logic for a single line of input
print $result;
</pre>

<p>At the command line:</p>

<pre><code>chmod +x slickestWay.pl
</code></pre>

<p>Now, depending on your input do one of the following:</p>

<ol>
<li><p>Wait for user input</p>

<pre><code>./slickestWay.pl
</code></pre></li>
<li><p>Read from file(s) named in arguments (no redirection required)</p>

<pre><code>./slickestWay.pl input.txt
./slickestWay.pl input.txt moreInput.txt
</code></pre></li>
<li><p>Use a pipe</p>

<pre><code>someOtherScript | ./slickestWay.pl 
</code></pre></li>
</ol>

<p>The <code>BEGIN</code> block is necessary if you need to initialize some kind of object-oriented interface, such as Text::CSV or some such, which you can add to the shebang with <code>-M</code>.</p>

<p><code>-l</code> and <code>-p</code> are also your friends.</p>
<hr><h3>  Answer by Sigusr2, Id: 27346470, Score: 11, created_at: 2014-12-07 18:52:13+00:00 </h3><p>If there is a reason you <em>can't</em> use the simple solution provided by ennuikiller above, then you will have to use Typeglobs to manipulate file handles. This is way more work. This example copies from the file in <code>$ARGV[0]</code> to that in <code>$ARGV[1]</code>. It defaults to <code>STDIN</code> and <code>STDOUT</code> respectively if files are not specified.</p>

<pre><code>use English;

my $in;
my $out;

if ($#ARGV &gt;= 0){
    unless (open($in,  "&lt;", $ARGV[0])){
      die "could not open $ARGV[0] for reading.";
    }
}
else {
    $in  = *STDIN;
}

if ($#ARGV &gt;= 1){
    unless (open($out, "&gt;", $ARGV[1])){
      die "could not open $ARGV[1] for writing.";
    }
}
else {
    $out  = *STDOUT;
}

while ($_ = &lt;$in&gt;){
    $out-&gt;print($_);
}
</code></pre>
<h4> Comment by Matija Nalis, Score: 2, Id: 67917200, created_at: 2016-10-30 16:29:46+00:00 </h4>+1 for a way that will work if filename to read from <i>is not</i> provided on command line but somewhere else (in some variable, read from config file etc - you just replace <code>$ARGV[0]</code> etc with other variable) where all other answers fail...<h4> Comment by David Mertens, Score: 0, Id: 83710809, created_at: 2018-01-20 23:04:53+00:00 </h4>Or, for reading, just <code>unshift</code> the filename onto <code>@ARGV</code> and use the diamond operator, <code>&lt;&gt;</code>.<hr><h3>  Answer by Thorsten Niehues, Id: 14503104, Score: 6, created_at: 2013-01-24 13:59:51+00:00 </h3><p>Do</p>

<pre><code>$userinput =  &lt;STDIN&gt;; #read stdin and put it in $userinput
chomp ($userinput);    #cut the return / line feed character
</code></pre>

<p>if you want to read just one line</p>
<h4> Comment by David Mertens, Score: 0, Id: 83710960, created_at: 2018-01-20 23:14:36+00:00 </h4>Only reads from STDIN, not from specified file. The diamond operator is <i>exactly</i> what the OP is looking for.<hr><h3>  Answer by Westrock, Id: 32682576, Score: -1, created_at: 2015-09-20 18:01:24+00:00 </h3><p>Here is how I made a script that could take either command line inputs or have a text file redirected.
<br></p>

<pre><code>if ($#ARGV &lt; 1) {
    @ARGV = ();
    @ARGV = &lt;&gt;;
    chomp(@ARGV);
}
</code></pre>

<p><br>
This will reassign the contents of the file to @ARGV, from there you just process @ARGV as if someone was including command line options.
<br>
<br>
<em>WARNING</em>
<br>
<br>
If no file is redirected, the program will sit their idle because it is waiting for input from STDIN.
<br>
<br>
I have not figured out a way to detect if a file is being redirected in yet to eliminate the STDIN issue. </p>
<h4> Comment by David Mertens, Score: 0, Id: 83710936, created_at: 2018-01-20 23:12:58+00:00 </h4>This is a cool approach, but not what the OP was asking for. This makes it possible to pass a single filename as an argument, the contents of which are used as command-line arguments. OP was looking for something different. Also, why the cryptic <code>$#ARGV &lt; 1</code> instead of (what I think of as) more clear <code>@ARGV == 1</code>?<hr><h3>  Answer by trapd00r, Id: 3138765, Score: -2, created_at: 2010-06-29 07:44:54+00:00 </h3><pre><code>if(my $file = shift) { # if file is specified, read from that
  open(my $fh, '&lt;', $file) or die($!);
  while(my $line = &lt;$fh&gt;) {
    print $line;
  }
}
else { # otherwise, read from STDIN
  print while(&lt;&gt;);
}
</code></pre>
<h4> Comment by Dave Sherohman, Score: 8, Id: 3224898, created_at: 2010-06-29 08:27:16+00:00 </h4>The plain <code>&lt;&gt;</code> operator will automatically find and read from any file(s) given on the command line. There&#39;s no need for the <code>if</code>.<h4> Comment by Eugen Konkov, Score: 0, Id: 76947292, created_at: 2017-07-08 13:14:32+00:00 </h4>You also do not describe what <code>shift</code> is doing here