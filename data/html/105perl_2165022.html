 <h2> Title: How can I troubleshoot my Perl CGI script? </h2> <h4> brian d foy, question_id: 2165022 </h4>Score: 105, Tags: {perl,cgi} <br><p>I have a Perl CGI script that isn't working and I don't know how to start narrowing down the problem. What can I do?</p>
<hr>
<p>Note: I'm adding the question because I really want to add my very lengthy answer to Stack Overflow. I keep externally linking to it in other answers and it deserves to be here. Don't be shy about editing my answer if you have something to add.</p>
<h4> Andrew Grimm, Id: 4712259 Score: 0: </h4>If your web browser is showing line noise, it may be printing the perl script instead. In that case, see <a href="http://stackoverflow.com/questions/2621161/cgi-perl-script-is-printing-the-html-along-with-content-type-text-html-strin" title="cgi perl script is printing the html along with content type text html strin">stackoverflow.com/questions/2621161/&hellip;</a><br>------------------------------------------------------------------ <br><h3> brian d foy, Id: 2165040, Score: 136: </h3><p>This answer is intended as a general framework for working through
problems with Perl CGI scripts and originally appeared on Perlmonks as <a href="http://www.perlmonks.org/?node_id=380424" rel="noreferrer">Troubleshooting Perl CGI Scripts</a>.  It is not a complete guide to every
problem that you may encounter, nor a tutorial on bug squashing.  It
is just the culmination of my experience debugging CGI scripts for twenty (plus!) years.  This page seems to have had many different homes, and I seem
to forget it exists, so I'm adding it to the StackOverflow. You
can send any comments or suggestions to me at 
bdfoy@cpan.org. It's also community wiki, but don't go too nuts. :)</p>

<hr>

<h3>Are you using Perl's built in features to help you find problems?</h3>

<p>Turn on warnings to let Perl warn you about questionable parts of your code. You can do this from the command line with the <code>-w</code> switch so you don't have to change any code or add a pragma to every file:</p>

<pre><code> % perl -w program.pl
</code></pre>

<p>However, you should force yourself to always clear up questionable code by adding the <code>warnings</code> pragma to all of your files:</p>

<pre><code> use warnings;
</code></pre>

<p>If you need more information than the short warning message, use the <code>diagnostics</code> pragma to get more information, or look in the <a href="http://perldoc.perl.org/perldiag.html" rel="noreferrer">perldiag</a> documentation:</p>

<pre><code> use diagnostics;
</code></pre>

<h3>Did you output a valid CGI header first?</h3>

<p>The server is expecting the first output from a CGI script to be the CGI header.  Typically that might be as simple as <code>print "Content-type: text/plain\n\n";</code> or with <a href="http://search.cpan.org/perldoc/CGI" rel="noreferrer">CGI.pm</a> and its derivatives, <code>print header()</code>.  Some servers are sensitive to error output (on <code>STDERR</code>) showing up before standard output (on <code>STDOUT</code>).</p>

<h3>Try sending errors to the browser</h3>

<p>Add this line</p>

<pre><code> use CGI::Carp 'fatalsToBrowser';
</code></pre>

<p>to your script. This also sends compilation errors to the browser window. Be sure to remove this before moving to a production environment, as the extra information can be a security risk.</p>

<h3>What did the error log say?</h3>

<p>Servers keep error logs (or they should, at least). 
Error output from the server and from your script should
show up there.  Find the error log and see what it says.
There isn't a standard place for log files.  Look in the 
server configuration for their location, or ask the server
admin.  You can also use tools such as <a href="http://search.cpan.org/perldoc/CGI::Carp" rel="noreferrer">CGI::Carp</a>
to keep your own log files. </p>

<h3>What are the script's permissions?</h3>

<p>If you see errors like &quot;Permission denied&quot; or &quot;Method not
implemented&quot;, it probably means that your script is not
readable and executable by the web server user.  On flavors
of Unix, changing the mode to 755 is recommended:
<code>chmod 755 filename</code>. Never set a mode to 777!</p>

<h3>Are you using <code>use strict</code>?</h3>

<p>Remember that Perl automatically creates variables when
you first use them.  This is a feature, but sometimes can
cause bugs if you mistype a variable name.  The pragma
<a href="http://perldoc.perl.org/strict.html" rel="noreferrer"><code>use strict</code></a> will help you find those sorts of
errors.  It's annoying until you get used to it, but your
programming will improve significantly after awhile and
you will be free to make different mistakes.</p>

<h3>Does the script compile?</h3>

<p>You can check for compilation errors by using the <code>-c</code>
switch.  Concentrate on the first errors reported.  Rinse,
repeat. If you are getting really strange errors, check to
ensure that your script has the right line endings.  If you
FTP in binary mode, checkout from CVS, or something else that
does not handle line end translation, the web server may see
your script as one big line.  Transfer Perl scripts in ASCII
mode.</p>

<h3>Is the script complaining about insecure dependencies?</h3>

<p>If your script complains about insecure dependencies, you 
are probably using the <code>-T</code> switch to turn on taint mode, which is
a good thing since it keeps you have passing unchecked data to the shell. If
it is complaining it is doing its job to help us write more secure scripts. Any
data originating from outside of the program (i.e. the environment)
is considered tainted.  Environment variables such as <code>PATH</code> and
<code>LD_LIBRARY_PATH</code>
are particularly troublesome.  You have to set these to a safe value
or unset them completely, as I recommend.  You should be using absolute
paths anyway.  If taint checking complains about something else,
make sure that you have untainted the data.  See <a href="http://perldoc.perl.org/perlsec.html" rel="noreferrer">perlsec</a>
man page for details.</p>

<h3>What happens when you run it from the command line?</h3>

<p>Does the script output what you expect when run from the
command line?  Is the header output first, followed by a
blank line?  Remember that <code>STDERR</code> may be merged with <code>STDOUT</code>
if you are on a terminal (e.g. an interactive session), and
due to buffering may show up in a jumbled order.  Turn on
Perl's autoflush feature by setting <code>$|</code> to a
true value. Typically you might see <code>$|++;</code> in
CGI programs.  Once set, every print and write will
immediately go to the output rather than being buffered.
You have to set this for each filehandle.  Use <code>select</code> to
change the default filehandle, like so:</p>

<pre><code>$|++;                            #sets $| for STDOUT
$old_handle = select( STDERR );  #change to STDERR
$|++;                            #sets $| for STDERR
select( $old_handle );           #change back to STDOUT
</code></pre>

<p>Either way, the first thing output should be the CGI header
followed by a blank line.</p>

<h3>What happens when you run it from the command line with a CGI-like environment?</h3>

<p>The web server environment is usually a lot more limited
than your command line environment, and has extra
information about the request.  If your script runs fine
from the command line, you might try simulating a web server
environment.  If the problem appears, you have an
environment problem.</p>

<p>Unset or remove these variables</p>

<ul>
<li><code>PATH</code></li>
<li><code>LD_LIBRARY_PATH</code></li>
<li>all <code>ORACLE_*</code> variables</li>
</ul>

<p>Set these variables</p>

<ul>
<li><code>REQUEST_METHOD</code> (set to <code>GET</code>, <code>HEAD</code>, or <code>POST</code> as appropriate)</li>
<li><code>SERVER_PORT</code> (set to 80, usually)</li>
<li><code>REMOTE_USER</code> (if you are doing protected access stuff)</li>
</ul>

<p>Recent versions of <code>CGI.pm</code> ( > 2.75 ) require the <code>-debug</code> flag to 
get the old (useful) behavior, so you might have to add it to
your <code>CGI.pm</code> imports.</p>

<pre><code>use CGI qw(-debug)
</code></pre>

<h3>Are you using <code>die()</code> or <code>warn</code>?</h3>

<p>Those functions print to <code>STDERR</code> unless you have redefined 
them.  They don't output a CGI header, either.  You can get
the same functionality with packages such as <a href="http://search.cpan.org/perldoc/CGI::Carp" rel="noreferrer">CGI::Carp</a></p>

<h3>What happens after you clear the browser cache?</h3>

<p>If you think your script is doing the right thing, and
when you perform the request manually you get the right
output, the browser might be the culprit.  Clear the cache
and set the cache size to zero while testing.  Remember that
some browsers are really stupid and won't actually reload
new content even though you tell it to do so.  This is
especially prevalent in cases where the URL path is the
same, but the content changes (e.g. dynamic images).</p>

<h3>Is the script where you think it is?</h3>

<p>The file system path to a script is not necessarily
directly related to the URL path to the script.  Make sure
you have the right directory, even if you have to write a
short test script to test this.  Furthermore, are you sure
that you are modifying the correct file?  If you don't see
any effect with your changes, you might be modifying a
different file, or uploading a file to the wrong place. 
(This is, by the way, my most frequent cause of such trouble
;)</p>

<h3>Are you using <a href="http://search.cpan.org/perldoc/CGI" rel="noreferrer"><code>CGI.pm</code></a>, or a derivative of it?</h3>

<p>If your problem is related to parsing the CGI input and you
aren't using a widely tested module like <code>CGI.pm</code>, <a href="http://search.cpan.org/perldoc/CGI::Request" rel="noreferrer"><code>CGI::Request</code></a>,
<a href="http://search.cpan.org/perldoc/CGI::Simple" rel="noreferrer"><code>CGI::Simple</code></a> or <a href="http://search.cpan.org/perldoc/CGI::Lite" rel="noreferrer"><code>CGI::Lite</code></a>, use the module and get on with life.
<code>CGI.pm</code> has a <code>cgi-lib.pl</code> compatibility mode which can help you solve input
problems due to older CGI parser implementations.</p>

<h3>Did you use absolute paths?</h3>

<p>If you are running external commands with
<code>system</code>, back ticks, or other IPC facilities,
you should use an absolute path to the external program. 
Not only do you know exactly what you are running, but you
avoid some security problems as well.  If you are opening
files for either reading or writing, use an absolute path. 
The CGI script may have a different idea about the current
directory than you do.  Alternatively, you can do an
explicit <code>chdir()</code> to put you in the right place.</p>

<h3>Did you check your return values?</h3>

<p>Most Perl functions will tell you if they worked or not
and will set <code>$!</code> on failure.  Did you check the
return value and examine <code>$!</code> for error messages? Did you check
<code>$@</code> if you were using <code>eval</code>?</p>

<h3>Which version of Perl are you using?</h3>

<p>The latest stable version of Perl is 5.28 (or not, depending on when this was last edited).  Are you using an older version?  Different versions of Perl may have different ideas of warnings.</p>

<h3>Which web server are you using?</h3>

<p>Different servers may act differently in the same
situation.  The same server product may act differently with
different configurations. Include as much of this
information as you can in any request for help.</p>

<h3>Did you check the server documentation?</h3>

<p>Serious CGI programmers should know as much about the
server as possible - including not only the server features
and behavior, but also the local configuration. The
documentation for your server might not be available to you
if you are using a commercial product.  Otherwise, the
documentation should be on your server.  If it isn't, look
for it on the web. </p>

<h3>Did you search the archives of <a href="http://groups.google.com/group/comp.infosystems.www.authoring.cgi" rel="noreferrer"><code>comp.infosystems.www.authoring.cgi</code></a>?</h3>

<p><em>This use to be useful but all the good posters have either died or wandered off.</em></p>

<p>It's likely that someone has had your problem before,
and that someone (possibly me) has answered it in this
newsgroup. Although this newsgroup has passed its heyday, the collected wisdom from the past can sometimes be useful.</p>

<h3>Can you reproduce the problem with a short test script?</h3>

<p>In large systems, it may be difficult to track down a bug
since so many things are happening.  Try to reproduce the problem
behavior with the shortest possible script.  Knowing the problem
is most of the fix.  This may be certainly time-consuming, but you
haven't found the problem yet and you're running out of options. :)</p>

<h3>Did you decide to go see a movie?</h3>

<p>Seriously.  Sometimes we can get so wrapped up in the problem that we
develop &quot;perceptual narrowing&quot; (tunnel vision).  Taking a break,
getting a cup of coffee, or blasting some bad guys in [Duke Nukem,Quake,Doom,Halo,COD] might give you
the fresh perspective that you need to re-approach the problem.</p>

<h3>Have you vocalized the problem?</h3>

<p>Seriously again.  Sometimes explaining the problem aloud
leads us to our own answers.  Talk to the penguin (plush toy) because
your co-workers aren't listening.  If you are interested in this
as a serious debugging tool (and I do recommend it if you haven't 
found the problem by now), you might also like to read <a href="https://rads.stackoverflow.com/amzn/click/com/0932633420" rel="noreferrer" rel="nofollow noreferrer">The Psychology
of Computer Programming</a>.</p>
<h4> vol7ron, Comment 13191279 Score: 2: </h4>Nice answer, I think it might be worth mentioning that some of these solutions should be purely for troubleshooting and not put into production code.  <code>use strict</code> is generally good to use at all times, whereas using <code>fatalsToBrowser</code> may not be advised in production, especially if you&#39;re using <code>die</code>.<br><h4> reinierpost, Comment 6200411 Score: 1: </h4>Why not <code>$|=1</code> instead of <code>$|++</code>?<br><h4> Hawk, Comment 50674445 Score: 1: </h4>Bonus points on &quot;Go see a movie&quot;!  That might seem trivial at first glance but it&#39;s not.  I can&#39;t count how many times I&#39;ve walked away, come back, then suddenly the problem becomes obvious as if by magic.  That is indeed a valuable troubleshooting tip.<br><h4> Snake Plissken, Comment 2998466 Score: 0: </h4>Seems like you might want to remove the link to the CGI meta FAQ. Is 5.12.1 considered &quot;stable&quot;?<br><h4> U. Windl, Comment 132002988 Score: 0: </h4>I&#39;m missing one thing: If your script looks at <code>path_info</code>, how to set an URL (or path_info) at he command line?<br><h4> brian d foy, Comment 132004176 Score: 0: </h4>@U.Windl: perhaps you want to ask a new question instead of comment .<br><h4> U. Windl, Comment 132023204 Score: 0: </h4>@briandfoy Never mind: I found out that I have to set the environment variables <code>PATH_INFO</code>; before I had tried <code>PATH_INFO=...</code> as parameter for the script, and that did not work as expected. Another thing was that my script expected a valid <code>REMOTE_ADDR</code>. You could add a note on commonly set environment variables that a non-trivial script might expect to be present.<br><h4> brian d foy, Comment 6216454 Score: 0: </h4>Why <code>$|=1</code> instead of <code>$|++</code>? It doesn&#39;t really make a difference, and even then, <code>$|</code> is magical.<br>------------------------------------------------------------------ <br><h3> Mikael S, Id: 2165067, Score: 10: </h3><p>I think <a href="http://search.cpan.org/perldoc?CGI::Debug" rel="noreferrer">CGI::Debug</a> is worth mentioning as well.</p>
------------------------------------------------------------------ <br><h3> mob, Id: 2165285, Score: 7: </h3><p>
<dt><b>Are you using an error handler while you are debugging?</b></dt></p>

<p><code>die</code> statements and other fatal run-time and compile-time errors get
printed to <code>STDERR</code>, which can be hard to find and may be conflated with
messages from other web pages at your site. While you're debugging your
script, it's a good idea to get the fatal error messages to display in your
browser somehow.</p>

<p>One way to do this is to call</p>

<pre><code>   use CGI::Carp qw(fatalsToBrowser);
</code></pre>

<p>at the top of your script. <a href="http://search.cpan.org/~lds/CGI.pm-3.48/lib/CGI/Carp.pm#___top" rel="noreferrer">That call</a> will install a <code>$SIG{__DIE__}</code> handler (see <a href="http://search.cpan.org/perldoc/perlvar#%SIG" rel="noreferrer">perlvar</a>)display fatal errors in your browser, prepending it with a valid header if necessary. Another CGI debugging trick that I used before I ever heard of <code>CGI::Carp</code> was to 
use <code>eval</code> with the <code>DATA</code> and <code>__END__</code> facilities on the script to catch compile-time errors:</p>

<pre><code>   #!/usr/bin/perl
   eval join'', &lt;DATA&gt;;
   if ($@) { print "Content-type: text/plain:\n\nError in the script:\n$@\n; }
   __DATA__
   # ... actual CGI script starts here
</code></pre>

<p>This more verbose technique has a slight advantage over <code>CGI::Carp</code> in that it will catch more compile-time errors.</p>

<p><strong>Update:</strong> I've never used it, but it looks like <a href="http://search.cpan.org/perldoc/CGI::Debug" rel="noreferrer"><code>CGI::Debug</code></a>, as Mikael S
suggested, is also a very useful and configurable tool for this purpose.

<br /><br /></p>
<h4> derobert, Comment 3875227 Score: 3: </h4>@Ether: <code>&lt;DATA&gt;</code> is a magic filehandle which reads the current script starting with <code>__END__</code>. Join is providing it list context, so &lt;fh&gt; returns an array, one line per item. Then join puts it back together (joining it with &#39;&#39;). Finally, eval.<br><h4> derobert, Comment 3883614 Score: 1: </h4>@Ether: Well, actually, they both work in the top-level script (according to the perldata manpage). But since <b>DATA</b> is preferred, I&#39;ve changed the answer.<br><h4> Ether, Comment 3883928 Score: 0: </h4>@derobert: thanks for the doc link; I didn&#39;t know about the backwards compatibility behaviour of __END__!<br><h4> derobert, Comment 3875240 Score: 0: </h4>@Ether: A more readable way to write line 2 would be: <code>eval join(q{}, &lt;DATA&gt;);</code><br><h4> Ether, Comment 3875337 Score: 0: </h4>@derobert: actually, __DATA__ is the token used to start the data section, not __END__ (I think that was my confusion).<br>------------------------------------------------------------------ <br><h3> sdaau, Id: 18441107, Score: 7: </h3><p>I wonder how come no-one mentioned the <code>PERLDB_OPTS</code> option called <code>RemotePort</code>; although admittedly, there aren't many working examples on the web (<code>RemotePort</code> isn't even mentioned in <a href="http://perldoc.perl.org/perldebug.html" rel="nofollow noreferrer">perldebug</a>) - and it was kinda problematic for me to come up with this one, but here it goes (it being a Linux example).</p>

<p>To do a proper example, first I needed something that can do a very simple simulation of a CGI web server, preferably through a single command line. After finding <a href="http://www.perlmonks.org/?node_id=385153" rel="nofollow noreferrer">Simple command line web server for running cgis. (perlmonks.org)</a>, I found the <a href="http://search.cpan.org/~ingy/IO-All-0.46/lib/IO/All.pod#A_Tiny_Web_Server" rel="nofollow noreferrer">IO::All - A Tiny Web Server</a> to be applicable for this test.</p>

<p>Here, I'll work in the <code>/tmp</code> directory; the CGI script will be <code>/tmp/test.pl</code> (included below). Note that the <code>IO::All</code> server will only serve executable files in the same directory as CGI, so <code>chmod +x test.pl</code> is required here. So, to do the usual CGI test run, I change directory to <code>/tmp</code> in the terminal, and run the one-liner web server there:</p>

<pre><code>$ cd /tmp
$ perl -MIO::All -e 'io(":8080")-&gt;fork-&gt;accept-&gt;(sub { $_[0] &lt; io(-x $1 ? "./$1 |" : $1) if /^GET \/(.*) / })'
</code></pre>

<p>The webserver command will block in the terminal, and will otherwise start the web server locally (on 127.0.0.1 or <code>localhost</code>) - afterwards, I can go to a web browser, and request this address:</p>

<pre><code>http://127.0.0.1:8080/test.pl
</code></pre>

<p>... and I should observe the <code>print</code>s made by <code>test.pl</code> being loaded - and shown - in the web browser.</p>

<hr>

<p>Now, to debug this script with <code>RemotePort</code>, first we need a <em>listener</em> on the network, through which we will interact with the Perl debugger; we can use the command line tool <code>netcat</code> (<code>nc</code>, saw that here: <a href="http://51hired.com/questions/13184/Perl%E5%A6%82%E4%BD%95remote%20debug" rel="nofollow noreferrer">Perl如何remote debug?</a>). So, first run the <code>netcat</code> listener in one terminal - where it will block and wait for connections on port 7234 (which will be our debug port):</p>

<pre><code>$ nc -l 7234
</code></pre>

<p>Then, we'd want <code>perl</code> to start in debug mode with <code>RemotePort</code>, when the <code>test.pl</code> has been called (even in CGI mode, through the server). This, in Linux, can be done using the following "shebang wrapper" script - which here also needs to be in <code>/tmp</code>, and <em>must</em> be made executable:</p>

<pre><code>cd /tmp

cat &gt; perldbgcall.sh &lt;&lt;'EOF'
#!/bin/bash
PERLDB_OPTS="RemotePort=localhost:7234" perl -d -e "do '$@'"
EOF

chmod +x perldbgcall.sh
</code></pre>

<p>This is kind of a tricky thing - see <a href="https://unix.stackexchange.com/questions/20880/how-can-i-use-environment-variables-in-my-shebang">shell script - How can I use environment variables in my shebang? - Unix &amp; Linux Stack Exchange</a>. But, the trick here seems to be <em>not</em> to fork the <code>perl</code> interpreter which handles <code>test.pl</code>  - so once we hit it, we don't <code>exec</code>, but instead we call <code>perl</code> "plainly", and basically "source" our <code>test.pl</code> script using <code>do</code> (see <a href="https://stackoverflow.com/questions/364842/how-do-i-run-a-perl-script-from-within-a-perl-script">How do I run a Perl script from within a Perl script?</a>).</p>

<p>Now that we have <code>perldbgcall.sh</code> in <code>/tmp</code> - we can change the <code>test.pl</code> file, so that it refers to this executable file on its shebang line (instead of the usual Perl interpreter) - here is <code>/tmp/test.pl</code> modified thus:</p>

<pre><code>#!./perldbgcall.sh

# this is test.pl

use 5.10.1;
use warnings;
use strict;

my $b = '1';
my $a = sub { "hello $b there" };
$b = '2';
print "YEAH " . $a-&gt;() . " CMON\n";
$b = '3';
print "CMON " . &amp;$a . " YEAH\n";

$DB::single=1;  # BREAKPOINT

$b = '4';
print "STEP " . &amp;$a . " NOW\n";
$b = '5';
print "STEP " . &amp;$a . " AGAIN\n";
</code></pre>

<p>Now, both <code>test.pl</code> and its new shebang handler, <code>perldbgcall.sh</code>, are in <code>/tmp</code>; and we have <code>nc</code> listening for debug connections on port 7234 - so we can finally open another terminal window, change directory to <code>/tmp</code>, and run the one-liner webserver (which will listen for web connections on port 8080) there:</p>

<pre><code>cd /tmp
perl -MIO::All -e 'io(":8080")-&gt;fork-&gt;accept-&gt;(sub { $_[0] &lt; io(-x $1 ? "./$1 |" : $1) if /^GET \/(.*) / })'
</code></pre>

<p>After this is done, we can go to our web browser, and request the same address, <code>http://127.0.0.1:8080/test.pl</code>. However, now when the webserver tries to execute the script, it will do so through <code>perldbgcall.sh</code> shebang - which will start <code>perl</code> in remote debugger mode. Thus, the script execution will pause - and so the web browser will lock, waiting for data. We can now switch to the <code>netcat</code> terminal, and we should see the familiar Perl debugger text - however, output through <code>nc</code>:</p>

<pre><code>$ nc -l 7234

Loading DB routines from perl5db.pl version 1.32
Editor support available.

Enter h or `h h' for help, or `man perldebug' for more help.

main::(-e:1):   do './test.pl'
  DB&lt;1&gt; r
main::(./test.pl:29):   $b = '4';
  DB&lt;1&gt;
</code></pre>

<p>As the snippet shows, we now basically use <code>nc</code> as a "terminal" - so we can type <code>r</code> (and Enter) for "run" - and the script will run up do the breakpoint statement (see also <a href="https://stackoverflow.com/questions/4489269/in-perl-what-is-the-difference-between-dbsingle-1-and-2">In perl, what is the difference between $DB::single = 1 and 2?</a>), before stopping again (note at that point, the browser will still lock).</p>

<p>So, now we can, say, step through the rest of <code>test.pl</code>, through the <code>nc</code> terminal:</p>

<pre><code>....
main::(./test.pl:29):   $b = '4';
  DB&lt;1&gt; n
main::(./test.pl:30):   print "STEP " . &amp;$a . " NOW\n";
  DB&lt;1&gt; n
main::(./test.pl:31):   $b = '5';
  DB&lt;1&gt; n
main::(./test.pl:32):   print "STEP " . &amp;$a . " AGAIN\n";
  DB&lt;1&gt; n
Debugged program terminated.  Use q to quit or R to restart,
  use o inhibit_exit to avoid stopping after program termination,
  h q, h R or h o to get additional info.
  DB&lt;1&gt;
</code></pre>

<p>... however, also at this point, the browser locks and waits for data. Only after we exit the debugger with <code>q</code>:</p>

<pre><code>  DB&lt;1&gt; q
$
</code></pre>

<p>... does the browser stop locking - and finally displays the (complete) output of <code>test.pl</code>:</p>

<pre><code>YEAH hello 2 there CMON
CMON hello 3 there YEAH
STEP hello 4 there NOW
STEP hello 5 there AGAIN
</code></pre>

<p>Of course, this kind of debug can be done even without running the web server - however, the neat thing here, is that we don't touch the web server at all; we trigger execution "natively" (for CGI) from a web browser - and the only change needed in the CGI script itself, is the change of shebang (and of course, the presence of the shebang wrapper script, as executable file in the same directory).</p>

<p>Well, hope this helps someone - I sure would have loved to have stumbled upon this, instead of writing it myself <code>:)</code><br>
Cheers!</p>
------------------------------------------------------------------ <br><h3> zawhtut, Id: 20088913, Score: 5: </h3><p>For me, I use <a href="http://mschilli.github.io/log4perl/" rel="noreferrer">log4perl</a> . It's quite useful and easy.</p>

<pre><code>use Log::Log4perl qw(:easy);

Log::Log4perl-&gt;easy_init( { level   =&gt; $DEBUG, file    =&gt; "&gt;&gt;d:\\tokyo.log" } );

my $logger = Log::Log4perl::get_logger();

$logger-&gt;debug("your log message");
</code></pre>
------------------------------------------------------------------ <br><h3> Ilan Kleiman, Id: 21567108, Score: 2: </h3><p>Honestly you can do all the fun stuff above this post. 
ALTHOUGH, the simplest and most proactive solution I found was to just "print it".</p>

<p>In example: 
(Normal code)</p>

<pre><code>`$somecommand`;
</code></pre>

<p>To see if it's doing what I really want it to do:
(Trouble shooting)</p>

<pre><code>print "$somecommand";
</code></pre>
<h4> U. Windl, Comment 132003072 Score: 0: </h4>Can you explain how that applies to debugging a CGI script?<br>------------------------------------------------------------------ <br><h3> D.Karthikeyan, Id: 36423751, Score: 0: </h3><p>You may  run the perl cgi-script in terminal using the below command</p>
<pre><code> $ perl filename.cgi
</code></pre>
<p>It interpret the code and provide result with HTML code.
It will report the error if any.</p>
<h4> D.Karthikeyan, Comment 60496826 Score: 2: </h4>Sorry,the command $ perl -c filename.cgi validates the syntax of the code and reports the error if any.  It wont provide html code of the cgi.<br><h4> Nagev, Comment 87843513 Score: 0: </h4>Invoking <code>perl -c filename</code> will indeed check syntax only. But <code>perl filename</code> does print the HTML output. It&#39;s no guarantee that there won&#39;t be a 500 CGI error though, but it&#39;s a good first test.<br>------------------------------------------------------------------ <br><h3> gpwr, Id: 19436985, Score: 1: </h3><p>It will probably also be worth mentioning that Perl will always tell you on what line the error occurs when you execute the Perl script from the command line. (An SSH Session for example)</p>

<p>I will usually do this if all else fails. I will SSH into the server and manually execute the Perl script. For example:</p>

<pre><code>% perl myscript.cgi 
</code></pre>

<p>If there is a problem then Perl will tell you about it. This debugging method does away with any file permission related issues or web browser or web server issues.</p>
<h4> brian d foy, Comment 32599777 Score: 0: </h4>Perl doesn&#39;t always tell you the line number where an error occurs. It tells you the line number where it realizes there is something wrong. The error likely has already happened.<br>