 <h2> Title: How to match any non white space character except a particular one? </h2> <h4> Lazer, question_id: 6125098 </h4>Score: 162, Tags: {regex,perl} <br><p>In Perl <code>\S</code> matches any non-whitespace character.</p>

<p>How can I match any non-whitespace character except a backslash <code>\</code>?</p>
------------------------------------------------------------------ <br><h3> Tim Pietzcker, Id: 6125137, Score: 201: </h3><p>You can use a <a href="http://www.regular-expressions.info/charclass.html" rel="noreferrer">character class</a>:</p>

<pre><code>/[^\s\\]/
</code></pre>

<p>matches anything that is not a whitespace character nor a <code>\</code>.  Here's another example:</p>

<p><code>[abc]</code> means "match <code>a</code>, <code>b</code> or <code>c</code>"; <code>[^abc]</code> means "match any character except <code>a</code>, <code>b</code> or <code>c</code>".</p>
<h4> Ben Carp, Comment 104479324 Score: 1: </h4>@AlexanderCska, have you figured it out? The above answer will only return the first match of a string. If you want all matches to be returned add the <code>g</code> modifier. <code>&#47;[^\s\\]&#47;g</code><br><h4> Tim Pietzcker, Comment 97456949 Score: 1: </h4>That should probably be <code>&#47;^\s+&#47;</code> - start of line, followed by one or more whitespace characters.<br><h4> Tim Pietzcker, Comment 97456889 Score: 1: </h4>Outside of a character class, it&#39;s &quot;beginning of the string&quot; (or line, depending on the current matching mode). Inside a character class, and only if it&#39;s the first character after the opening bracket, it negates the contents of the character class.<br><h4> Alexander Cska, Comment 97456924 Score: 0: </h4>Will the following match line that begins with a number of white spaces <code>$0~&#47;\s*^\s&#47;</code> followed by any character that is not a white spaces<br><h4> Alexander Cska, Comment 97456835 Score: 0: </h4>When is <code>^</code> interpreted as negation and when as line beginning ? In that respect, why this wont match a line starting with number of white spaces <code>$0~&#47;\s*^\s&#47;</code><br><h4> Alexander Cska, Comment 97457001 Score: 0: </h4>Unfortunately it does not work. I am trying to match a line if it begins with an indent<br>------------------------------------------------------------------ <br><h3> Denis de Bernardy, Id: 6125124, Score: 17: </h3><p>You can use a lookahead:</p>

<pre><code>/(?=\S)[^\\]/
</code></pre>
<h4> Denis de Bernardy, Comment 7108003 Score: 2: </h4>It looks ahead if it&#39;s not a space. And then the negative class accepts anything (which is not a space) except the characters in your class.<br><h4> jocull, Comment 72037979 Score: 0: </h4>I like this solution. It&#39;s good for things like &quot;give me all the non-word characters except whitespace&quot;: <code>&#47;(?=\S)\W&#47;</code><br><h4> Arvo Bowen, Comment 100152252 Score: 0: </h4>I had a situation where I needed to match any non whitespace character as well as non quotes.  It also had to allow for SPACES.  Ex: <code>THIS IS A TEST, AND AGAIN</code>.  The following worked well for me <code>(?=\S)[^&quot;]*</code>.<br><h4> Christian Noel, Comment 110216939 Score: 0: </h4>the accepted answer didn&#39;t work for me but this did. i was using this in sublime text regex search<br><h4> Taufik Nurhidayat, Comment 115854451 Score: 0: </h4>I searching for how to select any non Word char except - and her it&#39;s <code>&#47;(?=\W)[^-]&#47;g</code><br>------------------------------------------------------------------ <br><h3> storm_m2138, Id: 35325023, Score: 13: </h3><p>This worked for me using <strong>sed</strong> [<strong>Edit:</strong> comment below points out sed doesn't support \s]</p>

<pre><code>[^ ]
</code></pre>

<p>while</p>

<pre><code>[^\s] 
</code></pre>

<p>didn't</p>

<pre><code># Delete everything except space and 'g'
echo "ghai ghai" | sed "s/[^\sg]//g"
gg

echo "ghai ghai" | sed "s/[^ g]//g"
g g
</code></pre>
<h4> Alan Moore, Comment 58359866 Score: 3: </h4><code>\s</code> matches more than just the space character.  It includes TAB, linefeed carriage return, and others (how <i>many</i> others depends on the regex flavor).  It&#39;s a Perl invention, originally a shorthand for the POSIX character class <code>[:space:]</code>, and not supported in <code>sed</code>.  Your first regex above should be <code>s&#47;[^[:space:]g]&#47;&#47;g</code>.<br><h4> storm_m2138, Comment 58362830 Score: 0: </h4>Yup @AlanMoore works: <code>echo &quot;ghai ghai&quot; | sed &quot;s&#47;[^[:space:]g]&#47;&#47;g&quot;</code>  Yields: <code>g g</code><br>------------------------------------------------------------------ <br><h3> Torge, Id: 47311596, Score: 2: </h3><p>On my system: CentOS 5</p>

<p>I can use <code>\s</code> outside of collections but have to use <code>[:space:]</code> inside of collections. In fact I can use <code>[:space:]</code> only inside collections. So to match a single space using this I have to use <code>[[:space:]]</code>
Which is really strange.</p>

<pre><code>echo a b cX | sed -r "s/(a\sb[[:space:]]c[^[:space:]])/Result: \1/"

Result: a b cX
</code></pre>

<ul>
<li>first space I match with <code>\s</code></li>
<li>second space I match alternatively with <code>[[:space:]]</code></li>
<li>the X I match with "all but no space" <code>[^[:space:]]</code></li>
</ul>

<p>These two will not work:</p>

<pre><code>a[:space:]b  instead use a\sb or a[[:space:]]b

a[^\s]b      instead use a[^[:space:]]b
</code></pre>
<h4> user2394284, Comment 86394270 Score: 1: </h4>As of sed 4.4, it is apparently still true that you have to use <code>([^[:space:]])</code> instead of <code>([^\s])</code>. I&#39;m on openSUSE Tumbleweed 2018 04 03.<br>------------------------------------------------------------------ <br><h3> Gabriel Staples, Id: 71384374, Score: 0: </h3><p>If using regular expressions in <code>bash</code> or <code>grep</code> or something instead of just in perl, <code>\S</code> doesn't work to match all non-whitespace chars. The equivalent of <code>\S</code>, however, is <code>[^\r\n\t\f\v ]</code>.</p>
<p>So, instead of <a href="https://stackoverflow.com/a/6125137/4561887">this</a>:</p>
<pre class="lang-sh prettyprint-override"><code>[^\s\\]
</code></pre>
<p>...you'll have to do this instead, to match no whitespace chars (regex: <code>\r\n\t\f\v </code>) <em>and</em> no backslash (<code>\</code>; regex: <code>\\</code>)</p>
<pre class="lang-sh prettyprint-override"><code>[^\r\n\t\f\v \\]
</code></pre>
<h2>References:</h2>
<ol>
<li>[my answer] <a href="https://unix.stackexchange.com/a/693317/114401">Unix &amp; Linux: Any non-whitespace regular expression</a></li>
</ol>
------------------------------------------------------------------ <br><h3> brian d foy, Id: 71387795, Score: 0: </h3><p>In this case, it's easier to define the problem of &quot;non-whitespace without the backslash&quot; to be not &quot;whitespace or backslash&quot;, as <a href="https://stackoverflow.com/a/6125137/2766176">the accepted answer shows</a>:</p>
<pre><code>/[^\s\\]/
</code></pre>
<p>However, for tricker problems, the regex set feature might be handy. You can perform set operations on character classes to get what you want. This one subtracts the set that is just the backslash from the set that is the non-whitespace characters:</p>
<pre><code>use v5.18;
use experimental qw(regex_sets);

my $regex = qr/abc(?[ [\S] - [\\] ])/;


while( &lt;DATA&gt; ) {
    chomp;
    say &quot;[$_] &quot;, /$regex/ ? 'Matched' : 'Missed';
    }

__DATA__
abcd
abc d
abc\d
abcxyz
abc\\xyz
</code></pre>
<p>The output shows that neither whitespace nor the backslash matches after <code>c</code>:</p>
<pre><code>[abcd] Matched
[abc d] Missed
[abc\d] Missed
[abcxyz] Matched
[abc\\xyz] Missed
</code></pre>
<p>This gets more interesting when the larger set would be difficult to express gracefully and set operations can refine it. I'd rather see the set operation in this example:</p>
<pre><code>[b-df-hj-np-tv-z]
(?[ [a-z] - [aeiou] ])
</code></pre>
