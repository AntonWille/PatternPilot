 <h2> Title: How to print lines between two patterns, inclusive or exclusive (in sed, AWK or Perl)? </h2> <h4> fedorqui, question_id: 38972736 </h4>Score: 99, Tags: {shell,perl,awk,sed,pattern-matching} <br><p>I have a file like the following and I would like to print the lines between two given patterns <code>PAT1</code> and <code>PAT2</code>.</p>

<pre class="lang-none prettyprint-override"><code>1
2
PAT1
3    - first block
4
PAT2
5
6
PAT1
7    - second block
PAT2
8
9
PAT1
10    - third block
</code></pre>

<p>I have read <a href="https://stackoverflow.com/q/17988756/1983854">How to select lines between two marker patterns which may occur multiple times with awk/sed</a> but I am curious to see all the possible combinations of this, either including or excluding the pattern.</p>

<p>How can I print all lines between two patterns?</p>
<h4> fedorqui, Id: 65299113 Score: 2: </h4>@Cyrus yes, thank you! I also checked this one before going ahead and posting this question/answer. The point here is to provide a set of tools on this, since the volume of comments (and votes to them) in <a href="http://stackoverflow.com/a/17988834/1983854">my other answer</a> lead me think that a generic post would be of good help to future readers.<br><h4> fedorqui, Id: 65298823 Score: 0: </h4>I am posting an attempt of canonical answer to <a href="http://stackoverflow.com/a/17988834/1983854">How to select lines between two marker patterns which may occur multiple times with awk/sed</a> so that all cases are covered. I follow <a href="http://blog.stackoverflow.com/2011/07/its-ok-to-ask-and-answer-your-own-questions/">It&#39;s OK to Ask and Answer Your Own Questions</a> and posted the answer as Community Wiki, so feel free to improve it!<br><h4> user2138595, Id: 65324520 Score: 0: </h4>See also <a href="http://www.thelinuxrain.com/articles/how-to-use-flags-in-awk" rel="nofollow noreferrer">thelinuxrain.com/articles/how-to-use-flags-in-awk</a><br><h4> Alex Harvey, Id: 98219858 Score: 0: </h4>@fedorqui, I didn&#39;t hear back so I decided to have a go at improving the question to rank better on Google and clarifying what the scope is. Feel free to revert if you&#39;re not happy with it.<br><h4> fedorqui, Id: 98228088 Score: 0: </h4>@Alex not sure where my comments back were expected, but in any case thanks for the edit! It looks fine to me. Thanks for taking the time on this<br>------------------------------------------------------------------ <br><h3> fedorqui, Id: 38972737, Score: 149: </h3><h1>Print lines between PAT1 and PAT2</h1>

<pre><code>$ awk '/PAT1/,/PAT2/' file
PAT1
3    - first block
4
PAT2
PAT1
7    - second block
PAT2
PAT1
10    - third block
</code></pre>

<p>Or, using variables:</p>

<pre><code>awk '/PAT1/{flag=1} flag; /PAT2/{flag=0}' file
</code></pre>

<p>How does this work?</p>

<ul>
<li><code>/PAT1/</code> matches lines having this text, as well as <code>/PAT2/</code> does.  </li>
<li><code>/PAT1/{flag=1}</code> sets the <code>flag</code> when the text <code>PAT1</code> is found in a line.</li>
<li><code>/PAT2/{flag=0}</code> unsets the <code>flag</code> when the text <code>PAT2</code> is found in a line.</li>
<li><code>flag</code> is a pattern with the default action, which is to <code>print $0</code>: if <code>flag</code> is equal 1 the line is printed. This way, it will print all those lines occurring from the time <code>PAT1</code> occurs and up to the next <code>PAT2</code> is seen. This will also print the lines from the last match of <code>PAT1</code> up to the end of the file.</li>
</ul>

<h1>Print lines between PAT1 and PAT2 - not including PAT1 and PAT2</h1>

<pre><code>$ awk '/PAT1/{flag=1; next} /PAT2/{flag=0} flag' file
3    - first block
4
7    - second block
10    - third block
</code></pre>

<p>This uses <code>next</code> to skip the line that contains <code>PAT1</code> in order to avoid this being printed.</p>

<p>This call to <code>next</code> can be dropped by reshuffling the blocks: <code>awk '/PAT2/{flag=0} flag; /PAT1/{flag=1}' file</code>.</p>

<h1>Print lines between PAT1 and PAT2 - including PAT1</h1>

<pre><code>$ awk '/PAT1/{flag=1} /PAT2/{flag=0} flag' file
PAT1
3    - first block
4
PAT1
7    - second block
PAT1
10    - third block
</code></pre>

<p>By placing <code>flag</code> at the very end, it triggers the action that was set on either PAT1 or PAT2: to print on PAT1, not to print on PAT2.</p>

<h1>Print lines between PAT1 and PAT2 - including PAT2</h1>

<pre><code>$ awk 'flag; /PAT1/{flag=1} /PAT2/{flag=0}' file
3    - first block
4
PAT2
7    - second block
PAT2
10    - third block
</code></pre>

<p>By placing <code>flag</code> at the very beginning, it triggers the action that was set previously and hence print the closing pattern but not the starting one.</p>

<h1>Print lines between PAT1 and PAT2 - excluding lines from the last PAT1 to the end of file if no other PAT2 occurs</h1>

<p>This is based on <a href="https://stackoverflow.com/a/39018573/1983854">a solution by Ed Morton</a>.</p>

<pre><code>awk 'flag{
        if (/PAT2/)
           {printf "%s", buf; flag=0; buf=""}
        else
            buf = buf $0 ORS
     }
     /PAT1/ {flag=1}' file
</code></pre>

<p>As a one-liner:</p>

<pre><code>$ awk 'flag{ if (/PAT2/){printf "%s", buf; flag=0; buf=""} else buf = buf $0 ORS}; /PAT1/{flag=1}' file
3    - first block
4
7    - second block

# note the lack of third block, since no other PAT2 happens after it
</code></pre>

<p>This keeps all the selected lines in a buffer that gets populated from the moment PAT1 is found. Then, it keeps being filled with the following lines until PAT2 is found. In that point, it prints the stored content and empties the buffer.</p>
<h4> Mukul Anand, Comment 102964905 Score: 0: </h4>is it shortest match ?<br><h4> fedorqui, Comment 102967765 Score: 0: </h4>@MukulAnand it depends on the case<br><h4> Paul M, Comment 111844015 Score: 0: </h4>how about if I want to print one word/column from lines in a file between patterns? here&#39;s one answer  echo &quot;n&quot; | yum update | awk &#39;/PAT1/{flag=1; next} /PAT2/{flag=0} flag{ print $5 }&#39;<br><h4> bit_cracker007, Comment 113722034 Score: 0: </h4>Can I do grep over this awk? Like: <code>$ awk &#39;&#47;PAT1&#47;,&#47;PAT2&#47;&#39; | grep &quot;XYZ&quot;</code> ?<br><h4> Hemant, Comment 114104247 Score: 0: </h4>how to do it, if lines between PART1 and PART2 are extracted only once using awk?<br><h4> fedorqui, Comment 114106002 Score: 0: </h4>@Hemant just pipe normally: <code>awk &#39;... your things ...&#39; | awk &#39;this awk&#39;</code><br><h4> levigroker, Comment 115561425 Score: 0: </h4>I&#39;d appreciate a solution where PAT1 may repeat before PAT2 is encountered, and all we want is what is non-greedy between the  PAT1 which is closest to the PAT2. i.e. PAT1(some text we don&#39;t want)PAT1(some text we do want)PAT2<br><h4> Andrew, Comment 132825393 Score: 0: </h4>Doesn&#39;t work: awk: cmd. line:1: /&lt;p&gt;/{flag=1; next}/&lt;/p&gt;/{flag=0} flag awk: cmd. line:1:                                         ^ unterminated regexp<br><h4> fedorqui, Comment 132852435 Score: 0: </h4>@Andrew can you post the exact command you used?<br>------------------------------------------------------------------ <br><h3> hek2mgl, Id: 38978201, Score: 86: </h3><p>What about the classic <code>sed</code> solution?</p>

<h3>Print lines between PAT1 and PAT2 - include PAT1 and PAT2</h3>

<pre class="lang-none prettyprint-override"><code>sed -n '/PAT1/,/PAT2/p' FILE
</code></pre>

<h3>Print lines between PAT1 and PAT2 - exclude PAT1 and PAT2</h3>

<em>GNU sed</em>

<pre class="lang-none prettyprint-override"><code>sed -n '/PAT1/,/PAT2/{/PAT1/!{/PAT2/!p}}' FILE
</code></pre>

<em>Any sed</em><sup>1</sup>

<pre class="lang-none prettyprint-override"><code>sed -n '/PAT1/,/PAT2/{/PAT1/!{/PAT2/!p;};}' FILE
</code></pre>

<p>or even (Thanks <a href="https://stackoverflow.com/questions/38972736/how-to-select-lines-between-two-patterns/38978201#comment76283925_38978201">Sundeep</a>):</p>

<em>GNU sed</em>

<pre class="lang-none prettyprint-override"><code>sed -n '/PAT1/,/PAT2/{//!p}' FILE
</code></pre>

<em>Any sed</em>

<pre class="lang-none prettyprint-override"><code>sed -n '/PAT1/,/PAT2/{//!p;}' FILE
</code></pre>

<h3>Print lines between PAT1 and PAT2 - include PAT1 but not PAT2</h3>

<p>The following includes just the range start:</p>

<em>GNU sed</em>

<pre class="lang-none prettyprint-override"><code>sed -n '/PAT1/,/PAT2/{/PAT2/!p}' FILE
</code></pre>

<em>Any sed</em>

<pre class="lang-none prettyprint-override"><code>sed -n '/PAT1/,/PAT2/{/PAT2/!p;}' FILE
</code></pre>

<h3>Print lines between PAT1 and PAT2 - include PAT2 but not PAT1</h3>

<p>The following includes just the range end:</p>

<em>GNU sed</em>

<pre><code>sed -n '/PAT1/,/PAT2/{/PAT1/!p}' FILE
</code></pre>

<em>Any sed</em>

<pre><code>sed -n '/PAT1/,/PAT2/{/PAT1/!p;}' FILE
</code></pre>

<hr>

<p><sup>1</sup> Note about BSD/Mac OS X sed</p>

<p>A command like this here:</p>

<pre class="lang-none prettyprint-override"><code>sed -n '/PAT1/,/PAT2/{/PAT1/!{/PAT2/!p}}' FILE
</code></pre>

<p>Would emit an error:</p>

<pre class="lang-none prettyprint-override"><code>▶ sed -n '/PAT1/,/PAT2/{/PAT1/!{/PAT2/!p}}' FILE
sed: 1: "/PAT1/,/PAT2/{/PAT1/!{/ ...": extra characters at the end of p command
</code></pre>

<p>For this reason this answer has been edited to include BSD and GNU versions of the one-liners.</p>
<h4> Sundeep, Comment 76283925 Score: 6: </h4>not sure about other versions, but with GNU sed, the first one can be simplified to <code>sed -n &#39;&#47;PAT1&#47;,&#47;PAT2&#47;{&#47;&#47;!p}&#39; file</code> ... from <a href="https://www.gnu.org/software/sed/manual/sed.html#Regexp-Addresses" rel="nofollow noreferrer">manual</a> <code>empty regular expression ‘&#47;&#47;’ repeats the last regular expression match</code><br><h4> fedorqui, Comment 98172226 Score: 4: </h4>@AlexHarvey I think it is a great example of kindness what you did here, by sharing your knowledge to improve other answers. Ultimately, this was my goal when I posted this question, so we could have a canonical (<a href="https://xkcd.com/927/" rel="nofollow noreferrer">yet another one :P</a>) set of sources. Many thanks!<br><h4> hek2mgl, Comment 76293546 Score: 2: </h4>Looks like. Hard to find an incompatible version to prove that. :)<br><h4> David C. Rankin, Comment 65309931 Score: 2: </h4>Hey, the classic is even shorter!<br><h4> fedorqui, Comment 98184470 Score: 1: </h4>@AlexHarvey Let me share my view on this: I once answered <a href="https://stackoverflow.com/q/17988756/1983854">How to select lines between two marker patterns which may occur multiple times...</a> and kept getting quite a lot of comments asking for similar cases. Also, when being active in these tags I felt that I was reusing the same one-liners over and over again. For this I thought that a question-answer covering most of the cases could be useful. +25 stars, +30 votes, ~30K visits, lots of duplicates to this seem to agree with this. Of course it is not comprehensive but it seems to be working well.<br><h4> hek2mgl, Comment 76292934 Score: 1: </h4>@Sundeep That&#39;s for the hint. POSIX says: <code>If an RE is empty (that is, no pattern is specified) sed shall behave as if the last RE used in the last command applied (either as an address or as part of a substitute command) was specified.</code> Looks like the only remaining question here is how to interpret <code>the last RE</code>. BSD is saying something to this. Look here (Point 23): <a href="https://github.com/freebsd/freebsd/blob/master/usr.bin/sed/POSIX" rel="nofollow noreferrer">github.com/freebsd/freebsd/blob/master/usr.bin/sed/POSIX</a><br><h4> Sundeep, Comment 76293335 Score: 1: </h4>@hek2mgl thanks for additional info... so if I understood correctly, <code>&#47;PAT1&#47;,&#47;PAT2&#47;{&#47;&#47;!p}</code> will work only if last RE is dynamic.. if it was static, <code>&#47;&#47;</code> would resolve to <code>&#47;PAT2&#47;</code><br><h4> einpoklum, Comment 70270283 Score: 0: </h4>What about the case of the starting line also matching the end pattern (but perhaps not vice-versa)? That would break your 3rd case at least.<br><h4> hek2mgl, Comment 70271099 Score: 0: </h4>Then the start and end pattern is not well chosen or the regex need to be more precise.<br><h4> fedorqui, Comment 98156876 Score: 0: </h4>Note there is <a href="https://stackoverflow.com/a/55488022/1983854">a new answer</a> suggesting improvements to this one.<br><h4> Alex Harvey, Comment 98171994 Score: 0: </h4>@fedorqui, there&#39;s my best go at it.<br><h4> markling, Comment 134744963 Score: 0: </h4>If you compose the sed command from variables, then you must create it from a a combination of parts, some in single quotes, and some in double quotes. Something like this: <code>sed -n &quot;&#47;$pattern1&#47;,&#47;$pattern2&#47;&quot;&#39;{&#47;&#47;!p}&#39;</code>.   The bash shell will not expand the variables if they are in single quotes. But if you contain the whole command in double quotes, bash will interpret <code>!</code> as a history command, and will expand it. So that part of the sed command must be in single quotes.<br>------------------------------------------------------------------ <br><h3> James Brown, Id: 38975890, Score: 13: </h3><p>Using <code>grep</code> with PCRE (where available) to <strong>print markers and lines between markers</strong>:</p>

<pre><code>$ grep -Pzo "(?s)(PAT1(.*?)(PAT2|\Z))" file
PAT1
3    - first block
4
PAT2
PAT1
7    - second block
PAT2
PAT1
10    - third block
</code></pre>

<ul>
<li><code>-P</code> perl-regexp, PCRE. Not in all <code>grep</code> variants</li>
<li><code>-z</code> Treat the input as a set of lines, each
terminated by a zero byte instead of a newline </li>
<li><code>-o</code> print only matching</li>
<li><code>(?s)</code> DotAll, ie. dot finds newlines as well </li>
<li><code>(.*?)</code> nongreedy find</li>
<li><code>\Z</code> Match only at end of string, or before newline at the end</li>
</ul>

<p><strong>Print lines between markers excluding end marker</strong>:</p>

<pre><code>$ grep -Pzo "(?s)(PAT1(.*?)(?=(\nPAT2|\Z)))" file
PAT1
3    - first block
4
PAT1
7    - second block
PAT1
10    - third block
</code></pre>

<ul>
<li><code>(.*?)(?=(\nPAT2|\Z))</code> nongreedy find with lookahead for <code>\nPAT2</code> and <code>\Z</code></li>
</ul>

<p><strong>Print lines between markers excluding markers</strong>:</p>

<pre><code>$ grep -Pzo "(?s)((?&lt;=PAT1\n)(.*?)(?=(\nPAT2|\Z)))" file
3    - first block
4
7    - second block
10    - third block
</code></pre>

<ul>
<li><code>(?&lt;=PAT1\n)</code> positive lookbehind for <code>PAT1\n</code></li>
</ul>

<p><strong>Print lines between markers excluding start marker</strong>:</p>

<pre><code>$ grep -Pzo "(?s)((?&lt;=PAT1\n)(.*?)(PAT2|\Z))" file
3    - first block
4
PAT2
7    - second block
PAT2
10    - third block
</code></pre>
<h4> Phil, Comment 135671405 Score: 0: </h4>Liking this because it works with regex patterns. The chosen solution did not.<br>------------------------------------------------------------------ <br><h3> Alex Harvey, Id: 55773449, Score: 9: </h3><p>For completeness, here is a Perl solution:</p>

<h3>Print lines between PAT1 and PAT2 - include PAT1 and PAT2</h3>

<pre class="lang-none prettyprint-override"><code>perl -ne '/PAT1/../PAT2/ and print' FILE
</code></pre>

<p>or:</p>

<pre class="lang-none prettyprint-override"><code>perl -ne 'print if /PAT1/../PAT2/' FILE
</code></pre>

<h3>Print lines between PAT1 and PAT2 - exclude PAT1 and PAT2</h3>

<pre class="lang-none prettyprint-override"><code>perl -ne '/PAT1/../PAT2/ and !/PAT1/ and !/PAT2/ and print' FILE
</code></pre>

<p>or:</p>

<pre class="lang-none prettyprint-override"><code>perl -ne 'if (/PAT1/../PAT2/) {print unless /PAT1/ or /PAT2/}' FILE 
</code></pre>

<h3>Print lines between PAT1 and PAT2 - exclude PAT1 only</h3>

<pre class="lang-none prettyprint-override"><code>perl -ne '/PAT1/../PAT2/ and !/PAT1/ and print' FILE
</code></pre>

<h3>Print lines between PAT1 and PAT2 - exclude PAT2 only</h3>

<pre class="lang-none prettyprint-override"><code>perl -ne '/PAT1/../PAT2/ and !/PAT2/ and print' FILE
</code></pre>

<p>See also:</p>

<ul>
<li>Range operator section in <code>perldoc perlop</code> for more on the <code>/PAT1/../PAT2/</code> grammar:</li>
</ul>

<blockquote>
  <p><strong>Range operator</strong> </p>
  
  <p>...In scalar context, ".." returns a boolean value.  The operator is
  bistable, like a flip-flop, and emulates the line-range (comma)
  operator of sed, awk, and various editors.</p>
</blockquote>

<ul>
<li><p>For the <code>-n</code> option, see <code>perldoc perlrun</code>, which makes Perl behave like <code>sed -n</code>.</p></li>
<li><p><a href="https://docstore.mik.ua/orelly/perl3/cookbook/ch06_09.htm" rel="noreferrer">Perl Cookbook, 6.8</a> for a detailed discussion of extracting a range of lines.</p></li>
</ul>
------------------------------------------------------------------ <br><h3> karakfa, Id: 38977614, Score: 8: </h3><p>Here is another approach</p>

<p><strong>Include both patterns (default)</strong></p>

<pre><code>$ awk '/PAT1/,/PAT2/' file
PAT1
3    - first block
4
PAT2
PAT1
7    - second block
PAT2
PAT1
10    - third block
</code></pre>

<p><strong>Mask both patterns</strong></p>

<pre><code>$ awk '/PAT1/,/PAT2/{if(/PAT2|PAT1/) next; print}' file
3    - first block
4
7    - second block
10    - third block
</code></pre>

<p><strong>Mask start pattern</strong></p>

<pre><code>$ awk '/PAT1/,/PAT2/{if(/PAT1/) next; print}' file
3    - first block
4
PAT2
7    - second block
PAT2
10    - third block
</code></pre>

<p><strong>Mask end pattern</strong></p>

<pre><code>$ awk '/PAT1/,/PAT2/{if(/PAT2/) next; print}' file
PAT1
3    - first block
4
PAT1
7    - second block
PAT1
10    - third block
</code></pre>
------------------------------------------------------------------ <br><h3> Daedelus, Id: 42009435, Score: 7: </h3><p>Alternatively:</p>

<pre><code>sed '/START/,/END/!d;//d'
</code></pre>

<p>This deletes all lines except for those between and including START and END, then the <code>//d</code> deletes the START and END lines since <code>//</code> causes sed to use the previous patterns.</p>
------------------------------------------------------------------ <br><h3> aalosious, Id: 58568587, Score: 5: </h3><p>This is like a foot-note to the 2 top answers above (awk &amp; sed). I needed to run it on a large number of files, and hence performance was important. I put the 2 answers to a load-test of 10000 times:</p>

<h3>sedTester.sh</h3>

<pre><code>for i in `seq 10000`;do sed -n '/PAT1/,/PAT2/{/PAT1/!{/PAT2/!p;};}' patternTester &gt;&gt; sedTesterOutput; done
</code></pre>

<h3>awkTester.sh</h3>

<pre><code> for i in `seq 10000`;do awk '/PAT1/{flag=1; next} /PAT2/{flag=0} flag' patternTester &gt;&gt; awkTesterOutput; done
</code></pre>

<p>Here are the results:</p>

<pre><code>zsh sedTester.sh  11.89s user 39.63s system 81% cpu 1:02.96 total
zsh awkTester.sh  38.73s user 60.64s system 79% cpu 2:04.83 total
</code></pre>

<p>sed solutions seems to be twice as fast as the awk solution (Mac OS).</p>
------------------------------------------------------------------ <br><h3> David C. Rankin, Id: 38978493, Score: 4: </h3><p>You can do what you want with <code>sed</code> by <em>suppressing the normal printing of pattern space</em> with <code>-n</code>. For instance to <em>include</em> the patterns in the result you can do:</p>

<pre><code>$ sed -n '/PAT1/,/PAT2/p' filename
PAT1
3    - first block
4
PAT2
PAT1
7    - second block
PAT2
PAT1
10    - third block
</code></pre>

<p>To <em>exclude</em> the patterns and just print what is between them:</p>

<pre><code>$ sed -n '/PAT1/,/PAT2/{/PAT1/{n};/PAT2/{d};p}' filename
3    - first block
4
7    - second block
10    - third block
</code></pre>

<p>Which breaks down as</p>

<ul>
<li><p><code>sed -n '/PAT1/,/PAT2/</code> - locate the range between <code>PAT1</code> and <code>PAT2</code> and suppress printing;</p></li>
<li><p><code>/PAT1/{n};</code> - if it matches <code>PAT1</code> move to <code>n</code> (next) line;</p></li>
<li><p><code>/PAT2/{d};</code> - if it matches <code>PAT2</code> delete line;</p></li>
<li><p><code>p</code> - print all lines that fell within <code>/PAT1/,/PAT2/</code> and were not skipped or deleted.</p></li>
</ul>
<h4> fedorqui, Comment 65310005 Score: 0: </h4>Thanks for the interesting one-liners and its breakdown! I have to admit I still prefer awk, it looks clearer to me :)<br><h4> David C. Rankin, Comment 65310085 Score: 0: </h4>I got done sorting through this one only to find <i>hek2mgl</i> had a shorter way -- take a look at his <i>classic</i> <code>sed</code> solution.<br>------------------------------------------------------------------ <br><h3> potong, Id: 64970718, Score: 3: </h3><p>This might work for you (GNU sed) on the proviso that <code>PAT1</code> and <code>PAT2</code> are on separate lines:</p>
<pre><code>sed -n '/PAT1/{:a;N;/PAT2/!ba;p}' file
</code></pre>
<p>Turn off implicit printing by using the <code>-n</code> option and act like grep.</p>
<p>N.B. All solutions using the range idiom i.e. <code>/PAT1/,/PAT2/ command</code> suffer from the same edge case, where <code>PAT1</code> exists but <code>PAT2</code> does not and therefore will print from <code>PAT1</code> to the end of the file.</p>
<p>For completeness:</p>
<pre><code># PAT1 to PAT2 without PAT1
sed -n '/PAT1/{:a;N;/PAT2/!ba;s/^[^\n]*\n//p}' file 

# PAT1 to PAT2 without PAT2
sed -n '/PAT1/{:a;N;/PAT2/!ba;s/\n[^\n]*$//p}' file 

# PAT1 to PAT2 without PAT1 and PAT2   
sed -n '/PAT1/{:a;N;/PAT2/!ba;/\n.*\n/!d;s/^[^\n]*\n\|\n[^\n]*$/gp}' file
</code></pre>
<p>N.B. In the last solution <code>PAT1</code> and <code>PAT2</code> may be on consecutive lines and therefore a further edge case may arise. IMO both are deleted and nothing printed.</p>
