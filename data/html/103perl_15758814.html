 <h2> Title: Turning multiple lines into one comma separated line </h2> <h3> neversaint, question_id: 15758814 </h3>Score: 103, Tags: {linux,perl,unix,sed,awk} <br><p>I have the following data in multiple lines:</p>
<pre><code>foo
bar
qux
zuu
sdf
sdfasdf
</code></pre>
<p>What I want to do is to convert them to one comma separated line:</p>
<pre><code>foo,bar,qux,zuu,sdf,sdfasdf
</code></pre>
<p>What's the best unix one-liner to do that?</p>
<h4> Comment 41577359 valid: </h4>If the solutions below do not produce the required results, e.g. only the last line&#39;s content showing, you may have unwanted control characters in your input, e.g. <code>\r</code>. You can check that by piping the input to <code>hd</code> or <code>hexdump</code>. <code>\r</code> will (in conjunction with <code>\n</code>) produce the two-byte sequences <code>0a0d</code>. Fix with <code>|sed &#39;s&#47;\r&#47;&#47;g&#39;</code>.<br><h4> Comment 41905414 reinierpost: </h4>This question is a duplicate, but not all of the answers are.<br>------------------------------------------------------------------ <br><h3> Answer 15759052 Guru: </h3><p>Using paste command:</p>

<pre><code>paste -d, -s file
</code></pre>
<h4> Comment 54579169 NeoMorfeo: </h4>But how to accomplish that for a variable or a pipe?  Update myself: Using -s without value .... | paste -d, -s<br><h4> Comment 71330342 Carson Anderson: </h4>@NeoMorfeo You can use a <code>-</code> to read from pipe as well.  Ex: <code>echo -e &quot;1\n2\n3&quot; | paste -d, -s -</code><br><h4> Comment 64594047 CoderGuy123: </h4>While this works for when one wants to convert newlines (<code>\n</code>) into commas, it seems that one cannot use this method if one needs to convert newlines into &quot;<code>, </code>&quot; which is required for many other commands.<br>------------------------------------------------------------------ <br><h3> Answer 17759537 Serhii Kuzmychov: </h3><h3>file</h3>

<pre><code>aaa
bbb
ccc
ddd
</code></pre>

<h3>xargs</h3>

<pre><code>cat file | xargs
</code></pre>

<h3>result</h3>

<pre><code>aaa bbb ccc ddd 
</code></pre>

<h3>xargs improoved</h3>

<pre><code>cat file | xargs | sed -e 's/ /,/g'
</code></pre>

<h3>result</h3>

<pre><code>aaa,bbb,ccc,ddd 
</code></pre>
<h4> Comment 27059073 Serhii Kuzmychov: </h4>xargs turns multi-line into one line space-separated, then sed replaces all space by &#39;,&#39;(or &#39; ,&#39; if you will use sed -e &#39;s/ /\ ,/g&#39; ( by the way -e can be omited)<br><h4> Comment 79050981 jimh: </h4>I found this to be the solution I was looking for, not the accepted one because it works for pipes and multiple files and you can pass it to tr -s &quot; &quot; &quot;\t&quot; if you want to add tabs and so forth.  Thank you.<br><h4> Comment 67953056 Bee Kay: </h4>Thanks for the step by step!  I had a file with one entry per line, (fn, ln,id,status, blank line.)  I needed it in CSV, so I swapped &quot;blank line&quot; with an unused symbol (sed -e &#39;s/^$/#/&#39;) before using the mod you&#39;ve explained.<br><h4> Comment 27059201 Serhii Kuzmychov: </h4>usually xargs is not intended for t but it works :)<br><h4> Comment 27059227 Serhii Kuzmychov: </h4>and it more prefer way for every day use insted of the one bellow<br>------------------------------------------------------------------ <br><h3> Answer 15759187 n3rV3: </h3><p>There are many ways it can be achieved. The tool you use mostly depends on your own preference or experience.</p>

<p>Using tr command:</p>

<pre><code>tr '\n' ',' &lt; somefile
</code></pre>

<p>Using awk:</p>

<pre><code>awk -F'\n' '{if(NR == 1) {printf $0} else {printf ","$0}}' somefile
</code></pre>
<h4> Comment 22409635 Ed Morton: </h4>Never use <code>printf $0</code> as it will fail cryptically if $0 contains any printf formatting characters. The synopsis for printf is <code>printf format, data</code> so use <code>printf &quot;%s&quot;, $0</code> instead.<br><h4> Comment 22405846 Chris Seymour: </h4><code>awk &#39;{printf NR==1?$0:&quot;,&quot;$0}&#39; file</code><br><h4> Comment 22397780 Kent: </h4>your both commands would generate ending comma<br><h4> Comment 22398279 n3rV3: </h4>yes, i can fix it in awk but not in tr, give me a min.<br><h4> Comment 22418344 n3rV3: </h4>i still have a lot to learn. thanks<br>------------------------------------------------------------------ <br><h3> Answer 18419565 Serhii Kuzmychov: </h3><p><code>xargs -a your_file | sed 's/ /,/g'</code></p>

<p>This is a shorter way.</p>
<h4> Comment 65678237 cadrian: </h4>except if there are spaces in your lines...<br><h4> Comment 65954410 Serhii Kuzmychov: </h4>sed -e &#39;s/ /+/g&#39; test |xargs|sed &#39;s/ /,/g;s/+/ /g&#39;  it was just an idea how to use xargs :) do not think it is seriously<br>------------------------------------------------------------------ <br><h3> Answer 15759296 Kent: </h3><p>based on your input example, this awk line works. (without trailing comma)</p>

<pre><code>awk -vRS="" -vOFS=',' '$1=$1' file
</code></pre>

<p>test:</p>

<pre><code>kent$  echo "foo
bar
qux
zuu
sdf
sdfasdf"|awk -vRS="" -vOFS=',' '$1=$1' 
foo,bar,qux,zuu,sdf,sdfasdf
</code></pre>
<h4> Comment 22409716 Ed Morton: </h4>For clarity and to avoid getting surprised when you later do try to use a variable in a BEGIN block, I&#39;d always use -v unless setting a variable to different values between files. FYI omitting the space between -v and the variable name makes your script un-necessarily gawk-specific so I&#39;d use <code>-v RS=</code> instead of <code>-vRS=</code>.<br><h4> Comment 22405789 Chris Seymour: </h4>You only need to use <code>-v</code> if you want the variables available in the BEGIN block, slightly more concise <code>awk &#39;$1=$1&#39; RS= OFS=, file</code>.<br><h4> Comment 22410055 Kent: </h4>@EdMorton thx for the comment. (the &quot;space&quot; between -v and va). I learned many tips from you :). Personally I always use <code>-v</code> too.<br>------------------------------------------------------------------ <br><h3> Answer 15759204 choroba: </h3><p>Perl one-liner:</p>

<pre><code>perl -pe'chomp, s/$/,/ unless eof' file
</code></pre>

<p>or, if you want to be more cryptic:</p>

<pre><code>perl '-peeof||chomp&amp;&amp;s/$/,/' file
</code></pre>
<h4> Comment 22402849 sid_com: </h4>Even more cryptic: <code>perl &#39;-peeof||s|$&#47;$|,|&#39; file</code><br><h4> Comment 24263173 protist: </h4>sid_com, I like your choice of substitution delimiters :D... <code>perl -pe &#39;eof or s#\n$#,#&#39; thing</code><br><h4> Comment 39181190 Peter K: </h4>ok, even more cryptic perl: perl -l54 -pe &#39;eof and $\=&quot;&quot;&#39; file (and you can go with empty script body if you can tolerate last coma)<br>------------------------------------------------------------------ <br><h3> Answer 16821466 protist: </h3><pre><code>sed -n 's/.*/&amp;,/;H;$x;$s/,\n/,/g;$s/\n\(.*\)/\1/;$s/\(.*\),/\1/;$p'
</code></pre>
<h4> Comment 78751444 Lazarus Thurston: </h4>too complicated. Please explain @protist.<br>------------------------------------------------------------------ <br><h3> Answer 15761620 Vijay: </h3><pre><code>perl -pi.bak -e 'unless(eof){s/\n/,/g}' your_file
</code></pre>

<p>This will create a backup of original file with an extension of .bak and then modifies the original file</p>
