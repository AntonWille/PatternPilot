 <h2> Title: How can I remove text within parentheses with a regex? </h2> <h4> Technical Bard, question_id: 640001 </h4>Score: 109, Tags: {python,regex,perl} <br><p>I'm trying to handle a bunch of files, and I need to alter then to remove extraneous information in the filenames; notably, I'm trying to remove text inside parentheses. For example:</p>

<pre><code>filename = "Example_file_(extra_descriptor).ext"
</code></pre>

<p>and I want to regex a whole bunch of files where the parenthetical expression might be in the middle or at the end, and of variable length.</p>

<p>What would the regex look like?  Perl or Python syntax would be preferred.</p>
<h4> j_random_hacker, Id: 459381 Score: 2: </h4>@dmckee: It is harder if the parens can be <i>nested</i>, though if you just want to get rid of everything between the first &#39;(&#39; and the last &#39;)&#39; it&#39;s not much harder: just use a greedy &#39;.*&#39; instead of &#39;.*?&#39;.<br><h4> skyking, Id: 53109180 Score: 2: </h4>@j_random_hacker You&#39;re correct, it&#39;s hell of a lot harder since nested parentheses can&#39;t be recognized with a FSM (you have to keep track of the nesting level which is unlimited) and therefore not by a regex. For it to be possible you have to restrict yourself to a limited level of nesting.<br><h4> dmckee --- ex-moderator kitten, Id: 456926 Score: 0: </h4>Are you sure that the &quot;extra_descriptor&quot; cannot include a &quot;)&quot;? If it can the problem becomes much harder...<br>------------------------------------------------------------------ <br><h3> Can Berk G&#252;der, Id: 640016, Score: 174: </h3><pre><code>s/\([^)]*\)//
</code></pre>

<p>So in Python, you'd do:</p>

<pre><code>re.sub(r'\([^)]*\)', '', filename)
</code></pre>
<h4> daotoad, Comment 454934 Score: 20: </h4>.* gets everything between the first left paren and last right paren: &#39;a(b)c(d)e&#39; will become &#39;ae&#39;. [^)]* only removes between the first left paren and the first right paren: &#39;ac(d)e&#39;.  You&#39;ll also get different behaviors for nested parens.<br><h4> Kip, Comment 453831 Score: 2: </h4>is there any reason to prefer .*? over [^)]*<br><h4> Can Berk G&#252;der, Comment 454300 Score: 1: </h4>@Kip: nope. I don&#39;t know why, but .* is always the first thing that comes to mind.<br><h4> X-Istence, Comment 454376 Score: 0: </h4>@Kip: .*? is not handled by all regex parsers, whereas your [^)]* is handled by almost all of them.<br><h4> Gumbo, Comment 454538 Score: 0: </h4>@Kip: Another reason is backtracking.<br><h4> ovgolovin, Comment 16416512 Score: 0: </h4>@J.F.Sebastian Inverted class <code>[^)]*</code> is much faster than minimal quantifier <code>.*?</code>. The only exception is Perl, which performs optimization on the symbol following minimal quantifier (at least this optimization was only implemented in Perl at the time the book, I read this info in, was written).<br><h4> ovgolovin, Comment 16418823 Score: 0: </h4>@J.F.Sebastian Oh. My comment shouldn&#39;t have been addressed to you. I confused something. I commented because I think it&#39;s a good piece of information to supplement the answer.<br><h4> jfs, Comment 16419232 Score: 0: </h4>@ovgolovin: ok. btw, <a href="http://codepad.org/WQeqAXC9" rel="nofollow noreferrer">the regexes are not equivalent in general</a> unless there is re.DOTALL flag. Also Have you tried to measure it in Python?<br><h4> ovgolovin, Comment 16419804 Score: 0: </h4>@J.F.Sebastian No, I din&#39;t try to measure it in Python. I only remembered this maxim from the book. But the author had Python regexp engine in mind while writing it (he usually refers to Python flavor in it).<br><h4> DiB, Comment 65165555 Score: 0: </h4>I was looking to do this inside Visual Studio.  The regex for Visual Studio is <code>\([^)]*\)</code><br><h4> Narahari B M, Comment 117924392 Score: 0: </h4>When there are multiple parantheses, it is better to use <a href="https://stackoverflow.com/a/47823114/7131019">stackoverflow.com/a/47823114/7131019</a><br><h4> daotoad, Comment 454952 Score: 0: </h4>Oops, I was wrong in the last comment.  The &#39;?&#39; in the .* example makes it behave like the negated character class.  But then, so was Gumbo, since there won&#39;t be any backtracking with the non-greedy .*? construct.<br><h4> Human programmer, Comment 130551516 Score: 0: </h4>This answer will not work for filenames with nested brackets like this:  &quot;filename_abc(text(TM))&quot;  as the result will be &quot;filename_abc)&quot;<br>------------------------------------------------------------------ <br><h3> Wiktor Stribiżew, Id: 40621332, Score: 130: </h3><p>The pattern that matches substrings in parentheses <em>having no other <code>(</code> and <code>)</code> characters in between</em> (like <code>(xyz 123)</code> in <code>Text (abc(xyz 123)</code>) is</p>
<pre><code>\([^()]*\)
</code></pre>
<p><strong>Details</strong>:</p>
<ul>
<li><code>\(</code> - an opening round bracket (note that in POSIX BRE, <code>(</code> should be used, see <code>sed</code> example below)</li>
<li><code>[^()]*</code> - zero or more (due to the <code>*</code> <a href="http://www.regular-expressions.info/repeat.html" rel="noreferrer">Kleene star quantifier</a>) characters <em>other than</em> those defined in the <a href="http://www.regular-expressions.info/charclass.html#negated" rel="noreferrer"><em>negated character class</em>/<em>POSIX bracket expression</em></a>, that is, any chars other than <code>(</code> and <code>)</code></li>
<li><code>\)</code> - a closing round bracket (no escaping in POSIX BRE allowed)</li>
</ul>
<p>Removing code snippets:</p>
<ul>
<li><strong>JavaScript</strong>: <code>string.replace(/\([^()]*\)/g, '')</code></li>
<li><strong>PHP</strong>: <code>preg_replace('~\([^()]*\)~', '', $string)</code></li>
<li><strong>Perl</strong>: <code>$s =~ s/\([^()]*\)//g</code></li>
<li><strong>Python</strong>: <code>re.sub(r'\([^()]*\)', '', s)</code></li>
<li><strong>C#</strong>: <code>Regex.Replace(str, @&quot;\([^()]*\)&quot;, string.Empty)</code></li>
<li><strong>VB.NET</strong>: <code>Regex.Replace(str, &quot;\([^()]*\)&quot;, &quot;&quot;)</code></li>
<li><strong>Java</strong>: <code>s.replaceAll(&quot;\\([^()]*\\)&quot;, &quot;&quot;)</code></li>
<li><strong>Ruby</strong>: <code>s.gsub(/\([^()]*\)/, '')</code></li>
<li><strong>R</strong>: <code>gsub(&quot;\\([^()]*\\)&quot;, &quot;&quot;, x)</code></li>
<li><strong>Lua</strong>: <code>string.gsub(s, &quot;%([^()]*%)&quot;, &quot;&quot;)</code></li>
<li><strong>Bash/sed</strong>: <code>sed 's/([^()]*)//g'</code></li>
<li><strong>Tcl</strong>: <code>regsub -all {\([^()]*\)} $s &quot;&quot; result</code></li>
<li><strong>C++ <code>std::regex</code></strong>: <code>std::regex_replace(s, std::regex(R&quot;(\([^()]*\))&quot;), &quot;&quot;)</code></li>
<li><strong>Objective-C</strong>: <br/><code>NSRegularExpression *regex = [NSRegularExpression regularExpressionWithPattern:@&quot;\\([^()]*\\)&quot; options:NSRegularExpressionCaseInsensitive error:&amp;error]; NSString *modifiedString = [regex stringByReplacingMatchesInString:string options:0 range:NSMakeRange(0, [string length]) withTemplate:@&quot;&quot;];</code></li>
<li><strong>Swift</strong>: <code>s.replacingOccurrences(of: &quot;\\([^()]*\\)&quot;, with: &quot;&quot;, options: [.regularExpression])</code></li>
<li><strong>Google BigQuery</strong>: <code>REGEXP_REPLACE(col, &quot;\\([^()]*\\)&quot; , &quot;&quot;)</code></li>
</ul>
<h4> Wiktor Stribiżew, Comment 122011938 Score: 1: </h4>@AnoushiravanR It depends on the regex flavor. See <a href="https://stackoverflow.com/a/62129083/3832970">this answer of mine</a>.<br><h4> Anoushiravan R, Comment 122011906 Score: 0: </h4>Dear Wiktor I only have one question. If we were to exclude bracket <code>[</code> instead of parentheses, do we have to escape them within <code>[^ ]</code> structure like <code>[^\\[\\]]</code> or it was not necessary as other characters?<br>------------------------------------------------------------------ <br><h3> Gumbo, Id: 640054, Score: 24: </h3><p>I would use:</p>

<pre><code>\([^)]*\)
</code></pre>
<h4> Human programmer, Comment 130551568 Score: 0: </h4>This answer will not work for filenames with nested brackets like this: &quot;filename_abc(text(TM))&quot; as the result will be &quot;filename_abc)&quot;<br>------------------------------------------------------------------ <br><h3> daotoad, Id: 640819, Score: 7: </h3><p>If you don't absolutely need to use a regex, <strike>use</strike>consider using Perl's <a href="http://perldoc.perl.org/Text/Balanced.html" rel="nofollow noreferrer">Text::Balanced</a> to remove the parenthesis.</p>
<pre><code>use Text::Balanced qw(extract_bracketed);

my ($extracted, $remainder, $prefix) = extract_bracketed( $filename, '()', '[^(]*' );

{   no warnings 'uninitialized';

    $filename = (defined $prefix or defined $remainder)
                ? $prefix . $remainder
                : $extracted;
}
</code></pre>
<p>You may be thinking, &quot;Why do all this when a regex does the trick in one line?&quot;</p>
<pre><code>$filename =~ s/\([^}]*\)//;
</code></pre>
<p>Text::Balanced handles nested parenthesis.  So <code>$filename = 'foo_(bar(baz)buz)).foo'</code> will be extracted properly.  The regex based solutions offered here will fail on this string.  The one will stop at the first closing paren, and the other will eat them all.</p>
<pre><code>   $filename =~ s/\([^}]*\)//;
   # returns 'foo_buz)).foo'

   $filename =~ s/\(.*\)//;
   # returns 'foo_.foo'

   # text balanced example returns 'foo_).foo'
</code></pre>
<p>If either of the regex behaviors is acceptable, use a regex--but document the limitations and the assumptions being made.</p>
<h4> Chris Lutz, Comment 454377 Score: 0: </h4>While I know you can&#39;t parse nested parenthesis with (classic) regexes, if you know you&#39;re never going to encounter nested parenthesis, you can simplify the problem to one that CAN be done with regexes, and fairly easily. It&#39;s overkill to use a parser tool when we don&#39;t need it.<br><h4> daotoad, Comment 454525 Score: 0: </h4>@Chris Lutz - I should have said &quot;consider&quot; rather than &quot;use&quot; in the first sentence. In many cases a regex will do the job, which is why I said to use a regex if the behavior is acceptable.<br>------------------------------------------------------------------ <br><h3> jfs, Id: 640250, Score: 3: </h3><p>If a path may contain parentheses then the <code>r'\(.*?\)'</code> regex is not enough:</p>

<pre><code>import os, re

def remove_parenthesized_chunks(path, safeext=True, safedir=True):
    dirpath, basename = os.path.split(path) if safedir else ('', path)
    name, ext = os.path.splitext(basename) if safeext else (basename, '')
    name = re.sub(r'\(.*?\)', '', name)
    return os.path.join(dirpath, name+ext)
</code></pre>

<p>By default the function preserves parenthesized chunks in directory and extention parts of the path.</p>

<p>Example:</p>

<pre><code>&gt;&gt;&gt; f = remove_parenthesized_chunks
&gt;&gt;&gt; f("Example_file_(extra_descriptor).ext")
'Example_file_.ext'
&gt;&gt;&gt; path = r"c:\dir_(important)\example(extra).ext(untouchable)"
&gt;&gt;&gt; f(path)
'c:\\dir_(important)\\example.ext(untouchable)'
&gt;&gt;&gt; f(path, safeext=False)
'c:\\dir_(important)\\example.ext'
&gt;&gt;&gt; f(path, safedir=False)
'c:\\dir_\\example.ext(untouchable)'
&gt;&gt;&gt; f(path, False, False)
'c:\\dir_\\example.ext'
&gt;&gt;&gt; f(r"c:\(extra)\example(extra).ext", safedir=False)
'c:\\\\example.ext'
</code></pre>
------------------------------------------------------------------ <br><h3> Andrew Basile, Id: 47823114, Score: 3: </h3><p>For those who want to use Python, here's a simple routine that removes parenthesized substrings, including those with nested parentheses. Okay, it's not a regex, but it'll do the job!</p>

<pre><code>def remove_nested_parens(input_str):
    """Returns a copy of 'input_str' with any parenthesized text removed. Nested parentheses are handled."""
    result = ''
    paren_level = 0
    for ch in input_str:
        if ch == '(':
            paren_level += 1
        elif (ch == ')') and paren_level:
            paren_level -= 1
        elif not paren_level:
            result += ch
    return result

remove_nested_parens('example_(extra(qualifier)_text)_test(more_parens).ext')
</code></pre>
------------------------------------------------------------------ <br><h3> samoz, Id: 640038, Score: 1: </h3><p>If you can stand to use <code>sed</code> (possibly execute from within your program, it'd be as simple as:</p>

<pre><code>sed 's/(.*)//g'
</code></pre>
<h4> Gumbo, Comment 453560 Score: 0: </h4>You are just grouping the expression <code>.*</code>.<br><h4> runrig, Comment 453782 Score: 0: </h4>@Gumbo: No, he&#39;s not. In sed, &quot;\&#40;...\&#41;&quot; groups.<br>------------------------------------------------------------------ <br><h3> riza, Id: 640630, Score: 0: </h3><pre><code>&gt;&gt;&gt; import re
&gt;&gt;&gt; filename = "Example_file_(extra_descriptor).ext"
&gt;&gt;&gt; p = re.compile(r'\([^)]*\)')
&gt;&gt;&gt; re.sub(p, '', filename)
'Example_file_.ext'
</code></pre>
------------------------------------------------------------------ <br><h3> Peer Mohamed, Id: 11793027, Score: 0: </h3><p>Java code:</p>

<pre><code>Pattern pattern1 = Pattern.compile("(\\_\\(.*?\\))");
System.out.println(fileName.replace(matcher1.group(1), ""));
</code></pre>
