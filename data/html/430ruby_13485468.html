 <h2> Title: How to map and remove nil values in Ruby </h2> <h4> Pete Hamilton, question_id: 13485468, created_at: 2012-11-21 02:29:13+00:00 </h4>Score: 430, Tags: {ruby} <br><p>I have a <code>map</code> which either changes a value or sets it to nil. I then want to remove the nil entries from the list. The list doesn't need to be kept.</p>

<p>This is what I currently have:</p>

<pre class="lang-rb prettyprint-override"><code># A simple example function, which returns a value or nil
def transform(n)
  rand &gt; 0.5 ? n * 10 : nil }
end

items.map! { |x| transform(x) } # [1, 2, 3, 4, 5] =&gt; [10, nil, 30, 40, nil]
items.reject! { |x| x.nil? } # [10, nil, 30, 40, nil] =&gt; [10, 30, 40]
</code></pre>

<p>I'm aware I could just do a loop and conditionally collect in another array like this:</p>

<pre class="lang-rb prettyprint-override"><code>new_items = []
items.each do |x|
    x = transform(x)
    new_items.append(x) unless x.nil?
end
items = new_items
</code></pre>

<p>But it doesn't seem that idiomatic. Is there a nice way to map a function over a list, removing/excluding the nils as you go?</p>
<h4> Comment by SRack, Score: 10, Id: 101138067, created_at: 2019-08-02 09:43:13+00:00 </h4>Ruby 2.7 introduces <code>filter_map</code>, which seems to be perfect for this. Saves the need to re-process the array, instead getting it as desired first time through. <a href="https://stackoverflow.com/questions/13485468/map-and-remove-nil-values-in-ruby/57323856#answer-57323856">More info here.</a><hr><h3>  Answer by the Tin Man, Id: 13485482, Score: 1094, created_at: 2012-11-21 02:30:55+00:00 </h3><p>You could use <a href="https://ruby-doc.org/core-1.9.3/Array.html#method-i-compact" rel="noreferrer"><code>compact</code></a>:</p>

<pre><code>[1, nil, 3, nil, nil].compact
=&gt; [1, 3] 
</code></pre>

<hr>

<p>I'd like to remind people that if you're getting an array containing nils as the output of a <code>map</code> block, and that block tries to conditionally return values, then you've got code smell and need to rethink your logic. </p>

<p>For instance, if you're doing something that does this:</p>

<pre><code>[1,2,3].map{ |i|
  if i % 2 == 0
    i
  end
}
# =&gt; [nil, 2, nil]
</code></pre>

<p>Then don't. Instead, prior to the <code>map</code>, <code>reject</code> the stuff you don't want or <code>select</code> what you do want:</p>

<pre><code>[1,2,3].select{ |i| i % 2 == 0 }.map{ |i|
  i
}
# =&gt; [2]
</code></pre>

<p>I consider using <code>compact</code> to clean up a mess as a last-ditch effort to get rid of things we didn't handle correctly, usually because we didn't know what was coming at us. We should always know what sort of data is being thrown around in our program; Unexpected/unknown data is bad. Anytime I see nils in an array I'm working on, I dig into why they exist, and see if I can improve the code generating the array, rather than allow Ruby to waste time and memory generating nils then sifting through the array to remove them later. </p>

<pre><code>'Just my $%0.2f.' % [2.to_f/100]
</code></pre>
<h4> Comment by Ziggy, Score: 11, Id: 45989593, created_at: 2015-03-04 18:34:02+00:00 </h4>Both solutions iterate twice over the collection... why not use <code>reduce</code> or <code>inject</code>?<h4> Comment by the Tin Man, Score: 5, Id: 39461500, created_at: 2014-08-14 19:31:34+00:00 </h4>Why should it? The OP needs to strip <code>nil</code> entries, not empty strings. BTW, <code>nil</code> isn&#39;t the same as an empty-string.<h4> Comment by the Tin Man, Score: 5, Id: 45995637, created_at: 2015-03-04 21:27:27+00:00 </h4>It doesn&#39;t sound like you read the OPs question or the answer. The question is, how to remove nils from an array. <code>compact</code> is fastest but actually writing the code correctly in the start removes the need to deal with nils completely.<h4> Comment by Ziggy, Score: 4, Id: 52068235, created_at: 2015-08-19 03:52:31+00:00 </h4>I disagree! The question is &quot;Map and remove nil values&quot;. Well, to map and remove nil values is to reduce. In their example, the OP maps and then select out the nils. Calling map and then compact, or select and then map, amounts to making the same mistake: as you point out in your answer, it is a code smell.<h4> Comment by Anton, Score: 2, Id: 55020996, created_at: 2015-11-10 05:29:36+00:00 </h4>Answer from @Ziggy should be accepted as a correct answer<h4> Comment by rubyprince, Score: 2, Id: 82738372, created_at: 2017-12-19 11:53:03+00:00 </h4>@theTinMan why does the solution with <code>select</code> need another <code>map</code>? <code>[1,2,3].select{ |i| i % 2 == 0 }</code> is enough to return <code>[2]</code>, right? The map part doesnt make sense as it returns the element itself <code>map { |x| x }</code> which equivalent to the input array.<h4> Comment by FloatingRock, Score: 1, Id: 39437566, created_at: 2014-08-14 08:21:30+00:00 </h4>Note: Doesn&#39;t filter out <code>&quot;&quot;</code><h4> Comment by android.weasel, Score: 1, Id: 78655452, created_at: 2017-08-23 20:20:36+00:00 </h4>The example is too simple: if the map were a match against a regex with capture groups, then running the select simply to choose the strings that matched, and then running the map to re-match for the groups is wasteful, and map.compact is exactly right. The answers to the question should have tackled the non-trival example.<h4> Comment by rubyprince, Score: 1, Id: 92281868, created_at: 2018-10-06 06:36:54+00:00 </h4>@Helsing Looking at it again, I think what he is saying is instead of using map and compact like this <code>[1, 2, 3].map { |i| i * 2 if i % 2 == 0 }.compact</code>,it is better to use select and map instead <code>[1, 2, 3].select { |i| i % 2 == 0 }.map { |i| i * 2 }</code> to make the intent clearer<h4> Comment by Askdesigners, Score: 1, Id: 122321191, created_at: 2021-09-16 11:43:06+00:00 </h4>There&#39;s a lot of simplistic self-righteousness in this answer. How about if the array construction that produces nils requires some computation to derive? Like, if we need to calculate values in each element and then choose to return a value or a nil?      Black and white answers are a code smell.<h4> Comment by the Tin Man, Score: 0, Id: 122357341, created_at: 2021-09-17 17:23:31+00:00 </h4>It&#39;s important to remember that as Ruby has matured, how we write the code has changed. The answer was from &#39;12.<h4> Comment by Ziggy, Score: 0, Id: 129585661, created_at: 2022-08-16 17:39:33+00:00 </h4>Many years later, I am think select then map is the right answer. When I review code from juniors at my company and I see them using reduce the way I&#39;ve suggested in my answer, I tell them to select first, then map. No need to &quot;re-implement&quot; select with reduce, I tell them.<h4> Comment by Jochem Schulenklopper, Score: 0, Id: 82345172, created_at: 2017-12-07 10:36:28+00:00 </h4>Besides the point, but in this answer <code>[1,2,3].select{ |i| i % 2 == 0 }</code> can even be improved into <code>[1,2,3].select(&amp;:even?)</code><h4> Comment by Noel, Score: 0, Id: 92273476, created_at: 2018-10-05 19:02:37+00:00 </h4>@rubyprince that&#39;s exactly what I&#39;m asking myself right now. I think it&#39;s just a mistake of the poster. You could easily remove map and the code behaves the same way at least as far as my knowledge of ruby, and the quick tests I did showed.<h4> Comment by David West, Score: 0, Id: 59686547, created_at: 2016-03-15 17:03:33+00:00 </h4>speaking to @Ziggy&#39;s suggestion, there is a page here demonstrating how to use <code>inject</code> or <code>reduce</code> <a href="http://www.potstuck.com/2011/07/25/map-if-in-ruby-and-an-introduction-to-rubys-inject/" rel="nofollow noreferrer">potstuck.com/2011/07/25/&hellip;</a><hr><h3>  Answer by Ziggy, Id: 28862332, Score: 109, created_at: 2015-03-04 18:40:42+00:00 </h3><p>Try using <code>reduce</code> or <code>inject</code>.</p>

<pre><code>[1, 2, 3].reduce([]) { |memo, i|
  if i % 2 == 0
    memo &lt;&lt; i
  end

  memo
}
</code></pre>

<p>I agree with the accepted answer that we shouldn't <code>map</code> and <code>compact</code>, but not for the same reasons.</p>

<p>I feel deep inside that <code>map</code> then <code>compact</code> is equivalent to <code>select</code> then <code>map</code>. Consider: <code>map</code> is a one-to-one function. If you are mapping from some set of values, and you <code>map</code>, then you <em>want</em> one value in the output set for each value in the input set. If you are having to <code>select</code> before-hand, then you probably don't want a <code>map</code> on the set. If you are having to <code>select</code> afterwards (or <code>compact</code>) then you probably don't want a <code>map</code> on the set. In either case you are iterating twice over the entire set, when a <code>reduce</code> only needs to go once.</p>

<p>Also, in English, you are trying to "reduce a set of integers into a set of even integers".</p>
<h4> Comment by chees, Score: 3, Id: 51107835, created_at: 2015-07-23 01:24:20+00:00 </h4>+1 the currently accepted answer doesn&#39;t allow you to use the results of operations you performed during the select phase<h4> Comment by sebisnow, Score: 1, Id: 88893555, created_at: 2018-06-20 12:18:09+00:00 </h4>iterating over enumerable datastructures twice if only on pass is needed like in the accepted answer seems wasteful. Thus reduce the number of passes by using reduce! Thanks @Ziggy<h4> Comment by Ziggy, Score: 0, Id: 88912121, created_at: 2018-06-20 21:34:29+00:00 </h4>That&#39;s true! But doing two passes over a collection of n elements is still O(n). Unless your collection is so big that it doesn&#39;t fit in your cache, doing two passes is probably fine (I just think this is more elegant, expressive, and less likely to lead to bugs in the future when, say, the loops fall out of sync). If you like doing things in one pass too, you might be interested in learning about transducers! <a href="https://github.com/cognitect-labs/transducers-ruby" rel="nofollow noreferrer">github.com/cognitect-labs/transducers-ruby</a><h4> Comment by vinibrsl, Score: 0, Id: 99132037, created_at: 2019-05-22 13:18:42+00:00 </h4>RuboCop, in some cases, triggers the Style/UseEachWithObject offense. +1 tho.<h4> Comment by Jesse Clark, Score: 0, Id: 111648177, created_at: 2020-07-28 15:28:27+00:00 </h4>+1 to this answer for avoiding unnecessary passes over the array. And +1 to @ViniciusBrasil&#39;s suggestion for <code>each_with_object</code> being a nifty way to simplify reduce/inject.<hr><h3> ✔️ Answer by SRack, Id: 57323856, Score: 88, created_at: 2019-08-02 09:42:37+00:00 </h3><p><strong>Ruby 2.7+</strong></p>
<p><em>There is now!</em></p>
<p>Ruby 2.7 is introducing <code>filter_map</code> for this exact purpose. It's idiomatic and performant, and I'd expect it to become the norm very soon.</p>
<p>For example:</p>
<pre><code>numbers = [1, 2, 5, 8, 10, 13]
enum.filter_map { |i| i * 2 if i.even? }
# =&gt; [4, 16, 20]
</code></pre>
<p>In your case, as the block evaluates to falsey, simply:</p>
<pre><code>items.filter_map { |x| transform(x) }
</code></pre>
<p>&quot;<a href="https://blog.saeloun.com/2019/05/25/ruby-2-7-enumerable-filter-map.html" rel="nofollow noreferrer">Ruby 2.7 adds Enumerable#filter_map</a>&quot; is a good read on the subject, with some performance benchmarks against some of the earlier approaches to this problem:</p>
<pre><code>N = 100_000
enum = 1.upto(1_000)
Benchmark.bmbm do |x|
  x.report(&quot;select + map&quot;)  { N.times { enum.select { |i| i.even? }.map{ |i| i + 1 } } }
  x.report(&quot;map + compact&quot;) { N.times { enum.map { |i| i + 1 if i.even? }.compact } }
  x.report(&quot;filter_map&quot;)    { N.times { enum.filter_map { |i| i + 1 if i.even? } } }
end

# Rehearsal -------------------------------------------------
# select + map    8.569651   0.051319   8.620970 (  8.632449)
# map + compact   7.392666   0.133964   7.526630 (  7.538013)
# filter_map      6.923772   0.022314   6.946086 (  6.956135)
# --------------------------------------- total: 23.093686sec
# 
#                     user     system      total        real
# select + map    8.550637   0.033190   8.583827 (  8.597627)
# map + compact   7.263667   0.131180   7.394847 (  7.405570)
# filter_map      6.761388   0.018223   6.779611 (  6.790559)
</code></pre>
<h4> Comment by Pete Hamilton, Score: 1, Id: 101334677, created_at: 2019-08-09 10:43:04+00:00 </h4>Nice! Thanks for the update :)  Once Ruby 2.7.0 is released, I think it probably makes sense to switch the accepted answer to this one. I&#39;m not sure what the etiquette is here though, whether you generally give the existing accepted response a chance to update? I&#39;d argue this is the first answer referencing the new approach in 2.7, so should become the accepted one.  @the-tin-man do you agree with this take?<h4> Comment by SRack, Score: 0, Id: 101342988, created_at: 2019-08-09 14:47:48+00:00 </h4>Thanks @PeterHamilton - appreciate the feedback, and hope it will prove useful to plenty of people. I&#39;m happy to go with your decision, though obviously I like the argument you&#39;ve made :)<h4> Comment by the Tin Man, Score: 0, Id: 104268316, created_at: 2019-11-23 17:15:18+00:00 </h4>Yes, that&#39;s the nice thing about languages that have core teams who listen.<h4> Comment by the Tin Man, Score: 0, Id: 104892984, created_at: 2019-12-15 22:12:16+00:00 </h4>It&#39;s a nice gesture to recommend selected answers be changed, but it rarely happens. SO doesn&#39;t provide a tickler to remind people and people don&#39;t usually revisit old questions they&#39;ve asked unless SO says there&#39;s been activity. As a sidebar, I recommend looking at <a href="https://github.com/marcandre/fruity" rel="nofollow noreferrer">Fruity</a> for benchmarks because it&#39;s a lot less fiddly and makes it easier to make sensible tests.<hr><h3>  Answer by Evgeniya Manolova, Id: 20128010, Score: 42, created_at: 2013-11-21 17:35:20+00:00 </h3><p>Definitely <code>compact</code> is the best approach for solving this task. However, we can achieve the same result just with a simple subtraction:</p>

<pre><code>[1, nil, 3, nil, nil] - [nil]
 =&gt; [1, 3]
</code></pre>
<h4> Comment by the Tin Man, Score: 6, Id: 31869649, created_at: 2014-01-16 18:44:30+00:00 </h4>Yes, set subtraction will work, but it&#39;s about half as fast due to its overhead.<hr><h3>  Answer by sawa, Id: 13487378, Score: 34, created_at: 2012-11-21 06:08:27+00:00 </h3><p>In your example:</p>
<pre><code>items.map! { |x| transform(x) } # [1, 2, 3, 4, 5] =&gt; [1, nil, 3, nil, nil]
</code></pre>
<p>it does not look like the values have changed other than being replaced with <code>nil</code>. If that is the case, then:</p>
<pre><code>items.select{|x| transform(x) }
</code></pre>
<p>will suffice.</p>
<hr><h3>  Answer by Fred Willmore, Id: 25252635, Score: 31, created_at: 2014-08-11 21:22:01+00:00 </h3><p>If you wanted a looser criterion for rejection, for example, to reject empty strings as well as nil, you could use:</p>

<pre><code>[1, nil, 3, 0, ''].reject(&amp;:blank?)
 =&gt; [1, 3, 0] 
</code></pre>

<p>If you wanted to go further and reject zero values (or apply more complex logic to the process), you could pass a block to reject:</p>

<pre><code>[1, nil, 3, 0, ''].reject do |value| value.blank? || value==0 end
 =&gt; [1, 3]

[1, nil, 3, 0, '', 1000].reject do |value| value.blank? || value==0 || value&gt;10 end
 =&gt; [1, 3]
</code></pre>
<h4> Comment by ewalk, Score: 5, Id: 40579149, created_at: 2014-09-18 21:23:08+00:00 </h4>.blank? is only available in rails.<h4> Comment by Cadoiz, Score: 0, Id: 135231011, created_at: 2023-07-17 11:59:57+00:00 </h4>@fotis you&#39;re not wrong, but you miss, that <code>.blank?</code> will reject more then <code>.nil?</code> here, including <code>[]</code> or <code>&quot;&quot;</code>.<h4> Comment by Fotis, Score: 0, Id: 78047253, created_at: 2017-08-07 09:40:10+00:00 </h4>For future reference, since <code>blank?</code> is only available in rails, we could use <code>items.reject!(&amp;:nil?) # [1, nil, 3, nil, nil] =&gt; [1, 3]</code> which is not coupled to rails. (wouldn&#39;t exclude empty strings or 0s though)<hr><h3>  Answer by Abdullah Numan, Id: 68257020, Score: 9, created_at: 2021-07-05 13:28:49+00:00 </h3><p>You can use <code>#compact</code> method on the resulting array.</p>
<pre><code>[10, nil, 30, 40, nil].compact =&gt; [10, 30, 40]
</code></pre>
<h4> Comment by Cristik, Score: 1, Id: 120639654, created_at: 2021-07-05 17:29:55+00:00 </h4>This solution was already provided <a href="https://stackoverflow.com/a/13485482/1974224">here</a><hr><h3>  Answer by pnomolos, Id: 43884339, Score: 5, created_at: 2017-05-10 05:40:23+00:00 </h3><p><code>each_with_object</code> is probably the cleanest way to go here:</p>

<pre><code>new_items = items.each_with_object([]) do |x, memo|
    ret = process_x(x)
    memo &lt;&lt; ret unless ret.nil?
end
</code></pre>

<p>In my opinion, <code>each_with_object</code> is better than <code>inject</code>/<code>reduce</code> in conditional cases because you don't have to worry about the return value of the block.</p>
<h4> Comment by Cadoiz, Score: 0, Id: 135231935, created_at: 2023-07-17 13:05:26+00:00 </h4>RuboCop even tells me: &quot;Use <code>each_with_object</code> instead of <code>inject</code>. [Style/EachWithObject]&quot;<hr><h3>  Answer by Wand Maker, Id: 34537795, Score: 0, created_at: 2015-12-30 21:50:46+00:00 </h3><p>One more way to accomplish it will be as shown below. Here, we use <a href="http://ruby-doc.org/core-2.2.3/Enumerable.html#method-i-each_with_object" rel="nofollow noreferrer"><code>Enumerable#each_with_object</code></a> to collect values, and make use of <a href="http://ruby-doc.org/core-2.2.3/Object.html#method-i-tap" rel="nofollow noreferrer"><code>Object#tap</code></a> to get rid of temporary variable that is otherwise needed for <code>nil</code> check on result of <code>transform x</code> method.</p>
<pre><code>items.each_with_object([]) {|x, obj| (transform x).tap {|r| obj &lt;&lt; r unless r.nil?}}
</code></pre>
<hr />
<p>Complete example for illustration:</p>
<pre><code>items = [1,2,3,4,5]
def transform x
    rand(10) &gt; 5 ? nil : x
end

items.each_with_object([]) {|x, obj| (transform x).tap {|r| obj &lt;&lt; r unless r.nil?}}
</code></pre>
<hr />
<p><strong>Alternate approach:</strong></p>
<p>By looking at the method you are calling <code>transform x</code>, it is not clear what is the purpose of input <code>x</code> in that method.  If I assume that you are going to process the value of <code>x</code> by passing it some <code>url</code> and determine which of the <code>x</code>s really get processed into valid non-nil results - then, may be <a href="http://ruby-doc.org/core-2.2.3/Enumerable.html#method-i-group_by" rel="nofollow noreferrer"><code>Enumerabble.group_by</code></a> is a better option than <code>Enumerable#map</code>.</p>
<pre><code>h = items.group_by {|x| (transform x).nil? ? &quot;Bad&quot; : &quot;Good&quot;}
#=&gt; {&quot;Bad&quot;=&gt;[1, 2], &quot;Good&quot;=&gt;[3, 4, 5]}

h[&quot;Good&quot;]
#=&gt; [3,4,5]
</code></pre>
