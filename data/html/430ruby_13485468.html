 <h2> Title: How to map and remove nil values in Ruby </h2> <h4> Pete Hamilton, question_id: 13485468 </h4>Score: 430, Tags: {ruby} <br><p>I have a <code>map</code> which either changes a value or sets it to nil. I then want to remove the nil entries from the list. The list doesn't need to be kept.</p>

<p>This is what I currently have:</p>

<pre class="lang-rb prettyprint-override"><code># A simple example function, which returns a value or nil
def transform(n)
  rand &gt; 0.5 ? n * 10 : nil }
end

items.map! { |x| transform(x) } # [1, 2, 3, 4, 5] =&gt; [10, nil, 30, 40, nil]
items.reject! { |x| x.nil? } # [10, nil, 30, 40, nil] =&gt; [10, 30, 40]
</code></pre>

<p>I'm aware I could just do a loop and conditionally collect in another array like this:</p>

<pre class="lang-rb prettyprint-override"><code>new_items = []
items.each do |x|
    x = transform(x)
    new_items.append(x) unless x.nil?
end
items = new_items
</code></pre>

<p>But it doesn't seem that idiomatic. Is there a nice way to map a function over a list, removing/excluding the nils as you go?</p>
<h4> SRack, Id: 101138067 Score: 10: </h4>Ruby 2.7 introduces <code>filter_map</code>, which seems to be perfect for this. Saves the need to re-process the array, instead getting it as desired first time through. <a href="https://stackoverflow.com/questions/13485468/map-and-remove-nil-values-in-ruby/57323856#answer-57323856">More info here.</a><br>------------------------------------------------------------------ <br><h3> the Tin Man, Id: 13485482, Score: 1094: </h3><p>You could use <a href="https://ruby-doc.org/core-1.9.3/Array.html#method-i-compact" rel="noreferrer"><code>compact</code></a>:</p>

<pre><code>[1, nil, 3, nil, nil].compact
=&gt; [1, 3] 
</code></pre>

<hr>

<p>I'd like to remind people that if you're getting an array containing nils as the output of a <code>map</code> block, and that block tries to conditionally return values, then you've got code smell and need to rethink your logic. </p>

<p>For instance, if you're doing something that does this:</p>

<pre><code>[1,2,3].map{ |i|
  if i % 2 == 0
    i
  end
}
# =&gt; [nil, 2, nil]
</code></pre>

<p>Then don't. Instead, prior to the <code>map</code>, <code>reject</code> the stuff you don't want or <code>select</code> what you do want:</p>

<pre><code>[1,2,3].select{ |i| i % 2 == 0 }.map{ |i|
  i
}
# =&gt; [2]
</code></pre>

<p>I consider using <code>compact</code> to clean up a mess as a last-ditch effort to get rid of things we didn't handle correctly, usually because we didn't know what was coming at us. We should always know what sort of data is being thrown around in our program; Unexpected/unknown data is bad. Anytime I see nils in an array I'm working on, I dig into why they exist, and see if I can improve the code generating the array, rather than allow Ruby to waste time and memory generating nils then sifting through the array to remove them later. </p>

<pre><code>'Just my $%0.2f.' % [2.to_f/100]
</code></pre>
<h4> Ziggy, Comment 45989593 Score: 11: </h4>Both solutions iterate twice over the collection... why not use <code>reduce</code> or <code>inject</code>?<br><h4> the Tin Man, Comment 39461500 Score: 5: </h4>Why should it? The OP needs to strip <code>nil</code> entries, not empty strings. BTW, <code>nil</code> isn&#39;t the same as an empty-string.<br><h4> the Tin Man, Comment 45995637 Score: 5: </h4>It doesn&#39;t sound like you read the OPs question or the answer. The question is, how to remove nils from an array. <code>compact</code> is fastest but actually writing the code correctly in the start removes the need to deal with nils completely.<br><h4> Ziggy, Comment 52068235 Score: 4: </h4>I disagree! The question is &quot;Map and remove nil values&quot;. Well, to map and remove nil values is to reduce. In their example, the OP maps and then select out the nils. Calling map and then compact, or select and then map, amounts to making the same mistake: as you point out in your answer, it is a code smell.<br><h4> rubyprince, Comment 82738372 Score: 2: </h4>@theTinMan why does the solution with <code>select</code> need another <code>map</code>? <code>[1,2,3].select{ |i| i % 2 == 0 }</code> is enough to return <code>[2]</code>, right? The map part doesnt make sense as it returns the element itself <code>map { |x| x }</code> which equivalent to the input array.<br><h4> Anton, Comment 55020996 Score: 2: </h4>Answer from @Ziggy should be accepted as a correct answer<br><h4> FloatingRock, Comment 39437566 Score: 1: </h4>Note: Doesn&#39;t filter out <code>&quot;&quot;</code><br><h4> android.weasel, Comment 78655452 Score: 1: </h4>The example is too simple: if the map were a match against a regex with capture groups, then running the select simply to choose the strings that matched, and then running the map to re-match for the groups is wasteful, and map.compact is exactly right. The answers to the question should have tackled the non-trival example.<br><h4> rubyprince, Comment 92281868 Score: 1: </h4>@Helsing Looking at it again, I think what he is saying is instead of using map and compact like this <code>[1, 2, 3].map { |i| i * 2 if i % 2 == 0 }.compact</code>,it is better to use select and map instead <code>[1, 2, 3].select { |i| i % 2 == 0 }.map { |i| i * 2 }</code> to make the intent clearer<br><h4> Askdesigners, Comment 122321191 Score: 1: </h4>There&#39;s a lot of simplistic self-righteousness in this answer. How about if the array construction that produces nils requires some computation to derive? Like, if we need to calculate values in each element and then choose to return a value or a nil?      Black and white answers are a code smell.<br><h4> the Tin Man, Comment 122357341 Score: 0: </h4>It&#39;s important to remember that as Ruby has matured, how we write the code has changed. The answer was from &#39;12.<br><h4> Ziggy, Comment 129585661 Score: 0: </h4>Many years later, I am think select then map is the right answer. When I review code from juniors at my company and I see them using reduce the way I&#39;ve suggested in my answer, I tell them to select first, then map. No need to &quot;re-implement&quot; select with reduce, I tell them.<br><h4> Noel, Comment 92273476 Score: 0: </h4>@rubyprince that&#39;s exactly what I&#39;m asking myself right now. I think it&#39;s just a mistake of the poster. You could easily remove map and the code behaves the same way at least as far as my knowledge of ruby, and the quick tests I did showed.<br><h4> Jochem Schulenklopper, Comment 82345172 Score: 0: </h4>Besides the point, but in this answer <code>[1,2,3].select{ |i| i % 2 == 0 }</code> can even be improved into <code>[1,2,3].select(&amp;:even?)</code><br><h4> David West, Comment 59686547 Score: 0: </h4>speaking to @Ziggy&#39;s suggestion, there is a page here demonstrating how to use <code>inject</code> or <code>reduce</code> <a href="http://www.potstuck.com/2011/07/25/map-if-in-ruby-and-an-introduction-to-rubys-inject/" rel="nofollow noreferrer">potstuck.com/2011/07/25/&hellip;</a><br>------------------------------------------------------------------ <br><h3> Ziggy, Id: 28862332, Score: 109: </h3><p>Try using <code>reduce</code> or <code>inject</code>.</p>

<pre><code>[1, 2, 3].reduce([]) { |memo, i|
  if i % 2 == 0
    memo &lt;&lt; i
  end

  memo
}
</code></pre>

<p>I agree with the accepted answer that we shouldn't <code>map</code> and <code>compact</code>, but not for the same reasons.</p>

<p>I feel deep inside that <code>map</code> then <code>compact</code> is equivalent to <code>select</code> then <code>map</code>. Consider: <code>map</code> is a one-to-one function. If you are mapping from some set of values, and you <code>map</code>, then you <em>want</em> one value in the output set for each value in the input set. If you are having to <code>select</code> before-hand, then you probably don't want a <code>map</code> on the set. If you are having to <code>select</code> afterwards (or <code>compact</code>) then you probably don't want a <code>map</code> on the set. In either case you are iterating twice over the entire set, when a <code>reduce</code> only needs to go once.</p>

<p>Also, in English, you are trying to "reduce a set of integers into a set of even integers".</p>
<h4> chees, Comment 51107835 Score: 3: </h4>+1 the currently accepted answer doesn&#39;t allow you to use the results of operations you performed during the select phase<br><h4> sebisnow, Comment 88893555 Score: 1: </h4>iterating over enumerable datastructures twice if only on pass is needed like in the accepted answer seems wasteful. Thus reduce the number of passes by using reduce! Thanks @Ziggy<br><h4> Ziggy, Comment 88912121 Score: 0: </h4>That&#39;s true! But doing two passes over a collection of n elements is still O(n). Unless your collection is so big that it doesn&#39;t fit in your cache, doing two passes is probably fine (I just think this is more elegant, expressive, and less likely to lead to bugs in the future when, say, the loops fall out of sync). If you like doing things in one pass too, you might be interested in learning about transducers! <a href="https://github.com/cognitect-labs/transducers-ruby" rel="nofollow noreferrer">github.com/cognitect-labs/transducers-ruby</a><br><h4> vinibrsl, Comment 99132037 Score: 0: </h4>RuboCop, in some cases, triggers the Style/UseEachWithObject offense. +1 tho.<br><h4> Jesse Clark, Comment 111648177 Score: 0: </h4>+1 to this answer for avoiding unnecessary passes over the array. And +1 to @ViniciusBrasil&#39;s suggestion for <code>each_with_object</code> being a nifty way to simplify reduce/inject.<br>------------------------------------------------------------------ <br><h3> SRack, Id: 57323856, Score: 88: </h3><p><strong>Ruby 2.7+</strong></p>
<p><em>There is now!</em></p>
<p>Ruby 2.7 is introducing <code>filter_map</code> for this exact purpose. It's idiomatic and performant, and I'd expect it to become the norm very soon.</p>
<p>For example:</p>
<pre><code>numbers = [1, 2, 5, 8, 10, 13]
enum.filter_map { |i| i * 2 if i.even? }
# =&gt; [4, 16, 20]
</code></pre>
<p>In your case, as the block evaluates to falsey, simply:</p>
<pre><code>items.filter_map { |x| transform(x) }
</code></pre>
<p>&quot;<a href="https://blog.saeloun.com/2019/05/25/ruby-2-7-enumerable-filter-map.html" rel="nofollow noreferrer">Ruby 2.7 adds Enumerable#filter_map</a>&quot; is a good read on the subject, with some performance benchmarks against some of the earlier approaches to this problem:</p>
<pre><code>N = 100_000
enum = 1.upto(1_000)
Benchmark.bmbm do |x|
  x.report(&quot;select + map&quot;)  { N.times { enum.select { |i| i.even? }.map{ |i| i + 1 } } }
  x.report(&quot;map + compact&quot;) { N.times { enum.map { |i| i + 1 if i.even? }.compact } }
  x.report(&quot;filter_map&quot;)    { N.times { enum.filter_map { |i| i + 1 if i.even? } } }
end

# Rehearsal -------------------------------------------------
# select + map    8.569651   0.051319   8.620970 (  8.632449)
# map + compact   7.392666   0.133964   7.526630 (  7.538013)
# filter_map      6.923772   0.022314   6.946086 (  6.956135)
# --------------------------------------- total: 23.093686sec
# 
#                     user     system      total        real
# select + map    8.550637   0.033190   8.583827 (  8.597627)
# map + compact   7.263667   0.131180   7.394847 (  7.405570)
# filter_map      6.761388   0.018223   6.779611 (  6.790559)
</code></pre>
<h4> Pete Hamilton, Comment 101334677 Score: 1: </h4>Nice! Thanks for the update :)  Once Ruby 2.7.0 is released, I think it probably makes sense to switch the accepted answer to this one. I&#39;m not sure what the etiquette is here though, whether you generally give the existing accepted response a chance to update? I&#39;d argue this is the first answer referencing the new approach in 2.7, so should become the accepted one.  @the-tin-man do you agree with this take?<br><h4> SRack, Comment 101342988 Score: 0: </h4>Thanks @PeterHamilton - appreciate the feedback, and hope it will prove useful to plenty of people. I&#39;m happy to go with your decision, though obviously I like the argument you&#39;ve made :)<br><h4> the Tin Man, Comment 104268316 Score: 0: </h4>Yes, that&#39;s the nice thing about languages that have core teams who listen.<br><h4> the Tin Man, Comment 104892984 Score: 0: </h4>It&#39;s a nice gesture to recommend selected answers be changed, but it rarely happens. SO doesn&#39;t provide a tickler to remind people and people don&#39;t usually revisit old questions they&#39;ve asked unless SO says there&#39;s been activity. As a sidebar, I recommend looking at <a href="https://github.com/marcandre/fruity" rel="nofollow noreferrer">Fruity</a> for benchmarks because it&#39;s a lot less fiddly and makes it easier to make sensible tests.<br>------------------------------------------------------------------ <br><h3> Evgeniya Manolova, Id: 20128010, Score: 42: </h3><p>Definitely <code>compact</code> is the best approach for solving this task. However, we can achieve the same result just with a simple subtraction:</p>

<pre><code>[1, nil, 3, nil, nil] - [nil]
 =&gt; [1, 3]
</code></pre>
<h4> the Tin Man, Comment 31869649 Score: 6: </h4>Yes, set subtraction will work, but it&#39;s about half as fast due to its overhead.<br>------------------------------------------------------------------ <br><h3> sawa, Id: 13487378, Score: 34: </h3><p>In your example:</p>
<pre><code>items.map! { |x| transform(x) } # [1, 2, 3, 4, 5] =&gt; [1, nil, 3, nil, nil]
</code></pre>
<p>it does not look like the values have changed other than being replaced with <code>nil</code>. If that is the case, then:</p>
<pre><code>items.select{|x| transform(x) }
</code></pre>
<p>will suffice.</p>
------------------------------------------------------------------ <br><h3> Fred Willmore, Id: 25252635, Score: 31: </h3><p>If you wanted a looser criterion for rejection, for example, to reject empty strings as well as nil, you could use:</p>

<pre><code>[1, nil, 3, 0, ''].reject(&amp;:blank?)
 =&gt; [1, 3, 0] 
</code></pre>

<p>If you wanted to go further and reject zero values (or apply more complex logic to the process), you could pass a block to reject:</p>

<pre><code>[1, nil, 3, 0, ''].reject do |value| value.blank? || value==0 end
 =&gt; [1, 3]

[1, nil, 3, 0, '', 1000].reject do |value| value.blank? || value==0 || value&gt;10 end
 =&gt; [1, 3]
</code></pre>
<h4> ewalk, Comment 40579149 Score: 5: </h4>.blank? is only available in rails.<br><h4> Fotis, Comment 78047253 Score: 0: </h4>For future reference, since <code>blank?</code> is only available in rails, we could use <code>items.reject!(&amp;:nil?) # [1, nil, 3, nil, nil] =&gt; [1, 3]</code> which is not coupled to rails. (wouldn&#39;t exclude empty strings or 0s though)<br><h4> Cadoiz, Comment 135231011 Score: 0: </h4>@fotis you&#39;re not wrong, but you miss, that <code>.blank?</code> will reject more then <code>.nil?</code> here, including <code>[]</code> or <code>&quot;&quot;</code>.<br>------------------------------------------------------------------ <br><h3> Abdullah Numan, Id: 68257020, Score: 9: </h3><p>You can use <code>#compact</code> method on the resulting array.</p>
<pre><code>[10, nil, 30, 40, nil].compact =&gt; [10, 30, 40]
</code></pre>
<h4> Cristik, Comment 120639654 Score: 1: </h4>This solution was already provided <a href="https://stackoverflow.com/a/13485482/1974224">here</a><br>------------------------------------------------------------------ <br><h3> pnomolos, Id: 43884339, Score: 5: </h3><p><code>each_with_object</code> is probably the cleanest way to go here:</p>

<pre><code>new_items = items.each_with_object([]) do |x, memo|
    ret = process_x(x)
    memo &lt;&lt; ret unless ret.nil?
end
</code></pre>

<p>In my opinion, <code>each_with_object</code> is better than <code>inject</code>/<code>reduce</code> in conditional cases because you don't have to worry about the return value of the block.</p>
<h4> Cadoiz, Comment 135231935 Score: 0: </h4>RuboCop even tells me: &quot;Use <code>each_with_object</code> instead of <code>inject</code>. [Style/EachWithObject]&quot;<br>------------------------------------------------------------------ <br><h3> Wand Maker, Id: 34537795, Score: 0: </h3><p>One more way to accomplish it will be as shown below. Here, we use <a href="http://ruby-doc.org/core-2.2.3/Enumerable.html#method-i-each_with_object" rel="nofollow noreferrer"><code>Enumerable#each_with_object</code></a> to collect values, and make use of <a href="http://ruby-doc.org/core-2.2.3/Object.html#method-i-tap" rel="nofollow noreferrer"><code>Object#tap</code></a> to get rid of temporary variable that is otherwise needed for <code>nil</code> check on result of <code>transform x</code> method.</p>
<pre><code>items.each_with_object([]) {|x, obj| (transform x).tap {|r| obj &lt;&lt; r unless r.nil?}}
</code></pre>
<hr />
<p>Complete example for illustration:</p>
<pre><code>items = [1,2,3,4,5]
def transform x
    rand(10) &gt; 5 ? nil : x
end

items.each_with_object([]) {|x, obj| (transform x).tap {|r| obj &lt;&lt; r unless r.nil?}}
</code></pre>
<hr />
<p><strong>Alternate approach:</strong></p>
<p>By looking at the method you are calling <code>transform x</code>, it is not clear what is the purpose of input <code>x</code> in that method.  If I assume that you are going to process the value of <code>x</code> by passing it some <code>url</code> and determine which of the <code>x</code>s really get processed into valid non-nil results - then, may be <a href="http://ruby-doc.org/core-2.2.3/Enumerable.html#method-i-group_by" rel="nofollow noreferrer"><code>Enumerabble.group_by</code></a> is a better option than <code>Enumerable#map</code>.</p>
<pre><code>h = items.group_by {|x| (transform x).nil? ? &quot;Bad&quot; : &quot;Good&quot;}
#=&gt; {&quot;Bad&quot;=&gt;[1, 2], &quot;Good&quot;=&gt;[3, 4, 5]}

h[&quot;Good&quot;]
#=&gt; [3,4,5]
</code></pre>
