 <h2> Title: Automatically get loop index in foreach loop in Perl </h2> <h3> Nathan Fellman, question_id: 974656 </h3>Score: 79, Tags: {perl,foreach} <br><p>If I have the following array in Perl:</p>

<pre><code>@x = qw(a b c);
</code></pre>

<p>and I iterate over it with <code>foreach</code>, then <code>$_</code> will refer to the current <em>element</em> in the array:</p>

<pre><code>foreach (@x) {
    print;
}
</code></pre>

<p>will print:</p>

<pre><code>abc
</code></pre>

<p>Is there a similar way to get the <em>index</em> of the current element, without manually updating a counter? Something such as:</p>

<pre><code>foreach (@x) {
    print $index;
}
</code></pre>

<p>where <code>$index</code> is updated like <code>$_</code> to yield the output:</p>

<pre><code>012
</code></pre>
------------------------------------------------------------------ <br><h3> Answer 974819 trendels: </h3><p>Like <a href="https://stackoverflow.com/questions/974656/automatically-get-loop-index-in-foreach-loop-in-perl/974679#974679">codehead said</a>, you'd have to iterate over the array indices instead of its elements. I prefer this variant over the C-style <code>for</code> loop:</p>

<pre class="lang-perl prettyprint-override"><code>for my $i (0 .. $#x) {
    print "$i: $x[$i]\n";
}
</code></pre>
<h4> Comment 17069341 Andy N: </h4>This is not what you want if array index sequence is 2, 5, 8, 19 with gaps in sequence. I believe the question was something regarding index of current element.<br><h4> Comment 108652933 Arnold Cross: </h4>The only way to generalize for an array with gaps is to put the line, <code>next unless defined $x[$i];</code> at the start of the loop.  This seems to be true also for all the more risky solutions involving while/each and for/keys.  Apparently the array iterator sees each sequential index whether it exists or not.<br><h4> Comment 108674416 Arnold Cross: </h4>I just thought of a better way to write that line: <code>$x[$i] &#47;&#47; next;</code><br><h4> Comment 131717419 Han.Oliver: </h4>$# syntax is not supported perl 5.30..<br>------------------------------------------------------------------ <br><h3> Answer 975926 Chas. Owens: </h3><p>In Perl prior to 5.10, you can say</p>
<pre><code>#!/usr/bin/perl

use strict;
use warnings;

my @a = qw/a b c d e/;

my $index;
for my $elem (@a) {
    print &quot;At index &quot;, $index++, &quot;, I saw $elem\n&quot;;
}

#or

for my $index (0 .. $#a) {
    print &quot;At index $index I saw $a[$index]\n&quot;;
}
</code></pre>
<p>In Perl 5.10, you use <a href="http://perldoc.perl.org/functions/state.html" rel="nofollow noreferrer">state</a> to declare a variable that never gets reinitialized (unlike ones created with <a href="http://perldoc.perl.org/functions/my.html" rel="nofollow noreferrer">my</a>). This lets you keep the <code>$index</code> variable in a smaller scope, but it can lead to bugs (if you enter the loop a second time it will still have the last value):</p>
<pre><code>#!/usr/bin/perl

use 5.010;
use strict;
use warnings;

my @a = qw/a b c d e/;

for my $elem (@a) {
    state $index;
    say &quot;At index &quot;, $index++, &quot;, I saw $elem&quot;;
}
</code></pre>
<p>In Perl 5.12 you can say</p>
<pre><code>#!/usr/bin/perl

use 5.012; # This enables strict
use warnings;

my @a = qw/a b c d e/;

while (my ($index, $elem) = each @a) {
    say &quot;At index $index I saw $elem&quot;;
}
</code></pre>
<p>But be warned: you there are <a href="http://perldoc.perl.org/functions/each.html" rel="nofollow noreferrer">restrictions</a> to what you are allowed to do with <code>@a</code> while iterating over it with <code>each</code>.</p>
<p>It won't help you now, but in Perl 6 you will be able to say</p>
<pre><code>#!/usr/bin/perl6

my @a = &lt;a b c d e&gt;;
for @a Z 0 .. Inf -&gt; $elem, $index {
    say &quot;at index $index, I saw $elem&quot;
}
</code></pre>
<p>The <code>Z</code> operator zips the two lists together (i.e. it takes one element from the first list, then one element from the second, then one element from the first, and so on).  The second list is a <a href="http://en.wikipedia.org/wiki/Lazy_evaluation" rel="nofollow noreferrer">lazy</a> list that contains every integer from 0 to infinity (at least theoretically).  The <code>-&gt; $elem, $index</code> says that we are taking two values at a time from the result of the zip.  The rest should look normal to you (unless you are not familiar with the <a href="http://perldoc.perl.org/functions/say.html" rel="nofollow noreferrer"><code>say</code></a> function from 5.10 yet).</p>
<h4> Comment 129171121 Kai Carver: </h4>I liked this solution: <code>while (my ($i, $elem) = each @a)</code><br><h4> Comment 3350243 Brad Gilbert: </h4>I don&#39;t like the section on <code>state</code>, I think it would be better served with <code>{ my $index; ... }</code>.<br>------------------------------------------------------------------ <br><h3> Answer 974670 Alan Haggai Alavi: </h3><p><code>perldoc perlvar</code> does not seem to suggest any such variable.</p>
<h4> Comment 12741376 Alan Haggai Alavi: </h4><a href="http://stackoverflow.com/users/444794/andrewks"><i>AndrewKS</i></a>: This certainly is <i>not</i> against the spirit of StackOverflow. If you had tried <code>perldoc perlvar</code>, you would know why. Only variables listed in <code>perldoc perlvar</code> exist. Such a variable, as I already stated, does not exist.<br><h4> Comment 54167561 SgtPooki: </h4>This <i>is</i> against the spirit of stackoverflow, because the spirit is to provide an answer that can answer a question in it&#39;s entirety, without external resources. Providing optional resources such as links or terminal commands to run for learning is a bonus, but not the <i>spirit</i>. The fact that you had to provide further information in a comment is proof that this answer is not enough on it&#39;s own.<br><h4> Comment 103127214 jinawee: </h4>This is basically the same as a link-only answer.<br><h4> Comment 104168275 Peter Mortensen: </h4>Perhaps expand your answer?<br>------------------------------------------------------------------ <br><h3> Answer 23821330 Venkata Raju: </h3><p>It can be done with a <code>while</code> loop (<code>foreach</code> doesn't support this):</p>

<pre><code>my @arr = (1111, 2222, 3333);

while (my ($index, $element) = each(@arr))
{
   # You may need to "use feature 'say';"
   say "Index: $index, Element: $element";
}
</code></pre>

<p>Output:</p>

<pre><code>Index: 0, Element: 1111
Index: 1, Element: 2222
Index: 2, Element: 3333
</code></pre>

<p>Perl version: 5.14.4</p>
<h4> Comment 100626772 Able Mac: </h4>Perldoc says not to use While-Each --- It&#39;s easy enough to explicitly reset the iterator before starting a loop, but there is no way to insulate the iterator state used by a loop from the iterator state used by anything else that might execute during the loop body. To avoid these problems, use a foreach loop rather than while-each.--- <a href="https://perldoc.perl.org/functions/each.html" rel="nofollow noreferrer">perldoc.perl.org/functions/each.html</a><br>------------------------------------------------------------------ <br><h3> Answer 974679 codehead: </h3><p>Not with <code>foreach</code>.</p>

<p>If you definitely need the element cardinality in the array, use a 'for' iterator:</p>

<pre><code>for ($i=0; $i&lt;@x; ++$i) {
  print "Element at index $i is " , $x[$i] , "\n";
}
</code></pre>
<h4> Comment 784156 user55400: </h4>Quoting from &#39;perldoc perlvar&#39;: The &quot;foreach&quot; keyword is actually a synonym for the &quot;for&quot; keyword, so you can use &quot;foreach&quot; for readability or &quot;for&quot; for brevity. endquote. So they <i>are</i> interchangeable. Try it.<br><h4> Comment 783732 ysth: </h4>foreach and for are interchangeable synonyms.  Some introductory material tries to use for to mean the C-style loop and foreach for the list iterator loop, but that use of terminology isn&#39;t going to be familiar to everyone.<br><h4> Comment 787636 ysth: </h4>a C-style for loop (that y&#39;all keep calling a &quot;for loop&quot;) doesn&#39;t have to increment/decrement a variable, e.g.: for (my $iter = new_iter(); $iter; $iter = $iter-&gt;next() ) { ... }<br><h4> Comment 784098 Matthew Flaschen: </h4>foreach and for are /not/ interchangeable, as this instance shows.<br><h4> Comment 784184 Andrew Barnett: </h4>The keywords are interchangeable -- but the loops themselves have different meanings. A &quot;for&quot; loop is a loop with an incrementing (or decrementing) variable, even if it&#39;s introduced with the foreach keyword. A &quot;foreach&quot; loop has an internal iterator, even if it&#39;s introduced with the for keyword. The OP wanted access to the iterator, so he wants a &quot;for&quot; loop, regardless of the keyword used.<br><h4> Comment 784144 Chas. Owens: </h4>@Matthew Flaschen It is more correct to say that you can replace the keyword foreach with the keyword for, but not necessarily the other way around.<br>------------------------------------------------------------------ <br><h3> Answer 974944 Hynek -Pichi- Vychodil: </h3><p>No, you must make your own counter. Yet another example:</p>

<pre><code>my $index;
foreach (@x) {
    print $index++;
}
</code></pre>

<p>when used for indexing</p>

<pre><code>my $index;
foreach (@x) {
    print $x[$index]+$y[$index];
    $index++;
}
</code></pre>

<p>And of course you can use <code>local $index;</code> instead <code>my $index;</code> and so and so.</p>
<h4> Comment 783605 ysth: </h4>0+ is unneedded; postincrement returns 0 if the variable incremented was undef.<br><h4> Comment 784786 Hynek -Pichi- Vychodil: </h4>@ysth: You can be surprised when someone somewhere in application use same global $index variable as you. But if you write short script and you assume ... no, don&#39;t do it.<br><h4> Comment 100626868 Able Mac: </h4>This answer is arguably more readable than the <code>for</code> loop syntax of <code>for(my $index; $index &lt;= $#x; $index++){}</code>.<br>------------------------------------------------------------------ <br><h3> Answer 3236234 draegtun: </h3><p><a href="http://search.cpan.org/perldoc/autobox::Core" rel="nofollow noreferrer"><code>autobox::Core</code></a> provides, among many more things, a handy <code>for</code> method:</p>
<pre><code>use autobox::Core;

['a'..'z']-&gt;for( sub{
    my ($index, $value) = @_;
    say &quot;$index =&gt; $value&quot;;
});
</code></pre>
<p>Alternatively, have a look at an iterator module, for example: <a href="http://search.cpan.org/perldoc/Array::Iterator" rel="nofollow noreferrer"><code>Array::Iterator</code></a></p>
<pre><code>use Array::Iterator;

my $iter = Array::Iterator-&gt;new( ['a'..'z'] );
while ($iter-&gt;hasNext) {
    $iter-&gt;getNext;
    say $iter-&gt;currentIndex . ' =&gt; ' . $iter-&gt;current;
}
</code></pre>
<p>Also see:</p>
<ul>
<li><a href="http://transfixedbutnotdead.com/2010/06/16/each-to-their-own-autobox/" rel="nofollow noreferrer">each to their own (autobox)</a></li>
<li><a href="http://search.cpan.org/perldoc/perl5i" rel="nofollow noreferrer"><code>perl5i</code></a></li>
</ul>
<h4> Comment 3350250 Brad Gilbert: </h4>I would replace the links to the distributions with a link of the form: <a href="http://search.cpan.org/perldoc/Array::Iterator" rel="nofollow noreferrer">search.cpan.org/perldoc/Array::Iterator</a><br><h4> Comment 3351280 draegtun: </h4>@Brad Gilbert:  Changed.  Though personally I prefer the top level (home) view presented by <a href="http://search.cpan.org/dist/Array-Iterator" rel="nofollow noreferrer">search.cpan.org/dist/Array-Iterator</a><br><h4> Comment 3358372 Brad Gilbert: </h4>I would agree that it is sometimes useful to point to the Dist view instead of the perldoc view. Also just because I <i>would</i> replace the links, doesn&#39;t necessarily mean that you <i>should</i>.<br><h4> Comment 3362899 draegtun: </h4>@Brad Gilbert: This is a good example of TIMTOWTDI in perl perhaps? :)  Anyway its no problem and if the <i>perldoc</i> link is becoming more prevalent on SO then I&#39;m happy to switch to using it.<br>------------------------------------------------------------------ <br><h3> Answer 14372892 surendra ben: </h3><p>Yes. I have checked so many books and other blogs... The conclusion is, there isn't any system variable for the loop counter. We have to make our own counter. Correct me if I'm wrong.</p>
<h4> Comment 100626877 Able Mac: </h4>You are right, there is no accessible system counter. --- And &quot;make our own counter&quot; can be done many ways; the most common is probably the <code>for</code> (aka <code>foreach</code>) with the optional long syntax of <code>for($i=0;$i&lt;=$#array;$i++){}</code>.<br>------------------------------------------------------------------ <br><h3> Answer 57050445 Able Mac: </h3><p>Oh yes, you can! (sort of, but you shouldn't). <code>each(@array)</code> in a scalar context gives you the current index of the array.</p>

<pre><code>@a = (a..z);
for (@a) { 
  print each(@a) . "\t" . $_ . "\n"; 
}
</code></pre>

<p>Here <code>each(@a)</code> is in a scalar context and returns only the index, not the value at that index. Since we're in a <code>for</code> loop, we have the value in $_ already. The same mechanism is often used in a while-each loop. Same problem.</p>

<p>The problem comes if you do <code>for(@a)</code> again. The index isn't back to 0 like you'd expect; it's <code>undef</code> followed by 0,1,2... one count off. The perldoc of <code>each()</code> says to avoid this issue. Use a <code>for</code> loop to track the index.  </p>

<p><em><a href="https://perldoc.perl.org/functions/each.html" rel="nofollow noreferrer">each</a></em></p>

<p>Basically:</p>

<pre><code>for(my $i=0; $i&lt;=$#a; $i++) {
  print "The Element at $i is $a[$i]\n";
}
</code></pre>

<p>I'm a fan of the alternate method:</p>

<pre><code>my $index=0;
for (@a) {
  print "The Element at $index is $a[$index]\n";
  $index++;
}
</code></pre>
<h4> Comment 108652797 Arnold Cross: </h4>Nice try, but no.  each does not access the same iterator that the for loop is using.  The iterator of each is a part of the array or hash.  for creates its own list of aliases to the array and iterates over that.  You can see what I mean by using <code>each(@a)</code> again within the loop, for instance <code>print each(@a).&quot;=&lt; $_ &gt;=&quot;.each(@a);</code>.<br>------------------------------------------------------------------ <br><h3> Answer 975917 Axeman: </h3><p>Well, there is this way:</p>

<pre><code>use List::Rubyish;

$list = List::Rubyish-&gt;new( [ qw&lt;a b c&gt; ] );
$list-&gt;each_index( sub { say "\$_=$_" } );
</code></pre>

<p>See <a href="http://search.cpan.org/perldoc?List::Rubyish" rel="nofollow noreferrer">List::Rubyish</a>.</p>
------------------------------------------------------------------ <br><h3> Answer 50081639 aaa: </h3><p>Please consider: </p>

<pre><code>print "Element at index $_ is $x[$_]\n" for keys @x;
</code></pre>
<h4> Comment 87185473 Nathan Fellman: </h4>I don&#39;t think that <code>keys @x</code> behaves as you think.  I&#39;d expect it to return every even-indexed element.<br><h4> Comment 100627052 Able Mac: </h4><code>for keys @x</code> is in a list context, returns the current index, and to get the value you have to reference it <code>$x[$_]</code> --- A more readable way to write the exact same thing is <code>for my $idx (keys @x){print &quot;Element at index $idx is $x[$idx]\n&quot;;}</code><br>------------------------------------------------------------------ <br><h3> Answer 979600 user47322: </h3><p>You shouldn't need to know the index in most circumstances. You can do this:</p>

<pre><code>my @arr = (1, 2, 3);
foreach (@arr) {
    $_++;
}
print join(", ", @arr);
</code></pre>

<p>In this case, the output would be <strong>2, 3, 4</strong> as foreach sets an alias to the actual element, not just a copy.</p>
<h4> Comment 1924766 Nathan Fellman: </h4>I know that I don&#39;t need the index in most circumstances.  The question is about the best way to get it when I do need it.<br><h4> Comment 788139 Anon: </h4>What would happen if you replace the first line with:  my @arr = (&#39;foo&#39;, &#39;bar&#39;, &#39;foo&#39;);<br><h4> Comment 798212 user47322: </h4>It would print 1, 1, 1 since string scalars evaluate to zero when used in number context.<br>------------------------------------------------------------------ <br><h3> Answer 14151944 surendra ben: </h3><p>I have tried like....</p>

<pre><code>@array = qw /tomato banana papaya potato/;             # Example array
my $count;                                             # Local variable initial value will be 0.
print "\nBefore For loop value of counter is $count";  # Just printing value before entering the loop.

for (@array) { print "\n",$count++," $_" ; }           # String and variable seperated by comma to
                                                       # execute the value and print.
undef $count;                                          # Undefining so that later parts again it will
                                                       # be reset to 0.

print "\nAfter for loop value of counter is $count";   # Checking the counter value after for loop.
</code></pre>

<p>In short...</p>

<pre><code>@array = qw /a b c d/;
my $count;
for (@array) { print "\n",$count++," $_"; }
undef $count;
</code></pre>
<h4> Comment 19645153 Nathan Fellman: </h4>so you&#39;re basically suggesting that I keep track of the index manually.<br>