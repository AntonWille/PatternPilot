 <h2> Title: How do I parse a string to a float or int? </h2> <h3> Tristan Havelick, question_id: 379906 </h3>Score: 2722, Tags: {python,parsing,floating-point,type-conversion,integer} <br><p>How can I convert an <code>str</code> to a <code>float</code>?</p>
<pre><code>&quot;545.2222&quot; -&gt; 545.2222
</code></pre>
<p>Or an <code>str</code> to a <code>int</code>?</p>
<pre><code>&quot;31&quot; -&gt; 31
</code></pre>
<hr />
<p><sub>For the reverse, see <a href="https://stackoverflow.com/questions/961632">Convert integer to string in Python</a> and <a href="https://stackoverflow.com/questions/1317558">Converting a float to a string without rounding it</a>.</sub></p>
<p><sub>Please instead use <a href="https://stackoverflow.com/questions/20449427">How can I read inputs as numbers?</a> to close duplicate questions where OP received a string <em>from user input</em> and immediately wants to convert it, or was hoping for <code>input</code> (in 3.x) to convert the type automatically.</sub></p>
<h4> Comment 89346797 robertlayton: </h4>As a general rule, if you have an object in Python, and want to convert <i>to</i> that type of object, call <code>type(my_object)</code> on it. The result can usually be called as a function to do the conversion. For instance <code>type(100)</code> results in <code>int</code>, so you can call <code>int(my_object)</code> to try convert <code>my_object</code> to an integer. This doesn&#39;t always work, but is a good &quot;first guess&quot; when coding.<br><h4> Comment 135477565 InfiniteStack: </h4>Also make sure the string is actually can be converted to float<a href="https://semicolon.dev/stackoverflow/question/8/how-to-convert-a-string-to-a-float-in-python" rel="nofollow noreferrer">,</a> one way of doing that is to write a custom function with a try/except block, that checks for <code>return float(str_value)</code> inside try scope.<br>------------------------------------------------------------------ <br><h3> Answer 379910 Harley Holcombe: </h3><pre><code>&gt;&gt;&gt; a = "545.2222"
&gt;&gt;&gt; float(a)
545.22220000000004
&gt;&gt;&gt; int(float(a))
545
</code></pre>
<h4> Comment 78489411 dokkaebi: </h4>@MangatRaiModi Floating point numbers are inherently imperfect for representing decimals. For more, see <a href="https://stackoverflow.com/q/21895756/931277">stackoverflow.com/q/21895756/931277</a><br><h4> Comment 87456529 David Parks: </h4><code>int(a)</code> will give an error that the string isn&#39;t a valid integer: <code>ValueError: invalid literal for int() with base 10: &#39;545.222&#39;</code>, but converting from a float to an int is a supported conversion.<br><h4> Comment 87107678 463035818_is_not_an_ai: </h4>why not simply <code>int(a)</code> but <code>int(float(a))</code> ?<br><h4> Comment 78436017 Mangat Rai Modi: </h4>just wondering why there is &#39;04&#39; in the end? why not simply &#39;00&#39;? also my current version of python is not having &#39;04&#39;.<br><h4> Comment 91438141 Joe Bobson: </h4>You should handle <code>ValueError</code> if you want to be safe<br><h4> Comment 101659874 plugwash: </h4>@MangatRaiModi python changed it&#39;s rounding policy for floating point numbers a while back, it used to use a fixed number of digits, now it uses the &quot;shortest round trip&quot; representation.<br><h4> Comment 100283780 gaozhidf: </h4><code>return int(a) if float(a) == int(float(a)) else float(a)</code><br>------------------------------------------------------------------ <br><h3> Answer 20929983 Eric Leschinski: </h3><h2>Python2 method to check if a string is a float:</h2>
<pre><code>def is_float(value):
  if value is None:
      return False
  try:
      float(value)
      return True
  except:
      return False
</code></pre>
<p>For the Python3 version of is_float see: <a href="https://stackoverflow.com/questions/736043/checking-if-a-string-can-be-converted-to-float-in-python/20929881#20929881">Checking if a string can be converted to float in Python</a></p>
<p>A longer and more accurate name for this function could be: <code>is_convertible_to_float(value)</code></p>
<h2>What is, and is not a float in <a href="http://en.wikipedia.org/wiki/Python_%28programming_language%29" rel="noreferrer">Python</a> may surprise you:</h2>
<p>The below unit tests were done using python2.  Check it that Python3 has different behavior for what strings are convertable to float.  One confounding difference is that any number of interior underscores are now allowed:  <code>(float(&quot;1_3.4&quot;) == float(13.4))</code> is True</p>
<pre class="lang-none prettyprint-override"><code>val                   is_float(val) Note
--------------------  ----------   --------------------------------
&quot;&quot;                    False        Blank string
&quot;127&quot;                 True         Passed string
True                  True         Pure sweet Truth
&quot;True&quot;                False        Vile contemptible lie
False                 True         So false it becomes true
&quot;123.456&quot;             True         Decimal
&quot;      -127    &quot;      True         Spaces trimmed
&quot;\t\n12\r\n&quot;          True         whitespace ignored
&quot;NaN&quot;                 True         Not a number
&quot;NaNanananaBATMAN&quot;    False        I am Batman
&quot;-iNF&quot;                True         Negative infinity
&quot;123.E4&quot;              True         Exponential notation
&quot;.1&quot;                  True         mantissa only
&quot;1_2_3.4&quot;             False        Underscores not allowed
&quot;12 34&quot;               False        Spaces not allowed on interior
&quot;1,234&quot;               False        Commas gtfo
u'\x30'               True         Unicode is fine.
&quot;NULL&quot;                False        Null is not special
0x3fade               True         Hexadecimal
&quot;6e7777777777777&quot;     True         Shrunk to infinity
&quot;1.797693e+308&quot;       True         This is max value
&quot;infinity&quot;            True         Same as inf
&quot;infinityandBEYOND&quot;   False        Extra characters wreck it
&quot;12.34.56&quot;            False        Only one dot allowed
u'四'                 False        Japanese '4' is not a float.
&quot;#56&quot;                 False        Pound sign
&quot;56%&quot;                 False        Percent of what?
&quot;0E0&quot;                 True         Exponential, move dot 0 places
0**0                  True         0___0  Exponentiation
&quot;-5e-5&quot;               True         Raise to a negative number
&quot;+1e1&quot;                True         Plus is OK with exponent
&quot;+1e1^5&quot;              False        Fancy exponent not interpreted
&quot;+1e1.3&quot;              False        No decimals in exponent
&quot;-+1&quot;                 False        Make up your mind
&quot;(1)&quot;                 False        Parenthesis is bad
</code></pre>
<p>You think you know what numbers are? You are not so good as you think! Not big surprise.</p>
<h2>Don't use this code on life-critical software!</h2>
<p>Catching broad exceptions this way, killing canaries and gobbling the exception creates a tiny chance that a valid float as string will return false.  The <code>float(...)</code> line of code can failed for any of a thousand reasons that have nothing to do with the contents of the string.  But if you're writing life-critical software in a duck-typing prototype language like Python, then you've got much larger problems.</p>
<h4> Comment 101920067 wim: </h4>This except clause should be restricted to <code>TypeError, ValueError</code><br><h4> Comment 94099469 Eric Leschinski: </h4>I posted this answer in 2014. That <code>UTF-8</code> glyph for a Chinese <code>4</code> has been transforming over the years depending on how stackoverflow developers change up their character encoding scheme upon their microsoft toolstack.   It&#39;s a curiosity to see it flip flop over the years as new conversion schemes assert their new ideologies.  But yes, Any <code>UTF-8</code> glyph for a Eastern oriental numeric is not a Python float.  Bazinga.<br><h4> Comment 97021965 E.Serra: </h4>how can this be so upvoted, with such a broad exception?<br><h4> Comment 91486518 FindOutIslamNow: </h4>So true becomes 1, that is I inherited from C++ i think<br><h4> Comment 130369370 Peter Mortensen: </h4>Perhaps sort table by the second column?<br><h4> Comment 126152007 Michal Šrůtek: </h4><code>Commas gtfo</code> - laughed way too hard at this :D<br><h4> Comment 127396659 haridsv: </h4>IMHO, unless Python parser and <code>float</code> type converter behave differently, type casting should be reliable. I bet, all those false -ves that @EricLeschinski posted will go away if you set the right <code>locale</code> (i.e., the one the format is meant for). Locale setting is global. For client side code, user must already have the right locale set. For server side code the only workaround I know is to spawn a child Python process (need not be Python, of course).<br><h4> Comment 120847164 godfryd: </h4>Instead of <code>is_convertible_to_float</code> a better name would be <code>can_be_float</code><br><h4> Comment 101398109 Simon: </h4>Everything with spaces in between cannot be converted, like <code>&quot;- 12.3&quot;</code> and <code>&quot;45 e6&quot;</code><br>------------------------------------------------------------------ <br><h3> Answer 379966 Javier: </h3><pre><code>def num(s):
    try:
        return int(s)
    except ValueError:
        return float(s)
</code></pre>
<h4> Comment 18336781 jfs: </h4><i>implicit</i> mixing floats/ints might lead to subtle bugs due to possible loss of precision when working with floats or to different results for <code>&#47;</code> operator on floats/ints. Depending on context it might be preferable to return either int or float, not both.<br><h4> Comment 21478772 TimothyAWiseman: </h4>@J.F.Sebastian You are completely correct, but there are times when you want the input to dictate which one it will be.  Letting the input dictate which one can work nicely with duck-typing.<br><h4> Comment 83877108 iBug: </h4>You can nest another <code>try</code> to throw an exception when it&#39;s not convertible to float.<br><h4> Comment 93394378 Matt Hancock: </h4>Fails with <code>s = u&#39;\u0000&#39;</code><br><h4> Comment 95889334 marcelm: </h4>@iBug Good idea! I recommend throwing <code>ValueError</code> in the corresponding <code>except</code> :P<br><h4> Comment 118913266 wjandrea: </h4>@Matt Why wouldn&#39;t it? NUL is not a number. If you want to convert it to <code>0</code>, you&#39;ll need to go another route, like <code>int(u&#39;\x00&#39;.encode(&#39;hex&#39;), 16)</code>.<br>------------------------------------------------------------------ <br><h3> Answer 9510585 wim: </h3><p>Another method which deserves to be mentioned here is <a href="http://docs.python.org/library/ast.html#ast.literal_eval" rel="nofollow noreferrer"><code>ast.literal_eval</code></a>:</p>
<blockquote>
<p>This can be used for safely evaluating strings containing Python expressions from untrusted sources without the need to parse the values oneself.</p>
</blockquote>
<p>That is, a safe 'eval'</p>
<pre><code>&gt;&gt;&gt; import ast
&gt;&gt;&gt; ast.literal_eval(&quot;545.2222&quot;)
545.2222
&gt;&gt;&gt; ast.literal_eval(&quot;31&quot;)
31
</code></pre>
<h4> Comment 83555329 royce3: </h4>this is <i>not</i> a good solution to the problem. It works fine in Python 2, but the following happens in Python 3:  <code>python &gt;&gt;&gt; import ast &gt;&gt;&gt; ast.literal_eval(&#39;1-800-555-1212&#39;) -2566 &gt;&gt;&gt; </code>  To clarify why this is a problem, if you want it to leave phone numbers alone and not assume they are mathematical expressions, then this approach is not for you.<br><h4> Comment 83559194 wim: </h4>@royce3  Yeah, that&#39;s a good point and users should beware.  The behaviour was originally modified in order to address some issues with parsing of complex literals.  It&#39;s arguably a bug in <code>ast.literal_eval</code>, and has been discussed <a href="https://stackoverflow.com/q/20748202/674039">here</a>.<br><h4> Comment 127252241 wim: </h4>@royce3 For the record, <code>ast</code> will not literal eval that phone number to -2566 anymore in Python 3. It&#39;s in the Python 3.7 <a href="https://docs.python.org/3/whatsnew/3.7.html#changes-in-the-python-api" rel="nofollow noreferrer">changelog</a>: <i><code>ast.literal_eval()</code> is now stricter. Addition and subtraction of arbitrary numbers are no longer allowed. (Contributed by Serhiy Storchaka in <a href="https://github.com/python/cpython/issues/75959" rel="nofollow noreferrer">bpo-31778</a>)</i><br><h4> Comment 132014762 mirekphd: </h4>Caution: <code>ast.literal_eval</code> does not seem to work for numeric inputs (raising <code>ValueError: malformed node or string: 0</code>).<br>------------------------------------------------------------------ <br><h3> Answer 17815252 Mark Chackerian: </h3><h2>Localization and commas</h2>

<p>You should consider the possibility of commas in the string representation of a number, for cases like  <code>float("545,545.2222")</code> which throws an exception. Instead, use methods in <code>locale</code> to convert the strings to numbers and interpret commas correctly. The <code>locale.atof</code> method converts to a float in one step once the locale has been set for the desired number convention.</p>

<p><strong>Example 1 -- United States number conventions</strong> </p>

<p>In the United States and the UK, commas can be used as a thousands separator.  In this example with American locale, the comma is handled properly as a separator:</p>

<pre><code>&gt;&gt;&gt; import locale
&gt;&gt;&gt; a = u'545,545.2222'
&gt;&gt;&gt; locale.setlocale(locale.LC_ALL, 'en_US.UTF-8')
'en_US.UTF-8'
&gt;&gt;&gt; locale.atof(a)
545545.2222
&gt;&gt;&gt; int(locale.atof(a))
545545
&gt;&gt;&gt;
</code></pre>

<p><strong>Example 2 -- European number conventions</strong></p>

<p>In the <a href="https://en.wikipedia.org/wiki/Decimal_mark">majority of countries of the world</a>,  commas are used for decimal marks instead of periods.  In this example with French locale, the comma is correctly handled as a decimal mark:</p>

<pre><code>&gt;&gt;&gt; import locale
&gt;&gt;&gt; b = u'545,2222'
&gt;&gt;&gt; locale.setlocale(locale.LC_ALL, 'fr_FR')
'fr_FR'
&gt;&gt;&gt; locale.atof(b)
545.2222
</code></pre>

<p>The method <code>locale.atoi</code> is also available, but the argument should be an integer.</p>
<h4> Comment 94859982 user5359531: </h4>Using Dino&#39;s method, I guess the answer would be to use something like this: <code>locale.atof(x) if locale.localeconv().get(&#39;decimal_point&#39;) in x else locale.atoi(x)</code><br><h4> Comment 94860356 Mark Chackerian: </h4>I would recommend using Javier&#39;s method above (wrapping <code>locale.atoi</code> in a try and using <code>locale.atof</code> on exception -- it&#39;s probably more readable.<br><h4> Comment 94859567 user5359531: </h4>This seems like an ideal solution when you know if a float or int should be returned, but how can you get this to return an int only if an int was passed? For example, <code>x = &#39;1&#39;; locale.atof(x)</code> returns <code>1.0</code> when I actually want <code>1</code>.<br><h4> Comment 132014822 mirekphd: </h4>Caution: <code>locale.atof(my_int)</code> will change type from <code>int</code> to <code>float</code>...<br>------------------------------------------------------------------ <br><h3> Answer 379968 Dino Viehland: </h3><pre><code>float(x) if '.' in x else int(x)
</code></pre>
<h4> Comment 8841342 jchl: </h4>@Emile: I wouldn&#39;t call &quot;2e-3&quot; an &quot;extreme case&quot;.  This answer is just broken.<br><h4> Comment 4781568 Emile: </h4>Nitpick: doesn&#39;t work for extreme cases like float(&quot;2e-3&quot;)<br><h4> Comment 7820653 Ben G: </h4>Note : be careful when dealing with money amount passed as strings, as some countries use &quot;,&quot; as decimal separators<br><h4> Comment 30750077 ToolmakerSteve: </h4>@BenG DON&#39;T manipulate money as a float. That&#39;s asking for trouble. Use decimal for money! (But your comment about &#39;,&#39; is still valid and important)<br><h4> Comment 95174111 Todor Minakov: </h4>Easily breakable by an IP address - <code>192.168.0.1</code>; or <code>&quot;This is not a good approach. :)&quot;</code><br><h4> Comment 78641904 Ronny Andersson: </h4>Don&#39;t forget that &quot;not a number&quot; (NaN) and +/- infinity is also valid float values. So <code>float(&quot;nan&quot;)</code> is a perfectly valid float value that the above answer wouldn&#39;t catch at all<br>------------------------------------------------------------------ <br><h3> Answer 25299501 SethMMorton: </h3><p>If you aren't averse to third-party modules, you could check out the <a href="https://pypi.org/project/fastnumbers" rel="noreferrer">fastnumbers</a> module. It provides a function called <a href="http://fastnumbers.readthedocs.io/en/master/api.html#fastnumbers.fast_real" rel="noreferrer">fast_real</a> that does exactly what this question is asking for and does it faster than a pure-Python implementation:</p>

<pre><code>&gt;&gt;&gt; from fastnumbers import fast_real
&gt;&gt;&gt; fast_real("545.2222")
545.2222
&gt;&gt;&gt; type(fast_real("545.2222"))
float
&gt;&gt;&gt; fast_real("31")
31
&gt;&gt;&gt; type(fast_real("31"))
int
</code></pre>
------------------------------------------------------------------ <br><h3> Answer 31588754 Russia Must Remove Putin: </h3><blockquote>
  <p><strong>In Python, how can I parse a numeric string like "545.2222" to its corresponding float value, 542.2222? Or parse the string "31" to an integer, 31?</strong>
  I just want to know how to parse a float string to a float, and (separately) an int string to an int.</p>
</blockquote>

<p>It's good that you ask to do these separately. If you're mixing them, you may be setting yourself up for problems later. The simple answer is:</p>

<p><strong><code>"545.2222"</code> to float:</strong></p>

<pre><code>&gt;&gt;&gt; float("545.2222")
545.2222
</code></pre>

<p><strong><code>"31"</code> to an integer:</strong></p>

<pre><code>&gt;&gt;&gt; int("31")
31
</code></pre>

<h1>Other conversions, ints to and from strings and literals:</h1>

<p>Conversions from various bases, and you should know the base in advance (10 is the default). Note you can prefix them with what Python expects for its literals (see below) or remove the prefix:</p>

<pre><code>&gt;&gt;&gt; int("0b11111", 2)
31
&gt;&gt;&gt; int("11111", 2)
31
&gt;&gt;&gt; int('0o37', 8)
31
&gt;&gt;&gt; int('37', 8)
31
&gt;&gt;&gt; int('0x1f', 16)
31
&gt;&gt;&gt; int('1f', 16)
31
</code></pre>

<p>If you don't know the base in advance, but you do know they will have the correct prefix, Python can infer this for you if you pass <code>0</code> as the base:</p>

<pre><code>&gt;&gt;&gt; int("0b11111", 0)
31
&gt;&gt;&gt; int('0o37', 0)
31
&gt;&gt;&gt; int('0x1f', 0)
31
</code></pre>

<h3>Non-Decimal (i.e. Integer) Literals from other Bases</h3>

<p>If your motivation is to have your own code clearly represent hard-coded specific values, however, you may not need to convert from the bases - you can let Python do it for you automatically with the correct syntax.</p>

<p>You can use the apropos prefixes to get automatic conversion to integers with <a href="https://docs.python.org/3/reference/lexical_analysis.html#integer-literals" rel="noreferrer">the following literals</a>. These are valid for Python 2 and 3:</p>

<p>Binary, prefix <code>0b</code></p>

<pre><code>&gt;&gt;&gt; 0b11111
31
</code></pre>

<p>Octal, prefix <code>0o</code></p>

<pre><code>&gt;&gt;&gt; 0o37
31
</code></pre>

<p>Hexadecimal, prefix <code>0x</code></p>

<pre><code>&gt;&gt;&gt; 0x1f
31
</code></pre>

<p>This can be useful when describing binary flags, file permissions in code, or hex values for colors - for example, note no quotes:</p>

<pre><code>&gt;&gt;&gt; 0b10101 # binary flags
21
&gt;&gt;&gt; 0o755 # read, write, execute perms for owner, read &amp; ex for group &amp; others
493
&gt;&gt;&gt; 0xffffff # the color, white, max values for red, green, and blue
16777215
</code></pre>

<h3>Making ambiguous Python 2 octals compatible with Python 3</h3>

<p>If you see an integer that starts with a 0, in Python 2, this is (deprecated) octal syntax.</p>

<pre><code>&gt;&gt;&gt; 037
31
</code></pre>

<p>It is bad because it looks like the value should be <code>37</code>. So in Python 3, it now raises a <code>SyntaxError</code>:</p>

<pre><code>&gt;&gt;&gt; 037
  File "&lt;stdin&gt;", line 1
    037
      ^
SyntaxError: invalid token
</code></pre>

<p>Convert your Python 2 octals to octals that work in both 2 and 3 with the <code>0o</code> prefix:</p>

<pre><code>&gt;&gt;&gt; 0o37
31
</code></pre>
------------------------------------------------------------------ <br><h3> Answer 379932 user44484: </h3><p>Users <em>codelogic</em> and <em>harley</em> are correct, but keep in mind if you know the string is an integer (for example, 545) you can call int("545") without first casting to float.</p>

<p>If your strings are in a list, you could use the map function as well. </p>

<pre><code>&gt;&gt;&gt; x = ["545.0", "545.6", "999.2"]
&gt;&gt;&gt; map(float, x)
[545.0, 545.60000000000002, 999.20000000000005]
&gt;&gt;&gt;
</code></pre>

<p>It is only good if they're all the same type.</p>
------------------------------------------------------------------ <br><h3> Answer 7588720 krzym: </h3><p>The question seems a little bit old. But let me suggest a function, parseStr, which makes something similar, that is, returns integer or float and if a given ASCII string cannot be converted to none of them it returns it untouched. The code of course might be adjusted to do only what you want:</p>

<pre><code>   &gt;&gt;&gt; import string
   &gt;&gt;&gt; parseStr = lambda x: x.isalpha() and x or x.isdigit() and \
   ...                      int(x) or x.isalnum() and x or \
   ...                      len(set(string.punctuation).intersection(x)) == 1 and \
   ...                      x.count('.') == 1 and float(x) or x
   &gt;&gt;&gt; parseStr('123')
   123
   &gt;&gt;&gt; parseStr('123.3')
   123.3
   &gt;&gt;&gt; parseStr('3HC1')
   '3HC1'
   &gt;&gt;&gt; parseStr('12.e5')
   1200000.0
   &gt;&gt;&gt; parseStr('12$5')
   '12$5'
   &gt;&gt;&gt; parseStr('12.2.2')
   '12.2.2'
</code></pre>
<h4> Comment 17190621 Cees Timmerman: </h4><code>1e3</code> is a number in python, but a string according to your code.<br><h4> Comment 111323016 enchance: </h4>I prefer this answer.<br>------------------------------------------------------------------ <br><h3> Answer 379909 codelogic: </h3><p><code>float("545.2222")</code> and <code>int(float("545.2222"))</code></p>
<h4> Comment 207898 Brian: </h4>This will give you a float object if your string happens to be &quot;0&quot; or &quot;0.0&quot;, rather than the int it gives for other valid numbers.<br>------------------------------------------------------------------ <br><h3> Answer 16028076 Rafe: </h3><p>The <a href="http://en.wikipedia.org/wiki/YAML" rel="noreferrer">YAML</a> parser can help you figure out what datatype your string is. Use <code>yaml.load()</code>, and then you can use <code>type(result)</code> to test for type:</p>

<pre><code>&gt;&gt;&gt; import yaml

&gt;&gt;&gt; a = "545.2222"
&gt;&gt;&gt; result = yaml.load(a)
&gt;&gt;&gt; result
545.22220000000004
&gt;&gt;&gt; type(result)
&lt;type 'float'&gt;

&gt;&gt;&gt; b = "31"
&gt;&gt;&gt; result = yaml.load(b)
&gt;&gt;&gt; result
31
&gt;&gt;&gt; type(result)
&lt;type 'int'&gt;

&gt;&gt;&gt; c = "HI"
&gt;&gt;&gt; result = yaml.load(c)
&gt;&gt;&gt; result
'HI'
&gt;&gt;&gt; type(result)
&lt;type 'str'&gt;
</code></pre>
<h4> Comment 122180649 Mike Williamson: </h4>This is a great answer (or <code>json</code> or whatever your favorite is):  we all recognize that proper conversion is non-trivial.  So find a widely adopted library that manages this for you.  :)<br><h4> Comment 123363480 Rafe: </h4>JSON can work great but will just raise a TypeError if a string is passed, so needs some custom handling or pre-checks to avoid some attempts. Like I some regexp: <a href="https://stackoverflow.com/a/69790897/1236083">stackoverflow.com/a/69790897/1236083</a><br>------------------------------------------------------------------ <br><h3> Answer 44994308 Shameem: </h3><p>I use this function for that</p>

<pre><code>import ast

def parse_str(s):
   try:
      return ast.literal_eval(str(s))
   except:
      return
</code></pre>

<p>It will convert the string to its type</p>

<pre><code>value = parse_str('1')  # Returns Integer
value = parse_str('1.5')  # Returns Float
</code></pre>
<h4> Comment 98570024 musiphil: </h4>Please be noted that <code>parse_str(&#39; 1&#39;)</code> (with a space) will return <code>None</code>, not <code>1</code>.<br>------------------------------------------------------------------ <br><h3> Answer 33017514 Totoro: </h3><pre><code>def get_int_or_float(v):
    number_as_float = float(v)
    number_as_int = int(number_as_float)
    return number_as_int if number_as_float == number_as_int else number_as_float
</code></pre>
<h4> Comment 59855474 Greg0ry: </h4>Why would you raise in your <code>except</code> section if you are doing nothing there? float() would raise for you.<br><h4> Comment 68018921 Totoro: </h4>you are right I guess I copied and paste from a functionality that I was raising a particular exception. will edit. thanks<br><h4> Comment 75108517 Kuzeko: </h4>This will try to parse a string and return either <code>int</code> or <code>float</code> depending on what the string represents. It might rise parsing exceptions or [have some unexpected behaviour][1].<br>------------------------------------------------------------------ <br><h3> Answer 69147924 U13-Forward: </h3><p>You could use <code>json.loads</code>:</p>
<pre><code>&gt;&gt;&gt; import json
&gt;&gt;&gt; json.loads('123.456')
123.456
&gt;&gt;&gt; type(_)
&lt;class 'float'&gt;
&gt;&gt;&gt; 
</code></pre>
<p>As you can see it becomes a type of <code>float</code>.</p>
------------------------------------------------------------------ <br><h3> Answer 33044577 Jerry T: </h3><pre><code>def num(s):
    """num(s)
    num(3),num(3.7)--&gt;3
    num('3')--&gt;3, num('3.7')--&gt;3.7
    num('3,700')--&gt;ValueError
    num('3a'),num('a3'),--&gt;ValueError
    num('3e4') --&gt; 30000.0
    """
    try:
        return int(s)
    except ValueError:
        try:
            return float(s)
        except ValueError:
            raise ValueError('argument is not a string of number')
</code></pre>
------------------------------------------------------------------ <br><h3> Answer 3988355 Nick: </h3><p>You need to take into account rounding to do this properly.</p>
<p>i.e. - <code>int(5.1)</code> =&gt; 5
<code>int(5.6)</code> =&gt; 5  -- wrong, should be 6 so we do <code>int(5.6 + 0.5)</code> =&gt; 6</p>
<pre><code>def convert(n):
    try:
        return int(n)
    except ValueError:
        return float(n + 0.5)
</code></pre>
<h4> Comment 17189868 Cees Timmerman: </h4>Good point. That causes inflation, though, so <a href="http://stackoverflow.com/questions/10825926/python-3-x-rounding-behavior">Python 3</a> and <a href="http://stackoverflow.com/questions/311696/why-does-net-use-bankers-rounding-as-default">other modern languages</a> use banker&#39;s rounding.<br><h4> Comment 30749921 ToolmakerSteve: </h4>This answer is wrong (as originally written). It muddles the two cases of <code>int</code> and <code>float</code>. And it will give an exception, when <code>n</code> is a string, as OP desired. Maybe you meant: <b>When</b> an <code>int</code> result is desired, <code>round</code> should be done AFTER conversion to float. If the function should ALWAYS return an int, then you don&#39;t need the except part -- the entire function body can be <code>int(round(float(input)))</code>. If the function should return an int if possible, otherwise a float, then javier&#39;s original solution is correct!<br><h4> Comment 127361301 Avi Thour: </h4>ValueError: could not convert string to float<br>------------------------------------------------------------------ <br><h3> Answer 45063704 Sławomir Lenart: </h3><p>There is also regex, because sometimes string must be prepared and normalized before casting to a number:</p>
<pre><code>import re

def parseNumber(value, as_int=False):
    try:
        number = float(re.sub('[^.\-\d]', '', value))
        if as_int:
            return int(number + 0.5)
        else:
            return number
    except ValueError:
        return float('nan')  # or None if you wish
</code></pre>
<p>Usage:</p>
<pre class="lang-none prettyprint-override"><code>parseNumber('13,345')
&gt; 13345.0

parseNumber('- 123 000')
&gt; -123000.0

parseNumber('99999\n')
&gt; 99999.0
</code></pre>
<p>And by the way, something to verify you have a number:</p>
<pre><code>import numbers
def is_number(value):
    return isinstance(value, numbers.Number)
    # Will work with int, float, long, Decimal
</code></pre>
------------------------------------------------------------------ <br><h3> Answer 51126875 kCODINGeroo: </h3><p>To <code>typecast</code> in Python use the constructor functions of the type, passing the string (or whatever value you are trying to cast) as a parameter.</p>
<p>For example:</p>
<pre><code>&gt;&gt;&gt;float(&quot;23.333&quot;)
   23.333
</code></pre>
<p>Behind the scenes, Python is calling the objects <code>__float__</code> method, which should return a float representation of the parameter. This is especially powerful, as you can define your own types (using classes) with a <code>__float__</code> method so that it can be casted into a float using <code>float(myobject)</code>.</p>
------------------------------------------------------------------ <br><h3> Answer 58997070 shrewmouse: </h3><p><strong>Handles hex, octal, binary, decimal, and float</strong></p>
<p>This solution will handle all of the string conventions for numbers (all that I know about).</p>
<pre><code>def to_number(n):
    ''' Convert any number representation to a number
    This covers: float, decimal, hex, and octal numbers.
    '''

    try:
        return int(str(n), 0)
    except:
        try:
            # Python 3 doesn't accept &quot;010&quot; as a valid octal.  You must use the
            # '0o' prefix
            return int('0o' + n, 0)
        except:
            return float(n)
</code></pre>
<p>This test case output illustrates what I'm talking about.</p>
<pre class="lang-none prettyprint-override"><code>======================== CAPTURED OUTPUT =========================
to_number(3735928559)   = 3735928559 == 3735928559
to_number(&quot;0xFEEDFACE&quot;) = 4277009102 == 4277009102
to_number(&quot;0x0&quot;)        =          0 ==          0
to_number(100)          =        100 ==        100
to_number(&quot;42&quot;)         =         42 ==         42
to_number(8)            =          8 ==          8
to_number(&quot;0o20&quot;)       =         16 ==         16
to_number(&quot;020&quot;)        =         16 ==         16
to_number(3.14)         =       3.14 ==       3.14
to_number(&quot;2.72&quot;)       =       2.72 ==       2.72
to_number(&quot;1e3&quot;)        =     1000.0 ==       1000
to_number(0.001)        =      0.001 ==      0.001
to_number(&quot;0xA&quot;)        =         10 ==         10
to_number(&quot;012&quot;)        =         10 ==         10
to_number(&quot;0o12&quot;)       =         10 ==         10
to_number(&quot;0b01010&quot;)    =         10 ==         10
to_number(&quot;10&quot;)         =         10 ==         10
to_number(&quot;10.0&quot;)       =       10.0 ==         10
to_number(&quot;1e1&quot;)        =       10.0 ==         10
</code></pre>
<p>Here is the test:</p>
<pre><code>class test_to_number(unittest.TestCase):

    def test_hex(self):
        # All of the following should be converted to an integer
        #
        values = [

                 #          HEX
                 # ----------------------
                 # Input     |   Expected
                 # ----------------------
                (0xDEADBEEF  , 3735928559), # Hex
                (&quot;0xFEEDFACE&quot;, 4277009102), # Hex
                (&quot;0x0&quot;       ,          0), # Hex

                 #        Decimals
                 # ----------------------
                 # Input     |   Expected
                 # ----------------------
                (100         ,        100), # Decimal
                (&quot;42&quot;        ,         42), # Decimal
            ]



        values += [
                 #        Octals
                 # ----------------------
                 # Input     |   Expected
                 # ----------------------
                (0o10        ,          8), # Octal
                (&quot;0o20&quot;      ,         16), # Octal
                (&quot;020&quot;       ,         16), # Octal
            ]


        values += [
                 #        Floats
                 # ----------------------
                 # Input     |   Expected
                 # ----------------------
                (3.14        ,       3.14), # Float
                (&quot;2.72&quot;      ,       2.72), # Float
                (&quot;1e3&quot;       ,       1000), # Float
                (1e-3        ,      0.001), # Float
            ]

        values += [
                 #        All ints
                 # ----------------------
                 # Input     |   Expected
                 # ----------------------
                (&quot;0xA&quot;       ,         10),
                (&quot;012&quot;       ,         10),
                (&quot;0o12&quot;      ,         10),
                (&quot;0b01010&quot;   ,         10),
                (&quot;10&quot;        ,         10),
                (&quot;10.0&quot;      ,         10),
                (&quot;1e1&quot;       ,         10),
            ]

        for _input, expected in values:
            value = to_number(_input)

            if isinstance(_input, str):
                cmd = 'to_number(&quot;{}&quot;)'.format(_input)
            else:
                cmd = 'to_number({})'.format(_input)

            print(&quot;{:23} = {:10} == {:10}&quot;.format(cmd, value, expected))
            self.assertEqual(value, expected)
</code></pre>
<h4> Comment 127361323 Avi Thour: </h4>ValueError: could not convert string to float<br>------------------------------------------------------------------ <br><h3> Answer 59270522 Cybernetic: </h3><p>Pass your string to this function:</p>
<pre><code>def string_to_number(str):
  if(&quot;.&quot; in str):
    try:
      res = float(str)
    except:
      res = str
  elif(str.isdigit()):
    res = int(str)
  else:
    res = str
  return(res)
</code></pre>
<p>It will return int, float or string depending on what was passed.</p>
<h3>String that is an int</h3>
<pre><code>print(type(string_to_number(&quot;124&quot;)))
&lt;class 'int'&gt;
</code></pre>
<h3>String that is a float</h3>
<pre><code>print(type(string_to_number(&quot;12.4&quot;)))
&lt;class 'float'&gt;
</code></pre>
<h3>String that is a string</h3>
<pre><code>print(type(string_to_number(&quot;hello&quot;)))
&lt;class 'str'&gt;
</code></pre>
<h3>String that looks like a float</h3>
<pre><code>print(type(string_to_number(&quot;hel.lo&quot;)))
&lt;class 'str'&gt;
</code></pre>
<h4> Comment 121192566 Neuron: </h4>when looking at the name <code>string_to_number</code> I wouldn&#39;t expect it to return a string. I would expect it to raise an Exception if the input can&#39;t be parsed<br><h4> Comment 121213913 Neuron: </h4>I don&#39;t think it&#39;s a controversial opinion that a method called string_to_number should not return a string. I downvoted because the function is either poorly named or it&#39;s behaviour is wrong. also, there is no need to be passive aggressive. We can talk this out in a professional fashion<br>------------------------------------------------------------------ <br><h3> Answer 64275521 bougui: </h3><pre class="lang-py prettyprint-override"><code>a = int(float(a)) if int(float(a)) == float(a) else float(a)
</code></pre>
------------------------------------------------------------------ <br><h3> Answer 44041282 Kuzeko: </h3><p><strong>This is a corrected version</strong> of <a href="https://stackoverflow.com/questions/379906/how-do-i-parse-a-string-to-a-float-or-int/33017514#33017514">Totoro's answer</a>.</p>
<p>This will try to parse a string and return either <code>int</code> or <code>float</code> depending on what the string represents. It might rise parsing exceptions or <a href="https://stackoverflow.com/a/1778381/5973334">have some unexpected behaviour</a>.</p>
<pre><code>  def get_int_or_float(v):
        number_as_float = float(v)
        number_as_int = int(number_as_float)
        return number_as_int if number_as_float == number_as_int else
        number_as_float
</code></pre>
------------------------------------------------------------------ <br><h3> Answer 68397181 Sameh Farouk: </h3><p>If you are dealing with mixed integers and floats and want a consistent way to deal with your mixed data, here is my solution with the proper <a href="https://en.wikipedia.org/wiki/Docstring#Python" rel="nofollow noreferrer">docstring</a>:</p>
<pre><code>def parse_num(candidate):
    &quot;&quot;&quot;Parse string to number if possible
    It work equally well with negative and positive numbers, integers and floats.

    Args:
        candidate (str): string to convert

    Returns:
        float | int | None: float or int if possible otherwise None
    &quot;&quot;&quot;
    try:
        float_value = float(candidate)
    except ValueError:
        return None

    # Optional part if you prefer int to float when decimal part is 0
    if float_value.is_integer():
        return int(float_value)
    # end of the optional part

    return float_value

# Test
candidates = ['34.77', '-13', 'jh', '8990', '76_3234_54']
res_list = list(map(parse_num, candidates))
print('Before:')
print(candidates)
print('After:')
print(res_list)
</code></pre>
<p>Output:</p>
<pre><code>Before:
['34.77', '-13', 'jh', '8990', '76_3234_54']

After:
[34.77, -13, None, 8990, 76323454]
</code></pre>
------------------------------------------------------------------ <br><h3> Answer 39940402 SeasonalShot: </h3><p>Use:</p>

<pre><code>def num(s):
    try:
        for each in s:
            yield int(each)
    except ValueError:
        yield float(each)
a = num(["123.55","345","44"])
print a.next()
print a.next()
</code></pre>

<p>This is the most Pythonic way I could come up with. </p>
<h4> Comment 98570176 musiphil: </h4>The generator stops after the first interpretation of <code>float</code>. The <code>try</code>…<code>catch</code> block should probably be inside the <code>for</code> loop.<br>------------------------------------------------------------------ <br><h3> Answer 74094277 mmj: </h3><p>If you don't want to use third party modules the following might be the most robust solution:</p>
<pre><code>def string_to_int_or_float(s):
    try:
        f = float(s) # replace s with str(s) if you are not sure that s is a string
    except ValueError:
        print(&quot;Provided string '&quot; + s + &quot;' is not interpretable as a literal number.&quot;)
        raise
    try:
        i = int(str(f).rstrip('0').rstrip('.'))
    except:
        return f
    return i
</code></pre>
<p>It might not be the fastest, but it handles correctly literal numbers where many other solutions fail, such as:</p>
<pre><code>&gt;&gt;&gt; string_to_int_or_float('789.')
789
&gt;&gt;&gt; string_to_int_or_float('789.0')
789
&gt;&gt;&gt; string_to_int_or_float('12.3e2')
1230
&gt;&gt;&gt; string_to_int_or_float('12.3e-2')
0.123
&gt;&gt;&gt; string_to_int_or_float('4560e-1')
456
&gt;&gt;&gt; string_to_int_or_float('4560e-2')
45.6
</code></pre>
------------------------------------------------------------------ <br><h3> Answer 57458489 Abhishek Bhatia: </h3><p>This is a function which will convert any <code>object</code> (not just <code>str</code>) to <code>int</code> or <code>float</code>, based on if the actual string supplied <em>looks like</em> <code>int</code> or <code>float</code>. Further if it's an object which has both <code>__float</code> and <code>__int__</code> methods, it defaults to using <code>__float__</code></p>

<pre class="lang-py prettyprint-override"><code>def conv_to_num(x, num_type='asis'):
    '''Converts an object to a number if possible.
    num_type: int, float, 'asis'
    Defaults to floating point in case of ambiguity.
    '''
    import numbers

    is_num, is_str, is_other = [False]*3

    if isinstance(x, numbers.Number):
        is_num = True
    elif isinstance(x, str):
        is_str = True

    is_other = not any([is_num, is_str])

    if is_num:
        res = x
    elif is_str:
        is_float, is_int, is_char = [False]*3
        try:
            res = float(x)
            if '.' in x:
                is_float = True
            else:
                is_int = True
        except ValueError:
            res = x
            is_char = True

    else:
        if num_type == 'asis':
            funcs = [int, float]
        else:
            funcs = [num_type]

        for func in funcs:
            try:
                res = func(x)
                break
            except TypeError:
                continue
        else:
            res = x
</code></pre>
------------------------------------------------------------------ <br><h3> Answer 62022268 Shekku Joseph: </h3><p>By using int and float methods we can convert a string to integer and floats.</p>

<pre><code>s="45.8"
print(float(s))

y='67'
print(int(y))
</code></pre>
<h4> Comment 109698797 Georgy: </h4>This answer doesn&#39;t add anything new. See, for example, <a href="https://stackoverflow.com/questions/379906/how-do-i-parse-a-string-to-a-float-or-int/31588754#31588754">this answer</a> which gives the same information and more.<br>------------------------------------------------------------------ <br><h3> Answer 62986009 mamal: </h3><p>For numbers and characters together:</p>
<pre><code>string_for_int = &quot;498 results should get&quot;
string_for_float = &quot;498.45645765 results should get&quot;
</code></pre>
<p>First import <em>re</em>:</p>
<pre><code> import re

 # For getting the integer part:
 print(int(re.search(r'\d+', string_for_int).group())) #498

 # For getting the float part:
 print(float(re.search(r'\d+\.\d+', string_for_float).group())) #498.45645765
</code></pre>
<p>For easy model:</p>
<pre><code>value1 = &quot;10&quot;
value2 = &quot;10.2&quot;
print(int(value1)) # 10
print(float(value2)) # 10.2
</code></pre>
------------------------------------------------------------------ <br><h3> Answer 74583036 Pranav J: </h3><p>You can simply do this by</p>
<pre><code>s = '542.22'

f = float(s) # This converts string data to float data with a decimal point
print(f) 

i = int(f) # This converts string data to integer data by just taking the whole number part of it
print(i) 
</code></pre>
<p>For more information on parsing of data types check on python documentation!</p>
------------------------------------------------------------------ <br><h3> Answer 76330391 codiander: </h3><p>If you want to change the type to some other data type, then you can use explicit type casting, by which I mean that you have to use <code>int()</code> for changing a string type into <code>integer</code> and <code>float()</code> to change it into <code>float</code> type.</p>
<p>But if we see into the concept of type casting we would realize that type casting is not a good choice as a programmer until it is necessary and hence we should use type casting only in cases where it is a serious requirement like when you use an input function for entering a user inputted value.</p>
<p>Bonus tip: you can also use type casting for changing <code>tuple</code>s to <code>list</code>s and then convert them back into <code>tuple</code>s and thus you can make changes in a <code>tuple</code> which is an immutable data type (<code>list()</code> and <code>tuple()</code> are the respective functions).</p>
------------------------------------------------------------------ <br><h3> Answer 39437128 user4813927: </h3><p>Use:</p>

<pre><code>&gt;&gt;&gt; str_float = "545.2222"
&gt;&gt;&gt; float(str_float)
545.2222
&gt;&gt;&gt; type(_) # Check its type
&lt;type 'float'&gt;

&gt;&gt;&gt; str_int = "31"
&gt;&gt;&gt; int(str_int)
31
&gt;&gt;&gt; type(_) # Check its type
&lt;type 'int'&gt;
</code></pre>
------------------------------------------------------------------ <br><h3> Answer 379963 S.Lott: </h3><p>Here's another interpretation of your question (hint: it's vague). It's possible you're looking for something like this:</p>

<pre><code>def parseIntOrFloat( aString ):
    return eval( aString )
</code></pre>

<p>It works like this...</p>

<pre><code>&gt;&gt;&gt; parseIntOrFloat("545.2222")
545.22220000000004
&gt;&gt;&gt; parseIntOrFloat("545")
545
</code></pre>

<hr>

<p>Theoretically, there's an injection vulnerability. The string could, for example be <code>"import os; os.abort()"</code>. Without any background on where the string comes from, however, the possibility is theoretical speculation.  Since the question is vague, it's not at all clear if this vulnerability actually exists or not.</p>
<h4> Comment 17190270 Cees Timmerman: </h4>Even if his input is 100% safe, <code>eval()</code> is over 3 times as slow as <code>try: int(s) except: float(s)</code>.<br><h4> Comment 92102132 U13-Forward: </h4>Well, <code>eval</code> is bad practice (you must know because you have 310k reputation)<br><h4> Comment 132465691 Friedrich -- Слава Україні: </h4>It&#39;s the shortest oneliner hack; who cares about speed...<br>