 <h2> Title: Quickly getting to YYYY-mm-dd HH:MM:SS in Perl </h2> <h3> knorv, question_id: 1814196 </h3>Score: 83, Tags: {perl,datetime,formatting,timestamp} <br><p>When writing Perl scripts I frequently find the need to obtain the current time represented as a string formatted as <code>YYYY-mm-dd HH:MM:SS</code> (say <code>2009-11-29 14:28:29</code>).</p>

<p>In doing this I find myself taking this quite cumbersome path:</p>

<ul>
<li><code>man perlfunc</code></li>
<li><code>/localtime</code> to search for localtime - repeat five times (<code>/</code> + <code>\n</code>) to reach the relevant section of the manpage</li>
<li>Copy the string <code>($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = localtime(time);</code> from the manpage to my script.</li>
<li>Try with <code>my $now = sprintf("%04d-%02d-%02d %02d:%02d:%02d", $year, $mon, $mday, $hour, $min, $sec);</code></li>
<li>Remember gotcha #1: Must add 1900 to $year to get current year.</li>
<li>Try with <code>my $now = sprintf("%04d-%02d-%02d %02d:%02d:%02d", $year+1900, $mon, $mday, $hour, $min, $sec);</code></li>
<li>Remember gotcha #2: Must add 1 to $mon to get current month.</li>
<li>Try with <code>my $now = sprintf("%04d-%02d-%02d %02d:%02d:%02d", $year+1900, $mon+1, $mday, $hour, $min, $sec);</code></li>
<li>Seems ok. Done!</li>
</ul>

<p>While the process outlined above works it is far from optimal. I'm sure there is a smarter way, so my question is simply:</p>

<p><b>What is the easiest way to obtain a <code>YYYY-mm-dd HH:MM:SS</code> of the current date/time in Perl?</b></p>

<p>Where "easy" encompasses both "easy-to-write" and "easy-to-remember".</p>
<h4> Comment 1703837 AmbroseChapel: </h4>You should have written a subroutine to search the perlfunc and remember the gotchas for you, of course!<br><h4> Comment 98712115 Astrinus: </h4>Write a stackoverflow question with all the steps, pretending to ask for a solution :-)<br>------------------------------------------------------------------ <br><h3> Answer 1814967 Zaid: </h3><p>Why not use the <code>DateTime</code> module to do the dirty work for you? It's easy to write <em>and</em> remember!</p>
<pre><code>use strict;
use warnings;
use DateTime;

my $dt   = DateTime-&gt;now;   # Stores current date and time as datetime object
my $date = $dt-&gt;ymd;   # Retrieves date as a string in 'yyyy-mm-dd' format
my $time = $dt-&gt;hms;   # Retrieves time as a string in 'hh:mm:ss' format

my $wanted = &quot;$date $time&quot;;   # creates 'yyyy-mm-dd hh:mm:ss' string
print $wanted;
</code></pre>
<p>Once you know what's going on, you can get rid of the temps and save a few lines of code:</p>
<pre><code>use strict;
use warnings;
use DateTime;

my $dt = DateTime-&gt;now;
print join ' ', $dt-&gt;ymd, $dt-&gt;hms;
</code></pre>
------------------------------------------------------------------ <br><h3> Answer 1814210 Greg Bacon: </h3><p>Use <code>strftime</code> in the standard <a href="http://perldoc.perl.org/POSIX.html" rel="noreferrer"><code>POSIX</code></a> module. The arguments to <a href="https://perldoc.perl.org/POSIX.html#strftime" rel="noreferrer"><code>strftime</code></a> in Perlâ€™s binding were designed to align with the return values from <a href="https://perldoc.perl.org/functions/localtime.html" rel="noreferrer"><code>localtime</code></a> and <a href="https://perldoc.perl.org/functions/gmtime.html" rel="noreferrer"><code>gmtime</code></a>. Compare</p>

<pre><code>strftime(fmt, sec, min, hour, mday, mon, year, wday = -1, yday = -1, isdst = -1)
</code></pre>

<p>with</p>

<pre><code>my          ($sec,$min,$hour,$mday,$mon,$year,$wday,     $yday,     $isdst) = gmtime(time);
</code></pre>

<p>Example command-line use is</p>

<pre><code>$ perl -MPOSIX -le 'print strftime "%F %T", localtime $^T'
</code></pre>

<p>or from a source file as in</p>

<pre><code>use POSIX;

print strftime "%F %T", localtime time;
</code></pre>

<p>Some systems do not support the <code>%F</code> and <code>%T</code> shorthands, so you will have to be explicit with</p>

<pre><code>print strftime "%Y-%m-%d %H:%M:%S", localtime time;
</code></pre>

<p>or</p>

<pre><code>print strftime "%Y-%m-%d %H:%M:%S", gmtime time;
</code></pre>

<p>Note that <a href="https://perldoc.perl.org/functions/time.html" rel="noreferrer"><code>time</code></a> returns the current time when called whereas <a href="https://perldoc.perl.org/perlvar.html#%24BASETIME" rel="noreferrer"><code>$^T</code></a> is fixed to the time when your program started. With <a href="https://perldoc.perl.org/functions/gmtime.html" rel="noreferrer"><code>gmtime</code></a>, the return value is the current time in GMT. Retrieve time in your local timezone with <a href="https://perldoc.perl.org/functions/localtime.html" rel="noreferrer"><code>localtime</code></a>.</p>
<h4> Comment 17493021 MkV: </h4>There is also strftime in Time::Piece (core since 5.10) which lets you use a more object oriented form (see my answer below).  Also, $^T (time since program start) is not what you want.<br>------------------------------------------------------------------ <br><h3> Answer 12907886 Vish: </h3><p>Try this:</p>

<pre><code>use POSIX qw/strftime/;
print strftime('%Y-%m-%d',localtime);
</code></pre>

<p>the <code>strftime</code> method does the job effectively for me. Very simple and efficient.</p>

<hr>
------------------------------------------------------------------ <br><h3> Answer 12912646 MkV: </h3><p><a href="http://search.cpan.org/dist/Time-Piece">Time::Piece</a> (in core since Perl 5.10) also has a strftime function and by default overloads localtime and gmtime to return Time::Piece objects:</p>

<pre><code>use Time::Piece;
print localtime-&gt;strftime('%Y-%m-%d');
</code></pre>

<p>or without the overridden localtime:</p>

<pre><code>use Time::Piece (); 
print Time::Piece::localtime-&gt;strftime('%F %T');
</code></pre>
<h4> Comment 51968339 osirisgothra: </h4>+1 for the mention of a core module and usage -- since the vast amount of available modules are one of the major reasons most of us  use Perl in the first place<br>------------------------------------------------------------------ <br><h3> Answer 29891641 robm: </h3><p>if you just want a human readable time string and not that exact format:</p>

<pre><code>$t = localtime;
print "$t\n";
</code></pre>

<p>prints </p>

<pre><code>Mon Apr 27 10:16:19 2015
</code></pre>

<p>or whatever is configured for your locale.</p>
------------------------------------------------------------------ <br><h3> Answer 32712514 Holger: </h3><p>I made a little test (Perl v5.20.1 under FreeBSD in VM) calling the following blocks 1.000.000 times each:</p>

<p>A</p>

<pre><code>my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = localtime(time);
my $now = sprintf("%04d-%02d-%02d %02d:%02d:%02d", $year+1900, $mon+1, $mday, $hour, $min, $sec);
</code></pre>

<p>B</p>

<pre><code>my $now = strftime('%Y%m%d%H%M%S',localtime);
</code></pre>

<p>C</p>

<pre><code>my $now = Time::Piece::localtime-&gt;strftime('%Y%m%d%H%M%S');
</code></pre>

<p>with the following results:</p>

<p>A: 2 seconds</p>

<p>B: 11 seconds</p>

<p>C: 19 seconds</p>

<p>This is of course not a thorough test or benchmark, but at least it is reproducable for me, so even though it is more complicated, I'd prefer the first method if generating a datetimestamp is required very often.</p>

<p>Calling (eg. under FreeBSD 10.1)</p>

<pre><code>my $now = `date "+%Y%m%d%H%M%S" | tr -d "\n"`;
</code></pre>

<p>might not be such a good idea because it is not OS-independent and takes quite some time.</p>

<p>Best regards,
Holger</p>
------------------------------------------------------------------ <br><h3> Answer 21581429 ernix: </h3><p><code>Time::Piece::datetime()</code> can eliminate <code>T</code>.</p>

<pre><code>use Time::Piece;
print localtime-&gt;datetime(T =&gt; q{ });
</code></pre>
<h4> Comment 51968367 osirisgothra: </h4>another mention of Time::Piece should make me remember it now -- not exactly the easiest module to remember to use if not used on a daily basis :)<br>------------------------------------------------------------------ <br><h3> Answer 43612273 Off The Gold: </h3><p>Short and sweet, no additional modules needed:</p>

<pre><code>my $toDate = `date +%m/%d/%Y" "%l:%M:%S" "%p`;
</code></pre>

<p>Output for example would be: 04/25/2017  9:30:33 AM</p>
<h4> Comment 98724597 lfurini: </h4><code>date +%Y-%m-%d&quot; &quot;%H:%M:%S</code> to get the exact format needed by OP<br><h4> Comment 106843230 Roman: </h4>Doesn&#39;t work when called out of windows command line, does it? Windows version of &quot;date&quot; has different behaviour.<br><h4> Comment 106852076 Off The Gold: </h4>My answer was based on Perl running on a Unix system, so it may not apply to windows versions of Perl. So you didn&#39;t get this result running Perl on Windows?<br>------------------------------------------------------------------ <br><h3> Answer 56505990 druid62: </h3><p>In many cases, the needed 'current time' is rather $^T, which is the time at which the script started running, in whole seconds (assuming only 60 second minutes) since the UNIX epoch.</p>

<p>This to prevent that an early part of a script uses a different date (or daylight-saving status) than a later part of a script, for example in query-conditions and other derived values.</p>

<p>For that variant of 'current time', one can use a constant, also to document that it was frozen at compile time:</p>

<pre><code>use constant YMD_HMS_AT_START =&gt; POSIX::strftime( "%F %T", localtime $^T );
</code></pre>

<p>Alternative higher resolution startup time:</p>

<pre><code>0+ [ Time::HiRes::stat("/proc/$$") ]-&gt;[10]
</code></pre>
