 <h2> Title: Find size of an array in Perl </h2> <h4> David, question_id: 7406807 </h4>Score: 280, Tags: {perl} <br><p>I seem to have come across several different ways to find the size of an array. What is the difference between these three methods?</p>

<pre><code>my @arr = (2);
print scalar @arr; # First way to print array size

print $#arr; # Second way to print array size

my $arrSize = @arr;
print $arrSize; # Third way to print array size
</code></pre>
<h4> tadmc, Id: 8949784 Score: 45: </h4>The &quot;second way&quot; is NOT a way to print the array size...<br><h4> mob, Id: 8949228 Score: 13: </h4>other ways: <code>print 0+@arr</code>, <code>print &quot;&quot;.@arr</code>, <code>print ~~@arr</code><br><h4> ikegami, Id: 8949589 Score: 4: </h4>@mob, hum, one might want to avoid <code>&quot;&quot;.@arr</code> as <code>&quot;@arr&quot;</code> does something quite different.<br><h4> Peter Mortensen, Id: 125553800 Score: 0: </h4>Candidates: <i><a href="https://stackoverflow.com/questions/241388/">What does $#array mean in Perl?</a></i> (2008-10-27)<br><h4> Znik, Id: 92844211 Score: 0: </h4>in scalar context ;@arr returns table size. $x=@arr is scalar context. $#arr returns last index of array. indexing starting at 0, then is true equation $#arr+1 == @arr . If you write some element out of order, for example $arr[100]=&#39;any&#39;, then table is automatically increased to max index 100, and (including index 0) to 101 elements.<br>------------------------------------------------------------------ <br><h3> C. K. Young, Id: 7406842, Score: 265: </h3><p>The first and third ways are the same: they evaluate an array in scalar context. I would consider this to be the standard way to get an array's size.</p>

<p>The second way actually returns the last index of the array, which is not (usually) the same as the array size.</p>
<h4> Nate C-K, Comment 8949081 Score: 32: </h4>The size of (1,2,3) is 3, and the indexes are (by default) 0, 1 and 2. So, $#arr will be 2 in this case, not 3.<br><h4> Keith Thompson, Comment 8949824 Score: 9: </h4>@ikegami: Yes, but someone trying to understand the difference between <code>scalar @arr</code> and <code>$#arr</code> should <i>still</i> understand the possible effects of <code>$[</code>, rare though they are.<br><h4> ikegami, Comment 8949440 Score: 6: </h4>@Keith Thompson, <code>$[</code> is discouraged (and has been for a decade). <code>$[</code> is deprecated. Using <code>$[</code> issues a deprecation warning even when one doesn&#39;t turn on warnings. Assigning anything but zero to <code>$[</code> will be an error in 5.16. Can we stop mentioning <code>$[</code> already?<br><h4> Keith Thompson, Comment 8949190 Score: 5: </h4>The predefined variable <code>$[</code> specifies &quot;The index of the first element in an array, and of the first character in a substring&quot; (<code>perldoc perlvar</code>).  It&#39;s set to 0 by default, and setting it to anything other than 0 is highly discouraged.<br><h4> ikegami, Comment 8949516 Score: 2: </h4>@Keith Thompson, Older than 5.14, actually. But like I said, it&#39;s been discouraged and deprecated for far longer than that, and someone using <code>$[</code> would know of its effects.<br><h4> Keith Thompson, Comment 8949469 Score: 1: </h4>@ikegami: Sure, we can stop mentioning <code>$[</code> as soon as everyone in the world stops using versions of Perl older than 5.16.  8-)}<br><h4> David, Comment 8949035 Score: 0: </h4>What&#39;s the difference between the last index and the array size? Is the index not sequential from 0 to the array size?<br><h4> ikegami, Comment 82164904 Score: 0: </h4>@Keith Tompson, I beg to differ. Someone who doesn&#39;t use <code>$[</code> doesn&#39;t need to know about its effects. And as I already said, the person using <code>$[</code> --if the person even exists-- already knows its effects. There&#39;s no point in going through all this for the benefit of the non-existent person that uses <code>$[</code> without knowing what it is.<br>------------------------------------------------------------------ <br><h3> ikegami, Id: 7407036, Score: 49: </h3><p>First, the second (<code>$#array</code>) is not equivalent to the other two. <code>$#array</code> returns the last index of the array, which is one less than the size of the array.</p>
<p>The other two (<code>scalar @arr</code> and <code>$arrSize = @arr</code>) are virtually the same. You are simply using two different means to create scalar context. It comes down to a question of readability.</p>
<p>I personally prefer the following:</p>
<pre><code>say 0+@array;          # Represent @array as a number
</code></pre>
<p>I find it clearer than</p>
<pre><code>say scalar(@array);    # Represent @array as a scalar
</code></pre>
<p>and</p>
<pre><code>my $size = @array;
say $size;
</code></pre>
<p>The latter looks quite clear alone like this, but I find that the extra line takes away from clarity when part of other code. It's useful for teaching what <code>@array</code> does in scalar context, and maybe if you want to use <code>$size</code> more than once.</p>
<h4> Nate C-K, Comment 8952928 Score: 18: </h4>Personally I prefer the version that uses the &quot;scalar&quot; keyword, because it&#39;s quite explicit that it&#39;s forcing a scalar context. <code>my $size=@array</code> looks like it might be a mistake where the wrong sigil was used.<br><h4> ikegami, Comment 39370673 Score: 5: </h4>That&#39;s a really bad idea. People who use <code>scalar</code> for no reason learn the wrong lesson. They start getting into their heads that operators return lists that can be coerced into scalars. Seen it dozens of times.<br><h4> Nate C-K, Comment 39933442 Score: 2: </h4>Why is this &quot;no reason&quot;? You are using <code>scalar</code> because you are coercing the list to a scalar context. That is the right reason to use it. Your example does exactly the same thing, but relies on what Perl does when you evaluate a list variable in an implicitly scalar context. Thus, your example requires the reader to know about Perl&#39;s implicit behavior in that context. You&#39;re just adding one more layer of implicit behavior to the expression, and Perl already has too much implicit behavior that you have to reason through to decipher a program.<br><h4> ikegami, Comment 39935775 Score: 2: </h4>@Nate C-K, Re &quot;Why is this &quot;no reason&quot;? You are using <code>scalar</code> because you are coercing the list to a scalar context&quot;, You&#39;ve proving my point about learning the wrong lesson. This is completely false. No list is ever coerced by <code>scalar</code>. (If it did, <code>scalar(@array)</code> and <code>scalar(@array[0..$#array])</code> would return the same thing.) <code>scalar(@array)</code> tells <code>@array</code> to return a scalar, which you already told it to do with <code>my $size=</code>.<br><h4> Nate C-K, Comment 39941484 Score: 2: </h4>Believe it or not, developers have to debug code written by other developers. And developers have to debug code that they wrote three years ago.<br><h4> ikegami, Comment 39941508 Score: 2: </h4>@Nate C-K, I&#39;m not too worried about the programmer&#39;s ability to debug a program noone ever ran.<br><h4> Nate C-K, Comment 39939776 Score: 1: </h4>The original example wasn&#39;t <code>my $size = scalar(@array);</code>, it was <code>say scalar(@array);</code>. I see what you mean about the assignment, that in that context it is redundant, although as I pointed out before it clarifies your intent (since mixing up sigils is an extremely common mistake in Perl).<br><h4> Nate C-K, Comment 39940748 Score: 1: </h4>As I said (twice), because it&#39;s possible to mix up the sigils. Programmers write <code>my $x = @y</code> when they meant <code>my @x = @y</code> or <code>my $x = $y</code>. This happens all the time in Perl, whether it&#39;s due to confusion or just a simple typo.<br><h4> ikegami, Comment 39940941 Score: 1: </h4>@Nate C-K, Re &quot;it&#39;s possible to mix up the sigils&quot;, 1) I know you said that, but it doesn&#39;t answer my question. I asked how does <code>scalar($x)</code> clarify intent? 2) Re &quot;Programmers write <code>my $x = @y</code> when they meant <code>my @x = @y</code> or <code>my $x = $y</code>&quot;, No they don&#39;t. The program wouldn&#39;t work.<br><h4> Nate C-K, Comment 39941215 Score: 1: </h4>Yes... that&#39;s why it&#39;s a bug.<br><h4> ikegami, Comment 39941458 Score: 1: </h4>@Nate C-K, It won&#39;t even compile, so the only reader is the programmer who just wrote the code. You&#39;re saying he needs to tell himself what he means as he&#39;s writing the code? nah. No reason to do that. How about you have the programmer remember to use a scalar rather than remember to use <code>scalar</code>.<br><h4> ikegami, Comment 39940123 Score: 0: </h4>@Nate C-K, Re &quot;The original example wasn&#39;t <code>my $size = scalar(@array);</code>&quot;, So? I never said there was no reason for <code>scalar</code> in the original. It was in reply to you saying <code>my $size=@array;</code> shouldn&#39;t be used.<br><h4> ikegami, Comment 39940240 Score: 0: </h4>@Nate C-K, Re &quot;it clarifies your intent&quot;, How so? Does anything think you can assign something other than a scalar to a scalar? No, it superfluous and harmful.<br>------------------------------------------------------------------ <br><h3> Nate C-K, Id: 7406848, Score: 32: </h3><p>This gets the size by forcing the array into a scalar context, in which it is evaluated as its size:</p>

<pre><code>print scalar @arr;
</code></pre>

<p>This is another way of forcing the array into a scalar context, since it's being assigned to a scalar variable:</p>

<pre><code>my $arrSize = @arr;
</code></pre>

<p>This gets the index of the last element in the array, so it's actually the size minus 1 (assuming indexes start at 0, which is adjustable in Perl although doing so is usually a bad idea):</p>

<pre><code>print $#arr;
</code></pre>

<p>This last one isn't really good to use for getting the array size. It would be useful if you just want to get the last element of the array:</p>

<pre><code>my $lastElement = $arr[$#arr];
</code></pre>

<p>Also, as you can see here on Stack&nbsp;Overflow, this construct isn't handled correctly by most syntax highlighters...</p>
<h4> tuomassalo, Comment 45719752 Score: 2: </h4>A sidenote: just use <code>$arr[-1]</code> to get the last element. And <code>$arr[-2]</code> to get the penultimate one, and so on.<br><h4> Nate C-K, Comment 46148514 Score: 1: </h4>@tuomassalo: I agree  that your suggestion is a better approach. In retrospect, <code>$#arr</code> isn&#39;t a very useful feature, and it&#39;s no accident that other languages don&#39;t have it.<br>------------------------------------------------------------------ <br><h3> jhoanna, Id: 18797985, Score: 8: </h3><p>To use the second way, add 1:</p>

<pre><code>print $#arr + 1; # Second way to print array size
</code></pre>
<h4> Westrock, Comment 58300465 Score: 0: </h4><code>for [0..$#array] { print $array[$_ ] }</code>  works really well though if the purpose of getting the number of elements is to iterate through array. The advantage being that you get the element as well as a counter that are aligned.<br>------------------------------------------------------------------ <br><h3> Zon, Id: 19532849, Score: 6: </h3><p>All three give the same result if we modify the second one a bit:</p>

<pre><code>my @arr = (2, 4, 8, 10);

print "First result:\n";
print scalar @arr; 

print "\n\nSecond result:\n";
print $#arr + 1; # Shift numeration with +1 as it shows last index that starts with 0.

print "\n\nThird result:\n";
my $arrSize = @arr;
print $arrSize;
</code></pre>
<h4> devnull, Comment 28979759 Score: 6: </h4>Is this anything different from what has already been mentioned in <a href="http://stackoverflow.com/a/7407036/2235132">this</a> answer and <a href="http://stackoverflow.com/a/18797985/2235132">this</a> one?<br>------------------------------------------------------------------ <br><h3> dimas, Id: 17060255, Score: 5: </h3><p>Example:</p>

<pre><code>my @a = (undef, undef);
my $size = @a;

warn "Size: " . $#a;   # Size: 1. It's not the size
warn "Size: " . $size; # Size: 2
</code></pre>
------------------------------------------------------------------ <br><h3> Greg Bacon, Id: 31791569, Score: 3: </h3><p>The <a href="http://perldoc.perl.org/perlintro.html#Perl-variable-types" rel="nofollow noreferrer">“Perl variable types” section</a> of the <a href="http://perldoc.perl.org/perlintro.html" rel="nofollow noreferrer">perlintro documentation</a> contains</p>
<blockquote>
<p>The special variable <code>$#array</code> tells you the index of the last element of an array:</p>
<pre><code>print $mixed[$#mixed];       # last element, prints 1.23
</code></pre>
<p>You might be tempted to use <code>$#array + 1</code> to tell you how many items there are in an array. Don’t bother. As it happens, using <code>@array</code> where Perl expects to find a scalar value (“in scalar context”) will give you the number of elements in the array:</p>
<pre><code>if (@animals &lt; 5) { ... }
</code></pre>
</blockquote>
<p>The <a href="http://perldoc.perl.org/perldata.html" rel="nofollow noreferrer">perldata documentation</a> also covers this in the <a href="http://perldoc.perl.org/perldata.html#Scalar-values" rel="nofollow noreferrer">“Scalar values” section</a>.</p>
<blockquote>
<p>If you evaluate an array in scalar context, it returns the length of the array. (Note that this is not true of lists, which return the last value, like the C comma operator, nor of built-in functions, which return whatever they feel like returning.) The following is always true:</p>
<pre><code>scalar(@whatever) == $#whatever + 1;
</code></pre>
<p>Some programmers choose to use an explicit conversion so as to leave nothing to doubt:</p>
<pre><code>$element_count = scalar(@whatever);
</code></pre>
</blockquote>
<p>Earlier in the same section documents how to obtain the index of the last element of an array.</p>
<blockquote>
<p>The length of an array is a scalar value. You may find the length of array <code>@days</code> by evaluating <code>$#days</code>, as in <code>csh</code>. However, this isn’t the length of the array; it’s the subscript of the last element, which is a different value since there is ordinarily a 0th element.</p>
</blockquote>
------------------------------------------------------------------ <br><h3> jwal, Id: 43825644, Score: 3: </h3><p>From perldoc <a href="http://perldoc.perl.org/perldata.html" rel="nofollow noreferrer">perldata</a>, which should be safe to quote:</p>

<blockquote>
  <p>The following is always true:</p>

<pre><code>scalar(@whatever) == $#whatever + 1;
</code></pre>
</blockquote>

<p>Just so long as you don't $#whatever++ and mysteriously increase the size or your array.</p>

<blockquote>
  <p>The array indices start with 0.</p>
</blockquote>

<p>and</p>

<blockquote>
  <p>You can truncate an array down to nothing by assigning the null list () to it. The following are equivalent:</p>

<pre><code>    @whatever = ();
    $#whatever = -1;
</code></pre>
</blockquote>

<p>Which brings me to what I was looking for which is how to detect the array is empty. I found it if $#empty == -1;</p>
------------------------------------------------------------------ <br><h3> Kamal Nayan, Id: 43873596, Score: 3: </h3><p>There are various ways to print size of an array. Here are the meanings of all:</p>
<p>Let’s say our array is <code>my @arr = (3,4);</code></p>
<h3>Method 1: scalar</h3>
<p>This is the right way to get the size of arrays.</p>
<pre><code>print scalar @arr;  # Prints size, here 2
</code></pre>
<h3>Method 2: Index number</h3>
<p><code>$#arr</code> gives the last index of an array. So if array is of size 10 then its last index would be 9.</p>
<pre><code>print $#arr;     # Prints 1, as last index is 1
print $#arr + 1; # Adds 1 to the last index to get the array size
</code></pre>
<p>We are adding 1 here, considering the array as <strong>0-indexed</strong>. But, if it's not zero-based then, <strong>this logic will fail</strong>.</p>
<pre><code>perl -le 'local $[ = 4; my @arr = (3, 4); print $#arr + 1;'   # prints 6
</code></pre>
<p>The above example prints 6, because we have set its initial index to 4. Now the index would be 5 and 6, with elements 3 and 4 respectively.</p>
<h3>Method 3:</h3>
<p>When an array is used in a scalar context, then it returns the size of the array</p>
<pre><code>my $size = @arr;
print $size;   # Prints size, here 2
</code></pre>
<p>Actually, method 3 and method 1 are same.</p>
------------------------------------------------------------------ <br><h3> Reflective, Id: 49265518, Score: 1: </h3><p>Use <code>int(@array)</code> as it threats the argument as scalar.</p>
------------------------------------------------------------------ <br><h3> Sandeep_black, Id: 43114022, Score: 0: </h3><p>To find the size of an array use the <code>scalar</code> keyword:</p>

<pre><code>print scalar @array;
</code></pre>

<p>To find out the last index of an array there is <code>$#</code> (Perl default variable). It gives the last index of an array. As an array starts from 0, we get the size of array by adding one to <code>$#</code>:</p>

<pre><code>print "$#array+1";
</code></pre>

<p>Example:</p>

<pre><code>my @a = qw(1 3 5);
print scalar @a, "\n";
print $#a+1, "\n";
</code></pre>

<p>Output:</p>

<pre><code>3

3
</code></pre>
<h4> Peter Mortensen, Comment 117310043 Score: 0: </h4>What do you mean by <i>&quot;Perl default variable&quot;</i>?<br>------------------------------------------------------------------ <br><h3> Timur Shtatland, Id: 63582994, Score: 0: </h3><p>As numerous answers pointed out, the first and third way are the correct methods to get the array size, and the second way is not.</p>
<p>Here I expand on these answers with some usage examples.</p>
<p><code>@array_name</code> evaluates to the length of the array = the size of the array = the number of elements in the array, <strong>when used in a scalar context</strong>.</p>
<p>Below are some examples of a scalar context, such as <code>@array_name</code> by itself inside <code>if</code> or <code>unless</code>, of in arithmetic comparisons such as <code>==</code> or <code>!=</code>.</p>
<p>All of these examples will work if you change <code>@array_name</code> to <code>scalar(@array_name)</code>. This would make the code more explicit, but also longer and slightly less readable. Therefore, more idiomatic usage omitting <code>scalar()</code> is preferred here.</p>
<pre><code>my @a = (undef, q{}, 0, 1);

# All of these test whether 'array' has four elements:
print q{array has four elements} if @a == 4;
print q{array has four elements} unless @a != 4;
@a == 4 and print q{array has four elements};
!(@a != 4) and print q{array has four elements};

# All of the above print:
# array has four elements

# All of these test whether array is not empty:
print q{array is not empty} if @a;
print q{array is not empty} unless !@a;
@a and print q{array is not empty};
!(!@a) and print q{array is not empty};

# All of the above print:
# array is not empty
</code></pre>
