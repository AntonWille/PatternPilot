 <h2> Title: How do I get the full path to a Perl script that is executing? </h2> <h4> Chris Madden, question_id: 84932, created_at: 2008-09-17 16:16:00+00:00 </h4>Score: 186, Tags: {perl,path,location} <br><p>I have Perl script and need to determine the full path and filename of the script during execution. I discovered that depending on how you call the script <code>$0</code> varies and sometimes contains the <code>fullpath+filename</code> and sometimes just <code>filename</code>. Because the working directory can vary as well I can't think of a way to reliably get the <code>fullpath+filename</code> of the script.</p>

<p>Anyone got a solution?</p>
<h4> Comment by user1210923, Score: 0, Id: 115176336, created_at: 2020-12-04 17:42:15+00:00 </h4>I know this was a long time ago but I was just looking for a perl windows way of doing this and am quite happy with my solution   #!/usr/bin/perl -w 	my @catalog=<code>dir</code>; 	$myHome = substr($catalog[3],14); 	$myHome = &amp;rtrim($myHome); 	print qq(&lt;$myHome&gt;\n); # Right trim function to remove trailing whitespace sub rtrim { 	my $string = shift; 	$string =~ s/\s+$//; 	return $string; } just thought I&#39;d share<hr><h3>  Answer by user3061015, Id: 20349041, Score: -2, created_at: 2013-12-03 10:48:48+00:00 </h3><p>What's wrong with <code>$^X</code> ?</p>

<pre><code>#!/usr/bin/env perl&lt;br&gt;
print "This is executed by $^X\n";
</code></pre>

<p>Would give you the full path to the Perl binary being used.</p>

<p>Evert</p>
<h4> Comment by Putnik, Score: 1, Id: 32641547, created_at: 2014-02-06 14:00:24+00:00 </h4>It gives path to the Perl binary whilst path to a script required<hr><h3> ✔️ Answer by Drew Stephens, Id: 90721, Score: 284, created_at: 2008-09-18 07:30:54+00:00 </h3><p>There are a few ways:</p>

<ul>
<li><a href="http://perldoc.perl.org/perlvar.html#$0" rel="noreferrer"><code>$0</code></a> is the currently executing script as provided by POSIX, relative to the current working directory if the script is at or below the CWD</li>
<li>Additionally, <code>cwd()</code>, <code>getcwd()</code> and <code>abs_path()</code> are provided by the <a href="http://perldoc.perl.org/Cwd.html" rel="noreferrer"><code>Cwd</code></a> module and tell you where the script is being run from</li>
<li>The module <a href="http://perldoc.perl.org/FindBin.html" rel="noreferrer"><code>FindBin</code></a> provides the <code>$Bin</code> &amp; <code>$RealBin</code> variables that <em>usually</em> are the path to the executing script; this module also provides <code>$Script</code> &amp; <code>$RealScript</code> that are the name of the script</li>
<li><a href="http://perldoc.perl.org/perldata.html#Special-Literals" rel="noreferrer"><code>__FILE__</code></a> is the actual file that the Perl interpreter deals with during compilation, including its full path.</li>
</ul>

<p>I've seen the first three (<a href="http://perldoc.perl.org/perlvar.html#$0" rel="noreferrer"><code>$0</code></a>, the <a href="http://perldoc.perl.org/Cwd.html" rel="noreferrer"><code>Cwd</code></a> module and the <a href="http://perldoc.perl.org/FindBin.html" rel="noreferrer"><code>FindBin</code></a> module) fail under <code>mod_perl</code> spectacularly, producing worthless output such as <code>'.'</code> or an empty string.  In such environments, I use <a href="http://perldoc.perl.org/perldata.html#Special-Literals" rel="noreferrer"><code>__FILE__</code></a> and get the path from that using the <a href="http://perldoc.perl.org/File/Basename.html" rel="noreferrer"><code>File::Basename</code></a> module:</p>

<pre><code>use File::Basename;
my $dirname = dirname(__FILE__);
</code></pre>
<h4> Comment by DavidGamba, Score: 13, Id: 35398300, created_at: 2014-04-18 07:58:34+00:00 </h4><code>dirname(__FILE__)</code> doesn&#39;t follow symlinks, so if you linked the executable file and where hoping to find the location of some other file in the install location you need to check <code>if( -l __FILE__)</code> and then <code>dirname(readlink(__FILE__))</code>.<h4> Comment by Aftershock, Score: 10, Id: 22102194, created_at: 2013-03-23 15:15:00+00:00 </h4>It looks like abs_path needs to be used with _____FILE_____ as it may contain the name only with the path.<h4> Comment by Izkata, Score: 6, Id: 22190600, created_at: 2013-03-26 14:55:39+00:00 </h4>@vicTROLLA Probably because the biggest recommendation from this answer (using dirname with <code>__FILE__</code>) doesn&#39;t work quite as expected?  I end up with the relative path from where the script was executed, while the accepted answer gives me the full absolute path.<h4> Comment by Drew Stephens, Score: 4, Id: 60466574, created_at: 2016-04-05 12:18:41+00:00 </h4>@IliaRostovtsev You can find when a module was first included in the standard modules with this incantation: <code>perl -e &#39;use Module::CoreList; print Module::CoreList-&gt;first_release(&quot;File::Basename&quot;);&#39;; echo</code>. For <code>File::Basename</code> that was Perl 5.0.0, which was released in the late &#39;90s—I think it&#39;s save to use by now.<h4> Comment by Grant Bowman, Score: 2, Id: 66485387, created_at: 2016-09-20 07:24:11+00:00 </h4>So here is what worked for me, putting it all together with @Aftershock (thanks) to answer the original question.          <code>use Cwd &#39;abs_path&#39;;       use File::Basename;      my $start;       if ( -l __FILE__ ) { $start=dirname(readlink(__FILE__)); } else { $start=dirname(__FILE__); }       my $fullpath = abs_path($start).&#39;&#47;&#39;;       my $filename= basename($start);       print &quot;$fullpath$filename&quot;;</code><h4> Comment by Caterham, Score: 2, Id: 10939116, created_at: 2012-01-08 01:04:44+00:00 </h4>This is really the best solution, especially if you already have a modified $0<h4> Comment by vicTROLLA, Score: 1, Id: 21869794, created_at: 2013-03-17 00:27:40+00:00 </h4>Upvote. Not really sure why this answer was not accepted as the above accepted answer is not functional considering it involves stripping the script name off the end of the path.<h4> Comment by David Tonhofer, Score: 1, Id: 92720502, created_at: 2018-10-20 10:45:01+00:00 </h4><code>dirname</code> is said to involve &quot;quirks&quot; in the Perl documentation, and it is recommended to use <code>fileparse</code>. So basically <code>abs_path((fileparse(__FILE__))[1])</code> should give the path.<h4> Comment by Georgy Vladimirov, Score: 1, Id: 105142189, created_at: 2019-12-26 01:20:08+00:00 </h4>I would like to add an important thing to keep in mind that is tangental to this problem. That is, people usually want to find the directory of the running script, so that they can include some modules relative to the script&#39;s path, i.e. they want to add a <code>use lib ( &quot;$dirname&#47;lib&quot; )</code>. In those cases, it is important to put the <code>my $dirname = dirname(__FILE__);</code> inside a <code>BEGIN { ... }</code> block before the <code>use lib</code>, so that it will execute at compile time before that (normally <code>use</code> directives happen at compile time, so you need <code>BEGIN</code> to force the order of execution.<h4> Comment by user3673, Score: 1, Id: 112374836, created_at: 2020-08-23 17:31:24+00:00 </h4>Doesn&#39;t work: <code>$ cat &gt;testdirname use File::Basename; print dirname(__FILE__); $ perl testdirname .$ perl -v  This is perl 5, version 28, subversion 1 (v5.28.1) built for x86_64-linux-gnu-thread-multi</code><h4> Comment by Lily Ballard, Score: 1, Id: 113618926, created_at: 2020-10-07 21:21:48+00:00 </h4>@DavidTonhofer Surely you do <code>abs_path</code> first, otherwise if the file itself is a symlink you won&#39;t be resolving that symlink, since you&#39;re only resolving the directory. That would be <code>(fileparse(abs_path(__FILE__)))[1]</code><h4> Comment by Mark Reed, Score: 1, Id: 114870996, created_at: 2020-11-23 18:45:05+00:00 </h4>Worth mentioning here that <code>__FILE__</code> is <i>not</i> always an absolute path.<h4> Comment by Steven Fisher, Score: 0, Id: 119577865, created_at: 2021-05-22 17:00:29+00:00 </h4>@MarkReed Yes, in my case it was the filename only.<h4> Comment by Sos, Score: 0, Id: 39416713, created_at: 2014-08-13 17:12:28+00:00 </h4>newbie here: although your solution worked (seeing as I could open files in that directory), is it normal that when I <code>dd $dirname</code> or <code>print $dirname</code> I get &#39;.&#39; as output?<h4> Comment by kbro, Score: 0, Id: 46522537, created_at: 2015-03-19 16:44:49+00:00 </h4>I have a script that&#39;s being run from another script using require &#39;script.pl&#39; so $0 give me the path to the calling script, not the called one.  __FILE__ gives the right answer in this case.<h4> Comment by Ilia Ross, Score: 0, Id: 60458540, created_at: 2016-04-05 09:17:21+00:00 </h4>How safe is it to use <code>File::Basename;</code>, meaning when this module started to be shipped with Perl core? Is it possible that some old Perl versions wouldn&#39;t have it. How to check it?<hr><h3>  Answer by Mark, Id: 85070, Score: 39, created_at: 2008-09-17 16:31:53+00:00 </h3><pre><code>use File::Spec;
File::Spec-&gt;rel2abs( __FILE__ );
</code></pre>
<p><a href="http://perldoc.perl.org/File/Spec/Unix.html" rel="nofollow noreferrer">http://perldoc.perl.org/File/Spec/Unix.html</a></p>
<h4> Comment by David H., Score: 0, Id: 102833888, created_at: 2019-10-04 04:03:14+00:00 </h4>Then wrap in dirname() to get the absolute path - just what I needed!<hr><h3>  Answer by Ovid, Id: 84959, Score: 150, created_at: 2008-09-17 16:19:48+00:00 </h3><p>$0 is typically the name of your program, so how about this?</p>

<pre><code>use Cwd 'abs_path';
print abs_path($0);
</code></pre>

<p>Seems to me that this should work as abs_path knows if you are using a relative or absolute path.</p>

<p><strong>Update</strong> For anyone reading this years later, you should read <a href="https://stackoverflow.com/a/90721/2877364">Drew's answer</a>. It's much better than mine.</p>
<h4> Comment by vol7ron, Score: 3, Id: 17540729, created_at: 2012-10-17 19:02:35+00:00 </h4>wanted to add that there&#39;s a <code>realpath</code>, which is a synonym to <code>abs_path</code>, incase you prefer the no-underscore name<h4> Comment by Chris Madden, Score: 12, Id: 11260, created_at: 2008-09-17 17:03:01+00:00 </h4>Small comment, on activestate perl on windows $0 typically contains backslashes and abs_path returned forward slashes, so a quick &quot;tr /\//\\/;&quot; was needed to fix it.<h4> Comment by GreenGiant, Score: 2, Id: 57333954, created_at: 2016-01-14 16:57:32+00:00 </h4>@leonbloy When you execute a script inline (with <code>-e</code>), I believe perl creates a temp file to store your inline script. Looks like the location, in your case, is <code>&#47;tmp</code>. What did you expect the result to be?<h4> Comment by leonbloy, Score: 1, Id: 36390725, created_at: 2014-05-15 17:45:09+00:00 </h4>Other problem I have: <code>perl -e &#39;use Cwd &quot;abs_path&quot;;print abs_path($0);&#39;</code>  prints <code>&#47;tmp&#47;-e</code><h4> Comment by William Barrett, Score: 0, Id: 37697880, created_at: 2014-06-23 23:51:54+00:00 </h4>This worked fine for me under Windows 7.  However, the path did not contain any links.<h4> Comment by Richlv, Score: 0, Id: 78541708, created_at: 2017-08-21 08:02:42+00:00 </h4>@GreenGiant, it uses the current directory in that case - but I guess @leonbloy did not expect to see <code>-e</code> appended to the path.<h4> Comment by Znik, Score: 0, Id: 33604806, created_at: 2014-03-03 12:10:53+00:00 </h4>@Chris , did you report bug to Cwd module maintainer? It seems like Windows adoption bug.<h4> Comment by Scott Chu, Score: 0, Id: 35816728, created_at: 2014-04-30 06:22:08+00:00 </h4>This reports an error &quot;opendir(test.pl/..): is not a directory at test.pl line 8!<hr><h3>  Answer by bmdhacks, Id: 84982, Score: 16, created_at: 2008-09-17 16:22:39+00:00 </h3><p>I think the module you're looking for is FindBin:</p>

<pre><code>#!/usr/bin/perl
use FindBin;

$0 = "stealth";
print "The actual path to this is: $FindBin::Bin/$FindBin::Script\n";
</code></pre>
<hr><h3>  Answer by Benjamin W. Smith, Id: 85037, Score: 11, created_at: 2008-09-17 16:29:15+00:00 </h3><p>You could use <a href="http://search.cpan.org/~tty/kurila-1.13_0/lib/FindBin.pm" rel="noreferrer">FindBin</a>, <a href="http://perldoc.perl.org/Cwd.html" rel="noreferrer">Cwd</a>, <a href="http://perldoc.perl.org/File/Basename.html" rel="noreferrer">File::Basename</a>, or a combination of them.  They're all in the base distribution of Perl IIRC.</p>

<p>I used Cwd in the past:</p>

<p>Cwd:</p>

<pre><code>use Cwd qw(abs_path);
my $path = abs_path($0);
print "$path\n";
</code></pre>
<h4> Comment by Znik, Score: 1, Id: 33605345, created_at: 2014-03-03 12:24:50+00:00 </h4>@bmdhacks, you&#39;re right. Presumption is, you didn&#39;t change 0$. For example you do work above as soon as script starts (in initialization block), or elsewhere when you don&#39;t change $0. But $0 is excellent way to change process description visible under &#39;ps&#39; unix tool :) This can show curren process status, etc. This is depended on programmer purpose :)<hr><h3>  Answer by Eric Wilhelm, Id: 90769, Score: 10, created_at: 2008-09-18 07:45:24+00:00 </h3><p>Getting the absolute path to <code>$0</code> or <code>__FILE__</code> is what you want.  The only trouble is if someone did a <code>chdir()</code> and the <code>$0</code> was relative -- then you need to get the absolute path in a <code>BEGIN{}</code> to prevent any surprises.</p>

<p><code>FindBin</code> tries to go one better and grovel around in the <code>$PATH</code> for something matching the <code>basename($0)</code>, but there are times when that does far-too-surprising things (specifically:  when the file is "right in front of you" in the cwd.)</p>

<p><code>File::Fu</code> has <code>File::Fu-&gt;program_name</code> and <code>File::Fu-&gt;program_dir</code> for this.</p>
<h4> Comment by SamB, Score: 0, Id: 11659167, created_at: 2012-02-12 21:23:41+00:00 </h4>Is it really likely that anyone would be so foolish as to (permanently) <code>chdir()</code> at compile time?<h4> Comment by Znik, Score: 0, Id: 33605374, created_at: 2014-03-03 12:25:41+00:00 </h4>Simply do all works based on current dir and $0 at the script begin.<hr><h3>  Answer by wnoise, Id: 85264, Score: 8, created_at: 2008-09-17 16:52:24+00:00 </h3><p>Some short background:</p>

<p>Unfortunately the Unix API doesn't provide a running program with the full path to the executable.  In fact, the program executing yours can provide whatever it wants in the field that normally tells your program what it is.  There are, as all the answers point out, various heuristics for finding likely candidates.  But nothing short of searching the entire filesystem will always work, and even that will fail if the executable is moved or removed.</p>

<p>But you don't want the Perl executable, which is what's actually running, but the script it is executing.  And Perl needs to know where the script is to find it.  It stores this in <code>__FILE__</code>, while <code>$0</code> is from the Unix API.  This can still be a relative path, so take Mark's suggestion and canonize it with <code>File::Spec-&gt;rel2abs( __FILE__ );</code></p>
<h4> Comment by felwithe, Score: 0, Id: 68032420, created_at: 2016-11-02 21:46:08+00:00 </h4><code>__FILE__</code> still gives me a relative path. i.e. &#39;.&#39;.<hr><h3>  Answer by Sean, Id: 84973, Score: 6, created_at: 2008-09-17 16:21:33+00:00 </h3><p>Have you tried:</p>

<pre><code>$ENV{'SCRIPT_NAME'}
</code></pre>

<p>or</p>

<pre><code>use FindBin '$Bin';
print "The script is located in $Bin.\n";
</code></pre>

<p>It really depends on how it's being called and if it's CGI or being run from a normal shell, etc.</p>
<h4> Comment by Znik, Score: 1, Id: 33605129, created_at: 2014-03-03 12:19:38+00:00 </h4>Bad idea because SCRIPT_NAME enviroment is depended on shell you are using. This is complete incompatibile with windows cmd.exe, and incompatibile when you call script directly from other binaries. There is no warranty this wariable is set. Above ways are much more usable.<h4> Comment by Putnik, Score: 0, Id: 32641682, created_at: 2014-02-06 14:03:55+00:00 </h4>$ENV{&#39;SCRIPT_NAME&#39;} is empty when the script is running at console<hr><h3>  Answer by Matt, Id: 17735548, Score: 6, created_at: 2013-07-18 23:12:45+00:00 </h3><p>In order to get the path to the directory containing my script I used a combination of answers given already.</p>

<pre><code>#!/usr/bin/perl
use strict;
use warnings;
use File::Spec;
use File::Basename;

my $dir = dirname(File::Spec-&gt;rel2abs(__FILE__));
</code></pre>
<hr><h3>  Answer by moritz, Id: 85098, Score: 2, created_at: 2008-09-17 16:34:54+00:00 </h3><p><a href="http://perldoc.perl.org/perlfaq8.html" rel="nofollow noreferrer">perlfaq8</a> answers a very similar question with using the <code>rel2abs()</code> function on <code>$0</code>. That function can be found in File::Spec.</p>
<hr><h3>  Answer by daniel souza, Id: 24515046, Score: 2, created_at: 2014-07-01 16:19:13+00:00 </h3><p>There's no need to use external modules, with just one line you can have the file name and relative path. If you are using modules and need to apply a path relative to the script directory, the relative path is enough.</p>

<pre><code>$0 =~ m/(.+)[\/\\](.+)$/;
print "full path: $1, file name: $2\n";
</code></pre>
<h4> Comment by Keve, Score: 0, Id: 63541416, created_at: 2016-06-27 10:12:52+00:00 </h4>It does not provide the proper full path of the script if you run it like &quot;./myscript.pl&quot;, as it would only show &quot;.&quot; instead. But I still like this solution.<hr><h3>  Answer by Yong Li, Id: 5516160, Score: 1, created_at: 2011-04-01 16:27:08+00:00 </h3><p>Are you looking for this?:</p>

<pre><code>my $thisfile = $1 if $0 =~
/\\([^\\]*)$|\/([^\/]*)$/;

print "You are running $thisfile
now.\n";
</code></pre>

<p>The output will look like this:</p>

<pre><code>You are running MyFileName.pl now.
</code></pre>

<p>It works on both Windows and Unix.</p>
<hr><h3>  Answer by mkc, Id: 13566423, Score: 1, created_at: 2012-11-26 14:01:34+00:00 </h3><pre><code>#!/usr/bin/perl -w
use strict;


my $path = $0;
$path =~ s/\.\///g;
if ($path =~ /\//){
  if ($path =~ /^\//){
    $path =~ /^((\/[^\/]+){1,}\/)[^\/]+$/;
    $path = $1;
    }
  else {
    $path =~ /^(([^\/]+\/){1,})[^\/]+$/;
    my $path_b = $1;
    my $path_a = `pwd`;
    chop($path_a);
    $path = $path_a."/".$path_b;
    }
  }
else{
  $path = `pwd`;
  chop($path);
  $path.="/";
  }
$path =~ s/\/\//\//g;



print "\n$path\n";
</code></pre>

<p>:DD</p>
<h4> Comment by Lee Taylor, Score: 4, Id: 18587714, created_at: 2012-11-26 14:21:02+00:00 </h4>Please don&#39;t just answer with code. Please explain why this is the correct answer.<hr><h3>  Answer by DavidGamba, Id: 23149908, Score: 1, created_at: 2014-04-18 07:56:16+00:00 </h3><p>The problem with just using <code>dirname(__FILE__)</code> is that it doesn't follow symlinks. I had to use this for my script to follow the symlink to the actual file location.</p>

<pre><code>use File::Basename;
my $script_dir = undef;
if(-l __FILE__) {
  $script_dir = dirname(readlink(__FILE__));
}
else {
  $script_dir = dirname(__FILE__);
}
</code></pre>
<hr><h3>  Answer by Yordan Georgiev, Id: 6997006, Score: 0, created_at: 2011-08-09 13:36:04+00:00 </h3><pre><code>use strict ; use warnings ; use Cwd 'abs_path';
    sub ResolveMyProductBaseDir { 

        # Start - Resolve the ProductBaseDir
        #resolve the run dir where this scripts is placed
        my $ScriptAbsolutPath = abs_path($0) ; 
        #debug print "\$ScriptAbsolutPath is $ScriptAbsolutPath \n" ;
        $ScriptAbsolutPath =~ m/^(.*)(\\|\/)(.*)\.([a-z]*)/; 
        $RunDir = $1 ; 
        #debug print "\$1 is $1 \n" ;
        #change the \'s to /'s if we are on Windows
        $RunDir =~s/\\/\//gi ; 
        my @DirParts = split ('/' , $RunDir) ; 
        for (my $count=0; $count &lt; 4; $count++) {   pop @DirParts ;     }
        my $ProductBaseDir = join ( '/' , @DirParts ) ; 
        # Stop - Resolve the ProductBaseDir
        #debug print "ResolveMyProductBaseDir $ProductBaseDir is $ProductBaseDir \n" ; 
        return $ProductBaseDir ; 
    } #eof sub 
</code></pre>
<h4> Comment by the Tin Man, Score: 0, Id: 26892223, created_at: 2013-08-19 21:28:17+00:00 </h4>While a source-only answer might solve the user&#39;s question, it doesn&#39;t help them understand why it works. You&#39;ve given the user a fish, but instead you should teach them HOW to fish.<hr><h3>  Answer by Jonathan, Id: 20565937, Score: 0, created_at: 2013-12-13 11:57:26+00:00 </h3><p>The problem with <code>__FILE__</code> is that it will print the core module ".pm" path not necessarily the ".cgi" or  ".pl" script path that is running. I guess it depends on what your goal is.</p>

<p>It seems to me that <a href="http://search.cpan.org/~smueller/PathTools-3.40/" rel="nofollow"><code>Cwd</code></a> just needs to be updated for mod_perl. Here is my suggestion:</p>

<pre><code>my $path;

use File::Basename;
my $file = basename($ENV{SCRIPT_NAME});

if (exists $ENV{MOD_PERL} &amp;&amp; ($ENV{MOD_PERL_API_VERSION} &lt; 2)) {
  if ($^O =~/Win/) {
    $path = `echo %cd%`;
    chop $path;
    $path =~ s!\\!/!g;
    $path .= $ENV{SCRIPT_NAME};
  }
  else {
    $path = `pwd`;
    $path .= "/$file";
  }
  # add support for other operating systems
}
else {
  require Cwd;
  $path = Cwd::getcwd()."/$file";
}
print $path;
</code></pre>

<p>Please add any suggestions.</p>
<hr><h3>  Answer by Putnik, Id: 21605869, Score: 0, created_at: 2014-02-06 14:39:11+00:00 </h3><p>Without any external modules, valid for shell, works well even with '../':</p>

<pre><code>my $self = `pwd`;
chomp $self;
$self .='/'.$1 if $0 =~/([^\/]*)$/; #keep the filename only
print "self=$self\n";
</code></pre>

<p>test:</p>

<pre><code>$ /my/temp/Host$ perl ./host-mod.pl 
self=/my/temp/Host/host-mod.pl

$ /my/temp/Host$ ./host-mod.pl 
self=/my/temp/Host/host-mod.pl

$ /my/temp/Host$ ../Host/./host-mod.pl 
self=/my/temp/Host/host-mod.pl
</code></pre>
<h4> Comment by Znik, Score: 0, Id: 33605645, created_at: 2014-03-03 12:32:47+00:00 </h4>What when you call symlink? Cwd works excellent with this case.<hr><h3>  Answer by Elmar, Id: 25663214, Score: 0, created_at: 2014-09-04 10:32:56+00:00 </h3><p>All the library-free solutions don't actually work for more than a few ways to write a path (think ../ or /bla/x/../bin/./x/../ etc. My solution looks like below. I have one quirk: I don't have the faintest idea why I have to run the replacements twice. If I don't, I get a spurious "./" or "../". Apart from that, it seems quite robust to me.</p>

<pre><code>  my $callpath = $0;
  my $pwd = `pwd`; chomp($pwd);

  # if called relative -&gt; add pwd in front
  if ($callpath !~ /^\//) { $callpath = $pwd."/".$callpath; }  

  # do the cleanup
  $callpath =~ s!^\./!!;                          # starts with ./ -&gt; drop
  $callpath =~ s!/\./!/!g;                        # /./ -&gt; /
  $callpath =~ s!/\./!/!g;                        # /./ -&gt; /        (twice)

  $callpath =~ s!/[^/]+/\.\./!/!g;                # /xxx/../ -&gt; /
  $callpath =~ s!/[^/]+/\.\./!/!g;                # /xxx/../ -&gt; /   (twice)

  my $calldir = $callpath;
  $calldir =~ s/(.*)\/([^\/]+)/$1/;
</code></pre>
<hr><h3>  Answer by drjumper, Id: 52944919, Score: 0, created_at: 2018-10-23 08:51:38+00:00 </h3><p>None of the "top" answers were right for me. The problem with using FindBin '$Bin' or Cwd is that they return absolute path with all symbolic links resolved. In my case I needed the exact path with symbolic links present - the same as returns Unix command "pwd" and not "pwd -P". The following function provides the solution:</p>

<pre><code>sub get_script_full_path {
    use File::Basename;
    use File::Spec;
    use Cwd qw(chdir cwd);
    my $curr_dir = cwd();
    chdir(dirname($0));
    my $dir = $ENV{PWD};
    chdir( $curr_dir);
    return File::Spec-&gt;catfile($dir, basename($0));
}
</code></pre>
<h4> Comment by amphetamachine, Score: 1, Id: 121385901, created_at: 2021-08-06 18:39:36+00:00 </h4>This function has a side effect of modifying working directory of the executing script.<hr><h3>  Answer by user3228609, Id: 58417063, Score: 0, created_at: 2019-10-16 15:39:42+00:00 </h3><p>On Windows using <code>dirname</code> and <code>abs_path</code> together worked best for me.</p>

<pre><code>use File::Basename;
use Cwd qw(abs_path);

# absolute path of the directory containing the executing script
my $abs_dirname = dirname(abs_path($0));
print "\ndirname(abs_path(\$0)) -&gt; $abs_dirname\n";
</code></pre>

<p>here's why:</p>

<pre><code># this gives the answer I want in relative path form, not absolute
my $rel_dirname = dirname(__FILE__); 
print "dirname(__FILE__) -&gt; $rel_dirname\n"; 

# this gives the slightly wrong answer, but in the form I want 
my $full_filepath = abs_path($0);
print "abs_path(\$0) -&gt; $full_filepath\n";
</code></pre>
<hr><h3>  Answer by user3673, Id: 63550144, Score: 0, created_at: 2020-08-23 17:39:37+00:00 </h3><pre><code>use File::Basename;
use Cwd 'abs_path';
print dirname(abs_path(__FILE__)) ;
</code></pre>
<p><a href="https://stackoverflow.com/a/90721/871821">Drew's answer</a> gave me:</p>
<p>'.'</p>
<pre><code>$ cat &gt;testdirname
use File::Basename;
print dirname(__FILE__);
$ perl testdirname
.$ perl -v

This is perl 5, version 28, subversion 1 (v5.28.1) built for x86_64-linux-gnu-thread-multi][1]
</code></pre>
<hr><h3>  Answer by foxxtrot, Id: 84952, Score: -5, created_at: 2008-09-17 16:18:38+00:00 </h3><p>On *nix, you likely have the "whereis" command, which searches your $PATH looking for a binary with a given name.  If $0 doesn't contain the full path name, running whereis $scriptname and saving the result into a variable should tell you where the script is located.</p>
<h4> Comment by Lathan, Score: 0, Id: 8712569, created_at: 2011-08-30 13:20:24+00:00 </h4>That will not work, as $0 could also return a relative path to the file: ../perl/test.pl<h4> Comment by Znik, Score: 0, Id: 41497074, created_at: 2014-10-17 13:26:50+00:00 </h4>what will happen if executable script is out of PATH ?