 <h2> Title: How to iterate over rows in a Pandas DataFrame? </h2> <h3> Roman, question_id: 16476924 </h3>Score: 4035, Tags: {python,pandas,dataframe,loops} <br><p>I have a pandas dataframe, <code>df</code>:</p>
<pre class="lang-none prettyprint-override"><code>   c1   c2
0  10  100
1  11  110
2  12  120
</code></pre>
<p>How do I iterate over the rows of this dataframe? For every row, I want to access its elements (values in cells) by the name of the columns. For example:</p>
<pre class="lang-py prettyprint-override"><code>for row in df.rows:
    print(row['c1'], row['c2'])
</code></pre>
<hr />
<p>I found a <a href="https://stackoverflow.com/questions/7837722/what-is-the-most-efficient-way-to-loop-through-dataframes-with-pandas">similar question</a>, which suggests using either of these:</p>
<ul>
<li>
<pre class="lang-py prettyprint-override"><code>for date, row in df.T.iteritems():
</code></pre>
</li>
<li>
<pre class="lang-py prettyprint-override"><code>for row in df.iterrows():
</code></pre>
</li>
</ul>
<p>But I do not understand what the <code>row</code> object is and how I can work with it.</p>
<h4> Comment 103162518 oulenz: </h4>In contrast to what cs95 says, there are perfectly fine reasons to want to iterate over a dataframe, so new users should not feel discouraged. One example is if you want to execute some code using the values of each row as input. Also, if your dataframe is reasonably small (e.g. less than 1000 items), performance is not really an issue.<br><h4> Comment 134111017 cs95: </h4>If you are a beginner to this thread and are not familiar with the pandas library, it&#39;s worth taking a step back and evaluating whether iteration is indeed the solution to your problem. In some cases, it is. In most cases, it isn&#39;t. It is important to introduce beginners to the library by easing them into the concept of vectorization so they know the difference between writing &quot;good code&quot;, versus &quot;code that just works&quot; - and also know when to use which.<br><h4> Comment 136158671 Gabriel Staples: </h4>Related: <a href="https://stackoverflow.com/q/54028199/4561887">Are for-loops in pandas really bad? When should I care?</a><br><h4> Comment 136698377 Gabriel Staples: </h4>See also: <a href="https://stackoverflow.com/q/7837722/4561887">What is the most efficient way to loop through dataframes with pandas?</a>.<br>------------------------------------------------------------------ <br><h3> Answer 16476974 waitingkuo: </h3><p><a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.iterrows.html#pandas-dataframe-iterrows" rel="noreferrer"><code>DataFrame.iterrows</code></a> is a generator which yields both the index and row (as a Series):</p>
<pre><code>import pandas as pd

df = pd.DataFrame({'c1': [10, 11, 12], 'c2': [100, 110, 120]})
df = df.reset_index()  # make sure indexes pair with number of rows

for index, row in df.iterrows():
    print(row['c1'], row['c2'])
</code></pre>

<pre><code>10 100
11 110
12 120
</code></pre>
<hr />
<p>Obligatory disclaimer from the <a href="https://pandas.pydata.org/docs/user_guide/basics.html#iteration" rel="noreferrer">documentation</a></p>
<blockquote>
<p><strong>Iterating through pandas objects is generally slow. In many cases, iterating manually over the rows is not needed</strong> and can be avoided with one of the following approaches:</p>
<ul>
<li>Look for a vectorized solution: many operations can be performed using built-in methods or NumPy functions, (boolean) indexing, …</li>
<li>When you have a function that cannot work on the full DataFrame/Series at once, it is better to use apply() instead of iterating over the values. See the docs on function application.</li>
<li>If you need to do iterative manipulations on the values but performance is important, consider writing the inner loop with cython or numba. See the enhancing performance section for some examples of this approach.</li>
</ul>
</blockquote>
<p>Other answers in this thread delve into greater depth on alternatives to iter* functions if you are interested to learn more.</p>
<h4> Comment 136491868 Gabriel Staples: </h4>Although <code>.iterrows()</code> works, it is around <b>600x</b> slower than the fastest technique. I speed test and demonstrate 13 ways to iterate over a Pandas DataFrame <a href="https://stackoverflow.com/a/77270285/4561887">in my answer here</a>. <code>.iterrows()</code> is the 2nd slowest. 11 of the 13 techniques are faster than <code>.iterrows()</code>, and most of them are still really easy once you see an example of how to do them.<br>------------------------------------------------------------------ <br><h3> Answer 55557758 cs95: </h3><blockquote>
<h2>How to iterate over rows in a DataFrame in Pandas</h2>
</blockquote>
<h1>Answer: DON'T<sup>*</sup>!</h1>
<p>Iteration in Pandas is an anti-pattern and is something you should only do when you have exhausted every other option. You should not use any function with &quot;<code>iter</code>&quot; in its name for more than a few thousand rows or you will have to get used to a <strong>lot</strong> of waiting.</p>
<p>Do you want to print a DataFrame? Use <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.to_string.html" rel="noreferrer"><strong><code>DataFrame.to_string()</code></strong></a>.</p>
<p>Do you want to compute something? In that case, search for methods in this order (list modified from <a href="https://stackoverflow.com/questions/24870953/does-iterrows-have-performance-issues">here</a>):</p>
<ol>
<li>Vectorization</li>
<li><a href="https://en.wikipedia.org/wiki/Cython" rel="noreferrer">Cython</a> routines</li>
<li>List Comprehensions (vanilla <code>for</code> loop)</li>
<li><a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.apply.html" rel="noreferrer"><strong><code>DataFrame.apply()</code></strong></a>: i)  Reductions that can be performed in Cython, ii) Iteration in Python space</li>
<li><a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.items.html" rel="noreferrer"><strong><code>items()</code></strong></a>  <strike><a href="https://pandas.pydata.org/pandas-docs/version/1.5/reference/api/pandas.DataFrame.iteritems.html" rel="noreferrer"><strong><code>iteritems()</code></strong></a></strike> <sup>(deprecated since v1.5.0)</sup></li>
<li><a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.itertuples.html" rel="noreferrer"><strong><code>DataFrame.itertuples()</code></strong></a></li>
<li><a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.iterrows.html#pandas.DataFrame.iterrows" rel="noreferrer"><strong><code>DataFrame.iterrows()</code></strong></a></li>
</ol>
<p><code>iterrows</code> and <code>itertuples</code> (both receiving many votes in answers to this question) should be used in very rare circumstances, such as generating row objects/nametuples for sequential processing, which is really the only thing these functions are useful for.</p>
<p><strong>Appeal to Authority</strong></p>
<p><a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/basics.html#iteration" rel="noreferrer">The documentation page</a> on iteration has a huge red warning box that says:</p>
<blockquote>
<p>Iterating through pandas objects is generally slow. In many cases, iterating manually over the rows is not needed [...].</p>
</blockquote>
<p><sub>* It's actually a little more complicated than &quot;don't&quot;. <code>df.iterrows()</code> is the correct answer to this question, but &quot;vectorize your ops&quot; is the better one. I will concede that there are circumstances where iteration cannot be avoided (for example, some operations where the result depends on the value computed for the previous row). However, it takes some familiarity with the library to know when. If you're not sure whether you need an iterative solution, you probably don't. PS: To know more about my rationale for writing this answer, skip to the very bottom.</sub></p>
<hr />
<h2>Faster than Looping: <a href="https://stackoverflow.com/questions/1422149/what-is-vectorization">Vectorization</a>, <a href="https://cython.org" rel="noreferrer">Cython</a></h2>
<p>A good number of basic operations and computations are &quot;vectorised&quot; by pandas (either through NumPy, or through Cythonized functions). This includes arithmetic, comparisons, (most) reductions, reshaping (such as pivoting), joins, and groupby operations. Look through the documentation on <a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/basics.html#essential-basic-functionality" rel="noreferrer">Essential Basic Functionality</a> to find a suitable vectorised method for your problem.</p>
<p>If none exists, feel free to write your own using custom <a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/enhancingperf.html#cython-writing-c-extensions-for-pandas" rel="noreferrer">Cython extensions</a>.</p>
<hr />
<h2>Next Best Thing: <a href="https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions" rel="noreferrer">List Comprehensions</a><sup>*</sup></h2>
<p>List comprehensions should be your next port of call if 1) there is no vectorized solution available, 2) performance is important, but not important enough to go through the hassle of cythonizing your code, and 3) you're trying to perform elementwise transformation on your code. There is a <a href="https://stackoverflow.com/questions/54028199/for-loops-with-pandas-when-should-i-care">good amount of evidence</a> to suggest that list comprehensions are sufficiently fast (and even sometimes faster) for many common Pandas tasks.</p>
<p>The formula is simple,</p>
<pre class="lang-py prettyprint-override"><code># Iterating over one column - `f` is some function that processes your data
result = [f(x) for x in df['col']]

# Iterating over two columns, use `zip`
result = [f(x, y) for x, y in zip(df['col1'], df['col2'])]

# Iterating over multiple columns - same data type
result = [f(row[0], ..., row[n]) for row in df[['col1', ...,'coln']].to_numpy()]

# Iterating over multiple columns - differing data type
result = [f(row[0], ..., row[n]) for row in zip(df['col1'], ..., df['coln'])]
</code></pre>
<p>If you can encapsulate your business logic into a function, you can use a list comprehension that calls it. You can make arbitrarily complex things work through the simplicity and speed of raw Python code.</p>
<p><strong>Caveats</strong></p>
<p>List comprehensions assume that your data is easy to work with - what that means is your data types are consistent and you don't have NaNs, but this cannot always be guaranteed.</p>
<ol>
<li>The first one is more obvious, but when dealing with NaNs, prefer in-built pandas methods if they exist (because they have much better corner-case handling logic), or ensure your business logic includes appropriate NaN handling logic.</li>
<li>When dealing with mixed data types you should iterate over <code>zip(df['A'], df['B'], ...)</code> instead of <code>df[['A', 'B']].to_numpy()</code> as the latter implicitly upcasts data to the most common type. As an example if A is numeric and B is string, <code>to_numpy()</code> will cast the entire array to string, which may not be what you want. Fortunately <code>zip</code>ping your columns together is the most straightforward workaround to this.</li>
</ol>
<p><sub>*Your mileage may vary for the reasons outlined in the <strong>Caveats</strong> section above.</sub></p>
<hr />
<h2>An Obvious Example</h2>
<p>Let's demonstrate the difference with a simple example of adding two pandas columns <code>A + B</code>. This is a vectorizable operation, so it will be easy to contrast the performance of the methods discussed above.</p>
<img src="https://i.stack.imgur.com/y44RJ.png" width="600" />
<p><a href="https://gist.github.com/Coldsp33d/948f96b384ca5bdf6e8ce203ac97c9a0" rel="noreferrer">Benchmarking code, for your reference</a>. The line at the bottom measures a function written in numpandas, a style of Pandas that mixes heavily with NumPy to squeeze out maximum performance. Writing numpandas code should be avoided unless you know what you're doing. Stick to the API where you can (i.e., prefer <code>vec</code> over <code>vec_numpy</code>).</p>
<p>I should mention, however, that it isn't always this cut and dry. Sometimes the answer to &quot;what is the best method for an operation&quot; is &quot;it depends on your data&quot;. My advice is to test out different approaches on your data before settling on one.</p>
<hr />
<h2>My Personal Opinion <sup>*</sup></h2>
<p>Most of the analyses performed on the various alternatives to the iter family has been through the lens of performance. However, in most situations you will typically be working on a reasonably sized dataset (nothing beyond a few thousand or 100K rows) and performance will come second to simplicity/readability of the solution.</p>
<p>Here is my personal preference when selecting a method to use for a problem.</p>
<p>For the novice:</p>
<blockquote>
<p><em>Vectorization</em> (when possible)<em>; <code>apply()</code>; List Comprehensions; <code>itertuples()</code>/<code>iteritems()</code>; <code>iterrows()</code>; Cython</em></p>
</blockquote>
<p>For the more experienced:</p>
<blockquote>
<p><em>Vectorization</em> (when possible)<em>; <code>apply()</code>; List Comprehensions; Cython; <code>itertuples()</code>/<code>iteritems()</code>; <code>iterrows()</code></em></p>
</blockquote>
<p>Vectorization prevails as the most idiomatic method for any problem that can be vectorized. Always seek to vectorize! When in doubt, consult the docs, or look on Stack Overflow for an existing question on your particular task.</p>
<p>I do tend to go on about how bad <code>apply</code> is in a lot of my posts, but I do concede it is easier for a beginner to wrap their head around what it's doing. Additionally, there are quite a few use cases for <code>apply</code> has explained in <a href="https://stackoverflow.com/questions/54432583/when-should-i-not-want-to-use-pandas-apply-in-my-code">this post of mine</a>.</p>
<p>Cython ranks lower down on the list because it takes more time and effort to pull off correctly. You will usually never need to write code with pandas that demands this level of performance that even a list comprehension cannot satisfy.</p>
<p><sub>* As with any personal opinion, please take with heaps of salt!</sub></p>
<hr />
<h2>Further Reading</h2>
<ul>
<li><p><a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/10min.html" rel="noreferrer">10 Minutes to pandas</a>, and <a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/basics.html" rel="noreferrer">Essential Basic Functionality</a> - Useful links that introduce you to Pandas and its library of vectorized*/cythonized functions.</p>
</li>
<li><p><a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/enhancingperf.html" rel="noreferrer">Enhancing Performance</a> - A primer from the documentation on enhancing standard Pandas operations</p>
</li>
<li><p><em><a href="https://stackoverflow.com/questions/54028199/for-loops-with-pandas-when-should-i-care">Are for-loops in pandas really bad? When should I care?</a></em> - a detailed write-up by me on list comprehensions and their suitability for various operations (mainly ones involving non-numeric data)</p>
</li>
<li><p><em><a href="https://stackoverflow.com/questions/54432583/when-should-i-ever-want-to-use-pandas-apply-in-my-code">When should I (not) want to use pandas apply() in my code?</a></em> - <code>apply</code> is slow (but not as slow as the <code>iter*</code> family. There are, however, situations where one can (or should) consider <code>apply</code> as a serious alternative, especially in some <code>GroupBy</code> operations).</p>
</li>
</ul>
<p><sub>* Pandas string methods are &quot;vectorized&quot; in the sense that they are specified on the series but operate on each element. The underlying mechanisms are still iterative, because string operations are inherently hard to vectorize.</sub></p>
<hr />
<h2>Why I Wrote this Answer</h2>
<p>A common trend I notice from new users is to ask questions of the form &quot;How can I iterate over my df to do X?&quot;. Showing code that calls <code>iterrows()</code> while doing something inside a <code>for</code> loop. Here is why. A new user to the library who has not been introduced to the concept of vectorization will likely envision the code that solves their problem as iterating over their data to do something. Not knowing how to iterate over a DataFrame, the first thing they do is Google it and end up here, at this question. They then see the accepted answer telling them how to, and they close their eyes and run this code without ever first questioning if iteration is the right thing to do.</p>
<p>The aim of this answer is to help new users understand that iteration is not necessarily the solution to every problem, and that better, faster and more idiomatic solutions could exist, and that it is worth investing time in exploring them. I'm not trying to start a war of iteration vs. vectorization, but I want new users to be informed when developing solutions to their problems with this library.</p>
<p>And finally ... a TLDR to summarize this post</p>
<p><a href="https://i.stack.imgur.com/FYfgi.jpg" rel="noreferrer"><img src="https://i.stack.imgur.com/FYfgi.jpg" alt="enter image description here" /></a></p>
<h4> Comment 136020567 Timus: </h4>@GabrielStaples Look <a href="https://pandas.pydata.org/docs/user_guide/indexing.html#basics" rel="nofollow noreferrer">here</a>: <i>&quot;... You can pass a list of columns to <code>[]</code> to select columns in that order. ...&quot;</i><br><h4> Comment 136222735 Gabriel Staples: </h4>I used a lot of what you said and ran with it. Check out <a href="https://stackoverflow.com/a/77270285/4561887">these 13 techniques I came up with and the plot that shows their speed differences</a>. Pure vectorization is <b>1400x</b> faster. List comprehension is pretty good too!<br><h4> Comment 135984293 b_dev: </h4>Iterating could be a tool to help during debugging, say with ipdb, especially during initial development and understanding of edge cases.<br><h4> Comment 136017861 Gabriel Staples: </h4>What is the double-bracket syntax here? What does it mean and where is it officially documented? <code>df[[&#39;col1&#39;, ...,&#39;coln&#39;]].to_numpy()</code><br>------------------------------------------------------------------ <br><h3> Answer 41022840 viddik13: </h3><p>First consider if you really need to <em>iterate</em> over rows in a DataFrame. See <a href="https://stackoverflow.com/a/55557758/3844376">cs95's answer</a> for alternatives.</p>
<p>If you still need to iterate over rows, you can use methods below. Note some  <strong>important caveats</strong> which are not mentioned in any of the other answers.</p>
<ul>
<li><p><a href="http://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.iterrows.html" rel="noreferrer">DataFrame.iterrows()</a></p>
<pre><code>for index, row in df.iterrows():
    print(row[&quot;c1&quot;], row[&quot;c2&quot;])
</code></pre>
</li>
<li><p><a href="http://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.itertuples.html" rel="noreferrer">DataFrame.itertuples()</a></p>
<pre><code>for row in df.itertuples(index=True, name='Pandas'):
    print(row.c1, row.c2)
</code></pre>
</li>
</ul>
<p><code>itertuples()</code> is supposed to be faster than <code>iterrows()</code></p>
<p>But be aware, according to the docs (pandas 0.24.2 at the moment):</p>
<ul>
<li>iterrows: <code>dtype</code> might not match from row to row
<blockquote>
<p>Because iterrows returns a Series for each row, it <strong>does not preserve</strong> dtypes across the rows (dtypes are preserved across columns for DataFrames). To preserve dtypes while iterating over the rows, it is better to use itertuples() which returns namedtuples of the values and which is generally much faster than iterrows()</p>
</blockquote>
</li>
</ul>
<ul>
<li><p>iterrows: Do not modify rows</p>
<blockquote>
<p>You should <strong>never modify</strong> something you are iterating over. This is not guaranteed to work in all cases. Depending on the data types, the iterator returns a copy and not a view, and writing to it will have no effect.</p>
</blockquote>
<p>Use <a href="http://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.apply.html" rel="noreferrer">DataFrame.apply()</a> instead:</p>
<pre><code>new_df = df.apply(lambda x: x * 2, axis=1)
</code></pre>
</li>
<li><p>itertuples:</p>
<blockquote>
<p>The column names will be renamed to positional names if they are invalid Python identifiers, repeated, or start with an underscore. With a large number of columns (&gt;255), regular tuples are returned.</p>
</blockquote>
</li>
</ul>
<p>See <a href="https://pandas.pydata.org/docs/user_guide/basics.html#iteration" rel="noreferrer">pandas docs on iteration</a> for more details.</p>
<h4> Comment 89180584 Brian Burns: </h4>Note: you can also say something like <code>for row in df[[&#39;c1&#39;,&#39;c2&#39;]].itertuples(index=True, name=None):</code> to include only certain columns in the row iterator.<br><h4> Comment 124151002 Muhammad Yasirroni: </h4>I don&#39;t know why, but using <code>name=None</code> make <code>itertuples</code> 50% faster in my use case.<br>------------------------------------------------------------------ <br><h3> Answer 10739432 Wes McKinney: </h3><p>You should use <a href="http://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.iterrows.html" rel="noreferrer"><code>df.iterrows()</code></a>. Though iterating row-by-row is not especially efficient since <code>Series</code> objects have to be created.</p>
<h4> Comment 56363619 Richard Wong: </h4>I have done a bit of testing on the time consumption for df.iterrows(), df.itertuples(), and zip(df[&#39;a&#39;], df[&#39;b&#39;]) and posted the result in the answer of another question: <a href="http://stackoverflow.com/a/34311080/2142098">stackoverflow.com/a/34311080/2142098</a><br>------------------------------------------------------------------ <br><h3> Answer 32680162 e9t: </h3><p>While <code>iterrows()</code> is a good option, sometimes <code>itertuples()</code> can be much faster:</p>

<pre><code>df = pd.DataFrame({'a': randn(1000), 'b': randn(1000),'N': randint(100, 1000, (1000)), 'x': 'x'})

%timeit [row.a * 2 for idx, row in df.iterrows()]
# =&gt; 10 loops, best of 3: 50.3 ms per loop

%timeit [row[1] * 2 for row in df.itertuples()]
# =&gt; 1000 loops, best of 3: 541 µs per loop
</code></pre>
<h4> Comment 53208434 Alex: </h4>Much of the time difference in your two examples seems like it is due to the fact that you appear to be using label-based indexing for the .iterrows() command and integer-based indexing for the .itertuples() command.<br><h4> Comment 71581133 miradulo: </h4>@AbeMiessler <code>iterrows()</code> boxes each row of data into a Series, whereas <code>itertuples()</code>does not.<br><h4> Comment 93283838 Ajasja: </h4>I get a &gt;50 times increase as well <a href="https://i.stack.imgur.com/HBe9o.png" rel="nofollow noreferrer">i.stack.imgur.com/HBe9o.png</a> (while changing to attr accessor in the second run).<br>------------------------------------------------------------------ <br><h3> Answer 39370553 PJay: </h3><p>You can use the <a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.iloc.html" rel="noreferrer"><code>df.iloc</code></a> function as follows:</p>
<pre class="lang-py prettyprint-override"><code>for i in range(0, len(df)):
    print(df.iloc[i]['c1'], df.iloc[i]['c2'])
</code></pre>
<h4> Comment 83643245 Ken Williams: </h4>This is the only valid technique I know of if you want to preserve the data types, and also refer to columns by name.  <code>itertuples</code> preserves data types, but gets rid of any name it doesn&#39;t like.  <code>iterrows</code> does the opposite.<br>------------------------------------------------------------------ <br><h3> Answer 30566899 cheekybastard: </h3><p>You can also use <code>df.apply()</code> to iterate over rows and access multiple columns for a function.</p>
<p><a href="http://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.apply.html" rel="nofollow noreferrer">docs: DataFrame.apply()</a></p>
<pre><code>def valuation_formula(x, y):
    return x * y * 0.5

df['price'] = df.apply(lambda row: valuation_formula(row['x'], row['y']), axis=1)
</code></pre>
<p>Note that <code>axis=1</code> here is the same as <code>axis='columns'</code>, and is used do apply the function to each <em>row</em> instead of to each <em>column</em>. If unspecified, the default behavior is to apply to the function to each <em>column</em>.</p>
<h4> Comment 86313667 gented: </h4>Notice that <code>apply</code> doesn&#39;t &quot;iteratite&quot; over rows, rather it applies a function row-wise. The above code wouldn&#39;t work if you really <i>do</i> need iterations and indeces, for instance when comparing values across different rows (in that case you can do nothing but iterating).<br><h4> Comment 135973412 Gabriel Staples: </h4>@gented, that&#39;s not exactly true. To get access to values in a previous row, for instance, you can simply add a new column containing previous-row values, like this: <code>dataframe[&quot;val_previous&quot;] = dataframe[&quot;val&quot;].shift(1)</code>. Then, you could access this <code>val_previous</code> variable in a given row using this answer.<br>------------------------------------------------------------------ <br><h3> Answer 59413206 Romain Capron: </h3><h2>How to iterate efficiently</h2>
<p>If you really have to iterate a Pandas <code>DataFrame</code>, you will probably want to <strong>avoid using <code>iterrows()</code></strong>. There are different methods, and the usual <code>iterrows()</code> is far from being the best. <strong>`itertuples()`` can be 100 times faster.</strong></p>
<p><strong>In short:</strong></p>
<ul>
<li>As a general rule, use <code>df.itertuples(name=None)</code>. In particular, when you have a fixed number columns and fewer than 255 columns. <em>See bullet (3) below.</em></li>
<li>Otherwise, use <code>df.itertuples()</code>, except if your columns have special characters such as spaces or <code>-</code>. <em>See bullet (2) below.</em></li>
<li>It is possible to use <code>itertuples()</code> even if your dataframe has strange columns, by using the last example below. <em>See bullet (4) below.</em></li>
<li>Only use <code>iterrows()</code> if you cannot use any of the previous solutions. <em>See bullet (1) below.</em></li>
</ul>
<h2>Different methods to iterate over rows in a Pandas <code>DataFrame</code>:</h2>
<p>First, for use in all examples below, generate a random dataframe with a million rows and 4 columns, like this:</p>
<pre class="lang-py prettyprint-override"><code>df = pd.DataFrame(np.random.randint(0, 100, size=(1000000, 4)), columns=list('ABCD'))
print(df)
</code></pre>
<p>The output of all of these examples is shown at the bottom.</p>
<ol>
<li><p>The usual <code>iterrows()</code> is convenient, but damn slow:</p>
<pre class="lang-py prettyprint-override"><code>start_time = time.clock()
result = 0
for _, row in df.iterrows():
    result += max(row['B'], row['C'])

total_elapsed_time = round(time.clock() - start_time, 2)
print(&quot;1. Iterrows done in {} seconds, result = {}&quot;.format(total_elapsed_time, result))
</code></pre>
</li>
<li><p>Using the default <em>named</em> <code>itertuples()</code> is already much faster, but it doesn't work with column names such as <code>My Col-Name is very Strange</code> (you should avoid this method if your columns are repeated or if a column name cannot be simply converted to a Python variable name).:</p>
<pre class="lang-py prettyprint-override"><code>start_time = time.clock()
result = 0
for row in df.itertuples(index=False):
    result += max(row.B, row.C)

total_elapsed_time = round(time.clock() - start_time, 2)
print(&quot;2. Named Itertuples done in {} seconds, result = {}&quot;.format(total_elapsed_time, result))
</code></pre>
</li>
<li><p>Using <em>nameless</em> <code>itertuples()</code> by setting <code>name=None</code> is even faster, but not really convenient, as you have to define a variable per column.</p>
<pre class="lang-py prettyprint-override"><code>start_time = time.clock()
result = 0
for(_, col1, col2, col3, col4) in df.itertuples(name=None):
    result += max(col2, col3)

total_elapsed_time = round(time.clock() - start_time, 2)
print(&quot;3. Itertuples done in {} seconds, result = {}&quot;.format(total_elapsed_time, result))
</code></pre>
</li>
<li><p>Finally, using <em>polyvalent</em> <code>itertuples()</code> is slower than the previous example, but you do not have to define a variable per column and it works with column names such as <code>My Col-Name is very Strange</code>.</p>
<pre class="lang-py prettyprint-override"><code>start_time = time.clock()
result = 0
for row in df.itertuples(index=False):
    result += max(row[df.columns.get_loc('B')], row[df.columns.get_loc('C')])

total_elapsed_time = round(time.clock() - start_time, 2)
print(&quot;4. Polyvalent Itertuples working even with special characters in the column name done in {} seconds, result = {}&quot;.format(total_elapsed_time, result))
</code></pre>
</li>
</ol>
<p>Output of all code and examples above:</p>
<pre class="lang-none prettyprint-override"><code>         A   B   C   D
0       41  63  42  23
1       54   9  24  65
2       15  34  10   9
3       39  94  82  97
4        4  88  79  54
...     ..  ..  ..  ..
999995  48  27   4  25
999996  16  51  34  28
999997   1  39  61  14
999998  66  51  27  70
999999  51  53  47  99

[1000000 rows x 4 columns]

1. Iterrows done in 104.96 seconds, result = 66151519
2. Named Itertuples done in 1.26 seconds, result = 66151519
3. Itertuples done in 0.94 seconds, result = 66151519
4. Polyvalent Itertuples working even with special characters in the column name done in 2.94 seconds, result = 66151519
</code></pre>
<p>Plot of these results <a href="https://stackoverflow.com/a/77270285/4561887">from @Gabriel Staples in his answer here</a>:</p>
<p><a href="https://i.stack.imgur.com/ws9db.png" rel="nofollow noreferrer"><img src="https://i.stack.imgur.com/ws9db.png" alt="enter image description here" /></a></p>
<h2>See also</h2>
<ol>
<li><a href="https://medium.com/swlh/why-pandas-itertuples-is-faster-than-iterrows-and-how-to-make-it-even-faster-bc50c0edd30d" rel="nofollow noreferrer">This article is a very interesting comparison between <code>iterrows()</code> and <code>itertuples()</code></a></li>
</ol>
------------------------------------------------------------------ <br><h3> Answer 48297889 Lucas B: </h3><p>I was looking for <strong>How to iterate on rows</strong> <strong><em>and</em></strong> <strong>columns</strong> and ended here so:</p>

<pre><code>for i, row in df.iterrows():
    for j, column in row.iteritems():
        print(column)
</code></pre>
------------------------------------------------------------------ <br><h3> Answer 70096237 Sachin: </h3><p>We have multiple options to do the same, and lots of folks have shared their answers.</p>
<p>I found the below two methods easy and efficient to do:</p>
<ol>
<li><a href="http://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.iterrows.html" rel="noreferrer">DataFrame.iterrows()</a></li>
<li><a href="http://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.itertuples.html" rel="noreferrer">DataFrame.itertuples()</a></li>
</ol>
<p>Example:</p>
<pre><code> import pandas as pd
 inp = [{'c1':10, 'c2':100}, {'c1':11,'c2':110}, {'c1':12,'c2':120}]
 df = pd.DataFrame(inp)
 print (df)

 # With the iterrows method

 for index, row in df.iterrows():
     print(row[&quot;c1&quot;], row[&quot;c2&quot;])

 # With the itertuples method

 for row in df.itertuples(index=True, name='Pandas'):
     print(row.c1, row.c2)
</code></pre>
<p>Note: itertuples() is supposed to be faster than iterrows()</p>
------------------------------------------------------------------ <br><h3> Answer 47149876 piRSquared: </h3><p>You can write your own iterator that implements <code>namedtuple</code></p>

<pre><code>from collections import namedtuple

def myiter(d, cols=None):
    if cols is None:
        v = d.values.tolist()
        cols = d.columns.values.tolist()
    else:
        j = [d.columns.get_loc(c) for c in cols]
        v = d.values[:, j].tolist()

    n = namedtuple('MyTuple', cols)

    for line in iter(v):
        yield n(*line)
</code></pre>

<p>This is directly comparable to <code>pd.DataFrame.itertuples</code>.  I'm aiming at performing the same task with more efficiency.</p>

<hr>

<p>For the given dataframe with my function:</p>

<pre><code>list(myiter(df))

[MyTuple(c1=10, c2=100), MyTuple(c1=11, c2=110), MyTuple(c1=12, c2=120)]
</code></pre>

<p>Or with <code>pd.DataFrame.itertuples</code>:</p>

<pre><code>list(df.itertuples(index=False))

[Pandas(c1=10, c2=100), Pandas(c1=11, c2=110), Pandas(c1=12, c2=120)]
</code></pre>

<hr>

<p><strong>A comprehensive test</strong><br>
We test making all columns available and subsetting the columns.  </p>

<pre><code>def iterfullA(d):
    return list(myiter(d))

def iterfullB(d):
    return list(d.itertuples(index=False))

def itersubA(d):
    return list(myiter(d, ['col3', 'col4', 'col5', 'col6', 'col7']))

def itersubB(d):
    return list(d[['col3', 'col4', 'col5', 'col6', 'col7']].itertuples(index=False))

res = pd.DataFrame(
    index=[10, 30, 100, 300, 1000, 3000, 10000, 30000],
    columns='iterfullA iterfullB itersubA itersubB'.split(),
    dtype=float
)

for i in res.index:
    d = pd.DataFrame(np.random.randint(10, size=(i, 10))).add_prefix('col')
    for j in res.columns:
        stmt = '{}(d)'.format(j)
        setp = 'from __main__ import d, {}'.format(j)
        res.at[i, j] = timeit(stmt, setp, number=100)

res.groupby(res.columns.str[4:-1], axis=1).plot(loglog=True);
</code></pre>

<p><a href="https://i.stack.imgur.com/rt88e.png" rel="noreferrer"><img src="https://i.stack.imgur.com/rt88e.png" alt="enter image description here"></a></p>

<p><a href="https://i.stack.imgur.com/azbOF.png" rel="noreferrer"><img src="https://i.stack.imgur.com/azbOF.png" alt="enter image description here"></a></p>
<h4> Comment 82152350 James L.: </h4>For people who don&#39;t want to read the code: blue line is <code>intertuples</code>, orange line is a list of an iterator thru a yield block. <code>interrows</code> is not compared.<br>------------------------------------------------------------------ <br><h3> Answer 42741552 Pedro Lobito: </h3><p>To loop all rows in a <code>dataframe</code> you can use:</p>

<pre><code>for x in range(len(date_example.index)):
    print date_example['Date'].iloc[x]
</code></pre>
<h4> Comment 98187416 cs95: </h4>If you want to make this work, call df.columns.get_loc to get the integer index position of the date column (outside the loop), then use a single iloc indexing call inside.<br>------------------------------------------------------------------ <br><h3> Answer 47073107 Grag2015: </h3><pre><code> for ind in df.index:
     print df['c1'][ind], df['c2'][ind]
</code></pre>
<h4> Comment 98185895 cs95: </h4>This is chained indexing. Do not use this!<br>------------------------------------------------------------------ <br><h3> Answer 51069586 Zach: </h3><p>Sometimes a useful pattern is:</p>

<pre><code># Borrowing @KutalmisB df example
df = pd.DataFrame({'col1': [1, 2], 'col2': [0.1, 0.2]}, index=['a', 'b'])
# The to_dict call results in a list of dicts
# where each row_dict is a dictionary with k:v pairs of columns:value for that row
for row_dict in df.to_dict(orient='records'):
    print(row_dict)
</code></pre>

<p>Which results in:</p>

<pre><code>{'col1':1.0, 'col2':0.1}
{'col1':2.0, 'col2':0.2}
</code></pre>
------------------------------------------------------------------ <br><h3> Answer 60836700 bug_spray: </h3><p><strong>Update</strong>: cs95 has updated <a href="https://stackoverflow.com/questions/16476924/how-to-iterate-over-rows-in-a-dataframe-in-pandas/55557758#55557758">his answer</a> to include plain numpy vectorization. You can simply refer to his answer.</p>
<hr />
<p><a href="https://stackoverflow.com/questions/16476924/how-to-iterate-over-rows-in-a-dataframe-in-pandas/55557758#55557758">cs95 shows</a> that Pandas vectorization far outperforms other Pandas methods for computing stuff with dataframes.</p>
<p>I wanted to add that if you first convert the dataframe to a NumPy array and then use vectorization, it's even faster than Pandas dataframe vectorization, (and that includes the time to turn it back into a dataframe series).</p>
<p>If you add the following functions to cs95's benchmark code, this becomes pretty evident:</p>
<pre class="lang-py prettyprint-override"><code>def np_vectorization(df):
    np_arr = df.to_numpy()
    return pd.Series(np_arr[:,0] + np_arr[:,1], index=df.index)

def just_np_vectorization(df):
    np_arr = df.to_numpy()
    return np_arr[:,0] + np_arr[:,1]
</code></pre>
<p><a href="https://i.stack.imgur.com/L0u4A.png" rel="noreferrer"><img src="https://i.stack.imgur.com/L0u4A.png" alt="Enter image description here" /></a></p>
<h4> Comment 121960481 bug_spray: </h4><a href="https://gist.github.com/Coldsp33d/948f96b384ca5bdf6e8ce203ac97c9a0/revisions" rel="nofollow noreferrer">cs95&#39;s benchmarking code, for your reference</a><br>------------------------------------------------------------------ <br><h3> Answer 49984074 Herpes Free Engineer: </h3><p>To loop all rows in a <code>dataframe</code> and <strong>use</strong> values of each row <strong>conveniently</strong>, <code>namedtuples</code> can be converted to <code>ndarray</code>s. For example:</p>

<pre><code>df = pd.DataFrame({'col1': [1, 2], 'col2': [0.1, 0.2]}, index=['a', 'b'])
</code></pre>

<p>Iterating over the rows:</p>

<pre><code>for row in df.itertuples(index=False, name='Pandas'):
    print np.asarray(row)
</code></pre>

<p>results in:</p>

<pre><code>[ 1.   0.1]
[ 2.   0.2]
</code></pre>

<p>Please note that if <code>index=True</code>, <strong>the index is added as the first element of the tuple</strong>, which may be undesirable for some applications.</p>
------------------------------------------------------------------ <br><h3> Answer 58436037 Zeitgeist: </h3><p>There is a way to iterate throw rows while getting a DataFrame in return, and not a Series. I don't see anyone mentioning that you can pass index as a list for the row to be returned as a DataFrame:</p>

<pre><code>for i in range(len(df)):
    row = df.iloc[[i]]
</code></pre>

<p>Note the usage of double brackets. This returns a DataFrame with a single row.</p>
------------------------------------------------------------------ <br><h3> Answer 62136475 artoby: </h3><p>In short</p>
<ul>
<li>Use vectorization if possible</li>
<li>If an operation can't be vectorized - use list comprehensions</li>
<li>If you need a single object representing the entire row - use itertuples</li>
<li>If the above is too slow - try <em>swifter.apply</em></li>
<li>If it's still too slow - try a <a href="https://en.wikipedia.org/wiki/Cython" rel="noreferrer">Cython</a> routine</li>
</ul>
<h3>Benchmark</h3>
<p><a href="https://i.stack.imgur.com/ytaWK.png" rel="noreferrer"><img src="https://i.stack.imgur.com/ytaWK.png" alt="Benchmark of iteration over rows in a Pandas DataFrame" /></a></p>
<h4> Comment 132511413 JohnE: </h4>Cython will help ofc but numpy/numba probably more accessible for most people<br>------------------------------------------------------------------ <br><h3> Answer 66481258 dna-data: </h3><p>Use <code>df.iloc[]</code>. For example, using dataframe 'rows_df':</p>
<p><a href="https://i.stack.imgur.com/eRESg.png" rel="nofollow noreferrer"><img src="https://i.stack.imgur.com/eRESg.png" alt="Enter image description here" /></a></p>
<p><em>Or</em></p>
<p>To get values from a specific row, you can convert the dataframe into ndarray.</p>
<p>Then select the row and column values like this:</p>
<p><a href="https://i.stack.imgur.com/7iMUn.png" rel="nofollow noreferrer"><img src="https://i.stack.imgur.com/7iMUn.png" alt="Enter image description here" /></a></p>
<h4> Comment 117585284 Scratte: </h4>Consider not posting code in images, but as text in a code block.<br>------------------------------------------------------------------ <br><h3> Answer 65396738 JohnE: </h3><h2>Sometimes loops really are better than vectorized code</h2>
<p>As many answers here correctly point out, your default plan in Pandas should be to write vectorized code (with its implicit loops) rather than attempting an explicit loop yourself.  But the question remains whether you should <em>ever</em> write loops in Pandas, and if so what's the best way to loop in those situations.</p>
<p><strong>I believe there is at least one general situation where loops are appropriate: when you need to calculate some function that depends on values in <em>other</em> rows in a somewhat complex manner.  In this case, the looping code is often simpler, more readable, and less error prone than vectorized code.</strong></p>
<p><strong>The looping code might even be faster too</strong>, as you'll see below, so loops might make sense in cases where speed is of utmost importance. But really, those are just going to be subsets of cases where you probably should have been working in numpy/numba (rather than Pandas) to begin with, because optimized numpy/numba will almost always be faster than Pandas.</p>
<p>Let's show this with an example.  Suppose you want to take a cumulative sum of a column, but reset it whenever some other column equals zero:</p>
<pre><code>import pandas as pd
import numpy as np

df = pd.DataFrame( { 'x':[1,2,3,4,5,6], 'y':[1,1,1,0,1,1]  } )

#   x  y  desired_result
#0  1  1               1
#1  2  1               3
#2  3  1               6
#3  4  0               4
#4  5  1               9
#5  6  1              15
</code></pre>
<p>This is a good example where you could certainly write one line of Pandas to achieve this, although it's not especially readable, especially if you aren't fairly experienced with Pandas already:</p>
<pre><code>df.groupby( (df.y==0).cumsum() )['x'].cumsum()
</code></pre>
<p>That's going to be fast enough for most situations, although you could also write faster code by avoiding the <code>groupby</code>, but it will likely be even less readable.</p>
<p>Alternatively, what if we write this as a loop?  You could do something like the following with NumPy:</p>
<pre><code>import numba as nb

@nb.jit(nopython=True)  # Optional
def custom_sum(x,y):
    x_sum = x.copy()
    for i in range(1,len(df)):
        if y[i] &gt; 0: x_sum[i] = x_sum[i-1] + x[i]
    return x_sum

df['desired_result'] = custom_sum( df.x.to_numpy(), df.y.to_numpy() )
</code></pre>
<p>Admittedly, there's a bit of overhead there required to convert DataFrame columns to NumPy arrays, but the core piece of code is just one line of code that you could read even if you didn't know anything about Pandas or NumPy:</p>
<pre><code>if y[i] &gt; 0: x_sum[i] = x_sum[i-1] + x[i]
</code></pre>
<p>And this code is actually <em>faster</em> than the vectorized code.  In some quick tests with 100,000 rows, the above is about 10x faster than the <em>groupby</em> approach.  Note that one key to the speed there is numba, which is optional.  Without the &quot;@nb.jit&quot; line, the looping code is actually about 10x slower than the <em>groupby</em> approach.</p>
<p>Clearly this example is simple enough that you would likely prefer the one line of pandas to writing a loop with its associated overhead.  However, there are more complex versions of this problem for which the readability or speed of the NumPy/numba loop approach likely makes sense.</p>
------------------------------------------------------------------ <br><h3> Answer 75516239 Jordy: </h3><p>I recommend using <code>df.at[row, column]</code> (<a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.at.html" rel="noreferrer">source</a>) for iterate all pandas cells.</p>
<p>For example :</p>
<pre><code>for row in range(len(df)):
  print(df.at[row, 'c1'], df.at[row, 'c2'])
</code></pre>
<p>The output will be:</p>
<pre><code>10 100
11 110
12 120
</code></pre>
<hr />
<h1>Bonus</h1>
<p>You can also modify the value of cells with <code>df.at[row, column] = newValue</code>.</p>
<pre class="lang-py prettyprint-override"><code>for row in range(len(df)):
  df.at[row, 'c1'] = 'data-' + str(df.at[row, 'c1'])
  print(df.at[row, 'c1'], df.at[row, 'c2']) 
</code></pre>
<p>The output will be:</p>
<pre><code>data-10 100
data-11 110
data-12 120
</code></pre>
------------------------------------------------------------------ <br><h3> Answer 54896256 Hossein Kalbasi: </h3><p>For both viewing and modifying values, I would use <code>iterrows()</code>. In a for loop and by using tuple unpacking (see the example: <code>i, row</code>), I use the <code>row</code> for only viewing the value and use <code>i</code> with the <code>loc</code> method when I want to modify values. As stated in previous answers, here you should not modify something you are iterating over.</p>

<pre><code>for i, row in df.iterrows():
    df_column_A = df.loc[i, 'A']
    if df_column_A == 'Old_Value':
        df_column_A = 'New_value'  
</code></pre>

<p>Here the <code>row</code> in the loop is a copy of that row, and not a view of it. Therefore, you should NOT write something like <code>row['A'] = 'New_Value'</code>, it will not modify the DataFrame. However, you can use <code>i</code> and <code>loc</code> and specify the DataFrame to do the work.</p>
------------------------------------------------------------------ <br><h3> Answer 77270285 Gabriel Staples: </h3><p>Key takeaways:</p>
<ol>
<li>Use vectorization.</li>
<li><strong>Speed profile</strong> your code! Don't assume something is faster because you <em>think</em> it is faster; speed profile it and <em>prove</em> it is faster. The results may surprise you.</li>
</ol>
<h2>How to iterate over Pandas <code>DataFrame</code>s without iterating</h2>
<p>After <em>several weeks</em> of working on this answer, here's what I've come up with:</p>
<p>Here are <strong>13 techniques for iterating over Pandas <code>DataFrame</code>s</strong>. As you can see, the time it takes varies <em>dramatically</em>. The fastest technique is <strong>~1363x</strong> faster than the slowest technique! The key takeaway, <a href="https://stackoverflow.com/a/55557758/4561887">as @cs95 says here</a>, is <strong><em>don't</em> iterate! Use vectorization (<a href="https://en.wikipedia.org/wiki/Array_programming" rel="nofollow noreferrer">&quot;array programming&quot;</a>) instead.</strong> All this really means is that you should use the arrays directly in mathematical formulas rather than trying to manually iterate over the arrays. The underlying objects must support this, of course, but both Numpy and Pandas <em>do</em>.</p>
<p>There are many ways to use vectorization in Pandas, which you can see in the plot and in my example code below. When using the arrays directly, the underlying looping still takes place, but in (I think) very optimized underlying C code rather than through raw Python.</p>
<h2>Results</h2>
<p>13 techniques, numbered 1 to 13, were tested. The technique number and name is underneath each bar. The total calculation time is above each bar. Underneath that is the multiplier to show how much longer it took than the fastest technique to the far right:</p>
<p><sub>From <a href="https://github.com/ElectricRCAircraftGuy/eRCaGuy_hello_world/blob/master/python/pandas_dataframe_iteration_vs_vectorization_vs_list_comprehension_speed_tests.svg" rel="nofollow noreferrer"><code>pandas_dataframe_iteration_vs_vectorization_vs_list_comprehension_speed_tests.svg</code></a> in my <a href="https://github.com/ElectricRCAircraftGuy/eRCaGuy_hello_world" rel="nofollow noreferrer">eRCaGuy_hello_world</a> repo (produced by <a href="https://github.com/ElectricRCAircraftGuy/eRCaGuy_hello_world/blob/master/python/pandas_dataframe_iteration_vs_vectorization_vs_list_comprehension_speed_tests.py" rel="nofollow noreferrer">this code</a>).</sub></p>
<p><a href="https://i.stack.imgur.com/5biMy.png" rel="nofollow noreferrer"><img src="https://i.stack.imgur.com/5biMy.png" alt="enter image description here" /></a></p>
<h2>Summary</h2>
<p><strong>List comprehension</strong> and <strong>vectorization</strong> (possibly with <strong>boolean indexing</strong>) are all you really need.</p>
<p>Use <strong>list comprehension</strong> (good) and <strong>vectorization</strong> (best). Pure vectorization I think is <em>always</em> possible, but may take extra work in complicated calculations. Search this answer for <strong>&quot;boolean indexing&quot;</strong>, <strong>&quot;boolean array&quot;</strong>, and <strong>&quot;boolean mask&quot;</strong> (all three are the same thing) to see some of the more complicated cases where pure vectorization can thereby be used.</p>
<h4>Here are the 13 techniques, listed in order of <em>fastest first to slowest last</em>. I recommend <em>never</em> using the last (slowest) 3 to 4 techniques.</h4>
<ol>
<li>Technique 8: <code>8_pure_vectorization__with_df.loc[]_boolean_array_indexing_for_if_statment_corner_case</code></li>
<li>Technique 6: <code>6_vectorization__with_apply_for_if_statement_corner_case</code></li>
<li>Technique 7: <code>7_vectorization__with_list_comprehension_for_if_statment_corner_case</code></li>
<li>Technique 11: <code>11_list_comprehension_w_zip_and_direct_variable_assignment_calculated_in_place</code></li>
<li>Technique 10: <code>10_list_comprehension_w_zip_and_direct_variable_assignment_passed_to_func</code></li>
<li>Technique 12: <code>12_list_comprehension_w_zip_and_row_tuple_passed_to_func</code></li>
<li>Technique 5: <code>5_itertuples_in_for_loop</code></li>
<li>Technique 13: <code>13_list_comprehension_w__to_numpy__and_direct_variable_assignment_passed_to_func</code></li>
<li>Technique 9: <code>9_apply_function_with_lambda</code></li>
<li>Technique 1: <code>1_raw_for_loop_using_regular_df_indexing</code></li>
<li>Technique 2: <code>2_raw_for_loop_using_df.loc[]_indexing</code></li>
<li>Technique 4: <code>4_iterrows_in_for_loop</code></li>
<li>Technique 3: <code>3_raw_for_loop_using_df.iloc[]_indexing</code></li>
</ol>
<h4>Rules of thumb:</h4>
<ol>
<li>Techniques 3, 4, and 2 should <em>never</em> be used. They are super slow and have no advantages whatsoever. Keep in mind though: it's not the indexing technique, such as <code>.loc[]</code> or <code>.iloc[]</code> that makes these techniques bad, but rather, it's <em>the <code>for</code> loop they are in</em> that makes them bad! I use <code>.loc[]</code> inside the fastest (pure vectorization) approach, for instance! So, here are the 3 slowest techniques which should <em>never</em> be used:
<ol>
<li><code>3_raw_for_loop_using_df.iloc[]_indexing</code></li>
<li><code>4_iterrows_in_for_loop</code></li>
<li><code>2_raw_for_loop_using_df.loc[]_indexing</code></li>
</ol>
</li>
<li>Technique <code>1_raw_for_loop_using_regular_df_indexing</code> should never be used either, but if you're going to use a raw for loop, it's faster than the others.</li>
<li>The <strong><code>.apply()</code></strong> function (<code>9_apply_function_with_lambda</code>) is ok, but generally speaking, I'd avoid it too. Technique <code>6_vectorization__with_apply_for_if_statement_corner_case</code> did perform better than <code>7_vectorization__with_list_comprehension_for_if_statment_corner_case</code>, however, which is interesting.</li>
<li><strong>List comprehension</strong> is great! It's not the fastest, but it is easy to use and very fast!
<ol>
<li>The nice thing about it is that it can be used with <em>any</em> function that is intended to work on individual values, or array values. And this means you could have really complicated <code>if</code> statements and things inside the function. So, the tradeoff here is that it gives you great versatility with really readable and re-usable code by using external calculation functions, while still giving you great speed!</li>
</ol>
</li>
<li><strong>Vectorization</strong> is the fastest and best, and what you should use whenever the equation is simple. You can optionally use something like <code>.apply()</code> or <strong>list comprehension</strong> on just the more-complicated portions of the equation, while still easily using vectorization for the rest.</li>
<li><strong>Pure vectorization</strong> is the absolute fastest and best, and what you should use if you <em>are willing to put in the effort to make it work.</em>
<ol>
<li>For simple cases, it's what you should use.</li>
<li>For complicated cases, <code>if</code> statements, etc., pure vectorization can be made to work too, through <strong>boolean indexing,</strong> but can add extra work and can decrease readability to do so. So, you can optionally use <strong>list comprehension</strong> (usually the best) or <strong>.apply()</strong> (generally slower, but not always) for just those edge cases instead, while still using vectorization for the rest of the calculation. Ex: see techniques <code>7_vectorization__with_list_comprehension_for_if_statment_corner_case</code> and <code>6_vectorization__with_apply_for_if_statement_corner_case</code>.</li>
</ol>
</li>
</ol>
<h2>The test data</h2>
<p>Assume we have the following Pandas DataFrame. It has 2 million rows with 4 columns (<code>A</code>, <code>B</code>, <code>C</code>, and <code>D</code>), each with random values from <code>-1000</code> to <code>1000</code>:</p>
<pre><code>df =
           A    B    C    D
0       -365  842  284 -942
1        532  416 -102  888
2        397  321 -296 -616
3       -215  879  557  895
4        857  701 -157  480
...      ...  ...  ...  ...
1999995 -101 -233 -377 -939
1999996 -989  380  917  145
1999997 -879  333 -372 -970
1999998  738  982 -743  312
1999999 -306 -103  459  745
</code></pre>
<p>I produced this DataFrame like this:</p>
<pre class="lang-py prettyprint-override"><code>import numpy as np
import pandas as pd

# Create an array (numpy list of lists) of fake data
MIN_VAL = -1000
MAX_VAL = 1000
# NUM_ROWS = 10_000_000
NUM_ROWS = 2_000_000  # default for final tests
# NUM_ROWS = 1_000_000
# NUM_ROWS = 100_000
# NUM_ROWS = 10_000  # default for rapid development &amp; initial tests
NUM_COLS = 4
data = np.random.randint(MIN_VAL, MAX_VAL, size=(NUM_ROWS, NUM_COLS))

# Now convert it to a Pandas DataFrame with columns named &quot;A&quot;, &quot;B&quot;, &quot;C&quot;, and &quot;D&quot;
df_original = pd.DataFrame(data, columns=[&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;])
print(f&quot;df = \n{df_original}&quot;)
</code></pre>
<h2>The test equation/calculation</h2>
<p>I wanted to demonstrate that all of these techniques are possible on non-trivial functions or equations, so I intentionally made the equation they are calculating require:</p>
<ol>
<li><code>if</code> statements</li>
<li>data from multiple columns in the DataFrame</li>
<li>data from multiple rows in the DataFrame</li>
</ol>
<p>The equation we will be calculating for each row is this. I arbitrarily made it up, but I think it contains enough complexity that you will be able to expand on what I've done to perform any equation you want in Pandas with full vectorization:</p>
<p><a href="https://i.stack.imgur.com/W3c12.png" rel="nofollow noreferrer"><img src="https://i.stack.imgur.com/W3c12.png" alt="enter image description here" /></a></p>
<p>In Python, the above equation can be written like this:</p>
<pre class="lang-py prettyprint-override"><code># Calculate and return a new value, `val`, by performing the following equation:
val = (
    2 * A_i_minus_2
    + 3 * A_i_minus_1
    + 4 * A
    + 5 * A_i_plus_1
    # Python ternary operator; don't forget parentheses around the entire 
    # ternary expression!
    + ((6 * B) if B &gt; 0 else (60 * B))
    + 7 * C
    - 8 * D
)
</code></pre>
<p>Alternatively, you could write it like this:</p>
<pre class="lang-py prettyprint-override"><code># Calculate and return a new value, `val`, by performing the following equation:

if B &gt; 0:
    B_new = 6 * B
else:
    B_new = 60 * B

val = (
    2 * A_i_minus_2
    + 3 * A_i_minus_1
    + 4 * A
    + 5 * A_i_plus_1
    + B_new
    + 7 * C
    - 8 * D
)
</code></pre>
<p>Either of those can be wrapped into a function. Ex:</p>
<pre class="lang-py prettyprint-override"><code>def calculate_val(
        A_i_minus_2,
        A_i_minus_1,
        A,
        A_i_plus_1,
        B,
        C,
        D):
    val = (
        2 * A_i_minus_2
        + 3 * A_i_minus_1
        + 4 * A
        + 5 * A_i_plus_1
        # Python ternary operator; don't forget parentheses around the 
        # entire ternary expression!
        + ((6 * B) if B &gt; 0 else (60 * B))
        + 7 * C
        - 8 * D
    )
    return val
</code></pre>
<h2>The techniques</h2>
<p>The full code is available to download and run in my <strong><a href="https://github.com/ElectricRCAircraftGuy/eRCaGuy_hello_world/blob/master/python/pandas_dataframe_iteration_vs_vectorization_vs_list_comprehension_speed_tests.py" rel="nofollow noreferrer"><code>python/pandas_dataframe_iteration_vs_vectorization_vs_list_comprehension_speed_tests.py</code></a></strong> file in my <a href="https://github.com/ElectricRCAircraftGuy/eRCaGuy_hello_world" rel="nofollow noreferrer">eRCaGuy_hello_world</a> repo.</p>
<h4>Here is the code for all 13 techniques:</h4>
<ol>
<li><p><strong>Technique 1:</strong> <code>1_raw_for_loop_using_regular_df_indexing</code></p>
<pre class="lang-py prettyprint-override"><code>val = [np.NAN]*len(df)
for i in range(len(df)):
    if i &lt; 2 or i &gt; len(df)-2:
        continue

    val[i] = calculate_val(
        df[&quot;A&quot;][i-2],
        df[&quot;A&quot;][i-1],
        df[&quot;A&quot;][i],
        df[&quot;A&quot;][i+1],
        df[&quot;B&quot;][i],
        df[&quot;C&quot;][i],
        df[&quot;D&quot;][i],
    )
df[&quot;val&quot;] = val  # put this column back into the dataframe
</code></pre>
</li>
<li><p><strong>Technique 2:</strong> <code>2_raw_for_loop_using_df.loc[]_indexing</code></p>
<pre class="lang-py prettyprint-override"><code>val = [np.NAN]*len(df)
for i in range(len(df)):
    if i &lt; 2 or i &gt; len(df)-2:
        continue

    val[i] = calculate_val(
        df.loc[i-2, &quot;A&quot;],
        df.loc[i-1, &quot;A&quot;],
        df.loc[i,   &quot;A&quot;],
        df.loc[i+1, &quot;A&quot;],
        df.loc[i,   &quot;B&quot;],
        df.loc[i,   &quot;C&quot;],
        df.loc[i,   &quot;D&quot;],
    )

df[&quot;val&quot;] = val  # put this column back into the dataframe
</code></pre>
</li>
<li><p><strong>Technique 3:</strong> <code>3_raw_for_loop_using_df.iloc[]_indexing</code></p>
<pre class="lang-py prettyprint-override"><code># column indices
i_A = 0
i_B = 1
i_C = 2
i_D = 3

val = [np.NAN]*len(df)
for i in range(len(df)):
    if i &lt; 2 or i &gt; len(df)-2:
        continue

    val[i] = calculate_val(
        df.iloc[i-2, i_A],
        df.iloc[i-1, i_A],
        df.iloc[i,   i_A],
        df.iloc[i+1, i_A],
        df.iloc[i,   i_B],
        df.iloc[i,   i_C],
        df.iloc[i,   i_D],
    )

df[&quot;val&quot;] = val  # put this column back into the dataframe
</code></pre>
</li>
<li><p><strong>Technique 4:</strong> <code>4_iterrows_in_for_loop</code></p>
<pre class="lang-py prettyprint-override"><code>val = [np.NAN]*len(df)
for index, row in df.iterrows():
    if index &lt; 2 or index &gt; len(df)-2:
        continue

    val[index] = calculate_val(
        df[&quot;A&quot;][index-2],
        df[&quot;A&quot;][index-1],
        row[&quot;A&quot;],
        df[&quot;A&quot;][index+1],
        row[&quot;B&quot;],
        row[&quot;C&quot;],
        row[&quot;D&quot;],
    )

df[&quot;val&quot;] = val  # put this column back into the dataframe
</code></pre>
</li>
</ol>
<p>For all of the next examples, we must first prepare the dataframe by adding columns with previous and next values: <code>A_(i-2)</code>, <code>A_(i-1)</code>, and <code>A_(i+1)</code>. These columns in the DataFrame will be named <code>A_i_minus_2</code>, <code>A_i_minus_1</code>, and <code>A_i_plus_1</code>, respectively:</p>
<pre class="lang-py prettyprint-override"><code>df_original[&quot;A_i_minus_2&quot;] = df_original[&quot;A&quot;].shift(2)  # val at index i-2
df_original[&quot;A_i_minus_1&quot;] = df_original[&quot;A&quot;].shift(1)  # val at index i-1
df_original[&quot;A_i_plus_1&quot;] = df_original[&quot;A&quot;].shift(-1)  # val at index i+1

# Note: to ensure that no partial calculations are ever done with rows which
# have NaN values due to the shifting, we can either drop such rows with
# `.dropna()`, or set all values in these rows to NaN. I'll choose the latter
# so that the stats that will be generated with the techniques below will end
# up matching the stats which were produced by the prior techniques above. ie:
# the number of rows will be identical to before. 
#
# df_original = df_original.dropna()
df_original.iloc[:2, :] = np.NAN   # slicing operators: first two rows, 
                                   # all columns
df_original.iloc[-1:, :] = np.NAN  # slicing operators: last row, all columns
</code></pre>
<p>Running the vectorized code just above to produce those 3 new columns took a total of <strong>0.044961 seconds</strong>.</p>
<p>Now on to the rest of the techniques:</p>
<ol>
<li><p><strong>Technique 5:</strong> <code>5_itertuples_in_for_loop</code></p>
<pre class="lang-py prettyprint-override"><code>val = [np.NAN]*len(df)
for row in df.itertuples():
    val[row.Index] = calculate_val(
        row.A_i_minus_2,
        row.A_i_minus_1,
        row.A,
        row.A_i_plus_1,
        row.B,
        row.C,
        row.D,
    )

df[&quot;val&quot;] = val  # put this column back into the dataframe
</code></pre>
</li>
<li><p><strong>Technique 6:</strong> <code>6_vectorization__with_apply_for_if_statement_corner_case</code></p>
<pre class="lang-py prettyprint-override"><code>def calculate_new_column_b_value(b_value):
    # Python ternary operator
    b_value_new = (6 * b_value) if b_value &gt; 0 else (60 * b_value)  
    return b_value_new

# In this particular example, since we have an embedded `if-else` statement
# for the `B` column, pure vectorization is less intuitive. So, first we'll
# calculate a new `B` column using
# **`apply()`**, then we'll use vectorization for the rest.
df[&quot;B_new&quot;] = df[&quot;B&quot;].apply(calculate_new_column_b_value)
# OR (same thing, but with a lambda function instead)
# df[&quot;B_new&quot;] = df[&quot;B&quot;].apply(lambda x: (6 * x) if x &gt; 0 else (60 * x))

# Now we can use vectorization for the rest. &quot;Vectorization&quot; in this case
# means to simply use the column series variables in equations directly,
# without manually iterating over them. Pandas DataFrames will handle the
# underlying iteration automatically for you. You just focus on the math.
df[&quot;val&quot;] = (
    2 * df[&quot;A_i_minus_2&quot;]
    + 3 * df[&quot;A_i_minus_1&quot;]
    + 4 * df[&quot;A&quot;]
    + 5 * df[&quot;A_i_plus_1&quot;]
    + df[&quot;B_new&quot;]
    + 7 * df[&quot;C&quot;]
    - 8 * df[&quot;D&quot;]
)
</code></pre>
</li>
<li><p><strong>Technique 7:</strong> <code>7_vectorization__with_list_comprehension_for_if_statment_corner_case</code></p>
<pre class="lang-py prettyprint-override"><code># In this particular example, since we have an embedded `if-else` statement
# for the `B` column, pure vectorization is less intuitive. So, first we'll
# calculate a new `B` column using **list comprehension**, then we'll use
# vectorization for the rest.
df[&quot;B_new&quot;] = [
    calculate_new_column_b_value(b_value) for b_value in df[&quot;B&quot;]
]

# Now we can use vectorization for the rest. &quot;Vectorization&quot; in this case
# means to simply use the column series variables in equations directly,
# without manually iterating over them. Pandas DataFrames will handle the
# underlying iteration automatically for you. You just focus on the math.
df[&quot;val&quot;] = (
    2 * df[&quot;A_i_minus_2&quot;]
    + 3 * df[&quot;A_i_minus_1&quot;]
    + 4 * df[&quot;A&quot;]
    + 5 * df[&quot;A_i_plus_1&quot;]
    + df[&quot;B_new&quot;]
    + 7 * df[&quot;C&quot;]
    - 8 * df[&quot;D&quot;]
)
</code></pre>
</li>
<li><p><strong>Technique 8:</strong> <code>8_pure_vectorization__with_df.loc[]_boolean_array_indexing_for_if_statment_corner_case</code></p>
<p>This uses <strong>boolean indexing</strong>, AKA: a <strong>boolean mask</strong>, to accomplish the equivalent of the <code>if</code> statement in the equation. In this way, pure vectorization can be used for the entire equation, thereby maximizing performance and speed.</p>
<pre class="lang-py prettyprint-override"><code># If statement to evaluate:
#
#     if B &gt; 0:
#         B_new = 6 * B
#     else:
#         B_new = 60 * B
#
# In this particular example, since we have an embedded `if-else` statement
# for the `B` column, we can use some boolean array indexing through
# `df.loc[]` for some pure vectorization magic.
#
# Explanation:
#
# Long:
#
# The format is: `df.loc[rows, columns]`, except in this case, the rows are
# specified by a &quot;boolean array&quot; (AKA: a boolean expression, list of
# booleans, or &quot;boolean mask&quot;), specifying all rows where `B` is &gt; 0. Then,
# only in that `B` column for those rows, set the value accordingly. After
# we do this for where `B` is &gt; 0, we do the same thing for where `B` 
# is &lt;= 0, except with the other equation.
#
# Short:
#
# For all rows where the boolean expression applies, set the column value
# accordingly.
#
# GitHub CoPilot first showed me this `.loc[]` technique.
# See also the official documentation:
# https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.loc.html
#
# ===========================
# 1st: handle the &gt; 0 case
# ===========================
df[&quot;B_new&quot;] = df.loc[df[&quot;B&quot;] &gt; 0, &quot;B&quot;] * 6
#
# ===========================
# 2nd: handle the &lt;= 0 case, merging the results into the
# previously-created &quot;B_new&quot; column
# ===========================
# - NB: this does NOT work; it overwrites and replaces the whole &quot;B_new&quot;
#   column instead:
#
#       df[&quot;B_new&quot;] = df.loc[df[&quot;B&quot;] &lt;= 0, &quot;B&quot;] * 60
#
# This works:
df.loc[df[&quot;B&quot;] &lt;= 0, &quot;B_new&quot;] = df.loc[df[&quot;B&quot;] &lt;= 0, &quot;B&quot;] * 60

# Now use normal vectorization for the rest.
df[&quot;val&quot;] = (
    2 * df[&quot;A_i_minus_2&quot;]
    + 3 * df[&quot;A_i_minus_1&quot;]
    + 4 * df[&quot;A&quot;]
    + 5 * df[&quot;A_i_plus_1&quot;]
    + df[&quot;B_new&quot;]
    + 7 * df[&quot;C&quot;]
    - 8 * df[&quot;D&quot;]
)
</code></pre>
</li>
<li><p><strong>Technique 9:</strong> <code>9_apply_function_with_lambda</code></p>
<pre class="lang-py prettyprint-override"><code>df[&quot;val&quot;] = df.apply(
    lambda row: calculate_val(
        row[&quot;A_i_minus_2&quot;],
        row[&quot;A_i_minus_1&quot;],
        row[&quot;A&quot;],
        row[&quot;A_i_plus_1&quot;],
        row[&quot;B&quot;],
        row[&quot;C&quot;],
        row[&quot;D&quot;]
    ),
    axis='columns' # same as `axis=1`: &quot;apply function to each row&quot;, 
                   # rather than to each column
)
</code></pre>
</li>
<li><p><strong>Technique 10:</strong> <code>10_list_comprehension_w_zip_and_direct_variable_assignment_passed_to_func</code></p>
<pre class="lang-py prettyprint-override"><code>df[&quot;val&quot;] = [
    # Note: you *could* do the calculations directly here instead of using a
    # function call, so long as you don't have indented code blocks such as
    # sub-routines or multi-line if statements.
    #
    # I'm using a function call.
    calculate_val(
        A_i_minus_2,
        A_i_minus_1,
        A,
        A_i_plus_1,
        B,
        C,
        D
    ) for A_i_minus_2, A_i_minus_1, A, A_i_plus_1, B, C, D
    in zip(
        df[&quot;A_i_minus_2&quot;],
        df[&quot;A_i_minus_1&quot;],
        df[&quot;A&quot;],
        df[&quot;A_i_plus_1&quot;],
        df[&quot;B&quot;],
        df[&quot;C&quot;],
        df[&quot;D&quot;]
    )
]
</code></pre>
</li>
<li><p><strong>Technique 11:</strong> <code>11_list_comprehension_w_zip_and_direct_variable_assignment_calculated_in_place</code></p>
<pre class="lang-py prettyprint-override"><code>df[&quot;val&quot;] = [
    2 * A_i_minus_2
    + 3 * A_i_minus_1
    + 4 * A
    + 5 * A_i_plus_1
    # Python ternary operator; don't forget parentheses around the entire
    # ternary expression!
    + ((6 * B) if B &gt; 0 else (60 * B))
    + 7 * C
    - 8 * D
    for A_i_minus_2, A_i_minus_1, A, A_i_plus_1, B, C, D
    in zip(
        df[&quot;A_i_minus_2&quot;],
        df[&quot;A_i_minus_1&quot;],
        df[&quot;A&quot;],
        df[&quot;A_i_plus_1&quot;],
        df[&quot;B&quot;],
        df[&quot;C&quot;],
        df[&quot;D&quot;]
    )
]
</code></pre>
</li>
<li><p><strong>Technique 12:</strong> <code>12_list_comprehension_w_zip_and_row_tuple_passed_to_func</code></p>
<pre class="lang-py prettyprint-override"><code>df[&quot;val&quot;] = [
    calculate_val(
        row[0],
        row[1],
        row[2],
        row[3],
        row[4],
        row[5],
        row[6],
    ) for row
    in zip(
        df[&quot;A_i_minus_2&quot;],
        df[&quot;A_i_minus_1&quot;],
        df[&quot;A&quot;],
        df[&quot;A_i_plus_1&quot;],
        df[&quot;B&quot;],
        df[&quot;C&quot;],
        df[&quot;D&quot;]
    )
]
</code></pre>
</li>
<li><p><strong>Technique 13:</strong> <code>13_list_comprehension_w__to_numpy__and_direct_variable_assignment_passed_to_func</code></p>
<pre class="lang-py prettyprint-override"><code>df[&quot;val&quot;] = [
    # Note: you *could* do the calculations directly here instead of using a
    # function call, so long as you don't have indented code blocks such as
    # sub-routines or multi-line if statements.
    #
    # I'm using a function call.
    calculate_val(
        A_i_minus_2,
        A_i_minus_1,
        A,
        A_i_plus_1,
        B,
        C,
        D
    ) for A_i_minus_2, A_i_minus_1, A, A_i_plus_1, B, C, D
        # Note: this `[[...]]` double-bracket indexing is used to select a
        # subset of columns from the dataframe. The inner `[]` brackets
        # create a list from the column names within them, and the outer 
        # `[]` brackets accept this list to index into the dataframe and
        # select just this list of columns, in that order.
        # - See the official documentation on it here:
        #   https://pandas.pydata.org/docs/user_guide/indexing.html#basics
        #   - Search for the phrase &quot;You can pass a list of columns to [] to
        #     select columns in that order.&quot;
        #   - I learned this from this comment here:
        #     https://stackoverflow.com/questions/16476924/how-to-iterate-over-rows-in-a-dataframe-in-pandas/55557758#comment136020567_55557758
        # - One of the **list comprehension** examples in this answer here
        #   uses `.to_numpy()` like this:
        #   https://stackoverflow.com/a/55557758/4561887
    in df[[
        &quot;A_i_minus_2&quot;,
        &quot;A_i_minus_1&quot;,
        &quot;A&quot;,
        &quot;A_i_plus_1&quot;,
        &quot;B&quot;,
        &quot;C&quot;,
        &quot;D&quot;
    ]].to_numpy()  # NB: `.values` works here too, but is deprecated. See:
                   # https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.values.html
]
</code></pre>
</li>
</ol>
<p>Here are the results again:</p>
<p><a href="https://i.stack.imgur.com/5biMy.png" rel="nofollow noreferrer"><img src="https://i.stack.imgur.com/5biMy.png" alt="enter image description here" /></a></p>
<h2>Using the pre-shifted rows in the 4 <code>for</code> loop techniques as well</h2>
<p>I wanted to see if removing this <code>if</code> check and using the pre-shifted rows in the 4 <code>for</code> loop techniques would have much effect:</p>
<pre class="lang-py prettyprint-override"><code>if i &lt; 2 or i &gt; len(df)-2:
    continue
</code></pre>
<p>...so I created this file with those modifications: <a href="https://github.com/ElectricRCAircraftGuy/eRCaGuy_hello_world/blob/master/python/pandas_dataframe_iteration_vs_vectorization_vs_list_comprehension_speed_tests_mod.py" rel="nofollow noreferrer"><code>pandas_dataframe_iteration_vs_vectorization_vs_list_comprehension_speed_tests_mod.py</code></a>. Search the file for &quot;MOD:&quot; to find the 4 new, modified techniques.</p>
<p>It had only a slight improvement. Here are the results of these 17 techniques now, with the 4 new ones having the word <code>_MOD_</code> near the beginning of their name, just after their number. This is over 500k rows this time, not 2M:</p>
<p><a href="https://i.stack.imgur.com/HxKkJ.png" rel="nofollow noreferrer"><img src="https://i.stack.imgur.com/HxKkJ.png" alt="enter image description here" /></a></p>
<h2>More on <code>.iterrtuples()</code></h2>
<p>There are actually more nuances when using <code>.itertuples()</code>. To delve into some of those, read <a href="https://stackoverflow.com/a/59413206/4561887">this answer by @Romain Capron</a>. Here is a bar chart plot I made of his results:</p>
<p><a href="https://i.stack.imgur.com/ws9db.png" rel="nofollow noreferrer"><img src="https://i.stack.imgur.com/ws9db.png" alt="enter image description here" /></a></p>
<p>My plotting code for his results is in <strong><a href="https://github.com/ElectricRCAircraftGuy/eRCaGuy_hello_world/blob/master/python/pandas_plot_bar_chart_better_GREAT_AUTOLABEL_DATA.py" rel="nofollow noreferrer"><code>python/pandas_plot_bar_chart_better_GREAT_AUTOLABEL_DATA.py</code></a></strong> in my <a href="https://github.com/ElectricRCAircraftGuy/eRCaGuy_hello_world" rel="nofollow noreferrer">eRCaGuy_hello_world</a> repo.</p>
<h2>Future work</h2>
<p>Using Cython (Python compiled into C code), or just raw C functions called by Python, could be faster potentially, but I'm not going to do that for these tests. I'd only look into and speed test those options for big optimizations.</p>
<p>I currently don't know Cython and don't feel the need to learn it. As you can see above, simply using pure vectorization properly already runs incredibly fast, processing 2 <em>million</em> rows in only 0.1 seconds, or 20 million rows per second.</p>
<h2>References</h2>
<ol>
<li><p>A bunch of the official Pandas documentation, especially the <code>DataFrame</code> documentation here: <a href="https://pandas.pydata.org/pandas-docs/stable/reference/frame.html" rel="nofollow noreferrer">https://pandas.pydata.org/pandas-docs/stable/reference/frame.html</a>.</p>
</li>
<li><p><a href="https://stackoverflow.com/a/55557758/4561887">This excellent answer by @cs95</a> - this is where I learned in particular how to use list comprehension to iterate over a DataFrame.</p>
</li>
<li><p><a href="https://stackoverflow.com/a/59413206/4561887">This answer about <code>itertuples()</code>, by @Romain Capron</a> - I studied it carefully and edited/formatted it.</p>
</li>
<li><p>All of this is my own code, but I want to point out that I had dozens of chats with GitHub Copilot (mostly), Bing AI, and ChatGPT in order to figure out many of these techniques and debug my code as I went.</p>
</li>
<li><p>Bing Chat produced the pretty LaTeX equation for me, with the following prompt. Of course, I verified the output:</p>
<blockquote>
<p>Convert this Python code to a pretty equation I can paste onto Stack Overflow:</p>
<pre><code>    val = (
        2 * A_i_minus_2
        + 3 * A_i_minus_1
        + 4 * A
        + 5 * A_i_plus_1
        # Python ternary operator; don't forget parentheses around the entire ternary expression!
        + ((6 * B) if B &gt; 0 else (60 * B))
        + 7 * C
        - 8 * D
    )
</code></pre>
</blockquote>
</li>
</ol>
<h2>See also</h2>
<ol>
<li><p>This answer is also posted on my personal website here: <a href="https://gabrielstaples.com/python_iterate_over_pandas_dataframe/" rel="nofollow noreferrer">https://gabrielstaples.com/python_iterate_over_pandas_dataframe/</a></p>
</li>
<li><p><a href="https://en.wikipedia.org/wiki/Array_programming" rel="nofollow noreferrer">https://en.wikipedia.org/wiki/Array_programming</a> - array programming, or &quot;vectorization&quot;:</p>
<blockquote>
<p>In computer science, array programming refers to solutions that allow the application of operations to an entire set of values at once. Such solutions are commonly used in scientific and engineering settings.</p>
<p>Modern programming languages that support array programming (also known as vector or multidimensional languages) have been engineered specifically to generalize operations on scalars to apply transparently to vectors, matrices, and higher-dimensional arrays. These include APL, J, Fortran, MATLAB, Analytica, Octave, R, Cilk Plus, Julia, Perl Data Language (PDL). In these languages, an operation that operates on entire arrays can be called a vectorized operation,<a href="https://i.stack.imgur.com/5biMy.png" rel="nofollow noreferrer">1</a> regardless of whether it is executed on a vector processor, which implements vector instructions.</p>
</blockquote>
</li>
<li><p><a href="https://stackoverflow.com/q/54028199/4561887">Are for-loops in pandas really bad? When should I care?</a></p>
<ol>
<li><a href="https://stackoverflow.com/a/77270403/4561887">my answer</a></li>
</ol>
</li>
<li><p><a href="https://stackoverflow.com/q/24870953/4561887">Does pandas iterrows have performance issues?</a></p>
<ol>
<li><a href="https://stackoverflow.com/a/24871316/4561887">This answer</a>
<ol>
<li><p><a href="https://stackoverflow.com/questions/24870953/does-pandas-iterrows-have-performance-issues#comment136223122_24871316">My comment underneath it</a>:</p>
<blockquote>
<p>...Based on my results, I'd say, however, these are the best approaches, in this order of best first:</p>
<ol>
<li>vectorization,</li>
<li>list comprehension,</li>
<li><code>.itertuples()</code>,</li>
<li><code>.apply()</code>,</li>
<li>raw <code>for</code> loop,</li>
<li><code>.iterrows().</code></li>
</ol>
<p>I didn't test Cython.</p>
</blockquote>
</li>
</ol>
</li>
</ol>
</li>
</ol>
------------------------------------------------------------------ <br><h3> Answer 54264778 shubham ranjan: </h3><p>There are so many ways to iterate over the rows in Pandas dataframe. One very simple and intuitive way is:</p>

<pre><code>df = pd.DataFrame({'A':[1, 2, 3], 'B':[4, 5, 6], 'C':[7, 8, 9]})
print(df)
for i in range(df.shape[0]):
    # For printing the second column
    print(df.iloc[i, 1])

    # For printing more than one columns
    print(df.iloc[i, [0, 2]])
</code></pre>
------------------------------------------------------------------ <br><h3> Answer 64653674 Fran&#231;ois B.: </h3><p>The easiest way, use the <code>apply</code> function</p>
<pre class="lang-py prettyprint-override"><code>def print_row(row):
   print row['c1'], row['c2']

df.apply(lambda row: print_row(row), axis=1)
</code></pre>
------------------------------------------------------------------ <br><h3> Answer 68562557 Ernesto Els&#228;&#223;er: </h3><p>Probably the most elegant solution (but certainly not the most efficient):</p>
<pre><code>for row in df.values:
    c2 = row[1]
    print(row)
    # ...

for c1, c2 in df.values:
    # ...
</code></pre>
<p>Note that:</p>
<ul>
<li><a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.values.html" rel="noreferrer">the documentation</a> explicitly recommends to use <code>.to_numpy()</code> instead</li>
<li>the produced NumPy array will have a dtype that fits all columns, in the worst case <code>object</code></li>
<li>there are <a href="https://stackoverflow.com/a/55557758/4248897">good reasons</a> not to use a loop in the first place</li>
</ul>
<p>Still, I think this option should be included here, as a straightforward solution to a (one should think) trivial problem.</p>
------------------------------------------------------------------ <br><h3> Answer 47598852 James L.: </h3><p>You can also do NumPy indexing for even greater speed ups. It's not really iterating but works much better than iteration for certain applications.</p>

<pre><code>subset = row['c1'][0:5]
all = row['c1'][:]
</code></pre>

<p>You may also want to cast it to an array. These indexes/selections are supposed to act like NumPy arrays already, but I ran into issues and needed to cast</p>

<pre><code>np.asarray(all)
imgs[:] = cv2.resize(imgs[:], (224,224) ) # Resize every image in an hdf5 file
</code></pre>
------------------------------------------------------------------ <br><h3> Answer 68233908 Ashvani Jaiswal: </h3><p><code>df.iterrows()</code> returns <code>tuple(a, b)</code> where <code>a</code> is the <code>index</code> and <code>b</code> is the <code>row</code>.</p>
------------------------------------------------------------------ <br><h3> Answer 75989939 cottontail: </h3><h4>1. Iterate over <code>df.index</code> and access via <code>at[]</code></h4>
<p>A method that is quite readable is to iterate over the index (as suggested by <a href="https://stackoverflow.com/a/47073107/19123103">@Grag2015</a>). However, instead of chained indexing used there, use <code>at</code> for efficiency:</p>
<pre class="lang-py prettyprint-override"><code>for ind in df.index:
    print(df.at[ind, 'col A'])
</code></pre>
<p>The advantage of this method over <code>for i in range(len(df))</code> is it works even if the index is not <code>RangeIndex</code>. See the following example:</p>
<pre class="lang-py prettyprint-override"><code>df = pd.DataFrame({'col A': list('ABCDE'), 'col B': range(5)}, index=list('abcde'))

for ind in df.index:
    print(df.at[ind, 'col A'], df.at[ind, 'col B'])    # &lt;---- OK
    df.at[ind, 'col C'] = df.at[ind, 'col B'] * 2      # &lt;---- can assign values
        
for ind in range(len(df)):
    print(df.at[ind, 'col A'], df.at[ind, 'col B'])    # &lt;---- KeyError
</code></pre>
<p>If the integer location of a row is needed (e.g. to get previous row's values), wrap it by <code>enumerate()</code>:</p>
<pre class="lang-py prettyprint-override"><code>for i, ind in enumerate(df.index):
    prev_row_ind = df.index[i-1] if i &gt; 0 else df.index[i]
    df.at[ind, 'col C'] = df.at[prev_row_ind, 'col B'] * 2
</code></pre>
<hr />
<h4>2. Use <code>get_loc</code> with <code>itertuples()</code></h4>
<p>Even though it's much faster than <code>iterrows()</code>, a major drawback of <code>itertuples()</code> is that it mangles column labels if they contain space in them (e.g. <code>'col C'</code> becomes <code>_1</code> etc.), which makes it hard to access values in iteration.</p>
<p>You can use <code>df.columns.get_loc()</code> to get the integer location of a column label and use it to index the namedtuples. Note that the first element of each namedtuple is the index label, so to properly access the column by integer position, you either have to add 1 to whatever is returned from <code>get_loc</code> or unpack the tuple in the beginning.</p>
<pre class="lang-py prettyprint-override"><code>df = pd.DataFrame({'col A': list('ABCDE'), 'col B': range(5)}, index=list('abcde'))

for row in df.itertuples(name=None):
    pos = df.columns.get_loc('col B') + 1              # &lt;---- add 1 here
    print(row[pos])


for ind, *row in df.itertuples(name=None):
#   ^^^^^^^^^    &lt;---- unpacked here
    pos = df.columns.get_loc('col B')                  # &lt;---- already unpacked
    df.at[ind, 'col C'] = row[pos] * 2
    print(row[pos])
</code></pre>
<hr />
<h4>3. Convert to a dictionary and iterate over <code>dict_items</code></h4>
<p>Another way to loop over a dataframe is to convert it into a dictionary in <code>orient='index'</code> and iterate over the <code>dict_items</code> or <code>dict_values</code>.</p>
<pre class="lang-py prettyprint-override"><code>df = pd.DataFrame({'col A': list('ABCDE'), 'col B': range(5)})

for row in df.to_dict('index').values():
#                             ^^^^^^^^^         &lt;--- iterate over dict_values
    print(row['col A'], row['col B'])


for index, row in df.to_dict('index').items():
#                                    ^^^^^^^^   &lt;--- iterate over dict_items
    df.at[index, 'col A'] = row['col A'] + str(row['col B'])
</code></pre>
<p>This doesn't mangle dtypes like <code>iterrows</code>, doesn't mangle column labels like <code>itertuples</code> and agnostic about the number of columns (<code>zip(df['col A'], df['col B'], ...)</code> would quickly turn cumbersome if there are many columns).</p>
<hr />
<p>Finally, as <a href="https://stackoverflow.com/a/55557758/19123103">@cs95</a> mentioned, avoid looping as much possible. Especially if your data is numeric, there'll be an optimized method for your task in the library if you dig a little bit.</p>
<p>That said, there are some cases where iteration is more efficient than vectorized operations. One common such task is to dump a pandas dataframe into a nested json. At least as of pandas 1.5.3, an <code>itertuples()</code> loop is much faster than any vectorized operation involving <code>groupby.apply</code> method in that case.</p>
------------------------------------------------------------------ <br><h3> Answer 55202153 mjr2000: </h3><p>This example uses iloc to isolate each digit in the data frame. </p>

<pre><code>import pandas as pd

 a = [1, 2, 3, 4]
 b = [5, 6, 7, 8]

 mjr = pd.DataFrame({'a':a, 'b':b})

 size = mjr.shape

 for i in range(size[0]):
     for j in range(size[1]):
         print(mjr.iloc[i, j])
</code></pre>
------------------------------------------------------------------ <br><h3> Answer 71234113 gru: </h3><p><strong>Disclaimer:</strong> Although here are so many answers which recommend <strong>not</strong> using an iterative (loop) approach (and I mostly agree), I would still see it as a reasonable approach for the following situation:</p>
<h2>Extend a dataframe with data from an API</h2>
<p>Let's say you have a large dataframe which contains incomplete user data. Now you have to extend this data with additional columns, for example, the user's <code>age</code> and <code>gender</code>.</p>
<p>Both values have to be fetched from a backend API. I'm assuming the API doesn't provide a &quot;batch&quot; endpoint (which would accept multiple user IDs at once). Otherwise, you should rather call the API only once.</p>
<p>The costs (waiting time) for the network request surpass the iteration of the dataframe by far. We're talking about network round trip times of hundreds of milliseconds compared to the negligibly small gains in using alternative approaches to iterations.</p>
<h2>One expensive network request for each row</h2>
<p>So in this case, I would absolutely prefer using an iterative approach. Although the network request is expensive, it is guaranteed being triggered only once for each row in the dataframe. Here is an example using <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.iterrows.html#pandas-dataframe-iterrows" rel="nofollow noreferrer">DataFrame.iterrows</a>:</p>
<h2>Example</h2>
<pre class="lang-py prettyprint-override"><code>for index, row in users_df.iterrows():
  user_id = row['user_id']

  # Trigger expensive network request once for each row
  response_dict = backend_api.get(f'/api/user-data/{user_id}')

  # Extend dataframe with multiple data from response
  users_df.at[index, 'age'] = response_dict.get('age')
  users_df.at[index, 'gender'] = response_dict.get('gender')
</code></pre>
------------------------------------------------------------------ <br><h3> Answer 59264161 morganics: </h3><p>Some libraries (e.g. a Java interop library that I use) require values to be passed in a row at a time, for example, if streaming data. To replicate the streaming nature, I 'stream' my dataframe values one by one, I wrote the below, which comes in handy from time to time.</p>

<pre><code>class DataFrameReader:
  def __init__(self, df):
    self._df = df
    self._row = None
    self._columns = df.columns.tolist()
    self.reset()
    self.row_index = 0

  def __getattr__(self, key):
    return self.__getitem__(key)

  def read(self) -&gt; bool:
    self._row = next(self._iterator, None)
    self.row_index += 1
    return self._row is not None

  def columns(self):
    return self._columns

  def reset(self) -&gt; None:
    self._iterator = self._df.itertuples()

  def get_index(self):
    return self._row[0]

  def index(self):
    return self._row[0]

  def to_dict(self, columns: List[str] = None):
    return self.row(columns=columns)

  def tolist(self, cols) -&gt; List[object]:
    return [self.__getitem__(c) for c in cols]

  def row(self, columns: List[str] = None) -&gt; Dict[str, object]:
    cols = set(self._columns if columns is None else columns)
    return {c : self.__getitem__(c) for c in self._columns if c in cols}

  def __getitem__(self, key) -&gt; object:
    # the df index of the row is at index 0
    try:
        if type(key) is list:
            ix = [self._columns.index(key) + 1 for k in key]
        else:
            ix = self._columns.index(key) + 1
        return self._row[ix]
    except BaseException as e:
        return None

  def __next__(self) -&gt; 'DataFrameReader':
    if self.read():
        return self
    else:
        raise StopIteration

  def __iter__(self) -&gt; 'DataFrameReader':
    return self
</code></pre>

<p>Which can be used:</p>

<pre><code>for row in DataFrameReader(df):
  print(row.my_column_name)
  print(row.to_dict())
  print(row['my_column_name'])
  print(row.tolist())
</code></pre>

<p>And preserves the values/ name mapping for the rows being iterated. Obviously, is a lot slower than using apply and Cython as indicated above, but is necessary in some circumstances.</p>
------------------------------------------------------------------ <br><h3> Answer 64177887 imanzabet: </h3><p>Along with the great answers in this post I am going to propose <strong>Divide and Conquer</strong> approach, I am not writing this answer to abolish the other great answers but to fulfill them with another approach which was working efficiently for me. It has two steps of <code>splitting</code> and <code>merging</code> the pandas dataframe:</p>
<p><strong>PROS of Divide and Conquer:</strong></p>
<ul>
<li>You don't need to use vectorization or any other methods to cast the type of your dataframe into another type</li>
<li>You don't need to Cythonize your code which normally takes extra time from you</li>
<li>Both <code>iterrows()</code> and <code>itertuples()</code> in my case were having the same performance over entire dataframe</li>
<li>Depends on your choice of slicing <code>index</code>, you will be able to exponentially quicken the iteration. The higher <code>index</code>, the quicker your iteration process.</li>
</ul>
<p><strong>CONS of Divide and Conquer:</strong></p>
<ul>
<li>You shouldn't have dependency over the iteration process to the same dataframe and different <em>slice</em>. Meaning if you want to read or write from other <em>slice</em>, it maybe difficult to do that.</li>
</ul>
<p><strong>===================    Divide and Conquer Approach    =================</strong></p>
<p><strong>Step 1: Splitting/Slicing</strong></p>
<p>In this step, we are going to divide the iteration over the entire dataframe. Think that you are going to read a <a href="https://%3Chttps://en.wikipedia.org/wiki/Comma-separated_values%3E" rel="nofollow noreferrer">CSV</a> file into pandas df then iterate over it. In may case I have 5,000,000 records and I am going to split it into 100,000 records.</p>
<p><strong>NOTE:</strong> I need to reiterate as other runtime analysis explained in the other solutions in this page, &quot;number of records&quot; has exponential proportion of &quot;runtime&quot; on search on the df. Based on the benchmark on my data here are the results:</p>
<pre class="lang-none prettyprint-override"><code>Number of records | Iteration rate [per second]
========================================
100,000           | 500
500,000           | 200
1,000,000         | 50
5,000,000         | 20
</code></pre>
<p><strong>Step 2: Merging</strong></p>
<p>This is going to be an easy step, just merge all the written CSV files into one dataframe and write it into a bigger CSV file.</p>
<p>Here is the sample code:</p>
<pre><code># Step 1 (Splitting/Slicing)
import pandas as pd
df_all = pd.read_csv('C:/KtV.csv')
df_index = 100000
df_len = len(df)
for i in range(df_len // df_index + 1):
    lower_bound = i * df_index
    higher_bound = min(lower_bound + df_index, df_len)
    # Splitting/slicing df (make sure to copy() otherwise it will be a view
    df = df_all[lower_bound:higher_bound].copy()
    '''
    Write your iteration over the sliced df here
    using iterrows() or intertuples() or ...
    '''
    # Writing into CSV files
    df.to_csv('C:/KtV_prep_' + str(i) + '.csv')



# Step 2 (Merging)
filename = 'C:/KtV_prep_'
df = (pd.read_csv(f) for f in [filename + str(i) + '.csv' for i in range(ktv_len // ktv_index + 1)])
df_prep_all = pd.concat(df)
df_prep_all.to_csv('C:/KtV_prep_all.csv')
</code></pre>
<p><strong>Reference:</strong></p>
<p><a href="https://stackoverflow.com/questions/7837722/what-is-the-most-efficient-way-to-loop-through-dataframes-with-pandas">Efficient way of iteration over datafreame</a></p>
<p><a href="https://stackoverflow.com/questions/20906474/import-multiple-csv-files-into-pandas-and-concatenate-into-one-dataframe">Concatenate CSV files into one Pandas Dataframe</a></p>
<h4> Comment 136525610 tbrugere: </h4>what makes you think this approach is any faster than just directly doing iterrows on the whole dataframe? it has the same memory and time complexity and has more operations (the csv io should be very slow in particular).   Also, this is not a divide&amp;conquer approach stricto sensu. Divide and conquer is a recursive paradigm. You’re just cutting up your dataframe in df_index-sized subtables and using those.<br>------------------------------------------------------------------ <br><h3> Answer 67701850 tbrugere: </h3><p>As <a href="https://stackoverflow.com/questions/16476924/how-to-iterate-over-rows-in-a-dataframe-in-pandas/16476974#16476974">the accepted answer</a> states, the fastest way to apply a function over rows is to use a <strong>vectorized function</strong>, the so-called NumPy <code>ufuncs</code> (universal functions).</p>
<p>But what should you do when the function you want to apply isn't already implemented in NumPy?</p>
<p>Well, using the <code>vectorize</code> decorator from <code>numba</code>, you can easily create ufuncs directly in Python like this:</p>
<pre class="lang-py prettyprint-override"><code>from numba import vectorize, float64

@vectorize([float64(float64)])
def f(x):
    #x is your line, do something with it, and return a float
</code></pre>
<p>The documentation for this function is here: <em><a href="https://numba.pydata.org/numba-doc/latest/user/vectorize.html" rel="nofollow noreferrer">Creating NumPy universal functions</a></em></p>
