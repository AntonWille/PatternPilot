 <h2> Title: What is the easiest way to duplicate an activerecord record? </h2> <h3> Brent , question_id: 60033 </h3>Score: 473, Tags: {ruby-on-rails,ruby,rails-activerecord} <br><p>I want to make a copy of an ActiveRecord object, changing a single field in the process (in addition to the <strong>id</strong>).  What is the simplest way to accomplish this?</p>
<p>I realize I could create a new record, and then iterate over each of the fields copying the data field-by-field - but I figured there must be an easier way to do this.</p>
<p>Perhaps something like this:</p>
<pre class="lang-ruby prettyprint-override"><code> new_record = Record.copy(:id)
</code></pre>
------------------------------------------------------------------ <br><h3> Answer 54035727 Foram: </h3><p>In Rails 5 you can simply create duplicate object or record like this.</p>

<pre><code>new_user = old_user.dup
</code></pre>
------------------------------------------------------------------ <br><h3> Answer 60053 Michael Sepcot: </h3><p>To get a copy, use the <a href="https://api.rubyonrails.org/classes/ActiveRecord/Core.html#method-i-dup" rel="noreferrer">dup</a> (or clone for &lt; rails 3.1+) method:</p>
<pre><code>#rails &gt;= 3.1
new_record = old_record.dup

# rails &lt; 3.1
new_record = old_record.clone
</code></pre>
<p>Then you can change whichever fields you want.</p>
<p><a href="http://api.rubyonrails.com/classes/ActiveRecord/Base.html#M001363" rel="noreferrer">ActiveRecord overrides the built-in Object#clone</a> to give you a new (not saved to the DB) record with an unassigned ID.<br />
Note that it does not copy associations, so you'll have to do this manually if you need to.</p>
<p><a href="https://gist.github.com/994614" rel="noreferrer">Rails 3.1 clone is a shallow copy, use dup instead...</a></p>
<h4> Comment 8295197 bradgonesurfing: </h4>Definitely DO NOT use clone. As other posters have mentioned the clone method now delegates to using Kernel#clone which will copy the id. Use ActiveRecord::Base#dup from now on<br><h4> Comment 7579926 skattyadz: </h4>It looks like this functionality has been replaced with dup: <a href="https://gist.github.com/994614" rel="nofollow noreferrer">gist.github.com/994614</a><br><h4> Comment 5493096 Translunar: </h4>Does this still work in Rails 3.1.0.beta? When I do <code>q = p.clone</code>, and then <code>p == q</code>, I get <code>true</code> back. On the other hand, if I use <code>q = p.dup</code>, I get <code>false</code> back when comparing them.<br><h4> Comment 12443556 Matt Smith: </h4>I have to say, this was a real pain. A simple change like this to intended functionality could cripple some important features if you didn&#39;t have good spec coverage.<br><h4> Comment 25250859 Pablo Cantero: </h4>An addition for <code>dup</code> or <code>clone</code> if you want to change specific attributes is to use <code>tap</code> e.g. <code>clone = record.dup.tap { |new_clone| new_clone.name = &quot;dup_#{new_clone.name}&quot; }</code><br><h4> Comment 79902027 Fabio Ros: </h4>After that you should <code>new_record.save!</code> to persist the object.<br><h4> Comment 7570370 Turadg: </h4>The <a href="http://edgeapi.rubyonrails.org/classes/ActiveResource/Base.html#method-i-clone" rel="nofollow noreferrer">Rails 3.1 docs on clone</a> say it still works, but I&#39;m using Rails 3.1.0.rc4 and even the <code>new?</code> method isn&#39;t working.<br><h4> Comment 7579816 skattyadz: </h4>When I try to clone and then save in Rails 3.1 RC4, I get a <code>Mysql2::Error: Duplicate entry</code> error on the primary key.<br><h4> Comment 9632351 stringo0: </h4>Does dup do the same pre-rails 3.1? Or is its functionality different?<br><h4> Comment 38155106 bobbdelsol: </h4>My test show that myrecord.clone gives me an exact copy of the record including its id.  so myrecord.save I&#39;m back where i started from.   myrecord.dup gives me and exact copy but the ID is nil.  Now myrecord.save means I have an additional copy.  It copied all the attributes including my binary data.  So use Luis&#39;s answer<br>------------------------------------------------------------------ <br><h3> Answer 63032 Phillip Koebbe: </h3><p>Depending on your needs and programming style, you can also use a combination of the new method of the class and merge. For lack of a better <em>simple</em> example, suppose you have a task scheduled for a certain date and you want to duplicate it to another date. The actual attributes of the task aren't important, so:</p>

<pre>
old_task = Task.find(task_id)
new_task = Task.new(old_task.attributes.merge({:scheduled_on => some_new_date}))
</pre>

<p>will create a new task with <code>:id => nil</code>, <code>:scheduled_on => some_new_date</code>, and all other attributes the same as the original task. Using Task.new, you will have to explicitly call save, so if you want it saved automatically, change Task.new to Task.create.</p>

<p>Peace. </p>
<h4> Comment 18078269 bcackerman: </h4>Not quite sure how good of idea this is b/c you get <code>WARNING: Can&#39;t mass-assign protected attributes: id, due_date, created_at, updated_at</code> returned<br><h4> Comment 44840465 Ninigi: </h4>@RubenMartineJr. I know this is an old post, but yeah you can get around this by using &#39;.except&#39; on the attributes hash: new_task = Task.new(old_task.attributes.except(:attribute_you_dont_want&zwnj;&#8203;, :another_aydw).merge({:scheduled_on =&gt; some_new_date}))<br><h4> Comment 60911772 BenKoshy: </h4>old_task.attribtes assigns the ID field as well unfortunately. It&#39;s not working for me<br><h4> Comment 60911500 BenKoshy: </h4>@PhillipKoebbe thank you - but what if I want the id to not be null? I want rails to automatically assign a new id when i create the duplicate - is this possible?<br><h4> Comment 38095379 Ruben Martinez Jr.: </h4>When I do this, I get an unknown attribute error with one column because of a column that is there due to a has_many relationship. Is there any way around this?<br>------------------------------------------------------------------ <br><h3> Answer 9485535 Vaughn Draughon: </h3><p>You may also like the <a href="https://rubygems.org/gems/amoeba" rel="noreferrer">Amoeba gem</a> for ActiveRecord 3.2.</p>

<p>In your case, you probably want to make use of the <code>nullify</code>, <code>regex</code> or <code>prefix</code> options available in the configuration DSL.</p>

<p>It supports easy and automatic recursive duplication of <code>has_one</code>, <code>has_many</code> and <code>has_and_belongs_to_many</code> associations, field preprocessing and a highly flexible and powerful configuration DSL that can be applied both to the model and on the fly.</p>

<p>be sure to check out the <a href="https://github.com/rocksolidwebdesign/amoeba#readme" rel="noreferrer">Amoeba Documentation</a> but usage is pretty easy...</p>

<p>just</p>

<pre><code>gem install amoeba
</code></pre>

<p>or add </p>

<pre><code>gem 'amoeba'
</code></pre>

<p>to your Gemfile</p>

<p>then add the amoeba block to your model and run the <code>dup</code> method as usual</p>

<pre><code>class Post &lt; ActiveRecord::Base
  has_many :comments
  has_and_belongs_to_many :tags

  amoeba do
    enable
  end
end

class Comment &lt; ActiveRecord::Base
  belongs_to :post
end

class Tag &lt; ActiveRecord::Base
  has_and_belongs_to_many :posts
end

class PostsController &lt; ActionController
  def some_method
    my_post = Post.find(params[:id])
    new_post = my_post.dup
    new_post.save
  end
end
</code></pre>

<p>You can also control which fields get copied in numerous ways, but for example, if you wanted to prevent comments from being duplicated but you wanted to maintain the same tags, you could do something like this:</p>

<pre><code>class Post &lt; ActiveRecord::Base
  has_many :comments
  has_and_belongs_to_many :tags

  amoeba do
    exclude_field :comments
  end
end
</code></pre>

<p>You can also preprocess fields to help indicate uniqueness with both prefixes and suffixes as well as regexes. In addition, there are also numerous options so you can write in the most readable style for your purpose:</p>

<pre><code>class Post &lt; ActiveRecord::Base
  has_many :comments
  has_and_belongs_to_many :tags

  amoeba do
    include_field :tags
    prepend :title =&gt; "Copy of "
    append :contents =&gt; " (copied version)"
    regex :contents =&gt; {:replace =&gt; /dog/, :with =&gt; "cat"}
  end
end
</code></pre>

<p>Recursive copying of associations is easy, just enable amoeba on child models as well</p>

<pre><code>class Post &lt; ActiveRecord::Base
  has_many :comments

  amoeba do
    enable
  end
end

class Comment &lt; ActiveRecord::Base
  belongs_to :post
  has_many :ratings

  amoeba do
    enable
  end
end

class Rating &lt; ActiveRecord::Base
  belongs_to :comment
end
</code></pre>

<p>The configuration DSL has yet more options, so be sure to check out the documentation.</p>

<p>Enjoy! :)</p>
<h4> Comment 90613931 Victor Cordeiro Costa: </h4>Just a fix here. The correct method is <code>.amoeba_dup</code>, not just <code>.dup</code>. I was trying to execute this code, but it was not working on here.<br><h4> Comment 28478585 Mohd Anas: </h4>Thanks it works!! But i have one question how do i add new entries with the cloning before saving the cloned object?<br>------------------------------------------------------------------ <br><h3> Answer 6957504 bradgonesurfing: </h3><p>Use <a href="http://api.rubyonrails.org/classes/ActiveRecord/Core.html#method-i-dup" rel="noreferrer">ActiveRecord::Base#dup</a> if you don't want to copy the id</p>
<h4> Comment 73726869 Dan Weaver: </h4>@Thorin as per the accepted answer above, it looks like the correct method for Rails &lt; 3.1 is <code>.clone</code><br>------------------------------------------------------------------ <br><h3> Answer 62925 Fran&#231;ois Beausoleil: </h3><p>I usually just copy the attributes, changing whatever I need changing:</p>

<pre><code>new_user = User.new(old_user.attributes.merge(:login =&gt; "newlogin"))
</code></pre>
<h4> Comment 46368989 RajeshM: </h4>To create a new record with with Rails 4, do <code>User.create(old_user.attributes.merge({ login: &quot;newlogin&quot;, id: nil }))</code>. This will save a new user with the correct unique id.<br><h4> Comment 88721673 kucaahbe: </h4>Rails has <a href="http://api.rubyonrails.org/classes/Hash.html#method-i-except" rel="nofollow noreferrer">Hash#except</a> and <a href="http://api.rubyonrails.org/classes/Hash.html#method-i-slice" rel="nofollow noreferrer">Hash#slice</a>, potentially making suggested method most powerful and less error-prone. No need to add additional libs, easy to extend.<br><h4> Comment 38095340 Ruben Martinez Jr.: </h4>When I do this, I get an <code>unknown attribute</code> error with one column because of a column that is there due to a has_many relationship. Is there any way around this?<br><h4> Comment 46337458 Ben: </h4>with rails4, it does not create a unique id for the record<br>------------------------------------------------------------------ <br><h3> Answer 7265525 raidfive: </h3><p>If you need a deep copy with associations, I recommend the <a href="https://github.com/moiristo/deep_cloneable">deep_cloneable</a> gem.</p>
<h4> Comment 14381829 Rob: </h4>Me too. I tried this gem and it worked first time, very easy to use.<br>------------------------------------------------------------------ <br><h3> Answer 40329894 ThienSuBS: </h3><p>The easily way is:</p>

<pre><code>#your rails &gt;= 3.1 (i was done it with Rails 5.0.0.1)
  o = Model.find(id)
 # (Range).each do |item|
 (1..109).each do |item|
   new_record = o.dup
   new_record.save
 end
</code></pre>

<p>Or </p>

<pre><code># if your rails &lt; 3.1
 o = Model.find(id)
 (1..109).each do |item|
   new_record = o.clone
   new_record.save
 end     
</code></pre>
------------------------------------------------------------------ <br><h3> Answer 51925581 Zoran Majstorovic: </h3><p>Here is a sample of overriding ActiveRecord <code>#dup</code> method to customize instance duplication and include relation duplication as well:</p>

<pre><code>class Offer &lt; ApplicationRecord
  has_many :offer_items

  def dup
    super.tap do |new_offer|

      # change title of the new instance
      new_offer.title = "Copy of #{@offer.title}"

      # duplicate offer_items as well
      self.offer_items.each { |offer_item| new_offer.offer_items &lt;&lt; offer_item.dup }
    end
  end
end
</code></pre>

<p>Note: this method doesn't require any external gem but it requires newer ActiveRecord version with <code>#dup</code> method implemented</p>
------------------------------------------------------------------ <br><h3> Answer 33379580 esbanarango: </h3><p>You can also check the <a href="https://github.com/esbanarango/acts_as_inheritable" rel="nofollow">acts_as_inheritable</a> gem.</p>

<p>"Acts As Inheritable is a Ruby Gem specifically written for Rails/ActiveRecord models. It is meant to be used with the <a href="https://github.com/esbanarango/acts_as_inheritable#self-referential-association" rel="nofollow">Self-Referential Association</a>, or with a model having a parent that share the inheritable attributes. This will let you inherit any attribute or relation from the parent model."</p>

<p>By adding <code>acts_as_inheritable</code> to your models you will have access to these methods:</p>

<p><strong>inherit_attributes</strong></p>

<pre class="lang-ruby prettyprint-override"><code>class Person &lt; ActiveRecord::Base

  acts_as_inheritable attributes: %w(favorite_color last_name soccer_team)

  # Associations
  belongs_to  :parent, class_name: 'Person'
  has_many    :children, class_name: 'Person', foreign_key: :parent_id
end

parent = Person.create(last_name: 'Arango', soccer_team: 'Verdolaga', favorite_color:'Green')

son = Person.create(parent: parent)
son.inherit_attributes
son.last_name # =&gt; Arango
son.soccer_team # =&gt; Verdolaga
son.favorite_color # =&gt; Green
</code></pre>

<p><strong>inherit_relations</strong></p>

<pre class="lang-ruby prettyprint-override"><code>class Person &lt; ActiveRecord::Base

  acts_as_inheritable associations: %w(pet)

  # Associations
  has_one     :pet
end

parent = Person.create(last_name: 'Arango')
parent_pet = Pet.create(person: parent, name: 'Mango', breed:'Golden Retriver')
parent_pet.inspect #=&gt; #&lt;Pet id: 1, person_id: 1, name: "Mango", breed: "Golden Retriver"&gt;

son = Person.create(parent: parent)
son.inherit_relations
son.pet.inspect # =&gt; #&lt;Pet id: 2, person_id: 2, name: "Mango", breed: "Golden Retriver"&gt;
</code></pre>

<p>Hope this can help you.</p>
------------------------------------------------------------------ <br><h3> Answer 49322942 Paulo Fidalgo: </h3><p>Since there could be more logic, when duplicating a model, I would suggest to create a new class, where you handle all the needed logic.
To ease that, there's a gem that can help: <a href="https://github.com/palkan/clowne" rel="nofollow noreferrer">clowne</a></p>

<p>As per their documentation examples, for a User model:</p>

<pre><code>class User &lt; ActiveRecord::Base
  # create_table :users do |t|
  #  t.string :login
  #  t.string :email
  #  t.timestamps null: false
  # end

  has_one :profile
  has_many :posts
end
</code></pre>

<p>You create your cloner class:</p>

<pre><code>class UserCloner &lt; Clowne::Cloner
  adapter :active_record

  include_association :profile, clone_with: SpecialProfileCloner
  include_association :posts

  nullify :login

  # params here is an arbitrary Hash passed into cloner
  finalize do |_source, record, params|
    record.email = params[:email]
  end
end

class SpecialProfileCloner &lt; Clowne::Cloner
  adapter :active_record

  nullify :name
end
</code></pre>

<p>and then use it:</p>

<pre><code>user = User.last
#=&gt; &lt;#User(login: 'clown', email: 'clown@circus.example.com')&gt;

cloned = UserCloner.call(user, email: 'fake@example.com')
cloned.persisted?
# =&gt; false

cloned.save!
cloned.login
# =&gt; nil
cloned.email
# =&gt; "fake@example.com"

# associations:
cloned.posts.count == user.posts.count
# =&gt; true
cloned.profile.name
# =&gt; nil
</code></pre>

<p>Example copied from the project, but it will give a clear vision of what you can achieve.</p>

<p><strong>For a quick and simple record I would go with:</strong></p>

<p><code>Model.new(Model.last.attributes.reject {|k,_v| k.to_s == 'id'}</code></p>
------------------------------------------------------------------ <br><h3> Answer 66943947 Sachin Singh: </h3><p>Try rails's <code>dup</code> method:</p>
<pre><code>new_record = old_record.dup.save
</code></pre>
