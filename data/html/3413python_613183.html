 <h2> Title: How do I sort a dictionary by value? </h2> <h3> Gern Blanston, question_id: 613183 </h3>Score: 3413, Tags: {python,sorting,dictionary} <br><p>I have a dictionary of values read from two fields in a database: a string field and a numeric field. The string field is unique, so that is the key of the dictionary.</p>

<p>I can sort on the keys, but how can I sort based on the values?</p>

<p>Note: I have read Stack Overflow question here <em><a href="https://stackoverflow.com/questions/72899">How do I sort a list of dictionaries by a value of the dictionary?</a></em> and probably could change my code to have a list of dictionaries, but since I do not really need a list of dictionaries I wanted to know if there is a simpler solution to sort either in ascending or descending order.</p>
<h4> Comment 20901347 bobpaul: </h4>&quot;sorted()&quot; can operate on dictionaries (and returns a list of sorted keys), so I think he&#39;s aware of this. Without knowing his program, it&#39;s absurd to tell someone they&#39;re using the wrong data structure. If fast lookups are what you need 90% of the time, then a dict is probably what you want.<br><h4> Comment 3270272 Daishiman: </h4>The dictionary data structure does not have inherent order. You can iterate through it but there&#39;s nothing to guarantee that the iteration will follow any particular order. This is by design, so your best bet is probaly using anohter data structure for representation.<br><h4> Comment 79215136 Taylor D. Edmiston: </h4>@Daishiman The base class might not be ordered but <a href="https://docs.python.org/3/library/collections.html#collections.OrderedDict" rel="nofollow noreferrer">OrderedDict</a> is of course.<br><h4> Comment 94813348 Konrad Kocik: </h4>In Python 3.6+ dictionaries preserve insertion order. This is, of course, not the same as possibility of sorting them by value, but on the other hand it is no longer valid to say that &quot;dictionary data structure does not have inherent order&quot;.<br><h4> Comment 59347975 JStrahl: </h4>All three outputs (keys, values, both) for sorting dictionaries are covered here in a clear and concise style: <a href="http://stackoverflow.com/questions/16772071/sort-dict-by-value-python" title="sort dict by value python">stackoverflow.com/questions/16772071/sort-dict-by-value-pyth&zwnj;&#8203;on</a><br>------------------------------------------------------------------ <br><h3> Answer 613218 Devin Jeanpierre: </h3><h3>Python 3.7+ or CPython 3.6</h3>
<p>Dicts preserve insertion order in Python 3.7+. Same in CPython 3.6, but <a href="https://stackoverflow.com/q/39980323/4518341">it's an implementation detail</a>.</p>
<pre><code>&gt;&gt;&gt; x = {1: 2, 3: 4, 4: 3, 2: 1, 0: 0}
&gt;&gt;&gt; {k: v for k, v in sorted(x.items(), key=lambda item: item[1])}
{0: 0, 2: 1, 1: 2, 4: 3, 3: 4}
</code></pre>
<p>or</p>
<pre><code>&gt;&gt;&gt; dict(sorted(x.items(), key=lambda item: item[1]))
{0: 0, 2: 1, 1: 2, 4: 3, 3: 4}
</code></pre>
<h3>Older Python</h3>
<p>It is not possible to sort a dictionary, only to get a representation of a dictionary that is sorted. Dictionaries are inherently orderless, but other types, such as lists and tuples, are not. So you need an ordered data type to represent sorted values, which will be a listâ€”probably a list of tuples.</p>
<p>For instance,</p>
<pre><code>import operator
x = {1: 2, 3: 4, 4: 3, 2: 1, 0: 0}
sorted_x = sorted(x.items(), key=operator.itemgetter(1))
</code></pre>
<p><code>sorted_x</code> will be a list of tuples sorted by the second element in each tuple. <code>dict(sorted_x) == x</code>.</p>
<p>And for those wishing to sort on keys instead of values:</p>
<pre><code>import operator
x = {1: 2, 3: 4, 4: 3, 2: 1, 0: 0}
sorted_x = sorted(x.items(), key=operator.itemgetter(0))
</code></pre>
<p>In Python3 since <a href="https://stackoverflow.com/a/15712231/4293057">unpacking is not allowed</a> we can use</p>
<pre><code>x = {1: 2, 3: 4, 4: 3, 2: 1, 0: 0}
sorted_x = sorted(x.items(), key=lambda kv: kv[1])
</code></pre>
<p>If you want the output as a dict, you can use <a href="https://docs.python.org/3/library/collections.html#collections.OrderedDict" rel="noreferrer"><code>collections.OrderedDict</code></a>:</p>
<pre><code>import collections

sorted_dict = collections.OrderedDict(sorted_x)
</code></pre>
<h4> Comment 3270439 rmh: </h4>saidimu: Since we&#39;re already using <code>sorted()</code>, it&#39;s much more efficient to pass in the <code>reverse=True</code> argument.<br><h4> Comment 2787661 saidimu apale: </h4><code>sorted_x.reverse()</code> will give you a descending ordering (by the second tuple element)<br><h4> Comment 5594141 Benbob: </h4>In python3 I used a lambda: <code>sorted(d.items(), key=lambda x: x[1])</code>. Will this work in python 2.x?<br><h4> Comment 459741 Gregg Lind: </h4>for timings on various dictionary sorting by value schemes:  <a href="http://writeonly.wordpress.com/2008/08/30/sorting-dictionaries-by-value-in-python-improved/" rel="nofollow noreferrer">writeonly.wordpress.com/2008/08/30/&hellip;</a><br><h4> Comment 123505096 UdonN00dle: </h4>Where can I read more about the usage of <code>key=lambda item :item[1]</code> please? The part I don&#39;t quite understand is the <code>item[1]</code>, is it because when we do <code>x.items()</code> it returns the key-value pairs and with this we can tap into the value by doing <code>item[1]</code>?<br><h4> Comment 121379336 Hamza: </h4>Why this is not working now {k: v for k, v in sorted(x.items(), key=lambda item: item[1])}<br><h4> Comment 118874584 haneulkim: </h4>in case of value have same value how to ensure value with smaller key come first?<br><h4> Comment 120436038 Uros Pocek: </h4>map = {k: v for k, v in sorted(map.items(), key=lambda item: item[1], reverse=True)} use this for reverse(descending) order.<br><h4> Comment 126816731 CN_Cabbage: </h4>just remind that OrderedDict cannot output the sorted dictionary by value.<br><h4> Comment 133813027 plugwash: </h4>@UdonN00dle yes, dict.keys() returns an iterable object whose elements are (key,value) tuples. Sorted passes those elements to the &quot;key=&quot; function/lambda to get the sort key (not to be confused with the dictionary key). So yes &quot;lambda item :item[1]&quot; is taking a (key,value) tuple and extracting the value.<br><h4> Comment 134819258 404rorre: </h4>you can also use also a list comprehension for a dictionary. Pretty straight forward in my opinion. <code>sorted_x = {key: value for key, value in sorted_x}</code><br>------------------------------------------------------------------ <br><h3> Answer 3177911 Nas Banov: </h3><h2>As simple as: <code>sorted(dict1, key=dict1.get)</code></h2>

<p>Well, it is actually possible to do a "sort by dictionary values". Recently I had to do that in a Code Golf (Stack Overflow question <em><a href="https://stackoverflow.com/questions/3169051/code-golf-word-frequency-chart#3170549">Code golf: Word frequency chart</a></em>). Abridged, the problem was of the kind: given a text, count how often each word is encountered and display a list of the top words, sorted by decreasing frequency. </p>

<p>If you construct a dictionary with the words as keys and the number of occurrences of each word as value, simplified here as:</p>

<pre><code>from collections import defaultdict
d = defaultdict(int)
for w in text.split():
    d[w] += 1
</code></pre>

<p>then you can get a list of the words, ordered by frequency of use with <a href="https://docs.python.org/library/functions.html#sorted" rel="noreferrer"><code>sorted(d, key=d.get)</code></a> - the sort iterates over the dictionary keys, using the number of word occurrences as a sort key . </p>

<pre><code>for w in sorted(d, key=d.get, reverse=True):
    print(w, d[w])
</code></pre>

<p>I am writing this detailed explanation to illustrate what people often mean by "I can easily sort a dictionary by key, but how do I sort by value" - and I think the original post was trying to address such an issue. And the solution is to do sort of list of the keys, based on the values, as shown above.</p>
<h4> Comment 10448097 smci: </h4>This is also good but <i><code>key=operator.itemgetter(1)</code></i> should be more scalable for efficiency than <i><code>key=d.get</code></i><br><h4> Comment 76481868 Eevee: </h4>i have come from the future to tell you of <code>collections.Counter</code>, which has a <code>most_common</code> method that might interest you  :)<br><h4> Comment 39602912 Izkata: </h4>@bli <code>sorted_keys = sorted(d.items(), key=itemgetter(1), reverse=True)</code> and <code>for key, val in sorted_keys: print &quot;%s: %d&quot; % (key, val)</code> - itemgetter creates a function when it&#39;s called, you don&#39;t use it directly like in your example.  And a plain iteration on a dict uses the keys without the values<br><h4> Comment 130810386 dantiston: </h4>@Eevee fun fact Counter was <a href="https://docs.python.org/3.10/library/collections.html#counter-objects" rel="nofollow noreferrer">new in 3.1</a> which was <a href="https://www.python.org/download/releases/3.1/" rel="nofollow noreferrer">released in 2009</a>, so this answer was always outdated :-)<br><h4> Comment 136808890 ThisGuyCantEven: </h4>You can also use this in a dictionary comprehension: <code>sorted_words = {key:words[key] for key in sorted(words,key=words.get)}</code><br><h4> Comment 136873355 Nas Banov: </h4>@ThisGuyCantEven if you want to construct a <i>new</i> dictionary, see it covered in answer <a href="https://stackoverflow.com/a/613218/226086">stackoverflow.com/a/613218/226086</a> above. Note dictionary order preserved only since Python 3.7+ (last 5 years)<br><h4> Comment 136877114 ThisGuyCantEven: </h4>Considering 3.7 was EOL 5 months ago, and 3.6 was EOL over 2yrs ago. I would not recommend any solution &lt;3.7 (really &lt;3.8) unless the ultimate goal is to open a ton of security holes in your application &lt;3&lt;3. But you could always just use an <code>OrderedDict</code>.<br>------------------------------------------------------------------ <br><h3> Answer 2258273 Mark: </h3><p>You could use:</p>

<pre><code>sorted(d.items(), key=lambda x: x[1])
</code></pre>

<p>This will sort the dictionary by the values of each entry within the dictionary from smallest to largest.</p>

<p>To sort it in descending order just add <code>reverse=True</code>:</p>

<pre><code>sorted(d.items(), key=lambda x: x[1], reverse=True)
</code></pre>

<p><strong>Input:</strong></p>

<pre><code>d = {'one':1,'three':3,'five':5,'two':2,'four':4}
a = sorted(d.items(), key=lambda x: x[1])    
print(a)
</code></pre>

<p><strong>Output:</strong></p>

<pre><code>[('one', 1), ('two', 2), ('three', 3), ('four', 4), ('five', 5)]
</code></pre>
<h4> Comment 47252672 Claudiu: </h4>I&#39;d prefer <code>key=lambda (k, v): v</code> personally<br><h4> Comment 58175437 Bob Stein: </h4>@Claudiu I like that <code>(k, v)</code> syntax too, but it&#39;s not available in Python 3 where <a href="https://www.python.org/dev/peps/pep-3113/" rel="nofollow noreferrer">tuple parameter unpacking</a> was removed.<br><h4> Comment 97286619 tsveti_iko: </h4>If you wrap this in an <code>OrderedDict()</code> instance you will get a (ordered) dict instead of list of tuples!<br><h4> Comment 21031477 UsAndRufus: </h4>From what I&#39;ve seen (<a href="http://docs.python.org/2/library/collections.html?highlight=ordereddict#ordereddict-examples-and-recipes" rel="nofollow noreferrer">docs.python.org/2/library/&hellip;</a>), there is a class called OrderedDict which can be sorted and retain order whilst still being a dictionary. From the code examples, you can use lambda to sort it, but I haven&#39;t tried it out personally :P<br><h4> Comment 55249296 dhj: </h4>@Keyo shouldn&#39;t that be it returns an ordered list of keys (sorted by values) not <code>(k,v)</code> tuples? That&#39;s what I get with Python 2.7.10.   @Nyxynyx add the parameter reverse=True to sort in descending order.<br><h4> Comment 133611801 John Glen: </h4>This worked, and for some reason the top answers did not.<br><h4> Comment 123276799 Bhavika Ramesh: </h4>What if the dictionary has multiple values with the same value and we would want to sort the dictionary which consists of multiple same values where smaller value frequency gets printed first followed by larger value?<br>------------------------------------------------------------------ <br><h3> Answer 613228 Roberto Bonvallet: </h3><p>Dicts can't be sorted, but you can build a sorted list from them.</p>

<p>A sorted list of dict values:</p>

<pre><code>sorted(d.values())
</code></pre>

<p>A list of (key, value) pairs, sorted by value:</p>

<pre><code>from operator import itemgetter
sorted(d.items(), key=itemgetter(1))
</code></pre>
<h4> Comment 108645446 user3064538: </h4>Dicts can now be sorted, starting with CPython 3.6 and all other Python implementations starting with 3.7<br><h4> Comment 14505868 SabreWolfy: </h4>What order are keys with the same value placed in? I sorted the list by keys first, then by values, but the order of the keys with the same value does not remain.<br><h4> Comment 126263725 c8999c 3f964f64: </h4>True at the time, but now python dictionaries preserve the order in which items were inserted already by default. And therefore they can be sorted.<br>------------------------------------------------------------------ <br><h3> Answer 3177025 mykhal: </h3><p>In recent Python 2.7, we have the new <a href="http://docs.python.org/dev/whatsnew/2.7.html#pep-372-adding-an-ordered-dictionary-to-collections" rel="noreferrer">OrderedDict</a> type, which remembers the order in which the items were added.</p>

<pre><code>&gt;&gt;&gt; d = {"third": 3, "first": 1, "fourth": 4, "second": 2}

&gt;&gt;&gt; for k, v in d.items():
...     print "%s: %s" % (k, v)
...
second: 2
fourth: 4
third: 3
first: 1

&gt;&gt;&gt; d
{'second': 2, 'fourth': 4, 'third': 3, 'first': 1}
</code></pre>

<p>To make a new ordered dictionary from the original, sorting by the values:</p>

<pre><code>&gt;&gt;&gt; from collections import OrderedDict
&gt;&gt;&gt; d_sorted_by_value = OrderedDict(sorted(d.items(), key=lambda x: x[1]))
</code></pre>

<p>The OrderedDict behaves like a normal dict:</p>

<pre><code>&gt;&gt;&gt; for k, v in d_sorted_by_value.items():
...     print "%s: %s" % (k, v)
...
first: 1
second: 2
third: 3
fourth: 4

&gt;&gt;&gt; d_sorted_by_value
OrderedDict([('first': 1), ('second': 2), ('third': 3), ('fourth': 4)])
</code></pre>
<h4> Comment 3272707 mykhal: </h4>@Nas Banov: it is NOT sorting by the key. it is sorting in the order, we create the items. in our case, we sort by the value. unfortunately, the 3-item dict was unfortunately chosen so the order was the same, when sorted voth by value and key, so i expanded the sample dict.<br><h4> Comment 3271246 Nas Banov: </h4>This is not what the question is about - it is not about maintaining order of keys but about &quot;sorting by value&quot;<br><h4> Comment 102011442 ShadowRanger: </h4>Note: As of 3.6 (as a CPython/PyPy implementation detail) and as of 3.7 (as a Python language guarantee), plain <code>dict</code> is insertion ordered as well, so you can just replace <code>OrderedDict</code> with <code>dict</code> for code running on modern Python. <code>OrderedDict</code> isn&#39;t really needed anymore unless you need to rearrange the order of an existing <code>dict</code> (with <code>move_to_end</code>/<code>popitem</code>) or need equality comparisons to be order-sensitive. It uses a lot more memory than plain <code>dict</code>, so if you can, <code>dict</code> is the way to go.<br><h4> Comment 86527438 BallpointBen: </h4>@Boern <code>d.items()</code> returns a list-like container of <code>(key, value)</code> tuples. <code>[0]</code> accesses the first element of the tuple -- the key -- and <code>[1]</code> accesses the second element -- the value.<br><h4> Comment 29524413 JZAU: </h4><code>sorted(d.items(), key=lambda x: x[1])</code> Can you explain what the <code>x</code> means, why it can take <code>x[1]</code> to lambda? Why does it can&#39;t be <code>x[0]</code>? Thank you very much!<br><h4> Comment 29891536 CadentOrange: </h4>@jie <code>d.items()</code> returns a list of key/value pairs from the dictionary and <code>x</code> is an element of this tuple. <code>x[0]</code> will be key and <code>x[1]</code> will be the value. As we intend to sort on the value, we pass <code>x[1]</code> to the lambda.<br><h4> Comment 78927514 Boern: </h4>may be a stupid question: <code>x: x[1]</code> - what does the <code>1</code> access? The value itself? What is <code>0</code> then? The key?<br>------------------------------------------------------------------ <br><h3> Answer 34103440 arcseldon: </h3><h3>Using Python 3.5</h3>
<p>Whilst I found the accepted answer useful, I was also surprised that it hasn't been updated to reference <strong><a href="https://docs.python.org/3/library/collections.html#collections.OrderedDict" rel="nofollow noreferrer">OrderedDict</a></strong> from the standard library <strong>collections</strong> module as a viable, modern alternative - designed to solve exactly this type of problem.</p>
<pre><code>from operator import itemgetter
from collections import OrderedDict

x = {1: 2, 3: 4, 4: 3, 2: 1, 0: 0}
sorted_x = OrderedDict(sorted(x.items(), key=itemgetter(1)))
# OrderedDict([(0, 0), (2, 1), (1, 2), (4, 3), (3, 4)])
</code></pre>
<p>The official <strong><a href="https://docs.python.org/3/library/collections.html#collections.OrderedDict" rel="nofollow noreferrer">OrderedDict</a></strong> documentation offers a very similar example too, but using a lambda for the sort function:</p>
<pre><code># regular unsorted dictionary
d = {'banana': 3, 'apple':4, 'pear': 1, 'orange': 2}

# dictionary sorted by value
OrderedDict(sorted(d.items(), key=lambda t: t[1]))
# OrderedDict([('pear', 1), ('orange', 2), ('banana', 3), ('apple', 4)])
</code></pre>
<h4> Comment 126263884 c8999c 3f964f64: </h4>can you explain what itemgetter does in this example? otherwise this seems just as cryptic as using a lamba<br>------------------------------------------------------------------ <br><h3> Answer 613230 user26294: </h3><p>Pretty much the same as <a href="https://stackoverflow.com/a/613207/11044033">Hank Gay's answer</a>:</p>

<pre><code>sorted([(value,key) for (key,value) in mydict.items()])
</code></pre>

<p>Or optimized slightly as suggested by John Fouhy:</p>

<pre><code>sorted((value,key) for (key,value) in mydict.items())
</code></pre>
<h4> Comment 426122 John Fouhy: </h4>..and as with Hank Gay&#39;s answer, you don&#39;t need the square brackets.  sorted() will happily take any iterable, such as a generator expression.<br><h4> Comment 82368076 Jean-Fran&#231;ois Fabre: </h4>no, it&#39;s better to leave square brackets, because <code>sorted</code> will have to rebuild the list anyway, and rebuilding from gencomp will be faster. Good for codegolfing, bad for speed. Keep the ugly <code>([])</code> version.<br><h4> Comment 128345565 melMass: </h4>I&#39;m confused, this returns an array of tuples not a dict. IMO you are missing the dict comprehension part:  <code>{x: v for x, v in sorted((value, key) for (key, value) in mydict.items())}</code><br><h4> Comment 2787653 saidimu apale: </h4>You may still need to swap the (value,key) tuple elements to end up with the (key, value). Another list comprehension is then needed.  <code>[(key, value) for (value, key) in sorted_list_of_tuples]</code><br>------------------------------------------------------------------ <br><h3> Answer 39424969 Dilettant: </h3><h1>As of <a href="https://docs.python.org/3.6/whatsnew/3.6.html" rel="noreferrer">Python 3.6</a> the built-in dict will be ordered</h1>

<p>Good news, so the OP's original use case of mapping pairs retrieved from a database with unique string ids as keys and numeric values as values into a built-in Python v3.6+ dict, should now respect the insert order.</p>

<p>If say the resulting two column table expressions from a database query like:</p>

<pre><code>SELECT a_key, a_value FROM a_table ORDER BY a_value;
</code></pre>

<p>would be stored in two Python tuples, k_seq and v_seq (aligned by numerical index and with the same length of course), then:</p>

<pre><code>k_seq = ('foo', 'bar', 'baz')
v_seq = (0, 1, 42)
ordered_map = dict(zip(k_seq, v_seq))
</code></pre>

<p>Allow to output later as:</p>

<pre><code>for k, v in ordered_map.items():
    print(k, v)
</code></pre>

<p>yielding in this case (for the new Python 3.6+ built-in dict!):</p>

<pre><code>foo 0
bar 1
baz 42
</code></pre>

<p>in the same ordering per value of v.</p>

<p>Where in the Python 3.5 install on my machine it currently yields:</p>

<pre><code>bar 1
foo 0
baz 42
</code></pre>

<h2>Details:</h2>

<p>As proposed in 2012 by Raymond Hettinger (cf. mail on python-dev with subject <a href="https://mail.python.org/pipermail/python-dev/2012-December/123028.html" rel="noreferrer">"More compact dictionaries with faster iteration"</a>) and now (in 2016) announced in a mail by Victor Stinner to python-dev with subject <a href="https://mail.python.org/pipermail/python-dev/2016-September/146327.html" rel="noreferrer">"Python 3.6 dict becomes compact and gets a private version; and keywords become ordered"</a> due to the fix/implementation of issue 27350 <a href="http://bugs.python.org/issue27350" rel="noreferrer">"Compact and ordered dict"</a> in Python 3.6 we will now be able, to use a built-in dict to maintain insert order!!</p>

<p>Hopefully this will lead to a thin layer OrderedDict implementation as a first step. As @JimFasarakis-Hilliard indicated, some see use cases for the OrderedDict type also in the future. I think the Python community at large will carefully inspect, if this will stand the test of time, and what the next steps will be.</p>

<p>Time to rethink our coding habits to not miss the possibilities opened by stable ordering of:</p>

<ul>
<li>Keyword arguments and</li>
<li>(intermediate) dict storage</li>
</ul>

<p>The first because it eases dispatch in the implementation of functions and methods in some cases.</p>

<p>The second as it encourages to more easily use <code>dict</code>s as intermediate storage in processing pipelines.</p>

<p>Raymond Hettinger kindly provided documentation explaining "<a href="https://dl.dropboxusercontent.com/u/3967849/sfmu2/_build/html/goal.html" rel="noreferrer" title="The Tech Behind Python 3.6 Dictionaries">The Tech Behind Python 3.6 Dictionaries</a>" - from his San Francisco Python Meetup Group presentation 2016-DEC-08.</p>

<p>And maybe quite some Stack Overflow high decorated question and answer pages will receive variants of this information and many high quality answers will require a per version update too.</p>

<h3>Caveat Emptor (but also see below update 2017-12-15):</h3>

<p>As @ajcr rightfully notes: "The order-preserving aspect of this new implementation is considered an implementation detail and should not be relied upon." (from the <a href="https://docs.python.org/3.6/whatsnew/3.6.html" rel="noreferrer">whatsnew36</a>) not nit picking, <strong>but</strong> the citation was cut a bit pessimistic ;-). It continues as " (this may change in the future, but it is desired to have this new dict implementation in the language for a few releases before changing the language spec to mandate order-preserving semantics for all current and future Python implementations; this also helps preserve backwards-compatibility with older versions of the language where random iteration order is still in effect, e.g. Python 3.5)."</p>

<p>So as in some human languages (e.g. German), usage shapes the language, and the will now has been declared ... in <a href="https://docs.python.org/3.6/whatsnew/3.6.html" rel="noreferrer">whatsnew36</a>.</p>

<h3>Update 2017-12-15:</h3>

<p>In a <a href="https://mail.python.org/pipermail/python-dev/2017-December/151283.html" rel="noreferrer">mail to the python-dev list</a>, Guido van Rossum declared:</p>

<blockquote>
  <p>Make it so. "Dict keeps insertion order" is the ruling. Thanks! </p>
</blockquote>

<p>So, the version 3.6 CPython side-effect of dict insertion ordering is now becoming part of the language spec (and not anymore only an implementation detail). That mail thread also surfaced some distinguishing design goals for <code>collections.OrderedDict</code> as reminded by Raymond Hettinger during discussion.</p>
<h4> Comment 85153020 Bram Vanroy: </h4>In a response to this answer, and structured dicts, I posted <a href="https://stackoverflow.com/questions/613183/how-do-i-sort-a-dictionary-by-value/49073645#49073645">a new answer</a>. Feedback welcome!<br><h4> Comment 66183881 Dilettant: </h4>@ajcr thanks for the caveat, very appreciated -  as smileys and maybe&#39;s were weaved into my response,these should indicated, the change is massive but of course, only available for CPython (reference implementation) and PyPy. For something completely different ... I rarely talk to non-implementation details when coding man-machine instructions. If it would only have been Jython ;-) ... I might not have had the courage to write it.<br><h4> Comment 69358529 Dimitris Fasarakis Hilliard: </h4><code>OrderedDict</code> definitely won&#39;t be dropped; instead, it will become a thin wrapper around the current dict implementation (so you might add that it will become more compact, too). Adding that snippet with the <code>ImportError</code> isn&#39;t quite the best idea due to it misleading readers that <code>OrderedDict</code> has no use.<br>------------------------------------------------------------------ <br><h3> Answer 7237524 Remi: </h3><p>It can often be very handy to use <b><a href="http://docs.python.org/library/collections.html#collections.namedtuple" rel="noreferrer">namedtuple</a></b>. For example, you have a dictionary of 'name' as keys and 'score' as values and you want to sort on 'score':</p>

<pre><code>import collections
Player = collections.namedtuple('Player', 'score name')
d = {'John':5, 'Alex':10, 'Richard': 7}
</code></pre>

<p>sorting with lowest score first:</p>

<pre><code>worst = sorted(Player(v,k) for (k,v) in d.items())
</code></pre>

<p>sorting with highest score first:</p>

<pre><code>best = sorted([Player(v,k) for (k,v) in d.items()], reverse=True)
</code></pre>

<p>Now you can get the name and score of, let's say the second-best player (index=1) very Pythonically like this:</p>

<pre><code>player = best[1]
player.name
    'Richard'
player.score
    7
</code></pre>
<h4> Comment 71369022 rowana: </h4>How could I convert it back to a dictionary?<br><h4> Comment 71976890 Remi: </h4>as_list=[Player(v,k) for (k,v) in d.items()]       as_dict=dict((p.name,p.score) for p in as_list)<br>------------------------------------------------------------------ <br><h3> Answer 52345214 Maxime Ch&#233;ramy: </h3><p>Starting from Python 3.6, <code>dict</code> objects are now ordered by insertion order. It's officially in the specifications of Python 3.7.</p>
<pre><code>&gt;&gt;&gt; words = {&quot;python&quot;: 2, &quot;blah&quot;: 4, &quot;alice&quot;: 3}
&gt;&gt;&gt; dict(sorted(words.items(), key=lambda x: x[1]))
{'python': 2, 'alice': 3, 'blah': 4}
</code></pre>
<p>Before that, you had to use <code>OrderedDict</code>.</p>
<p><a href="https://docs.python.org/3.7/library/stdtypes.html#typesmapping" rel="noreferrer">Python 3.7 documentation</a> says:</p>
<blockquote>
<p>Changed in version 3.7: Dictionary order is guaranteed to be insertion
order. This behavior was implementation detail of CPython from 3.6.</p>
</blockquote>
<h4> Comment 93639658 vizyourdata: </h4>works great! <code>dict(sorted(words.items(), key=lambda x: x[1], reverse=True))</code> for DESC<br><h4> Comment 136807980 ThisGuyCantEven: </h4>Also this works : <code>{key:words[key] for key in sorted(words,key=words.get)}</code> (add <code>reverse=True</code> for DESC)<br>------------------------------------------------------------------ <br><h3> Answer 4215710 jimifiki: </h3><p>I had the same problem, and I solved it like this:</p>

<pre><code>WantedOutput = sorted(MyDict, key=lambda x : MyDict[x]) 
</code></pre>

<p>(People who answer "It is not possible to sort a dict" did not read the question! In fact, "I can sort on the keys, but how can I sort based on the values?" clearly means that he wants a list of the keys sorted according to the value of their values.)</p>

<p>Please notice that the order is not well defined (keys with the same value will be in an arbitrary order in the output list).</p>
<h4> Comment 95143642 Max: </h4>@Dejell: as the contributor says, he interprets the question as &quot;can I get the list of keys sorted according to the values&quot;. We don&#39;t need the values in the result, we have them in the dictionary.<br><h4> Comment 66528932 Ron Klein: </h4>Note that you&#39;re both iterating the dictionary and fetching values by their key, so performance wise this is not an optimal solution.<br>------------------------------------------------------------------ <br><h3> Answer 11230132 Ivan Sas: </h3><p>If values are numeric you may also use <a href="https://docs.python.org/library/collections.html#collections.Counter" rel="noreferrer"><code>Counter</code></a> from <a href="https://docs.python.org/library/collections.html" rel="noreferrer">collections</a>.</p>

<pre><code>from collections import Counter

x = {'hello': 1, 'python': 5, 'world': 3}
c = Counter(x)
print(c.most_common())

&gt;&gt; [('python', 5), ('world', 3), ('hello', 1)]    
</code></pre>
<h4> Comment 31210677 James Sapam: </h4>what about if you dictionary is &gt;&gt;&gt; x={&#39;hello&#39;:1,&#39;python&#39;:5, &#39;world&#39;:300}<br><h4> Comment 31211363 lvc: </h4>@yopy <code>Counter({&#39;hello&#39;:1, &#39;python&#39;:5, &#39;world&#39;:300}).most_common()</code> gives <code>[(&#39;world&#39;, 300), (&#39;python&#39;, 5), (&#39;hello&#39;, 1)]</code>. This actually works for any sortable value type (although many <i>other</i> Counter operations do require values to be comparable to ints).<br>------------------------------------------------------------------ <br><h3> Answer 18375444 sweetdream: </h3><p>In Python 2.7, simply do:</p>

<pre class="lang-py prettyprint-override"><code>from collections import OrderedDict
# regular unsorted dictionary
d = {'banana': 3, 'apple':4, 'pear': 1, 'orange': 2}

# dictionary sorted by key
OrderedDict(sorted(d.items(), key=lambda t: t[0]))
OrderedDict([('apple', 4), ('banana', 3), ('orange', 2), ('pear', 1)])

# dictionary sorted by value
OrderedDict(sorted(d.items(), key=lambda t: t[1]))
OrderedDict([('pear', 1), ('orange', 2), ('banana', 3), ('apple', 4)])
</code></pre>

<p>copy-paste from : <a href="http://docs.python.org/dev/library/collections.html#ordereddict-examples-and-recipes">http://docs.python.org/dev/library/collections.html#ordereddict-examples-and-recipes</a></p>

<p>Enjoy ;-)</p>
------------------------------------------------------------------ <br><h3> Answer 5227519 PedroMorgan: </h3><p>This is the code:</p>

<pre><code>import operator
origin_list = [
    {"name": "foo", "rank": 0, "rofl": 20000},
    {"name": "Silly", "rank": 15, "rofl": 1000},
    {"name": "Baa", "rank": 300, "rofl": 20},
    {"name": "Zoo", "rank": 10, "rofl": 200},
    {"name": "Penguin", "rank": -1, "rofl": 10000}
]
print "&gt;&gt; Original &gt;&gt;"
for foo in origin_list:
    print foo

print "\n&gt;&gt; Rofl sort &gt;&gt;"
for foo in sorted(origin_list, key=operator.itemgetter("rofl")):
    print foo

print "\n&gt;&gt; Rank sort &gt;&gt;"
for foo in sorted(origin_list, key=operator.itemgetter("rank")):
    print foo
</code></pre>

<p>Here are the results:</p>

<p><strong>Original</strong></p>

<pre><code>{'name': 'foo', 'rank': 0, 'rofl': 20000}
{'name': 'Silly', 'rank': 15, 'rofl': 1000}
{'name': 'Baa', 'rank': 300, 'rofl': 20}
{'name': 'Zoo', 'rank': 10, 'rofl': 200}
{'name': 'Penguin', 'rank': -1, 'rofl': 10000}
</code></pre>

<p><strong>Rofl</strong></p>

<pre><code>{'name': 'Baa', 'rank': 300, 'rofl': 20}
{'name': 'Zoo', 'rank': 10, 'rofl': 200}
{'name': 'Silly', 'rank': 15, 'rofl': 1000}
{'name': 'Penguin', 'rank': -1, 'rofl': 10000}
{'name': 'foo', 'rank': 0, 'rofl': 20000}
</code></pre>

<p><strong>Rank</strong> </p>

<pre><code>{'name': 'Penguin', 'rank': -1, 'rofl': 10000}
{'name': 'foo', 'rank': 0, 'rofl': 20000}
{'name': 'Zoo', 'rank': 10, 'rofl': 200}
{'name': 'Silly', 'rank': 15, 'rofl': 1000}
{'name': 'Baa', 'rank': 300, 'rofl': 20}
</code></pre>
------------------------------------------------------------------ <br><h3> Answer 22903797 Nathaniel Payne: </h3><p>Try the following approach. Let us define a dictionary called mydict with the following data:</p>

<pre><code>mydict = {'carl':40,
          'alan':2,
          'bob':1,
          'danny':3}
</code></pre>

<p>If one wanted to sort the dictionary by keys, one could do something like:</p>

<pre><code>for key in sorted(mydict.iterkeys()):
    print "%s: %s" % (key, mydict[key])
</code></pre>

<p>This should return the following output:</p>

<pre><code>alan: 2
bob: 1
carl: 40
danny: 3
</code></pre>

<p>On the other hand, if one wanted to sort a dictionary by value (as is asked in the question), one could do the following:</p>

<pre><code>for key, value in sorted(mydict.iteritems(), key=lambda (k,v): (v,k)):
    print "%s: %s" % (key, value)
</code></pre>

<p>The result of this command (sorting the dictionary by value) should return the following:</p>

<pre><code>bob: 1
alan: 2
danny: 3
carl: 40
</code></pre>
<h4> Comment 76931274 Andomar: </h4>Awesome! <code>for key, value in sorted(mydict.iteritems(), key=lambda (k,v): v[&quot;score&quot;]):</code> allows you to sort by a subkey<br><h4> Comment 119924329 lb_so: </h4>this doesn&#39;t work in later versions of python that dont support tuple unpacking and where dicts no longer have iteritems()<br>------------------------------------------------------------------ <br><h3> Answer 613326 S.Lott: </h3><p>You can create an "inverted index", also</p>

<pre><code>from collections import defaultdict
inverse= defaultdict( list )
for k, v in originalDict.items():
    inverse[v].append( k )
</code></pre>

<p>Now your inverse has the values; each value has a list of applicable keys.</p>

<pre><code>for k in sorted(inverse):
    print k, inverse[k]
</code></pre>
------------------------------------------------------------------ <br><h3> Answer 15310681 Abhijit: </h3><p>You can use the <a href="http://docs.python.org/2/library/collections.html#collections.Counter">collections.Counter</a>. Note, this will work for both numeric and non-numeric values.</p>

<pre><code>&gt;&gt;&gt; x = {1: 2, 3: 4, 4:3, 2:1, 0:0}
&gt;&gt;&gt; from collections import Counter
&gt;&gt;&gt; #To sort in reverse order
&gt;&gt;&gt; Counter(x).most_common()
[(3, 4), (4, 3), (1, 2), (2, 1), (0, 0)]
&gt;&gt;&gt; #To sort in ascending order
&gt;&gt;&gt; Counter(x).most_common()[::-1]
[(0, 0), (2, 1), (1, 2), (4, 3), (3, 4)]
&gt;&gt;&gt; #To get a dictionary sorted by values
&gt;&gt;&gt; from collections import OrderedDict
&gt;&gt;&gt; OrderedDict(Counter(x).most_common()[::-1])
OrderedDict([(0, 0), (2, 1), (1, 2), (4, 3), (3, 4)])
</code></pre>
<h4> Comment 34847147 Peter Mortensen: </h4>How is this different from <a href="http://stackoverflow.com/questions/613183/python-sort-a-dictionary-by-value/11230132#11230132">Ivan Sas&#39;s answer</a>?<br>------------------------------------------------------------------ <br><h3> Answer 22150003 Eamonn Kenny: </h3><p>The collections solution mentioned in another answer is absolutely superb, because you retain a connection between the key and value which in the case of dictionaries is extremely important.</p>
<p>I don't agree with the number one choice presented in another answer, because it throws away the keys.</p>
<p>I used the solution mentioned above (code shown below) and retained access to both keys and values and in my case the ordering was on the values, but the importance was the ordering of the keys after ordering the values.</p>
<pre><code>from collections import Counter

x = {'hello':1, 'python':5, 'world':3}
c=Counter(x)
print( c.most_common() )


&gt;&gt; [('python', 5), ('world', 3), ('hello', 1)]
</code></pre>
------------------------------------------------------------------ <br><h3> Answer 44187197 Vishwanath Rawat: </h3><p>You can also use a custom function that can be passed to parameter <em>key</em>.</p>
<pre><code>def dict_val(x):
    return x[1]

x = {1: 2, 3: 4, 4: 3, 2: 1, 0: 0}
sorted_x = sorted(x.items(), key=dict_val)
</code></pre>
<h4> Comment 130480815 Peter Mortensen: </h4>End-of-life for Python 2 was in 2020.<br><h4> Comment 116323245 rkochev: </h4>This is the only answer that worked so far in python 2.7<br>------------------------------------------------------------------ <br><h3> Answer 26049456 malthe: </h3><p>You can use a <a href="https://pypi.python.org/pypi/skipdict/1.0">skip dict</a> which is a dictionary that's permanently sorted by value.</p>

<pre><code>&gt;&gt;&gt; data = {1: 2, 3: 4, 4: 3, 2: 1, 0: 0}
&gt;&gt;&gt; SkipDict(data)
{0: 0.0, 2: 1.0, 1: 2.0, 4: 3.0, 3: 4.0}
</code></pre>

<p>If you use <code>keys()</code>, <code>values()</code> or <code>items()</code> then you'll iterate in sorted order by value.</p>

<p>It's implemented using the <a href="http://en.wikipedia.org/wiki/Skip_list">skip list</a> datastructure.</p>
<h4> Comment 106284747 user6304394: </h4>can we change the order of sort, right now, it is asending, but I want decsending.<br><h4> Comment 106286713 malthe: </h4>afaik you would have to negate your values in order to reverse the ordering<br>------------------------------------------------------------------ <br><h3> Answer 31741215 rassa45: </h3><p>Of course, remember, you need to use <code>OrderedDict</code> because regular Python dictionaries don't keep the original order. </p>

<pre><code>from collections import OrderedDict
a = OrderedDict(sorted(originalDict.items(), key=lambda x: x[1]))
</code></pre>

<hr>

<p>If you do not have Python 2.7 or higher, the best you can do is iterate over the values in a generator function. (There is an <code>OrderedDict</code> for 2.4 and 2.6  <a href="https://pypi.python.org/pypi/ordereddict" rel="noreferrer">here</a>, but </p>

<p>a) I don't know about how well it works </p>

<p>and </p>

<p>b) You have to download and install it of course. If you do not have administrative access, then I'm afraid the option's out.)</p>

<hr>

<pre><code>def gen(originalDict):
    for x, y in sorted(zip(originalDict.keys(), originalDict.values()), key=lambda z: z[1]):
        yield (x, y)
    #Yields as a tuple with (key, value). You can iterate with conditional clauses to get what you want. 

for bleh, meh in gen(myDict):
    if bleh == "foo":
        print(myDict[bleh])
</code></pre>

<hr>

<p>You can also print out every value</p>

<pre><code>for bleh, meh in gen(myDict):
    print(bleh, meh)
</code></pre>

<p>Please remember to remove the parentheses after print if not using Python 3.0 or above</p>
<h4> Comment 94560075 gerrit: </h4><i>regular Python dictionaries don&#39;t keep the original order</i> â€” as of Python 3.7, they do.<br>------------------------------------------------------------------ <br><h3> Answer 4068769 Argun: </h3><pre><code>from django.utils.datastructures import SortedDict

def sortedDictByKey(self,data):
    """Sorted dictionary order by key"""
    sortedDict = SortedDict()
    if data:
        if isinstance(data, dict):
            sortedKey = sorted(data.keys())
            for k in sortedKey:
                sortedDict[k] = data[k]
    return sortedDict
</code></pre>
<h4> Comment 8703854 Remi: </h4>question was: sort by value, not by keys... I like seeing a function. You can import collections and of course use sorted(data.values())<br>------------------------------------------------------------------ <br><h3> Answer 30949456 Scott: </h3><p>Here is a solution using zip on <a href="https://docs.python.org/2/library/stdtypes.html#dictionary-view-objects" rel="noreferrer"><code>d.values()</code> and <code>d.keys()</code></a>.  A few lines down this link (on Dictionary view objects) is:</p>

<blockquote>
  <p>This allows the creation of (value, key) pairs using zip(): pairs = zip(d.values(), d.keys()).</p>
</blockquote>

<p>So we can do the following:</p>

<pre><code>d = {'key1': 874.7, 'key2': 5, 'key3': 8.1}

d_sorted = sorted(zip(d.values(), d.keys()))

print d_sorted 
# prints: [(5, 'key2'), (8.1, 'key3'), (874.7, 'key1')]
</code></pre>
------------------------------------------------------------------ <br><h3> Answer 49073645 Bram Vanroy: </h3><p><a href="https://stackoverflow.com/a/39424969/1150683">As pointed out by Dilettant</a>, Python 3.6 will now <em>keep the order</em>! I thought I'd share a function I wrote that eases the sorting of an iterable (tuple, list, dict). In the latter case, you can sort either on keys or values, and it can take numeric comparison into account. <strong>Only for &gt;= 3.6!</strong></p>
<p>When you try using sorted on an iterable that holds e.g. strings as well as ints, sorted() will fail. Of course you can force string comparison with str(). However, in some cases you want to do <em>actual</em> numeric comparison where <code>12</code> is smaller than <code>20</code> (which is not the case in string comparison). So I came up with the following. When you want explicit numeric comparison you can use the flag <code>num_as_num</code> which will try to do explicit numeric sorting by trying to convert all values to floats. If that succeeds, it will do numeric sorting, otherwise it'll resort to string comparison.</p>
<p>Comments for improvement welcome.</p>
<pre><code>def sort_iterable(iterable, sort_on=None, reverse=False, num_as_num=False):
    def _sort(i):
      # sort by 0 = keys, 1 values, None for lists and tuples
      try:
        if num_as_num:
          if i is None:
            _sorted = sorted(iterable, key=lambda v: float(v), reverse=reverse)
          else:
            _sorted = dict(sorted(iterable.items(), key=lambda v: float(v[i]), reverse=reverse))
        else:
          raise TypeError
      except (TypeError, ValueError):
        if i is None:
          _sorted = sorted(iterable, key=lambda v: str(v), reverse=reverse)
        else:
          _sorted = dict(sorted(iterable.items(), key=lambda v: str(v[i]), reverse=reverse))
      
      return _sorted
      
    if isinstance(iterable, list):
      sorted_list = _sort(None)
      return sorted_list
    elif isinstance(iterable, tuple):
      sorted_list = tuple(_sort(None))
      return sorted_list
    elif isinstance(iterable, dict):
      if sort_on == 'keys':
        sorted_dict = _sort(0)
        return sorted_dict
      elif sort_on == 'values':
        sorted_dict = _sort(1)
        return sorted_dict
      elif sort_on is not None:
        raise ValueError(f&quot;Unexpected value {sort_on} for sort_on. When sorting a dict, use key or values&quot;)
    else:
      raise TypeError(f&quot;Unexpected type {type(iterable)} for iterable. Expected a list, tuple, or dict&quot;)
</code></pre>
------------------------------------------------------------------ <br><h3> Answer 50554874 mcgag: </h3><p>I just learned a relevant skill from <em><a href="https://www.coursera.org/learn/python-data/lecture/0ou0N/10-tuples" rel="nofollow noreferrer">Python for Everybody</a></em>.</p>
<p>You may use a temporary list to help you to sort the dictionary:</p>
<pre><code># Assume dictionary to be:
d = {'apple': 500.1, 'banana': 1500.2, 'orange': 1.0, 'pineapple': 789.0}

# Create a temporary list
tmp = []

# Iterate through the dictionary and append each tuple into the temporary list
for key, value in d.items():
    tmptuple = (value, key)
    tmp.append(tmptuple)

# Sort the list in ascending order
tmp = sorted(tmp)

print (tmp)
</code></pre>
<p>If you want to sort the list in descending order, simply change the original sorting line to:</p>
<pre><code>tmp = sorted(tmp, reverse=True)
</code></pre>
<p>Using list comprehension, the one-liner would be:</p>
<pre><code># Assuming the dictionary looks like
d = {'apple': 500.1, 'banana': 1500.2, 'orange': 1.0, 'pineapple': 789.0}
# One-liner for sorting in ascending order
print (sorted([(v, k) for k, v in d.items()]))
# One-liner for sorting in descending order
print (sorted([(v, k) for k, v in d.items()], reverse=True))
</code></pre>
<p>Sample Output:</p>
<pre><code># Ascending order
[(1.0, 'orange'), (500.1, 'apple'), (789.0, 'pineapple'), (1500.2, 'banana')]
# Descending order
[(1500.2, 'banana'), (789.0, 'pineapple'), (500.1, 'apple'), (1.0, 'orange')]
</code></pre>
<h4> Comment 108965274 Hermes Morales: </h4>If you want to print it in the initial format you should do:print ([(k,v) for v,k in sorted([(v,k) for k,v in d.items()])]) . The output is: [(&#39;orange&#39;, 1.0), (&#39;apple&#39;, 500.1), (&#39;pineapple&#39;, 789.0), (&#39;banana&#39;, 1500.2)]. With [(k,v) for v,k in sorted([(v,k) for k,v in d.items()], reverse = True)]  the output is: [(&#39;banana&#39;, 1500.2), (&#39;pineapple&#39;, 789.0), (&#39;apple&#39;, 500.1), (&#39;orange&#39;, 1.0)]<br>------------------------------------------------------------------ <br><h3> Answer 7817348 ponty: </h3><p>Use <strong>ValueSortedDict</strong> from <a href="http://pypi.python.org/pypi/dicts" rel="noreferrer">dicts</a>:</p>

<pre><code>from dicts.sorteddict import ValueSortedDict
d = {1: 2, 3: 4, 4:3, 2:1, 0:0}
sorted_dict = ValueSortedDict(d)
print sorted_dict.items() 

[(0, 0), (2, 1), (1, 2), (4, 3), (3, 4)]
</code></pre>
------------------------------------------------------------------ <br><h3> Answer 7947321 juhoh: </h3><p>Iterate through a dict and sort it by its values in descending order:</p>

<pre><code>$ python --version
Python 3.2.2

$ cat sort_dict_by_val_desc.py 
dictionary = dict(siis = 1, sana = 2, joka = 3, tuli = 4, aina = 5)
for word in sorted(dictionary, key=dictionary.get, reverse=True):
  print(word, dictionary[word])

$ python sort_dict_by_val_desc.py 
aina 5
tuli 4
joka 3
sana 2
siis 1
</code></pre>
------------------------------------------------------------------ <br><h3> Answer 8992838 Petr Viktorin: </h3><p>If your values are integers, and you use Python 2.7 or newer, you can use <a href="http://docs.python.org/py3k/library/collections.html#collections.Counter" rel="noreferrer"><code>collections.Counter</code></a> instead of <code>dict</code>. The <code>most_common</code> method will give you all items, sorted by the value.</p>
------------------------------------------------------------------ <br><h3> Answer 8148132 iFail: </h3><p>This works in 3.1.x:</p>

<pre><code>import operator
slovar_sorted=sorted(slovar.items(), key=operator.itemgetter(1), reverse=True)
print(slovar_sorted)
</code></pre>
------------------------------------------------------------------ <br><h3> Answer 15587800 Abhijit: </h3><p>For the sake of completeness, I am posting a solution using <a href="http://docs.python.org/2/library/heapq.html" rel="noreferrer">heapq</a>. Note, this method will work for both numeric and non-numeric values</p>

<pre><code>&gt;&gt;&gt; x = {1: 2, 3: 4, 4:3, 2:1, 0:0}
&gt;&gt;&gt; x_items = x.items()
&gt;&gt;&gt; heapq.heapify(x_items)
&gt;&gt;&gt; #To sort in reverse order
&gt;&gt;&gt; heapq.nlargest(len(x_items),x_items, operator.itemgetter(1))
[(3, 4), (4, 3), (1, 2), (2, 1), (0, 0)]
&gt;&gt;&gt; #To sort in ascending order
&gt;&gt;&gt; heapq.nsmallest(len(x_items),x_items, operator.itemgetter(1))
[(0, 0), (2, 1), (1, 2), (4, 3), (3, 4)]
</code></pre>
------------------------------------------------------------------ <br><h3> Answer 21767696 lessthanl0l: </h3><pre><code>months = {"January": 31, "February": 28, "March": 31, "April": 30, "May": 31,
          "June": 30, "July": 31, "August": 31, "September": 30, "October": 31,
          "November": 30, "December": 31}

def mykey(t):
    """ Customize your sorting logic using this function.  The parameter to
    this function is a tuple.  Comment/uncomment the return statements to test
    different logics.
    """
    return t[1]              # sort by number of days in the month
    #return t[1], t[0]       # sort by number of days, then by month name
    #return len(t[0])        # sort by length of month name
    #return t[0][-1]         # sort by last character of month name


# Since a dictionary can't be sorted by value, what you can do is to convert
# it into a list of tuples with tuple length 2.
# You can then do custom sorts by passing your own function to sorted().
months_as_list = sorted(months.items(), key=mykey, reverse=False)

for month in months_as_list:
    print month
</code></pre>
------------------------------------------------------------------ <br><h3> Answer 54878340 Wira Bhakti: </h3><p>Besides using built-in modules, etc., I try solve it manually...</p>
<p><strong>First</strong>, I made a function whose job is to returning minimal value each items of the dict:</p>
<pre><code>def returnminDict(_dct):
    dict_items = _dct.items()
    list_items = list(dict_items)
    init_items = list_items[0]
    for i in range(len(list_items)):
        if list_items[i][1] &gt; init_items[1]:
           continue
        else:
           init_items = list_items[i]
    return init_items
</code></pre>
<p><strong>Second</strong>, now we have a function which returns an item that has the minimal value. Then I make a new dict and loop over the dict:</p>
<pre><code>def SelectDictSort(_dct):
    new_dict = {}
    while _dct:
        mindict = returnminDict(_dct)
        new_dict.update(dict((mindict,)))
        _dct.pop(mindict[0])
    return new_dict
</code></pre>
<p>I try with <code>SelectDictSort({2: 5, 5: 1, 4: 3, 1: 1, 0: 1, 9: 2, 8: 2})</code>. It will return:</p>
<pre><code>{0: 1, 1: 1, 5: 1, 8: 2, 9: 2, 4: 3, 2: 5}
</code></pre>
<p>Hmmm... I donâ€™t know which is correct, but this what I have tried...</p>
------------------------------------------------------------------ <br><h3> Answer 13208582 raton: </h3><p>Using Python 3.2:</p>

<pre><code>x = {"b":4, "a":3, "c":1}
for i in sorted(x.values()):
    print(list(x.keys())[list(x.values()).index(i)])
</code></pre>
------------------------------------------------------------------ <br><h3> Answer 44148366 xiyurui: </h3><p>This method will not use lambda and works well on Python 3.6:</p>

<pre><code> # sort dictionary by value
d = {'a1': 'fsdfds', 'g5': 'aa3432ff', 'ca':'zz23432'}
def getkeybyvalue(d,i):
    for k, v in d.items():
        if v == i:
            return (k)

sortvaluelist = sorted(d.values())

# In &gt;&gt; Python 3.6+ &lt;&lt; the INSERTION-ORDER of a dict is preserved. That is,
# when creating a NEW dictionary and filling it 'in sorted order',
# that order will be maintained.
sortresult ={}
for i1 in sortvaluelist:   
    key = getkeybyvalue(d,i1)
    sortresult[key] = i1
print ('=====sort by value=====')
print (sortresult)
print ('=======================')
</code></pre>
<h4> Comment 75314223 HDJEMAI: </h4><b>From review queue:</b> May I request you to please add some context around your source-code. Code-only answers are difficult to understand. It will help the asker and future readers both if you can add more information in your post.<br><h4> Comment 99009432 Jean-Fran&#231;ois Fabre: </h4>this is a very inefficient solution, with linear search and all<br>