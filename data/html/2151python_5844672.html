 <h2> Title: Delete an element from a dictionary </h2> <h3> richzilla, question_id: 5844672 </h3>Score: 2151, Tags: {python,dictionary,del} <br><p>How do I delete an item from a dictionary in Python?</p>
<p>Without modifying the original dictionary, how do I obtain another dict with the item removed?</p>
<hr />
<p><sub>See also <a href="https://stackoverflow.com/questions/11277432">How can I remove a key from a Python dictionary?</a> for the specific issue of removing an item (by key) that may not already be present.</sub></p>
<h4> Comment 6714414 amillerrhodes: </h4>Why do you need a function that returns a dictionary, when you can just modify the dictionary directly?<br><h4> Comment 94970229 Gene Callahan: </h4>&quot;Why do you need a function that returns a dictionary, when you can just modify the dictionary directly?&quot; Perhaps because you want to write pure functions that <i>don&#39;t</i> modify their parameters?<br><h4> Comment 63739556 Mark Mikofski: </h4>The <a href="https://docs.python.org/2/library/stdtypes.html#dict.pop" rel="nofollow noreferrer">dictionary <code>pop</code> method</a> changes the dictionary <i>in-place</i>. Therefore it alters the <i>reference</i> to the dictionary that was passed from the caller to the &quot;helper function&quot;. So the &quot;helper function&quot; doesn&#39;t need to return anything, since the original reference to the dictionary in the caller will already be altered. Don&#39;t assign the return from <code>dict.pop()</code> to anything if you don&#39;t need it. EG: <code>do stuff with my_dict; my_dict.pop(my_key, None); do more stuff with my_dict # now doesn&#39;t have my_key</code>. Use <code>deepcopy(my_dict)</code> if needed.<br><h4> Comment 87696492 smci: </h4>Since the original title disagreed with the details and specifically excluded the obvious solution <code>d.pop()</code>, I fixed the title to ask the question specified in the details.<br><h4> Comment 87698160 smci: </h4>We should add a caveat asking if you <b>really</b> want to do this, as if you do it N times on a dictionary with E elements you&#39;ll leak(/use) O(N*E) memory with all the deep copies. If you merely want a read-only (shallow copy), do <code>d.pop(key)</code>. But if anything ever modifies the shallow copy, you have a <a href="https://stackoverflow.com/questions/2465921/how-to-copy-a-dictionary-and-only-edit-the-copy">well-known problem with aliasing</a>. It helps if you tell us the wider context. (Is anything else ever modifying the dict values? Are you trying to destructively iterate over a list? if not, what?)<br>------------------------------------------------------------------ <br><h3> Answer 5844697 tMC: </h3><pre><code>&gt;&gt;&gt; def delete_key(dict, key):
...     del dict[key]
...     return dict
... 
&gt;&gt;&gt; test_dict = {'one': 1, 'two' : 2}
&gt;&gt;&gt; print delete_key(test_dict, 'two')
{'one': 1}
&gt;&gt;&gt;
</code></pre>

<p>this doesn't do any error handling, it assumes the key is in the dict, you might want to check that first and <code>raise</code> if its not</p>
<h4> Comment 56294330 Mad Physicist: </h4>How is your method any different than just <code>del test_dict[key]</code>?<br>------------------------------------------------------------------ <br><h3> Answer 5844692 Greg Hewgill: </h3><p>The <a href="http://docs.python.org/reference/simple_stmts.html#the-del-statement" rel="noreferrer"><code>del</code> statement</a> removes an element:</p>
<pre><code>del d[key]
</code></pre>
<p>Note that this mutates the existing dictionary, so the contents of the dictionary changes for anybody else who has a reference to the same instance. To return a <em>new</em> dictionary, make a copy of the dictionary:</p>
<pre><code>def removekey(d, key):
    r = dict(d)
    del r[key]
    return r
</code></pre>
<p>The <code>dict()</code> constructor makes a <em>shallow copy</em>. To make a deep copy, see the <a href="https://docs.python.org/library/copy.html" rel="noreferrer"><code>copy</code> module</a>.</p>
<hr />
<p>Note that making a copy for every dict <code>del</code>/assignment/etc. means you're going from constant time to linear time, and also using linear space. For small dicts, this is not a problem. But if you're planning to make lots of copies of large dicts, you probably want a different data structure, like a HAMT (as described in <a href="https://stackoverflow.com/a/50341031/908494">this answer</a>).</p>
<h4> Comment 27210339 VertigoRay: </h4>@tMC If you edit the <code>dict</code> as you&#39;re looping through it, it&#39;ll give you an error: <code>RuntimeError: dictionary changed size during iteration</code><br><h4> Comment 38696941 Zen: </h4>This answer has a weakness, it could be misleading. Readers may misunderstand that dict(d) can give them a copy with &#39;d&#39;. But it&#39;s an incomplete copy. When only doing del keys operations, that&#39;s OK. But when you want to do something else to a nested dict, modifying &#39;r&#39; using that copy method may cause change to the original &#39;d&#39;. To get an authentic copy, you need first &#39; import copy &#39;, and then &#39;r = copy.deepcopy(d) &#39;.<br><h4> Comment 33032426 Serge: </h4>What about <code>pop</code> method which in fact does the same? Isn&#39;t it more pythonic? (being dict&#39;s method, not special reserved word)?<br><h4> Comment 6712870 tMC: </h4>thats a great point about the mutability of dictionaries +1 - though i can&#39;t think of a time when i wanted copies of the dictionary, i&#39;ve always relied on &#39;everyones&#39; copy being the same. great point.<br><h4> Comment 38728354 Zen: </h4>@GregHewgill, I know that, so it&#39;s not a serious weakness. But since you mentioned &quot;To return a new dictionary, make a copy of the dictionary:&quot;. With your 358K points and 143095 view times, this could be misleading to considerable beginners of python. By the way,  I myself was mislead by this post before.<br><h4> Comment 76429767 holzkohlengrill: </h4>To overcome <code>RuntimeError dictionary changed size during iteration</code> see: <a href="https://stackoverflow.com/a/11941855/4773274">stackoverflow.com/a/11941855/4773274</a><br><h4> Comment 76562146 dmjalund: </h4>to go through items in a dictionary to delete, I first create a list of the keys of the records i need to delete, then I iterate through this list and do del mydict[iterKey]<br><h4> Comment 113447075 BUFU: </h4>@DavidC. when you <code>d_copy = d</code>, you reference <i>the same dictionary</i> with a second name (so the <code>id()</code> of both is the same). when you <code>d_copy = dict(d)</code> you make a (shallow) copy and therefore <i>another</i> dict with the <i>same content</i>. so when you del in the first version, both d and d_copy are altered, in the second, they are not - unless you have a nested dict or something (like a list inside the dict), because the nested dict/list is the same for both again (because the content is another reference to the same dict/list)... and that&#39;s where <code>copy.deepcopy()</code> comes in.<br><h4> Comment 109220246 DavidC.: </h4>@Greg Hewgill Thank you for your answer. I was wondering if a simpler solution is to copy the <code>d</code> dictionary to <code>d_copy</code>: <code>d = d_copy</code> and then work over <code>d_copy</code>. What is the difference between this approach with respect to making a <code>shallow copy</code> (<code>dict()</code> constructor) or even making a <code>deep copy</code> ?<br><h4> Comment 87698348 abarnert: </h4>I&#39;ve added an explanation of the costs of copying a dict every time you want to change it, with a link to my answer that shows how to avoid them. (This is definitely not what you want to do all the time, but I think it is what some people looking for this question will, or should, want to do.) Feel free to revert if that seems inappropriate.<br><h4> Comment 126285228 brookbot: </h4>The answer fails to mention that a KeyError exception may be raised and needs to be handled if the key is missing. Up voted nikita answer below<br><h4> Comment 132514372 Azhar Uddin Sheikh: </h4>@GregHewgill need <b>INFO</b> let&#39;s say I am adding an <code>item</code> to a <code>dict|HashMap|table</code> in each <code>iteration</code> inside a <code>fn</code> which is <b>O(n)</b>  <code>space complexity</code> later on that <code>fn</code> I have another <code>iteration</code> which <code>removed</code> all <code>item</code> from the same <code>dict</code> will this be considered <code>space constant</code> ie <b>O(1)</b> ?<br><h4> Comment 38718468 Greg Hewgill: </h4>@Zen: You&#39;re right, but that&#39;s an answer to a different question. This question was only asking about removing elements from a dictionary.<br>------------------------------------------------------------------ <br><h3> Answer 22564121 Crystal: </h3><p><a href="https://docs.python.org/library/stdtypes.html#dict.pop" rel="noreferrer"><code>pop</code></a> mutates the dictionary.</p>

<pre><code> &gt;&gt;&gt; lol = {"hello": "gdbye"}
 &gt;&gt;&gt; lol.pop("hello")
     'gdbye'
 &gt;&gt;&gt; lol
     {}
</code></pre>

<p>If you want to keep the original you could just copy it.</p>
<h4> Comment 83772839 kevr: </h4>@ivanleoncz why?<br><h4> Comment 74671353 ivanleoncz: </h4>&quot;del&quot; is ok, but &quot;pop&quot; seems more &quot;Pythonic&quot;, in my opinion.<br><h4> Comment 107262874 itachi: </h4>@ivanleoncz It&#39;s also better for one more reason, <code>pop</code> can be provided with a default value that will be returned when a key is missing from dict. It&#39;s good when you need to remove a few keys but some of them might be missing; <code>del</code> would throw <code>KeyError</code> in such case.<br><h4> Comment 83773040 ivanleoncz: </h4><code>pop</code> returns the value that was &#39;popped&#39;, which allows you to use this value for whatever further reason. If it&#39;s not more &quot;Pythonic&quot;, I&#39;d say that seems better, for sure :). It&#39;s not a dict, but it works the same way for both: <a href="https://github.com/ivanlmj/python-prototypes/blob/master/3.4/pop_list.py" rel="nofollow noreferrer">github.com/ivanlmj/python-prototypes/blob/master/3.4/&hellip;</a><br>------------------------------------------------------------------ <br><h3> Answer 5844700 utdemir: </h3><p>I think your solution is best way to do it. But if you want another solution, you can create a new dictionary with using the keys from old dictionary without including your specified key, like this:</p>

<pre><code>&gt;&gt;&gt; a
{0: 'zero', 1: 'one', 2: 'two', 3: 'three'}
&gt;&gt;&gt; {i:a[i] for i in a if i!=0}
{1: 'one', 2: 'two', 3: 'three'}
</code></pre>
<h4> Comment 45007850 kmatheny: </h4>For those not familiar with comprehensions, you can also do something like this: <code>{i:a[i] for i in a if i not in [0, 1, 2]}</code> if you want to remove several elements.<br><h4> Comment 71591593 rlbond: </h4>Better would be <code>{k:v for k,v in a.items() if k != 0}</code> I think.<br><h4> Comment 25770827 Joe J: </h4>Really cool.  I like the quick method to filter a dictionary without defining a new function.<br><h4> Comment 81716717 Cole: </h4>The best solution for removing an item by key and returning the result of the new dict in the same line. For example if you need to use an an already constructed dict without a single item as <code>**kwargs</code>, <code>some_function(**{k:v for k,v in some_dict.items() if k not &#39;some_key&#39;})</code><br><h4> Comment 87604056 Andrew Winterbotham: </h4>Best solution here. One liner and it doesn&#39;t mutate the original dictionary.<br>------------------------------------------------------------------ <br><h3> Answer 46352190 Nikita: </h3><p>There're a lot of nice answers, but I want to emphasize one thing.</p>

<p>You can use both <a href="https://docs.python.org/3/library/stdtypes.html#dict.pop" rel="noreferrer"><code>dict.pop()</code></a> method and a more generic <a href="https://docs.python.org/3/tutorial/datastructures.html#the-del-statement" rel="noreferrer"><code>del</code> statement</a> to remove items from a dictionary. They both mutate the original dictionary, so you need to make a copy (see details below).</p>

<p><strong>And both of them will raise a <a href="https://docs.python.org/3/library/exceptions.html#KeyError" rel="noreferrer"><code>KeyError</code></a> if the key you're providing to them is not present in the dictionary:</strong></p>

<pre><code>key_to_remove = "c"
d = {"a": 1, "b": 2}
del d[key_to_remove]  # Raises `KeyError: 'c'`
</code></pre>

<p>and</p>

<pre><code>key_to_remove = "c"
d = {"a": 1, "b": 2}
d.pop(key_to_remove)  # Raises `KeyError: 'c'`
</code></pre>

<p>You have to take care of this:</p>

<p><strong>by capturing the exception:</strong></p>

<pre><code>key_to_remove = "c"
d = {"a": 1, "b": 2}
try:
    del d[key_to_remove]
except KeyError as ex:
    print("No such key: '%s'" % ex.message)
</code></pre>

<p>and</p>

<pre><code>key_to_remove = "c"
d = {"a": 1, "b": 2}
try:
    d.pop(key_to_remove)
except KeyError as ex:
    print("No such key: '%s'" % ex.message)
</code></pre>

<p><strong>by performing a check:</strong></p>

<pre><code>key_to_remove = "c"
d = {"a": 1, "b": 2}
if key_to_remove in d:
    del d[key_to_remove]
</code></pre>

<p>and</p>

<pre><code>key_to_remove = "c"
d = {"a": 1, "b": 2}
if key_to_remove in d:
    d.pop(key_to_remove)
</code></pre>

<p><strong>but with <code>pop()</code> there's also a much more concise way - provide the default return value:</strong></p>

<pre><code>key_to_remove = "c"
d = {"a": 1, "b": 2}
d.pop(key_to_remove, None)  # No `KeyError` here
</code></pre>

<p>Unless you use <code>pop()</code> to get the value of a key being removed you may provide anything, not necessary <code>None</code>.
Though it might be that using <code>del</code> with <code>in</code> check is <strong>slightly</strong> faster due to <code>pop()</code> being a function with its own complications causing overhead. Usually it's not the case, so <code>pop()</code> with default value is good enough.</p>

<hr>

<p>As for the main question, you'll have to make a copy of your dictionary, to save the original dictionary and have a new one without the key being removed.</p>

<p>Some other people here suggest making a full (deep) copy with <a href="https://docs.python.org/3/library/copy.html?#copy.deepcopy" rel="noreferrer"><code>copy.deepcopy()</code></a>, which might be an overkill, a "normal" (shallow) copy, using <a href="https://docs.python.org/3/library/copy.html?#copy.copy" rel="noreferrer"><code>copy.copy()</code></a> or <a href="https://docs.python.org/3/library/stdtypes.html#dict.copy" rel="noreferrer"><code>dict.copy()</code></a>, might be enough. The dictionary keeps a reference to the object as a value for a key. So when you remove a key from a dictionary this reference is removed, not the object being referenced. The object itself may be removed later automatically by the garbage collector, if there're no other references for it in the memory. Making a deep copy requires more calculations compared to shallow copy, so it decreases code performance by making the copy, wasting memory and providing more work to the GC, sometimes shallow copy is enough.</p>

<p>However, if you have mutable objects as dictionary values and plan to modify them later in the returned dictionary without the key, you have to make a deep copy.</p>

<p><strong>With shallow copy:</strong></p>

<pre><code>def get_dict_wo_key(dictionary, key):
    """Returns a **shallow** copy of the dictionary without a key."""
    _dict = dictionary.copy()
    _dict.pop(key, None)
    return _dict


d = {"a": [1, 2, 3], "b": 2, "c": 3}
key_to_remove = "c"

new_d = get_dict_wo_key(d, key_to_remove)
print(d)  # {"a": [1, 2, 3], "b": 2, "c": 3}
print(new_d)  # {"a": [1, 2, 3], "b": 2}
new_d["a"].append(100)
print(d)  # {"a": [1, 2, 3, 100], "b": 2, "c": 3}
print(new_d)  # {"a": [1, 2, 3, 100], "b": 2}
new_d["b"] = 2222
print(d)  # {"a": [1, 2, 3, 100], "b": 2, "c": 3}
print(new_d)  # {"a": [1, 2, 3, 100], "b": 2222}
</code></pre>

<p><strong>With deep copy:</strong></p>

<pre><code>from copy import deepcopy


def get_dict_wo_key(dictionary, key):
    """Returns a **deep** copy of the dictionary without a key."""
    _dict = deepcopy(dictionary)
    _dict.pop(key, None)
    return _dict


d = {"a": [1, 2, 3], "b": 2, "c": 3}
key_to_remove = "c"

new_d = get_dict_wo_key(d, key_to_remove)
print(d)  # {"a": [1, 2, 3], "b": 2, "c": 3}
print(new_d)  # {"a": [1, 2, 3], "b": 2}
new_d["a"].append(100)
print(d)  # {"a": [1, 2, 3], "b": 2, "c": 3}
print(new_d)  # {"a": [1, 2, 3, 100], "b": 2}
new_d["b"] = 2222
print(d)  # {"a": [1, 2, 3], "b": 2, "c": 3}
print(new_d)  # {"a": [1, 2, 3, 100], "b": 2222}
</code></pre>
------------------------------------------------------------------ <br><h3> Answer 5844680 arussell84: </h3><p>The <a href="http://docs.python.org/tutorial/datastructures.html#the-del-statement" rel="noreferrer">del statement</a> is what you're looking for. If you have a dictionary named foo with a key called 'bar', you can delete 'bar' from foo like this:</p>

<pre><code>del foo['bar']
</code></pre>

<p>Note that this permanently modifies the dictionary being operated on. If you want to keep the original dictionary, you'll have to create a copy beforehand:</p>

<pre><code>&gt;&gt;&gt; foo = {'bar': 'baz'}
&gt;&gt;&gt; fu = dict(foo)
&gt;&gt;&gt; del foo['bar']
&gt;&gt;&gt; print foo
{}
&gt;&gt;&gt; print fu
{'bar': 'baz'}
</code></pre>

<p>The <a href="https://docs.python.org/3/library/stdtypes.html#dict" rel="noreferrer"><code>dict</code></a> call makes a shallow copy. If you want a deep copy, use <a href="https://docs.python.org/3/library/copy.html#copy.deepcopy" rel="noreferrer"><code>copy.deepcopy</code></a>.</p>

<p>Here's a method you can copy &amp; paste, for your convenience:</p>

<pre><code>def minus_key(key, dictionary):
    shallow_copy = dict(dictionary)
    del shallow_copy[key]
    return shallow_copy
</code></pre>
<h4> Comment 75538040 arussell84: </h4>I&#39;ve added a function that can be copy/pasted, for your convenience.<br><h4> Comment 75488394 maxkoryukov: </h4>@pythonian29033 about <code>&gt;&gt;&gt;</code>. Yes, it is REPL-style, but let&#39;s talk frankly: the only one man had wrote this sample, and 1000 have read this. I think, it would be great to write examples in the way allowing easy copy and run. I don&#39;t like to remove this angle brackets by hand. Or copy line by line.. So I don&#39;t understand: why this angles are still there))) May be I don&#39;t know something?<br><h4> Comment 75473071 maxkoryukov: </h4>@pythonian29033 , actually, <b>no</b>. The accepted answer works as expected — it returns the dict without one key. The approach from this answer mutates original dict;) There is a significat difference<br><h4> Comment 75473106 maxkoryukov: </h4>@arussell84, why <code>&gt;&gt;&gt;</code> is often used in the python-examples? Yeah, python-doc contains a lot of such things. But such code is <b>not convenient for copypaste</b>. I am confused...<br><h4> Comment 75487096 pythonian29033: </h4>@maxkoryukov yup it does! but that function and this answer is exactly the same, with the exception of that answer being inside of a function.  and you must not have been coding in python for a while, the <code>&gt;&gt;&gt;</code> mimics the listening notation from python in cli mode<br><h4> Comment 75487955 maxkoryukov: </h4>@pythonian29033, agreed;) sorry, my mistake, the code from this answer actually do the same job as the accepted one. You are right about this;)<br><h4> Comment 75489744 pythonian29033: </h4>well I guess guys are posting their answers with the intention of solving the problems and helping understand the solution as apposed to something that can just be copied and pasted<br><h4> Comment 75537364 arussell84: </h4>Yes, I used the REPL-style syntax to illustrate what is actual code vs. what the output is. I wanted to show the output to better illustrate that the original and the (shallow) copy are different after the <code>dict</code> statement.<br>------------------------------------------------------------------ <br><h3> Answer 50341031 abarnert: </h3><blockquote>
  <p>… how can I delete an item from a dictionary to return a copy (i.e., not modifying the original)?</p>
</blockquote>

<p>A <code>dict</code> is the wrong data structure to use for this.</p>

<p>Sure, copying the dict and popping from the copy works, and so does building a new dict with a comprehension, but all that copying takes time—you've replaced a constant-time operation with a linear-time one. And all those copies alive at once take space—linear space per copy.</p>

<p>Other data structures, like <a href="https://en.wikipedia.org/wiki/Hash_array_mapped_trie" rel="noreferrer">hash array mapped tries</a>, are designed for exactly this kind of use case: adding or removing an element returns a copy <em>in logarithmic time, sharing most of its storage with the original</em>.<sup>1</sup></p>

<p>Of course there are some downsides. Performance is logarithmic rather than constant (although with a large base, usually 32-128). And, while you can make the non-mutating API identical to <code>dict</code>, the "mutating" API is obviously different. And, most of all, there's no HAMT batteries included with Python.<sup>2</sup></p>

<p>The <a href="https://pypi.org/project/pyrsistent/" rel="noreferrer"><code>pyrsistent</code></a> library is a pretty solid implementation of HAMT-based dict-replacements (and various other types) for Python. It even has a nifty <a href="http://pyrsistent.readthedocs.io/en/latest/intro.html#evolvers" rel="noreferrer">evolver API</a> for porting existing mutating code to persistent code as smoothly as possible. But if you want to be explicit about returning copies rather than mutating, you just use it like this:</p>

<pre><code>&gt;&gt;&gt; from pyrsistent import m
&gt;&gt;&gt; d1 = m(a=1, b=2)
&gt;&gt;&gt; d2 = d1.set('c', 3)
&gt;&gt;&gt; d3 = d1.remove('a')
&gt;&gt;&gt; d1
pmap({'a': 1, 'b': 2})
&gt;&gt;&gt; d2
pmap({'c': 3, 'a': 1, 'b': 2})
&gt;&gt;&gt; d3
pmap({'b': 2})
</code></pre>

<p>That <code>d3 = d1.remove('a')</code> is exactly what the question is asking for.</p>

<p>If you've got mutable data structures like <code>dict</code> and <code>list</code> embedded in the <code>pmap</code>, you'll still have aliasing issues—you can only fix that by going immutable all the way down, embedding <code>pmap</code>s and <code>pvector</code>s.</p>

<hr>

<p><sub>1. HAMTs have also become popular in languages like Scala, Clojure, Haskell because they play very nicely with lock-free programming and software transactional memory, but neither of those is very relevant in Python.</sub></p>

<p><sub>2. In fact, there <em>is</em> an HAMT in the stdlib, used in the implementation of <a href="https://docs.python.org/3.7/library/contextvars.html" rel="noreferrer"><code>contextvars</code></a>. <a href="https://www.python.org/dev/peps/pep-0550/#appendix-hamt-performance-analysis" rel="noreferrer">The earlier withdrawn PEP explains why.</a> But this is a hidden implementation detail of the library, not a public collection type.</sub></p>
<h4> Comment 131868503 kdauria: </h4>The <a href="https://github.com/MagicStack/immutables" rel="nofollow noreferrer"><code>immutables</code></a> package is now available.<br>------------------------------------------------------------------ <br><h3> Answer 70512721 Franz Gastring: </h3><p>Using del you can remove a dict value passing the key of that value</p>
<p>Link:
<a href="https://docs.python.org/3/tutorial/datastructures.html#the-del-statement" rel="noreferrer">del method</a></p>
<pre><code>del dictionary['key_to_del']
</code></pre>
<h4> Comment 132976644 Damien: </h4>This is the most readable and efficient, IMHO<br><h4> Comment 136162297 RSW: </h4>I was surprise to know it even works for <code>del rule[&#39;key_to_del&#39;][&#39;nestedMapProp&#39;]</code>.<br>------------------------------------------------------------------ <br><h3> Answer 5844685 satels: </h3><pre><code>d = {1: 2, '2': 3, 5: 7}
del d[5]
print 'd = ', d
</code></pre>

<p>Result: <code>d = {1: 2, '2': 3}</code></p>
------------------------------------------------------------------ <br><h3> Answer 28811205 Khanh Hua: </h3><p>Simply call del d['key'].</p>

<p>However, in production, it is always a good practice to check if 'key' exists in d.</p>

<pre><code>if 'key' in d:
    del d['key']
</code></pre>
<h4> Comment 75472926 maxkoryukov: </h4>Hmm, no, in production it is better to follow <a href="https://docs.python.org/2/glossary.html#term-eafp" rel="nofollow noreferrer">EAFP</a> ideology. Just remove key in <code>try-except</code> block. At least, this will be an atomic operation;)<br><h4> Comment 75473014 maxkoryukov: </h4>And if you want to be concise — use <code>d.pop(&#39;key&#39;, None)</code> , it is oneliner. But the actual question was about getting the dictionary without one key, and not about modifying the dict. So <a href="https://stackoverflow.com/a/5844700/1115187">comprehensions</a> - is a good choice here;)<br>------------------------------------------------------------------ <br><h3> Answer 5844707 phihag: </h3><p>No, there is no other way than</p>

<pre><code>def dictMinus(dct, val):
   copy = dct.copy()
   del copy[val]
   return copy
</code></pre>

<p>However, often creating copies of only slightly altered dictionaries is probably not a good idea because it will result in comparatively large memory demands. It is usually better to log the old dictionary(if even necessary) and then modify it.</p>
------------------------------------------------------------------ <br><h3> Answer 45526235 daino3: </h3><pre><code># mutate/remove with a default
ret_val = body.pop('key', 5)
# no mutation with a default
ret_val = body.get('key', 5)
</code></pre>
------------------------------------------------------------------ <br><h3> Answer 34995888 incalite: </h3><p>Here a top level design approach:</p>

<pre><code>def eraseElement(d,k):
    if isinstance(d, dict):
        if k in d:
            d.pop(k)
            print(d)
        else:
            print("Cannot find matching key")
    else:
        print("Not able to delete")


exp = {'A':34, 'B':55, 'C':87}
eraseElement(exp, 'C')
</code></pre>

<p>I'm passing the dictionary and the key I want into my function, validates if it's a dictionary and if the key is okay, and if both exist, removes the value from the dictionary and prints out the left-overs.</p>

<p>Output: <code>{'B': 55, 'A': 34}</code></p>

<p>Hope that helps!</p>
------------------------------------------------------------------ <br><h3> Answer 46352998 Mayur Agarwal: </h3><p>Below code snippet will help you definitely, I have added comments in each line which will help you in understanding the code.</p>

<pre><code>def execute():
   dic = {'a':1,'b':2}
   dic2 = remove_key_from_dict(dic, 'b')  
   print(dict2)           # {'a': 1}
   print(dict)            # {'a':1,'b':2}

def remove_key_from_dict(dictionary_to_use, key_to_delete):
   copy_of_dict = dict(dictionary_to_use)     # creating clone/copy of the dictionary
   if key_to_delete in copy_of_dict :         # checking given key is present in the dictionary
       del copy_of_dict [key_to_delete]       # deleting the key from the dictionary 
   return copy_of_dict                        # returning the final dictionary
</code></pre>

<p>or you can also use dict.pop()</p>

<pre><code>d = {"a": 1, "b": 2}

res = d.pop("c")  # No `KeyError` here
print (res)       # this line will not execute
</code></pre>

<p>or the better approach is</p>

<pre><code>res = d.pop("c", "key not found")
print (res)   # key not found
print (d)     # {"a": 1, "b": 2}

res = d.pop("b", "key not found")
print (res)   # 2
print (d)     # {"a": 1}
</code></pre>
------------------------------------------------------------------ <br><h3> Answer 71277179 Mohammad Reza: </h3><h3>Solution 1: with deleting</h3>
<pre><code>info = {'country': 'Iran'}
country = info.pop('country') if 'country' in info else None
</code></pre>
<h3>Solution 2: without deleting</h3>
<pre><code>info = {'country': 'Iran'}
country = info.get('country') or None
</code></pre>
------------------------------------------------------------------ <br><h3> Answer 18523364 BigBlueHat: </h3><p>Here's another variation using list comprehension:</p>
<pre><code>original_d = {'a': None, 'b': 'Some'}
d = dict((k,v) for k, v in original_d.iteritems() if v)
# result should be {'b': 'Some'}
</code></pre>
<p>The approach is based on an answer from this post:
<a href="https://stackoverflow.com/questions/12118695/efficient-way-to-remove-keys-with-empty-values-from-a-dict">Efficient way to remove keys with empty strings from a dict</a></p>
<p>For Python 3 this is</p>
<pre><code>original_d = {'a': None, 'b': 'Some'}
d = dict((k,v) for k, v in original_d.items() if v)
print(d)
</code></pre>
<h4> Comment 36192346 holgac: </h4>This answer, although not complete, lets us learn that we can remove items with if conditions too. just changing <code>if v</code> to <code>if k is not &#39;a&#39;</code> answers the op. But i don&#39;t think that&#39;s an efficient way, this removes the element in O(n) rather than O(log n) as pop or del does.<br><h4> Comment 27240406 user2357112: </h4>If you&#39;re going to answer a years-old question that already has a simple, appropriate, accepted answer, at least make sure your answer is right. This doesn&#39;t do what the OP asked for.<br><h4> Comment 112808232 Phil: </h4>@holgac copying the dictionary runs in O(n), so your argument about efficiency is not correct given OP required the original dict remain unmodified, which requires the dict be copied.<br><h4> Comment 126110190 KansaiRobot: </h4>AttributeError: &#39;dict&#39; object has no attribute &#39;iteritems&#39;<br><h4> Comment 27240886 BigBlueHat: </h4>I don&#39;t generally check dates on questions I think could have valuable info added to them. Additionally, per one of the comments on the question I linked to: &quot;Usually this is exactly what someone wants and is probably what the OP needs, but it is not what the OP asked for&quot; <a href="http://stackoverflow.com/questions/12118695/efficient-way-to-remove-keys-with-empty-values-from-a-dict#comment16203889_12118700" title="efficient way to remove keys with empty values from a dict%23comment16203889_12118700">stackoverflow.com/questions/12118695/&hellip;</a> I knew it wasn&#39;t a direct answer to the question; rather an expansion to the options.<br>------------------------------------------------------------------ <br><h3> Answer 57399377 Sameeresque: </h3><pre><code>    species = {'HI': {'1': (1215.671, 0.41600000000000004),
  '10': (919.351, 0.0012),
  '1025': (1025.722, 0.0791),
  '11': (918.129, 0.0009199999999999999),
  '12': (917.181, 0.000723),
  '1215': (1215.671, 0.41600000000000004),
  '13': (916.429, 0.0005769999999999999),
  '14': (915.824, 0.000468),
  '15': (915.329, 0.00038500000000000003),
 'CII': {'1036': (1036.3367, 0.11900000000000001), '1334': (1334.532, 0.129)}}
</code></pre>

<p>The following code will make a copy of dict <code>species</code> and delete items which are not in <code>trans_HI</code></p>

<pre><code>trans_HI=['1025','1215']
for transition in species['HI'].copy().keys():
    if transition not in trans_HI:
        species['HI'].pop(transition)
</code></pre>
------------------------------------------------------------------ <br><h3> Answer 68499409 Vincent55: </h3><p>can try my method. In one line.</p>
<pre class="lang-py prettyprint-override"><code>yourList = [{'key':'key1','version':'1'},{'key':'key2','version':'2'},{'key':'key3','version':'3'}]
resultList = [{'key':dic['key']} for dic in yourList if 'key' in dic]
print(resultList)
</code></pre>
------------------------------------------------------------------ <br><h3> Answer 75219782 DOT: </h3><p>In Python 3, 'dict' object has no attribute 'remove'.</p>
<p>But with <a href="https://github.com/MagicStack/immutables" rel="nofollow noreferrer">immutables</a> package, can perform mutations that allow to apply changes to the Map object and create new (derived) Maps:</p>
<pre><code>import immutables
map = immutables.Map(a=1, b=2)
map1 = map.delete('b')
print(map, map1)
# will print:
#   &lt;immutables.Map({'b': 2, 'a': 1})&gt;
#   &lt;immutables.Map({'a': 1})&gt;
</code></pre>
<h4> Comment 133947677 Guillaume F.: </h4>Python 3 dictionaries have the .pop() method though.<br>