 <h2> Title: How do I get the number of elements in a list (length of a list) in Python? </h2> <h4> y2k, question_id: 1712227 </h4>Score: 2262, Tags: {python,list} <br><p>How do I get the number of elements in the list <code>items</code>?</p>
<pre><code>items = [&quot;apple&quot;, &quot;orange&quot;, &quot;banana&quot;]

# There are 3 items.
</code></pre>
<h4> Russia Must Remove Putin, Id: 67942875 Score: 34: </h4>You are obviously asking for the number of elements in the list. If a searcher comes here looking for the size of the object in memory, this is the actual question &amp; answers they are looking for: <a href="http://stackoverflow.com/q/449560/541136">How do I determine the size of an object in Python?</a><br><h4> Karl Knechtel, Id: 130791018 Score: 2: </h4>@RussiaMustRemovePutin The title of this question was subsequently edited, so it seems unlikely that people with that question would end up here as it stands.<br>------------------------------------------------------------------ <br><h3> Crystalline Core, Id: 62708034, Score: 5: </h3><p>There is an inbuilt function called len() in python which will help in these conditions.</p>
<pre><code>&gt;&gt;&gt; a = [1,2,3,4,5,6]
&gt;&gt;&gt; len(a)  # Here the len() function counts the number of items in the list.
6
</code></pre>
<p>This will work slightly different in the case of string: it counts the characters.</p>
<pre><code>&gt;&gt;&gt; a = &quot;Hello&quot;
&gt;&gt;&gt; len(a)
5
</code></pre>
<h4> wjandrea, Comment 132693046 Score: 0: </h4>Saying it &quot;counts&quot; might be misleading because in most cases, it&#39;ll just be retrieving an integer that&#39;s already defined on the object, not iterating through and incrementing a number like &quot;counts&quot; implies.<br>------------------------------------------------------------------ <br><h3> gnud, Id: 1712236, Score: 2935: </h3><p>The <a href="https://docs.python.org/3/library/functions.html#len" rel="noreferrer"><code>len()</code></a> function can be used with several different types in Python - both built-in types and library types. For example:</p>
<pre><code>&gt;&gt;&gt; len([1, 2, 3])
3
</code></pre>
------------------------------------------------------------------ <br><h3> Russia Must Remove Putin, Id: 27137427, Score: 305: </h3><blockquote>
<h1>How do I get the length of a list?</h1>
</blockquote>
<p>To find the number of elements in a list, use the builtin function <a href="https://docs.python.org/3/library/functions.html#len" rel="noreferrer"><code>len</code></a>:</p>
<pre><code>items = []
items.append(&quot;apple&quot;)
items.append(&quot;orange&quot;)
items.append(&quot;banana&quot;)
</code></pre>
<p>And now:</p>
<pre><code>len(items)
</code></pre>
<p>returns 3.</p>
<h2>Explanation</h2>
<p>Everything in Python is an object, including lists. All objects have a header of some sort in the C implementation.</p>
<p>Lists and other similar builtin objects with a &quot;size&quot; in Python, in particular, have an attribute called <code>ob_size</code>, where the number of elements in the object is cached. So checking the number of objects in a list is very fast.</p>
<p>But if you're checking if list size is zero or not, don't use <code>len</code> - instead, put the list in a boolean context - <a href="https://stackoverflow.com/a/45778282/541136">it is treated as False if empty, and True if non-empty</a>.</p>
<h2>From the <a href="https://docs.python.org/library/functions.html#len" rel="noreferrer">docs</a></h2>
<p><strong><code>len(s)</code></strong></p>
<blockquote>
<p>Return the length (the number of items) of an object. The argument may be a sequence (such as a string, bytes, tuple, list, or range) or
a collection (such as a dictionary, set, or frozen set).</p>
</blockquote>
<p><code>len</code> is implemented with <code>__len__</code>, from the data model <a href="https://docs.python.org/reference/datamodel.html#object.__len__" rel="noreferrer">docs</a>:</p>
<p><strong><code>object.__len__(self)</code></strong></p>
<blockquote>
<p>Called to implement the built-in function <code>len()</code>. Should return the length of the object, an integer &gt;= 0. Also, an object that doesn’t
define a <code>__nonzero__()</code> [in Python 2 or <code>__bool__()</code> in Python 3] method and whose <code>__len__()</code> method returns zero
is considered to be false in a Boolean context.</p>
</blockquote>
<p>And we can also see that <code>__len__</code> is a method of lists:</p>
<pre><code>items.__len__()
</code></pre>
<p>returns 3.</p>
<h2>Builtin types you can get the <code>len</code> (length) of</h2>
<p>And in fact we see we can get this information for all of the described types:</p>
<pre><code>&gt;&gt;&gt; all(hasattr(cls, '__len__') for cls in (str, bytes, tuple, list, 
                                            range, dict, set, frozenset))
True
</code></pre>
<h2>Do not use <code>len</code> to test for an empty or nonempty list</h2>
<p>To test for a specific length, of course, simply test for equality:</p>
<pre><code>if len(items) == required_length:
    ...
</code></pre>
<p>But there's a special case for testing for a zero length list or the inverse. In that case, do not test for equality.</p>
<p>Also, do not do:</p>
<pre><code>if len(items): 
    ...
</code></pre>
<p>Instead, simply do:</p>
<pre><code>if items:     # Then we have some items, not empty!
    ...
</code></pre>
<p>or</p>
<pre><code>if not items: # Then we have an empty list!
    ...
</code></pre>
<p>I <a href="https://stackoverflow.com/questions/53513/best-way-to-check-if-a-list-is-empty/45778282#45778282">explain why here</a> but in short, <code>if items</code> or <code>if not items</code> is more readable and performant than other alternatives.</p>
------------------------------------------------------------------ <br><h3> Naftuli Kay, Id: 16114025, Score: 79: </h3><p>While this may not be useful due to the fact that it'd make a lot more sense as being "out of the box" functionality, a fairly simple hack would be to build a class with a <code>length</code> property:</p>

<pre><code>class slist(list):
    @property
    def length(self):
        return len(self)
</code></pre>

<p>You can use it like so:</p>

<pre><code>&gt;&gt;&gt; l = slist(range(10))
&gt;&gt;&gt; l.length
10
&gt;&gt;&gt; print l
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
</code></pre>

<p>Essentially, it's exactly identical to a list object, with the added benefit of having an OOP-friendly <code>length</code> property.</p>

<p>As always, your mileage may vary.</p>
<h4> Tadhg McDonald-Jensen, Comment 63029366 Score: 27: </h4>just so you know, you can just do <code>length = property(len)</code> and skip the one line wrapper function and keep the documentation / introspection of <code>len</code> with your property.<br>------------------------------------------------------------------ <br><h3> MSeifert, Id: 43285376, Score: 28: </h3><p>Besides <a href="https://docs.python.org/library/functions.html#len" rel="noreferrer"><code>len</code></a> you can also use <a href="https://docs.python.org/library/operator.html#operator.length_hint" rel="noreferrer"><code>operator.length_hint</code></a> (requires Python 3.4+). For a normal <code>list</code> both are equivalent, but <code>length_hint</code> makes it possible to get the length of a list-iterator, which could be useful in certain circumstances:</p>

<pre><code>&gt;&gt;&gt; from operator import length_hint
&gt;&gt;&gt; l = ["apple", "orange", "banana"]
&gt;&gt;&gt; len(l)
3
&gt;&gt;&gt; length_hint(l)
3

&gt;&gt;&gt; list_iterator = iter(l)
&gt;&gt;&gt; len(list_iterator)
TypeError: object of type 'list_iterator' has no len()
&gt;&gt;&gt; length_hint(list_iterator)
3
</code></pre>

<p>But <code>length_hint</code> is by definition only a "hint", so most of the time <code>len</code> is better.</p>

<p>I've seen several answers suggesting accessing <code>__len__</code>. This is all right when dealing with built-in classes like <code>list</code>, but it could lead to problems with custom classes, because <code>len</code> (and <code>length_hint</code>) implement some safety checks. For example, both do not allow negative lengths or lengths that exceed a certain value (the <code>sys.maxsize</code> value). So it's always safer to use the <code>len</code> function instead of the <code>__len__</code> method!</p>
------------------------------------------------------------------ <br><h3> Jonathan Komar, Id: 47680896, Score: 14: </h3><p>And for completeness (primarily educational), it is possible without using the <code>len()</code> function. I would not condone this as a good option <strong>DO NOT PROGRAM LIKE THIS IN PYTHON</strong>, but it serves a purpose for learning algorithms.</p>
<pre><code>def count(list):   # list is an iterable object but no type checking here!
    item_count = 0
    for item in list:
        item_count += 1
    return item_count

count([1,2,3,4,5])
</code></pre>
<p>(The list object must be iterable, implied by the <code>for..in</code> stanza.)</p>
<p>The lesson here for new programmers is: You can’t get the number of items in a list without counting them at some point. The question becomes: when is a good time to count them? For example, high-performance code like the connect system call for sockets (written in C) <code>connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</code>, does not calculate the length of elements (giving that responsibility to the calling code). Notice that the length of the address is passed along to save the step of counting the length first? Another option: computationally, it might make sense to keep track of the number of items as you add them within the object that you pass. Mind that this takes up more space in memory. See <a href="https://stackoverflow.com/a/16114025/7851470">Naftuli Kay‘s answer</a>.</p>
<p>Example of keeping track of the length to improve performance while taking up more space in memory. Note that I never use the len() function because the length is tracked:</p>
<pre><code>class MyList(object):
    def __init__(self):
        self._data = []
        self.length = 0 # length tracker that takes up memory but makes length op O(1) time
        

        # the implicit iterator in a list class
    def __iter__(self):
        for elem in self._data:
            yield elem
            
    def add(self, elem):
        self._data.append(elem)
        self.length += 1
            
    def remove(self, elem):
        self._data.remove(elem)
        self.length -= 1
            
mylist = MyList()
mylist.add(1)
mylist.add(2)
mylist.add(3)
print(mylist.length) # 3
mylist.remove(3)
print(mylist.length) # 2
</code></pre>
<h4> Kirk Strauser, Comment 115280307 Score: 5: </h4>If we&#39;re going down the rabbit hole of &quot;don&#39;t do this but it&#39;s fun&quot;, I offer <code>length = max(enumerate(list))[0] + 1</code>.<br><h4> Jonathan Komar, Comment 119397874 Score: 2: </h4>@KirkStrauser Haha, I laughed at this clever avoidance on <code>len()</code><br><h4> Granny Aching, Comment 98508318 Score: 2: </h4>Why <code>for item in list[:]:</code>? Why not <code>for item in list:</code>? Also, I&#39;d use <code>+= 1</code> to increment.<br><h4> ShadowRanger, Comment 132684992 Score: 1: </h4>@JonathanKomar: The <code>[:]</code> in <code>list[:]</code> is not a &quot;range specifier&quot;, that&#39;s slicing, which shallow copies the entire <code>list</code> for no reason. If you omitted the <code>[:]</code>, it would not perform any such wasteful copies; it&#39;s not &quot;beneficial to know it is implied&quot;, because it&#39;s <i>not</i> implied at all. I have no idea what &quot;A list type [] is inferred as well&quot; is supposed to mean, but there&#39;s no inferred types; the objects have types, and anything meeting the duck-typing requirements of what you&#39;ve done will be accepted (be it <code>list</code>, <code>tuple</code>, <code>str</code>, etc.).<br><h4> Jonathan Komar, Comment 132704837 Score: 0: </h4>@ShadowRanger As emphasized, &quot;DO NOT PROGRAM LIKE THIS IN PYTHON [...] purpose for learning algorithms&quot;, you shouldn&#39;t be analyzing this answer for performance.  I am happy you understand what is going on. I&#39;ll adjust the answer in this case.<br>------------------------------------------------------------------ <br><h3> Shai Alon, Id: 31401712, Score: 10: </h3><p>Answering your question as the examples also given previously:</p>

<pre><code>items = []
items.append("apple")
items.append("orange")
items.append("banana")

print items.__len__()
</code></pre>
<h4> Russia Must Remove Putin, Comment 67792245 Score: 20: </h4>In Python, names that start with underscores are semantically non-public methods and should not be used by users.<br><h4> Russia Must Remove Putin, Comment 69133537 Score: 6: </h4>This Q&amp;A explains why you shouldn&#39;t use the special methods directly as a user: <a href="http://stackoverflow.com/q/40272161/541136">stackoverflow.com/q/40272161/541136</a><br><h4> Shai Alon, Comment 69130791 Score: 3: </h4>1. <code>__foo__</code>: this is just a convention, a way for the Python system to use names that won&#39;t conflict with user names.  2. <code>_foo</code>: this is just a convention, a way for the programmer to indicate that the variable is private (whatever that means in Python).  3. <code>__foo</code>: this has real meaning: the interpreter replaces this name with <code>_classname__foo</code> as a way to ensure that the name will not overlap with a similar name in another class.  * No other form of underscores have meaning in the Python world.  * There&#39;s no difference between class, variable, global, etc in these conventions.<br><h4> Shai Alon, Comment 72152858 Score: 0: </h4>@AaronHall but for len function it&#39;s almost the same. It might be faster for very large variables. However, I get your point and we should use len(obj) and not obj.__len__().<br>------------------------------------------------------------------ <br><h3> Alan Bagel, Id: 66926253, Score: 6: </h3><p>You can use the <code>len()</code> function to find the length of an iterable in python.</p>
<pre><code>my_list = [1, 2, 3, 4, 5]
print(len(my_list))  # OUTPUT: 5
</code></pre>
<p>The <code>len()</code> function also works with strings:</p>
<pre><code>my_string = &quot;hello&quot;
print(len(my_string))  # OUTPUT: 5
</code></pre>
<p>So to conclude, <code>len()</code> works with any sequence or collection (or any sized object that defines <code>__len__</code>).</p>
------------------------------------------------------------------ <br><h3> Tamil Selvan, Id: 70598253, Score: 5: </h3><p>There are three ways that you can find the length of the elements in the list. I will compare the 3 methods with performance analysis here.</p>
<h3>Method 1: Using <code>len()</code></h3>
<pre><code>items = []
items.append(&quot;apple&quot;)
items.append(&quot;orange&quot;)
items.append(&quot;banana&quot;)

print(len(items))
</code></pre>
<p>output:</p>
<pre><code>3
</code></pre>
<h3>Method 2: Using Naive Counter Method</h3>
<pre><code>items = []
items.append(&quot;apple&quot;)
items.append(&quot;orange&quot;)
items.append(&quot;banana&quot;)

counter = 0
for i in items:
    counter = counter + 1

print(counter)
</code></pre>
<p>output:</p>
<pre><code>3
</code></pre>
<h3>Method 3: Using <code>length_hint()</code></h3>
<pre><code>items = []
items.append(&quot;apple&quot;)
items.append(&quot;orange&quot;)
items.append(&quot;banana&quot;)

from operator import length_hint
list_len_hint = length_hint(items)
print(list_len_hint)
</code></pre>
<p>output:</p>
<pre><code>3
</code></pre>
<h3>Performance Analysis – Naive vs <code>len()</code> vs <code>length_hint()</code></h3>
<p><strong>Note</strong>: In order to compare, I am changing the input list into a large set that can give a good amount of time difference to compare the methods.</p>
<pre><code>items = list(range(100000000))

# Performance Analysis
from operator import length_hint
import time

# Finding length of list
# using loop
# Initializing counter

start_time_naive = time.time()
counter = 0
for i in items:
    # incrementing counter
    counter = counter + 1
end_time_naive = str(time.time() - start_time_naive)

# Finding length of list
# using len()
start_time_len = time.time()
list_len = len(items)
end_time_len = str(time.time() - start_time_len)

# Finding length of list
# using length_hint()
start_time_hint = time.time()
list_len_hint = length_hint(items)
end_time_hint = str(time.time() - start_time_hint)

# Printing Times of each
print(&quot;Time taken using naive method is : &quot; + end_time_naive)
print(&quot;Time taken using len() is : &quot; + end_time_len)
print(&quot;Time taken using length_hint() is : &quot; + end_time_hint)
</code></pre>
<p>Output:</p>
<pre><code>Time taken using naive method is : 7.536813735961914
Time taken using len() is : 0.0
Time taken using length_hint() is : 0.0
</code></pre>
<h3>Conclusion</h3>
<p>It can be clearly seen that time taken for naive is very large compared to the other two methods, hence <code>len()</code> &amp; <code>length_hint()</code> is the best choice to use.</p>
<h4> ShadowRanger, Comment 132685027 Score: 2: </h4>This is <i>terrible</i> micro-benchmarking code. A single execution timed with <code>time.time()</code>? Learn to use the <code>timeit</code> module; there are <i>so</i> many confounding variables that it&#39;s impossible to draw any conclusions from your test beyond &quot;of course looping and counting is slower&quot;.<br>------------------------------------------------------------------ <br><h3> Alec, Id: 56301389, Score: 4: </h3><p>Simple: use <code>len(list)</code> or <code>list.__len__()</code></p>
<p>In terms of how <code>len()</code> actually works, this is <a href="https://github.com/python/cpython/blob/4db8988420e0a122d617df741381b0c385af032c/Python/bltinmodule.c#L1547-L1559" rel="nofollow noreferrer">its C implementation</a>:</p>
<pre><code>static PyObject *
builtin_len(PyObject *module, PyObject *obj)
/*[clinic end generated code: output=fa7a270d314dfb6c input=bc55598da9e9c9b5]*/
{
    Py_ssize_t res;

    res = PyObject_Size(obj);
    if (res &lt; 0) {
        assert(PyErr_Occurred());
        return NULL;
    }
    return PyLong_FromSsize_t(res);
}
</code></pre>
<p><code>Py_ssize_t</code> is the maximum length that the object can have. <a href="https://docs.python.org/3/c-api/object.html#c.PyObject_Size" rel="nofollow noreferrer"><code>PyObject_Size()</code></a> is a function that returns the size of an object. If it cannot determine the size of an object, it returns -1. In that case, this code block will be executed:</p>
<pre><code>    if (res &lt; 0) {
        assert(PyErr_Occurred());
        return NULL;
    }
</code></pre>
<p>And an exception is raised as a result. Otherwise, this code block will be executed:</p>
<pre><code>    return PyLong_FromSsize_t(res);
</code></pre>
<p><code>res</code> which is a <code>C</code> integer, is converted into a Python <code>int</code> (which is still called a &quot;Long&quot; in the C code because Python 2 had two types for storing integers) and returned.</p>
<h4> cs95, Comment 99500530 Score: 5: </h4>Why does knowing, or knowing about the C implementation matter?<br><h4> MSeifert, Comment 104013520 Score: 0: </h4>Since this question isn&#39;t specific to CPython this answer may be misleading. PyPy, IronPython, ... can and do implement it differently.<br><h4> user3064538, Comment 116141599 Score: 0: </h4>This isn&#39;t a useful answer, as it&#39;s just saying &quot;<code>len</code> calls <code>PyObject_Size()</code>&quot; and doesn&#39;t say what that does, which is &quot;<code>PyObject_Size()</code> <a href="https://github.com/python/cpython/blob/ace3f9a0ce7b9fe8ae757fdd614f1e7a171f92b0/Objects/abstract.c#L52" rel="nofollow noreferrer">calls</a> the <a href="https://docs.python.org/3/c-api/typeobj.html#c.PySequenceMethods.sq_length" rel="nofollow noreferrer"><code>sq_length</code></a> or <a href="https://docs.python.org/3/c-api/mapping.html#c.PyMapping_Size" rel="nofollow noreferrer">PyMapping_Size</a> on the passed in object.&quot;<br>------------------------------------------------------------------ <br><h3> Comsavvy, Id: 65402167, Score: 4: </h3><p>To get the number of elements in any sequential objects, your goto method in Python is  <code>len()</code> eg.</p>
<pre class="lang-py prettyprint-override"><code>a = range(1000) # range
b = 'abcdefghijklmnopqrstuvwxyz' # string
c = [10, 20, 30] # List
d = (30, 40, 50, 60, 70) # tuple
e = {11, 21, 31, 41} # set
</code></pre>
<p><code>len()</code> method can work on all the above data types because they are iterable i.e You can iterate over them.</p>
<pre class="lang-py prettyprint-override"><code>all_var = [a, b, c, d, e] # All variables are stored to a list
for var in all_var:
    print(len(var))
</code></pre>
<p>A rough estimate of the <code>len()</code> method</p>
<pre class="lang-py prettyprint-override"><code>def len(iterable, /):
    total = 0
    for i in iterable:
        total += 1
    return total
</code></pre>
<h4> Comsavvy, Comment 128847916 Score: 0: </h4>There is a slight difference between iterator and iterable. All iterators are iterable but not the otherwise. Kindly refer to this article for more explanation <a href="https://www.geeksforgeeks.org/python-difference-iterable-iterator/amp/" rel="nofollow noreferrer">geeksforgeeks.org/python-difference-iterable-iterator/amp</a><br><h4> ShadowRanger, Comment 132685036 Score: 0: </h4>@wjandrea: If we&#39;re going to be picky, it&#39;s any <i>collection</i>. Works just fine on <code>set</code>s and <code>dict</code>s (neither of which are sequences).<br><h4> wjandrea, Comment 132692702 Score: 0: </h4>@ShadowRanger True, good point, though <a href="https://docs.python.org/3/library/functions.html#len" rel="nofollow noreferrer">the docs</a> say &quot;The argument may be a sequence <b>or</b> a collection&quot;. On the other hand, if we <a href="https://docs.python.org/3/library/collections.abc.html#collections-abstract-base-classes" rel="nofollow noreferrer">follow <code>collections.abc</code></a>, then any <code>Sequence</code> is a <code>Collection</code> by definition, but we only need a <code>Sized</code> object to get its length. So I think for the sake of this answer, it&#39;d be beter to say &quot;any object&quot; and avoid overcomplicating things.<br><h4> wjandrea, Comment 132692800 Score: 0: </h4>After the corrections, this answer is still incorrect with regard to iterables. The <code>len()</code> method works on those data types not because they&#39;re iterable, but because they have a <code>__len__()</code> method, which is to say they have a size that&#39;s known ahead of time, before iteration. And I&#39;m not sure how useful that rough estimate is where it actually <i>does</i> work on any (finite) iterable.<br><h4> wjandrea, Comment 120392535 Score: 0: </h4><i>&quot;any iterable&quot;</i> -- That&#39;s incorrect. I think you mean &quot;any sequence&quot;. Generators, for example: <code>len(x for x in range(8))</code> -&gt; <code>TypeError: object of type &#39;generator&#39; has no len()</code>.<br>