 <h2> Title: Determine the type of an object? </h2> <h3> Justin Ethier, question_id: 2225038 </h3>Score: 2141, Tags: {python,dictionary,types,typeof} <br><p>Is there a simple way to determine if a variable is a list, dictionary, or something else?</p>
<h4> Comment 8048162 Robert P: </h4>@S.Lott I&#39;d disagree with that; by being able to know the type, you can deal with some pretty variant input and still do the right thing.  It lets you work around interface issues inherent with relying on pure duck-typing (eg, the .bark() method on a Tree means something entirely different than on a Dog.)  For example, you could make a function that does some work on a file that accepts a string (eg, a path), a path object, or a list.  All have different interfaces, but the final result is the same: do some operation on that file.<br><h4> Comment 2184014 Justin Ethier: </h4>While in general I agree with you, there are situations where it is helpful to know. In this particular case I was doing some quick hacking that I eventually rolled back, so you are correct this time. But in some cases - when using reflection, for example - it is important to know what type of object you are dealing with.<br><h4> Comment 8050466 Robert P: </h4>@S.Lott I hoped it would be obvious that it&#39;s a contrived example; nonetheless it&#39;s a major failing point of duck typing, and one that <code>try</code> doesn&#39;t help with.  For example, if you knew that a user could pass in a string or an array, both are index-able, but that index means something completely different.  Simply relying on a try-catch in those cases will fail in unexpected and strange ways.  One solution is to make a separate method, another to add a little type checking.  I personally prefer polymorphic behavior over multiple methods that do almost the same thing...but that&#39;s just me :)<br><h4> Comment 16932398 Elliot Cameron: </h4>@S.Lott, what about unit testing? Sometimes you want your tests to verify that a function is returning something of the right type. A very real example is when you have class factory.<br><h4> Comment 23709673 Karl: </h4>For a less contrived example, consider a serializer/deserializer. By definition you are converting between user-supplied objects and a serialized representation. The serializer needs to determine the type of object you passed in, and you may not have adequate information to determine the deserialized type without asking the runtime (or at the very least, you may need it for sanity checking to catch bad data before it enters your system!)<br><h4> Comment 2183376 S.Lott: </h4>You shouldn&#39;t need to &quot;tell the difference&quot;.  Ever.  The point of Python (and duck typing) is that you never need to know.  Your function from which your &quot;getting an object back&quot; isn&#39;t designed properly if it returns objects of random, inconsistent types.<br><h4> Comment 45527757 Brent Bradburn: </h4>Another reason to explicitly discover the type of an object is that the documentation doesn&#39;t always tell you -- and sometimes it&#39;s just useful to know.  So not for control-flow, but just so you can reverse-engineer the return values of a function under different conditions.  Example: Python3 <a href="https://docs.python.org/3/library/subprocess.html#subprocess.check_output" rel="nofollow noreferrer"><code>subprocess.check_output()</code></a> returns different types depending on the <code>universal_newlines</code> parameter.<br><h4> Comment 42951199 Joe: </h4>Another possible scenario: Catching several exception types in a single &quot;except&quot; block, do some processing (like adding info to the error message), and then raise the exception with the additional info. You can &quot;Except (Ex1, Ex2) as err:&quot; and later on, raise type(err)(some_better_error_message). Using this method, one can also catch-all on a base exception type (e.g.: requests.exceptions.RequestsException as err) and then raise it again using the right sub class (again: raise type(err)(new_message)).<br><h4> Comment 8048281 S.Lott: </h4>@Robert P: &quot;the .bark() method on a Tree means something entirely different than on a Dog&quot;.  While true, I find this example contrived.  If your application is so hopelessly confused that (1) Dogs and Trees are appearing willy-nilly inside lists or tuples, and (2) you&#39;ve semantically overloaded a method name like that, then type-checking isn&#39;t going to be much help.  The &quot;string, path object or a list&quot; example is also easily handled through simple <code>try:</code> blocks without resorting to type checking.  Type checking imposes bad limits.  It stifles the &quot;open&quot; of the open-closed principle.<br><h4> Comment 99903213 Georgy: </h4>Also: <a href="https://stackoverflow.com/questions/402504/how-to-determine-a-python-variables-type">How to determine a Python variable&#39;s type?</a><br><h4> Comment 114234411 user11991978: </h4>If it&#39;s a simple case, you might wanna use type() or isinstance() and a neat if/else ladder.<br><h4> Comment 8055675 S.Lott: </h4>@Robert P: It&#39;s not a &quot;major failing point&quot;, since it doesn&#39;t actually matter.  &quot;if you knew that a user could pass in a string or an array,&quot; is contrived.  <b>You</b> define an API to accept one or the other.  What a user &quot;could pass in&quot; doesn&#39;t matter.  when they provide the wrong one, something <b>must</b> eventually break.  That&#39;s the definition of &quot;wrong type&quot; -- something breaks.  Which leads to an exception.  Which leads to a <code>try:</code> detecting the wrong type.  The definition of &quot;wrong type&quot; is that an exception <b>must</b> the raised somewhere.<br><h4> Comment 2185973 S.Lott: </h4>You&#39;d have to provide some more concrete examples of when you think you need to know the data type.  Usually, that&#39;s a sign of (a) a poorly-defined function or (b) pretty-poor polymorphism.   It&#39;s usually fixable with a simple design change.<br>------------------------------------------------------------------ <br><h3> Answer 2225066 poke: </h3><p>There are two built-in functions that help you identify the type of an object. You can use <a href="http://docs.python.org/3/library/functions.html#type" rel="noreferrer"><code>type()</code></a>  if you need the exact type of an object, and <a href="http://docs.python.org/3/library/functions.html#isinstance" rel="noreferrer"><code>isinstance()</code></a> to <em>check</em> an object’s type against something. Usually, you want to use <code>isinstance()</code> most of the times since it is very robust and also supports type inheritance.</p>
<hr />
<p>To get the actual type of an object, you use the built-in <a href="http://docs.python.org/3/library/functions.html#type" rel="noreferrer"><code>type()</code></a> function. Passing an object as the only parameter will return the type object of that object:</p>
<pre><code>&gt;&gt;&gt; type([]) is list
True
&gt;&gt;&gt; type({}) is dict
True
&gt;&gt;&gt; type('') is str
True
&gt;&gt;&gt; type(0) is int
True
</code></pre>
<p>This of course also works for custom types:</p>
<pre><code>&gt;&gt;&gt; class Test1 (object):
        pass
&gt;&gt;&gt; class Test2 (Test1):
        pass
&gt;&gt;&gt; a = Test1()
&gt;&gt;&gt; b = Test2()
&gt;&gt;&gt; type(a) is Test1
True
&gt;&gt;&gt; type(b) is Test2
True
</code></pre>
<p>Note that <code>type()</code> will only return the immediate type of the object, but won’t be able to tell you about type inheritance.</p>
<pre><code>&gt;&gt;&gt; type(b) is Test1
False
</code></pre>
<p>To cover that, you should use the <a href="http://docs.python.org/3/library/functions.html#isinstance" rel="noreferrer"><code>isinstance</code></a> function. This of course also works for built-in types:</p>
<pre><code>&gt;&gt;&gt; isinstance(b, Test1)
True
&gt;&gt;&gt; isinstance(b, Test2)
True
&gt;&gt;&gt; isinstance(a, Test1)
True
&gt;&gt;&gt; isinstance(a, Test2)
False
&gt;&gt;&gt; isinstance([], list)
True
&gt;&gt;&gt; isinstance({}, dict)
True
</code></pre>
<p><code>isinstance()</code> is usually the preferred way to ensure the type of an object because it will also accept derived types. So unless you actually need the type object (for whatever reason), using <code>isinstance()</code> is preferred over <code>type()</code>.</p>
<p>The second parameter of <code>isinstance()</code> also accepts a tuple of types, so it’s possible to check for multiple types at once. <code>isinstance</code> will then return true, if the object is of any of those types:</p>
<pre><code>&gt;&gt;&gt; isinstance([], (tuple, list, set))
True
</code></pre>
<h4> Comment 2179735 John La Rooy: </h4>I think it&#39;s clearer to use <code>is</code> instead of <code>==</code> as the types are singletons<br><h4> Comment 2180226 John La Rooy: </h4>@Mike Graham, there are times when <code>type</code> is the best answer. There are times when <code>isinstance</code> is the best answer and there are times when duck typing is the best answer. It&#39;s important to know all of the options so you can choose which is more appropriate for the situation.<br><h4> Comment 2180060 Mike Graham: </h4>@gnibbler, In the cases you would be typechecking (which you shouldn&#39;t be doing to begin with), <code>isinstance</code> is the preferred form anyhow, so neither <code>==</code> or <code>is</code> need be used.<br><h4> Comment 2185927 Mike Graham: </h4>@gnibbler, That may be, though I haven&#39;t yet ran into the situation where <code>type(foo) is SomeType</code> would be better than <code>isinstance(foo, SomeType)</code>.<br><h4> Comment 17803764 flying sheep: </h4>@poke: i totally agree about PEP8, but you’re attacking a strawman here: the important part of Sven’s argument wasn’t PEP8, but that you can use <code>isinstance</code> for your usecase (checking for a range of types) as well, and with as clean a syntax as well, which has the great advantage that you can capture subclasses. someone using <code>OrderedDict</code> would hate your code to fail because it just accepts pure dicts.<br><h4> Comment 77811103 Artyer: </h4>Example from CPython implentation: <a href="https://github.com/python/cpython/blob/e4c06bcca358c6dcb6393a75a1589ff6a2d45cde/Lib/collections/__init__.py#L398" rel="nofollow noreferrer"><code>collections.namedtuple</code></a>: <code>type(name) is str</code> as attribute names that are not strings (exactly) make no sense, and are probably an error.  But to check for <code>int</code>s that are not <code>bool</code>s, you would do <code>isinstance(x, int) and not isinstance(x, bool)</code>, so as to not exclude <code>int</code> subclasses, but to exclude <code>bool</code>. Note, that <code>bool</code> is not subclassable, so <code>type(x) is not bool</code> works the same, but that would be inconsistent.<br><h4> Comment 9668249 Sven Marnach: </h4>@poke: Maybe I&#39;m a bit late to the party, but I don&#39;t think there is ever a situation where you should prefer <code>type(x) is X</code> over <code>isinstance(x, X)</code>.  Even the example in your last comment is better written as <code>isinstance(param, (list, tuple))</code>.  PEP 8 explicitly discourages the use of <code>type(x) is X</code>.<br><h4> Comment 62324514 Mike O&#39;Connor: </h4>Oddly, I just implemented <code>isinstance()</code> in my project and was momentarily tripped up until I realized that <code>isinstance(True, int)</code> yields <code>True</code>.<br><h4> Comment 2187794 poke: </h4>I used constructs like <code>type( param ) in ( list, tuple )</code> in the past, when working with different parameter types, where a completely different approach was required based on the type.<br><h4> Comment 63207471 Alan Franzoni: </h4>On the other hand, using type() in Python 2.x for instances of classic classes (not inheriting from object) is just plain useless, since the type is always instance.<br><h4> Comment 9669146 poke: </h4>@SvenMarnach PEP8 is a style guideline though, not a rule that has to be enforced. The example still works and can be useful.<br><h4> Comment 133805022 Matthaeus Gaius Caesar: </h4>this will not work if you are trying to output the type to a log...<br><h4> Comment 25971557 don bright: </h4>i have some code where &quot;type(x) is Y&quot; returns false but  &quot;isinstance(x,Y)&quot; returns true<br><h4> Comment 25982905 poke: </h4>@donbright That’s when <code>type(x)</code> is <code>Z</code> and <code>Z</code> is a subtype of <code>Y</code> (meaning that every instance of <code>Z</code> is also an instance of <code>Y</code> but the type of that instance is not identical to <code>Y</code>).<br><h4> Comment 36929902 deed02392: </h4>CAREFUL! You can clobber types and your checks will fail:  &gt;&gt;&gt; the_d = {}  &gt;&gt;&gt; t = lambda x: &quot;aight&quot; if type(x) is dict else &quot;NOPE&quot; &gt;&gt;&gt; t(the_d) &#39;aight&#39; &gt;&gt;&gt; dict = &quot;dude.&quot; &gt;&gt;&gt; t(the_d) &#39;NOPE&#39;<br><h4> Comment 62328013 poke: </h4>@MikeO&#39;Connor That’s because <code>True</code> is of type <code>bool</code> and <code>bool</code> is a subtype of <code>int</code>.<br><h4> Comment 62401296 Mike O&#39;Connor: </h4>@poke, I quite found that to be the case. My point was that you need to work around that if you want to distinguish between ints and bools; I did. So I had to add <code>&#39;bool&#39; in str(type())</code> to my Boolean expression.<br>------------------------------------------------------------------ <br><h3> Answer 2225055 brettkelly: </h3><p>Use <code>type()</code>:</p>
<pre><code>&gt;&gt;&gt; a = []
&gt;&gt;&gt; type(a)
&lt;type 'list'&gt;
&gt;&gt;&gt; f = ()
&gt;&gt;&gt; type(f)
&lt;type 'tuple'&gt;
</code></pre>
------------------------------------------------------------------ <br><h3> Answer 2225081 Seth Johnson: </h3><p>It might be more Pythonic to use a <code>try</code>...<code>except</code> block. That way, if you have a class which quacks like a list, or quacks like a dict, it will behave properly regardless of what its type <em>really</em> is.</p>

<p>To clarify, the preferred method of "telling the difference" between variable types is with something called <a href="http://en.wikipedia.org/wiki/Duck_typing" rel="noreferrer">duck typing</a>: as long as the methods (and return types) that a variable responds to are what your subroutine expects, treat it like what you expect it to be. For example, if you have a class that overloads the bracket operators with <code>getattr</code> and <code>setattr</code>, but uses some funny internal scheme, it would be appropriate for it to behave as a dictionary if that's what it's trying to emulate.</p>

<p>The other problem with the <code>type(A) is type(B)</code> checking is that if <code>A</code> is a subclass of <code>B</code>, it evaluates to <code>false</code> when, programmatically, you would hope it would be <code>true</code>. If an object is a subclass of a list, it should work like a list: checking the type as presented in the other answer will prevent this. (<code>isinstance</code> will work, however).</p>
<h4> Comment 10059534 Justin Ethier: </h4>Duck typing isn&#39;t really about telling the difference, though. It is about using a common interface.<br><h4> Comment 59570079 Rens van der Heijden: </h4>Be careful -- most coding style guides recommend not using exception handling as part of the normal control flow of code, usually because it makes code difficult to read. <code>try</code>... <code>except</code> is a good solution when you want to deal with errors, but not when deciding on behavior based on type.<br>------------------------------------------------------------------ <br><h3> Answer 17330925 Lorenzo Persichetti: </h3><p>On instances of object you also have the:</p>

<pre class="lang-py prettyprint-override"><code>__class__
</code></pre>

<p>attribute. Here is a sample taken from Python 3.3 console</p>

<pre class="lang-py prettyprint-override"><code>&gt;&gt;&gt; str = "str"
&gt;&gt;&gt; str.__class__
&lt;class 'str'&gt;
&gt;&gt;&gt; i = 2
&gt;&gt;&gt; i.__class__
&lt;class 'int'&gt;
&gt;&gt;&gt; class Test():
...     pass
...
&gt;&gt;&gt; a = Test()
&gt;&gt;&gt; a.__class__
&lt;class '__main__.Test'&gt;
</code></pre>

<p>Beware that in python 3.x and in New-Style classes (aviable optionally from Python 2.6) class and type have been merged and this can sometime lead to unexpected results. Mainly for this reason my favorite way of testing types/classes is to the <a href="http://docs.python.org/3.3/library/functions.html#isinstance" rel="noreferrer">isinstance</a> built in function.</p>
<h4> Comment 58913499 mstbaum: </h4>Your point at the end is very important. type(obj) is Class wasn&#39;t working correctly, but isinstance did the trick.  I understand that isinstance is preferred anyway, but it&#39;s more beneficial than just checking derived types, as suggested in the accepted answer.<br><h4> Comment 63209012 Alan Franzoni: </h4><code>__class__</code> is mostly OK on Python 2.x, the only objects in Python which don&#39;t have <code>__class__</code> attribute are old-style classes AFAIK. I don&#39;t understand your Python 3 concern, by the way - on such version, just every object has a <code>__class__</code> attribute that points to the proper class.<br>------------------------------------------------------------------ <br><h3> Answer 42796643 Russia Must Remove Putin: </h3><h1>Determine the type of a Python object</h1>

<p>Determine the type of an object with <code>type</code></p>

<pre><code>&gt;&gt;&gt; obj = object()
&gt;&gt;&gt; type(obj)
&lt;class 'object'&gt;
</code></pre>

<p>Although it works, avoid double underscore attributes like <code>__class__</code> - they're not semantically public, and, while perhaps not in this case, the builtin functions usually have better behavior.</p>

<pre><code>&gt;&gt;&gt; obj.__class__ # avoid this!
&lt;class 'object'&gt;
</code></pre>

<h2>type checking</h2>

<blockquote>
  <p>Is there a simple way to determine if a variable is a list, dictionary, or something else? I am getting an object back that may be either type and I need to be able to tell the difference.</p>
</blockquote>

<p>Well that's a different question, don't use type - use <code>isinstance</code>:</p>

<pre><code>def foo(obj):
    """given a string with items separated by spaces, 
    or a list or tuple, 
    do something sensible
    """
    if isinstance(obj, str):
        obj = str.split()
    return _foo_handles_only_lists_or_tuples(obj)
</code></pre>

<p>This covers the case where your user might be doing something clever or sensible by subclassing <code>str</code> - according to the principle of Liskov Substitution, you want to be able to use subclass instances without breaking your code - and <code>isinstance</code> supports this. </p>

<h2>Use Abstractions</h2>

<p>Even better, you might look for a specific Abstract Base Class from <code>collections</code> or <code>numbers</code>:</p>

<pre><code>from collections import Iterable
from numbers import Number

def bar(obj):
    """does something sensible with an iterable of numbers, 
    or just one number
    """
    if isinstance(obj, Number): # make it a 1-tuple
        obj = (obj,)
    if not isinstance(obj, Iterable):
        raise TypeError('obj must be either a number or iterable of numbers')
    return _bar_sensible_with_iterable(obj)
</code></pre>

<h2>Or Just Don't explicitly Type-check</h2>

<p>Or, perhaps best of all, use duck-typing, and don't explicitly type-check your code. Duck-typing supports Liskov Substitution with more elegance and less verbosity. </p>

<pre><code>def baz(obj):
    """given an obj, a dict (or anything with an .items method) 
    do something sensible with each key-value pair
    """
    for key, value in obj.items():
        _baz_something_sensible(key, value)
</code></pre>

<h2>Conclusion</h2>

<ul>
<li>Use <code>type</code> to actually get an instance's class. </li>
<li>Use <code>isinstance</code> to explicitly check for actual subclasses or registered abstractions. </li>
<li>And just avoid type-checking where it makes sense.</li>
</ul>
<h4> Comment 79947964 toonarmycaptain: </h4>There&#39;s always <code>try</code>/<code>except</code> instead of checking explicitly.<br><h4> Comment 79950415 Russia Must Remove Putin: </h4>Presumably that&#39;s what the user will do if they aren&#39;t sure about the types they&#39;ll be passing in. I don&#39;t like to clutter a correct implementation with exception handling unless I have something very good to do with the exception. The exception raised should be enough to inform the user that they need to correct their usage.<br><h4> Comment 129093582 John: </h4>Lovely reminder here about why not to use <code>__class__</code>, which, when the object is a <code>Mock</code> is the only way I could get the supposed type, as <code>type</code> would just say <code>Mock</code>. There is a much better assertion to be had by using the <code>return_value</code> of the mocked class, BTW.<br>------------------------------------------------------------------ <br><h3> Answer 23974819 deed02392: </h3><p>You can use <code>type()</code> or <code>isinstance()</code>.</p>

<pre><code>&gt;&gt;&gt; type([]) is list
True
</code></pre>

<p>Be warned that you can clobber <code>list</code> or any other type by assigning a variable in the current scope of the same name.</p>

<pre><code>&gt;&gt;&gt; the_d = {}
&gt;&gt;&gt; t = lambda x: "aight" if type(x) is dict else "NOPE"
&gt;&gt;&gt; t(the_d) 'aight'
&gt;&gt;&gt; dict = "dude."
&gt;&gt;&gt; t(the_d) 'NOPE'
</code></pre>

<p>Above we see that <code>dict</code> gets reassigned to a string, therefore the test:</p>

<pre><code>type({}) is dict
</code></pre>

<p>...fails.</p>

<p>To get around this and use <code>type()</code> more cautiously:</p>

<pre><code>&gt;&gt;&gt; import __builtin__
&gt;&gt;&gt; the_d = {}
&gt;&gt;&gt; type({}) is dict
True
&gt;&gt;&gt; dict =""
&gt;&gt;&gt; type({}) is dict
False
&gt;&gt;&gt; type({}) is __builtin__.dict
True
</code></pre>
<h4> Comment 37064730 deed02392: </h4>I agree with you on the &quot;don&#39;t do that&quot; part. But indeed to tell someone not to do something you should at least explain why not and I figured this was a relevant opportunity to do just that. I meant for the cautious method to look ugly and illustrate why they might not want to do it, leaving them to decide.<br><h4> Comment 36939320 Blckknght: </h4>I&#39;m not sure it&#39;s necessary to point out that shadowing the name of a builtin data type is bad for this case. Your <code>dict</code> string will also fail for lots of other code, like <code>dict([(&quot;key1&quot;, &quot;value1&quot;), (&quot;key2&quot;, &quot;value2&quot;)])</code>. The answer for those kinds of issues is <a href="http://www.youtube.com/watch?v=zCh7z5EwYF8" rel="nofollow noreferrer">&quot;Then don&#39;t do that&quot;</a>. Don&#39;t shadow builtin type names and expect things to work properly.<br><h4> Comment 63208902 Alan Franzoni: </h4>type() doesn&#39;t work as expected on Python 2.x for classic instances.<br>------------------------------------------------------------------ <br><h3> Answer 47284495 tnusraddinov: </h3><p>be careful using isinstance </p>

<pre><code>isinstance(True, bool)
True
&gt;&gt;&gt; isinstance(True, int)
True
</code></pre>

<p>but type</p>

<pre><code>type(True) == bool
True
&gt;&gt;&gt; type(True) == int
False
</code></pre>
<h4> Comment 126411825 Say OL: </h4>A useful remark<br>------------------------------------------------------------------ <br><h3> Answer 69856435 ItsMe: </h3><p>using type()</p>
<pre class="lang-py prettyprint-override"><code>x='hello this is a string'
print(type(x))
</code></pre>
<p>output</p>
<pre><code>&lt;class 'str'&gt;
</code></pre>
<p>to extract only the str use this</p>
<pre class="lang-py prettyprint-override"><code>x='this is a string'
print(type(x).__name__)#you can use__name__to find class
</code></pre>
<p>output</p>
<pre><code>str
</code></pre>
<p>if you use <code>type(variable).__name__</code> it can be read by us</p>
------------------------------------------------------------------ <br><h3> Answer 37876801 Alan Franzoni: </h3><p>While the questions is pretty old, I stumbled across this while finding out a proper way myself, and I think it still needs clarifying, <strong>at least for Python 2.x</strong> (did not check on Python 3, but since the issue arises with classic classes which are gone on such version, it probably doesn't matter).</p>

<p>Here I'm trying to answer the title's question: <strong>how can I determine the type of an arbitrary object</strong>? Other suggestions about using or not using isinstance are fine in many comments and answers, but I'm not addressing those concerns.</p>

<p>The main issue with the <code>type()</code> approach is that <strong>it doesn't work properly with old-style instances</strong>:</p>

<pre><code>class One:
    pass

class Two:
    pass


o = One()
t = Two()

o_type = type(o)
t_type = type(t)

print "Are o and t instances of the same class?", o_type is t_type
</code></pre>

<p>Executing this snippet would yield:</p>

<pre><code>Are o and t instances of the same class? True
</code></pre>

<p>Which, I argue, is not what most people would expect.</p>

<p>The <code>__class__</code> approach is the most close to correctness, but it won't work in one crucial case: when the passed-in object is an old-style <em>class</em> (not an instance!), since those objects lack such attribute.</p>

<p>This is the smallest snippet of code I could think of that satisfies such legitimate question in a consistent fashion:</p>

<pre><code>#!/usr/bin/env python
from types import ClassType
#we adopt the null object pattern in the (unlikely) case
#that __class__ is None for some strange reason
_NO_CLASS=object()
def get_object_type(obj):
    obj_type = getattr(obj, "__class__", _NO_CLASS)
    if obj_type is not _NO_CLASS:
        return obj_type
    # AFAIK the only situation where this happens is an old-style class
    obj_type = type(obj)
    if obj_type is not ClassType:
        raise ValueError("Could not determine object '{}' type.".format(obj_type))
    return obj_type
</code></pre>
------------------------------------------------------------------ <br><h3> Answer 56634559 Georgy: </h3><p>In many practical cases instead of using <code>type</code> or <code>isinstance</code> you can also use <a href="https://docs.python.org/library/functools.html#functools.singledispatch" rel="noreferrer"><code>@functools.singledispatch</code></a>, which is used to define <a href="https://docs.python.org/glossary.html#term-generic-function" rel="noreferrer">generic functions</a> (<em>function composed of multiple functions implementing the same operation for different types</em>).</p>

<p>In other words, you would want to use it when you have a code like the following:</p>

<pre><code>def do_something(arg):
    if isinstance(arg, int):
        ... # some code specific to processing integers
    if isinstance(arg, str):
        ... # some code specific to processing strings
    if isinstance(arg, list):
        ... # some code specific to processing lists
    ...  # etc
</code></pre>

<p>Here is a small example of how it works:</p>

<pre><code>from functools import singledispatch


@singledispatch
def say_type(arg):
    raise NotImplementedError(f"I don't work with {type(arg)}")


@say_type.register
def _(arg: int):
    print(f"{arg} is an integer")


@say_type.register
def _(arg: bool):
    print(f"{arg} is a boolean")
</code></pre>

<pre class="lang-none prettyprint-override"><code>&gt;&gt;&gt; say_type(0)
0 is an integer
&gt;&gt;&gt; say_type(False)
False is a boolean
&gt;&gt;&gt; say_type(dict())
# long error traceback ending with:
NotImplementedError: I don't work with &lt;class 'dict'&gt;
</code></pre>

<hr>

<p>Additionaly we can use <a href="https://docs.python.org/library/collections.abc.html" rel="noreferrer">abstract classes</a> to cover several types at once:</p>

<pre><code>from collections.abc import Sequence


@say_type.register
def _(arg: Sequence):
    print(f"{arg} is a sequence!")
</code></pre>

<pre class="lang-none prettyprint-override"><code>&gt;&gt;&gt; say_type([0, 1, 2])
[0, 1, 2] is a sequence!
&gt;&gt;&gt; say_type((1, 2, 3))
(1, 2, 3) is a sequence!
</code></pre>
------------------------------------------------------------------ <br><h3> Answer 41021761 Dimitris Fasarakis Hilliard: </h3><p>As an aside to the previous answers, it's worth mentioning the existence of <a href="https://docs.python.org/3/library/collections.abc.html" rel="nofollow noreferrer"><code>collections.abc</code></a> which contains several abstract base classes (ABCs) that complement duck-typing.</p>

<p>For example, instead of explicitly checking if something is a list with: </p>

<pre><code>isinstance(my_obj, list)
</code></pre>

<p>you could, if you're only interested in seeing if the object you have allows getting items, use <a href="https://docs.python.org/3/library/collections.abc.html#collections.abc.Sequence" rel="nofollow noreferrer"><code>collections.abc.Sequence</code></a>:</p>

<pre><code>from collections.abc import Sequence
isinstance(my_obj, Sequence) 
</code></pre>

<p>if you're strictly interested in objects that allow getting, setting <em>and</em> deleting items (i.e <em>mutable</em> sequences), you'd opt for <code>collections.abc.MutableSequence</code>.</p>

<p>Many other ABCs are defined there, <code>Mapping</code> for objects that can be used as maps, <code>Iterable</code>, <code>Callable</code>, et cetera. A full list of all these can be seen in <a href="https://docs.python.org/3/library/collections.abc.html#collections-abstract-base-classes" rel="nofollow noreferrer">the documentation for <code>collections.abc</code>.</a></p>
------------------------------------------------------------------ <br><h3> Answer 66989625 Yash Marmat: </h3><pre><code>value = 12
print(type(value)) # will return &lt;class 'int'&gt; (means integer)
</code></pre>
<p>or you can do something like this</p>
<pre><code>value = 12
print(type(value) == int) # will return true
</code></pre>
------------------------------------------------------------------ <br><h3> Answer 56628816 Jos&#233; Crespo Barrios: </h3><p>In general you can extract a string from object with the class name,</p>

<pre><code>str_class = object.__class__.__name__
</code></pre>

<p>and using it for comparison,</p>

<pre><code>if str_class == 'dict':
    # blablabla..
elif str_class == 'customclass':
    # blebleble..
</code></pre>
------------------------------------------------------------------ <br><h3> Answer 56301446 Alec: </h3><p><code>type()</code> is a better solution than <code>isinstance()</code>, particularly for <code>booleans</code>:</p>

<p><code>True</code> and <code>False</code> are just keywords that mean <code>1</code> and <code>0</code> in python. Thus, </p>

<pre><code>isinstance(True, int)
</code></pre>

<p>and</p>

<pre><code>isinstance(False, int)
</code></pre>

<p>both return <code>True</code>. Both booleans are an instance of an integer. <code>type()</code>, however, is more clever:</p>

<pre><code>type(True) == int
</code></pre>

<p>returns <code>False</code>.</p>
------------------------------------------------------------------ <br><h3> Answer 62694570 Adnan Y: </h3><p>For the sake of completeness, isinstance <strong>will</strong> not work for type checking of a subtype that is not an instance. While that makes perfect sense, none of the answers (including the accepted one) covers it. Use <a href="https://docs.python.org/3/library/functions.html#issubclass" rel="nofollow noreferrer">issubclass</a> for that.</p>
<pre><code>&gt;&gt;&gt; class a(list):
...   pass
... 
&gt;&gt;&gt; isinstance(a, list)
False
&gt;&gt;&gt; issubclass(a, list)
True
</code></pre>
