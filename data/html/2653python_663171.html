 <h2> Title: How do I get a substring of a string in Python? </h2> <h3> Joan Venge, question_id: 663171 </h3>Score: 2653, Tags: {python,string,substring} <br><p>I want to get a new string from the third character to the end of the string, e.g. <code>myString[2:end]</code>. If omitting the second part means 'to the end', and if you omit the first part, does it start from the start?</p>
<h4> Comment 85827634 mario ruiz: </h4>This one contains a clear explanation <a href="https://www.pythoncentral.io/cutting-and-slicing-strings-in-python/" rel="nofollow noreferrer">pythoncentral.io/cutting-and-slicing-strings-in-python</a><br>------------------------------------------------------------------ <br><h3> Answer 9528361 codingscientist: </h3><p>A common way to achieve this is by string slicing. </p>

<p><code>MyString[a:b]</code> gives you a substring from index a to (b - 1).</p>
------------------------------------------------------------------ <br><h3> Answer 663175 Paolo Bergantino: </h3><pre><code>&gt;&gt;&gt; x = "Hello World!"
&gt;&gt;&gt; x[2:]
'llo World!'
&gt;&gt;&gt; x[:2]
'He'
&gt;&gt;&gt; x[:-2]
'Hello Worl'
&gt;&gt;&gt; x[-2:]
'd!'
&gt;&gt;&gt; x[2:-2]
'llo Worl'
</code></pre>

<p>Python calls this concept "slicing" and it works on more than just strings. Take a look <a href="https://stackoverflow.com/questions/509211/good-primer-for-python-slice-notation">here</a> for a comprehensive introduction.</p>
------------------------------------------------------------------ <br><h3> Answer 9780082 Endophage: </h3><p>Just for completeness as nobody else has mentioned it.  The third parameter to an array slice is a step.  So reversing a string is as simple as:</p>

<pre><code>some_string[::-1]
</code></pre>

<p>Or selecting alternate characters would be:</p>

<pre><code>"H-e-l-l-o- -W-o-r-l-d"[::2] # outputs "Hello World"
</code></pre>

<p>The ability to step forwards and backwards through the string maintains consistency with being able to array slice from the start or end.</p>
<h4> Comment 20793155 Endophage: </h4>@mtahmed absolutely related to question. What if you wanted to substring by selecting alternate characters from the string? That would be my_string[::2]<br><h4> Comment 83178504 Endophage: </h4>Sure, the specific example of selecting alternate characters may not be relevant to the question, but understanding there is a 3rd parameter to slicing very much is relevant and the simple examples serve to illustrate how it works. The Python community also has a great history of educating new members in a friendly way :-)<br><h4> Comment 82849960 John Lockwood: </h4>I think it&#39;s more likely you wanted to mention the third parameter to slice.  Needing to get every other character from a string may be an important use case somewhere, but I&#39;ve never had to do it. Not that there&#39;s anything wrong with wanting to show off what you know -- what&#39;s the point of knowing things if you can&#39;t do that. :) But the case for relevance to the question is overstated.<br><h4> Comment 117973257 Zoliqa: </h4>It is clear that if you put some_string[::-1] you got back, the string in reverse order. However, I really don&#39;t understand what you do in this case with the other numbers?   Ex.: test_string[5:1:-1] - will result a totally different way that I expect. How the first and second numbers will effect the string if the third number is &quot;-1&quot; ?<br>------------------------------------------------------------------ <br><h3> Answer 11808384 Michał Leon: </h3><p>Substr() normally (i.e. PHP and Perl) works this way: </p>

<pre><code>s = Substr(s, beginning, LENGTH)
</code></pre>

<p>So the parameters are <code>beginning</code> and <code>LENGTH</code>.</p>

<p>But Python's behaviour is different; it expects beginning and one after END (!). <strong>This is difficult to spot by beginners.</strong> So the correct replacement for Substr(s, beginning, LENGTH) is</p>

<pre><code>s = s[ beginning : beginning + LENGTH]
</code></pre>
<h4> Comment 24240292 Nicu Surdu: </h4>The beginners should learn the pythonic way when moving to python, not stick to other language habits<br><h4> Comment 97005145 victortv: </h4>A (probably) more pythonic way to do that is <code>s[beginning:][:length]</code><br><h4> Comment 95090784 PhilHibbs: </h4>And just for completeness, Java is like Python in that the String.substring() method takes start and one-past-end. This one just bit me hard, I had assumed it was length like every other substring function in the world.<br><h4> Comment 102963727 Gloweye: </h4>As someone who began with Python instead of [dirty word]-languages like PHP, I think Python is much more simple and intuitive with its string[beginning:end]. Length generally isn&#39;t relevant.<br><h4> Comment 125356416 AndyB: </h4>@PhilHibbs &quot;Like every other substring function&quot; is rather too strong a statement, since there are at least <b>two</b> other common ways to interpret substring arguments.   One is <code>(start, length)</code> and the other is <code>(start, end)</code>. Python&#39;s <code>(start, end+1)</code> is admittedly unusual, but fits well with the way other things in Python work.<br><h4> Comment 129389102 mattmc3: </h4>No. This is epically bad advice. Python supports negative indexing, so the math won&#39;t work here at all. Imagine <code>start=-4</code> and <code>length=8</code> and your string is the alphabet; your math gets you an empty string as a result because you are getting the string between <code>w</code> and <code>e</code>, instead of the correct result, <code>wxyz</code>.<br><h4> Comment 132611754 Leslie Krause: </h4>For me, length is far more relevant than ending index. I usually know how long the captured string is since it rarely changes, For example, if I&#39;m parsing a date &quot;DD-MMM-YYYY&quot;, it&#39;s far more intuitive for me to specify year as starting index = 8 and length = 4. Trying to mentally figure out that ending index is error prone.<br>------------------------------------------------------------------ <br><h3> Answer 663333 gimel: </h3><p>One example seems to be missing here: full (shallow) copy.</p>

<pre><code>&gt;&gt;&gt; x = "Hello World!"
&gt;&gt;&gt; x
'Hello World!'
&gt;&gt;&gt; x[:]
'Hello World!'
&gt;&gt;&gt; x==x[:]
True
&gt;&gt;&gt;
</code></pre>

<p>This is a common idiom for creating a copy of sequence types (not of interned strings), <code>[:]</code>. Shallow copies a list, see <em><a href="https://stackoverflow.com/questions/323689/python-list-slice-used-for-no-obvious-reason">Python list slice syntax used for no obvious reason</a></em>.</p>
<h4> Comment 24239876 Nicu Surdu: </h4>This has almost nothing to do with the question about substring. Doesn&#39;t even apply to string. Saying stringA = stringB is enough ...<br><h4> Comment 80817550 Russia Must Remove Putin: </h4>Attempting to sum up the other criticisms of this answer: In Python, strings are immutable, therefore there is no reason to make a copy of a string - so <code>s[:]</code> doesn&#39;t make a copy at all: <code>s = &#39;abc&#39;; s0 = s[:]; assert s is s0</code>. Yes it was the idiomatic way to copy a list in Python until lists got <code>list.copy</code>, but a full slice of an immutable type has no reason to make a copy because it can&#39;t be changed, so there may as well be only one in memory and we shouldn&#39;t waste time copying it. Since this answer is wrong and <b>doesn&#39;t even answer the question</b> - should it be deleted?<br><h4> Comment 24241693 gimel: </h4>The [:] full copy creates a NEW COPY, uses slice syntax and is read as &quot;substring from start to end&quot;<br><h4> Comment 70008125 bfontaine: </h4>What’s the point since strings are immutable? <code>a=b</code> should be sufficient.<br><h4> Comment 76353596 ShadowRanger: </h4>@gimel: Actually, <code>[:]</code> on an immutable type doesn&#39;t make a copy at all. While <code>mysequence[:]</code> is mostly harmless when <code>mysequence</code> is an immutable type like <code>str</code>, <code>tuple</code>, <code>bytes</code> (Py3) or <code>unicode</code> (Py2), <code>a = b[:]</code> is equivalent to <code>a = b</code>, it just wastes a little time dispatching the slicing byte codes which the object responds to by returning itself since it&#39;s pointless to shallow copy when, aside from object identity tests, it&#39;s equivalent to just return another reference to one&#39;s immutable self.<br>------------------------------------------------------------------ <br><h3> Answer 44730432 Russia Must Remove Putin: </h3><blockquote>
<p>Is there a way to substring a string in Python, to get a new string from the 3rd character to the end of the string?</p>
<p>Maybe like <code>myString[2:end]</code>?</p>
</blockquote>
<p>Yes, this actually works if you assign, or <a href="https://docs.python.org/reference/simple_stmts.html#assignment-statements" rel="noreferrer">bind</a>, the name,<code>end</code>, to constant singleton, <code>None</code>:</p>
<pre><code>&gt;&gt;&gt; end = None
&gt;&gt;&gt; myString = '1234567890'
&gt;&gt;&gt; myString[2:end]
'34567890'
</code></pre>
<p>Slice notation has 3 important arguments:</p>
<ul>
<li>start</li>
<li>stop</li>
<li>step</li>
</ul>
<p>Their defaults when not given are <code>None</code> - but we can pass them explicitly:</p>
<pre><code>&gt;&gt;&gt; stop = step = None
&gt;&gt;&gt; start = 2
&gt;&gt;&gt; myString[start:stop:step]
'34567890'
</code></pre>
<blockquote>
<p>If leaving the second part means 'till the end', if you leave the first part, does it start from the start?</p>
</blockquote>
<p>Yes, for example:</p>
<pre><code>&gt;&gt;&gt; start = None
&gt;&gt;&gt; stop = 2
&gt;&gt;&gt; myString[start:stop:step]
'12'
</code></pre>
<p>Note that we include start in the slice, but we only go up to, and not including, stop.</p>
<p>When step is <code>None</code>, by default the slice uses <code>1</code> for the step. If you step with a negative integer, Python is smart enough to go from the end to the beginning.</p>
<pre><code>&gt;&gt;&gt; myString[::-1]
'0987654321'
</code></pre>
<p>I explain slice notation in great detail in <a href="https://stackoverflow.com/a/24713353/541136">my answer to Explain slice notation Question.</a></p>
------------------------------------------------------------------ <br><h3> Answer 663185 bouvard: </h3><p>You've got it right there except for "end". It's called slice notation. Your example should read:</p>

<pre><code>new_sub_string = myString[2:]
</code></pre>

<p>If you leave out the second parameter it is implicitly the end of the string.</p>
------------------------------------------------------------------ <br><h3> Answer 39240743 ostrokach: </h3><p>I would like to add two points to the discussion:</p>

<ol>
<li><p>You can use <code>None</code> instead on an empty space to specify "from the start" or "to the end":</p>

<pre><code>'abcde'[2:None] == 'abcde'[2:] == 'cde'
</code></pre>

<p>This is particularly helpful in functions, where you can't provide an empty space as an argument:</p>

<pre><code>def substring(s, start, end):
    """Remove `start` characters from the beginning and `end` 
    characters from the end of string `s`.

    Examples
    --------
    &gt;&gt;&gt; substring('abcde', 0, 3)
    'abc'
    &gt;&gt;&gt; substring('abcde', 1, None)
    'bcde'
    """
    return s[start:end]
</code></pre></li>
<li><p>Python has <a href="https://docs.python.org/3/library/functions.html#slice" rel="noreferrer">slice</a> objects:</p>

<pre><code>idx = slice(2, None)
'abcde'[idx] == 'abcde'[2:] == 'cde'
</code></pre></li>
</ol>
------------------------------------------------------------------ <br><h3> Answer 71736121 Babatunde Mustapha: </h3><pre><code>text = &quot;StackOverflow&quot;
#using python slicing, you can get different subsets of the above string

#reverse of the string
text[::-1] # 'wolfrevOkcatS' 

#fist five characters
text[:5] # Stack'

#last five characters
text[-5:] # 'rflow'

#3rd character to the fifth character
text[2:5] # 'ack'

#characters at even positions
text[1::2] # 'tcOefo'
</code></pre>
<h4> Comment 134879109 r3cgm: </h4>The text[2:5] comment says &quot;rflow&quot; but I think that example output is actually &quot;ack&quot;.  Thanks for the helpful examples!<br>------------------------------------------------------------------ <br><h3> Answer 54733520 CopyPasteIt: </h3><p>If myString contains an account number that begins at offset 6 and has length 9, then you can extract the account number this way: <code>acct = myString[6:][:9]</code>.</p>

<p>If the OP accepts that, they might want to try, in an experimental fashion,</p>

<pre><code>myString[2:][:999999]
</code></pre>

<p>It works - no error is raised, and no default 'string padding' occurs.</p>
<h4> Comment 97005162 victortv: </h4>I think if you want to use this method <code>myString[offset:][:length]</code> in the case of OP you can just use <code>myString[offset:][:]</code><br><h4> Comment 97005350 CopyPasteIt: </h4>@VictorVal   The answer is for those (like me) who have learned Python as a 2nd (3rd, 4th, ...) programming language and want to some familiar &#39;syntax hooks&#39; to approach the language. Any experts in the language will most likely view my answer as a bit silly.<br><h4> Comment 99695128 Sebi: </h4>Should answers like this be flagged for deletion? Other answers explain similar solution much better, and seeing this one had made me scratch my head and lookup python for few minutes before realising that it&#39;s just that type answer.<br>------------------------------------------------------------------ <br><h3> Answer 61509129 Edson Horacio Junior: </h3><p>Well, I got a situation where I needed to translate a PHP script to Python, and it had many usages of <code>substr(string, beginning, LENGTH)</code>.<br>
If I chose Python's <code>string[beginning:end]</code> I'd have to calculate <strong>a lot</strong> of end indexes, so the easier way was to use <code>string[beginning:][:length]</code>, it saved me a lot of trouble.</p>
------------------------------------------------------------------ <br><h3> Answer 66849490 Harsh: </h3><pre><code>str1='There you are'
&gt;&gt;&gt; str1[:]
'There you are'

&gt;&gt;&gt; str1[1:]
'here you are'

#To print alternate characters skipping one element in between

&gt;&gt;&gt; str1[::2]
'Teeyuae'

#To print last element of last two elements
&gt;&gt;&gt; str1[:-2:-1]
'e'

#Similarly
&gt;&gt;&gt; str1[:-2:-1]
'e'


#Using slice datatype

&gt;&gt;&gt; str1='There you are'
&gt;&gt;&gt; s1=slice(2,6)
&gt;&gt;&gt; str1[s1]
'ere '


</code></pre>
<h4> Comment 122410878 LHM: </h4>I like your approach in listing out the options.  It seems two of your options are the same, though?<br>------------------------------------------------------------------ <br><h3> Answer 29121528 Rudi Uhl: </h3><p>Maybe I missed it, but I couldn't find a complete answer on this page to the original question(s) because variables are not further discussed here. So I had to go on searching.</p>

<p>Since I'm not yet allowed to comment, let me add my conclusion here. I'm sure I was not the only one interested in it when accessing this page:  </p>

<pre><code> &gt;&gt;&gt;myString = 'Hello World'
 &gt;&gt;&gt;end = 5

 &gt;&gt;&gt;myString[2:end]
 'llo'
</code></pre>

<p>If you leave the first part, you get   </p>

<pre><code> &gt;&gt;&gt;myString[:end]
 'Hello' 
</code></pre>

<p>And if you left the : in the middle as well you got the simplest substring, which would be the 5th character (count starting with 0, so it's the blank in this case):</p>

<pre><code> &gt;&gt;&gt;myString[end]
 ' '
</code></pre>
------------------------------------------------------------------ <br><h3> Answer 39240974 levi: </h3><p>Using hardcoded indexes itself can be a mess.</p>

<p>In order to avoid that, Python offers a built-in object <code>slice()</code>.</p>

<pre><code>string = "my company has 1000$ on profit, but I lost 500$ gambling."
</code></pre>

<p>If we want to know how many money I got left.</p>

<p>Normal solution:</p>

<pre><code>final = int(string[15:19]) - int(string[43:46])
print(final)
&gt;&gt;&gt;500
</code></pre>

<p>Using slices:</p>

<pre><code>EARNINGS = slice(15, 19)
LOSSES = slice(43, 46)
final = int(string[EARNINGS]) - int(string[LOSSES])
print(final)
&gt;&gt;&gt;500
</code></pre>

<p>Using slice you gain readability.</p>
<h4> Comment 70899542 ASalazar: </h4>Maybe this isn&#39;t the best example, because the hardcoded indexes remain and the readability comes from intermediate variables, which you could have used in the first example.<br>------------------------------------------------------------------ <br><h3> Answer 62717439 Crystalline Core: </h3><pre><code>a=&quot;Helloo&quot;
print(a[:-1])
</code></pre>
<p>In the above code, [:-1] declares to print from the starting till the maximum limit-1.</p>
<p><strong>OUTPUT :</strong></p>
<pre><code>&gt;&gt;&gt; Hello
</code></pre>
<blockquote>
<p>Note: Here a [:-1] is also the same as a [0:-1] and a [0:len(a)-1]</p>
</blockquote>
<pre><code>a=&quot;I Am Siva&quot;
print(a[2:])
</code></pre>
<p><strong>OUTPUT:</strong></p>
<pre><code>&gt;&gt;&gt; Am Siva
</code></pre>
<p>In the above code a [2:] declares to print a from index 2 till the last element.</p>
<blockquote>
<p>Remember that if you set the maximum limit to print a string, as (x) then it will print the string till (x-1) and also remember that the index of a list or string will always start from 0.</p>
</blockquote>
------------------------------------------------------------------ <br><h3> Answer 70445274 kannappan: </h3><p>I have a simpler solution using <strong>for loop</strong> to find a given substring in a string.
Let's say we have two string variables,</p>
<pre><code>main_string = &quot;lullaby&quot;
match_string = &quot;ll&quot;
</code></pre>
<p>If you want to check whether the given match string exists in the main string,  you can do this,</p>
<pre><code>match_string_len = len(match_string)
for index,value in enumerate(main_string):
    sub_string = main_string[index:match_string_len+index]
    if sub_string == match_string:
       print(&quot;match string found in main string&quot;)
</code></pre>
