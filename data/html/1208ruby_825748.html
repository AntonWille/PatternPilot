 <h2> Title: How to pass command line arguments to a rake task </h2> <h4> Tilendor, question_id: 825748 </h4>Score: 1208, Tags: {ruby,command-line,rake,command-line-arguments} <br><p>I have a rake task that needs to insert a value into multiple databases.  </p>

<p>I'd like to pass this value into the rake task from the command line, or from <em>another</em> rake task.</p>

<p>How can I do this?</p>
<h4> Brian Maltzan, Id: 7034580 Score: 4: </h4><a href="http://rake.rubyforge.org/files/doc/rakefile_rdoc.html" rel="nofollow noreferrer">rakefile rdoc</a><br><h4> Jonathan Allard, Id: 41998543 Score: 3: </h4><a href="http://docs.seattlerb.org/rake/" rel="nofollow noreferrer">Docs</a> have been mirrored by SeattleRb.<br>------------------------------------------------------------------ <br><h3> Nick Desjardins, Id: 825832, Score: 1188: </h3><p>You can specify formal arguments in rake by adding symbol arguments to the task call.  For example:</p>

<pre><code>require 'rake'

task :my_task, [:arg1, :arg2] do |t, args|
  puts "Args were: #{args} of class #{args.class}"
  puts "arg1 was: '#{args[:arg1]}' of class #{args[:arg1].class}"
  puts "arg2 was: '#{args[:arg2]}' of class #{args[:arg2].class}"
end

task :invoke_my_task do
  Rake.application.invoke_task("my_task[1, 2]")
end

# or if you prefer this syntax...
task :invoke_my_task_2 do
  Rake::Task[:my_task].invoke(3, 4)
end

# a task with prerequisites passes its 
# arguments to it prerequisites
task :with_prerequisite, [:arg1, :arg2] =&gt; :my_task #&lt;- name of prerequisite task

# to specify default values, 
# we take advantage of args being a Rake::TaskArguments object
task :with_defaults, :arg1, :arg2 do |t, args|
  args.with_defaults(:arg1 =&gt; :default_1, :arg2 =&gt; :default_2)
  puts "Args with defaults were: #{args}"
end
</code></pre>

<p>Then, from the command line:</p>

<pre>
> rake my_task[1,false]
Args were: {:arg1=>"1", :arg2=>"false"} of class Rake::TaskArguments
arg1 was: '1' of class String
arg2 was: 'false' of class String

> rake "my_task[1, 2]"
Args were: {:arg1=>"1", :arg2=>"2"}

> rake invoke_my_task
Args were: {:arg1=>"1", :arg2=>"2"}

> rake invoke_my_task_2
Args were: {:arg1=>3, :arg2=>4}

> rake with_prerequisite[5,6]
Args were: {:arg1=>"5", :arg2=>"6"}

> rake with_defaults
Args with defaults were: {:arg1=>:default_1, :arg2=>:default_2}

> rake with_defaults['x','y']
Args with defaults were: {:arg1=>"x", :arg2=>"y"}
</pre>

<p>As demonstrated in the second example, if you want to use spaces, the quotes around the target name are necessary to keep the shell from splitting up the arguments at the space.</p>

<p>Looking at the code in <strong>rake.rb</strong>, it appears that rake does not parse task strings to extract arguments for prerequisites, so you can't do <code>task :t1 =&gt; "dep[1,2]"</code>.  The only way to specify different arguments for a prerequisite would be to invoke it explicitly within the dependent task action, as in <code>:invoke_my_task</code> and <code>:invoke_my_task_2</code>.</p>

<p>Note that some shells (like zsh) require you to escape the brackets: <code>rake my_task\['arg1'\]</code></p>
<h4> Seth Bro, Comment 25796842 Score: 77: </h4>Note that zsh fails to parse the command line arguments correctly (<code>zsh: no matches found: ...</code>), so you need to escape the brackets: <code>rake my_task\[&#39;arg1&#39;\]</code>. From <a href="http://robots.thoughtbot.com/post/18129303042/how-to-use-arguments-in-a-rake-task" rel="nofollow noreferrer">robots.thoughtbot.com/post/18129303042/&hellip;</a><br><h4> Ajedi32, Comment 15967775 Score: 12: </h4>Note: According to rake, this syntax for accepting variables in tasks is deprecated: <code>WARNING: &#39;task :t, arg, :needs =&gt; [deps]&#39; is deprecated.  Please use &#39;task :t, [args] =&gt; [deps]&#39; instead.</code><br><h4> gaqzi, Comment 1068855 Score: 5: </h4>To invoke a task within a namespace simpy do:     Rake::Task[&#39;namespace:task&#39;].invoke<br><h4> Joshua Pinter, Comment 87465059 Score: 5: </h4>NOTE: <b>Do not add a space between arguments.</b> Use <code>rake my_task[1,2]</code> instead of <code>rake my_task[1, 2]</code>. Otherwise you get the dreaded <code>Don&#39;t know how to build task &#39;my_task[1,&#39;</code> error and you&#39;ll be scratching your head for longer than you&#39;d like to admit.<br><h4> GMA, Comment 31540790 Score: 2: </h4>@SethBro YES. If only your comment hadn&#39;t been hidden behind the &quot;See more comments&quot; link I wouldn&#39;t have wasted 10 minutes unable to make this work.<br><h4> Roberto, Comment 58869697 Score: 1: </h4>Add <code>alias rake=&#39;noglob rake&#39;</code> in your <code>.zshrc</code> and forget escaping the brackets.<br><h4> Nick Desjardins, Comment 8520434 Score: 1: </h4>That&#39;s a separate question, Igoru, but the reason your call to invoke only runs once is that rake is dependency-oriented, so it will only execute a task if it is needed. For generic tasks that means if it hasn&#39;t already run. To explicitly execute a task regardless of its dependencies or if it is needed, call execute instead of invoke.<br><h4> vlsd, Comment 119738097 Score: 0: </h4>for your last example with defaults, is that a recursive call to <code>with_defaults</code> or does the task name and the method name just happen to the be same?<br><h4> x-yuri, Comment 120639154 Score: 0: </h4>What&#39;s the point of escaping <code>x</code> and <code>y</code> in <code>rake with_defaults[&#39;x&#39;,&#39;y&#39;]</code>? What <code>rake</code> gets is <code>with_defaults[x,y]</code> anyway.<br><h4> igorsantos07, Comment 8506058 Score: 0: </h4>Is there a way to call a task more than one time in a row? I tried <code>5.times { Rake::Task[:my_task].invoke }</code> and it only worked for the first time.<br><h4> res, Comment 66059038 Score: 0: </h4>valid syntax for current rails (5) is: <code>task :task_name, [:var1, :var2] =&gt; :environment do |t, vars|</code>. Inside task vars looks like: <code>{:var1 =&gt; val, :var2 =&gt; val}</code><br><h4> William Entriken, Comment 72788422 Score: 0: </h4>For completeness: a task cannot explicitly specify (or override) values for its dependent task&#39;s arguments.<br><h4> Tilendor, Comment 639071 Score: 0: </h4>This doesn&#39;t tell me how to run the rake task with arguments from another task.  It covers only command line usage<br><h4> inger, Comment 6100799 Score: 0: </h4>@Rob, @Nick:  &quot;particularly needed to pass arguments to prerequisite task&quot;. I can&#39;t see an example explicitly passing parameters to prereq task.. Did I miss something? Is there a way to do this, rather than invoking?<br><h4> opsb, Comment 4266353 Score: 0: </h4>Actually amazed, I&#39;ve looked for the answer to this so many times and it&#39;s always been rake task arg1=2 arg2=3. This is much simpler when the arguments are in series.<br><h4> Rob, Comment 5161785 Score: 0: </h4>Thanks, I particularly needed to pass arguments to prerequisite task, your examples work perfectly.<br>------------------------------------------------------------------ <br><h3> Blair Anderson, Id: 29502094, Score: 474: </h3><p>Options and dependencies need to be inside arrays:</p>
<pre><code>namespace :thing do
  desc &quot;it does a thing&quot;
  task :work, [:option, :foo, :bar] do |task, args|
    puts &quot;work&quot;, args
  end
  
  task :another, [:option, :foo, :bar] do |task, args|
    puts &quot;another #{args}&quot;
    Rake::Task[&quot;thing:work&quot;].invoke(args[:option], args[:foo], args[:bar])
    # or splat the args
    # Rake::Task[&quot;thing:work&quot;].invoke(*args)
  end

end
</code></pre>
<p>Then</p>
<pre><code>rake thing:work[1,2,3]
=&gt; work: {:option=&gt;&quot;1&quot;, :foo=&gt;&quot;2&quot;, :bar=&gt;&quot;3&quot;}

rake thing:another[1,2,3]
=&gt; another {:option=&gt;&quot;1&quot;, :foo=&gt;&quot;2&quot;, :bar=&gt;&quot;3&quot;}
=&gt; work: {:option=&gt;&quot;1&quot;, :foo=&gt;&quot;2&quot;, :bar=&gt;&quot;3&quot;}
</code></pre>
<blockquote>
<p>NOTE: variable <code>task</code> is the task object, not very helpful unless you know/care about Rake internals.</p>
</blockquote>
<p><strong>RAILS NOTE:</strong></p>
<blockquote>
<p>If running the task from Rails, it's best to preload the environment by adding <code>=&gt; [:environment]</code> which is a way to setup <em>dependent</em> tasks.</p>
</blockquote>
<pre><code>  task :work, [:option, :foo, :bar] =&gt; [:environment] do |task, args|
    puts &quot;work&quot;, args
  end
</code></pre>
<h4> hutusi, Comment 77647948 Score: 68: </h4>Unfortuanely, zsh can not parse the call correctly, you need type the command on zsh like this: <code>rake thing:work\[1,2,3\]</code>, or this <code>rake &#39;thing:work[1,2,3]&#39;</code><br><h4> rpbaltazar, Comment 66832364 Score: 41: </h4>Also, make sure you don&#39;t use spaces between the arguments. E.g don&#39;t do this: <code>rake thing:work[1, 2, 3]</code> as it won&#39;t work and you&#39;ll get an error <code>Don&#39;t know how to build task</code><br><h4> theterminalguy, Comment 70495076 Score: 18: </h4>Also, make sure you enclose the argument in string. e.g from your command line run the rake task like so  <code>rake thing:work&#39;[1,2,3]&#39;</code><br><h4> Joshua Pinter, Comment 87403872 Score: 5: </h4>Instead of having a note to explain that <code>t</code> means <code>task</code>, why not just use <code>task</code> as the param name?<br><h4> Blair Anderson, Comment 86715362 Score: 2: </h4>@sakurashinken you can remove the <code>:environment</code> symbol from your task. rails applications have an :environment task...<br><h4> user2490003, Comment 98074924 Score: 1: </h4>Rake tasks seem to have an almost nonsensical layout for name, dependencies, and arguments. The conclusion - while it works - is not something you could have arrived at intuitively.<br><h4> user2490003, Comment 101982950 Score: 0: </h4>This is such a counter intuitive setup for a task runner / system. It&#39;s neither easily readable or easily writeable<br><h4> Blair Anderson, Comment 71502704 Score: 0: </h4>@DamianSimonPeter you do not need to use strings. can simply do <code>rake thing:workd[true,false,cheese]</code> the values will be strings!<br><h4> Joshua Pinter, Comment 87614067 Score: 0: </h4>@BlairAnderson Explicitness. I love it! :-)<br><h4> sakurashinken, Comment 86713470 Score: 0: </h4>This failed for me with the error <code>Don&#39;t know how to build task &#39;environment&#39; (see --tasks)</code> Nick Desjardins answer worked great.<br>------------------------------------------------------------------ <br><h3> timurb, Id: 5050412, Score: 384: </h3><p>In addition to answer by kch (I didn't find how to leave a comment to that, sorry):</p>

<p>You don't have to specify variables as <code>ENV</code> variables before the <code>rake</code> command. You can just set them as usual command line parameters like that:</p>

<pre><code>rake mytask var=foo
</code></pre>

<p>and access those from your rake file as ENV variables like such:</p>

<pre><code>p ENV['var'] # =&gt; "foo"
</code></pre>
<h4> stevec, Comment 99421318 Score: 5: </h4>This is the best simplest answer IMO. It worked right away. What exactly does the <code>p</code> mean?<br><h4> Kevin Triplett, Comment 133464179 Score: 1: </h4>This worked, whereas the chosen answer did not for me -- and after seeing the answers, I think rake is another Rails abomination along with ActionView. I&#39;m sure it solves a particular set of problems but it makes everyday tasks painful.<br><h4> Pavan Kumar V, Comment 134992646 Score: 1: </h4>very straight forward - in 2023 too! 😎 THANKS<br><h4> kqcef, Comment 99459798 Score: 1: </h4>@user5783745 Like puts but instead of logging value.to_s to standard out it calls Obj.inspect and logs that to standard out. <a href="http://ruby-doc.org/core-2.0.0/Kernel.html#method-i-p" rel="nofollow noreferrer">ruby-doc.org/core-2.0.0/Kernel.html#method-i-p</a><br><h4> lzap, Comment 105824653 Score: 0: </h4>Rake is utterly overengineered mess and this is the only way which worked. And it&#39;s not just me, this answer has the same amount of votes as the &quot;correct&quot; answer.<br><h4> frostymarvelous, Comment 135484092 Score: 0: </h4>nothing else worked for me. this immediately worked. thank you.<br><h4> moger777, Comment 136624784 Score: 0: </h4>I like this option more than the more idiomatic way. Order based variables can be problematic since it&#39;s harder to keep track of them.<br>------------------------------------------------------------------ <br><h3> Tombart, Id: 19466362, Score: 120: </h3><p>If you want to pass named arguments (e.g. with standard <code>OptionParser</code>) you could use something like this:</p>

<pre><code>$ rake user:create -- --user test@example.com --pass 123
</code></pre>

<p>note the <code>--</code>, that's necessary for bypassing standard Rake arguments. Should work with Rake <strong>0.9.x</strong>, <strong>&lt;= 10.3.x</strong>.</p>

<p>Newer Rake has changed its parsing of <code>--</code>, and now you have to make sure it's not passed to the <code>OptionParser#parse</code> method, for example with <code>parser.parse!(ARGV[2..-1])</code></p>

<pre><code>require 'rake'
require 'optparse'
# Rake task for creating an account

namespace :user do |args|
  desc 'Creates user account with given credentials: rake user:create'
  # environment is required to have access to Rails models
  task :create do
    options = {}
    OptionParser.new(args) do |opts|
      opts.banner = "Usage: rake user:create [options]"
      opts.on("-u", "--user {username}","User's email address", String) do |user|
        options[:user] = user
      end
      opts.on("-p", "--pass {password}","User's password", String) do |pass|
        options[:pass] = pass
      end
    end.parse!

    puts "creating user account..."
    u = Hash.new
    u[:email] = options[:user]
    u[:password] = options[:pass]
    # with some DB layer like ActiveRecord:
    # user = User.new(u); user.save!
    puts "user: " + u.to_s
    puts "account created."
    exit 0
  end
end
</code></pre>

<p><code>exit</code> at the end will make sure that the extra arguments won't be interpreted as Rake task. </p>

<p>Also the shortcut for arguments should work:</p>

<pre><code> rake user:create -- -u test@example.com -p 123
</code></pre>

<p>When rake scripts look like this, maybe it's time to look for another tool that would allow this just out of box.</p>
<h4> Joe, Comment 30313801 Score: 13: </h4>From my perspective this really is the best answer. Bypass environment variable kludges, strange syntax with task arguments, the additional benefit for standard <code>--option-names</code>.  My only suggestion would be to use <code>exit</code> rather than <code>abort</code> as <code>abort</code> will leave you with a return code of 1 to the shell.  If the rake task is a part of a higher-level script it&#39;s more common to assume a non-zero exit is some type of error.<br><h4> Tombart, Comment 44648542 Score: 2: </h4>The way how Rake parses ARGV was changed in <code>10.4.1</code> and reverted in <code>10.4.2</code>. <a href="https://github.com/ruby/rake/commit/86af0ef6d793b85068a44fb3407b23c9c9b09bc7" rel="nofollow noreferrer">github.com/ruby/rake/commit/&hellip;</a><br><h4> Augustin Riedinger, Comment 34820196 Score: 2: </h4>Besides, I don&#39;t understand what the <code>{username}</code> is here for. Where is it used? Why isn&#39;t it there in <code>-u {username}</code>? Cheers<br><h4> Rik Smith-Unna, Comment 31769572 Score: 1: </h4>I agree with Joe, this is the best answer. The natural thing is to use the same interface for passing options to rake as you would when passing options to a script.<br><h4> Augustin Riedinger, Comment 34784005 Score: 1: </h4>I agree this is the best answer. Ain&#39;t there a way to bypass the ugly <code>--</code>? Like passing <code>rake</code> arguments to the actual task or something? Like <code>task :my_task, :*args do |t, args|</code> or something?<br><h4> karatedog, Comment 121046254 Score: 0: </h4>the side effect of using <code>exit 0</code> is this task exits Rake when it is finished. So if you have a task that calls 2 tasks, and it calls the above first, the second task won&#39;t run.<br><h4> valheru, Comment 71704774 Score: 0: </h4>What about when you&#39;re using bundle exec rake?<br><h4> pawel7318, Comment 44652617 Score: 0: </h4>I&#39;m using 10.4.2. I created new question <a href="http://stackoverflow.com/questions/28110384/how-to-parse-rake-arguments-with-optionparser/28112320">here</a>.<br><h4> Justin Tanner, Comment 42584029 Score: 0: </h4><code>exit(&quot;account created.&quot;)</code> is causing an error <code>rake aborted!</code> wouldn&#39;t <code>puts &quot;account created&quot;; exit(0)</code> be a better approach?<br><h4> pawel7318, Comment 44593626 Score: 0: </h4>It worked for me after I <code>ARGV.shift</code> twice to remove <code>create:user</code> and <code>--</code> from <code>ARGV</code>. I&#39;m sure it&#39;s not the way it should be done. I will appreciate if someone will show how to fix it properly.<br><h4> Tombart, Comment 44647908 Score: 0: </h4>@pawel7318 Which version of Rake do you use? Rake doesn&#39;t seem to follow semantic versioning conventions, there is a compatibility breaking change since <code>10.4.0</code><br><h4> Tombart, Comment 34837742 Score: 0: </h4>As far as I know there&#39;s no way how to bypass ugly <code>--</code> (just not using rake). <code>{username}</code> should be replaced by your real username. It&#39;s just a notation for variable, it&#39;s not interpreted by ruby.<br>------------------------------------------------------------------ <br><h3> Tilendor, Id: 825864, Score: 59: </h3><p>I've found the answer from these two websites: <a href="http://nhw.pl/wp/2008/10/11/rake-and-arguments-for-tasks" rel="noreferrer">Net Maniac</a> and <a href="http://www.aimred.com/news/developers/2008/10/16/arguments-for-rake/" rel="noreferrer">Aimred</a>.</p>

<p>You need to have version > 0.8 of rake to use this technique</p>

<p>The normal rake task description is this:</p>

<pre><code>desc 'Task Description'
task :task_name =&gt; [:depends_on_taskA, :depends_on_taskB] do
  #interesting things
end
</code></pre>

<p>To pass arguments, do three things:</p>

<ol>
<li>Add the argument names after the task name, separated by commas.</li>
<li>Put the dependencies at the end using :needs => [...]</li>
<li>Place |t, args| after the do.  (t is the object for this task)</li>
</ol>

<p>To access the arguments in the script, use args.arg_name</p>

<pre><code>desc 'Takes arguments task'
task :task_name, :display_value, :display_times, :needs =&gt; [:depends_on_taskA, :depends_on_taskB] do |t, args|
  args.display_times.to_i.times do
    puts args.display_value
  end
end
</code></pre>

<p>To call this task from the command line, pass it the arguments in []s</p>

<pre><code>rake task_name['Hello',4]
</code></pre>

<p>will output</p>

<pre><code>Hello
Hello
Hello
Hello
</code></pre>

<p>and if you want to call this task from another task, and pass it arguments, use invoke</p>

<pre><code>task :caller do
  puts 'In Caller'
  Rake::Task[:task_name].invoke('hi',2)
end
</code></pre>

<p>then the command</p>

<pre><code>rake caller
</code></pre>

<p>will output</p>

<pre><code>In Caller
hi
hi
</code></pre>

<p>I haven't found a way to pass arguments as part of a dependency, as the following code breaks:</p>

<pre><code>task :caller =&gt; :task_name['hi',2]' do
   puts 'In Caller'
end
</code></pre>
<h4> madh, Comment 11088768 Score: 15: </h4>The format for this functionality has changed as this warning states:    <code>&#39;task :t, arg, :needs =&gt; [deps]&#39; is deprecated.  Please use &#39;task :t, [args] =&gt; [deps]&#39; instead.</code><br>------------------------------------------------------------------ <br><h3> Nate Flink, Id: 27206251, Score: 35: </h3><p>I couldn't figure out how to pass args and also the :environment until I worked this out:</p>

<pre><code>namespace :db do
  desc 'Export product data'
  task :export, [:file_token, :file_path] =&gt; :environment do |t, args|
    args.with_defaults(:file_token =&gt; "products", :file_path =&gt; "./lib/data/")

       #do stuff [...]

  end
end
</code></pre>

<p>And then I call like this:</p>

<pre><code>rake db:export['foo, /tmp/']
</code></pre>
<h4> Olivier JM, Comment 110075433 Score: 0: </h4>Thanks for this, great solution while maintaining the :environment<br>------------------------------------------------------------------ <br><h3> fl00r, Id: 5146980, Score: 32: </h3><p>Actually @Nick Desjardins answered perfect. But just for education: you can use dirty approach: using <code>ENV</code> argument</p>

<pre><code>task :my_task do
  myvar = ENV['myvar']
  puts "myvar: #{myvar}"
end 

rake my_task myvar=10
#=&gt; myvar: 10
</code></pre>
------------------------------------------------------------------ <br><h3> kch, Id: 825872, Score: 29: </h3><p>Another commonly used option is to pass environment variables. In your code you read them via <code>ENV['VAR']</code>, and can pass them right before the <code>rake</code> command, like</p>

<pre><code>$ VAR=foo rake mytask
</code></pre>
<h4> mu is too short, Comment 5756599 Score: 3: </h4>@jhs: <code>rake blah -- --these --go --to --a-program</code> (note the <code>--</code> to tell rake that its switches have ended), see <a href="http://stackoverflow.com/questions/5086224/how-can-i-pass-named-arguments-to-a-rake-task/5086648#5086648" title="how can i pass named arguments to a rake task">stackoverflow.com/questions/5086224/&hellip;</a><br><h4> karatedog, Comment 121046139 Score: 1: </h4>@muistooshort Right, passing arguments with double dash works. I cannot correct the previous comment, the error was on passing linux style command line arguments like: <code>--switch1 value1 --switch2 value2</code>.<br><h4> JasonSmith, Comment 3531561 Score: 0: </h4>Frankly I was hoping for rake task -- these --go --to -a program and my task could get them from ARGV. Unfortunately I&#39;m not sure if that&#39;s possible however I am currently using your solution: rake var1=val1 var2=val2<br><h4> karatedog, Comment 121045050 Score: 0: </h4>@muistooshort unfortunately (not knowing how it worked back in &#39;11) this will try to run all the arguments passed as if they were tasks. One of the half ugly solution is to create empty tasks based on ARGV,content so these task will indeed be run, they just won&#39;t do anything, the second is to <code>exit</code> at the end of the task. Exiting is the easier, but that will break any compound task that try to run the exiting task along others as <code>exit</code> will halt task execution and exit Rake.<br><h4> mu is too short, Comment 121045755 Score: 0: </h4>@karatedog Are you sure about that? I just tried it to make sure and it seems okay, am I missing something?<br>------------------------------------------------------------------ <br><h3> Feng, Id: 12909673, Score: 25: </h3><pre><code>desc 'an updated version'
task :task_name, [:arg1, :arg2] =&gt; [:dependency1, :dependency2] do |t, args|
    puts args[:arg1]
end
</code></pre>
<h4> Gayle, Comment 36288739 Score: 3: </h4>from <a href="http://rake.rubyforge.org/files/doc/rakefile_rdoc.html" rel="nofollow noreferrer">rake.rubyforge.org/files/doc/rakefile_rdoc.html</a>   &quot;Just a few words of caution. The rake task name and its arguments need to be a single command line argument to rake. This generally means no spaces. If spaces are needed, then the entire rake + argument string should be quoted. Something like this:     rake &quot;name[billy bob, smith]&quot; &quot;<br><h4> Dex, Comment 35703657 Score: 0: </h4>To call this, go: <code>rake task_name[hello, world]</code><br>------------------------------------------------------------------ <br><h3> jassa, Id: 36929059, Score: 24: </h3><p>I just wanted to be able to run:</p>

<pre><code>$ rake some:task arg1 arg2
</code></pre>

<p>Simple, right? (Nope!)</p>

<p>Rake interprets <code>arg1</code> and <code>arg2</code> as tasks, and tries to run them. So we just abort before it does.</p>

<pre><code>namespace :some do
  task task: :environment do
    arg1, arg2 = ARGV

    # your task...

    exit
  end
end
</code></pre>

<p>Take that, brackets!</p>

<p><strong>Disclaimer</strong>: I wanted to be able to do this in a pretty small pet project. Not intended for "real world" usage since you lose the ability to chain rake tasks (i.e. <code>rake task1 task2 task3</code>). IMO not worth it. Just use the ugly <code>rake task[arg1,arg2]</code>.</p>
<h4> XtraSimplicity, Comment 93593094 Score: 1: </h4><code>_, *args = ARGV</code> is perfect for capturing all subsequent arguments! Thanks heaps!<br><h4> fatty, Comment 66241568 Score: 4: </h4>Needed to make this <code>_, arg1, arg2 = ARGV</code> as the first arg was seen to be the name of the rake task. But that <code>exit</code> is a neat trick.<br><h4> Nuclearman, Comment 68329451 Score: 0: </h4><code>rake task[arg1,arg2] &amp;&amp; rake task2 &amp;&amp; rake task3</code> Not sure if that&#39;s less ugly than <code>rake task[arg1,arg2] task2 task3</code>. Probably less efficient though.<br>------------------------------------------------------------------ <br><h3> Naveen Kumar Madipally, Id: 71111415, Score: 14: </h3><pre><code>namespace :namespace1 do
  task :task1, [:arg1, :arg2, :arg3] =&gt; :environment do |_t, args|
    p args[:arg1]
  end
end
</code></pre>
<p>calling</p>
<p><code>rake namespace1:task1[&quot;1&quot;,&quot;2&quot;,&quot;3&quot;]</code></p>
<p>No need to provide environment while calling</p>
<p>in zsh need to enclose calling in quotes</p>
<p><code>rake 'namespace1:task1[&quot;1&quot;,&quot;2&quot;,&quot;3&quot;]'</code></p>
<h4> guero64, Comment 127795336 Score: 1: </h4>Actually, I think single quote goes after <code>rake</code>; i.e. <code>rake &#39;namespace1:task1[&quot;1&quot;,&quot;2&quot;,&quot;3&quot;]&#39;</code>.  Otherwise thank you for helpful answer.<br>------------------------------------------------------------------ <br><h3> djburdick, Id: 14078271, Score: 13: </h3><p>I use a regular ruby argument in the rake file:</p>

<pre><code>DB = ARGV[1]
</code></pre>

<p>then I stub out the rake tasks at the bottom of the file (since rake will look for a task based on that argument name).</p>

<pre><code>task :database_name1
task :database_name2
</code></pre>

<p>command line:</p>

<pre><code>rake mytask db_name
</code></pre>

<p>this feels cleaner to me than the var=foo ENV var and the task args[blah, blah2] solutions.<br>
the stub is a little jenky, but not too bad if you just have a few environments that are a one-time setup</p>
<h4> Juanda, Comment 20046080 Score: 2: </h4>To prevent frozen strings issues, use <code>dup</code> at the end:      db = ARGV[1].dup<br><h4> Duarte, Comment 123637648 Score: 1: </h4>I get an error when trying this:  <code>rake aborted! Don&#39;t know how to build task &#39;hello world&#39;</code><br><h4> Andre Figueiredo, Comment 63692579 Score: 0: </h4>Event better <code>db = ARGV[1].dup unless ARGV[1].nil?</code> to prevent exception of duping a nil.<br>------------------------------------------------------------------ <br><h3> Daniel Garmoshka, Id: 54664057, Score: 6: </h3><p>To run rake tasks with traditional arguments style:</p>

<pre><code>rake task arg1 arg2
</code></pre>

<p>And then use:</p>

<pre><code>task :task do |_, args|
  puts "This is argument 1: #{args.first}"
end
</code></pre>

<p>Add following patch of rake gem:</p>

<pre><code>Rake::Application.class_eval do

  alias origin_top_level top_level

  def top_level
    @top_level_tasks = [top_level_tasks.join(' ')]
    origin_top_level
  end

  def parse_task_string(string) # :nodoc:
    parts = string.split ' '
    return parts.shift, parts
  end

end

Rake::Task.class_eval do

  def invoke(*args)
    invoke_with_call_chain(args, Rake::InvocationChain::EMPTY)
  end

end
</code></pre>
------------------------------------------------------------------ <br><h3> Asim Mushtaq, Id: 23271702, Score: 5: </h3><p>The ways to pass argument are correct in above answer. However to run  rake task with arguments, there is a small technicality involved in newer version of rails</p>

<p>It will work with rake "namespace:taskname['argument1']"</p>

<p>Note the Inverted quotes in running the task from command line. </p>
------------------------------------------------------------------ <br><h3> lobati, Id: 64732696, Score: 4: </h3><p>One thing I don't see here is <a href="https://blog.stevenocchipinti.com/2013/10/18/rake-task-with-an-arbitrary-number-of-arguments/" rel="nofollow noreferrer">how to handle arbitrary arguments</a>. If you pass arguments that are not listed in the task definition, they are still accessible under <code>args.extras</code>:</p>
<pre class="lang-rb prettyprint-override"><code>task :thing, [:foo] do |task, args|
  puts args[:foo]     # named argument
  puts args.extras    # any additional arguments that were passed
end
</code></pre>
------------------------------------------------------------------ <br><h3> Gal, Id: 19481547, Score: 3: </h3><p>To pass arguments to the default task, you can do something like this. For example, say 
"version" is your argument:</p>

<pre><code>task :default, [:version] =&gt; [:build]

task :build, :version do |t,args|
  version = args[:version]
  puts version ? "version is #{version}" : "no version passed"
end
</code></pre>

<p>Then you can call it like so:</p>

<pre><code>$ rake
no version passed
</code></pre>

<p>or </p>

<pre><code>$ rake default[3.2.1]
version is 3.2.1
</code></pre>

<p>or</p>

<pre><code>$ rake build[3.2.1]
version is 3.2.1
</code></pre>

<p>However, I have not found a way to avoid specifying the task name (default or build) while passing in arguments. Would love to hear if anyone knows of a way.</p>
------------------------------------------------------------------ <br><h3> Abdo, Id: 21817334, Score: 3: </h3><p>I like the "querystring" syntax for argument passing, especially when there are a lot of arguments to be passed. </p>

<p>Example:</p>

<pre><code>rake "mytask[width=10&amp;height=20]"
</code></pre>

<p>The "querystring" being:</p>

<pre><code>width=10&amp;height=20
</code></pre>

<p><strong>Warning:</strong> note that the syntax is <code>rake "mytask[foo=bar]"</code> and <strong>NOT</strong> <code>rake mytask["foo=bar"]</code></p>

<p>When parsed inside the rake task using <code>Rack::Utils.parse_nested_query</code> , we get a <code>Hash</code>:</p>

<pre><code>=&gt; {"width"=&gt;"10", "height"=&gt;"20"}
</code></pre>

<p>(The cool thing is that you can pass hashes and arrays, more below)</p>

<p>This is how to achieve this:</p>

<pre><code>require 'rack/utils'

task :mytask, :args_expr do |t,args|
  args.with_defaults(:args_expr =&gt; "width=10&amp;height=10")
  options = Rack::Utils.parse_nested_query(args[:args_expr])
end
</code></pre>

<p>Here's a more extended example that I'm using with Rails in my <a href="https://github.com/zxiest/delayed_job_active_record_threaded" rel="nofollow">delayed_job_active_record_threaded</a> gem:</p>

<pre><code>bundle exec rake "dj:start[ebooks[workers_number]=16&amp;ebooks[worker_timeout]=60&amp;albums[workers_number]=32&amp;albums[worker_timeout]=120]"
</code></pre>

<p>Parsed the same way as above, with an environment dependency (in order load the Rails environment)</p>

<pre><code>namespace :dj do
  task :start, [ :args_expr ] =&gt; :environment do |t, args|
    # defaults here...
    options = Rack::Utils.parse_nested_query(args[:args_expr])  
  end
end
</code></pre>

<p>Gives the following in <code>options</code></p>

<pre><code>=&gt; {"ebooks"=&gt;{"workers_number"=&gt;"16", "worker_timeout"=&gt;"60"}, "albums"=&gt;{"workers_number"=&gt;"32", "worker_timeout"=&gt;"120"}}
</code></pre>
------------------------------------------------------------------ <br><h3> hexinpeter, Id: 28289772, Score: 3: </h3><p>Most of the methods described above did not work for me, maybe they are deprecated in the newer versions.
The up-to-date guide can be found here: <a href="http://guides.rubyonrails.org/command_line.html#custom-rake-tasks" rel="nofollow">http://guides.rubyonrails.org/command_line.html#custom-rake-tasks</a></p>

<p>a copy-and-paste ans from the guide is here:</p>

<pre><code>task :task_name, [:arg_1] =&gt; [:pre_1, :pre_2] do |t, args|
  # You can use args from here
end
</code></pre>

<p>Invoke it like this</p>

<pre><code>bin/rake "task_name[value 1]" # entire argument string should be quoted
</code></pre>
------------------------------------------------------------------ <br><h3> xander-miller, Id: 43927791, Score: 3: </h3><p>If you can't be bothered to remember what argument position is for what and you want do something like a ruby argument hash. You can use one argument to pass in a string and then regex that string into an options hash.  </p>

<pre><code>namespace :dummy_data do
  desc "Tests options hash like arguments"
  task :test, [:options] =&gt; :environment do |t, args|
    arg_options = args[:options] || '' # nil catch incase no options are provided
    two_d_array = arg_options.scan(/\W*(\w*): (\w*)\W*/)
    puts two_d_array.to_s + ' # options are regexed into a 2d array'
    string_key_hash = two_d_array.to_h
    puts string_key_hash.to_s + ' # options are in a hash with keys as strings'
    options = two_d_array.map {|p| [p[0].to_sym, p[1]]}.to_h
    puts options.to_s + ' # options are in a hash with symbols'
    default_options = {users: '50', friends: '25', colour: 'red', name: 'tom'}
    options = default_options.merge(options)
    puts options.to_s + ' # default option values are merged into options'
  end
end
</code></pre>

<p>And on the command line you get.</p>

<pre><code>$ rake dummy_data:test["users: 100 friends: 50 colour: red"]
[["users", "100"], ["friends", "50"], ["colour", "red"]] # options are regexed into a 2d array
{"users"=&gt;"100", "friends"=&gt;"50", "colour"=&gt;"red"} # options are in a hash with keys as strings
{:users=&gt;"100", :friends=&gt;"50", :colour=&gt;"red"} # options are in a hash with symbols
{:users=&gt;"100", :friends=&gt;"50", :colour=&gt;"red", :name=&gt;"tom"} # default option values are merged into options
</code></pre>
<h4> Joshua Pinter, Comment 87403713 Score: 3: </h4>Your code needs a few well-placed empty lines. I don&#39;t know how you read that wall of text.<br>------------------------------------------------------------------ <br><h3> Kᴏɴsᴛᴀɴᴛɪɴ Sʜɪʟᴏᴠ, Id: 77668015, Score: 0: </h3><p>Run by using <code>ARGV[1]</code>:</p>
<pre><code>rake task:calculate args='{ &quot;id&quot;: 336910, &quot;unlink&quot;: true }'
</code></pre>
<p>Task converts <code>ARGV[1]</code> to <code>Hash</code> for use:</p>
<pre><code>namespace :task do
  desc 'calculate'
  task calculate: :environment do
    require 'json'

    start = Time.current
    args = ARGV[1] ? JSON.parse(ARGV[1][5..]) : {}
    p &quot;Start task:calculate with args = #{args}&quot;
    # YourService.new(args).run # run you service
    p &quot;End task:calculate with args = #{args}&quot;
    p &quot;By time (minutes): #{((Time.current - start) / 60).round(0)}&quot;
  end
end
</code></pre>
<p>Output:</p>
<pre><code>Running via Spring preloader in process 66889
&quot;Start task:calculate with args = {\&quot;id\&quot;=&gt;336910, \&quot;unlink\&quot;=&gt;true}&quot;
&quot;End task:calculate with args = {\&quot;id\&quot;=&gt;336910, \&quot;unlink\&quot;=&gt;true}&quot;
&quot;By time (minutes): 0&quot;
</code></pre>
------------------------------------------------------------------ <br><h3> nakwa, Id: 76207815, Score: -1: </h3><p>I came up with this:</p>
<pre><code># CLI syntax 
rake sometasks:mytask -- myparam=value
</code></pre>
<pre><code># app/lib/tasks/sometasks.rake

def parse_options
    options = ActiveSupport::HashWithIndifferentAccess.new
    separator_index = ARGV.index(&quot;--&quot;)
    if separator_index
      option_array = ARGV.slice(separator_index + 1 , ARGV.length)
      option_pairs = option_array.map { |pair| pair.split(&quot;=&quot;) }
      option_pairs.each { |opt| options[opt[0]] = opt[1] || true }
    end
    options
end

namespace :sometasks do
  task :mytask do 
    options = parse_options
    myparam = options[:myparam]
    # my task ...
  end
end

</code></pre>
<p>This allows to pass any param, and should work while calling multiple rake tasks in a row, if each param is assigned a value.</p>
<p>There's probably room for improvement though.</p>
------------------------------------------------------------------ <br><h3> tundervirld, Id: 22070576, Score: -5: </h3><p>While passing parameters, it is better option is an input file, can this be a excel a json or whatever you need and from there read the data structure and variables you need from that including the variable name as is the need.
To read a file can have the following structure.</p>

<pre><code>  namespace :name_sapace_task do
    desc "Description task...."
      task :name_task  =&gt; :environment do
        data =  ActiveSupport::JSON.decode(File.read(Rails.root+"public/file.json")) if defined?(data)
    # and work whit yoour data, example is data["user_id"]

    end
  end
</code></pre>

<h1>Example json</h1>

<pre><code>{
  "name_task": "I'm a task",
  "user_id": 389,
  "users_assigned": [389,672,524],
  "task_id": 3
}
</code></pre>

<h1>Execution</h1>

<pre><code>rake :name_task 
</code></pre>
<h4> ZiggyTheHamster, Comment 52109554 Score: 4: </h4>If you need a JSON instructions file for your Rake task, you&#39;re probably doing too many things in your Rake task.<br><h4> jeffdill2, Comment 56817130 Score: 0: </h4>This is <i>way</i> over-complicating something that&#39;s incredibly simple.<br><h4> tundervirld, Comment 114902561 Score: 0: </h4>We were using a rake task to do many complex things like a task. One of them was to be the input to an ETL process, and you could need many input fields to do it.We were using a rake task to do many complex things like a task. One of them was to be the input to an ETL process, and you could need many input fields to do it. If you are thinking that a Rake Task is for easiest thing only, maybe you aren&#39;t using in other complex context.  Thanks for commenting.<br>