 <h2> Title: How to generate a random string in Ruby </h2> <h3> Jeff, question_id: 88311 </h3>Score: 827, Tags: {ruby,random,passwords} <br><p>I'm currently generating an 8-character pseudo-random uppercase string for "A" .. "Z":</p>

<pre><code>value = ""; 8.times{value  &lt;&lt; (65 + rand(25)).chr}
</code></pre>

<p>but it doesn't look clean, and it can't be passed as an argument since it isn't a single statement.  To get a mixed-case string "a" .. "z" plus "A" .. "Z", I changed it to:</p>

<pre><code>value = ""; 8.times{value &lt;&lt; ((rand(2)==1?65:97) + rand(25)).chr}
</code></pre>

<p>but it looks like trash.</p>

<p>Does anyone have a better method?</p>
<h4> Comment 14720680 Jeff: </h4>Suppose there is a method to reset a user&#39;s password and it has an argument for the new password. I would like to pass in a random string, in the above code I need a tmp variable, whereas in the single statement examples bellow I can do the whole thing as a one liner. Sure a utility method could be nice in the long run, esp if I&#39;m needing similar here and there, but sometimes you just want it in place, one time, done.<br><h4> Comment 14720848 David J.: </h4>No, you don&#39;t have to use a temporary variable. Try this: <code>reset_user_password!(random_string)</code> where <code>def random_string; SecureRandom.urlsafe_base64(20) end</code><br><h4> Comment 17429539 Colonel Panic: </h4>8 letters is a shamefully weak password. Given the md5sum a modern PC could recover the password in <a href="http://www.codinghorror.com/blog/2012/04/speed-hashing.html" rel="nofollow noreferrer">30 seconds</a>. How about something longer <a href="http://rubydoc.info/stdlib/securerandom/1.9.2/SecureRandom#urlsafe_base64-class_method" rel="nofollow noreferrer"><code>securerandom.urlsafe_base64</code></a><br><h4> Comment 61150850 Shiva: </h4>well, put a webdesigner infront of VIM and ask him to save and exit; Jokes apart. <code>require &#39;securerandom&#39;; SecureRandom.hex(15)</code> should work fine<br><h4> Comment 14437666 David J.: </h4>I don&#39;t understand why you care that &quot;since it isn&#39;t a single statement it can&#39;t be passed as an argument&quot;. Why not just make it a utility or helper method?<br>------------------------------------------------------------------ <br><h3> Answer 32656602 Alex Antonov: </h3><p>This solution needs external dependency, but seems prettier than another.</p>

<ol>
<li>Install gem <a href="https://github.com/stympy/faker" rel="nofollow noreferrer">faker</a></li>
<li><code>Faker::Lorem.characters(10) # =&gt; "ang9cbhoa8"</code></li>
</ol>
<h4> Comment 116978217 Mr. Rene: </h4>Passing number with the 1st argument of characters is deprecated. Use keyword argument like <code>characters(number: ...)</code> instead.    <code>Faker::Lorem.characters(number: 10) # =&gt; &quot;ang9cbhoa8&quot;</code><br>------------------------------------------------------------------ <br><h3> Answer 88341 Kent Fredric: </h3><pre><code>(0...8).map { (65 + rand(26)).chr }.join
</code></pre>
<p>I spend too much time golfing.</p>
<pre><code>(0...50).map { ('a'..'z').to_a[rand(26)] }.join
</code></pre>
<p>And a last one that's even more confusing, but more flexible and wastes fewer cycles:</p>
<pre><code>o = [('a'..'z'), ('A'..'Z')].map(&amp;:to_a).flatten
string = (0...50).map { o[rand(o.length)] }.join
</code></pre>
<p>If you want to generate some random text then use the following:</p>
<pre><code>50.times.map { (0...(rand(10))).map { ('a'..'z').to_a[rand(26)] }.join }.join(&quot; &quot;)
</code></pre>
<p>this code generates 50 random word string with words length less than 10 characters and then join with space</p>
<h4> Comment 14435768 fny: </h4>34 characters and blazing fast: <code>(&#39;a&#39;..&#39;z&#39;).to_a.shuffle[0,8].join</code>. Note you&#39;ll need Ruby &gt;=1.9 to <code>shuffle</code>.<br><h4> Comment 21462228 Robin: </h4><code>[*(&#39;a&#39;..&#39;z&#39;),*(&#39;0&#39;..&#39;9&#39;)].shuffle[0,8].join</code> to generate a random string with both letters and numbers.<br><h4> Comment 22328719 pencil: </h4><code>rand</code> is deterministic and predictable. Don&#39;t use this for generating passwords! Use one of the <code>SecureRandom</code> solutions instead.<br><h4> Comment 14959978 michaeltwofish: </h4>@faraz your method isn&#39;t functionally the same, it&#39;s not random with replacement.<br><h4> Comment 14720891 David J.: </h4>Leveraging existing libraries is preferable unless you have a driver to roll your own. See <code>SecureRandom</code> as one example, in the other answers.<br><h4> Comment 50115248 PL J: </h4>The solutions with <code>shuffle</code> wouldn&#39;t be that awesome, as they&#39;d generate strings with one occurrence of a character ( so string such as &quot;gbalgqut&quot; would be impossible - double &quot;g&quot; )<br><h4> Comment 37778142 Tanel Suurhans: </h4>Always use existing solutions like SecureRandom in favor of homegrown &quot;random&quot; solutions. Seriously, they are there for a reason.<br><h4> Comment 37792728 Kent Fredric: </h4>@TanelSuurhans As the OP of this answer I agree with all the sentiments regarding &quot;use proven tested tools&quot;. Just at the time of this answer, such tools were not core yet, and author appeared to have golfing as an objective.  Understanding how your language works is just as important as using tools written in the language.<br><h4> Comment 26805259 Dennis Krupenik: </h4>the last example should read  <code>(0...50).map { [(&#39;a&#39;..&#39;z&#39;),(&#39;A&#39;..&#39;Z&#39;)].flat_map(&amp;:to_a).sample }.join</code>  you definitely <i>have not</i> spent <i>too</i> much time golfing xD<br><h4> Comment 28551867 Vizjerai: </h4>further reduced from Dennis&#39;s answer <code>(0..50).map { [*&#39;a&#39;..&#39;z&#39;,*&#39;A&#39;..&#39;Z&#39;].sample }.join</code><br><h4> Comment 91704878 aidan: </h4>If golf is the objective, <code>(&#39;a&#39;..&#39;z&#39;)</code> is identical to <code>(?a..?z)</code>; two characters saved.<br><h4> Comment 14987101 fny: </h4>Touche @michaeltwofish. Here&#39;s the shortest and most performant one-liner I could muster: <code>[].fill(0,l){rand(65..90).chr}.join</code> (35 chars). <code>fill</code> is faster than <code>map</code>, but for real performance, drop the golf and prebuild the array with a <i>proper</i> use of <code>sample</code>: <code>chars=[&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;F&quot;, &quot;G&quot;, &quot;H&quot;, &quot;J&quot;, &quot;K&quot;, &quot;L&quot;, &quot;M&quot;, &quot;N&quot;, &quot;P&quot;, &quot;Q&quot;, &quot;R&quot;, &quot;S&quot;, &quot;T&quot;, &quot;U&quot;, &quot;V&quot;, &quot;W&quot;, &quot;X&quot;, &quot;Y&quot;, &quot;Z&quot;];[].fill(0,l){chars.sample}.join</code> That not even significantly faster for 8 characters. With 8 characters, no worries. Anything flies. ;)  See my <a href="http://goo.gl/cOu9G" rel="nofollow noreferrer">full benchmarks</a> for details.<br><h4> Comment 14524267 Alex Gaudio: </h4>first example should be rand(26) otherwise you never get the letter &#39;Z&#39;<br>------------------------------------------------------------------ <br><h3> Answer 1619602 christopherstyles: </h3><p>Why not use SecureRandom?</p>

<pre><code>require 'securerandom'
random_string = SecureRandom.hex

# outputs: 5b5cd0da3121fc53b4bc84d0c8af2e81 (i.e. 32 chars of 0..9, a..f)
</code></pre>

<p>SecureRandom also has methods for:</p>

<ul>
<li>base64</li>
<li>random_bytes</li>
<li>random_number</li>
</ul>

<p>see: <a href="http://ruby-doc.org/stdlib-1.9.2/libdoc/securerandom/rdoc/SecureRandom.html" rel="noreferrer">http://ruby-doc.org/stdlib-1.9.2/libdoc/securerandom/rdoc/SecureRandom.html</a></p>
<h4> Comment 6982662 J-_-L: </h4>By the way, it&#39;s part of the stdlib in 1.9 and recent 1.8 versions, so one can just <code>require &#39;securerandom&#39;</code> to get this neat <code>SecureRandom</code> helper :)<br><h4> Comment 11202086 Marc: </h4>BTW SecureRandom was removed from ActiveSupport in version 3.2. From the changelog: &quot;Removed ActiveSupport::SecureRandom in favor of SecureRandom from the standard library&quot;.<br><h4> Comment 35392122 Gerry Shaw: </h4><code>SecureRandom.random_number(36**12).to_s(36).rjust(12, &quot;0&quot;)</code> will generate a string with 0-9a-z (36 characters) that is ALWAYS 12 characters long.  Change 12 to whatever length you want.  Unfortunately no way to just get A-Z using <code>Integer#to_s</code>.<br><h4> Comment 5109943 Jeff Dickey: </h4>base64 would, but not hex like in his example<br><h4> Comment 46937290 nzifnab: </h4>@stringo0 that is wrong.  If you wanted to pass <code>+fGH1</code> through a URL, you just need to URL-encode it like you would ANY value that&#39;s going through a URL:  <code>%2BfGH1</code><br><h4> Comment 75088615 gogofan: </h4>I tried &#39;SecureRandom.random_number(9**6)&#39; but it sometimes returns 5 numbers but it sometimes returns 6 numbers.<br><h4> Comment 131752053 JakeRobb: </h4>@dcangulo hello from the future! üëãüèª The chances are low enough that you generally don&#39;t need to worry about it with something like <code>SecureRandom.hex</code>, but it&#39;s not impossible. If you&#39;re using this to generate unique IDs, use <code>SecureRandom.uuid</code>.<br><h4> Comment 136081903 user229044: </h4>@JakeRobb Err, <code>SecureRandom.uuid</code> is exactly as likely to generate duplicates as <code>SecureRandom.hex</code>. They are two different encodings for 128 random bits.<br><h4> Comment 136119954 JakeRobb: </h4>Right you are, thanks for the callout! I was thinking of Type 1 UUIDs, but this method generates a Type 4.<br><h4> Comment 3638968 stringo0: </h4>This generates strings that aren&#39;t safe for passing as get variables for websites - for example, you can get string=+fGH1 (+ is read as a space), and string=fyhi/ (the slash is used for navigation)<br><h4> Comment 11006649 Thomas: </h4>@JeffDickey no, thats wrong. <code>SecureRandom.base64 =&gt; &quot;7p0lfNClJwolM9BJcgG5lQ==&quot;</code> as you see, there are <code>=</code> in it. Method hex only returns <code>0-9a-f</code><br><h4> Comment 93262450 dcangulo: </h4>What are the chances of getting a duplicate?<br><h4> Comment 57990264 user1491929: </h4>To generate a string containing only 5 alpha characters you could do this <code>SecureRandom.hex.gsub(&#47;\d&#47;, &quot;&quot;)[0..4]</code><br><h4> Comment 75088541 gogofan: </h4>Hi, I like SecureRandom, but how do I get a string of 6 numbers, each digit with range 0-9. And I would like it in a way that it&#39;s easy to stub in my Rails controller spec.<br>------------------------------------------------------------------ <br><h3> Answer 3572953 Christoffer M&#246;ller: </h3><p>I use this for generating random URL friendly strings with a length between 1 and  <code>string_length</code> characters:</p>
<pre><code>string_length = 8
rand(36**string_length).to_s(36)
</code></pre>
<p>It generates random strings of lowercase a-z and 0-9. It's not very customizable but it's short and clean.</p>
<h4> Comment 8897422 Brian E: </h4>This is a great solution (and fast, too), but it will occasionally produce a string <i>under</i> <code>length</code> length, roughly once in ~40<br><h4> Comment 19804815 Adrien Rey-Jarthon: </h4>Here is the version always producing tokens of the desired length: <code>(36**(length-1) + rand(36**length - 36**(length-1))).to_s(36)</code><br><h4> Comment 9353579 Eric Hu: </h4>@Brian E this would guarantee the digits you want: <code>(36**(length-1) + rand(36**length)).to_s(36)</code>.  36**(length-1) converted to base 36 is 10**(length-1), which is the smallest value that has the digit length you want.<br><h4> Comment 5435141 Jo Liss: </h4>+1 for the shortest version (that doesn&#39;t call external binaries ^^).  If the random string isn&#39;t public facing, I sometimes even just use <code>rand.to_s</code>; ugly, but works.<br><h4> Comment 42410087 kakubei: </h4>This spits out an error for me in Rails 4 and Ruby 2.1.1: <code>NameError: undefined local variable or method </code>length&#39; for main:Object`<br><h4> Comment 63890141 user1115652: </h4>This will give you an exact length: <code>Random.new.rand( 36**(length-1) ... 36**length ).to_s( 36 )</code><br><h4> Comment 19804791 Adrien Rey-Jarthon: </h4>@EricHu You&#39;re solution also produce tokens longer than <code>length</code>.<br><h4> Comment 37611661 justcode: </h4>@BigBourin Your solution doesnt always produce tokens of desired length<br><h4> Comment 34027797 Max Williams: </h4>Yep, +1 for brevity and lack of dependencies.<br><h4> Comment 63891739 user1115652: </h4>If you need speed and exact length, you can also use this, which runs about 20x faster than the one in my last comment: <code>( rand * (36**length - 36**(length-1) ) + 36**(length-1) ).floor.to_s( 36 )</code>. It&#39;s not as readable though, so I would put it in a function. Probably the simplest would be to generate something that is guaranteed to be to long, and then truncate it.<br><h4> Comment 71087093 Jan Klimo: </h4>I&#39;m using this to generate 6 char tokens in a very simple way: <code>rand(36**11).to_s(36).upcase[0,6]</code> i.e. just make the original string safely long enough and then take any N chars from it<br><h4> Comment 136078469 user229044: </h4>@JanKlimo That&#39;s just wrong though. <code>rand(36**11).to_s(36)</code> may return a string with only 1 character.  There are ways of doing this that are provably correct and will work 100% of the time, and there is your way, which may randomly produce fewer digits than is required. Don&#39;t do that. Don&#39;t write code that is probabilistically correct, when <i>guaranteed</i> correct is so trivial.<br>------------------------------------------------------------------ <br><h3> Answer 493230 ImNotQuiteJack: </h3><p>This solution generates a string of easily readable characters for activation codes; I didn't want people confusing 8 with B, 1 with I, 0 with O, L with 1, etc.</p>

<pre><code># Generates a random string from a set of easily readable characters
def generate_activation_code(size = 6)
  charset = %w{ 2 3 4 6 7 9 A C D E F G H J K M N P Q R T V W X Y Z}
  (0...size).map{ charset.to_a[rand(charset.size)] }.join
end
</code></pre>
<h4> Comment 26442659 colinm: </h4>@gtd - Yep. U and V are ambigvovs.<br><h4> Comment 28575021 gtd: </h4>To be secure you would also want to use <code>SecureRandom.random_number(charset.size)</code> instead of <code>rand(charset.size)</code><br><h4> Comment 12030608 gtd: </h4>Is &#39;U&#39; ambiguous or is that a typo?<br><h4> Comment 41430580 dkniffin: </h4>I was just trying to improve on this, by adding lower case and/or some special characters (shift+num), and got the following lists: <code>%w{ A C D E F G H J K L M N P Q R T W X Y Z 2 3 4 6 7 9 ! @ # $ % ^ &amp; * +}</code> and <code>%w{ A D E F G H J L N Q R T Y a d e f h n r y 2 3 4 7 ! @ # $ % ^ &amp; * }</code> (first list doesn&#39;t include lower case, but it&#39;s longer) Kinda interesting how that worked out.<br><h4> Comment 26442971 gtd: </h4>@colinm V&#39;s in there though.<br><h4> Comment 9828096 Tom Corelis: </h4>Couldn&#39;t you just use <code>charset.sample</code> instead of <code>charset.to_a[rand(charset.size)</code>?<br><h4> Comment 12030524 gtd: </h4>@Tom, if you are using Ruby 1.9 or Rails then yes.  Plain 1.8.7 then no.<br>------------------------------------------------------------------ <br><h3> Answer 48521297 Markus: </h3><p>Since Ruby 2.5, it's really easy with <code>SecureRandom.alphanumeric</code>:</p>

<pre><code>len = 8
SecureRandom.alphanumeric(len)
=&gt; "larHSsgL"
</code></pre>

<p>It generates random strings containing A-Z, a-z and 0-9 and therefore should be applicable in most use-cases. And they are generated randomly secure, which might be a benefit, too.</p>

<hr>

<p>This is a benchmark to compare it with the solution having the most upvotes:</p>

<pre><code>require 'benchmark'
require 'securerandom'

len = 10
n = 100_000

Benchmark.bm(12) do |x|
  x.report('SecureRandom') { n.times { SecureRandom.alphanumeric(len) } }
  x.report('rand') do
    o = [('a'..'z'), ('A'..'Z'), (0..9)].map(&amp;:to_a).flatten
    n.times { (0...len).map { o[rand(o.length)] }.join }
  end
end
</code></pre>

<hr>

<pre><code>                   user     system      total        real
SecureRandom   0.429442   0.002746   0.432188 (  0.432705)
rand           0.306650   0.000716   0.307366 (  0.307745)
</code></pre>

<p>So the <code>rand</code> solution only takes about 3/4 of the time of <code>SecureRandom</code>. That might matter if you generate a lot of strings, but if you just create some random string from time to time I'd always go with the more secure implementation since it is also easier to call and more explicit.</p>
<h4> Comment 122420730 cozyconemotel: </h4>Now we need a similar solution for 0-z (without the uppercase characters). SecureRandom doesn&#39;t seem to provide that out of the box.<br>------------------------------------------------------------------ <br><h3> Answer 7222962 Travis Reeder: </h3><p>Others have mentioned something similar, but this uses the  URL safe function.</p>

<pre><code>require 'securerandom'
p SecureRandom.urlsafe_base64(5) #=&gt; "UtM7aa8"
p SecureRandom.urlsafe_base64 #=&gt; "UZLdOkzop70Ddx-IJR0ABg"
p SecureRandom.urlsafe_base64(nil, true) #=&gt; "i0XQ-7gglIsHGV2_BNPrdQ=="
</code></pre>

<p>The result may contain A-Z, a-z, 0-9, ‚Äú-‚Äù and ‚Äú_‚Äù. ‚Äú=‚Äù is also used if padding is true.</p>
------------------------------------------------------------------ <br><h3> Answer 8730431 Shai Coleman: </h3><pre><code>[*('A'..'Z')].sample(8).join
</code></pre>

<p>Generate a random 8 letter string (e.g. NVAYXHGR)</p>

<pre><code>([*('A'..'Z'),*('0'..'9')]-%w(0 1 I O)).sample(8).join
</code></pre>

<p>Generate a random 8 character string (e.g. 3PH4SWF2), excludes 0/1/I/O. Ruby 1.9</p>
<h4> Comment 13467465 tybro0103: </h4>Only problem is each character in the result is unique. Limits the possible values.<br><h4> Comment 14721028 David J.: </h4>If this <a href="http://www.ruby-forum.com/topic/822646" rel="nofollow noreferrer">feature request</a> goes through, Ruby 1.9.x may end up with #sample for sampling without replacment and #choice for sampling with replacement.<br><h4> Comment 57761766 jayunit100: </h4>This is an error, i think you need ... <code>[*(&quot;A&quot;..&quot;Z&quot;)]&#39;</code> ; ((not single qoutes))<br><h4> Comment 64527100 Sinscary: </h4>can you tell me how i can <code>stub</code> this for <code>rspec</code> to pass.<br>------------------------------------------------------------------ <br><h3> Answer 1117003 Travis Reeder: </h3><p>I can't remember where I found this, but it seems like the best and the least process intensive to me:</p>

<pre><code>def random_string(length=10)
  chars = 'abcdefghjkmnpqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ0123456789'
  password = ''
  length.times { password &lt;&lt; chars[rand(chars.size)] }
  password
end
</code></pre>
<h4> Comment 5335330 deadwards: </h4>Perhaps you found it here? <a href="http://travisonrails.com/2007/06/07/generate-random-text-with-ruby" rel="nofollow noreferrer">travisonrails.com/2007/06/07/generate-random-text-with-ruby</a><br><h4> Comment 32266641 Andrew: </h4>The <code>0</code> and <code>1</code> and <code>O</code> and <code>I</code> were intentionally missing because those characters are ambiguous. If this sort of code is being used to generate a set of characters that a user needs to copy, it&#39;s best to exclude characters that may be difficult to distinguish out of context.<br><h4> Comment 21863398 sunnyrjuneja: </h4>Isn&#39;t there a 0 and 1 missing from this?<br><h4> Comment 21887654 Travis Reeder: </h4>Looks like that could be where I found it.<br><h4> Comment 21887664 Travis Reeder: </h4>And ya, it does look like 0 and 1 are missing.<br>------------------------------------------------------------------ <br><h3> Answer 11462624 LENZCOM: </h3><pre><code>require 'securerandom'
SecureRandom.urlsafe_base64(9)
</code></pre>
<h4> Comment 16839985 tardate: </h4>btw, urlsafe_base64 returns a string about 4/3 the length indicated. To get a string exactly n chars long, try <code>n=9 ; SecureRandom.urlsafe_base64(n)[0..n-1]</code><br><h4> Comment 16839514 tardate: </h4>old skool (and uglier) alternative: <code>Random.new.bytes(9)</code><br>------------------------------------------------------------------ <br><h3> Answer 17596273 Srikanta Mahapatro: </h3><p>If you want a string of specified length, use:</p>

<pre><code>require 'securerandom'
randomstring = SecureRandom.hex(n)
</code></pre>

<p>It will generate a random string of length <code>2n</code> containing <code>0-9</code> and <code>a-f</code></p>
<h4> Comment 60131690 Omar Ali: </h4>It doesn&#39;t generate a string of length <code>n</code>, it actually generates a string that&#39;s 4/3 of <code>n</code>.<br><h4> Comment 106385206 Rihards: </h4>@OmarAli you&#39;re wrong. As per Ruby documentation in case of <code>.hex</code> it&#39;s 2n. Documentation: SecureRandom.hex generates a random hexadecimal string. The argument <i>n</i> specifies the length, in bytes, of the random number to be generated. The length of the resulting hexadecimal string is twice of <i>n</i>.<br>------------------------------------------------------------------ <br><h3> Answer 26107751 gr8scott06: </h3><p><code>Array.new(n){[*"0".."9"].sample}.join</code>,
where <code>n=8</code> in your case.</p>

<p>Generalized: <code>Array.new(n){[*"A".."Z", *"0".."9"].sample}.join</code>, etc. </p>

<p>From: "<a href="https://stackoverflow.com/questions/26076011/rails-generate-pseudo-random-string-a-z-0-9/26076063#26076063">Generate pseudo random string A-Z, 0-9</a>".</p>
------------------------------------------------------------------ <br><h3> Answer 6412228 Nathan Long: </h3><p>I think this is a nice balance of conciseness, clarity and ease of modification.</p>
<pre><code>characters = ('a'..'z').to_a + ('A'..'Z').to_a
# Prior to 1.9, use .choice, not .sample
(0..8).map{characters.sample}.join
</code></pre>
<h3>Easily modified</h3>
<p>For example, including digits:</p>
<pre><code>characters = ('a'..'z').to_a + ('A'..'Z').to_a + (0..9).to_a
</code></pre>
<p>Uppercase hexadecimal:</p>
<pre><code>characters = ('A'..'F').to_a + (0..9).to_a
</code></pre>
<p>For a truly impressive array of characters:</p>
<pre><code>characters = (32..126).to_a.pack('U*').chars.to_a
</code></pre>
<h4> Comment 37732737 luster: </h4>i would recommend this to just use capital letters + numbers, also remove the &quot;confusing&quot; ones         charset = (1..9).to_a.concat((&#39;A&#39;..&#39;Z&#39;).to_a).reject{ |a| [0, 1, &#39;O&#39;, &#39;I&#39;].include?(a) }         (0...size).map{ charset[rand(charset.size)] }.join<br>------------------------------------------------------------------ <br><h3> Answer 88422 Coren: </h3><pre><code>require 'sha1'
srand
seed = "--#{rand(10000)}--#{Time.now}--"
Digest::SHA1.hexdigest(seed)[0,8]
</code></pre>
<h4> Comment 12617 webmat: </h4>Keep in mind that a hex digest returns only 0-9 and a-f characters.<br><h4> Comment 12249 Jeff: </h4>Interesting, but quite a bit more computationally expensive<br><h4> Comment 12262 Kent Fredric: </h4>Also no capacity for limited scope of characters.<br>------------------------------------------------------------------ <br><h3> Answer 3326909 Ragmaanir: </h3><p>Ruby 1.9+:</p>

<pre><code>ALPHABET = ('a'..'z').to_a
#=&gt; ["a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z"]

10.times.map { ALPHABET.sample }.join
#=&gt; "stkbssowre"

# or

10.times.inject('') { |s| s + ALPHABET.sample }
#=&gt; "fdgvacnxhc"
</code></pre>
<h4> Comment 4792498 Misha Moroshko: </h4>The <code>map</code> solution is really nice!<br><h4> Comment 81777104 odlp: </h4>You can ask <code>#sample</code> for how many elements you want. E.g. <code>ALPHABET.sample(10).join</code>... <a href="https://ruby-doc.org/core-2.4.0/Array.html#method-i-sample" rel="nofollow noreferrer">ruby-doc.org/core-2.4.0/Array.html#method-i-sample</a><br><h4> Comment 84342299 Sa≈°a Zejniloviƒá: </h4>That is actually wrong. <code>sample(10)</code> gives you 10 unique samples. But you want to allow them to repeat.   But I would use <code>Array.new(10).map</code> for performance<br><h4> Comment 86627244 taylorthurlow: </h4>I wanted alphanumeric with both lower and upper cases. I&#39;ve also switched to use <code>Array.new</code> and its block syntax.  <code>Array.new(20) { [*&#39;0&#39;..&#39;9&#39;, *&#39;a&#39;..&#39;z&#39;, *&#39;A&#39;..&#39;Z&#39;].sample }.join</code><br>------------------------------------------------------------------ <br><h3> Answer 27010181 Awais: </h3><p>Here is one line simple code for random string with length 8:</p>

<pre><code> random_string = ('0'..'z').to_a.shuffle.first(8).join
</code></pre>

<p>You can also use it for random password having length 8:</p>

<pre><code>random_password = ('0'..'z').to_a.shuffle.first(8).join
</code></pre>
<h4> Comment 76931824 Benjamin Carlsson: </h4>You should not use this to generate yourself a password, as this method will never repeat a character. Therefore you&#39;re only using <code>P(36, 8) &#47; 36^8 = 0.4</code> of the possible character space for 8 characters (~2x easier to brute force) or <code>P(36, 25) &#47; 36^25 = 0.00001</code> of the possible character space for 25 characters (~100,000x easier to brute force).<br>------------------------------------------------------------------ <br><h3> Answer 2031464 user163365: </h3><p>Another method I like to use:</p>

<pre><code> rand(2**256).to_s(36)[0..7]
</code></pre>

<p>Add <code>ljust</code> if you are really paranoid about the correct string length:</p>

<pre><code> rand(2**256).to_s(36).ljust(8,'a')[0..7]
</code></pre>
<h4> Comment 11019097 Jeff: </h4>Even better to grab the least significant part of the random number by using the right hand side of the string: rand(2**64).to_s(36)[-10,10]<br>------------------------------------------------------------------ <br><h3> Answer 15719632 pencil: </h3><p>Be aware: <code>rand</code> is predictable for an attacker and therefore probably insecure. You should definitely use SecureRandom if this is for generating passwords. I use something like this:</p>

<pre><code>length = 10
characters = ('A'..'Z').to_a + ('a'..'z').to_a + ('0'..'9').to_a

password = SecureRandom.random_bytes(length).each_char.map do |char|
  characters[(char.ord % characters.length)]
end.join
</code></pre>
<h4> Comment 71715486 Breedly: </h4>This is probably the &quot;most&quot; secure solution. SecureRandom attempts to use underlying security APIs provided by the operating system. If you have OpenSSL it will use that, if you&#39;re on Windows it will go the best option there.  I especially like this solution because it allows you to specify a set of characters for use. Though it won&#39;t work if your character set is longer than the maximum value of a byte: 255.  I recommend viewing the source code for SecureRandom in the doc:  <a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/securerandom/rdoc/SecureRandom.html#method-c-random_bytes" rel="nofollow noreferrer">ruby-doc.org/stdlib-1.9.3/libdoc/securerandom/rdoc/&hellip;</a><br>------------------------------------------------------------------ <br><h3> Answer 10220012 Teej: </h3><pre><code>SecureRandom.base64(15).tr('+/=lIO0', 'pqrsxyz')
</code></pre>

<p>Something from Devise</p>
<h4> Comment 27543060 miguelcobain: </h4>Why is it replacing string characters using <code>.tr(&#39;+&#47;=lIO0&#39;, &#39;pqrsxyz&#39;)</code>?<br><h4> Comment 29417885 RobDil: </h4>The special characters because they are not URL safe. And l/I or O/0 because they are very easy confused if you use the technique to generate readable user passwords.<br><h4> Comment 42640030 Shai Coleman: </h4>That function has a bit of bias towards certain characters. Also for other lengths (e.g. 16), the last character will not be random. Here&#39;s a way to avoid that.      SecureRandom.base64(64).tr(&#39;+/=lIO01&#39;, &#39;&#39;)[0,16]<br>------------------------------------------------------------------ <br><h3> Answer 12890596 Thaha kp: </h3><p>Here is one simple code for random password with length 8:</p>

<pre><code>rand_password=('0'..'z').to_a.shuffle.first(8).join
</code></pre>
------------------------------------------------------------------ <br><h3> Answer 10773250 pdu: </h3><p>Just adding my cents here...</p>

<pre><code>def random_string(length = 8)
  rand(32**length).to_s(32)
end
</code></pre>
<h4> Comment 16839462 tardate: </h4>NB: this doesn&#39;t always return a string exactly +length+ long - it may be shorter. It depends on the the number returned by <code>rand</code><br>------------------------------------------------------------------ <br><h3> Answer 25456667 Tilo: </h3><p>You can use <a href="https://github.com/rubyworks/facets/blob/126a619fd766bc45588cac18d09c4f1927538e33/lib/core/facets/string/random.rb" rel="nofollow noreferrer"><code>String#random</code></a> from the Facets of Ruby Gem <code>facets</code>.</p>

<p>It basically does this:</p>

<pre><code>class String
  def self.random(len=32, character_set = ["A".."Z", "a".."z", "0".."9"])
    characters = character_set.map { |i| i.to_a }.flatten
    characters_len = characters.length
    (0...len).map{ characters[rand(characters_len)] }.join
  end
end
</code></pre>
------------------------------------------------------------------ <br><h3> Answer 3431889 erik: </h3><p>I was doing something like this recently to generate an 8 byte random string from 62 characters.  The characters were 0-9,a-z,A-Z.  I had an array of them as was looping 8 times and picking a random value out of the array.  This was inside a Rails app.</p>

<pre><code>str = ''
8.times {|i| str &lt;&lt; ARRAY_OF_POSSIBLE_VALUES[rand(SIZE_OF_ARRAY_OF_POSSIBLE_VALUES)] }
</code></pre>

<p>The weird thing is that I got good number of duplicates.  Now randomly this should pretty much never happen.  62^8 is huge, but out of 1200 or so codes in the db i had a good number of duplicates.  I noticed them happening on hour boundaries of each other. In other words I might see a duple at 12:12:23 and 2:12:22 or something like that...not sure if time is the issue or not.</p>

<p>This code was in the before create of an ActiveRecord object.   Before the record was created this code would run and generate the 'unique' code.  Entries in the DB were always produced reliably, but the code (<code>str</code> in the above line) was being duplicated much too often.</p>

<p>I created a script to run through 100000 iterations of this above line with small delay so it would take 3-4 hours hoping to see some kind of repeat pattern on an hourly basis, but saw nothing.  I have no idea why this was happening in my Rails app.</p>
------------------------------------------------------------------ <br><h3> Answer 5735905 Tim James: </h3><p>Given:</p>

<pre><code>chars = [*('a'..'z'),*('0'..'9')].flatten
</code></pre>

<p>Single expression, can be passed as an argument, allows duplicate characters:</p>

<pre><code>Array.new(len) { chars.sample }.join
</code></pre>
------------------------------------------------------------------ <br><h3> Answer 89042 Ryan Bigg: </h3><p>With this method you can pass in an abitrary length. It's set as a default as 6.</p>

<pre><code>def generate_random_string(length=6)
  string = ""
  chars = ("A".."Z").to_a
  length.times do
    string &lt;&lt; chars[rand(chars.length-1)]
  end
  string
end
</code></pre>
------------------------------------------------------------------ <br><h3> Answer 89514 webmat: </h3><p>I like Radar's answer best, so far, I think. I'd tweak a bit like this:</p>

<pre><code>CHARS = ('a'..'z').to_a + ('A'..'Z').to_a
def rand_string(length=8)
  s=''
  length.times{ s &lt;&lt; CHARS[rand(CHARS.length)] }
  s
end
</code></pre>
<h4> Comment 24950109 niels: </h4>Why not use <code>(CHARS*length).sample(length).join</code>?<br><h4> Comment 82609985 Tom Lord: </h4>@niels This suggestion would generate a <i>weighted</i> string, in favour of non-repeated characters. For example, if <code>CHARS=[&#39;a&#39;,&#39;b&#39;]</code> then your method would generate <code>&quot;aa&quot;</code> or <code>&quot;bb&quot;</code> only 33% of the time, but <code>&quot;ab&quot;</code> or <code>&quot;ba&quot;</code> 67% of the time. Maybe that&#39;s not a problem, but it&#39;s worth bearing in mind!<br><h4> Comment 82756926 niels: </h4>good point, @TomLord, I think I didn&#39;t actually realise that when I posted that suggestion (although I must admit I don&#39;t remember posting that at all :D)<br>------------------------------------------------------------------ <br><h3> Answer 9234645 peter: </h3><p>2 solutions for a random string consisting of 3 ranges:</p>

<pre><code>(('a'..'z').to_a + ('A'..'Z').to_a + (0..9).to_a).sample(8).join

([*(48..57),*(65..90),*(97..122)]).sample(8).collect(&amp;:chr)*""
</code></pre>

<h3>One Character from each Range.</h3>

<p>And if you need at least one character from each range, such as creating a random password that has one uppercase, one lowercase letter and one digit, you can do something like this: </p>

<pre><code>( ('a'..'z').to_a.sample(8) + ('A'..'Z').to_a.sample(8) + (0..9).to_a.sample(8) ).shuffle.join 
#=&gt; "Kc5zOGtM0H796QgPp8u2Sxo1"
</code></pre>
<h4> Comment 101660261 Joshua Pinter: </h4>And if you want to enforce a certain number of each range, you could do something like this: <code>( (&#39;a&#39;..&#39;z&#39;).to_a.sample(8) + (&#39;A&#39;..&#39;Z&#39;).to_a.sample(8) + (0..9).to_a.sample(8) + [ &quot;%&quot;, &quot;!&quot;, &quot;*&quot; ].sample(8) ).shuffle.join #=&gt; &quot;Kc5zOGtM0*H796QgPp%!8u2Sxo1&quot;</code><br>------------------------------------------------------------------ <br><h3> Answer 10434882 tybro0103: </h3><p>My 2 cents:</p>

<pre><code>  def token(length=16)
    chars = [*('A'..'Z'), *('a'..'z'), *(0..9)]
    (0..length).map {chars.sample}.join
  end
</code></pre>
------------------------------------------------------------------ <br><h3> Answer 20272585 Josh: </h3><p>My favorite is <code>(:A..:Z).to_a.shuffle[0,8].join</code>.  Note that shuffle requires Ruby > 1.9.</p>
------------------------------------------------------------------ <br><h3> Answer 25358706 lzap: </h3><p>Another trick that works with Ruby 1.8+ and is fast is:</p>

<pre><code>&gt;&gt; require "openssl"
&gt;&gt; OpenSSL::Random.random_bytes(20).unpack('H*').join
=&gt; "2f3ff53dd712ba2303a573d9f9a8c1dbc1942d28"
</code></pre>

<p>It get's you random hex string. Similar way you should be able to generate base64 string ('M*').</p>
------------------------------------------------------------------ <br><h3> Answer 88470 Carlos Villela: </h3><p>We've been using this on our code:</p>

<pre><code>class String

  def self.random(length=10)
    ('a'..'z').sort_by {rand}[0,length].join
  end

end
</code></pre>

<p>The maximum length supported is 25 (we're only using it with the default anyway, so hasn't been a problem).</p>

<p>Someone mentioned that 'a'..'z' is suboptimal if you want to completely avoid generating offensive words. One of the ideas we had was removing vowels, but you still end up with WTFBBQ etc.</p>
<h4> Comment 21148 Jeff: </h4>Yes, I suppose that technically isn&#39;t really a random string anymore, good find webmat.<br><h4> Comment 12646 webmat: </h4>Your approach can&#39;t return repeating characters (e.g, uuunMoBldj)... Is this what&#39;s wanted?<br>------------------------------------------------------------------ <br><h3> Answer 7173336 Evgenii: </h3><p>Here is another method:</p>

<ul>
<li>It uses the secure random number generator instead of rand()</li>
<li>Can be used in URLs and file names</li>
<li>Contains uppercase, lowercase characters and numbers</li>
<li>Has an option not to include ambiguous characters I0l01</li>
</ul>

<p>Needs <code>require "securerandom"</code></p>

<pre><code>def secure_random_string(length = 32, non_ambiguous = false)
  characters = ('a'..'z').to_a + ('A'..'Z').to_a + ('0'..'9').to_a

  %w{I O l 0 1}.each{ |ambiguous_character| 
    characters.delete ambiguous_character 
  } if non_ambiguous

  (0...length).map{
    characters[ActiveSupport::SecureRandom.random_number(characters.size)]
  }.join
end
</code></pre>
------------------------------------------------------------------ <br><h3> Answer 7653318 eric: </h3><pre><code>''.tap {|v| 4.times { v &lt;&lt; ('a'..'z').to_a.sample} }
</code></pre>
------------------------------------------------------------------ <br><h3> Answer 51750404 Lucas Andrade: </h3><p>Here is a improve of @Travis R answer:</p>

<pre><code> def random_string(length=5)
    chars = 'abdefghjkmnpqrstuvwxyzABDEFGHJKLMNPQRSTUVWXYZ'
    numbers = '0123456789'
    random_s = ''
    (length/2).times { random_s &lt;&lt; numbers[rand(numbers.size)] }
    (length - random_s.length).times { random_s &lt;&lt; chars[rand(chars.size)] }
    random_s.split('').shuffle.join
  end
</code></pre>

<p>At @Travis R answer chars and numbers were together, so sometimes <code>random_string</code> could return only numbers or only characters. With this improve at least half of <code>random_string</code> will be characters and the rest are numbers. Just in case if you need a random string with numbers and characters</p>
------------------------------------------------------------------ <br><h3> Answer 5073878 Manuel A. Guilamo: </h3><p>try this out</p>

<pre><code>def rand_name(len=9)
  ary = [('0'..'9').to_a, ('a'..'z').to_a, ('A'..'Z').to_a]
  name = ''

  len.times do
    name &lt;&lt; ary.choice.choice
  end
  name
end
</code></pre>

<p>I love the answers of the thread, have been very helpful, indeed!, but if I may say, none of them satisfies my ayes, maybe is the rand() method. it's just doesn't seems right to me, since we've got the Array#choice method for that matter.</p>
<h4> Comment 136078635 user229044: </h4><code>ar = [(&#39;0&#39;..&#39;9&#39;).to_a, (&#39;a&#39;..&#39;z&#39;).to_a, (&#39;A&#39;..&#39;Z&#39;).to_a].flatten; 10.times.map { ar.choice }.join</code><br>------------------------------------------------------------------ <br><h3> Answer 10292347 Chris Bloom: </h3><p>This is based on a few other answers, but it adds a bit more complexity:</p>

<pre><code>def random_password
  specials = ((32..47).to_a + (58..64).to_a + (91..96).to_a + (123..126).to_a).pack('U*').chars.to_a
  numbers  = (0..9).to_a
  alpha    = ('a'..'z').to_a + ('A'..'Z').to_a
  %w{i I l L 1 O o 0}.each{ |ambiguous_character| 
    alpha.delete ambiguous_character 
  }
  characters = (alpha + specials + numbers)
  password = Random.new.rand(8..18).times.map{characters.sample}
  password &lt;&lt; specials.sample unless password.join =~ Regexp.new(Regexp.escape(specials.join))
  password &lt;&lt; numbers.sample  unless password.join =~ Regexp.new(Regexp.escape(numbers.join))
  password.shuffle.join
end
</code></pre>

<p>Essentially it ensures a password that is 8 - 20 characters in length, and which contains at least one number and one special character.</p>
------------------------------------------------------------------ <br><h3> Answer 11313001 lzap: </h3><p>If you are on a UNIX and you still must use Ruby 1.8 (no SecureRandom) without Rails, you can also use this:</p>

<pre><code>random_string = `openssl rand -base64 24`
</code></pre>

<p>Note this spawns new shell, this is very slow and it can only be recommended for scripts.</p>
------------------------------------------------------------------ <br><h3> Answer 37333123 shiva kumar: </h3><p>For devise secure_validatable you can use this</p>
<pre class="lang-rb prettyprint-override"><code>(0...8).map { ([65, 97].sample + rand(26)).chr }.push(rand(99)).join
</code></pre>
<h4> Comment 64545467 Kyle Tolle: </h4>To generate a random password using uppercase, lowercase, numbers, and special characters, I used something like:  <code>random_ascii_character = -&gt; { (33..126).to_a.sample.chr }; 8.times.map { random_ascii_character.call }.shuffle.join</code><br>------------------------------------------------------------------ <br><h3> Answer 88338 easeout: </h3><p>To make your first into one statement:</p>

<pre><code>(0...8).collect { |n| value  &lt;&lt; (65 + rand(25)).chr }.join()
</code></pre>
------------------------------------------------------------------ <br><h3> Answer 15789933 Simptive: </h3><p>Create an empty string or a pre-fix if require:</p>

<pre><code>myStr = "OID-"
</code></pre>

<p>Use this code to populate the string with random numbers:</p>

<pre><code>begin; n = ((rand * 43) + 47).ceil; myStr &lt;&lt; n.chr if !(58..64).include?(n); end while(myStr.length &lt; 12)
</code></pre>

<p>Notes:</p>

<pre><code>(rand * 43) + 47).ceil
</code></pre>

<p>It will generate random numbers from 48-91 (0,1,2..Y,Z)</p>

<pre><code>!(58..64).include?(n)
</code></pre>

<p>It is used to skip special characters (as I am not interested to include them)</p>

<pre><code>while(myStr.length &lt; 12)
</code></pre>

<p>It will generate total 12 characters long string including prefix.</p>

<p>Sample Output:</p>

<pre><code>"OID-XZ2J32XM"
</code></pre>
------------------------------------------------------------------ <br><h3> Answer 17949884 Abdo: </h3><p>Here's a solution that is flexible and allows dups:</p>

<pre><code>class String
  # generate a random string of length n using current string as the source of characters
  def random(n)
    return "" if n &lt;= 0
    (chars * (n / length + 1)).shuffle[0..n-1].join  
  end
end
</code></pre>

<p>Example:</p>

<pre><code>"ATCG".random(8) =&gt; "CGTGAAGA"
</code></pre>

<p>You can also allow a certain character to appear more frequently:</p>

<pre><code>"AAAAATCG".random(10) =&gt; "CTGAAAAAGC"
</code></pre>

<p>Explanation:
The method above takes the chars of a given string and generates a big enough array. It then shuffles it, takes the first n items, then joins them.</p>
------------------------------------------------------------------ <br><h3> Answer 23310810 Automatico: </h3><pre><code>Array.new(8).inject(""){|r|r&lt;&lt;('0'..'z').to_a.shuffle[0]}  # 57
(1..8).inject(""){|r|r&lt;&lt;('0'..'z').to_a.shuffle[0]}        # 51
e="";8.times{e&lt;&lt;('0'..'z').to_a.shuffle[0]};e              # 45
(1..8).map{('0'..'z').to_a.shuffle[0]}.join                # 43
(1..8).map{rand(49..122).chr}.join                         # 34
</code></pre>
------------------------------------------------------------------ <br><h3> Answer 35601419 DDD: </h3><pre><code>10.times do 
  alphabet = ('a'..'z').to_a
  string += alpha[rand(alpha.length)]
end
</code></pre>
------------------------------------------------------------------ <br><h3> Answer 39246466 Minski: </h3><pre><code>a='';8.times{a&lt;&lt;[*'a'..'z'].sample};p a
</code></pre>

<p>or</p>

<pre><code>8.times.collect{[*'a'..'z'].sample}.join
</code></pre>
------------------------------------------------------------------ <br><h3> Answer 88371 Purfideas: </h3><p>This is almost as ugly but perhaps as step in right direction?</p>

<pre><code> (1..8).map{|i| ('a'..'z').to_a[rand(26)]}.join
</code></pre>
<h4> Comment 12224 Purfideas: </h4>:) I actually love the fastest gun in a perverse way<br>------------------------------------------------------------------ <br><h3> Answer 1157293 maykeye: </h3><p>In ruby 1.9 one can use Array's choice method which returns random element from array</p>
<h4> Comment 1192735 Andrew Grimm: </h4>Thanks for the heads up - however, <a href="http://svn.ruby-lang.org/repos/ruby/tags/v1_9_1_0/NEWS" rel="nofollow noreferrer">svn.ruby-lang.org/repos/ruby/tags/v1_9_1_0/NEWS</a> seems to indicate that Array#sample is to be used in 1.9.1, not Array#choose / choice<br>