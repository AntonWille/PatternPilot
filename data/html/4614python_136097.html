 <h2> Title: What is the difference between @staticmethod and @classmethod in Python? </h2> <h4> Daryl Spitzer, question_id: 136097 </h4>Score: 4614, Tags: {python,oop,static-methods,python-decorators,class-method} <br><p>What is the difference between a method <a href="https://peps.python.org/pep-0318/" rel="noreferrer">decorated</a> with <a href="http://docs.python.org/library/functions.html#staticmethod" rel="noreferrer"><code>@staticmethod</code></a> and one decorated with <a href="http://docs.python.org/library/functions.html#classmethod" rel="noreferrer"><code>@classmethod</code></a>?</p>
<h4> Mr. Unnormalized Posterior, Id: 89555342 Score: 62: </h4>tl;dr &gt;&gt; when compared to normal methods, the static methods and class methods can also be accessed using the class but unlike class methods, static methods are immutable via inheritance.<br><h4> FistOfFury, Id: 82292014 Score: 25: </h4>static methods are sometimes better off as module level functions in python for the sake of cleanliness.  With a module function it is easier to import just the function you need and prevent unnecessary &quot;.&quot; syntax (I&#39;m looking at you Objective-C). class methods have more use since they can be used in combination with polymorphism to create &quot;factory pattern&quot; functions.  this is because class methods receive the class as an implicit parameter.<br><h4> moooeeeep, Id: 91457103 Score: 9: </h4>Related talk by Raymond Hettinger on the topic: <a href="https://www.youtube.com/watch?v=HTLu2DFOdTg" rel="nofollow noreferrer">youtube.com/watch?v=HTLu2DFOdTg</a><br>------------------------------------------------------------------ <br><h3> unutbu, Id: 1669524, Score: 3885: </h3><p>Maybe a bit of example code will help: Notice the difference in the call signatures of <code>foo</code>, <code>class_foo</code> and <code>static_foo</code>:</p>
<pre><code>class A(object):
    def foo(self, x):
        print(f&quot;executing foo({self}, {x})&quot;)

    @classmethod
    def class_foo(cls, x):
        print(f&quot;executing class_foo({cls}, {x})&quot;)

    @staticmethod
    def static_foo(x):
        print(f&quot;executing static_foo({x})&quot;)

a = A()
</code></pre>
<p>Below is the usual way an object instance calls a method. The object instance, <code>a</code>, is implicitly passed as the first argument.</p>
<pre><code>a.foo(1)
# executing foo(&lt;__main__.A object at 0xb7dbef0c&gt;, 1)
</code></pre>
<hr />
<p><strong>With classmethods</strong>, the class of the object instance is implicitly passed as the first argument instead of <code>self</code>.</p>
<pre><code>a.class_foo(1)
# executing class_foo(&lt;class '__main__.A'&gt;, 1)
</code></pre>
<p>You can also call <code>class_foo</code> using the class. In fact, if you define something to be
a classmethod, it is probably because you intend to call it from the class rather than from a class instance. <code>A.foo(1)</code> would have raised a TypeError, but <code>A.class_foo(1)</code> works just fine:</p>
<pre><code>A.class_foo(1)
# executing class_foo(&lt;class '__main__.A'&gt;, 1)
</code></pre>
<p>One use people have found for class methods is to create <a href="https://stackoverflow.com/a/1950927/190597">inheritable alternative constructors</a>.</p>
<hr />
<p><strong>With staticmethods</strong>, neither <code>self</code> (the object instance) nor  <code>cls</code> (the class) is implicitly passed as the first argument. They behave like plain functions except that you can call them from an instance or the class:</p>
<pre><code>a.static_foo(1)
# executing static_foo(1)

A.static_foo('hi')
# executing static_foo(hi)
</code></pre>
<p>Staticmethods are used to group functions which have some logical connection with a class to the class.</p>
<hr />
<p><code>foo</code> is just a function, but when you call <code>a.foo</code> you don't just get the function,
you get a &quot;partially applied&quot; version of the function with the object instance <code>a</code> bound as the first argument to the function. <code>foo</code> expects 2 arguments, while <code>a.foo</code> only expects 1 argument.</p>
<p><code>a</code> is bound to <code>foo</code>. That is what is meant by the term &quot;bound&quot; below:</p>
<pre><code>print(a.foo)
# &lt;bound method A.foo of &lt;__main__.A object at 0xb7d52f0c&gt;&gt;
</code></pre>
<p>With <code>a.class_foo</code>, <code>a</code> is not bound to <code>class_foo</code>, rather the class <code>A</code> is bound to <code>class_foo</code>.</p>
<pre><code>print(a.class_foo)
# &lt;bound method type.class_foo of &lt;class '__main__.A'&gt;&gt;
</code></pre>
<p>Here, with a staticmethod, even though it is a method, <code>a.static_foo</code> just returns
a good 'ole function with no arguments bound. <code>static_foo</code> expects 1 argument, and
<code>a.static_foo</code> expects 1 argument too.</p>
<pre><code>print(a.static_foo)
# &lt;function static_foo at 0xb7d479cc&gt;
</code></pre>
<p>And of course the same thing happens when you call <code>static_foo</code> with the class <code>A</code> instead.</p>
<pre><code>print(A.static_foo)
# &lt;function static_foo at 0xb7d479cc&gt;
</code></pre>
<h4> unutbu, Comment 9038195 Score: 501: </h4>@Alcott: You might want to move a function into a class because it logically belongs with the class. In the Python source code (e.g. multiprocessing,turtle,dist-packages), it is used to &quot;hide&quot; single-underscore &quot;private&quot; functions from the module namespace. Its use, though, is highly concentrated in just a few modules -- perhaps an indication that it is mainly a stylistic thing. Though I could not find any example of this, <code>@staticmethod</code> might help organize your code by being overridable by subclasses. Without it you&#39;d have variants of the function floating around in the module namespace.<br><h4> Alcott, Comment 9033735 Score: 250: </h4>I don&#39;t understand what&#39;s the catch for using staticmethod. we can just use a simple outside-of-class function.<br><h4> MestreLion, Comment 13459246 Score: 155: </h4>@Alcott: as unutbu said, static methods are an organization/stylistic feature. Sometimes a module have many classes, and some helper functions are logically tied to a a given class and not to the others, so it makes sense not to &quot;pollute&quot; the module with many &quot;free functions&quot;, and it is better to use a static method than relying on the poor style of mixing classes and function defs together in code just to show they are &quot;related&quot;<br><h4> Philip Couling, Comment 125154599 Score: 1: </h4>Of course the above responses to Alcott&#39;s comment also miss the obvious... you can override static methods and class methods in a child class.  At this point the distinction between classmethod and staticmethod become extremely important.  If one static method calls another static method, it should really be a class method calling <code>cls.some_static_method()</code> so that the child classes can replace the static easily.<br><h4> saolof, Comment 126552129 Score: 1: </h4>@Alcott  Staticmethod defines a function, but it does one more thing - it makes the function a class variable. If you happen to want to want a class variable that is a function (and not a method) and don&#39;t want to use the function for anything unrelated to the class, then staticmethod is the idiomatic way to do it.<br><h4> paperskilltrees, Comment 132984407 Score: 0: </h4>Could @unutbu please clarify if this answer still applies to Python 3? It is not completely clear, although I see the 3rd-party edit that added f-strings. A comment on what changed between Python 2 and 3 would also be appreciated!<br>------------------------------------------------------------------ <br><h3> Thomas Wouters, Id: 136138, Score: 952: </h3><p>A <strong>staticmethod</strong> is a method that knows nothing about the class or instance it was called on. It just gets the arguments that were passed, no implicit first argument.</p>
<p>A <strong>classmethod</strong>, on the other hand, is a method that gets passed the class it was called on, or the class of the instance it was called on, as first argument. This is useful when you want the method to be a factory for the class: since it gets the actual class it was called on as first argument, you can always instantiate the right class, even when subclasses are involved. Observe for instance how <code>dict.fromkeys()</code>, a classmethod, returns an instance of the subclass when called on a subclass:</p>
<pre><code>&gt;&gt;&gt; class DictSubclass(dict):
...     def __repr__(self):
...         return &quot;DictSubclass&quot;
... 
&gt;&gt;&gt; dict.fromkeys(&quot;abc&quot;)
{'a': None, 'c': None, 'b': None}
&gt;&gt;&gt; DictSubclass.fromkeys(&quot;abc&quot;)
DictSubclass
&gt;&gt;&gt; 
</code></pre>
<h4> Tony Meyer, Comment 36456 Score: 858: </h4>A staticmethod isn&#39;t useless - it&#39;s a way of putting a function into a class (because it logically belongs there), while indicating that it does not require access to the class.<br><h4> Thomas Wouters, Comment 37041 Score: 155: </h4>Hence only &#39;basically&#39; useless. Such organization, as well as dependency injection, are valid uses of staticmethods, but since modules, not classes like in Java, are the basic elements of code organization in Python, their use and usefulness is rare.<br><h4> haridsv, Comment 2605431 Score: 123: </h4>Perhaps for the inheritance sake? Static methods can be inherited and overridden just like instance methods and class methods and the lookup works as expected (unlike in Java). Static methods are not really resolved statically whether called on the class or instance, so the only difference between class and static methods is the implicit first argument.<br><h4> Imbrondir, Comment 8572255 Score: 101: </h4>They also create a cleaner namespace, and makes it easier to understand the function have something to do with the class.<br><h4> Ben James, Comment 2415805 Score: 48: </h4>What&#39;s logical about defining a method inside a class, when it has nothing to do with either the class or its instances?<br><h4> MestreLion, Comment 13458865 Score: 25: </h4>-1: This answer A) gives a very corner-case feature of class method as an explanation of its utility (so they are only useful when subclassing to allow you the name of the subclass, <i>really</i>?), and B) implies &quot;static methods should be module methods&quot;, which, although they semantically are, it makes a <i>lot</i> or sense to use them <i>if your module defines many classes, and a given helper function only applies to a given class</i>. So a very poor answer with lots of misconceptions imho.<br><h4> Ethan Furman, Comment 9867702 Score: 18: </h4>@BenJames:  A staticmethod should have something to do with the class its defined in, it just doesn&#39;t need either class nor instance data to do its job. (see <a href="http://stackoverflow.com/questions/7855237">stackoverflow.com/questions/7855237</a>)<br><h4> Adam Parkin, Comment 12090764 Score: 7: </h4>So which is better: having a Math <b>class</b> with methods like sin, cos, etc, or having a Math <b>module</b> with functions sin, cos, etc.  Seems to me that the latter would be preferable, so I&#39;m hard pressed to think of a possible case where staticmethod would be useful. Helper methods I suppose are a potential case, but if a helper is so general as to not need anything from the class or a class instance, you really do have to wonder if it would be better served as a utility routine in a library.<br><h4> Jonathan Livni, Comment 13007300 Score: 5: </h4>When you have a class instance its often simpler to call <code>inst.method()</code> rather than <code>module.method()</code>. Sometimes you don&#39;t even know which module you&#39;re using, Python <i>is</i> a dynamic language after all...<br><h4> VengaVenga, Comment 132157154 Score: 0: </h4>&gt; &quot;It is basically useless in Python&quot; This may not be politically correct but I would strongly recommend not to use <code>@classmethod</code> and  <code>@staticmethod</code> but just skip this information. Why? The beauty of Python (in contrast to Java or C) is that its code is very compact and the inventors of Python make a lot of implicit assumptions for you that make sense in 99% of cases. There may be good reasons for not adhering to this concept. But then its much better to look around for alternatives rather than over decorating Python code.<br>------------------------------------------------------------------ <br><h3> Terence Simpson, Id: 136149, Score: 194: </h3><p>Basically <code>@classmethod</code> makes a method whose first argument is the class it's called from (rather than the class instance), <code>@staticmethod</code> does not have any implicit arguments.</p>
<h4> c z, Comment 135605312 Score: 0: </h4>The other answers add unnecessary confusion to a simple answer. This is literally the only think that changes.<br>------------------------------------------------------------------ <br><h3> Du D., Id: 36798076, Score: 139: </h3><p>To decide whether to use <a href="https://docs.python.org/3/library/functions.html?highlight=staticmethod#staticmethod" rel="noreferrer">@staticmethod</a> or <a href="https://docs.python.org/3.5/library/functions.html?highlight=classmethod#classmethod" rel="noreferrer">@classmethod</a> you have to look inside your method. <strong>If your method accesses other variables/methods in your class then use @classmethod</strong>. On the other hand, if your method does not touches any other parts of the class then use @staticmethod.</p>
<pre><code>class Apple:

    _counter = 0

    @staticmethod
    def about_apple():
        print('Apple is good for you.')

        # note you can still access other member of the class
        # but you have to use the class instance 
        # which is not very nice, because you have repeat yourself
        # 
        # For example:
        # @staticmethod
        #    print('Number of apples have been juiced: %s' % Apple._counter)
        #
        # @classmethod
        #    print('Number of apples have been juiced: %s' % cls._counter)
        #
        #    @classmethod is especially useful when you move your function to another class,
        #       you don't have to rename the referenced class 

    @classmethod
    def make_apple_juice(cls, number_of_apples):
        print('Making juice:')
        for i in range(number_of_apples):
            cls._juice_this(i)

    @classmethod
    def _juice_this(cls, apple):
        print('Juicing apple %d...' % apple)
        cls._counter += 1
</code></pre>
<h4> apaderno, Comment 103932170 Score: 7: </h4><code>cls._counter</code> would still be <code>cls._counter</code> even if the code is put in a different class, or the class name is changed. <code>Apple._counter</code> is specific  for the <code>Apple</code> class; for a different class, or when the class name is changed, you would need to change the referenced class.<br><h4> Zachiah, Comment 131602313 Score: 0: </h4>I hope by &quot;move&quot; you don&#39;t mean &quot;copy&quot; lol<br><h4> Mehdi, Comment 133522068 Score: 0: </h4>why even bother with the decorator in that case, your description does not really clarify<br><h4> Robert Nowak, Comment 103034394 Score: 0: </h4>what would be the advantage of classmethod and cls._counter vs. staticmethod and Apple._counter<br>------------------------------------------------------------------ <br><h3> Chris B., Id: 1669579, Score: 128: </h3><p><strong>Official python docs:</strong></p>

<p><a href="http://docs.python.org/library/functions.html#classmethod" rel="noreferrer">@classmethod</a></p>

<blockquote>
  <p>A class method receives the class as
  implicit first argument, just like an
  instance method receives the instance.
  To declare a class method, use this
  idiom:</p>

<pre><code>class C:
    @classmethod
    def f(cls, arg1, arg2, ...): ... 
</code></pre>
  
  <p>The <code>@classmethod</code> form is a function
  <a href="http://docs.python.org/2/glossary.html#term-decorator" rel="noreferrer"><em>decorator</em></a> – see the description of
  function definitions in <a href="http://docs.python.org/2/reference/compound_stmts.html#function" rel="noreferrer"><em>Function
  definitions</em></a> for details.</p>
  
  <p>It can be called either on the class
  (such as <code>C.f()</code>) or on an instance
  (such as <code>C().f()</code>). The instance is
  ignored except for its class. If a
  class method is called for a derived
  class, the derived class object is
  passed as the implied first argument.</p>
  
  <p>Class methods are different than C++
  or Java static methods. If you want
  those, see <a href="http://docs.python.org/2/library/functions.html#staticmethod" rel="noreferrer"><code>staticmethod()</code></a> in this
  section.</p>
</blockquote>

<p><a href="http://docs.python.org/library/functions.html#staticmethod" rel="noreferrer">@staticmethod</a></p>

<blockquote>
  <p>A static method does not receive an
  implicit first argument. To declare a
  static method, use this idiom:</p>

<pre><code>class C:
    @staticmethod
    def f(arg1, arg2, ...): ... 
</code></pre>
  
  <p>The <code>@staticmethod</code> form is a function
  <a href="http://docs.python.org/2/glossary.html#term-decorator" rel="noreferrer"><em>decorator</em></a> – see the description of
  function definitions in <a href="http://docs.python.org/2/reference/compound_stmts.html#function" rel="noreferrer"><em>Function
  definitions</em></a> for details.</p>
  
  <p>It can be called either on the class
  (such as <code>C.f()</code>) or on an instance
  (such as <code>C().f()</code>). The instance is
  ignored except for its class.</p>
  
  <p>Static methods in Python are similar
  to those found in Java or C++. For a
  more advanced concept, see
  <a href="http://docs.python.org/2/library/functions.html#classmethod" rel="noreferrer"><code>classmethod()</code></a> in this section.</p>
</blockquote>
<h4> Aaron Bentley, Comment 109329459 Score: 0: </h4>It may be a cut-and-paste error, but strictly speaking you can&#39;t call a method on a class if you ignore the class.<br><h4> mirek, Comment 107014132 Score: 0: </h4>Isn&#39;t there an error in docs? Shouldn&#39;t be at staticmethod: &quot;The instance and its class are both ignored.&quot; instead of &quot;The instance is ignored except for its class.&quot;?<br><h4> Hamidreza Hosseinkhani, Comment 131881233 Score: 0: </h4>You are wrong! &quot;static members&quot; in Java are equivalent to &quot;class members&quot; in Python (the difference is in Java you can access a public static attribute from an object but in Python, you can not). &quot;static methods&quot; in Java are equivalent to &quot;classmethod&quot; in Python that can access the class state (class members) &quot;staticmethod&quot; in Python is a relatively useless method that does not access the class state nor instance state and is like a pure function out of the class definition.<br>------------------------------------------------------------------ <br><h3> Tom Neyland, Id: 1669457, Score: 98: </h3><p><a href="http://rapd.wordpress.com/2008/07/02/python-staticmethod-vs-classmethod/" rel="noreferrer">Here</a> is a short article on this question</p>
<blockquote>
<p>@staticmethod function is nothing more than a function defined inside a class. It is callable without instantiating the class first. It’s definition is immutable via inheritance.</p>
<p>@classmethod function also callable without instantiating the class, but its definition follows Sub class, not Parent class, via inheritance. That’s because the first argument for @classmethod function must always be cls (class).</p>
</blockquote>
<h4> Matt Anderson, Comment 1542742 Score: 10: </h4>No. By using a staticmethod you aren&#39;t bound at all; there is no implicit first parameter. By using classmethod, you get as implicit first parameter the class you called the method on (if you called it directly on a class), or the class of the instance you called the method on (if you called it on an instance).<br><h4> MestreLion, Comment 13459425 Score: 9: </h4>Could be expanded a bit to show that, by having a class as a first argument, class methods have direct access to other class attributes and methods, while static methods do not (they would need to hardcode MyClass.attr for that)<br><h4> c z, Comment 102364398 Score: 2: </h4>&quot;It’s definition is immutable via inheritance.&quot; doesn&#39;t make any sense in Python, you can override a static method just fine.<br><h4> Mohan Gulati, Comment 1542649 Score: 2: </h4>So does that mean that by using a staticmethod I am always bound to the Parent class and with the classmethod I am bound the class that I declare the classmethod in (in this case the sub class)?<br>------------------------------------------------------------------ <br><h3> Russia Must Remove Putin, Id: 28117800, Score: 75: </h3><blockquote>
<h2>What is the difference between @staticmethod and @classmethod in Python?</h2>
</blockquote>
<p>You may have seen Python code like this pseudocode, which demonstrates the signatures of the various method types and provides a docstring to explain each:</p>
<pre><code>class Foo(object):

    def a_normal_instance_method(self, arg_1, kwarg_2=None):
        '''
        Return a value that is a function of the instance with its
        attributes, and other arguments such as arg_1 and kwarg2
        '''

    @staticmethod
    def a_static_method(arg_0):
        '''
        Return a value that is a function of arg_0. It does not know the 
        instance or class it is called from.
        '''

    @classmethod
    def a_class_method(cls, arg1):
        '''
        Return a value that is a function of the class and other arguments.
        respects subclassing, it is called with the class it is called from.
        '''
</code></pre>
<h1>The Normal Instance Method</h1>
<p>First I'll explain <code>a_normal_instance_method</code>. This is precisely called an &quot;<strong>instance method</strong>&quot;. When an instance method is used, it is used as a partial function (as opposed to a total function, defined for all values when viewed in source code) that is, when used, the first of the arguments is predefined as the instance of the object, with all of its given attributes. It has the instance of the object bound to it, and it must be called from an instance of the object. Typically, it will access various attributes of the instance.</p>
<p>For example, this is an instance of a string:</p>
<pre><code>', '
</code></pre>
<p>if we use the instance method, <code>join</code> on this string, to join another iterable,
it quite obviously is a function of the instance, in addition to being a function of the iterable list, <code>['a', 'b', 'c']</code>:</p>
<pre><code>&gt;&gt;&gt; ', '.join(['a', 'b', 'c'])
'a, b, c'
</code></pre>
<h3>Bound methods</h3>
<p>Instance methods can be bound via a dotted lookup for use later.</p>
<p>For example, this binds the <code>str.join</code> method to the <code>':'</code> instance:</p>
<pre><code>&gt;&gt;&gt; join_with_colons = ':'.join 
</code></pre>
<p>And later we can use this as a function that already has the first argument bound to it. In this way, it works like a partial function on the instance:</p>
<pre><code>&gt;&gt;&gt; join_with_colons('abcde')
'a:b:c:d:e'
&gt;&gt;&gt; join_with_colons(['FF', 'FF', 'FF', 'FF', 'FF', 'FF'])
'FF:FF:FF:FF:FF:FF'
</code></pre>
<h1>Static Method</h1>
<p>The static method does <em>not</em> take the instance as an argument.</p>
<p>It is very similar to a module level function.</p>
<p>However, a module level function must live in the module and be specially imported to other places where it is used.</p>
<p>If it is attached to the object, however, it will follow the object conveniently through importing and inheritance as well.</p>
<p>An example of a static method is <code>str.maketrans</code>, moved from the <code>string</code> module in Python 3.  It makes a translation table suitable for consumption by <code>str.translate</code>. It does seem rather silly when used from an instance of a string, as demonstrated below, but importing the function from the <code>string</code> module is rather clumsy, and it's nice to be able to call it from the class, as in <code>str.maketrans</code></p>
<pre><code># demonstrate same function whether called from instance or not:
&gt;&gt;&gt; ', '.maketrans('ABC', 'abc')
{65: 97, 66: 98, 67: 99}
&gt;&gt;&gt; str.maketrans('ABC', 'abc')
{65: 97, 66: 98, 67: 99}
</code></pre>
<p>In python 2, you have to import this function from the increasingly less useful string module:</p>
<pre><code>&gt;&gt;&gt; import string
&gt;&gt;&gt; 'ABCDEFG'.translate(string.maketrans('ABC', 'abc'))
'abcDEFG'
</code></pre>
<h1>Class Method</h1>
<p>A class method is a similar to an instance method in that it takes an implicit first argument, but instead of taking the instance, it takes the class. Frequently these are used as alternative constructors for better semantic usage and it will support inheritance.</p>
<p>The most canonical example of a builtin classmethod is <code>dict.fromkeys</code>. It is used as an alternative constructor of dict, (well suited for when you know what your keys are and want a default value for them.)</p>
<pre><code>&gt;&gt;&gt; dict.fromkeys(['a', 'b', 'c'])
{'c': None, 'b': None, 'a': None}
</code></pre>
<p>When we subclass dict, we can use the same constructor, which creates an instance of the subclass.</p>
<pre><code>&gt;&gt;&gt; class MyDict(dict): 'A dict subclass, use to demo classmethods'
&gt;&gt;&gt; md = MyDict.fromkeys(['a', 'b', 'c'])
&gt;&gt;&gt; md
{'a': None, 'c': None, 'b': None}
&gt;&gt;&gt; type(md)
&lt;class '__main__.MyDict'&gt;
</code></pre>
<p>See the <a href="https://github.com/pydata/pandas/blob/master/pandas/core/frame.py" rel="noreferrer">pandas source code</a> for other similar examples of alternative constructors, and see also the official Python documentation on <a href="https://docs.python.org/library/functions.html#classmethod" rel="noreferrer"><code>classmethod</code></a> and <a href="https://docs.python.org/library/functions.html#staticmethod" rel="noreferrer"><code>staticmethod</code></a>.</p>
------------------------------------------------------------------ <br><h3> Gaurang Shah, Id: 46664125, Score: 63: </h3><p>I started learning programming language with C++ and then Java and then Python and so this question bothered me a lot as well, until I understood the simple usage of each. </p>

<p><strong>Class Method:</strong> Python unlike Java and C++ doesn't have constructor overloading.  And so to achieve this you could use <code>classmethod</code>. Following example will explain this </p>

<p>Let's consider we have a <code>Person</code> class which takes two arguments <code>first_name</code> and <code>last_name</code> and creates the instance of <code>Person</code>. </p>

<pre><code>class Person(object):

    def __init__(self, first_name, last_name):
        self.first_name = first_name
        self.last_name = last_name
</code></pre>

<p>Now, if the requirement comes where you need to create a class using a single name only, just a <code>first_name</code>, you <strong>can't</strong> do something like this in Python. </p>

<p>This will give you an error when you will try to create an object (instance).</p>

<pre><code>class Person(object):

    def __init__(self, first_name, last_name):
        self.first_name = first_name
        self.last_name = last_name

    def __init__(self, first_name):
        self.first_name = first_name
</code></pre>

<p>However, you could achieve the same thing using <code>@classmethod</code> as mentioned below </p>

<pre><code>class Person(object):

    def __init__(self, first_name, last_name):
        self.first_name = first_name
        self.last_name = last_name

    @classmethod
    def get_person(cls, first_name):
        return cls(first_name, "")
</code></pre>

<p><strong>Static Method:</strong> This is rather simple, it's not bound to instance or class and you can simply call that using class name. </p>

<p>So let's say in above example you need a validation that <code>first_name</code> should not exceed 20 characters, you can simply do this. </p>

<pre><code>@staticmethod  
def validate_name(name):
    return len(name) &lt;= 20
</code></pre>

<p>and you could simply call using <code>class name</code></p>

<pre><code>Person.validate_name("Gaurang Shah")
</code></pre>
<h4> akarilimano, Comment 102374373 Score: 11: </h4>It&#39;s an old post, but more pythonic way to achieve constructor accepting either one or two arguments would be using <code>def __init__(self, first_name, last_name=&quot;&quot;)</code> instead of classmethod <code>get_person</code>. Also result will be exactly the same in this case.<br>------------------------------------------------------------------ <br><h3> blue_note, Id: 56236639, Score: 61: </h3><p><strong>Only the first argument differs</strong>:</p>
<ul>
<li>normal method: <strong>the current object</strong> is automatically passed as an (additional) first argument</li>
<li>classmethod: <strong>the class of the current object</strong> is automatically passed as an (additional) fist argument</li>
<li>staticmethod: <strong>no extra arguments</strong> are automatically passed. What you passed to the function is what you get.</li>
</ul>
<p>In more detail...</p>
<h2>normal method</h2>
<p>The &quot;standard&quot; method, as in every object oriented language. When an object's method is called, it is automatically given an extra argument <code>self</code> as its first argument. That is, method</p>
<pre><code>def f(self, x, y)
</code></pre>
<p>must be called with 2 arguments. <code>self</code> is automatically passed, and it is <em>the object itself</em>. Similar to the <code>this</code> that magically appears in eg. java/c++, only in python it is shown explicitly.</p>
<blockquote>
<p>actually, the first argument does not <em>have to</em> be called <code>self</code>, but it's the standard convention, so keep it</p>
</blockquote>
<h2>class method</h2>
<p>When the method is decorated</p>
<pre><code>@classmethod
def f(cls, x, y)
</code></pre>
<p>the automatically provided argument <em>is not</em> <code>self</code>, but <em>the class of</em> <code>self</code>.</p>
<h2>static method</h2>
<p>When the method is decorated</p>
<pre><code>@staticmethod
def f(x, y)
</code></pre>
<p>the method <em>is not given</em> any automatic argument at all. It is only given the parameters that it is called with.</p>
<h1>usages</h1>
<ul>
<li><code>classmethod</code> is mostly used for alternative constructors.</li>
<li><code>staticmethod</code> does not use the state of the object, or even the structure of the class itself. It could be a function external to a class. It only put inside the class for grouping functions with similar functionality (for example, like Java's <code>Math</code> class static methods)</li>
</ul>
<pre class="lang-py prettyprint-override"><code>class Point
    def __init__(self, x, y):
        self.x = x
        self.y = y

    @classmethod
    def frompolar(cls, radius, angle):
        &quot;&quot;&quot;The `cls` argument is the `Point` class itself&quot;&quot;&quot;
        return cls(radius * cos(angle), radius * sin(angle))

    @staticmethod
    def angle(x, y):
        &quot;&quot;&quot;this could be outside the class, but we put it here 
just because we think it is logically related to the class.&quot;&quot;&quot;
        return atan(y, x)


p1 = Point(3, 2)
p2 = Point.frompolar(3, pi/4)

angle = Point.angle(3, 2)

</code></pre>
<h4> Rich Lysakowski PhD, Comment 126063088 Score: 0: </h4>This is the best answer out of the bunch above.  It is clear with good and concise examples.  The other examples leave out some details.<br><h4> Abayomi Olowu, Comment 128976273 Score: 0: </h4>this is the only answer that explains this concept very well. i was learn graphql for apis on python and some use classmethod while the others use staticmethod under their class mutation. this brought me to the reason why they are been used that way and this here really provided answers to my curiorcity. thank you<br>------------------------------------------------------------------ <br><h3> Nathan Tregillus, Id: 30329887, Score: 47: </h3><p>I think a better question is &quot;When would you use <code>@classmethod</code> vs <code>@staticmethod</code>?&quot;</p>
<p><code>@classmethod</code> allows you easy access to private members that are associated to the class definition. this is a great way to do singletons, or factory classes that control the number of instances of the created objects exist.</p>
<p><code>@staticmethod</code> provides marginal performance gains, but I have yet to see a productive use of a static method within a class that couldn't be achieved as a standalone function outside the class.</p>
<h4> joel, Comment 112113794 Score: 0: </h4>This question mentions access of private class members. I want to highlight that (depending on your definition of private), <code>@staticmethod</code>s have a different access level to <code>@classmethod</code>s. The former shouldn&#39;t access class private class members<br>------------------------------------------------------------------ <br><h3> Laxmi, Id: 39829692, Score: 39: </h3><p><strong>Static Methods:</strong></p>

<ul>
<li>Simple functions with no self argument. </li>
<li>Work on class attributes; not on instance attributes.</li>
<li>Can be called through both class and instance.</li>
<li>The built-in function staticmethod()is used to create them.</li>
</ul>

<p><strong>Benefits of Static Methods:</strong></p>

<ul>
<li>It localizes the function name in the classscope</li>
<li>It moves the function code closer to where it is used</li>
<li><p>More convenient to import versus module-level functions since each method does not have to be specially imported</p>

<pre><code>@staticmethod
def some_static_method(*args, **kwds):
    pass
</code></pre></li>
</ul>

<p><strong>Class Methods:</strong></p>

<ul>
<li>Functions that have first argument as classname.</li>
<li>Can be called through both class and instance.</li>
<li><p>These are created with classmethod in-built function.</p>

<pre><code> @classmethod
 def some_class_method(cls, *args, **kwds):
     pass
</code></pre></li>
</ul>
------------------------------------------------------------------ <br><h3> Jens Timmerman, Id: 9428384, Score: 37: </h3><p>@decorators were added in python 2.4 If you're using python &lt; 2.4 you can use the classmethod() and staticmethod() function.</p>

<p>For example, if you want to create a factory method (A function returning an instance of a different implementation of a class depending on what argument it gets) you can do something like:</p>

<pre><code>class Cluster(object):

    def _is_cluster_for(cls, name):
        """
        see if this class is the cluster with this name
        this is a classmethod
        """ 
        return cls.__name__ == name
    _is_cluster_for = classmethod(_is_cluster_for)

    #static method
    def getCluster(name):
        """
        static factory method, should be in Cluster class
        returns a cluster object for the given name
        """
        for cls in Cluster.__subclasses__():
            if cls._is_cluster_for(name):
                return cls()
    getCluster = staticmethod(getCluster)
</code></pre>

<p>Also observe that this is a good example for using a classmethod and a static method,
The static method clearly belongs to the class, since it uses the class Cluster internally.
The classmethod only needs information about the class, and no instance of the object.</p>

<p>Another benefit of making the <code>_is_cluster_for</code> method a classmethod is so a subclass can decide to change it's implementation, maybe because it is pretty generic and can handle more than one type of cluster, so just checking the name of the class would not be enough.</p>
------------------------------------------------------------------ <br><h3> Selva, Id: 48250384, Score: 33: </h3><p>Let me tell the similarity between a method decorated with @classmethod vs @staticmethod first.</p>

<p><strong>Similarity:</strong> Both of them can be called on the <em>Class</em> itself, rather than just the <em>instance</em> of the class. So, both of them in a sense are <em>Class's methods</em>. </p>

<p><strong>Difference:</strong> A classmethod will receive the class itself as the first argument, while a staticmethod does not.</p>

<p>So a static method is, in a sense, not bound to the Class itself and is just hanging in there just because it may have a related functionality. </p>

<pre><code>&gt;&gt;&gt; class Klaus:
        @classmethod
        def classmthd(*args):
            return args

        @staticmethod
        def staticmthd(*args):
            return args

# 1. Call classmethod without any arg
&gt;&gt;&gt; Klaus.classmthd()  
(__main__.Klaus,)  # the class gets passed as the first argument

# 2. Call classmethod with 1 arg
&gt;&gt;&gt; Klaus.classmthd('chumma')
(__main__.Klaus, 'chumma')

# 3. Call staticmethod without any arg
&gt;&gt;&gt; Klaus.staticmthd()  
()

# 4. Call staticmethod with 1 arg
&gt;&gt;&gt; Klaus.staticmthd('chumma')
('chumma',)
</code></pre>
<h4> sliders_alpha, Comment 130316111 Score: 0: </h4>but why would you want to use one instead of the other? what is a real world use case?<br>------------------------------------------------------------------ <br><h3> Armin Ronacher, Id: 136246, Score: 30: </h3><p><code>@staticmethod</code> just disables the default function as method descriptor.  classmethod wraps your function in a container callable that passes a reference to the owning class as first argument:</p>

<pre><code>&gt;&gt;&gt; class C(object):
...  pass
... 
&gt;&gt;&gt; def f():
...  pass
... 
&gt;&gt;&gt; staticmethod(f).__get__(None, C)
&lt;function f at 0x5c1cf0&gt;
&gt;&gt;&gt; classmethod(f).__get__(None, C)
&lt;bound method type.f of &lt;class '__main__.C'&gt;&gt;
</code></pre>

<p>As a matter of fact, <code>classmethod</code> has a runtime overhead but makes it possible to access the owning class.  Alternatively I recommend using a metaclass and putting the class methods on that metaclass:</p>

<pre><code>&gt;&gt;&gt; class CMeta(type):
...  def foo(cls):
...   print cls
... 
&gt;&gt;&gt; class C(object):
...  __metaclass__ = CMeta
... 
&gt;&gt;&gt; C.foo()
&lt;class '__main__.C'&gt;
</code></pre>
<h4> Russia Must Remove Putin, Comment 63109244 Score: 1: </h4>One possible downside of a metaclass for this that immediately occurs to me is that you can&#39;t call the classmethod directly on an instance. <code>c = C(); c.foo()</code> raises AttributeError, you&#39;d have to do <code>type(c).foo()</code>. This might also be considered a feature - I can&#39;t think of why you&#39;d want to though.<br>------------------------------------------------------------------ <br><h3> Adam Parkin, Id: 39776104, Score: 26: </h3><p>Another consideration with respect to staticmethod vs classmethod comes up with inheritance.  Say you have the following class:</p>
<pre><code>class Foo(object):
    @staticmethod
    def bar():
        return &quot;In Foo&quot;
</code></pre>
<p>And you then want to override <code>bar()</code> in a child class:</p>
<pre><code>class Foo2(Foo):
    @staticmethod
    def bar():
        return &quot;In Foo2&quot;
</code></pre>
<p>This works, but note that now the <code>bar()</code> implementation in the child class (<code>Foo2</code>) can no longer take advantage of anything specific to that class.  For example, say <code>Foo2</code> had a method called <code>magic()</code> that you want to use in the <code>Foo2</code> implementation of <code>bar()</code>:</p>
<pre><code>class Foo2(Foo):
    @staticmethod
    def bar():
        return &quot;In Foo2&quot;
    @staticmethod
    def magic():
        return &quot;Something useful you'd like to use in bar, but now can't&quot; 
</code></pre>
<p>The workaround here would be to call <code>Foo2.magic()</code> in <code>bar()</code>, but then you're repeating yourself (if the name of <code>Foo2</code> changes, you'll have to remember to update that <code>bar()</code> method).</p>
<p>To me, this is a slight violation of the <a href="https://en.wikipedia.org/wiki/Open/closed_principle" rel="noreferrer">open/closed principle</a>, since a decision made in <code>Foo</code> is impacting your ability to refactor common code in a derived class (ie it's less open to extension).  If <code>bar()</code> were a <code>classmethod</code> we'd be fine:</p>
<pre><code>class Foo(object):
    @classmethod
    def bar(cls):
        return &quot;In Foo&quot;

class Foo2(Foo):
    @classmethod
    def bar(cls):
        return &quot;In Foo2 &quot; + cls.magic()
    @classmethod
    def magic(cls):
        return &quot;MAGIC&quot;

print Foo2().bar()
</code></pre>
<p>Gives: <code>In Foo2 MAGIC</code></p>
<p>Also: historical note: Guido Van Rossum (Python's creator) once referred to <code>staticmethod</code>'s as &quot;an accident&quot;: <a href="https://mail.python.org/pipermail/python-ideas/2012-May/014969.html" rel="noreferrer">https://mail.python.org/pipermail/python-ideas/2012-May/014969.html</a></p>
<blockquote>
<p>we all know how limited static methods are. (They're basically an accident -- back in the Python 2.2 days when I was inventing new-style classes and descriptors, I meant to implement class methods but at first I didn't understand them and accidentally implemented static methods first. Then it was too late to remove them and only provide class methods.</p>
</blockquote>
<p>Also: <a href="https://mail.python.org/pipermail/python-ideas/2016-July/041189.html" rel="noreferrer">https://mail.python.org/pipermail/python-ideas/2016-July/041189.html</a></p>
<blockquote>
<p>Honestly, staticmethod was something of a mistake -- I was trying to do something like Java class methods but once it was released I found what was really needed was classmethod. But it was too late to get rid of staticmethod.</p>
</blockquote>
------------------------------------------------------------------ <br><h3> zangw, Id: 33727452, Score: 25: </h3><p><a href="https://dzone.com/articles/definitive-guide-how-use" rel="nofollow noreferrer">The definitive guide on how to use static, class or abstract methods in Python</a> is one good link for this topic, and summary it as following.</p>
<p><strong><code>@staticmethod</code></strong> function is nothing more than a function defined inside a class. It is callable without instantiating the class first. It’s definition is immutable via inheritance.</p>
<ul>
<li>Python does not have to instantiate a bound-method for object.</li>
<li>It eases the readability of the code, and it does not depend on the state of object itself;</li>
</ul>
<p><strong><code>@classmethod</code></strong> function also callable without instantiating the class, but its definition follows Sub class, not Parent class, via inheritance, can be overridden by subclass. That’s because the first argument for <code>@classmethod</code> function must always be <em>cls</em> (class).</p>
<ul>
<li><em>Factory methods</em>, that are used to create an instance for a class using for example some sort of pre-processing.</li>
<li><em>Static methods calling static methods</em>: if you split a static methods in several static methods, you shouldn't hard-code the class name but use class methods</li>
</ul>
<h4> Ulysses, Comment 87271487 Score: 0: </h4>Thanks @zangw - the inherited immutability of static function is the key difference it seems<br>------------------------------------------------------------------ <br><h3> H.H, Id: 66672138, Score: 13: </h3><p><strong>The difference occurs when there is inheritance.</strong></p>
<p>Suppose that there are two classes -- <code>Parent</code> and <code>Child</code>. If one wants to use <code>@staticmethod</code>, <code>print_name</code> method should be written twice because the name of the class should be written in the print line.</p>
<pre><code>class Parent:
   _class_name = &quot;Parent&quot;

   @staticmethod
   def print_name():
       print(Parent._class_name)


class Child(Parent):
   _class_name = &quot;Child&quot;

   @staticmethod
   def print_name():
       print(Child._class_name)


Parent.print_name()
Child.print_name()
</code></pre>
<p>However, for <code>@classmethod</code>, it is not required to write <code>print_name</code> method twice.</p>
<pre><code>class Parent:
    _class_name = &quot;Parent&quot;

    @classmethod
    def print_name(cls):
        print(cls._class_name)


class Child(Parent):
    _class_name = &quot;Child&quot;


Parent.print_name()
Child.print_name()
</code></pre>
<h4> masih, Comment 121192769 Score: 0: </h4>Liked very much the simplicity of this answer. Wish could have given 100 votes for it.<br>------------------------------------------------------------------ <br><h3> illuminato, Id: 65754079, Score: 11: </h3><p>Python comes with several built-in decorators. The big three are:</p>
<pre><code>@classmethod
@staticmethod
@property
</code></pre>
<p>First let's note that any function of a class can be called with instance of this class (after we initialized this class).</p>
<p><strong>@classmethod</strong> is the way to <strong>call function</strong> not only as an instance of a class but also <strong>directly by the class itself</strong> as its first argument.</p>
<p><strong>@staticmethod</strong> is a way of putting a function into a class (because it logically belongs there), while indicating that it does not require access to the class (so we <strong>don't need to use <code>self</code></strong> in function definition).</p>
<p>Let's consider the following class:</p>
<pre><code>class DecoratorTest(object):

    def __init__(self):
        pass

    def doubler(self, x):
        return x*2

    @classmethod
    def class_doubler(cls, x): 
        &quot;&quot;&quot;
        We need to use 'cls' instead of 'self'; 
        'cls' references the class instead of 
        an instance of the class
        &quot;&quot;&quot;
        return x*2

    @staticmethod
    def static_doubler(x): 
        &quot;&quot;&quot;
        No need to add 'self' here;
        static_doubler() could just be 
        a function outside the class.
        &quot;&quot;&quot;
        return x*2
</code></pre>
<p>Let's see how it works:</p>
<pre><code>decor = DecoratorTest()

print(decor.doubler(5))
# 10

# a call with an instance of a class
print(decor.class_doubler(5)) 
# 10

# a direct call by the class itself
print(DecoratorTest.class_doubler(5)) 
# 10

# staticmethod can be called the same as classmethod.

# as an instance of the class
print(decor.static_doubler(5))
# 10

# or as a direct call 
print(DecoratorTest.static_doubler(5))
# 10
</code></pre>
<p><a href="https://www.codearmo.com/python-tutorial/object-orientated-programming-static-class-methods" rel="nofollow noreferrer">Here</a> you can see some use cases for those methods.</p>
<p>Bonus: you can read about <code>@property</code> decorator <a href="https://www.programiz.com/python-programming/property" rel="nofollow noreferrer">here</a></p>
------------------------------------------------------------------ <br><h3> Rizwan Mumtaz, Id: 39589894, Score: 11: </h3><p>I will try to explain the basic difference using an example.</p>

<pre><code>class A(object):
    x = 0

    def say_hi(self):
        pass

    @staticmethod
    def say_hi_static():
        pass

    @classmethod
    def say_hi_class(cls):
        pass

    def run_self(self):
        self.x += 1
        print self.x # outputs 1
        self.say_hi()
        self.say_hi_static()
        self.say_hi_class()

    @staticmethod
    def run_static():
        print A.x  # outputs 0
        # A.say_hi() #  wrong
        A.say_hi_static()
        A.say_hi_class()

    @classmethod
    def run_class(cls):
        print cls.x # outputs 0
        # cls.say_hi() #  wrong
        cls.say_hi_static()
        cls.say_hi_class()
</code></pre>

<p>1 - we can directly call static and classmethods without initializing</p>

<pre><code># A.run_self() #  wrong
A.run_static()
A.run_class()
</code></pre>

<p>2- Static method cannot call self method but can call other static and classmethod</p>

<p>3- Static method belong to class and will not use object at all.</p>

<p>4- Class method are not bound to an object but to a class.</p>
------------------------------------------------------------------ <br><h3> Milovan Tomašević, Id: 64732009, Score: 10: </h3><p><strong><em>Instance Method</em></strong>:</p>
<p><code>+</code> <em>Can</em> modify object instance state</p>
<p><code>+</code> <em>Can</em> modify class state</p>
<p><strong><em>Class Method</em></strong>:</p>
<p><code>-</code> <em>Can't</em> modify object instance state</p>
<p><code>+</code> <em>Can</em> modify class state</p>
<p><strong><em>Static Method</em></strong>:</p>
<p><code>-</code> <em>Can't</em> modify object instance state</p>
<p><code>-</code> <em>Can't</em> modify class state</p>
<pre class="lang-py prettyprint-override"><code>class MyClass:
    ''' 
    Instance method has a mandatory first attribute self which represent the instance itself. 
    Instance method must be called by a instantiated instance.
    '''
    def method(self):
        return 'instance method called', self
    
    '''
    Class method has a mandatory first attribute cls which represent the class itself. 
    Class method can be called by an instance or by the class directly. 
    Its most common using scenario is to define a factory method.
    '''
    @classmethod
    def class_method(cls):
        return 'class method called', cls
    
    '''
    Static method doesn’t have any attributes of instances or the class. 
    It also can be called by an instance or by the class directly. 
    Its most common using scenario is to define some helper or utility functions which are closely relative to the class.
    '''
    @staticmethod
    def static_method():
        return 'static method called'


obj = MyClass()
print(obj.method())
print(obj.class_method()) # MyClass.class_method()
print(obj.static_method()) # MyClass.static_method()
</code></pre>
<p>output:</p>
<pre class="lang-sh prettyprint-override"><code>('instance method called', &lt;__main__.MyClass object at 0x100fb3940&gt;)
('class method called', &lt;class '__main__.MyClass'&gt;)
static method called
</code></pre>
<p>The instance method we actually had access to the object instance , right so this was an instance off a my class object whereas with the class method we have access to the class itself. But not to any of the objects,  because the class method doesn't really care about an object existing. However you can both call a class method and static method on an object instance. This is going to work it doesn't really make a difference, so again when you call static method here it's going to work and it's going to know which method you want to call.</p>
<p>The Static methods are used to do some utility tasks, and class methods are used for factory methods. The factory methods can return class objects for different use cases.</p>
<p>And finally, a short example for better understanding:</p>
<pre class="lang-py prettyprint-override"><code>class Student:
    def __init__(self, first_name, last_name):
        self.first_name = first_name
        self.last_name = last_name

    @classmethod
    def get_from_string(cls, name_string: str):
        first_name, last_name = name_string.split()
        if Student.validate_name(first_name) and Student.validate_name(last_name):
            return cls(first_name, last_name)
        else:
            print('Invalid Names')

    @staticmethod
    def validate_name(name):
        return len(name) &lt;= 10


stackoverflow_student = Student.get_from_string('Name Surname')
print(stackoverflow_student.first_name) # Name
print(stackoverflow_student.last_name) # Surname
</code></pre>
------------------------------------------------------------------ <br><h3> vijay, Id: 46327819, Score: 7: </h3><p>@classmethod : can be used to create a shared global access to all the instances created of that class..... like updating a record by multiple users....
I particulary found it use ful when creating singletons as well..:)</p>

<p>@static method:  has nothing to do with the class or instance being associated with ...but for readability can use static method</p>
------------------------------------------------------------------ <br><h3> Michael Swartz, Id: 51015649, Score: 7: </h3><p>My contribution demonstrates the difference amongst <code>@classmethod</code>, <code>@staticmethod</code>, and instance methods, including how an instance can indirectly call a <code>@staticmethod</code>. But instead of indirectly calling a <code>@staticmethod</code> from an instance, making it private may be more "pythonic." Getting something from a private method isn't demonstrated here but it's basically the same concept.</p>

<pre><code>#!python3

from os import system
system('cls')
# %   %   %   %   %   %   %   %   %   %   %   %   %   %   %   %   %   %   %   %

class DemoClass(object):
    # instance methods need a class instance and
    # can access the instance through 'self'
    def instance_method_1(self):
        return 'called from inside the instance_method_1()'

    def instance_method_2(self):
        # an instance outside the class indirectly calls the static_method
        return self.static_method() + ' via instance_method_2()'

    # class methods don't need a class instance, they can't access the
    # instance (self) but they have access to the class itself via 'cls'
    @classmethod
    def class_method(cls):
        return 'called from inside the class_method()'

    # static methods don't have access to 'cls' or 'self', they work like
    # regular functions but belong to the class' namespace
    @staticmethod
    def static_method():
        return 'called from inside the static_method()'
# %   %   %   %   %   %   %   %   %   %   %   %   %   %   %   %   %   %   %   %

# works even if the class hasn't been instantiated
print(DemoClass.class_method() + '\n')
''' called from inside the class_method() '''

# works even if the class hasn't been instantiated
print(DemoClass.static_method() + '\n')
''' called from inside the static_method() '''
# %   %   %   %   %   %   %   %   %   %   %   %   %   %   %   %   %   %   %   %

# &gt;&gt;&gt;&gt;&gt; all methods types can be called on a class instance &lt;&lt;&lt;&lt;&lt;
# instantiate the class
democlassObj = DemoClass()

# call instance_method_1()
print(democlassObj.instance_method_1() + '\n')
''' called from inside the instance_method_1() '''

# # indirectly call static_method through instance_method_2(), there's really no use
# for this since a @staticmethod can be called whether the class has been
# instantiated or not
print(democlassObj.instance_method_2() + '\n')
''' called from inside the static_method() via instance_method_2() '''

# call class_method()
print(democlassObj.class_method() + '\n')
'''  called from inside the class_method() '''

# call static_method()
print(democlassObj.static_method())
''' called from inside the static_method() '''

"""
# whether the class is instantiated or not, this doesn't work
print(DemoClass.instance_method_1() + '\n')
'''
TypeError: TypeError: unbound method instancemethod() must be called with
DemoClass instance as first argument (got nothing instead)
'''
"""
</code></pre>
------------------------------------------------------------------ <br><h3> David Schumann, Id: 54347204, Score: 7: </h3><p>You might want to consider the difference between:</p>

<pre class="lang-py prettyprint-override"><code>class A:
    def foo():  # no self parameter, no decorator
        pass
</code></pre>
<p>and</p>
<pre class="lang-py prettyprint-override"><code>class B:
    @staticmethod
    def foo():  # no self parameter
        pass
</code></pre>
<p>This has changed between python2 and python3:</p>
<p>python2:</p>
<pre class="lang-py prettyprint-override"><code>&gt;&gt;&gt; A.foo()
TypeError
&gt;&gt;&gt; A().foo()
TypeError
&gt;&gt;&gt; B.foo()
&gt;&gt;&gt; B().foo()
</code></pre>
<p>python3:</p>
<pre class="lang-py prettyprint-override"><code>&gt;&gt;&gt; A.foo()
&gt;&gt;&gt; A().foo()
TypeError
&gt;&gt;&gt; B.foo()
&gt;&gt;&gt; B().foo()
</code></pre>
<p>So using  <code>@staticmethod</code> for methods only called directly from the class has become optional in python3. If you want to call them from both class and instance, you still need to use the <code>@staticmethod</code> decorator.</p>
<p>The other cases have been well covered by unutbus answer.</p>
------------------------------------------------------------------ <br><h3> Nicolae Petridean, Id: 58953655, Score: 7: </h3><p>A class method receives the class as implicit first argument, just like an instance method receives the instance. It is a method which is bound to the class and not the object of the class.It has access to the state of the class as it takes a class parameter that points to the class and not the object instance. It can modify a class state that would apply across all the instances of the class. For example it can modify a class variable that will be applicable to all the instances. </p>

<p>On the other hand, a static method does not receive an implicit first argument, compared to class methods or instance methods. And can’t access or modify class state. It only belongs to the class because from design point of view that is the correct way. But in terms of functionality is not bound, at runtime, to the class.</p>

<p>as a guideline, use static methods as utilities, use class methods for example as factory . Or maybe to define a singleton. And use instance methods to model the state and behavior of instances.</p>

<p>Hope I was clear ! </p>
------------------------------------------------------------------ <br><h3> Tushar Vazirani, Id: 47591541, Score: 4: </h3><p>Class methods, as the name suggests, are used to make changes to classes and not the objects. To make changes to classes, they will modify the class attributes(not object attributes), since that is how you update classes.
This is the reason that class methods take the class(conventionally denoted by 'cls') as the first argument.</p>

<pre><code>class A(object):
    m=54

    @classmethod
    def class_method(cls):
        print "m is %d" % cls.m
</code></pre>

<p>Static methods on the other hand, are used to perform functionalities that are not bound to the class i.e. they will not read or write class variables. Hence, static methods do not take classes as arguments. They are used so that classes can perform functionalities that are not directly related to the purpose of the class.</p>

<pre><code>class X(object):
    m=54 #will not be referenced

    @staticmethod
    def static_method():
        print "Referencing/calling a variable or function outside this class. E.g. Some global variable/function."
</code></pre>
<h4> joel, Comment 112113448 Score: 0: </h4>methods don&#39;t always make changes<br>------------------------------------------------------------------ <br><h3> Jacky Wang, Id: 58951325, Score: 4: </h3><p>I think giving a purely Python version of <code>staticmethod</code> and <code>classmethod</code> would help to understand the difference between them at language level (Refers to <a href="https://docs.python.org/2/howto/descriptor.html#static-methods-and-class-methods" rel="nofollow noreferrer">Descriptor Howto Guide</a>).</p>
<p>Both of them are non-data descriptors (It would be easier to understand them if you are familiar with <a href="https://docs.python.org/3/reference/datamodel.html#implementing-descriptors" rel="nofollow noreferrer">descriptors</a> first).</p>
<pre><code>class StaticMethod(object):
    &quot;Emulate PyStaticMethod_Type() in Objects/funcobject.c&quot;

    def __init__(self, f):
        self.f = f

    def __get__(self, obj, objtype=None):
        return self.f


class ClassMethod(object):
    &quot;Emulate PyClassMethod_Type() in Objects/funcobject.c&quot;
    def __init__(self, f):
        self.f = f

    def __get__(self, obj, cls=None):
        def inner(*args, **kwargs):
            if cls is None:
                cls = type(obj)
            return self.f(cls, *args, **kwargs)
        return inner
</code></pre>
------------------------------------------------------------------ <br><h3> Wizard, Id: 47769396, Score: 3: </h3><p>Analyze @staticmethod <strong>literally</strong> providing different insights.</p>

<p>A normal method of a class is an implicit <strong>dynamic</strong> method which takes the instance as first argument.<br>
In contrast, a staticmethod does not take the instance as first argument, so is called <strong>'static'</strong>.</p>

<p>A staticmethod is indeed such a normal function the same as those outside a class definition.<br>
It is luckily grouped into the class just in order to stand closer where it is applied, or you might scroll around to find it.</p>
------------------------------------------------------------------ <br><h3> Ale, Id: 63197044, Score: 2: </h3><p>One pretty important practical difference occurs when subclassing. If you don't mind, I'll hijack @unutbu's example:</p>
<pre class="lang-py prettyprint-override"><code>class A: 
    def foo(self, x): 
        print(&quot;executing foo(%s, %s)&quot; % (self, x)) 
 
    @classmethod
    def class_foo(cls, x): 
        print(&quot;executing class_foo(%s, %s)&quot; % (cls, x))
 
    @staticmethod 
    def static_foo(x): 
        print(&quot;executing static_foo(%s)&quot; % x)

class B(A):
    pass
</code></pre>
<p>In <code>class_foo</code>, the method knows which class it is called on:</p>
<pre class="lang-py prettyprint-override"><code>A.class_foo(1)
# =&gt; executing class_foo(&lt;class '__main__.A'&gt;, 1)
B.class_foo(1)
# =&gt; executing class_foo(&lt;class '__main__.B'&gt;, 1)
</code></pre>
<p>In <code>static_foo</code>, there is no way to determine whether it is called on <code>A</code> or <code>B</code>:</p>
<pre class="lang-py prettyprint-override"><code>A.static_foo(1)
# =&gt; executing static_foo(1)
B.static_foo(1)
# =&gt; executing static_foo(1)
</code></pre>
<p>Note that this doesn't mean you can't use other methods in a <code>staticmethod</code>, you just have to reference the class directly, which means subclasses' staticmethods will still reference the parent class:</p>
<pre class="lang-py prettyprint-override"><code>class A:
    @classmethod
    def class_qux(cls, x):
        print(f&quot;executing class_qux({cls}, {x})&quot;)
    
    @classmethod
    def class_bar(cls, x):
        cls.class_qux(x)

    @staticmethod
    def static_bar(x):
        A.class_qux(x)

class B(A):
    pass

A.class_bar(1)
# =&gt; executing class_qux(&lt;class '__main__.A'&gt;, 1)
B.class_bar(1)
# =&gt; executing class_qux(&lt;class '__main__.B'&gt;, 1)
A.static_bar(1)
# =&gt; executing class_qux(&lt;class '__main__.A'&gt;, 1)
B.static_bar(1)
# =&gt; executing class_qux(&lt;class '__main__.A'&gt;, 1)
</code></pre>
------------------------------------------------------------------ <br><h3> Sia, Id: 66020869, Score: 2: </h3><p>tldr;</p>
<p>A <code>staticmethod</code> is essentially a function bound to a class (and consequently its instances)</p>
<p>A <code>classmethod</code> is essentially an inheritable <code>staticmethod</code>.</p>
<p>For details, see the excellent answers by others.</p>
------------------------------------------------------------------ <br><h3> Giorgos Myrianthous, Id: 66049235, Score: 2: </h3><p>First let's start with an example code that we'll use to understand both concepts:</p>
<pre><code>class Employee:

    NO_OF_EMPLOYEES = 0
  
    def __init__(self, first_name, last_name, salary):
        self.first_name = first_name
        self.last_name = last_name
        self.salary = salary
        self.increment_employees()

    def give_raise(self, amount):
        self.salary += amount

    @classmethod
    def employee_from_full_name(cls, full_name, salary):
        split_name = full_name.split(' ')
        first_name = split_name[0]
        last_name = split_name[1]
        return cls(first_name, last_name, salary)

    @classmethod
    def increment_employees(cls):
        cls.NO_OF_EMPLOYEES += 1

    @staticmethod
    def get_employee_legal_obligations_txt():
        legal_obligations = &quot;&quot;&quot;
        1. An employee must complete 8 hours per working day
        2. ...
        &quot;&quot;&quot;
        return legal_obligations
</code></pre>
<hr />
<p><strong>Class method</strong></p>
<p>A class method accepts the class itself as an implicit argument and -optionally- any other arguments specified in the definition. It’s important to understand that a class method, does not have access to object instances (like instance methods do). Therefore, class methods cannot be used to alter the state of an instantiated object but instead, they are capable of changing the class state which is shared amongst all the instances of that class.
Class methods are typically useful when we need to access the class itself — for example, when we want to create a factory method, that is a method that creates instances of the class. In other words, class methods can serve as alternative constructors.</p>
<p>In our example code, an instance of <code>Employee</code> can be constructed by providing three arguments; <code>first_name</code> , <code>last_name</code> and <code>salary</code>.</p>
<pre><code>employee_1 = Employee('Andrew', 'Brown', 85000)
print(employee_1.first_name)
print(employee_1.salary)

'Andrew'
85000
</code></pre>
<p>Now let’s assume that there’s a chance that the name of an Employee can be provided in a single field in which the first and last names are separated by a whitespace. In this case, we could possibly use our class method called <code>employee_from_full_name</code> that accepts three arguments in total. The first one, is the class itself, which is an implicit argument which means that it won’t be provided when calling the method — Python will automatically do this for us:</p>
<pre><code>employee_2 = Employee.employee_from_full_name('John Black', 95000)
print(employee_2.first_name)
print(employee_2.salary)

'John'
95000
</code></pre>
<p>Note that it is also possible to call <code>employee_from_full_name</code> from object instances although in this context it doesn’t make a lot of sense:</p>
<pre><code>employee_1 = Employee('Andrew', 'Brown', 85000)
employee_2 = employee_1.employee_from_full_name('John Black', 95000)
</code></pre>
<p>Another reason why we might want to create a class method, is when we need to change the state of the class. In our example, the class variable <code>NO_OF_EMPLOYEES</code> keeps track of the number of employees currently working for the company. This method is called every time a new instance of Employee is created and it updates the count accordingly:</p>
<pre><code>employee_1 = Employee('Andrew', 'Brown', 85000)
print(f'Number of employees: {Employee.NO_OF_EMPLOYEES}')
employee_2 = Employee.employee_from_full_name('John Black', 95000)
print(f'Number of employees: {Employee.NO_OF_EMPLOYEES}')

Number of employees: 1
Number of employees: 2
</code></pre>
<hr />
<p><strong>Static methods</strong></p>
<p>On the other hand, in static methods neither the instance (i.e. <code>self</code>) nor the class itself (i.e. <code>cls</code>) is passed as an implicit argument. This means that such methods, are not capable of accessing the class itself or its instances.
Now one could argue that static methods are not useful in the context of classes as they can also be placed in helper modules instead of adding them as members of the class. In object oriented programming, it is important to structure your classes into logical chunks and thus, static methods are quite useful when we need to add a method under a class simply because it logically belongs to the class.
In our example, the static method named <code>get_employee_legal_obligations_txt</code> simply returns a string that contains the legal obligations of every single employee of a company. This function, does not interact with the class itself nor with any instance. It could have been placed into a different helper module however, it is only relevant to this class and therefore we have to place it under the Employee class.</p>
<p>A static method can be access directly from the class itself</p>
<pre><code>print(Employee.get_employee_legal_obligations_txt())


    1. An employee must complete 8 hours per working day
    2. ...
</code></pre>
<p>or from an instance of the class:</p>
<pre><code>employee_1 = Employee('Andrew', 'Brown', 85000)
print(employee_1.get_employee_legal_obligations_txt())


    1. An employee must complete 8 hours per working day
    2. ...
</code></pre>
<hr />
<p><strong>References</strong></p>
<ul>
<li><a href="https://towardsdatascience.com/whats-the-difference-between-static-and-class-methods-in-python-1ef581de4351" rel="nofollow noreferrer">What's the difference between static and class methods in Python?</a></li>
</ul>
------------------------------------------------------------------ <br><h3> Super Kai - Kazuya Ito, Id: 74470227, Score: 2: </h3><p><code>@classmethod</code> is more powerful than <code>@staticmethod</code>.</p>
<h3><code>@classmethod</code>:</h3>
<ul>
<li><p>can call class variables and instance, class and static methods both by <code>cls</code> and directly by class name but not instance variables.</p>
</li>
<li><p>can be called both by object and directly by class name.</p>
</li>
<li><p>needs <code>cls</code> for the 1st argument otherwise <code>@classmethod</code> cannot be called and the name of <code>cls</code> is used in convention so other names instead of <code>cls</code> still work.</p>
</li>
</ul>
<h3><code>@staticmethod</code>:</h3>
<ul>
<li><p>can be called both by an object and directly by class name.</p>
</li>
<li><p>can call class variables and instance, class and static methods directly by class name but not instance variables.</p>
</li>
<li><p>doesn't need <code>self</code> or <code>cls</code>.</p>
</li>
</ul>
<p>*In detail, I also explain about <strong>instance method</strong> in <a href="https://stackoverflow.com/questions/46230482/what-is-an-instance-method-in-python/74482579#74482579"><strong>my answer</strong></a> for <a href="https://stackoverflow.com/questions/46230482/what-is-an-instance-method-in-python"><strong>What is an &quot;instance method&quot; in Python?</strong></a></p>
<h1><code>@classmethod</code>:</h1>
<p>For example, <code>@classmethod</code> can call the class variable and the instance, class and static methods both by <code>cls</code> and directly by class name and <code>@classmethod</code> can be called both by object and directly by class name as shown below:</p>
<pre class="lang-py prettyprint-override"><code>class Person:
    x = &quot;Hello&quot;
    def __init__(self, name):
        self.name = name
    
    @classmethod # Here
    def test1(cls):
        print(cls.x)   # Class variable by `cls`
        cls.test2(cls) # Instance method by `cls`
        cls.test3()    # Class method by `cls`
        cls.test4()    # Static method by `cls`
        print()
        print(Person.x)       # Class variable by class name
        Person.test2(&quot;Test2&quot;) # Instance method by class name
        Person.test3()        # Class method by class name
        Person.test4()        # Static method by class name
    
    def test2(self):
        print(&quot;Test2&quot;)
        
    @classmethod
    def test3(cls):
        print(&quot;Test3&quot;)
        
    @staticmethod
    def test4():
        print(&quot;Test4&quot;)

obj = Person(&quot;John&quot;)
obj.test1() # By object

# Or

Person.test1() # By class name
</code></pre>
<p>Output:</p>
<pre class="lang-none prettyprint-override"><code>Hello
Test2
Test3
Test4

Hello
Test2
Test3
Test4
</code></pre>
<p>And, <code>@classmethod</code> cannot call instance variables both by <code>cls</code> and directly by class name so if <code>@classmethod</code> tries to call the instance variable both by <code>cls</code> and directly by class name as shown below:</p>
<pre class="lang-py prettyprint-override"><code># ...
    
    @classmethod
    def test1(cls):
        print(cls.name) # Instance variable by `cls`
        
        # Or

        print(Person.name) # Instance variable by class name
# ...

obj = Person(&quot;John&quot;)
obj.test1()

# Or

Person.test1()
</code></pre>
<p>The error below occurs:</p>
<blockquote>
<p>AttributeError: type object 'Person' has no attribute 'name'</p>
</blockquote>
<p>And, if <code>@classmethod</code> doesn't have <code>cls</code>:</p>
<pre class="lang-py prettyprint-override"><code># ...
    
    @classmethod
    def test1(): # Without &quot;cls&quot;
        print(&quot;Test1&quot;)
  
# ...

obj = Person(&quot;John&quot;)
obj.test1()

# Or

Person.test1()
</code></pre>
<p><code>@classmethod</code> cannot be called, then the error below occurs as shown below:</p>
<blockquote>
<p>TypeError: test1() takes 0 positional arguments but 1 was given</p>
</blockquote>
<p>And, the name of <code>cls</code> is used in convention so other name instead of <code>cls</code> still work as shown below:</p>
<pre class="lang-py prettyprint-override"><code># ...

    @classmethod
    def test1(orange):
        print(orange.x)      # Class variable
        orange.test2(orange) # Instance method
        orange.test3()       # Class method
        orange.test4()       # Static method

# ...

obj = Person(&quot;John&quot;)
obj.test1()

# Or

Person.test1()
</code></pre>
<p>Output:</p>
<pre class="lang-none prettyprint-override"><code>Hello
Test2
Test3
Test4
</code></pre>
<h1><code>@staticmethod</code>:</h1>
<p>For example, <code>@staticmethod</code> can be called both by object and directly by class name as shown below:</p>
<pre class="lang-py prettyprint-override"><code>class Person:
    x = &quot;Hello&quot;
    def __init__(self, name):
        self.name = name

    @staticmethod # Here
    def test1():
        print(&quot;Test1&quot;)
    
    def test2(self):
        print(&quot;Test2&quot;)
        
    @classmethod
    def test3(cls):
        print(&quot;Test3&quot;)
        
    @staticmethod
    def test4():
        print(&quot;Test4&quot;)

obj = Person(&quot;John&quot;)
obj.test1() # By object

# Or

Person.test1() # By class name
</code></pre>
<p>Output:</p>
<pre class="lang-none prettyprint-override"><code>Test1
</code></pre>
<p>And, <code>@staticmethod</code> can call the class variable and the instance, class and static methods directly by class name but not instance variable as shown below:</p>
<pre class="lang-py prettyprint-override"><code># ...
    
    @staticmethod
    def test1():
        print(Person.x)       # Class variable
        Person.test2(&quot;Test2&quot;) # Instance method
        Person.test3()        # Class method
        Person.test4()        # Static method
            
# ...

obj = Person(&quot;John&quot;)
obj.test1()

# Or

Person.test1()
</code></pre>
<p>Output:</p>
<pre class="lang-none prettyprint-override"><code>Hello
Test2
Test3
Test4
</code></pre>
<p>And, if <code>@staticmethod</code> tries to call the instance variable as shown below:</p>
<pre class="lang-py prettyprint-override"><code># ...
    
    @staticmethod
    def test1():
        print(Person.name) # Instance variable
            
# ...

obj = Person(&quot;John&quot;)
obj.test1()

# Or

Person.test1()
</code></pre>
<p>The error below occurs:</p>
<blockquote>
<p>AttributeError: type object 'Person' has no attribute 'name'</p>
</blockquote>
<p>And, <code>@staticmethod</code> doesn't need <code>self</code> or <code>cls</code> so if <code>@staticmethod</code> has <code>self</code> or <code>cls</code>, you need to pass an argument as shown below:</p>
<pre class="lang-py prettyprint-override"><code># ...
    
    @staticmethod
    def test1(self): # With &quot;self&quot;
        print(self)

    # Or

    @staticmethod
    def test1(cls): # With &quot;cls&quot;
        print(cls)

# ...

obj = Person(&quot;John&quot;)
obj.test1(&quot;Test1&quot;) # With an argument

# Or

Person.test1(&quot;Test1&quot;) # With an argument
</code></pre>
<p>Output:</p>
<pre class="lang-none prettyprint-override"><code>Test1
</code></pre>
<p>Otherwise, if you don't pass an argument as shown below:</p>
<pre class="lang-py prettyprint-override"><code># ...
    
    @staticmethod
    def test1(self): # With &quot;self&quot;
        print(&quot;Test1&quot;)

    # Or

    @staticmethod
    def test1(cls): # With &quot;cls&quot;
        print(&quot;Test1&quot;)

# ...

obj = Person(&quot;John&quot;)
obj.test1() # Without an argument

# Or

Person.test1() # Without an argument
</code></pre>
<p>These errors below occur:</p>
<blockquote>
<p>TypeError: test1() missing 1 required positional argument: 'self'</p>
</blockquote>
<blockquote>
<p>TypeError: test1() missing 1 required positional argument: 'cls'</p>
</blockquote>
------------------------------------------------------------------ <br><h3> Thrastylon, Id: 76270065, Score: 1: </h3><p>There is no special upside of <code>@staticmethod</code> over <code>@classmethod</code>.
If you're starting a codebase from scratch and want to lean towards simplicity and consistency, just stick with <code>@classmethod</code>.</p>
<p>If you don't trust me, what about the creator of Python?</p>
<blockquote>
<p>Honestly, staticmethod was something of a mistake -- I was trying to
do something like Java class methods but once it was released I found
what was really needed was classmethod. But it was too late to get rid
of staticmethod.</p>
<p>— Guido van Rossum, <a href="https://mail.python.org/pipermail/python-ideas/2016-July/041189.html" rel="nofollow noreferrer"><em>RE: Good uses for staticmethod</em></a></p>
</blockquote>
------------------------------------------------------------------ <br><h3> mirek, Id: 60492563, Score: 0: </h3><p>staticmethod has no access to attibutes of the object, of the class, or of parent classes in the inheritance hierarchy.
It can be called at the class directly (without creating an object).</p>

<p>classmethod has no access to attributes of the object. It however can access attributes of the class and of parent classes in the inheritance hierarchy.
It can be called at the class directly (without creating an object). If called at the object then it is the same as normal method which doesn't access <code>self.&lt;attribute(s)&gt;</code> and accesses <code>self.__class__.&lt;attribute(s)&gt;</code> only.</p>

<p>Think we have a class with <code>b=2</code>, we will create an object and re-set this to <code>b=4</code> in it.
Staticmethod cannot access nothing from previous.
Classmethod can access <code>.b==2</code> only, via <code>cls.b</code>.
Normal method can access both: <code>.b==4</code> via <code>self.b</code> and <code>.b==2</code> via <code>self.__class__.b</code>.</p>

<p>We could follow the KISS style (keep it simple, stupid): Don't use staticmethods and classmethods, don't use classes without instantiating them, access only the object's attributes <code>self.attribute(s)</code>. There are languages where the OOP is implemented that way and I think it is not bad idea. :)</p>
<h4> mirek, Comment 107015531 Score: 0: </h4>One important thing more to classmethods: If you modify an attribute in the class method, all existing objects of this class which do not explicitly set this attribute will have the modified value.<br><h4> joel, Comment 112113419 Score: 0: </h4>the first sentence isn&#39;t <i>quite</i> true. a staticmethod can access public class members by specifying the class name, just as any caller could<br>------------------------------------------------------------------ <br><h3> Arpan Saini, Id: 68459641, Score: 0: </h3><p><strong>Definition of static method and class method from it's documentation. and When to use static method and when to use class method.</strong></p>
<ul>
<li><p><strong>Static method</strong> are like static method in java and C#, it won't use any initialize value of the class, all it need from outside to work fine.</p>
</li>
<li><p><strong>class method</strong>: are generally used for inheritance override, when we over-ride a method, and then we use CLS instance to tell if we want to call method of child or parent class. in case you want to use both the methods with same name and different signature.</p>
</li>
</ul>
<p>staticmethod(function) -&gt; method</p>
<pre><code>Convert a function to be a static method.

A static method does not receive an implicit first argument.
To declare a static method, use this idiom:

     class C:
         @staticmethod
         def f(arg1, arg2, ...):
             ...

It can be called either on the class (e.g. C.f()) or on an instance
(e.g. C().f()).  The instance is ignored except for its class.

Static methods in Python are similar to those found in Java or C++.
For a more advanced concept, see the classmethod builtin.
&quot;&quot;&quot;
</code></pre>
<p>classmethod(function) -&gt; method</p>
<pre><code>Convert a function to be a class method.

A class method receives the class as implicit first argument,
just like an instance method receives the instance.
To declare a class method, use this idiom:

  class C:
      @classmethod
      def f(cls, arg1, arg2, ...):
          ...

It can be called either on the class (e.g. C.f()) or on an instance
(e.g. C().f()).  The instance is ignored except for its class.
If a class method is called for a derived class, the derived class
object is passed as the implied first argument.

Class methods are different than C++ or Java static methods.
If you want those, see the staticmethod builtin.
</code></pre>
------------------------------------------------------------------ <br><h3> David Mendes, Id: 73852182, Score: 0: </h3><p>I'd like to add on top of all the previous answers the following, which is not official, but adheres to standards.</p>
<p>First of all you can look at always giving the least amount of privilege necessary. So if you don't need something specific to the instance, make it a class method. If you don't need something specific to the class, make it a static method.</p>
<p>Second thing is consider what you can communicate by the type of method that you make it. Static Method - helper function meant to be used outside of the class itself. Class function - can be called without instantiation however is meant to be used with that class only - otherwise would've been a static method ! Instance method - meant to be used only by instances.</p>
<p>This can help you in communicating patterns and how your code should be used.</p>
<pre><code>class Foo:
    @classmethod
    def bar(cls, id: int = None):
        query = session.query(
            a.id,
            a.name,
            a.address,
        )

        if id is not None:
            query = query.filter(a.id == id)

        return query
</code></pre>
<p>For example the above -- there is no reason why the method bar could not be static. However by making it a class method you communicate that it should be used by the class itself, as opposed it being a helper function meant to be used elsewhere !</p>
<p>Remember the above is not official, rather my personal preference</p>
------------------------------------------------------------------ <br><h3> Cathal Garvey, Id: 13920259, Score: -5: </h3><p>A quick hack-up ofotherwise identical methods in iPython reveals that <code>@staticmethod</code> yields marginal performance gains (in the nanoseconds), but otherwise it seems to serve no function. Also, any performance gains will probably be wiped out by the additional work of processing the method through <code>staticmethod()</code> during compilation (which happens prior to any code execution when you run a script).</p>

<p>For the sake of code readability I'd avoid <code>@staticmethod</code> unless your method will be used for loads of work, where the nanoseconds count.</p>
<h4> Keith Pinson, Comment 19189719 Score: 8: </h4>&quot;Otherwise seems to serve no function&quot;: not strictly true. See above discussion.<br>