 <h2> Title: Why is it string.join(list) instead of list.join(string)? </h2> <h3> Evan Fosmark, question_id: 493819 </h3>Score: 2085, Tags: {python,string,list} <br><p>This has always confused me. It seems like this would be nicer:</p>
<pre><code>[&quot;Hello&quot;, &quot;world&quot;].join(&quot;-&quot;)
</code></pre>
<p>Than this:</p>
<pre><code>&quot;-&quot;.join([&quot;Hello&quot;, &quot;world&quot;])
</code></pre>
<p>Is there a specific reason it is like this?</p>
<h4> Comment 99329739 Joshua Burns: </h4>I think the original idea is that because join() returns a string, it would have to be called from the string context. Putting join() on a list doesn&#39;t make a ton of sense in that a list is a container of objects and shouldn&#39;t have a one-off function specific to only strings.<br><h4> Comment 125013336 ntjess: </h4>Well, <code>str.split()</code> returns a non-string and makes quite a bit of sense. It seems like the same logic should be ok here, right? (Just talking about the conceptual problem of a non-string output)<br><h4> Comment 116053392 Zimri Leijen: </h4>I may be biased because I am used to javascript, but you want to join the list, it should be a method of list imo. It feels backwards.<br><h4> Comment 110256457 Arthur Tacca: </h4>@BallpointBen &quot;...because Python&#39;s type system isn&#39;t strong enough&quot; is exactly wrong. As Yoshiki Shibukawa&#39;s answer (from 8 years before you comment!) says, iterable.join() was considered as possibility but was rejected because it&#39;s a less good API design - not because it wasn&#39;t possible to implement.<br><h4> Comment 82224224 Wizard: </h4>For easy memory and understanding, <code>-</code> declares that you are joining a list and converting to a string.It&#39;s result oriented.<br><h4> Comment 129290501 Dogweather: </h4>@ntjess 100%. And the strongest argument for <code>sequence.join()</code> is real-world code. This is the flow of data. Something produced the sequence, which we now want to join. Nothing ever produces the separator. It always hard-coded by the programmer.<br><h4> Comment 118499724 Cheukting: </h4>I think it&#39;s because of the fact that &quot; <code>join</code> is a string method that results in a string&quot; makes more sense?<br><h4> Comment 133659522 gboffi: </h4>Is it the sequence that joins the string (the <code>my_items.join(&quot;; &quot;)</code> that&#39;s favored by the OP), or is the string that joins the (elements of the) sequence?<br><h4> Comment 133897322 ProfDFrancis: </h4>I generally say this is one of the two rare situations where Javascript is more sensible than Python (the other being the awkward <code>a = b if c else d</code>). However in light of the brilliant answer <a href="https://stackoverflow.com/a/493842/7549483">stackoverflow.com/a/493842/7549483</a> I think I can no longer say that.<br>------------------------------------------------------------------ <br><h3> Answer 493842 recursive: </h3><p>It's because any iterable can be joined (e.g, list, tuple, dict, set), but its contents and the &quot;joiner&quot; <em>must be</em> strings.</p>
<p>For example:</p>
<pre><code>'_'.join(['welcome', 'to', 'stack', 'overflow'])
'_'.join(('welcome', 'to', 'stack', 'overflow'))
</code></pre>
<pre><code>'welcome_to_stack_overflow'
</code></pre>
<p>Using something other than strings will raise the following error:</p>
<blockquote>
<p>TypeError: sequence item 0: expected str instance, int found</p>
</blockquote>
<h4> Comment 83484750 Eduardo Pignatelli: </h4>I do not agree conceptually even if It makes sense codewise. <code>list.join(string)</code> appears more an object-oriented approach whereas <code>string.join(list)</code> sounds much more procedural to me.<br><h4> Comment 86071241 Steen Sch&#252;tt: </h4>So why isn&#39;t it implemented on iterable?<br><h4> Comment 88588605 user4815162342: </h4>@TimeSheep Because iterable is not a concrete type, iterable is an interface, any type that defines an <code>__iter__</code> method. Requiring all iterables to also implement <code>join</code> would complicate a general interface (which also covers iterables over non-strings) for a very particular use case. Defining <code>join</code> on strins side-steps this problem at the cost of the &quot;unintuitive&quot; order. A better choice might have been to keep it a function with the first argument being the iterable and the second (optional one) being the joiner string - but that ship has sailed.<br><h4> Comment 88284542 pimgeek: </h4>I have tried to use <code>print(str.join(&#39;-&#39;, my_list))</code> and it works, feels better.<br><h4> Comment 86088477 recursive: </h4>@TimeSheep:  A list of integers doesn&#39;t have a meaningful join, even though it&#39;s iterable.<br><h4> Comment 92325651 user4815162342: </h4>@PerLundberg But then <i>every</i> iterable would sport a <code>join</code> method, even those where it makes no sense. For example, you&#39;d have a <code>file.join</code> that has nothing to do with files, generators would have a <code>join</code> method that is entirely unrelated to generators (and very dangerous with infinite ones). I am not familiar with Ruby, but I suspect it simply implements <code>join()</code> as a list method, not as a method on every single iterator.<br><h4> Comment 86619524 recursive: </h4>@krysopath:  It <i>can</i> be, but there are multiple such understandings.  Non-list iterables of strings need a way to be joined.  And lists of strings are iterables.  So it&#39;s possible to satisfy all the use cases with this single method.  Lists <i>could</i> have a join method, like in javascript, but there are plenty of use cases in python where the existing join method would still be needed.  And you can pretty trivially transform the existing one into what you&#39;re thinking. e.g. <code>&quot;, &quot;.join(map(str,numbers))</code>.<br><h4> Comment 86595562 krysopath: </h4>@recursive, I think an iterable of integers can be understood as string.<br><h4> Comment 92330020 Per Lundberg: </h4>@user4815162342 You are right, it is actually implemented on the <code>Array</code> class: <a href="https://ruby-doc.org/core-2.5.1/Array.html#method-i-join" rel="nofollow noreferrer">ruby-doc.org/core-2.5.1/Array.html#method-i-join</a>  Your reasoning might be correct, there&#39;s probably a good reason why they didn&#39;t choose that route (and also why Ruby didn&#39;t choose it either). I think I&#39;m now more in the camp of the &quot;many hard-core Python programmers&quot; mentioned in another answer to this question. :-)<br><h4> Comment 92319659 Per Lundberg: </h4>@user4815162342 Maybe this is the exact root cause here, that iterable is an interface instead of an abstract base class (with some non-abstract methods)? In that case, the base class would provide a reasonable, default implementation of <code>iterable.join</code> which implementers could override as needed. I&#39;m not <i>sure</i>, but I suspect this is how it works in Ruby (where [1,2,3].join` is supported)<br><h4> Comment 137052150 Dogweather: </h4>So it could be implemented both places. Seems like this is Python not heeding its own Zen: “practicality over purity”<br><h4> Comment 137070988 recursive: </h4>@Dogweather: &quot;There should be one-- and preferably only one --obvious way to do it.&quot;<br><h4> Comment 86627769 krysopath: </h4>@recursive, I think the words <code>&quot;joiner&quot; are always strings.</code> capture the essence very nicely. Your point about conventions is just true, though. I figure the reason might be the string handling/bytes encode/decode paradigm python has going on. A string is so very close to a sequence of numbers, thats why I was perhaps stating the obvious :)<br>------------------------------------------------------------------ <br><h3> Answer 12662361 Yoshiki Shibukawa: </h3><p>This was discussed in the <a href="http://mail.python.org/pipermail/python-dev/1999-June/095366.html" rel="nofollow noreferrer" title="String methods... finally">String methods... finally</a> thread in the Python-Dev achive, and was accepted by Guido. This thread began in Jun 1999, and <code>str.join</code> was included in Python 1.6 which was released in Sep 2000 (and supported Unicode). Python 2.0 (supported <code>str</code> methods including <code>join</code>) was released in Oct 2000.</p>
<ul>
<li>There were four options proposed in this thread:
<ul>
<li><code>separator.join(items)</code></li>
<li><code>items.join(separator)</code></li>
<li><code>items.reduce(separator)</code></li>
<li><code>join</code> as a built-in function</li>
</ul>
</li>
<li>Guido wanted to support not only <code>list</code>s and <code>tuple</code>s, but all sequences/iterables.</li>
<li><code>items.reduce(separator)</code> is difficult for newcomers.</li>
<li><code>items.join(separator)</code> introduces unexpected dependency from sequences to str/unicode.</li>
<li><code>join()</code> as a free-standing built-in function would support only specific data types. So using a built-in namespace is not good. If <code>join()</code> were to support many data types, creating an optimized implementation would be difficult: if implemented using the <code>__add__</code> method then it would be O(n²).</li>
<li>The separator string (<code>separator</code>) should not be omitted. Explicit is better than implicit.</li>
</ul>
<p>Here are some additional thoughts (my own, and my friend's):</p>
<ul>
<li>Unicode support was coming, but it was not final. At that time UTF-8 was the most likely about to replace UCS-2/-4. To calculate total buffer length for UTF-8 strings, the method needs to know the character encoding.</li>
<li>At that time, Python had already decided on a common sequence interface rule where a user could create a sequence-like (iterable) class. But Python didn't support extending built-in types until 2.2. At that time it was difficult to provide basic <code>iterable</code> class (which is mentioned in another comment).</li>
</ul>
<p>Guido's decision is recorded in a <a href="http://mail.python.org/pipermail/python-dev/1999-June/095436.html" rel="nofollow noreferrer" title="historical mail">historical mail</a>, deciding on <code>separator.join(items)</code>:</p>
<blockquote>
<p>Funny, but it does seem right!  Barry, go for it...  <br />
--Guido van Rossum</p>
</blockquote>
<h4> Comment 128856680 tschwab: </h4>This is the best answer, as it provides the authoritative background and reasons it was chosen.<br><h4> Comment 126376276 zdim: </h4>Nice, this documents the reasoning.  It&#39;d be nice to know more about the &quot;<i>unexpected dependency from sequences to str/unicode.</i>&quot; -- and whether that is still so.<br><h4> Comment 136454318 user3840170: </h4>@JasonC You can actually invoke it like that if you want: <code>str.join(&quot;,&quot;, [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;])</code> returns <code>&quot;a,b,c&quot;</code>.<br><h4> Comment 135054688 Jason C: </h4>@zdim the join method, if implemented on an iterable, would have to involve converting items to strings, which would introduce a str dependency from the iterable implementation. it will always be so.<br><h4> Comment 135054696 Jason C: </h4>i wonder why they didn&#39;t consider <code>string.join(sep, seq)</code> or similar. 🤷‍♂️<br>------------------------------------------------------------------ <br><h3> Answer 493884 Kiv: </h3><p>I agree that it's counterintuitive at first, but there's a good reason. Join can't be a method of a list because:</p>

<ul>
<li>it must work for different iterables too (tuples, generators, etc.) </li>
<li>it must have different behavior between different types of strings.</li>
</ul>

<p>There are actually two join methods (Python 3.0):</p>

<pre><code>&gt;&gt;&gt; b"".join
&lt;built-in method join of bytes object at 0x00A46800&gt;
&gt;&gt;&gt; "".join
&lt;built-in method join of str object at 0x00A28D40&gt;
</code></pre>

<p>If join was a method of a list, then it would have to inspect its arguments to decide which one of them to call. And you can't join byte and str together, so the way they have it now makes sense. </p>
------------------------------------------------------------------ <br><h3> Answer 29617379 Russia Must Remove Putin: </h3><blockquote>
<p>Why is it <code>string.join(list)</code> instead of <code>list.join(string)</code>?</p>
</blockquote>
<p>This is because <code>join</code> is a &quot;string&quot; method! It creates a string from any iterable. If we stuck the method on lists, what about when we have iterables that aren't lists?</p>
<p>What if you have a tuple of strings? If this were a <code>list</code> method, you would have to cast every such iterator of strings as a <code>list</code> before you could join the elements into a single string! For example:</p>
<pre><code>some_strings = ('foo', 'bar', 'baz')
</code></pre>
<p>Let's roll our own list join method:</p>
<pre><code>class OurList(list): 
    def join(self, s):
        return s.join(self)
</code></pre>
<p>And to use it, note that we have to first create a list from each iterable to join the strings in that iterable, wasting both memory and processing power:</p>
<pre><code>&gt;&gt;&gt; l = OurList(some_strings) # step 1, create our list
&gt;&gt;&gt; l.join(', ') # step 2, use our list join method!
'foo, bar, baz'
</code></pre>
<p>So we see we have to add an extra step to use our list method, instead of just using the builtin string method:</p>
<pre><code>&gt;&gt;&gt; ' | '.join(some_strings) # a single step!
'foo | bar | baz'
</code></pre>
<h2>Performance Caveat for Generators</h2>
<p>The algorithm Python uses to create the final string with <code>str.join</code> actually has to pass over the iterable twice, so if you provide it a generator expression, it has to materialize it into a list first before it can create the final string.</p>
<p>Thus, while passing around generators is usually better than list comprehensions, <code>str.join</code> is an exception:</p>
<pre><code>&gt;&gt;&gt; import timeit
&gt;&gt;&gt; min(timeit.repeat(lambda: ''.join(str(i) for i in range(10) if i)))
3.839168446022086
&gt;&gt;&gt; min(timeit.repeat(lambda: ''.join([str(i) for i in range(10) if i])))
3.339879313018173
</code></pre>
<p>Nevertheless, the <code>str.join</code> operation is still semantically a &quot;string&quot; operation, so it still makes sense to have it on the <code>str</code> object than on miscellaneous iterables.</p>
------------------------------------------------------------------ <br><h3> Answer 494320 Andy Dent: </h3><p>Think of it as the natural orthogonal operation to split.</p>

<p>I understand why it is applicable to anything iterable and so can't easily be implemented <em>just</em> on list.</p>

<p>For readability, I'd like to see it in the language but I don't think that is actually feasible - if iterability were an interface then it could be added to the interface but it is just a convention and so there's no central way to add it to the set of things which are iterable.</p>
------------------------------------------------------------------ <br><h3> Answer 47633307 Wizard: </h3><p><code>-</code> in <code>&quot;-&quot;.join(my_list)</code> declares that you are converting to a string from joining elements a list.It's result-oriented. (just for easy memory and understanding)</p>
<p>I made an exhaustive cheatsheet of methods_of_string for your reference.</p>
<pre><code>string_methods_44 = {
    'convert': ['join','split', 'rsplit','splitlines', 'partition', 'rpartition'],
    'edit': ['replace', 'lstrip', 'rstrip', 'strip'],
    'search': ['endswith', 'startswith', 'count', 'index', 'find','rindex', 'rfind',],
    'condition': ['isalnum', 'isalpha', 'isdecimal', 'isdigit', 'isnumeric','isidentifier',
                  'islower','istitle', 'isupper','isprintable', 'isspace', ],
    'text': ['lower', 'upper', 'capitalize', 'title', 'swapcase',
             'center', 'ljust', 'rjust', 'zfill', 'expandtabs','casefold'],
    'encode': ['translate', 'maketrans', 'encode'],
    'format': ['format', 'format_map']}
</code></pre>
------------------------------------------------------------------ <br><h3> Answer 493843 S.Lott: </h3><p>Primarily because the result of a <code>someString.join()</code> is a string.</p>

<p>The sequence (list or tuple or whatever) doesn't appear in the result, just a string.  Because the result is a string, it makes sense as a method of a string.</p>
------------------------------------------------------------------ <br><h3> Answer 58401587 fiftytwocards: </h3><p>The variables <code>my_list</code> and <code>"-"</code> are both objects. Specifically, they're instances of the classes <code>list</code> and <code>str</code>, respectively. The <code>join</code> function belongs to the class <code>str</code>. Therefore, the syntax <code>"-".join(my_list)</code> is used because the object <code>"-"</code> is taking <code>my_list</code> as an input.</p>
------------------------------------------------------------------ <br><h3> Answer 71337270 Francis Cagney: </h3><p>You can't only join lists and tuples. You can join almost any iterable.
And iterables include generators, maps, filters etc</p>
<pre><code>&gt;&gt;&gt; '-'.join(chr(x) for x in range(48, 55))
'0-1-2-3-4-5-6'

&gt;&gt;&gt; '-'.join(map(str, (1, 10, 100)))
'1-10-100'
</code></pre>
<p>And the beauty of using generators, maps, filters etc is that they cost little memory, and are created almost instantaneously.</p>
<p>Just another reason why it's conceptually:</p>
<pre><code>str.join(&lt;iterator&gt;)
</code></pre>
<p>It's efficient only granting str this ability. Instead of granting join to all the iterators: list, tuple, set, dict, generator, map, filter all of which only have object as common parent.</p>
<p>Of course range(), and zip() are also iterators, but they will never return str so they cannot be used with str.join()</p>
<pre><code>&gt;&gt;&gt; '-'.join(range(48, 55))
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
TypeError: sequence item 0: expected str instance, int found
</code></pre>
<h4> Comment 126377326 zdim: </h4>&quot;<i>Instead of granting join to all the iterators: [...], all of which only have object as common parent.</i>&quot;  -- this seems a sensible reason (to not have <code>iter.join()</code>)<br>------------------------------------------------------------------ <br><h3> Answer 73206761 Dogweather: </h3><p>I 100% agree with your issue. If we boil down all the answers and comments here, the explanation comes down to &quot;historical reasons&quot;.</p>
<p><code>str.join</code> isn't just confusing or not-nice looking, it's impractical in real-world code. It defeats readable function or method chaining because the separator is rarely (ever?) the result of some previous computation. In my experience, it's always a constant, hard-coded value like <code>&quot;, &quot;</code>.</p>
<p>I clean up my code — enabling reading it in one direction — using <code>tools.functoolz</code>:</p>
<pre class="lang-py prettyprint-override"><code>&gt;&gt;&gt; from toolz.functoolz import curry, pipe
&gt;&gt;&gt; join = curry(str.join)
&gt;&gt;&gt;
&gt;&gt;&gt; a = [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;]
&gt;&gt;&gt; pipe(
...     a, 
...     join(&quot;; &quot;)
&gt;&gt;&gt; )
'one; two; three'
</code></pre>
<p>I'll have several other functions in the pipe as well. The result is that it reads easily in just one direction, from beginning to end as a chain of functions. Currying <code>map</code> helps a lot.</p>
<h4> Comment 134667956 Dogweather: </h4>@user3840170 If you read to the end of the first paragraph, you&#39;ll see the actual answer I wrote.<br><h4> Comment 134660838 user3840170: </h4>“I agree” is not an answer to a “why” question.<br>