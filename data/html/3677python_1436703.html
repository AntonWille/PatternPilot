 <h2> Title: What is the difference between __str__ and __repr__? </h2> <h4> Casebash, question_id: 1436703 </h4>Score: 3677, Tags: {python,magic-methods,repr} <br><p>What is the difference between <a href="https://docs.python.org/3/reference/datamodel.html#object.__str__" rel="noreferrer"><code>__str__</code></a> and <a href="https://docs.python.org/3/reference/datamodel.html#object.__repr__" rel="noreferrer"><code>__repr__</code></a> in Python?</p>
------------------------------------------------------------------ <br><h3> moshez, Id: 2626364, Score: 3468: </h3>
<p><a href="https://stackoverflow.com/a/1436756/3798217">Alex Martelli summarized well</a> but, surprisingly, was too succinct.</p>
<p>First, let me reiterate the main points in <a href="https://stackoverflow.com/users/95810/alex-martelli">Alex</a>’s post:</p>
<ul>
<li>The default implementation is useless (it’s hard to think of one which wouldn’t be, but yeah)</li>
<li><code>__repr__</code> goal is to be unambiguous</li>
<li><code>__str__</code> goal is to be readable</li>
<li>Container’s <code>__str__</code> uses contained objects’ <code>__repr__</code></li>
</ul>
<p><strong>Default implementation is useless</strong></p>
<p>This is mostly a surprise because Python’s defaults tend to be fairly useful. However, in this case, having a default for <code>__repr__</code> which would act like:</p>
<pre class="lang-python prettyprint-override"><code>return &quot;%s(%r)&quot; % (self.__class__, self.__dict__)
</code></pre>
<p>would have been too dangerous (for example, too easy to get into infinite recursion if objects reference each other). So Python cops out. Note that there is one default which is true: if <code>__repr__</code> is defined, and <code>__str__</code> is not, the object will behave as though <code>__str__=__repr__</code>.</p>
<p>This means, in simple terms: almost every object you implement should have a functional <code>__repr__</code> that’s usable for understanding the object. Implementing <code>__str__</code> is optional: do that if you need a “pretty print” functionality (for example, used by a report generator).</p>
<p><strong>The goal of <code>__repr__</code> is to be unambiguous</strong></p>
<p>Let me come right out and say it — I do not believe in debuggers. I don’t really know how to use any debugger, and have never used one seriously. Furthermore, I believe that the big fault in debuggers is their basic nature — most failures I debug happened a long long time ago, in a galaxy far far away. This means that I do believe, with religious fervor, in logging. Logging is the lifeblood of any decent fire-and-forget server system. Python makes it easy to log: with maybe some project specific wrappers, all you need is a</p>
<pre class="lang-python prettyprint-override"><code>log(INFO, &quot;I am in the weird function and a is&quot;, a, &quot;and b is&quot;, b, &quot;but I got a null C — using default&quot;, default_c)
</code></pre>
<p>But you have to do the last step — make sure every object you implement has a useful repr, so code like that can just work. This is why the “eval” thing comes up: if you have enough information so <code>eval(repr(c))==c</code>, that means you know everything there is to know about <code>c</code>. If that’s easy enough, at least in a fuzzy way, do it. If not, make sure you have enough information about <code>c</code> anyway. I usually use an eval-like format: <code>&quot;MyClass(this=%r,that=%r)&quot; % (self.this,self.that)</code>. It does not mean that you can actually construct MyClass, or that those are the right constructor arguments — but it is a useful form to express “this is everything you need to know about this instance”.</p>
<p>Note: I used <code>%r</code> above, not <code>%s</code>. You always want to use <code>repr()</code> [or <code>%r</code> formatting character, equivalently] inside <code>__repr__</code> implementation, or you’re defeating the goal of repr. You want to be able to differentiate <code>MyClass(3)</code> and <code>MyClass(&quot;3&quot;)</code>.</p>
<p><strong>The goal of <code>__str__</code> is to be readable</strong></p>
<p>Specifically, it is not intended to be unambiguous — notice that <code>str(3)==str(&quot;3&quot;)</code>. Likewise, if you implement an IP abstraction, having the str of it look like 192.168.1.1 is just fine. When implementing a date/time abstraction, the str can be &quot;2010/4/12 15:35:22&quot;, etc. The goal is to represent it in a way that a user, not a programmer, would want to read it. Chop off useless digits, pretend to be some other class — as long is it supports readability, it is an improvement.</p>
<p><strong>Container’s <code>__str__</code> uses contained objects’ <code>__repr__</code></strong></p>
<p>This seems surprising, doesn’t it? It is a little, but how readable would it be if it used their <code>__str__</code>?</p>
<pre class="lang-python prettyprint-override"><code>[moshe is, 3, hello
world, this is a list, oh I don't know, containing just 4 elements]
</code></pre>
<p>Not very. Specifically, the strings in a container would find it way too easy to disturb its string representation. In the face of ambiguity, remember, Python resists the temptation to guess. If you want the above behavior when you’re printing a list, just</p>
<pre class="lang-python prettyprint-override"><code>print(&quot;[&quot; + &quot;, &quot;.join(lst) + &quot;]&quot;)
</code></pre>
<p>(you can probably also figure out what to do about dictionaries).</p>
<p><strong>Summary</strong></p>
<p>Implement <code>__repr__</code> for any class you implement. This should be second nature. Implement <code>__str__</code> if you think it would be useful to have a string version which errs on the side of readability.</p>
<h4> Samuel, Comment 45597487 Score: 366: </h4>Definitely disagree with your opinion that debugging isn&#39;t the way to go. For development use a debugger (and/or logging), for production use logging. With a debugger you have a view of everything that went wrong when the problem occurred. You can see the full picture. Unless you are logging EVERYTHING you can&#39;t get that. Plus if you are logging everything you&#39;re going have to wade through tons of data to get at what you want.<br><h4> ThatAintWorking, Comment 46649638 Score: 42: </h4>Great answer (except the bit about not using debuggers). I&#39;d just like to add a link to this <a href="http://stackoverflow.com/questions/1307014/python-str-versus-unicode">other Q&amp;A about <b>str</b> vs <b>unicode</b> in Python 3</a> which could be relevant to the discussion for people who have made the switch.<br><h4> RedGlyph, Comment 101141471 Score: 31: </h4>on debugger vs no debugger: don&#39;t get such entrenched opinions. In some applications debugging is not realistic, typically when real-time is involved, or when your code only executes remotely on a platform with little access or no console. In most other cases it will be much quicker to stop at an exception to investigate, or to set a breakpoint, because you don&#39;t have to go through thousands of lines of logging (which will clutter your disk and slow down the application). Finally, it&#39;s not always possible to log, for example on embedded devices, there debugger is your friend too.<br><h4> Marco Sulla, Comment 105654853 Score: 7: </h4>About debuggging vs logging, they are both useful. If a bug is reproducible, debugging is more simple. If the bug is randomic, logging is essential.<br><h4> joanis, Comment 119324524 Score: 7: </h4>A small update for recent versions of Python 3: you can use f-strings and still invoke the <code>__repr__</code> of data you embed, by adding <code>!r</code>: you can replace <code>&quot;MyClass(this=%r,that=%r)&quot; % (self.this,self.that)</code> by <code>f&quot;MyClass(this={self.this!r},that={self.that!r})&quot;</code>. Otherwise, thanks for this great post!<br><h4> NelsonGon, Comment 99893469 Score: 0: </h4>Is <code>eval(repr())</code> safe for use in say an API module that stores user passwords?<br><h4> Newbyte, Comment 136928822 Score: 0: </h4>I think the part about debuggers should be removed. It&#39;s not really relevant to the question asked or helpful. In my experience, it tends to be the case that people find debuggers unnecessary until they learn how to use them. Additionally it is possible to use debuggers even for failures that happened long ago in some cases (see coredumps).<br><h4> avimimoun, Comment 125389719 Score: 0: </h4>Meaby <code>return &quot;%s(**%r)&quot; % (self.__class__, self.__dict__)</code><br>------------------------------------------------------------------ <br><h3> Ned Batchelder, Id: 1438297, Score: 795: </h3><p>My rule of thumb:  <code>__repr__</code> is for developers, <code>__str__</code> is for customers.</p>
<h4> Naren Yellavula, Comment 98926405 Score: 25: </h4>This is true because for obj = uuid.uuid1(), obj.__str__() is &quot;2d7fc7f0-7706-11e9-94ae-0242ac110002&quot; and obj.__repr__() is &quot;UUID(&#39;2d7fc7f0-7706-11e9-94ae-0242ac110002&#39;)&quot;. Developers need (value + origin) whereas customers need a value and they don&#39;t care how they got it!<br><h4> Shiplu Mokaddim, Comment 105488427 Score: 14: </h4>Here <i>customer</i> may not necessarily mean end-user. It&#39;s the client or user of the object. So if its an SDK then the SDK developers will use <code>__str__</code> so normal developers have readable object. On the other hand, <code>__repr__</code> is for the SDK developers themselves.<br><h4> wjandrea, Comment 134543767 Score: 1: </h4>@Mark Customers can be technical too, like for example GParted exposes UUIDs for partitions (<a href="https://i.stack.imgur.com/qWpxa.png" rel="nofollow noreferrer">screenshot</a>). If you want an example that works for non-technical customers: <code>d = datetime.date.today()</code> str: <code>2023-05-20</code> repr: <code>datetime.date(2023, 5, 20)</code><br><h4> Mark Ransom, Comment 124456934 Score: 0: </h4>@NarenYellavula if you&#39;re exposing a UUID to a customer you&#39;re probably doing something wrong.<br><h4> Mark Ransom, Comment 126982587 Score: 0: </h4>@AbdessabourMtk they&#39;re overly complex, and there&#39;s no protection against typing them wrong.  Maybe in certain contexts like as part of a QR code they would be OK.<br>------------------------------------------------------------------ <br><h3> Alex Martelli, Id: 1436756, Score: 531: </h3><p>Unless you specifically act to ensure otherwise, most classes don't have helpful results for either:</p>
<pre><code>&gt;&gt;&gt; class Sic(object): pass
... 
&gt;&gt;&gt; print(str(Sic()))
&lt;__main__.Sic object at 0x8b7d0&gt;
&gt;&gt;&gt; print(repr(Sic()))
&lt;__main__.Sic object at 0x8b7d0&gt;
</code></pre>
<p>As you see -- no difference, and no info beyond the class and object's <code>id</code>.  If you only override one of the two:</p>
<pre><code>&gt;&gt;&gt; class Sic(object): 
...   def __repr__(self): return 'foo'
... 
&gt;&gt;&gt; print(str(Sic()))
foo
&gt;&gt;&gt; print(repr(Sic()))
foo
&gt;&gt;&gt; class Sic(object):
...   def __str__(self): return 'foo'
... 
&gt;&gt;&gt; print(str(Sic()))
foo
&gt;&gt;&gt; print(repr(Sic()))
&lt;__main__.Sic object at 0x2617f0&gt;
</code></pre>
<p>As you see, if you override <code>__repr__</code>, that's ALSO used for <code>__str__</code>, but not vice versa.</p>
<p>Other crucial tidbits to know: <code>__str__</code> on a built-on container uses the <code>__repr__</code>, NOT the <code>__str__</code>, for the items it contains. And, despite the words on the subject found in typical docs, hardly anybody bothers making the <code>__repr__</code> of objects be a string that <code>eval</code> may use to build an equal object (it's just too hard, AND not knowing how the relevant module was actually imported makes it actually flat out impossible).</p>
<p>So, my advice: focus on making <code>__str__</code> reasonably human-readable, and <code>__repr__</code> as unambiguous as you possibly can, even if that interferes with the fuzzy unattainable goal of making <code>__repr__</code>'s returned value acceptable as input to <code>eval</code>!</p>
<h4> Steven T. Snyder, Comment 9992427 Score: 53: </h4>In my unit tests I always check that <code>eval(repr(foo))</code> evaluates to an object equal to <code>foo</code>. You&#39;re right that it won&#39;t work outside of my test cases since I don&#39;t know how the module is imported, but this at least ensures that it works in <i>some</i> predictable context. I think this a good way of evaluating if the result of <code>__repr__</code> is explicit enough. Doing this in a unit test also helps ensure that <code>__repr__</code> follows changes to the class.<br><h4> abarnert, Comment 40619938 Score: 7: </h4>I always try to make sure that either <code>eval(repr(spam)) == spam</code> (at least in the right context), or <code>eval(repr(spam))</code> raises a <code>SyntaxError</code>. That way you avoid confusion. (And that&#39;s <i>almost</i> true for the builtins and most of the stdlib, except for, e.g., recursive lists, where <code>a=[]; a.append(a); print(eval(repr(a)))</code> gives you <code>[[Ellipses]]</code>…) Of course I don&#39;t do that to actually <i>use</i> <code>eval(repr(spam))</code>, except as a sanity check in unit tests… but I <i>do</i> sometimes copy and paste <code>repr(spam)</code> into an interactive session.<br><h4> djvg, Comment 115164858 Score: 2: </h4>@abarnert: for a custom <code>class Spam</code>, <code>eval(repr(spam)) == spam</code> would require <code>Spam.__eq__</code>to be implemented as well, right? By default <code>object.__eq__</code> uses <code>is</code> (<a href="https://docs.python.org/3/reference/datamodel.html#object.__eq__" rel="nofollow noreferrer">docs</a>).<br><h4> mtraceur, Comment 104635420 Score: 1: </h4>@SuperGeo Other answers cover this: container <code>str</code> use element <code>repr</code> because <code>[1, 2, 3]</code> != <code>[&quot;1&quot;, &quot;2, 3&quot;]</code>.<br><h4> SuperGeo, Comment 83919034 Score: 1: </h4>Why would not containers (lists, tuples) use  <code>__str__</code> for each element instead of <code>__repr__</code>? Seems plain wrong to me, as I implemented a readable <code>__str__</code> in my object and when it is part of a list I see the uglier <code>__repr__</code> instead.<br><h4> mtraceur, Comment 136925566 Score: 1: </h4>Phrased yet another way: the str is supposed to be something that&#39;s optimally human-friendly <i>by itself</i>, when it&#39;s already unambiguous where it starts and ends (like if you show the string in a GUI field) - a container&#39;s human-friendly string still usually needs to ensure that it&#39;s unambiguous about what it contains, so the convention is that a container&#39;s <code>str</code> calls <code>repr</code> on its elements.<br><h4> wjandrea, Comment 134543904 Score: 0: </h4><i>&quot;not knowing how the relevant module was actually imported makes it actually flat out impossible&quot;</i> -- For the record, the <a href="https://docs.python.org/3/reference/datamodel.html#object.__repr__" rel="nofollow noreferrer">official docs say</a>: <i>&quot;If at all possible, this should look like a valid Python expression that could be used to recreate an object with the same value (<b>given an appropriate environment</b>).&quot;</i> (added bold). So for example, if I do <code>collections.Counter([1, 1, 1])</code>, I get <code>Counter({1: 3})</code>, which can be recreated given <code>from collections import Counter</code>.<br><h4> Joe, Comment 136917174 Score: 0: </h4>@mtraceur, I don&#39;t understand your comment, since <code>repr(1) == str(1)</code>. How does using <code>repr</code> instead of <code>str</code> on the integers in that list make a difference?<br><h4> Joe, Comment 136917201 Score: 0: </h4>I did find a rejected PEP recommending that str(container) should call str(item) <a href="https://peps.python.org/pep-3140/" rel="nofollow noreferrer">here</a>.<br><h4> mtraceur, Comment 136925527 Score: 0: </h4>@Joe think about things being <i>not</i> as intended/expected - what if someone inserts a <i>string</i> into your container, and that string&#39;s value is <code>&quot;1, 2&quot;</code>? If for example you wrote the list class to call <code>str</code> instead of <code>repr</code> on its elements, you would <i>lie</i> to your users, presenting <code>[”1, 2&quot;]</code> <i>as if</i> it&#39;s <code>[1, 2]</code>. Calling <code>repr</code> on each element prevents destroying information and creating ambiguity like that.<br><h4> Joe, Comment 136935062 Score: 0: </h4>oh, I see, it&#39;s not <code>str</code> vs <code>repr</code> on ints that&#39;s the issue, since they&#39;re equal, it&#39;s <code>str</code> vs <code>repr</code> on the strings <code>&quot;1&quot;</code>, <code>&quot;2&quot;</code> and <code>&quot;3&quot;</code> that&#39;s the issue (in the example in your earlier comment), since they are not the same, and the former is the same as it would be on the ints.<br><h4> max, Comment 95167441 Score: 0: </h4>Just ran into an annoying bug related to the fact that <code>eval(repr(x))</code> fails even for builtin types: <code>class A(str, Enum): X = &#39;x&#39;</code> will raise SyntaxError on <code>eval(repr(A.X))</code>. It&#39;s sad, but understandable. BTW, <code>eval(str(A.X))</code> actually works, but of course only if <code>class A</code> is in scope -- so it&#39;s probably not very useful.<br><h4> DerMike, Comment 133062860 Score: 0: </h4>Interesting idea with the unit tests ... but when doing this, remember that each test is only as good as its ability to fail.<br>------------------------------------------------------------------ <br><h3> bitoffdev, Id: 19597196, Score: 216: </h3><blockquote>
  <p>In short, the goal of <code>__repr__</code> is to be unambiguous and <code>__str__</code> is to be
  readable.</p>
</blockquote>

<p>Here is a good example:</p>

<pre><code>&gt;&gt;&gt; import datetime
&gt;&gt;&gt; today = datetime.datetime.now()
&gt;&gt;&gt; str(today)
'2012-03-14 09:21:58.130922'
&gt;&gt;&gt; repr(today)
'datetime.datetime(2012, 3, 14, 9, 21, 58, 130922)'
</code></pre>

<p>Read this documentation for repr:</p>

<blockquote>
  <p><code>repr(object)</code></p>
  
  <p>Return a string containing a printable representation of an object. This is the same value yielded by conversions (reverse
  quotes). It is sometimes useful to be able to access this operation as
  an ordinary function. For many types, this function makes an attempt
  to return a string that would yield an object with the same value when
  passed to <code>eval()</code>, otherwise the representation is a string enclosed in
  angle brackets that contains the name of the type of the object
  together with additional information often including the name and
  address of the object. A class can control what this function returns
  for its instances by defining a <code>__repr__()</code> method.</p>
</blockquote>

<p>Here is the documentation for str:</p>

<blockquote>
  <p><code>str(object='')</code></p>
  
  <p>Return a string containing a nicely printable
  representation of an object. For strings, this returns the string
  itself. The difference with <code>repr(object)</code> is that <code>str(object)</code> does not
  always attempt to return a string that is acceptable to <code>eval()</code>; its
  goal is to return a printable string. If no argument is given, returns
  the empty string, <code>''</code>.</p>
</blockquote>
<h4> PSK0007, Comment 111199240 Score: 2: </h4>building upon the above example  by &quot;bitoffdev&quot; and  @deadly we can see how <b>str</b> is for the end user because it only gives us a readable string where as <b>repr</b> is fro developers because it gives us the value as well as the type.   If  you are looking for interview answers then it would be perfect.<br><h4> Vicrobot, Comment 90779593 Score: 2: </h4>What is the meaning of printable string here? Can you explain it please?<br>------------------------------------------------------------------ <br><h3> None, Id: 1436721, Score: 215: </h3><p><strong><code>__repr__</code></strong>: representation of python object usually eval will convert it back to that object</p>

<p><strong><code>__str__</code></strong>: is whatever you think is that object in text form</p>

<p>e.g.</p>

<pre><code>&gt;&gt;&gt; s="""w'o"w"""
&gt;&gt;&gt; repr(s)
'\'w\\\'o"w\''
&gt;&gt;&gt; str(s)
'w\'o"w'
&gt;&gt;&gt; eval(str(s))==s
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "&lt;string&gt;", line 1
    w'o"w
       ^
SyntaxError: EOL while scanning single-quoted string
&gt;&gt;&gt; eval(repr(s))==s
True
</code></pre>
<h4> Tarun Kumar, Comment 124693632 Score: 3: </h4>__repr__() : used to create &quot;constructor-like expression&quot; in string, so that eval() can re-construct an object back from this string representation   __str__() : used to create string containing a printable representation of an object<br>------------------------------------------------------------------ <br><h3> Russia Must Remove Putin, Id: 28132458, Score: 177: </h3><h2>What is the difference between <code>__str__</code> and <code>__repr__</code> in Python?</h2>
<p><code>__str__</code> (read as &quot;dunder (double-underscore) string&quot;) and <code>__repr__</code> (read as &quot;dunder-repper&quot; (for &quot;representation&quot;)) are both special methods that return strings based on the state of the object.</p>
<p><code>__repr__</code> provides backup behavior if <code>__str__</code> is missing.</p>
<p>So one should first write a <code>__repr__</code> that allows you to reinstantiate an equivalent object from the string it returns e.g. using <code>eval</code> or by typing it in character-for-character in a Python shell.</p>
<p>At any time later, one can write a <code>__str__</code> for a user-readable string representation of the instance, when one believes it to be necessary.</p>
<h3><code>__str__</code></h3>
<p>If you print an object, or pass it to <code>format</code>, <code>str.format</code>, or <code>str</code>, then if a <code>__str__</code> method is defined, that method will be called, otherwise, <code>__repr__</code> will be used.</p>
<h3><code>__repr__</code></h3>
<p>The <code>__repr__</code> method is called by the builtin function <code>repr</code> and is what is echoed on your python shell when it evaluates an expression that returns an object.</p>
<p>Since it provides a backup for <code>__str__</code>, if you can only write one, start with <code>__repr__</code></p>
<p>Here's the builtin help on <code>repr</code>:</p>
<pre><code>repr(...)
    repr(object) -&gt; string
    
    Return the canonical string representation of the object.
    For most object types, eval(repr(object)) == object.
</code></pre>
<p>That is, for most objects, if you type in what is printed by <code>repr</code>, you should be able to create an equivalent object. <em>But this is not the default implementation.</em></p>
<h3>Default Implementation of <code>__repr__</code></h3>
<p>The default object <code>__repr__</code> is (<a href="https://github.com/python/cpython/blob/v3.7.3/Objects/object.c#L496" rel="nofollow noreferrer">C Python source</a>) something like:</p>
<pre><code>def __repr__(self):
    return '&lt;{0}.{1} object at {2}&gt;'.format(
      type(self).__module__, type(self).__qualname__, hex(id(self)))
</code></pre>
<p>That means by default you'll print the module the object is from, the class name, and the hexadecimal representation of its location in memory - for example:</p>
<pre><code>&lt;__main__.Foo object at 0x7f80665abdd0&gt;
</code></pre>
<p>This information isn't very useful, but there's no way to derive how one might accurately create a canonical representation of any given instance, and it's better than nothing, at least telling us how we might uniquely identify it in memory.</p>
<h3>How can <code>__repr__</code> be useful?</h3>
<p>Let's look at how useful it can be, using the Python shell and <code>datetime</code> objects. First we need to import the <code>datetime</code> module:</p>
<pre><code>import datetime
</code></pre>
<p>If we call <code>datetime.now</code> in the shell, we'll see everything we need to recreate an equivalent datetime object. This is created by the datetime <code>__repr__</code>:</p>
<pre><code>&gt;&gt;&gt; datetime.datetime.now()
datetime.datetime(2015, 1, 24, 20, 5, 36, 491180)
</code></pre>
<p>If we print a datetime object, we see a nice human readable (in fact, ISO) format. This is implemented by datetime's <code>__str__</code>:</p>
<pre><code>&gt;&gt;&gt; print(datetime.datetime.now())
2015-01-24 20:05:44.977951
</code></pre>
<p>It is a simple matter to recreate the object we lost because we didn't assign it to a variable by copying and pasting from the <code>__repr__</code> output, and then printing it, and we get it in the same human readable output as the other object:</p>
<pre><code>&gt;&gt;&gt; the_past = datetime.datetime(2015, 1, 24, 20, 5, 36, 491180)
&gt;&gt;&gt; print(the_past)
2015-01-24 20:05:36.491180
</code></pre>
<h3>How do I implement them?</h3>
<p>As you're developing, you'll want to be able to reproduce objects in the same state, if possible. This, for example, is how the datetime object defines <code>__repr__</code> (<a href="https://github.com/python/cpython/blob/v3.7.3/Lib/datetime.py#L1876" rel="nofollow noreferrer">Python source</a>). It is fairly complex, because of all of the attributes needed to reproduce such an object:</p>
<pre><code>def __repr__(self):
    &quot;&quot;&quot;Convert to formal string, for repr().&quot;&quot;&quot;
    L = [self._year, self._month, self._day,  # These are never zero
         self._hour, self._minute, self._second, self._microsecond]
    if L[-1] == 0:
        del L[-1]
    if L[-1] == 0:
        del L[-1]
    s = &quot;%s.%s(%s)&quot; % (self.__class__.__module__,
                       self.__class__.__qualname__,
                       &quot;, &quot;.join(map(str, L)))
    if self._tzinfo is not None:
        assert s[-1:] == &quot;)&quot;
        s = s[:-1] + &quot;, tzinfo=%r&quot; % self._tzinfo + &quot;)&quot;
    if self._fold:
        assert s[-1:] == &quot;)&quot;
        s = s[:-1] + &quot;, fold=1)&quot;
    return s
</code></pre>
<p>If you want your object to have a more human readable representation, you can implement <code>__str__</code> next. Here's how the datetime object (<a href="https://github.com/python/cpython/blob/v3.7.3/Lib/datetime.py#L1895" rel="nofollow noreferrer">Python source</a>) implements <code>__str__</code>, which it easily does because it already has a function to display it in ISO format:</p>
<pre><code>def __str__(self):
    &quot;Convert to string, for str().&quot;
    return self.isoformat(sep=' ')
</code></pre>
<h4>Set <code>__repr__ = __str__</code>?</h4>
<p>This is a critique of another answer here that suggests setting <code>__repr__ = __str__</code>.</p>
<p>Setting <code>__repr__ = __str__</code> is silly - <code>__repr__</code> is a fallback for <code>__str__</code> and a <code>__repr__</code>, written for developers usage in debugging, should be written before you write a <code>__str__</code>.</p>
<p>You need a <code>__str__</code> only when you need a textual representation of the object.</p>
<h3>Conclusion</h3>
<p>Define <code>__repr__</code> for objects you write so you and other developers have a reproducible example when using it as you develop. Define <code>__str__</code> when you need a human readable string representation of it.</p>
<h4> Solomon Ucko, Comment 93999470 Score: 1: </h4>Shouldn&#39;t it be something along the lines of <code>type(obj).__qualname__</code>?<br><h4> Russia Must Remove Putin, Comment 94014066 Score: 0: </h4>@SolomonUcko yes in Python 3, that would seem to be the case - I&#39;ve been hunting down the source code where this is implemented and I&#39;ll update my answer with that information when I get it together.<br><h4> Gokul nath, Comment 125520621 Score: 0: </h4>This answer will be more helpful for beginners. Nice explanation!!<br><h4> G&#233;ry Ogam, Comment 126709060 Score: 0: </h4>I have changed <code>self.__module__</code> to <code>type(self).__module__</code> (since for exemple <code>3</code> has no <code>__module__</code>) and <code>type(self).__name__</code> to <code>type(self).__qualname__</code> (since for instance with <code>class A: class B: pass</code> that is what <code>repr(A.B())</code> returns).<br>------------------------------------------------------------------ <br><h3> Yong Yang, Id: 44099267, Score: 49: </h3><p>On page 358 of the book <strong><em>Python scripting for computational science</em></strong> by Hans Petter Langtangen, it clearly states that </p>

<ul>
<li>The <code>__repr__</code> aims at a complete string representation of the object;</li>
<li>The <code>__str__</code> is to return a nice string for printing.</li>
</ul>

<p>So, I prefer to understand them as</p>

<ul>
<li><strong>repr = reproduce</strong></li>
<li><strong>str = string (representation)</strong></li>
</ul>

<p>from the user's point of view
although this is a misunderstanding I made when learning python.</p>

<p>A small but good example is also given on the same page as follows:</p>

<h2>Example</h2>

<pre><code>In [38]: str('s')
Out[38]: 's'

In [39]: repr('s')
Out[39]: "'s'"

In [40]: eval(str('s'))
Traceback (most recent call last):

  File "&lt;ipython-input-40-abd46c0c43e7&gt;", line 1, in &lt;module&gt;
    eval(str('s'))

  File "&lt;string&gt;", line 1, in &lt;module&gt;

NameError: name 's' is not defined


In [41]: eval(repr('s'))
Out[41]: 's'
</code></pre>
<h4> NelsonGon, Comment 99893843 Score: 10: </h4>It&#39;s kind of misleading to refer to <code>repr</code> as reproduce. It is better to think of it as represent.<br><h4> Ace, Comment 136423232 Score: 1: </h4>@NelsonGon he is not totally wrong, docs say - &quot;this should look like a valid Python expression that could be used to recreate an object with the same value (given an appropriate environment). If this is not possible, a string of the form &lt;...some useful description...&gt; should be returned.&quot;  so it makes sense to in a way think of this as reproducing the object, as many have pointed out the use of  <code>eval</code><br><h4> jiten, Comment 94617094 Score: 0: </h4>It is at pg. #351.<br>------------------------------------------------------------------ <br><h3> Mangu Singh Rajpurohit, Id: 39382137, Score: 48: </h3><p>Apart from all the answers given, I would like to add few points :-</p>
<ol>
<li><p><code>__repr__()</code> is invoked when you simply write object's name on interactive python console and press enter.</p>
</li>
<li><p><code>__str__()</code> is invoked when you use object with print statement.</p>
</li>
<li><p>In case, if <code>__str__</code> is missing, then print and any function using <code>str()</code> invokes <code>__repr__()</code> of object.</p>
</li>
<li><p><code>__str__()</code> of containers, when invoked will execute <code>__repr__()</code> method of its contained elements.</p>
</li>
<li><p><code>str()</code> called within <code>__str__()</code> could potentially recurse without a base case, and error on maximum recursion depth.</p>
</li>
<li><p><code>__repr__()</code> can call <code>repr()</code> which will attempt to avoid infinite recursion automatically, replacing an already represented object with <code>...</code>.</p>
</li>
</ol>
<h4> wjandrea, Comment 136267381 Score: 0: </h4><i>&quot;<code>repr()</code> which will attempt to avoid infinite recursion automatically, replacing an already represented object with <code>...</code>&quot;</i> — Where did you get that from? It doesn&#39;t do that. Maybe you&#39;re thinking of <a href="//docs.python.org/3/library/reprlib.html#reprlib.recursive_repr" rel="nofollow noreferrer"><code>reprlib.recursive_repr</code></a><br>------------------------------------------------------------------ <br><h3> wescpy, Id: 63464185, Score: 38: </h3><p><strong>TL;DR:</strong></p>
<p><a href="https://i.stack.imgur.com/cpqeK.png" rel="nofollow noreferrer"><img src="https://i.stack.imgur.com/cpqeK.png" alt="Differences between str()/repr() and __str__()/__repr__()" /></a></p>
<p><strong>LONG</strong></p>
<p>When it comes down to the nitty-gritty, this question is analogous to asking the difference between the <code>str()</code> and <code>repr()</code> built-in functions. I'm going to describe the differences in my own words (which means I may be &quot;borrowing&quot; liberally from <a href="http://corepython.com" rel="nofollow noreferrer"><em>Core Python Programming</em></a> so please forgive me).</p>
<p><strong>Both</strong> <code>str()</code> and <code>repr()</code> have the same basic job: their goal is to return a string representation of a Python object. What <em>kind</em> of string representation is what differentiates them.</p>
<ul>
<li><code>str()</code> &amp; <code>__str__()</code> return a <em>printable</em> string representation of
an object... something human-readable/for human consumption</li>
<li><code>repr()</code> &amp; <code>__repr__()</code> return a string representation of an object that is a <em>valid Python expression</em>, an object you can pass to <code>eval()</code> or type into the Python shell without getting an error.</li>
</ul>
<p>For example, let's assign a string to <code>x</code> and an <code>int</code> to <code>y</code>, and simply showing human-readable string versions of each:</p>
<pre><code>&gt;&gt;&gt; x, y = 'foo', 123
&gt;&gt;&gt; str(x), str(y)
('foo', '123')
</code></pre>
<p>Can we take <strong>what is inside the quotes</strong> in both cases and enter them verbatim into the Python interpreter? Let's give it a try:</p>
<pre><code>&gt;&gt;&gt; 123
123
&gt;&gt;&gt; foo
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
NameError: name 'foo' is not defined
</code></pre>
<p>Clearly you can for an <code>int</code> but not necessarily for a <code>str</code>. Similarly, while I can pass <code>'123'</code> to <code>eval()</code>, that doesn't work for <code>'foo'</code>:</p>
<pre><code>&gt;&gt;&gt; eval('123')
123
&gt;&gt;&gt; eval('foo')
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
  File &quot;&lt;string&gt;&quot;, line 1, in &lt;module&gt;
NameError: name 'foo' is not defined
</code></pre>
<p>So this tells you the Python shell just <code>eval()</code>s what you give it. Now, let's <code>repr()</code> both expressions and see what we get. More specifically, take its output and dump <em>those</em> out in the interpreter (there's a point to this which we'll address afterwards):</p>
<pre><code>&gt;&gt;&gt; repr(x), repr(y)
(&quot;'foo'&quot;, '123')
&gt;&gt;&gt; 123
123
&gt;&gt;&gt; 'foo'
'foo'
</code></pre>
<p>Wow, they <em>both</em> work? That's because <code>'foo'</code>, while a printable string representation of that string, it's <strong>not</strong> evaluatable, but <code>&quot;'foo'&quot;</code> is. <code>123</code> is a valid Python <code>int</code> called by either <code>str()</code> or <code>repr()</code>. What happens when we call <code>eval()</code> with these?</p>
<pre><code>&gt;&gt;&gt; eval('123')
123
&gt;&gt;&gt; eval(&quot;'foo'&quot;)
'foo'
</code></pre>
<p>It works because <code>123</code> and <code>'foo'</code> are valid Python objects. Another key takeaway is that while sometimes both return the same thing (the same string representation), that's not always the case. (And yes, yes, I can go create a variable <code>foo</code> where the <code>eval()</code> works, but that's not the point.)</p>
<p><strong>More factoids about both pairs</strong></p>
<ol>
<li>Sometimes, <code>str()</code> and <code>repr()</code> are called <em>implicitly</em>, meaning they're called on behalf of users: when users use <code>print</code>, even if they don't call <code>str()</code> explicitly, such a call is made on their behalf before the object is displayed.</li>
<li>In the Python shell (interactive interpreter), if you enter a variable at the <code>&gt;&gt;&gt;</code> prompt and press RETURN, the interpreter displays the results of <code>repr()</code> implicitly called on that object.</li>
<li>To connect <code>str()</code> and <code>repr()</code> to <code>__str__()</code> and <code>__repr__()</code>, realize that calls to the built-in functions, i.e., <code>str(x)</code> or <code>repr(y)</code> result in calling their object's corresponding special methods: <code>x.__str__()</code> or <code>y.__repr__()</code></li>
<li>By implementing <code>__str__()</code> and <code>__repr__()</code> for <em>your</em> Python classes, you overload the built-in functions (<code>str()</code> and <code>repr()</code>), allowing instances of your classes to be passed in to <code>str()</code> and <code>repr()</code>. When such calls are made, they turn around and call the class' <code>__str__()</code> and <code>__repr__()</code> (per #3).</li>
</ol>
<h4> wjandrea, Comment 136267192 Score: 0: </h4><a href="//meta.stackoverflow.com/q/285551/4518341">Don&#39;t post pictures of text</a>. Stack Exchange supports <a href="/editing-help#tables">table formatting</a> now if you want to use that.<br><h4> wjandrea, Comment 136267252 Score: 0: </h4><i>&quot;<code>repr()</code> &amp; <code>__repr__()</code> return a string representation of an object that is a valid Python expression&quot;</i> — Not always. Yes it&#39;s a goal, but some objects can&#39;t be meaningfully represented, like <code>object</code> for example: <code>object()</code> → <code>&lt;object object at 0x7f4aa8b38f50&gt;</code>. I know other answers cover this and you&#39;re probably aware of it, but I found it strange you didn&#39;t mention it anywhere in this long explanation.<br><h4> Ace, Comment 136423055 Score: 0: </h4>@wjandrea you seem pretty good at editing posts, so you can edit the post and copy the entire table from image to markdown. not everyone has time to waste as you might have, the goal is to communicate the information and this image does it very well.<br>------------------------------------------------------------------ <br><h3> Zer0, Id: 34734815, Score: 17: </h3><p>To put it simply:</p>

<p><code>__str__</code> is used in to show a string representation of your object <strong>to be read easily</strong> by others.</p>

<p><code>__repr__</code> is used to show a string representation of <strong>the</strong> object.</p>

<p>Let's say I want to create a <code>Fraction</code> class where the string representation of a fraction is '(1/2)' and the object (Fraction class) is to be represented as 'Fraction (1,2)'</p>

<p>So we can create a simple Fraction class:</p>

<pre><code>class Fraction:
    def __init__(self, num, den):
        self.__num = num
        self.__den = den

    def __str__(self):
        return '(' + str(self.__num) + '/' + str(self.__den) + ')'

    def __repr__(self):
        return 'Fraction (' + str(self.__num) + ',' + str(self.__den) + ')'



f = Fraction(1,2)
print('I want to represent the Fraction STRING as ' + str(f)) # (1/2)
print('I want to represent the Fraction OBJECT as ', repr(f)) # Fraction (1,2)
</code></pre>
------------------------------------------------------------------ <br><h3> Casebash, Id: 1436706, Score: 15: </h3><p>From <a href="https://web.archive.org/web/20071127054034/http://pyref.infogami.com/__str__" rel="noreferrer">an (An Unofficial) Python Reference Wiki (archive copy)</a> by effbot:</p>

<p><code>__str__</code> "<em>computes the "informal" string representation of an object. This differs from <code>__repr__</code> in that it does not have to be a valid Python expression: a more convenient or concise representation may be used instead.</em>"</p>
<h4> Mad Physicist, Comment 80631615 Score: 4: </h4><code>__repr__</code> is by no means required to return a vaild Python expression.<br>------------------------------------------------------------------ <br><h3> asmeurer, Id: 13395755, Score: 14: </h3><p>In all honesty, <code>eval(repr(obj))</code> is never used. If you find yourself using it, you should stop, because <code>eval</code> is dangerous, and strings are a very inefficient way to serialize your objects (use <code>pickle</code> instead).</p>
<p>Therefore, I would recommend setting <code>__repr__ = __str__</code>. The reason is that <code>str(list)</code> calls <code>repr</code> on the elements (I consider this to be one of the biggest design flaws of Python that was not addressed by Python 3). An actual <code>repr</code> will probably not be very helpful as the output of <code>print([your, objects])</code>.</p>
<p>To qualify this, in my experience, the most useful use case of the <code>repr</code> function is to put a string inside another string (using string formatting). This way, you don't have to worry about escaping quotes or anything. But note that there is no <code>eval</code> happening here.</p>
<h4> jwg, Comment 37141861 Score: 26: </h4>I think this misses the point. The use of <code>eval(repr(obj))</code> is a sanity test and a rule of thumb - if this recreates the original object correctly then you have a decent <code>__repr__</code> implementation. It&#39;s not intended that you actually serialize objects this way.<br><h4> Luis Masuelli, Comment 59127770 Score: 10: </h4><code>eval</code> is not inherently dangerous. Is not more dangerous than <code>unlink</code>, <code>open</code>, or writing to files. Should we stop writing to files because perhaps a malicious attack could use an arbitrary file path to put content inside? Everything is dangerous if dumbly used by dumb people. Idiocy is dangerous. Dunning-Kruger effects are dangerous. <code>eval</code> is just a function.<br>------------------------------------------------------------------ <br><h3> Taufiq Rahman, Id: 40960730, Score: 12: </h3><p><code>str</code> - Creates a new string object from the given object.</p>

<p><code>repr</code> - Returns the canonical string representation of the object.</p>

<p>The differences:</p>

<p><strong>str():</strong></p>

<ul>
<li>makes object readable</li>
<li>generates output for end-user</li>
</ul>

<p><strong>repr():</strong></p>

<ul>
<li>needs code that reproduces object</li>
<li>generates output for developer</li>
</ul>
------------------------------------------------------------------ <br><h3> JonnyRobbie, Id: 68665826, Score: 10: </h3><p>You can get some insight from this code:</p>
<pre><code>class Foo:
    def __repr__(self):
        return &quot;repr&quot;

    def __str__(self):
        return &quot;str&quot;

foo = Foo()
foo  # repr
print(foo)  # str
</code></pre>
------------------------------------------------------------------ <br><h3> Ijaz Ahmad, Id: 43207419, Score: 9: </h3><p>From the book <em>Fluent Python</em>:</p>
<blockquote>
<p>A basic requirement for a Python object is to provide usable
string   representations of itself, one used for debugging and
logging, another for presentation to end users. That is why the
special methods <code>__repr__</code> and <code>__str__</code> exist in the data model.</p>
</blockquote>
------------------------------------------------------------------ <br><h3> bluenote10, Id: 44201752, Score: 9: </h3><p>One aspect that is missing in other answers. It's true that in general the pattern is:</p>

<ul>
<li>Goal of <code>__str__</code>: human-readable</li>
<li>Goal of <code>__repr__</code>: unambiguous, possibly machine-readable via <code>eval</code></li>
</ul>

<p>Unfortunately, this differentiation is flawed, because the Python REPL and also IPython use <code>__repr__</code> for printing objects in a REPL console (see related questions for <a href="https://stackoverflow.com/questions/28304092/when-i-am-in-the-python-or-ipython-console-what-is-called-when-i-am-returned-an">Python</a> and <a href="https://stackoverflow.com/questions/41453624/tell-ipython-to-use-an-objects-str-instead-of-repr-for-output">IPython</a>). Thus, projects which are targeted for interactive console work (e.g., Numpy or Pandas) have started to ignore above rules and provide a human-readable <code>__repr__</code> implementation instead.</p>
------------------------------------------------------------------ <br><h3> prosti, Id: 56481986, Score: 9: </h3><p><code>__str__</code> can be invoked on an object by calling <code>str(obj)</code> and should return a human readable string. </p>

<p><code>__repr__</code> can be invoked on an object by calling <code>repr(obj)</code> and should return internal object (object fields/attributes)</p>

<p>This example may help:</p>

<pre><code>class C1:pass

class C2:        
    def __str__(self):
        return str(f"{self.__class__.__name__} class str ")

class C3:        
    def __repr__(self):        
         return str(f"{self.__class__.__name__} class repr")

class C4:        
    def __str__(self):
        return str(f"{self.__class__.__name__} class str ")
    def __repr__(self):        
         return str(f"{self.__class__.__name__} class repr")


ci1 = C1()    
ci2 = C2()  
ci3 = C3()  
ci4 = C4()

print(ci1)       #&lt;__main__.C1 object at 0x0000024C44A80C18&gt;
print(str(ci1))  #&lt;__main__.C1 object at 0x0000024C44A80C18&gt;
print(repr(ci1)) #&lt;__main__.C1 object at 0x0000024C44A80C18&gt;
print(ci2)       #C2 class str
print(str(ci2))  #C2 class str
print(repr(ci2)) #&lt;__main__.C2 object at 0x0000024C44AE12E8&gt;
print(ci3)       #C3 class repr
print(str(ci3))  #C3 class repr
print(repr(ci3)) #C3 class repr
print(ci4)       #C4 class str 
print(str(ci4))  #C4 class str 
print(repr(ci4)) #C4 class repr
</code></pre>
------------------------------------------------------------------ <br><h3> BattleDrum, Id: 31427937, Score: 6: </h3><pre><code>&gt;&gt;&gt; print(decimal.Decimal(23) / decimal.Decimal("1.05"))
21.90476190476190476190476190
&gt;&gt;&gt; decimal.Decimal(23) / decimal.Decimal("1.05")
Decimal('21.90476190476190476190476190')
</code></pre>

<p>When <code>print()</code> is called on the result of <code>decimal.Decimal(23) / decimal.Decimal("1.05")</code> the raw number is printed; this output is in <strong>string form</strong> which can be achieved with <code>__str__()</code>. If we simply enter the expression we get a <code>decimal.Decimal</code> output — this output is in <strong>representational form</strong> which can be achieved with <code>__repr__()</code>. All Python objects have two output forms. String form is designed to be human-readable. The representational form is designed to produce output that if fed to a Python interpreter would (when possible) reproduce the represented object.</p>
------------------------------------------------------------------ <br><h3> orome, Id: 33421226, Score: 6: </h3><p>The difference between <code>__str__</code> and <code>__repr__</code> for me boils down to the former being readable even by an end user, and the latter being as useful as possible to developers. Given that, I find that the default implementation of <code>__repr__</code> often fails to achieve this goal because it <em>omits</em> information useful to developers.</p>
<p>For this reason, if I have a simple enough <code>__str__</code>, I generally just try to get the best of both worlds with something like:</p>
<pre><code>def __repr__(self):
    return '{0} ({1})'.format(object.__repr__(self), str(self))
</code></pre>
------------------------------------------------------------------ <br><h3> zangw, Id: 33727876, Score: 5: </h3><blockquote>
  <p>One important thing to keep in mind is that container's <code>__str__</code> uses contained objects' <code>__repr__</code>.</p>
</blockquote>

<pre><code>&gt;&gt;&gt; from datetime import datetime
&gt;&gt;&gt; from decimal import Decimal
&gt;&gt;&gt; print (Decimal('52'), datetime.now())
(Decimal('52'), datetime.datetime(2015, 11, 16, 10, 51, 26, 185000))
&gt;&gt;&gt; str((Decimal('52'), datetime.now()))
"(Decimal('52'), datetime.datetime(2015, 11, 16, 10, 52, 22, 176000))"
</code></pre>

<p><em>Python favors unambiguity over readability</em>, the <code>__str__</code> call of a <code>tuple</code> calls the contained objects' <code>__repr__</code>, the <em>"formal"</em> representation of an object. Although the formal representation is harder to read than an informal one, it is unambiguous and more robust against bugs.</p>
<h4> jiten, Comment 94618177 Score: 0: </h4>It uses <code>__repr__</code>  when it (<code>__str__</code> ) is not defined! So, you are wrong.<br>------------------------------------------------------------------ <br><h3> ShadowWalker, Id: 49447574, Score: 5: </h3><p>In a nutshell:</p>

<pre class="lang-py prettyprint-override"><code>class Demo:
  def __repr__(self):
    return 'repr'
  def __str__(self):
    return 'str'

demo = Demo()
print(demo) # use __str__, output 'str' to stdout

s = str(demo) # __str__ is used, return 'str'
r = repr(demo) # __repr__ is used, return 'repr'

import logging
logger = logging.getLogger(logging.INFO)
logger.info(demo) # use __str__, output 'str' to stdout

from pprint import pprint, pformat
pprint(demo) # use __repr__, output 'repr' to stdout
result = pformat(demo) # use __repr__, result is string which value is 'str'
</code></pre>
------------------------------------------------------------------ <br><h3> Wizard, Id: 47690304, Score: 4: </h3><p>Understand <code>__str__</code> and <code>__repr__</code> intuitively and permanently distinguish them at all.</p>

<p><code>__str__</code> return the string disguised body of a given object for readable of eyes<br>
<code>__repr__</code> return the real flesh body of a given object (return itself) for unambiguity to identify.</p>

<p>See it in an example</p>

<pre><code>In [30]: str(datetime.datetime.now())
Out[30]: '2017-12-07 15:41:14.002752'
Disguised in string form
</code></pre>

<p>As to <code>__repr__</code></p>

<pre><code>In [32]: datetime.datetime.now()
Out[32]: datetime.datetime(2017, 12, 7, 15, 43, 27, 297769)
Presence in real body which allows to be manipulated directly.
</code></pre>

<p>We can do arithmetic operation on <code>__repr__</code> results conveniently.</p>

<pre><code>In [33]: datetime.datetime.now()
Out[33]: datetime.datetime(2017, 12, 7, 15, 47, 9, 741521)
In [34]: datetime.datetime(2017, 12, 7, 15, 47, 9, 741521) - datetime.datetime(2
    ...: 017, 12, 7, 15, 43, 27, 297769)
Out[34]: datetime.timedelta(0, 222, 443752)
</code></pre>

<p>if apply the operation on <code>__str__</code></p>

<pre><code>In [35]: '2017-12-07 15:43:14.002752' - '2017-12-07 15:41:14.002752'
TypeError: unsupported operand type(s) for -: 'str' and 'str'
</code></pre>

<p>Returns nothing but error.</p>

<p>Another example.</p>

<pre><code>In [36]: str('string_body')
Out[36]: 'string_body' # in string form

In [37]: repr('real_body')
Out[37]: "'real_body'" #its real body hide inside
</code></pre>

<p>Hope this help you build concrete grounds to explore more answers.</p>
------------------------------------------------------------------ <br><h3> techkuz, Id: 50229578, Score: 3: </h3><p><code>__repr__</code> is used everywhere, except by <code>print</code> and <code>str</code> methods (when a <code>__str__</code>is defined !)</p>
------------------------------------------------------------------ <br><h3> Sampath, Id: 55744921, Score: 3: </h3><ol>
<li><code>__str__</code> must return string object whereas <code>__repr__</code> can return any python expression.</li>
<li>If <code>__str__</code> implementation is missing then <code>__repr__</code> function is used as fallback. There is no fallback if <code>__repr__</code> function implementation is missing.</li>
<li>If <code>__repr__</code> function is returning String representation of the object, we can skip implementation of <code>__str__</code> function.</li>
</ol>

<p>Source: <a href="https://www.journaldev.com/22460/python-str-repr-functions" rel="nofollow noreferrer">https://www.journaldev.com/22460/python-str-repr-functions</a></p>
<h4> wjandrea, Comment 136267300 Score: 0: </h4><i>&quot;<code>__repr__</code> can return any python expression&quot;</i> — Where did you get that from? <code>__repr__</code> also needs to return a string, plus expressions are elements of syntax, not objects, so they can&#39;t be &quot;returned&quot;.<br><h4> wjandrea, Comment 136267305 Score: 0: </h4><i>&quot;There is no fallback if <code>__repr__</code> function implementation is missing.&quot;</i> — There is a fallback: <code>object.__repr__</code><br>------------------------------------------------------------------ <br><h3> Yilmaz, Id: 65164408, Score: 3: </h3><p>Every object inherits <code>__repr__</code>  from the base class that all objects created.</p>
<pre><code>class Person:
     pass

p=Person()
</code></pre>
<p>if you call <code>repr(p)</code> you will get this as default:</p>
<pre><code> &lt;__main__.Person object at 0x7fb2604f03a0&gt;
</code></pre>
<p>But if you call <code>str(p)</code> you will get the same output. it is because when <code>__str__</code> does not exist, Python calls <code>__repr__</code></p>
<p>Let's implement our own <code>__str__</code></p>
<pre><code>class Person:
    def __init__(self,name,age):
        self.name=name
        self.age=age
    def __repr__(self):
        print(&quot;__repr__ called&quot;)
        return f&quot;Person(name='{self.name}',age={self.age})&quot;

p=Person(&quot;ali&quot;,20)
</code></pre>
<p><code>print(p)</code> and <code>str(p)</code>will return</p>
<pre><code> __repr__ called
     Person(name='ali',age=20)
</code></pre>
<p>let's add <code>__str__()</code></p>
<pre><code>class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age
        
    def __repr__(self):
        print('__repr__ called')
        return f&quot;Person(name='{self.name}, age=self.age')&quot;
    
    def __str__(self):
        print('__str__ called')
        return self.name

p=Person(&quot;ali&quot;,20)
</code></pre>
<p>if we call <code>print(p)</code> and str(p), it will call <code>__str__()</code> so it will return</p>
<pre><code>__str__ called
ali
</code></pre>
<p><code>repr(p)</code> will return</p>
<p><strong>repr</strong> called
&quot;Person(name='ali, age=self.age')&quot;</p>
<p>Let's omit <code>__repr__</code> and just implement <code>__str__</code>.</p>
<pre><code>class Person:
def __init__(self, name, age):
    self.name = name
    self.age = age

def __str__(self):
    print('__str__ called')
    return self.name

p=Person('ali',20)
</code></pre>
<p><code>print(p)</code> will look for the <code>__str__</code> and will return:</p>
<pre><code>__str__ called
ali
</code></pre>
<p>NOTE= if we had <code>__repr__</code> and <code>__str__</code> defined, <code>f'name is {p}'</code> would call <code>__str__</code></p>
------------------------------------------------------------------ <br><h3> Vlad Bezden, Id: 72027825, Score: 3: </h3><blockquote>
<p>Programmers with prior experience in languages with a <code>toString</code> method tend to implement <code>__str__</code> and not <code>__repr__</code>.
If you only implement one of these special methods in Python, choose <code>__repr__</code>.</p>
</blockquote>
<p>From <a href="https://rads.stackoverflow.com/amzn/click/com/B09WZJMMJP" rel="nofollow noreferrer" rel="nofollow noreferrer">Fluent Python</a> book, by Ramalho, Luciano.</p>
------------------------------------------------------------------ <br><h3> Shaiful Islam, Id: 73923738, Score: 2: </h3><p>repr() used when we debug or log.It is used for developers to understand code.
one the other hand str() user for non developer like(QA) or user.<br></p>
<pre><code>class Customer:
    def __init__(self,name):
        self.name = name
    def __repr__(self):
        return &quot;Customer('{}')&quot;.format(self.name)
    def __str__(self):
        return f&quot;cunstomer name is {self.name}&quot;

cus_1 = Customer(&quot;Thusi&quot;)
print(repr(cus_1)) #print(cus_1.__repr__()) 
print(str(cus_1)) #print(cus_1.__str__())
</code></pre>
------------------------------------------------------------------ <br><h3> barii, Id: 72238659, Score: 0: </h3><p>Basically <code>__str__</code> or <strong>str()</strong> is used for creating output that is human-readable are must be for end-users.
On the other hand, <strong>repr()</strong> or <code>__repr__</code> mainly returns canonical string representation of objects which serve the purpose of debugging and development helps the programmers.</p>
<h4> wjandrea, Comment 136271695 Score: 0: </h4><i>&quot;<code>__str__</code> or <code>str()</code> is&quot;</i> — Do you mean &quot;<code>__str__</code> and <code>str()</code> are&quot;? They&#39;re not the same thing.<br>