 <h2> Title: What&#39;s the canonical way to check for type in Python? </h2> <h4> Herge, question_id: 152580 </h4>Score: 1872, Tags: {python,types} <br><p>How do I check if an object is of a given type, or if it inherits from a given type?</p>
<p>How do I check if the object <code>o</code> is of type <code>str</code>?</p>
<hr />
<p><sub>Beginners often wrongly expect the string to <em>already be</em> &quot;a number&quot; - either expecting Python 3.x <code>input</code> to convert type, or expecting that a string like <code>'1'</code> is <em>also simultaneously</em> an integer. This is the wrong canonical for those questions. Please carefully read the question and then use <a href="https://stackoverflow.com/questions/354038">How do I check if a string represents a number (float or int)?</a>, <a href="https://stackoverflow.com/questions/20449427/">How can I read inputs as numbers?</a> and/or <a href="https://stackoverflow.com/questions/23294658/">Asking the user for input until they give a valid response</a> as appropriate.</sub></p>
<h4> Sheena, Id: 93357935 Score: 7: </h4>Python type annotations are now a thing. Take a look at <a href="https://mypy.readthedocs.io/en/stable/index.html" rel="nofollow noreferrer">mypy</a><br><h4> clacke, Id: 64655384 Score: 7: </h4>It seems the most common reason for asking for this is that one wants to distinguish between strings and iterables of strings. This is a tricky question because strings <i>are</i> iterables of strings -- a single-character string is even a sequence of itself (last time I checked -- one probably shouldn&#39;t rely on it). But would anyone ever have use for something string-like? <b><a href="https://pypi.python.org/pypi/stringlike" rel="nofollow noreferrer">Yes</a></b>. So the answer to &quot;What should I do to distinguish between strings and other iterables of strings?&quot; is properly: &quot;It depends on what you are trying to do&quot;. :-D<br><h4> Karl Knechtel, Id: 130104262 Score: 2: </h4>@clacke A single-character string is still a sequence of itself in 2022, and has been for as far back as I can determine; and the behaviour is a <i>necessary consequence</i> of strings being iterables over the characters (technically, Unicode code points) in them, plus the <i>lack of a separate type</i> for those individual characters.<br>------------------------------------------------------------------ <br><h3> Ultrablendz, Id: 62122230, Score: -5: </h3><p>A simple way to check type is to compare it with something whose type you know.</p>

<pre><code>&gt;&gt;&gt; a  = 1
&gt;&gt;&gt; type(a) == type(1)
True
&gt;&gt;&gt; b = 'abc'
&gt;&gt;&gt; type(b) == type('')
True
</code></pre>
------------------------------------------------------------------ <br><h3> Fredrik Johansson, Id: 152596, Score: 2199: </h3><p>Use <a href="https://docs.python.org/library/functions.html#isinstance" rel="noreferrer"><code>isinstance</code></a> to check if <code>o</code> is an instance of <code>str</code> or any subclass of <code>str</code>:</p>
<pre><code>if isinstance(o, str):
</code></pre>
<p>To check if the type of <code>o</code> is exactly <code>str</code>, <em>excluding subclasses of <code>str</code></em>:</p>
<pre><code>if type(o) is str:
</code></pre>
<p>See <a href="http://docs.python.org/library/functions.html" rel="noreferrer">Built-in Functions</a> in the Python Library Reference for relevant information.</p>
<hr />
<h4>Checking for strings in Python 2</h4>
<p>For Python 2, this is a better way to check if <code>o</code> is a string:</p>
<pre><code>if isinstance(o, basestring):
</code></pre>
<p>because this will also catch Unicode strings. <a href="https://docs.python.org/2/library/functions.html#unicode" rel="noreferrer"><code>unicode</code></a> is not a subclass of <code>str</code>; both <code>str</code> and <code>unicode</code> are subclasses of <a href="https://docs.python.org/2/library/functions.html#basestring" rel="noreferrer"><code>basestring</code></a>. In Python 3, <code>basestring</code> no longer exists since there's <a href="https://docs.python.org/whatsnew/3.0.html#text-vs-data-instead-of-unicode-vs-8-bit" rel="noreferrer">a strict separation</a> of strings (<a href="https://docs.python.org/3/library/functions.html#func-str" rel="noreferrer"><code>str</code></a>) and binary data (<a href="https://docs.python.org/3/library/functions.html#func-bytes" rel="noreferrer"><code>bytes</code></a>).</p>
<p>Alternatively, <code>isinstance</code> accepts a tuple of classes. This will return <code>True</code> if <code>o</code> is an instance of any subclass of any of <code>(str, unicode)</code>:</p>
<pre><code>if isinstance(o, (str, unicode)):
</code></pre>
<h4> Thomas Wouters, Comment 45451 Score: 33: </h4>str.__subclasses__() only returns the direct subclasses of str, and does not do the same thing as issubclass() or isinstance(). (To do that, you would have to recursively call .__subclasses__().<br><h4> Jon Coombs, Comment 43305524 Score: 19: </h4>This is a good answer, but I think it really ought to start with a warning that you usually shouldn&#39;t be doing this in Python. As it is, it seems to validate the assumption that this is a &quot;canonical thing to do in Python&quot;, which it isn&#39;t.<br><h4> mavavilj, Comment 74565131 Score: 6: </h4>What&#39;s the difference between instance and &quot;exactly&quot;? If <code>type(a) is Object</code> then isn&#39;t it also true that <code>isinstance(a, Object)</code>. However, if <code>type(a) is SubClassOfObject</code>, then  <code>type(a) is Object == False</code>, but <code>isinstance(a, Object) == True</code>. Right?<br><h4> BallpointBen, Comment 110933633 Score: 3: </h4>@JonCoombs According to the rationale of <a href="https://www.python.org/dev/peps/pep-0622/#rationale-and-goals" rel="nofollow noreferrer">PEP 622</a>, <code>isinstance()</code> is the second most called builtin function, after <code>len()</code>. I think we have to accept that <code>isinstance</code> is de facto canonical Python.<br><h4> Terry Brown, Comment 75924507 Score: 2: </h4>@mavavilj - <code>a is b</code> means a and b are the exact same thing, i.e. references to the same entity in memory.  So <code>a</code> and <code>b</code> would have to be the exact same class, not subclasses, as with <code>isinstance()</code>.  See for example <a href="https://stackoverflow.com/a/133024/1072212">stackoverflow.com/a/133024/1072212</a><br><h4> ShadowRanger, Comment 131333028 Score: 1: </h4>@paxdiablo: Yep, inheriting from <code>ABC</code> and defining at least one <code>@abstractmethod</code> is the way to do this for most use cases (where preventing instantiation of the base class is because you know it lacks necessary functionality that subclasses must implement). Regardless, Jon Coombs is right, you shouldn&#39;t <i>usually</i> do this. There are cases where it&#39;s needed (type-checking arguments to <code>__init__</code> can be good, to establish invariants for attributes, rather than having things fail long after the mistake where the wrong types were passed), but <i>most</i> of the time, duck-typing is the way to go.<br><h4> paxdiablo, Comment 120094207 Score: 0: </h4>@JonCoombs, I realise this is a long time coming, but I&#39;ve recently had a need in Python to do exactly that. It&#39;s a neat way to prevent instantiation of base classes (have the dunder-new method throw an exception if the class type being allocated is the base class). There may be another way to do it with the <code>ABC</code> stuff but I&#39;m in a hurry :-)<br>------------------------------------------------------------------ <br><h3> Dan Lenski, Id: 154156, Score: 271: </h3><p>The <strong>most</strong> Pythonic way to check the type of an object is... not to check it.</p>

<p>Since Python encourages <a href="http://wikipedia.org/wiki/Duck_typing" rel="noreferrer">Duck Typing</a>, you should just <code>try...except</code> to use the object's methods the way you want to use them.  So if your function is looking for a writable file object, <em>don't</em> check that it's a subclass of <code>file</code>, just try to use its <code>.write()</code> method!</p>

<p>Of course, sometimes these nice abstractions break down and <code>isinstance(obj, cls)</code> is what you need.  But use sparingly.</p>
<h4> RickyA, Comment 18899728 Score: 173: </h4>Duck typing is about <i>using</i> an library. Type checking is about <i>writing</i> an library. Not the same problem domain.<br><h4> sastanin, Comment 258000 Score: 97: </h4>IMHO, the most Pythonic way is to cope with whatever argument which is given. In my code I often cannot know if I recieve an object or an array of objects, and I use type-checking internally to convert a single object to a one-element list.<br><h4> Dan Lenski, Comment 37459339 Score: 25: </h4>@RickyA, I disagree. Duck typing is about interacting with objects using interfaces with well-known semantics. This can apply either to library code or to the code that uses such a library.<br><h4> ideasman42, Comment 16214016 Score: 16: </h4>Rather then just trying to use its write method there are times when you want to do this without causing an exception.  In this case you could do... <code>if hasattr(ob, &quot;write&quot;) and callable(ob.write):</code>  Or save some dict access... <code>func = getattr(ob, &quot;write&quot;, None)</code> <code>if callable(func): ...</code><br><h4> user5359531, Comment 63188970 Score: 13: </h4>&quot;The most Pythonic way to check the type of an object is... not to check it.&quot; This does not help at all when I am trying to debug my code...<br><h4> Bachsau, Comment 87149461 Score: 1: </h4>@sastanin I do not agree with you. Python is generally a strong typed language, so a function should NOT cope with whatever type it gets. If you expect an <code>int</code>, just try to use it as an <code>int</code>. It will be fine if you get a <code>bool</code> because that is a subclass of <code>int</code>. But don&#39;t use type checking to detect a <code>str</code> and convert it in that case. Using a <code>str</code> like an <code>int</code> will most likely fail. That&#39;s OK and what the user expects.<br><h4> ideasman42, Comment 43722172 Score: 8: </h4>@nyuszika7h, In Python3 <code>hasattr</code> only supresses an AttributeError - See: <a href="https://docs.python.org/3.4/library/functions.html#hasattr" rel="nofollow noreferrer">docs.python.org/3.4/library/functions.html#hasattr</a><br><h4> Addem, Comment 56660367 Score: 1: </h4>I&#39;m confused by the suggestion.  Right now I&#39;m writing code that simulates algebraic expressions and I want to search the expression tree for any two numbers that can be summed, as one step in the process of simplification.  How would you search an expression tree for two numbers that can be added without testing their types?<br><h4> Jacob Lee, Comment 109897950 Score: 3: </h4>The try ... except pattern isn&#39;t going to do any good when the result is &quot;wrong&quot; for your use-case but doesn&#39;t raise an exception. For example, given a list of mixed types, you may want to call json.dumps only on the dicts in that list before passing the result to a csv writer because of what ends up happening with quoting in the output.<br><h4> Excalabur, Comment 59340492 Score: 3: </h4>@Addem:  If the case where they&#39;re likely to be addable is common, just try it!   <code>try: a + b except TypeError: something_appropriate</code>.  If you&#39;re doing a type-check on the numbers you are fairly likely to miss some, as there&#39;s a lot of ways of storing numbers that doesn&#39;t subclass the base number classes.<br><h4> dualed, Comment 75421726 Score: 3: </h4>Duck typing is not a form of abstraction (referring to answer). Since it avoids actual typing (typing is an abstraction) and deals with concrete implementations - like &quot;does this method exist&quot; or maybe more fitting &quot;Does my nuclear power plan blow up or turn on the fans if I run <code>powerplant.blow()</code>&quot; (who knows :))<br><h4> Rodrigo E. Principe, Comment 78470257 Score: 2: </h4>What if I pass an object that has the same method but returns something different? It will pass the <code>try</code> but will have an unexpected behavior.<br><h4> smci, Comment 91447323 Score: 2: </h4>As well as mentioning <code>try...except</code>, you should also say that the <code>except</code> should not be a naked <code>except</code>, it <b>should always specify the specific named exception(s) that could occur if the object&#39;s type was wrong</b> e.g. <code>except TypeError, KeyError, UserDefinedYachtError:</code>. It should not implicitly catch <a href="https://docs.python.org/3/library/exceptions.html#concrete-exceptions" rel="nofollow noreferrer">other exceptions</a>: MemoryError, OSError etc., especially dangerous ones. <b>Naked except considered bad</b><br><h4> ShadowRanger, Comment 131333088 Score: 1: </h4>@JacobLee: Sure. Did you reach the last paragraph of the answer? There&#39;s no one answer; it&#39;s best to use duck-typing if you can without causing other problems. When you can&#39;t, there&#39;s <code>isinstance</code>.<br><h4> H.Rabiee, Comment 109426507 Score: 1: </h4>Writing API with that philosophy is hurtful. I prefer to type check for integer/str, as a matter of fact it&#39;s necessary even in API development<br><h4> Dan Lenski, Comment 37459432 Score: 1: </h4>@tohecz, I don&#39;t think it&#39;s <b>wrong</b>, but if you have a way to treat objects more generically rather than check their type explicitly, then your code may be more generically applicable. I generally agree with @sastanin&#39;s approach for the kind of commonly-used convenience function which may either take a single item or a list of them: <code>list_OF_strings = [list_OR_string] if isinstance(list_OR_string, basestring) else list_OR_string</code>.<br><h4> alexia, Comment 43717143 Score: 1: </h4>@ideasman42 Note that <code>hasattr</code> ignores all exceptions, including <code>KeyboardInterrupt</code> and similar. You should use <code>getattr(obj, attr, None)</code>.<br><h4> yo&#39;, Comment 33577369 Score: 0: </h4>So you say it is wrong to have a function that accepts both a string and a list of strings?<br><h4> smci, Comment 91447247 Score: 0: </h4>@RodrigoE.Principe: sounds like a method hijacking a parent-class&#39;s signature. Can you provide an example? Anyway, that&#39;s why static type checking was introduced.<br><h4> devdanke, Comment 131471595 Score: 0: </h4>It&#39;s 2022.  Things have changed since this answer was submitted.  It&#39;s widely accepted that programming with types has many benefits.<br><h4> claypooj, Comment 131507412 Score: 0: </h4>Basically what @Ricky A. said, but a concrete example. If my custom object accepts dates, it&#39;s really important to know whether the date passed to it during initialization is a <code>str</code> or a <code>datetime.date</code> object. You can generally create a <code>datetime.date</code> object from a <code>str</code>, so you could still work with it, but you&#39;d need to know it wasn&#39;t a <code>datetime.date</code> object first.<br><h4> chepner, Comment 132785091 Score: 0: </h4>A <code>str</code> could be anything: some could be parsed <i>as</i> dates, but others can&#39;t. If the purpose of the function is to operate on dates, let the <i>caller</i> deal with converting a particular <code>str</code> value to a <code>datetime.date</code> first (and any errors that might arise in the process) and provide your function with the resulting value.<br><h4> joel, Comment 136169887 Score: 0: </h4>somtimes you need <code>isinstance</code> for <code>@overload</code>-ed functions<br>------------------------------------------------------------------ <br><h3> Herge, Id: 152592, Score: 80: </h3><p><code>isinstance(o, str)</code> will return <code>True</code> if <code>o</code> is an <code>str</code> or is of a type that inherits from <code>str</code>.</p>
<p><code>type(o) is str</code> will return <code>True</code> if and only if <code>o</code> is a <code>str</code>. It will return <code>False</code> if <code>o</code> is of a type that inherits from <code>str</code>.</p>
<h4> Thomas Wouters, Comment 45303 Score: 9: </h4>Of course, this will fail if the object is not an instance of &#39;str&#39;, but of something string-like instead. Like unicode, mmap, UserString or any other user-defined type. The usual approach in Python is not to do typechecks.<br><h4> sastanin, Comment 257995 Score: 2: </h4>This is very helpful. Because the difference between <code>isinstance</code> and <code>type(var) == type(&#39;&#39;)</code> is not clear.<br>------------------------------------------------------------------ <br><h3> SuperNova, Id: 68052807, Score: 54: </h3><p>In <a href="https://www.python.org/dev/peps/pep-0604/" rel="noreferrer">Python 3.10</a>, you can use <code>|</code> in <code>isinstance</code>:</p>
<pre><code>&gt;&gt;&gt; isinstance(1223, int | str) 
True

&gt;&gt;&gt; isinstance('abcd', int | str) 
True
</code></pre>
<h4> Karl Knechtel, Comment 133002575 Score: 4: </h4>Surely the example should actually use an integer in order to demonstrate the functionality?<br><h4> A Kareem, Comment 128486464 Score: 1: </h4>One of the great things in python is that it avoids having random symbols all over the code. Unfortunately that property is slowly disappearing over time.<br>------------------------------------------------------------------ <br><h3> Praxeolitic, Id: 37076991, Score: 45: </h3><p>After the question was asked and answered, <a href="https://www.python.org/dev/peps/pep-0484/" rel="noreferrer">type hints were added to Python</a>. Type hints in Python allow types to be checked but in a very different way from statically typed languages. Type hints in Python associate the expected types of arguments with functions as runtime accessible data associated with functions and this <em>allows</em> for types to be checked. Example of type hint syntax:</p>

<pre><code>def foo(i: int):
    return i

foo(5)
foo('oops')
</code></pre>

<p>In this case we want an error to be triggered for <code>foo('oops')</code> since the annotated type of the argument is <code>int</code>. The added type hint does not <em>cause</em> an error to occur when the script is run normally. However, it adds attributes to the function describing the expected types that other programs can query and use to check for type errors.</p>

<p>One of these other programs that can be used to find the type error is <code>mypy</code>:</p>

<pre><code>mypy script.py
script.py:12: error: Argument 1 to "foo" has incompatible type "str"; expected "int"
</code></pre>

<p>(You might need to install <code>mypy</code> from your package manager. I don't think it comes with CPython but seems to have some level of "officialness".)</p>

<p>Type checking this way is different from type checking in statically typed compiled languages. Because types are dynamic in Python, type checking must be done at runtime, which imposes a cost -- even on correct programs -- if we insist that it happen at every chance. Explicit type checks may also be more restrictive than needed and cause unnecessary errors (e.g. does the argument really need to be of exactly <code>list</code> type or is anything iterable sufficient?).</p>

<p>The upside of explicit type checking is that it can catch errors earlier and give clearer error messages than duck typing. The exact requirements of a duck type can only be expressed with external documentation (hopefully it's thorough and accurate) and errors from incompatible types can occur far from where they originate.</p>

<p>Python's type hints are meant to offer a compromise where types can be specified and checked but there is no additional cost during usual code execution.</p>

<p>The <code>typing</code> package offers type variables that can be used in type hints to express needed behaviors without requiring particular types. For example, it includes variables such as <code>Iterable</code> and <code>Callable</code> for hints to specify the need for any type with those behaviors.</p>

<p>While type hints are the most Pythonic way to check types, it's often even more Pythonic to not check types at all and rely on duck typing. Type hints are relatively new and the jury is still out on when they're the most Pythonic solution. A relatively uncontroversial but very general comparison: Type hints provide a form of documentation that can be enforced, allow code to generate earlier and easier to understand errors, can catch errors that duck typing can't, and can be checked statically (in an unusual sense but it's still outside of runtime). On the other hand, duck typing has been the Pythonic way for a long time, doesn't impose the cognitive overhead of static typing, is less verbose, and will accept all viable types and then some.</p>
<h4> Kevin, Comment 90575794 Score: 12: </h4>That is not true either.  It <a href="https://github.com/python/mypy/blob/master/mypy/fastparse.py" rel="nofollow noreferrer">uses</a> typed_ast, which itself <a href="https://github.com/python/typed_ast" rel="nofollow noreferrer">is just a clone of ast</a> with extra features.  <a href="https://docs.python.org/3/library/ast.html" rel="nofollow noreferrer">ast</a> does not import modules; it parses them into an abstract syntax tree.<br><h4> Kevin, Comment 90565490 Score: 4: </h4>-1: <a href="http://mypy-lang.org/" rel="nofollow noreferrer">mypy</a> specifically calls itself a &quot;static type checker&quot; so I&#39;m not sure where you got &quot;type checking must be done at runtime&quot; from.<br><h4> Praxeolitic, Comment 90568022 Score: 0: </h4>@Kevin In retrospect, that was an unnecessary digression, but to get into it more, Python&#39;s type hints are turned into runtime data and <code>mypy</code> is a Python module that uses <code>importlib</code> to access that data. Whether this is &quot;static type checking&quot; is a philosophical question but it&#39;s different from what most would expect since the normal language interpreter and import machinery are involved.<br>------------------------------------------------------------------ <br><h3> Alexander Kojevnikov, Id: 152583, Score: 16: </h3><pre><code>isinstance(o, str)
</code></pre>

<p><a href="https://docs.python.org/2/library/functions.html#isinstance" rel="noreferrer">Link to docs</a></p>
<h4> EKons, Comment 65057229 Score: 8: </h4>While this link may answer the question, it is better to include the essential parts of the answer here and provide the link for reference. Link-only answers can become invalid if the linked page changes.<br>------------------------------------------------------------------ <br><h3> Yerramsetty Rohit, Id: 57099789, Score: 14: </h3><p>You can check for type of a variable using __name__ of a type.</p>

<p>Ex:</p>

<pre><code>&gt;&gt;&gt; a = [1,2,3,4]  
&gt;&gt;&gt; b = 1  
&gt;&gt;&gt; type(a).__name__
'list'
&gt;&gt;&gt; type(a).__name__ == 'list'
True
&gt;&gt;&gt; type(b).__name__ == 'list'
False
&gt;&gt;&gt; type(b).__name__
'int'
</code></pre>
<h4> Gouvernathor, Comment 129060924 Score: 4: </h4>That&#39;s a terrible way of checking the type of something. I can create a random class with the name I want, and it will pass your tests. It&#39;s even worse than duck-typing.<br><h4> Neuron, Comment 130410100 Score: 1: </h4>This is such a terrible solution and it is a shame its rating is still in the positive. There already is the <code>isinstance</code> check and you should use it.<br><h4> ShadowRanger, Comment 131333142 Score: 1: </h4>The only conceivable case where this is even a quasi-reasonable solution is during live development, where you&#39;re constant reloading a module and want instances of classes made before the <code>reload</code> to still be detected as the same thing as instances made after the <code>reload</code> (you <i>want</i> the test to be wrong; they&#39;re not the same class, but you&#39;re pretending they&#39;re close). But it&#39;s terrible in every other context.<br><h4> Atcold, Comment 134229656 Score: 0: </h4>Thanks! This is exactly what I was looking for. In my code, I&#39;m checking for a class type before the class it&#39;s defined. So, using its name seems to be the only viable way to avoid duck-typing. I&#39;m glad this solution rating is positive.<br><h4> Davis Herring, Comment 136936355 Score: 0: </h4>@Atcold: If the class hasn&#39;t been defined, there are no objects of that type.<br>------------------------------------------------------------------ <br><h3> Granitosaurus, Id: 54720728, Score: 9: </h3><p>For more complex type validations I like <a href="https://github.com/agronholm/typeguard" rel="noreferrer">typeguard</a>'s approach of validating based on python type hint annotations:</p>

<pre><code>from typeguard import check_type
from typing import List

try:
    check_type('mylist', [1, 2], List[int])
except TypeError as e:
    print(e)
</code></pre>

<p>You can perform very complex validations in very clean and readable fashion.</p>

<pre><code>check_type('foo', [1, 3.14], List[Union[int, float]])
# vs
isinstance(foo, list) and all(isinstance(a, (int, float)) for a in foo) 
</code></pre>
------------------------------------------------------------------ <br><h3> Will Harding, Id: 153032, Score: 7: </h3><p>I think the cool thing about using a dynamic language like Python is you really shouldn't have to check something like that.</p>

<p>I would just call the required methods on your object and catch an <code>AttributeError</code>. Later on this will allow you to call your methods with other (seemingly unrelated) objects to accomplish different tasks, such as mocking an object for testing.</p>

<p>I've used this a lot when getting data off the web with <code>urllib2.urlopen()</code> which returns a <em>file like</em> object. This can in turn can be passed to almost any method that reads from a file, because it implements the same <code>read()</code> method as a real file.</p>

<p>But I'm sure there is a time and place for using <code>isinstance()</code>, otherwise it probably wouldn't be there :)</p>
<h4> Gray, Comment 95068400 Score: 2: </h4>A good example of when you <i>must</i> use it is if you are parsing a dynamic json object.  You don&#39;t know ahead of time if a field is a string or a dictionary.<br>------------------------------------------------------------------ <br><h3> Simply Beautiful Art, Id: 67462404, Score: 7: </h3><p>The accepted answer answers the question in that it provides the answers to the asked questions.</p>
<blockquote>
<p>Q: What is the best way to check whether a given object is of a given type? How about checking whether the object inherits from a given type?</p>
</blockquote>
<blockquote>
<p>A: Use <code>isinstance, issubclass, type</code> to check based on types.</p>
</blockquote>
<p>As other answers and comments are quick to point out however, there's a lot more to the idea of &quot;type-checking&quot; than that in python. Since the addition of Python 3 and <a href="https://www.python.org/dev/peps/pep-0484/" rel="noreferrer">type hints</a>, much has changed as well. Below, I go over some of the difficulties with type checking, duck typing, and exception handling. For those that think type checking isn't what is needed (it usually isn't, but we're here), I also point out how type hints can be used instead.</p>
<h3>Type Checking</h3>
<p>Type checking is not always an appropriate thing to do in python. Consider the following example:</p>
<pre class="lang-py prettyprint-override"><code>def sum(nums):
    &quot;&quot;&quot;Expect an iterable of integers and return the sum.&quot;&quot;&quot;
    result = 0
    for n in nums:
        result += n
    return result
</code></pre>
<p>To check if the input is an iterable of integers, we run into a major issue. The only way to check if every element is an integer would be to loop through to check each element. But if we loop through the entire iterator, then there will be nothing left for intended code. We have two options in this kind of situation.</p>
<ol>
<li><p>Check as we loop.</p>
</li>
<li><p>Check beforehand but store everything as we check.</p>
</li>
</ol>
<p>Option 1 has the downside of complicating our code, especially if we need to perform similar checks in many places. It forces us to move type checking from the top of the function to <em>everywhere</em> we use the iterable in our code.</p>
<p>Option 2 has the obvious downside that it destroys the entire purpose of iterators. The entire point is to not store the data because we shouldn't need to.</p>
<p>One might also think that checking if checking all of the elements is too much then perhaps we can just check if the input itself is of the type iterable, but there isn't actually any iterable base class. Any type implementing <code>__iter__</code> is iterable.</p>
<h3>Exception Handling and Duck Typing</h3>
<p>An alternative approach would be to forgo type checking altogether and focus on exception handling and duck typing instead. That is to say, wrap your code in a try-except block and catch any errors that occur. Alternatively, don't do anything and let exceptions rise naturally from your code.</p>
<p>Here's one way to go about catching an exception.</p>
<pre class="lang-py prettyprint-override"><code>def sum(nums):
    &quot;&quot;&quot;Try to catch exceptions?&quot;&quot;&quot;
    try:
        result = 0
        for n in nums:
            result += n
        return result
    except TypeError as e:
        print(e)
</code></pre>
<p>Compared to the options before, this is certainly better. We're checking as we run the code. If there's a <code>TypeError</code> anywhere, we'll know. We don't have to place a check everywhere that we loop through the input. And we don't have to store the input as we iterate over it.</p>
<p>Furthermore, this approach enables duck typing. Rather than checking for <code>specific types</code>, we have moved to checking for <code>specific behaviors</code> and look for when the input fails to behave as expected (in this case, looping through <code>nums</code> and being able to add <code>n</code>).</p>
<p>However, the exact reasons which make exception handling nice can also be their downfall.</p>
<ol>
<li><p>A <code>float</code> isn't an <code>int</code>, but it satisfies the <em>behavioral</em> requirements to work.</p>
</li>
<li><p>It is also bad practice to wrap the entire code with a try-except block.</p>
</li>
</ol>
<p>At first these may not seem like issues, but here's some reasons that may change your mind.</p>
<ol>
<li><p>A user can no longer expect our function to return an <code>int</code> as intended. This may break code elsewhere.</p>
</li>
<li><p>Since exceptions can come from a wide variety of sources, using the try-except on the whole code block may end up catching exceptions you didn't intend to. We only wanted to check if <code>nums</code> was iterable and had integer elements.</p>
</li>
<li><p>Ideally we'd like to catch exceptions our code generators and raise, in their place, more informative exceptions. It's not fun when an exception is raised from someone else's code with no explanation other than a line you didn't write and that some <code>TypeError</code> occured.</p>
</li>
</ol>
<p>In order to fix the exception handling in response to the above points, our code would then become this... abomination.</p>
<pre class="lang-py prettyprint-override"><code>def sum(nums):
    &quot;&quot;&quot;
    Try to catch all of our exceptions only.
    Re-raise them with more specific details.
    &quot;&quot;&quot;
    result = 0

    try:
        iter(nums)
    except TypeError as e:
        raise TypeError(&quot;nums must be iterable&quot;)

    for n in nums:
        try:
            result += int(n)
        except TypeError as e:
            raise TypeError(&quot;stopped mid iteration since a non-integer was found&quot;)

    return result
</code></pre>
<p>You can kinda see where this is going. The more we try to &quot;properly&quot; check things, the worse our code is looking. Compared to the original code, this isn't readable at all.</p>
<p>We could argue perhaps this is a bit extreme. But on the other hand, this is only a very simple example. In practice, your code is probably much more complicated than this.</p>
<h3>Type Hints</h3>
<p>We've seen what happens when we try to modify our small example to &quot;enable type checking&quot;. Rather than focusing on trying to force specific types, type hinting allows for a way to make types clear to users.</p>
<pre class="lang-py prettyprint-override"><code>from typing import Iterable

def sum(nums: Iterable[int]) -&gt; int:
    result = 0
    for n in nums:
        result += n
    return result
</code></pre>
<p>Here are some advantages to using type-hints.</p>
<ul>
<li><p>The code actually looks good now!</p>
</li>
<li><p>Static type analysis may be performed by your editor if you use type hints!</p>
</li>
<li><p>They are stored on the function/class, making them dynamically usable e.g. <a href="https://github.com/agronholm/typeguard" rel="noreferrer"><code>typeguard</code></a> and <a href="https://docs.python.org/3/library/dataclasses.html" rel="noreferrer"><code>dataclasses</code></a>.</p>
</li>
<li><p>They show up for functions when using <code>help(...)</code>.</p>
</li>
<li><p>No need to sanity check if your input type is right based on a description or worse lack thereof.</p>
</li>
<li><p>You can &quot;type&quot; hint based on <a href="https://www.python.org/dev/peps/pep-0544/" rel="noreferrer">structure</a> e.g. &quot;does it have this attribute?&quot; without requiring subclassing by the user.</p>
</li>
</ul>
<p>The downside to type hinting?</p>
<ul>
<li>Type hints are nothing more than syntax and special text on their own. <em>It isn't the same as type checking</em>.</li>
</ul>
<p>In other words, it doesn't actually answer the question because it doesn't provide type checking. Regardless, however, if you are here for type checking, then you <em>should</em> be type hinting as well. Of course, if you've come to the conclusion that type checking isn't actually necessary but you want some semblance of typing, then type hints are for you.</p>
<h4> ShadowRanger, Comment 136233649 Score: 0: </h4>Using <code>result += int(n)</code> risks silent data loss. If <code>n</code> is a <code>float</code>, it&#39;ll be silently truncated (e.g. <code>2.5</code> would become <code>2</code>). I <i>strongly</i> suggest using <code>operator.index</code> in place of <code>int</code> when you want this sort of semi-duck-typing solution; it will accept <code>int</code>, and anything which <i>type</i> which can, for <i>all</i> possible values, be losslessly converted to <code>int</code> (e.g. a <code>numpy.int32</code> scalar, but not <code>float</code> or <code>str</code>).<br>------------------------------------------------------------------ <br><h3> Chris Barker, Id: 11763264, Score: 6: </h3><p>To Hugo:</p>

<p>You probably mean <code>list</code> rather than <code>array</code>, but that points to the whole problem with type checking - you don't want to know if the object in question is a list, you want to know if it's some kind of sequence or if it's a single object. So try to use it like a sequence.</p>

<p>Say you want to add the object to an existing sequence, or if it's a sequence of objects, add them all</p>

<pre><code>try:
   my_sequence.extend(o)
except TypeError:
  my_sequence.append(o)
</code></pre>

<p>One trick with this is if you are working with strings and/or sequences of strings - that's tricky, as a string is often thought of as a single object, but it's also a sequence of characters. Worse than that, as it's really a sequence of single-length strings.</p>

<p>I usually choose to design my API so that it only accepts either a single value or a sequence - it makes things easier. It's not hard to put a <code>[ ]</code> around your single value when you pass it in if need be.</p>

<p>(Though this can cause errors with strings, as they do look like (are) sequences.)</p>
------------------------------------------------------------------ <br><h3> spielzeugland, Id: 75465809, Score: 2: </h3><p>If you have to check for the type of <code>str</code> or <code>int</code> please use <code>instanceof</code>. As already mentioned by others the explanation is to also include sub classes. One important example for sub classes from my perspective are Enums with data type like <code>IntEnum</code> or <code>StrEnum</code>. Which are a pretty nice way to define related constants. However, it is kind of annoying if libraries do not accept those as such types.</p>
<p>Example:</p>
<pre><code>import enum

class MyEnum(str, enum.Enum):
    A = &quot;a&quot;
    B = &quot;b&quot;

print(f&quot;is string: {isinstance(MyEnum.A, str)}&quot;)   # True
print(f&quot;is string: {type(MyEnum.A) == str}&quot;)       # False!!!
print(f&quot;is string: {type(MyEnum.A.value) == str}&quot;) # True
</code></pre>
------------------------------------------------------------------ <br><h3> zetmain, Id: 76368322, Score: 1: </h3><p>To check if an object is of a given type or if it inherits from a given type, you can use the <code>isinstance()</code> function. Here's how you can check if an object o is of type str:</p>
<pre><code>o = &quot;Hello, world!&quot;

if isinstance(o, str):
    print(&quot;The object is of type str.&quot;)
else:
    print(&quot;The object is not of type str.&quot;)
</code></pre>
<h4> joel, Comment 136271922 Score: 0: </h4>this answer was already given above many years ago<br>------------------------------------------------------------------ <br><h3> Sheykhmousa, Id: 75249040, Score: 0: </h3><p>In Python, you can use the built-in <code>isinstance()</code> function to check if an object is of a given type, or if it inherits from a given type.</p>
<p>To check if the object o is of type str, you would use the following code:</p>
<pre><code>if isinstance(o, str):
# o is of type str
</code></pre>
<p>You can also use <code>type()</code> function to check the object type.</p>
<pre><code>if type(o) == str:
# o is of type str
</code></pre>
<p>You can also check if the object is a sub class of a particular class using <code>issubclass()</code> function.</p>
<pre><code>if issubclass(type(o),str):
# o is sub class of str
</code></pre>
<h4> Karl Knechtel, Comment 133002540 Score: 0: </h4>Please read <a href="https://stackoverflow.com/questions/how-to-answer">How to Answer</a>, and check existing answers before contributing another answer to a question. All of this material is thoroughly covered already.<br>------------------------------------------------------------------ <br><h3> Dogweather, Id: 77737531, Score: 0: </h3><p>Python 3.10 introduced a new way to check for type that's often cleaner than <code>if/instanceof()</code>: <a href="https://docs.python.org/3/tutorial/controlflow.html#match-statements" rel="nofollow noreferrer">the match statement</a>. It can check for many types:</p>
<pre class="lang-py prettyprint-override"><code>float(x) # Is it a floating point?
str(x)   # Is it a string?
int(x)   # Is it an integer?
...
</code></pre>
<p>For example, here's how you can handle some function that returns a variety of types, that each need to be handled differently:</p>
<pre class="lang-py prettyprint-override"><code>def read_user_input() -&gt; float | str | None:
    ...

# Get user input, rounding floats to 2 decimal places.
def user_input() -&gt; str:
    match read_user_input()
        case float(a_number):
            n = str(round(2, a_number))
        case str(a_string):
            n = return str(round(2, float(a_string.strip())))
        case None:
            n = &quot;(No input given)&quot;

    return n
</code></pre>
<p><strong>Bonus:</strong> When you check for type this way, <a href="https://dogweather.dev/2022/10/03/i-discovered-that-python-now-can-do-true-match-exhaustiveness-checking/" rel="nofollow noreferrer">type checkers can verify that that the <code>match</code> is exhaustive</a>; that you've handled every possible type that you function will give you.</p>
------------------------------------------------------------------ <br><h3> cherah30, Id: 59466517, Score: -14: </h3><p>I think the best way is to typing well your variables. You can do this by using the &quot;typing&quot; library.</p>
<p>Example:</p>
<pre class="lang-py prettyprint-override"><code>from typing import NewType
UserId = NewType ('UserId', int)
some_id = UserId (524313`)
</code></pre>
<p>See <a href="https://docs.python.org/3/library/typing.html" rel="nofollow noreferrer">https://docs.python.org/3/library/typing.html</a>.</p>
<h4> General Grievance, Comment 128312657 Score: 4: </h4>But you didn&#39;t demonstrate a check anywhere, did you? If you did, can you please explain where you&#39;re checking for the type in the code you have given?<br>