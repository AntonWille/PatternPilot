 <h2> Title: How to read a file line-by-line into a list? </h2> <h3> Julie Raswick, question_id: 3277503 </h3>Score: 2025, Tags: {python,string,file,readlines} <br><p>How do I read every line of a file in Python and store each line as an element in a list? </p>

<p>I want to read the file line by line and append each line to the end of the list.</p>
------------------------------------------------------------------ <br><h3> Answer 17166344 Lee: </h3><p>Another option is <a href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.genfromtxt.html" rel="noreferrer"><code>numpy.genfromtxt</code></a>, for example:</p>

<pre><code>import numpy as np
data = np.genfromtxt("yourfile.dat",delimiter="\n")
</code></pre>

<p>This will make <code>data</code> a NumPy array with as many rows as are in your file.</p>
------------------------------------------------------------------ <br><h3> Answer 3277512 robert: </h3><p>This is more explicit than necessary, but does what you want.</p>

<pre class="lang-py prettyprint-override"><code>with open("file.txt") as file_in:
    lines = []
    for line in file_in:
        lines.append(line)
</code></pre>
<h4> Comment 91755992 JohannesB: </h4>I prefer this answer since it doesn&#39;t require to load the whole file into memory (in this case it is still appended to <code>array</code> though, but there might be other circumstances). Certainly for big files this approach might mitigate problems.<br><h4> Comment 105499167 AMC: </h4><b>Note:</b> This solution does not strip newlines.<br><h4> Comment 108965817 andrebrait: </h4>This solution does load the whole file to memory. I don&#39;t know why people think it does not.<br><h4> Comment 92226102 Elias Strehle: </h4>Appending to an array is slow. I cannot think of a use case where this is the best solution.<br><h4> Comment 110209442 Jo&#227;o Monteiro: </h4>@andrebrait It loads the whole file into lines[] by choice, but can just load line by line.<br><h4> Comment 125234238 wjandrea: </h4>@Jo&#227;o That&#39;s true, if you added an <code>if</code>-statement in the <code>for</code>-loop, it&#39;d be worthwhile, but as it&#39;s written, it&#39;s equivalent to <code>lines = file.readlines()</code> but more verbose than necessary.<br>------------------------------------------------------------------ <br><h3> Answer 3277516 SilentGhost: </h3><p>This code will read the entire file into memory and remove all whitespace characters (newlines and spaces) from the end of each line:</p>
<pre class="lang-py prettyprint-override"><code>with open(filename) as file:
    lines = [line.rstrip() for line in file]
</code></pre>
<p>If you're working with a large file, then you should instead read and process it line-by-line:</p>
<pre class="lang-py prettyprint-override"><code>with open(filename) as file:
    for line in file:
        print(line.rstrip())
</code></pre>
<p>In Python 3.8 and up you can use a while loop with the <a href="https://docs.python.org/3/whatsnew/3.8.html#assignment-expressions" rel="noreferrer">walrus operator</a> like so:</p>
<pre class="lang-py prettyprint-override"><code>with open(filename) as file:
    while line := file.readline():
        print(line.rstrip())
</code></pre>
<p>Depending on what you plan to do with your file and how it was encoded, you may also want to manually set the <a href="https://www.tutorialspoint.com/python/python_files_io.htm" rel="noreferrer">access mode</a> and character encoding:</p>
<pre class="lang-py prettyprint-override"><code>with open(filename, 'r', encoding='UTF-8') as file:
    while line := file.readline():
        print(line.rstrip())
</code></pre>
<h4> Comment 85163715 Tirtha R: </h4>I checked the memory profile of different ways given in the answers using the procedure mentioned <a href="https://stackoverflow.com/a/45679009/3529829">here</a>. The memory usage is far better when each line is read from the file and processed, as suggested by @DevShark <a href="https://stackoverflow.com/a/35622867/3529829">here</a>. Holding all lines in a collection object is <b>not</b> a good idea if memory is a constraint or the file is large.         The execution time is similar in both the approaches.<br><h4> Comment 127404881 PlasmaHH: </h4>I think the walrus version would stop on empty lines<br><h4> Comment 125233792 wjandrea: </h4>@Timo It&#39;s not. See the docs: <a href="https://docs.python.org/3/library/io.html#io.IOBase.readlines" rel="nofollow noreferrer"><code>io.IOBase.readlines()</code></a>. Why do you think it is?<br><h4> Comment 117310437 Timo: </h4>I think that <code>readlines()</code> is deprecated.<br><h4> Comment 131002812 ShadowRanger: </h4>@AlexisWilke: See <a href="https://stackoverflow.com/q/50297704/364696">&quot;:=&quot; syntax and assignment expressions: what and why?</a><br><h4> Comment 131002993 ShadowRanger: </h4>@ketza: No downside. In fact, it&#39;s better as just <code>lines = [line.rstrip() for line in f]</code> (avoiding a needless temporary <code>list</code> on top of the one the listcomp generates; file objects are already iterables of their lines, and you can begin processing faster and save on peak memory utilization by avoid <code>.readlines()</code> in this, and most other, cases); I&#39;ve edited to use that approach.<br><h4> Comment 127720131 Alexis Wilke: </h4>What is that <code>:=</code> operator?!<br><h4> Comment 131002747 ShadowRanger: </h4>@wjandrea: It&#39;s not deprecated, but it should have been; <code>fileobj.readlines()</code> is a micro-optimization equivalent to just doing <code>list(fileobj)</code>, and its mere existence makes people use it when they really just wanted to iterate <code>fileobj</code> directly, rather than making an unnecessary huge temporary <code>list</code>. The obvious way to do it ends up being the wrong (or at least, inefficient) way to do it so often.<br><h4> Comment 127754533 Vezen BU: </h4>@AlexisWilke basically, while (x := something): do ... means while something: x = something; do ...<br><h4> Comment 129414300 ketza: </h4>Is there any potential downside of squeezing the first approach into one line? Like so: <code>lines = [line.rstrip() for line in f.readlines()]</code><br><h4> Comment 130874180 Patrizio Bertoni: </h4>plus one for the walrus. Noice!<br><h4> Comment 132540211 seunggabi: </h4>def read(filename):     with open(filename) as file:         lines = [line.rstrip() for line in file]          return&quot;\n&quot;.join(lines)<br><h4> Comment 133667197 cod3monk3y: </h4>As @PlasmaHH suggests, the walrus operator versions terminate on the first empty or blank line. <code>readline</code> will return <code>\n</code> for empty lines, or <code>&lt;whitespace&gt;\n</code> for blank lines. Using an <code>rstrip</code> in the condition like this will cause these to be an empty string, which is Falsey, which terminates the loop. As mentioned <a href="https://stackoverflow.com/a/45019413/1174169">in this answer</a>, <code>readline</code> only returns an empty string at EOF so as to be unambiguous as to blank lines (<code>\n</code>) and EOF (<code>&#39;&#39;</code>). The first two examples that have <code>rstrip</code> in the <code>print</code> function correctly.<br><h4> Comment 136167361 Sumit S: </h4>Instead of writing print(line.rstrip()) print (line, end=&quot;&quot;) another option<br>------------------------------------------------------------------ <br><h3> Answer 3277515 Felix Kling: </h3><p>See <a href="http://docs.python.org/tutorial/inputoutput.html#reading-and-writing-files" rel="noreferrer">Input and Ouput</a>:</p>
<pre class="lang-py prettyprint-override"><code>with open('filename') as f:
    lines = f.readlines()
</code></pre>
<p>or with stripping the newline character:</p>
<pre class="lang-py prettyprint-override"><code>with open('filename') as f:
    lines = [line.rstrip('\n') for line in f]
</code></pre>
<h4> Comment 52410775 Mark: </h4>Better, use <code>f.read().splitlines()</code>, which does remove newlines<br><h4> Comment 59234494 Brad Hein: </h4>Best to read the file one line at a time rather than reading the whole file into memory all at once. Doing so doesn&#39;t scale well with large input files. See below answer by robert.<br><h4> Comment 101934431 Mark Amery: </h4>@AaronHall <i>&quot;when the object has no more references to it it will be garbage collected and the file closed&quot;</i> - this is true of CPython, but not true of PyPy. Not all Python implementations immediately destruct objects when they are no longer referenced. As such, the best practice of using <code>with</code> with <code>open</code> is relevant even in this case.<br><h4> Comment 87776451 Russia Must Remove Putin: </h4>Yes, to the point others are making here, while it&#39;s not &quot;best practice&quot; to use <code>open</code> without the context manager (or some other guaranteed way to close it), this is not really one of those cases - when the object has no more references to it it will be garbage collected and the file closed, which should happen immediately on error or not, when the list comprehension is done processing.<br><h4> Comment 87605023 Ramisa Anjum Aditi: </h4><code>lines = [x.rstrip(&#39;\n&#39;) for x in open(&#39;data\hsf.txt&#39;,&#39;r&#39;)]</code> If I write this way, how can I close the file after reading?<br><h4> Comment 58347259 a06e: </h4>Is the second version, with <code>for line in open(filename)</code> safe? That is, will the file be automatically closed?<br>------------------------------------------------------------------ <br><h3> Answer 3277511 Noctis Skytower: </h3><p>This will yield an "array" of lines from the file.</p>

<pre><code>lines = tuple(open(filename, 'r'))
</code></pre>

<p><code>open</code> returns a file which can be iterated over. When you iterate over a file, you get the lines from that file. <code>tuple</code> can take an iterator and instantiate a tuple instance for you from the iterator that you give it. <code>lines</code> is a tuple created from the lines of the file.</p>
<h4> Comment 43290935 Noctis Skytower: </h4>@MarshallFarrier Try <code>lines = open(filename).read().split(&#39;\n&#39;)</code> instead.<br><h4> Comment 48518342 jaynp: </h4>@NoctisSkytower I find <code>lines = open(filename).read().splitlines()</code> a little cleaner, and I believe it also handles DOS line endings better.<br><h4> Comment 43913306 Vanuan: </h4>does it close the file?<br><h4> Comment 56935865 Noctis Skytower: </h4>@mklement0 Assuming a file of 1000 lines, a <code>list</code> takes up about 13.22% more space than a <code>tuple</code>. Results come from <code>from sys import getsizeof as g; i = [None] * 1000; round((g(list(i)) &#47; g(tuple(i)) - 1) * 100, 2)</code>. Creating a <code>tuple</code> takes about 4.17% more time than creating a <code>list</code> (with a 0.16% standard deviation). Results come from running <code>from timeit import timeit as t; round((t(&#39;tuple(i)&#39;, &#39;i = [None] * 1000&#39;) &#47; t(&#39;list(i)&#39;, &#39;i = [None] * 1000&#39;) - 1) * 100, 2)</code> 30 times. My solution favors space over speed when the need for mutability is unknown.<br><h4> Comment 43921003 Noctis Skytower: </h4>@Vanuan Since there is no remaining reference to the file after the line is run, the destructor <i>should</i> automatically close the file.<br><h4> Comment 48892582 mklement0: </h4>This is elegant (except it&#39;s worth noting in the answer itself that the trailing <code>\n</code> is retained in each element), but I&#39;m curious why you chose <code>tuple()</code> over <code>list()</code>. Based on my informal tests, <code>list()</code> performs slightly better (probably won&#39;t matter much). <code>list()</code>, unlike <code>tuple()</code> will return a <i>mutable</i> sequence (which may or may not be desired).<br><h4> Comment 48553777 Noctis Skytower: </h4>@dal102 Yes, I agree with you and wish that I had knowledge of the <code>splitlines</code> method sooner. However, note that the <code>newline</code> argument of the <code>open</code> function is <code>None</code>, so universal newlines mode is enabled, and splitting on <code>&#39;\n&#39;</code> is valid in this case. Especially interesting, though, is that there is a <code>bytes.splitlines</code> method. This gives one the ability to emulate universal newlines mode when opening a file in binary mode. You do not actually need to open a file in text mode to easily split the file&#39;s data on line boundaries and can avoid importing the <code>re</code> module.<br><h4> Comment 43277965 Marshall Farrier: </h4>This is the nicest answer if you want the newline characters in there. Any way to modify it to take those out without ruining the beautiful simplicity of this version?<br><h4> Comment 133507636 Noctis Skytower: </h4>@PatrickT Consider the original question, &quot;How to read a file line-by-line into a list?&quot; If the goal is to store the contents of a file in an array-like data structure, my answer should be sufficient. However, in acknowledgment of your question, you are correct that it may be better to read a file line-by-line (or even block-by-block). If you can process a file incrementally without the need of loading it entirely in RAM, you could use a more memory-efficient solution for solving whatever problem you are tackling.<br><h4> Comment 125234488 wjandrea: </h4>Semantically, <a href="/a/24854173/4518341">you should use a list for this and not a tuple</a>. Performance considerations are premature: if it turns out later you need to add or remove elements from <code>lines</code>, the choice of using a tuple is going to come back to bite you.<br><h4> Comment 122393769 PatrickT: </h4>If the file were very large, wouldn&#39;t that create a very large tuple? Wouldn&#39;t looping line by line be more memory-efficient in such cases? Thanks.<br>------------------------------------------------------------------ <br><h3> Answer 29740172 Pedro Lobito: </h3><p>According to Python's <a href="https://docs.python.org/3/tutorial/inputoutput.html#methods-of-file-objects" rel="nofollow noreferrer">Methods of File Objects</a>, the simplest way to convert a text file into <code>list</code> is:</p>
<pre><code>with open('file.txt') as f:
    my_list = list(f)
    # my_list = [x.rstrip() for x in f] # remove line breaks
</code></pre>
<ul>
<li><a href="https://trinket.io/python3/55c02e4c91" rel="nofollow noreferrer">Demo</a></li>
</ul>
<hr />
<p>If you just need to iterate over the text file lines, you can use:</p>
<pre><code>with open('file.txt') as f:
    for line in f:
       ...
</code></pre>
<hr />
<p>Old answer:</p>
<p>Using <code>with</code> and <code>readlines()</code> :</p>
<pre><code>with open('file.txt') as f:
    lines = f.readlines()
</code></pre>
<p>If you don't care about closing the file, this one-liner will work:</p>
<pre><code>lines = open('file.txt').readlines()
</code></pre>
<p>The <em>traditional</em> way:</p>
<pre><code>f = open('file.txt') # Open file on read mode
lines = f.read().splitlines() # List with stripped line-breaks
f.close() # Close file
</code></pre>
<h4> Comment 122163238 mightyandweakcoder: </h4>@oneturkmen no, he&#39;s correct. he&#39;s looping through the lines in the file. You would be correct if the line is after the &#39;with&#39; clause<br><h4> Comment 119861646 oneturkmen: </h4>The commented line in the first example <code># my_list = [x.rstrip() for x in f] # remove line breaks</code> should instead be <code># my_list = [x.rstrip() for x in my_list] # remove line breaks</code><br>------------------------------------------------------------------ <br><h3> Answer 22123823 Eneko Alonso: </h3><p>If you want the <code>\n</code> included:</p>

<pre><code>with open(fname) as f:
    content = f.readlines()
</code></pre>

<p>If you do not want <code>\n</code> included:</p>

<pre><code>with open(fname) as f:
    content = f.read().splitlines()
</code></pre>
<h4> Comment 125234589 wjandrea: </h4>@Joke You must be doing something wrong (no offense). With <code>s = &#39;1\n2\n3\n&#39;</code>, <code>s.splitlines()</code> returns <code>[&#39;1&#39;, &#39;2&#39;, &#39;3&#39;]</code>. Maybe your input actually contains blank lines? <code>s = &#39;1\n\n2\n\n3\n\n&#39;</code><br><h4> Comment 120775144 huang: </h4>great, it contains empty string between each line. <code>&#39;1\n2\n3\n&#39; =&gt; [ &#39;1&#39;, &#39;&#39;, &#39;2&#39;, &#39;&#39;, &#39;3&#39;, &#39;&#39; ]</code><br>------------------------------------------------------------------ <br><h3> Answer 35622867 DevShark: </h3><p>You could simply do the following, as has been suggested:</p>

<pre><code>with open('/your/path/file') as f:
    my_lines = f.readlines()
</code></pre>

<p>Note that this approach has 2 downsides:</p>

<p>1) You store all the lines in memory. In the general case, this is a very bad idea. The file could be very large, and you could run out of memory. Even if it's not large, it is simply a waste of memory.</p>

<p>2) This does not allow processing of each line as you read them. So if you process your lines after this, it is not efficient (requires two passes rather than one).</p>

<p>A better approach for the general case would be the following:</p>

<pre><code>with open('/your/path/file') as f:
    for line in f:
        process(line)
</code></pre>

<p>Where you define your process function any way you want. For example:</p>

<pre><code>def process(line):
    if 'save the world' in line.lower():
         superman.save_the_world()
</code></pre>

<p>(The implementation of the <code>Superman</code> class is left as an exercise for you).</p>

<p>This will work nicely for any file size and you go through your file in just 1 pass. This is typically how generic parsers will work.</p>
<h4> Comment 62098287 Ephexx: </h4>This was exactly what I needed - and thanks for explaining the downsides. As a beginner in Python, it&#39;s awesome to understand why a solution is the solution. Cheers!<br><h4> Comment 69483018 DevShark: </h4>You always need to do something with the lines. It can be as simple as printing the lines, or counting them. There is no value in having your process read the lines in memory, but not doing anything with it.<br><h4> Comment 69435412 DevShark: </h4>Think a bit more Corey. Do you really ever want your computer to read each line, without ever doing anything with these lines? Surely you can realize you always need to process them one way or another.<br><h4> Comment 76440340 DevShark: </h4>You always need to do something with them. I think the point you are trying to make is that you might want to apply a function to all of them at once, rather than one by one. That is indeed the case sometimes. But it is very inefficient from a memory standpoint to do so, and prevents you from reading files if its footprint is larger than your Ram. That&#39;s why typically generic parsers operate in the way I described.<br><h4> Comment 79392874 DevShark: </h4>@PierreOcinom that is correct. Given that the file is opened in read only mode, you couldn&#39;t modify the original file with the code above. To open a file for both reading and writing, use <code>open(&#39;file_path&#39;, &#39;r+&#39;)</code><br><h4> Comment 85163554 Tirtha R: </h4>I checked the memory profile of both the ways using the procedure mentioned <a href="https://stackoverflow.com/a/45679009/3529829">here</a>. The memory usage is far better when each line is read from the file and processed, as suggested by @DevShark. Holding all lines in a collection object is <b>not</b> a good idea if memory is a constraint or the file is large.  The execution time is similar in both the approaches.<br><h4> Comment 89963531 DevShark: </h4>Thanks for running the numbers. This is what was expected.<br><h4> Comment 91551464 JeramieH: </h4>@DevShark Loading the lines into a set to use as a filter list during execution. They must all be loaded into RAM, and there&#39;s no per-line processing necessary.<br><h4> Comment 91552679 DevShark: </h4>My statement was “you always need to do something with the lines”, and your example illustrate it: you add them to a set. I think your point is that the code I wrote is not the only way to do things. That is correct. To load them all into a set, the other approach of reading all the lines in one go might be more to your liking.<br><h4> Comment 78184286 Pierre Monico: </h4>Good approach, but just to be precise: in this context, &quot;processing the lines&quot; won&#39;t alter them in the original file. You need to copy them to another file if you need them to be modified and stored.<br><h4> Comment 69452457 Corey Goldberg: </h4>@DevShark always?  that&#39;s just false.<br><h4> Comment 76435383 Corey Goldberg: </h4>of course you don&#39;t <i>always</i> need to process items as you read them from a file at the moment you read them... that&#39;s nonsense.  Perhaps you need to generate a list of items stored in a file as input to another function?  Is that such an outrageous idea?<br><h4> Comment 69427102 Corey Goldberg: </h4>the question doesn&#39;t state the need to process every line, so this answer gives irrelevant information<br>------------------------------------------------------------------ <br><h3> Answer 43625375 PythonProgrammi: </h3><p><strong>Having a Text file content:</strong></p>
<pre><code>line 1
line 2
line 3
</code></pre>
<p><strong>We can use this Python script in the same directory of the txt above</strong></p>
<pre class="lang-py prettyprint-override"><code>&gt;&gt;&gt; with open(&quot;myfile.txt&quot;, encoding=&quot;utf-8&quot;) as file:
...     x = [l.rstrip(&quot;\n&quot;) for l in file]
&gt;&gt;&gt; x
['line 1','line 2','line 3']
</code></pre>
<p><strong>Using append:</strong></p>
<pre><code>x = []
with open(&quot;myfile.txt&quot;) as file:
    for l in file:
        x.append(l.strip())
</code></pre>
<p><strong>Or:</strong></p>
<pre><code>&gt;&gt;&gt; x = open(&quot;myfile.txt&quot;).read().splitlines()
&gt;&gt;&gt; x
['line 1', 'line 2', 'line 3']
</code></pre>
<p><strong>Or:</strong></p>
<pre><code>&gt;&gt;&gt; x = open(&quot;myfile.txt&quot;).readlines()
&gt;&gt;&gt; x
['linea 1\n', 'line 2\n', 'line 3\n']
</code></pre>
<p><strong>Or:</strong></p>
<pre><code>def print_output(lines_in_textfile):
    print(&quot;lines_in_textfile =&quot;, lines_in_textfile)

y = [x.rstrip() for x in open(&quot;001.txt&quot;)]
print_output(y)

with open('001.txt', 'r', encoding='utf-8') as file:
    file = file.read().splitlines()
    print_output(file)

with open('001.txt', 'r', encoding='utf-8') as file:
    file = [x.rstrip(&quot;\n&quot;) for x in file]
    print_output(file)
</code></pre>
<p>output:</p>
<pre><code>lines_in_textfile = ['line 1', 'line 2', 'line 3']
lines_in_textfile = ['line 1', 'line 2', 'line 3']
lines_in_textfile = ['line 1', 'line 2', 'line 3']
</code></pre>
<h4> Comment 109982191 craq: </h4>@EricOLebigot from the examples shown, it looks like <code>read().splitlines()</code> and <code>readlines()</code> don&#39;t produce the same output. Are you sure they&#39;re equivalent?<br><h4> Comment 109983073 PythonProgrammi: </h4>If you use readlines only, you need to use the strip method to get rid of the \n in the text, so I changed the last examples using a list comprehension to have the same output in both cases. So, if you use read().readlines() you will have a &quot;clean&quot; item with the line and without the newline characther, otherwise, you must do what you see in the code above.<br><h4> Comment 110022301 Eric O. Lebigot: </h4>Indeed. Note that in the code above all the <code>strip()</code> should be <code>rstrip(&quot;\n&quot;)</code> or spaces around a line are deleted. Also, there is no point in doing <code>readlines()</code> in a list comprehension: simply iterating over the file is better, as it doesn&#39;t waste time and memory by creating an intermediate list of the lines.<br><h4> Comment 92802653 Eric O. Lebigot: </h4><code>read().splitlines()</code> is provided to you by Python: it&#39;s simply <code>readlines()</code> (which is probably faster, as it is less wasteful).<br><h4> Comment 88339503 Mausy5043: </h4>is the <code>encoding=&quot;utf-8&quot;</code> required?<br><h4> Comment 88340240 PythonProgrammi: </h4>@Mausy5043 no, but when you read a text file, you can have some strange character (expecially in italian)<br><h4> Comment 115428943 Abhijeet Singh: </h4>with open(&quot;Beautify.txt&quot;) as file_in:     lines = []     for line in file_in:         lines.append(line.replace(&#39;\n&#39;,&#39;&#39;))<br>------------------------------------------------------------------ <br><h3> Answer 50105587 LangeHaare: </h3><p>Introduced in Python 3.4, <a href="https://docs.python.org/3/library/pathlib.html" rel="noreferrer"><code>pathlib</code></a> has a really convenient method for reading in text from files, as follows:</p>
<pre><code>from pathlib import Path
p = Path('my_text_file')
lines = p.read_text().splitlines()
</code></pre>
<p>(The <code>splitlines</code> call is what turns it from a string containing the whole contents of the file to a list of lines in the file.)</p>
<p><code>pathlib</code> has a lot of handy conveniences in it. <a href="https://docs.python.org/3/library/pathlib.html#pathlib.Path.read_text" rel="noreferrer"><code>read_text</code></a> is nice and concise, and you don't have to worry about opening and closing the file. If all you need to do with the file is read it all in in one go, it's a good choice.</p>
------------------------------------------------------------------ <br><h3> Answer 48290921 MSeifert: </h3><p>To read a file into a list you need to do three things:</p>

<ul>
<li>Open the file</li>
<li>Read the file</li>
<li>Store the contents as list</li>
</ul>

<p>Fortunately Python makes it very easy to do these things so the shortest way to read a file into a list is:</p>

<pre><code>lst = list(open(filename))
</code></pre>

<p>However I'll add some more explanation.</p>

<h2>Opening the file</h2>

<p>I assume that you want to open a specific file and you don't deal directly with a file-handle (or a file-like-handle). The most commonly used function to open a file in Python is <a href="https://docs.python.org/library/functions.html#open" rel="noreferrer"><code>open</code></a>, it takes one mandatory argument and two optional ones in Python 2.7:</p>

<ul>
<li>Filename</li>
<li>Mode</li>
<li>Buffering (I'll ignore this argument in this answer)</li>
</ul>

<p>The filename should be a string that represents the <em>path to the file</em>. For example:</p>

<pre><code>open('afile')   # opens the file named afile in the current working directory
open('adir/afile')            # relative path (relative to the current working directory)
open('C:/users/aname/afile')  # absolute path (windows)
open('/usr/local/afile')      # absolute path (linux)
</code></pre>

<p>Note that the file extension needs to be specified. This is especially important for Windows users because file extensions like <code>.txt</code> or <code>.doc</code>, etc. are hidden <em>by default</em> when viewed in the explorer.</p>

<p>The second argument is the <code>mode</code>, it's <code>r</code> by default which means "read-only". That's exactly what you need in your case. </p>

<p>But in case you actually want to create a file and/or write to a file you'll need a different argument here. <a href="https://stackoverflow.com/a/30566011/5393381">There is an excellent answer if you want an overview</a>.</p>

<p>For reading a file you can omit the <code>mode</code> or pass it in explicitly:</p>

<pre><code>open(filename)
open(filename, 'r')
</code></pre>

<p>Both will open the file in read-only mode. In case you want to read in a binary file on Windows you need to use the mode <code>rb</code>:</p>

<pre><code>open(filename, 'rb')
</code></pre>

<p>On other platforms the <code>'b'</code> (binary mode) is simply ignored.</p>

<hr>

<p>Now that I've shown how to <code>open</code> the file, let's talk about the fact that you always need to <code>close</code> it again. Otherwise it will keep an open file-handle to the file until the process exits (or Python garbages the file-handle). </p>

<p>While you could use:</p>

<pre><code>f = open(filename)
# ... do stuff with f
f.close()
</code></pre>

<p>That will fail to close the file when something between <code>open</code> and <code>close</code> throws an exception. You could avoid that by using a <code>try</code> and <code>finally</code>:</p>

<pre><code>f = open(filename)
# nothing in between!
try:
    # do stuff with f
finally:
    f.close()
</code></pre>

<p>However Python provides context managers that have a prettier syntax (but for <code>open</code> it's almost identical to the <code>try</code> and <code>finally</code> above):</p>

<pre><code>with open(filename) as f:
    # do stuff with f
# The file is always closed after the with-scope ends.
</code></pre>

<p>The last approach is the <strong>recommended</strong> approach to open a file in Python!</p>

<h2>Reading the file</h2>

<p>Okay, you've opened the file, now how to read it? </p>

<p>The <code>open</code> function returns a <a href="https://docs.python.org/2/library/stdtypes.html#bltin-file-objects" rel="noreferrer"><code>file</code></a> object and it supports Pythons iteration protocol. Each iteration will give you a line:</p>

<pre><code>with open(filename) as f:
    for line in f:
        print(line)
</code></pre>

<p>This will print each line of the file. Note however that each line will contain a newline character <code>\n</code> at the end (you might want to check if your Python is built with <a href="https://docs.python.org/2/glossary.html#term-universal-newlines" rel="noreferrer">universal newlines support</a> - otherwise you could also have <code>\r\n</code> on Windows or <code>\r</code> on Mac as newlines). If you don't want that you can could simply remove the last character (or the last two characters on Windows):</p>

<pre><code>with open(filename) as f:
    for line in f:
        print(line[:-1])
</code></pre>

<p>But the last line doesn't necessarily has a trailing newline, so one shouldn't use that. One could check if it ends with a trailing newline and if so remove it:</p>

<pre><code>with open(filename) as f:
    for line in f:
        if line.endswith('\n'):
            line = line[:-1]
        print(line)
</code></pre>

<p>But you could simply remove all whitespaces (including the <code>\n</code> character) from the <em>end of the string</em>, this will also remove all other <em>trailing</em> whitespaces so you have to be careful if these are important:</p>

<pre><code>with open(filename) as f:
    for line in f:
        print(f.rstrip())
</code></pre>

<p>However if the lines end with <code>\r\n</code> (Windows "newlines") that <code>.rstrip()</code> will also take care of the <code>\r</code>!</p>

<h2>Store the contents as list</h2>

<p>Now that you know how to open the file and read it, it's time to store the contents in a list. The simplest option would be to use the <a href="https://docs.python.org/2/library/functions.html#func-list" rel="noreferrer"><code>list</code></a> function:</p>

<pre><code>with open(filename) as f:
    lst = list(f)
</code></pre>

<p>In case you want to strip the trailing newlines you could use a list comprehension instead:</p>

<pre><code>with open(filename) as f:
    lst = [line.rstrip() for line in f]
</code></pre>

<p>Or even simpler: The <a href="https://docs.python.org/2/library/stdtypes.html#file.readlines" rel="noreferrer"><code>.readlines()</code></a> method of the <code>file</code> object by default returns a <code>list</code> of the lines:</p>

<pre><code>with open(filename) as f:
    lst = f.readlines()
</code></pre>

<p>This will also include the trailing newline characters, if you don't want them I would recommend the <code>[line.rstrip() for line in f]</code> approach because it avoids keeping two lists containing all the lines in memory.</p>

<p>There's an additional option to get the desired output, however it's rather "suboptimal": <a href="https://docs.python.org/2/library/stdtypes.html#file.read" rel="noreferrer"><code>read</code></a> the complete file in a string and then split on newlines:</p>

<pre><code>with open(filename) as f:
    lst = f.read().split('\n')
</code></pre>

<p>or:</p>

<pre><code>with open(filename) as f:
    lst = f.read().splitlines()
</code></pre>

<p>These take care of the trailing newlines automatically because the <code>split</code> character isn't included. However they are not ideal because you keep the file as string and as a list of lines in memory!</p>

<h2>Summary</h2>

<ul>
<li>Use <code>with open(...) as f</code> when opening files because you don't need to take care of closing the file yourself and it closes the file even if some exception happens.</li>
<li><code>file</code> objects support the iteration protocol so reading a file line-by-line is as simple as <code>for line in the_file_object:</code>.</li>
<li>Always browse the documentation for the available functions/classes. Most of the time there's a perfect match for the task or at least one or two good ones. The obvious choice in this case would be <code>readlines()</code> but if you want to process the lines before storing them in the list I would recommend a simple list-comprehension.</li>
</ul>
<h4> Comment 105499417 AMC: </h4><i>The last approach is the recommended approach to open a file in Python!</i> Why is it last, then? Won&#39;t the vast majority of people just glance at the first few lines of an answer before moving on?<br><h4> Comment 105500207 MSeifert: </h4>@AMC I haven&#39;t put much thought into it when I wrote the answer. Do you think I should put it at the top of the answer?<br><h4> Comment 105500265 AMC: </h4>It might be best, yeah. I also just noticed that you mention Python 2, so that could be updated, too.<br><h4> Comment 105500539 MSeifert: </h4>Ah the question was originally tagged python-2.x. It may make sense to update it more generally. I&#39;ll see if I come to that in the next time. Thanks for your suggestions. Much appreciated!<br>------------------------------------------------------------------ <br><h3> Answer 27583116 Johnny: </h3><p><strong>Clean and Pythonic Way of Reading the Lines of a File Into a List</strong></p>

<hr>

<p>First and foremost, you should focus on opening your file and reading its contents in an efficient and pythonic way. Here is an example of the way I personally DO NOT prefer:</p>

<pre class="lang-python prettyprint-override"><code>infile = open('my_file.txt', 'r')  # Open the file for reading.

data = infile.read()  # Read the contents of the file.

infile.close()  # Close the file since we're done using it.
</code></pre>

<p>Instead, I prefer the below method of opening files for both reading and writing as it
is very clean, and does not require an extra step of closing the file
once you are done using it. In the statement below, we're opening the file
for reading, and assigning it to the variable 'infile.'  Once the code within
this statement has finished running, the file will be automatically closed.</p>

<pre class="lang-python prettyprint-override"><code># Open the file for reading.
with open('my_file.txt', 'r') as infile:

    data = infile.read()  # Read the contents of the file into memory.
</code></pre>

<p>Now we need to focus on bringing this data into a <strong>Python List</strong> because they are iterable, efficient, and flexible.  In your case, the desired goal is to bring each line of the text file into a separate element. To accomplish this, we will use the <strong>splitlines()</strong> method as follows:</p>

<pre class="lang-python prettyprint-override"><code># Return a list of the lines, breaking at line boundaries.
my_list = data.splitlines()
</code></pre>

<hr>

<p><strong><em>The Final Product:</em></strong></p>

<pre class="lang-python prettyprint-override"><code># Open the file for reading.
with open('my_file.txt', 'r') as infile:

    data = infile.read()  # Read the contents of the file into memory.

# Return a list of the lines, breaking at line boundaries.
my_list = data.splitlines()
</code></pre>

<p><em>Testing Our Code:</em></p>

<ul>
<li>Contents of the text file:</li>
</ul>

<pre class="lang-none prettyprint-override"><code>     A fost odatã ca-n povesti,
     A fost ca niciodatã,
     Din rude mãri împãrãtesti,
     O prea frumoasã fatã.
</code></pre>

<ul>
<li>Print statements for testing purposes:</li>
</ul>

<pre class="lang-python prettyprint-override"><code>    print my_list  # Print the list.

    # Print each line in the list.
    for line in my_list:
        print line

    # Print the fourth element in this list.
    print my_list[3]
</code></pre>

<ul>
<li>Output (different-looking because of unicode characters):</li>
</ul>

<pre class="lang-none prettyprint-override"><code>     ['A fost odat\xc3\xa3 ca-n povesti,', 'A fost ca niciodat\xc3\xa3,',
     'Din rude m\xc3\xa3ri \xc3\xaemp\xc3\xa3r\xc3\xa3testi,', 'O prea
     frumoas\xc3\xa3 fat\xc3\xa3.']

     A fost odatã ca-n povesti, A fost ca niciodatã, Din rude mãri
     împãrãtesti, O prea frumoasã fatã.

     O prea frumoasã fatã.
</code></pre>
------------------------------------------------------------------ <br><h3> Answer 23889306 user1833244: </h3><p>Here's one more option by using list comprehensions on files;</p>

<pre><code>lines = [line.rstrip() for line in open('file.txt')]
</code></pre>

<p>This should be more efficient way as the most of the work is done inside the Python interpreter.</p>
<h4> Comment 48891343 mklement0: </h4><code>rstrip()</code> potentially strips <i>all</i> trailing whitespace, not just the <code>\n</code>; use <code>.rstrip(&#39;\n&#39;)</code>.<br><h4> Comment 105211554 Mark Amery: </h4>This also doesn&#39;t guarantee that the file will be closed after reading in all Python implementations (although in CPython, the main Python implementation, it will be).<br><h4> Comment 105499435 AMC: </h4><i>This should be more efficient way as the most of the work is done inside the Python interpreter.</i> What does that mean?<br><h4> Comment 131003084 ShadowRanger: </h4>@AMC: The wording used is wrong, but building the same <code>list</code> via a listcomp allows for using some special purpose bytecodes that operate more efficiently than a manual loop repeatedly calling <code>.append(line.rstrip())</code> on some <code>list</code> created outside the loop. It&#39;s still doing most of the work in the bytecode interpreter loop, it just does it a little faster. To push the per-item work entirely to the C layer on the CPython reference interpreter, you&#39;d do <code>with open(&#39;file.txt&#39;) as f: lines = list(map(str.rstrip, f))</code>, which would cut the bytecode interpreter out of the loop entirely.<br>------------------------------------------------------------------ <br><h3> Answer 21073824 moldovean: </h3><pre><code>f = open("your_file.txt",'r')
out = f.readlines() # will append in the list out
</code></pre>

<p>Now variable out is a list (array) of what you want. You could either do:</p>

<pre><code>for line in out:
    print (line)
</code></pre>

<p>Or:</p>

<pre><code>for line in f:
    print (line)
</code></pre>

<p>You'll get the same results.</p>
------------------------------------------------------------------ <br><h3> Answer 48288683 Martin Thoma: </h3><p><strong>Read and write text files with Python 2 and Python 3; it works with Unicode</strong></p>

<pre><code>#!/usr/bin/env python3
# -*- coding: utf-8 -*-

# Define data
lines = ['     A first string  ',
         'A Unicode sample: €',
         'German: äöüß']

# Write text file
with open('file.txt', 'w') as fp:
    fp.write('\n'.join(lines))

# Read text file
with open('file.txt', 'r') as fp:
    read_lines = fp.readlines()
    read_lines = [line.rstrip('\n') for line in read_lines]

print(lines == read_lines)
</code></pre>

<p>Things to notice:</p>

<ul>
<li><code>with</code> is a so-called <a href="https://docs.python.org/2/reference/compound_stmts.html#with" rel="noreferrer">context manager</a>. It makes sure that the opened file is closed again.</li>
<li>All solutions here which simply make <code>.strip()</code> or <code>.rstrip()</code> will fail to reproduce the <code>lines</code> as they also strip the white space.</li>
</ul>

<p><strong>Common file endings</strong></p>

<p><code>.txt</code></p>

<p><strong>More advanced file writing/reading</strong></p>

<ul>
<li>CSV: Super simple format (<a href="https://stackoverflow.com/a/41585079/562769">read &amp; write</a>)</li>
<li>JSON: Nice for writing human-readable data; VERY commonly used (<a href="https://stackoverflow.com/a/37795053/562769">read &amp; write</a>)</li>
<li>YAML: YAML is a superset of JSON, but easier to read (<a href="https://stackoverflow.com/a/42054860/562769">read &amp; write</a>, <a href="https://stackoverflow.com/a/1729545/562769">comparison of JSON and YAML</a>)</li>
<li>pickle: A Python serialization format (<a href="https://stackoverflow.com/a/33245595/562769">read &amp; write</a>)</li>
<li><a href="http://msgpack.org/" rel="noreferrer">MessagePack</a> (<a href="https://pypi.python.org/pypi/msgpack-python" rel="noreferrer">Python package</a>): More compact representation (<a href="https://stackoverflow.com/q/43442194/562769">read &amp; write</a>)</li>
<li><a href="https://en.wikipedia.org/wiki/Hierarchical_Data_Format" rel="noreferrer">HDF5</a> (<a href="http://docs.h5py.org/en/latest/quick.html" rel="noreferrer">Python package</a>): Nice for matrices (<a href="https://stackoverflow.com/a/41586571/562769">read &amp; write</a>)</li>
<li>XML: exists too *sigh* (<a href="https://stackoverflow.com/a/1912483/562769">read</a> &amp; <a href="https://stackoverflow.com/a/3605831/562769">write</a>)</li>
</ul>

<p>For your application, the following might be important:</p>

<ul>
<li>Support by other programming languages</li>
<li>Reading/writing performance</li>
<li>Compactness (file size)</li>
</ul>

<p>See also: <em><a href="https://en.wikipedia.org/wiki/Comparison_of_data_serialization_formats" rel="noreferrer">Comparison of data serialization formats</a></em></p>

<p>In case you are rather looking for a way to make configuration files, you might want to read my short article <em><a href="https://martin-thoma.com/configuration-files-in-python/" rel="noreferrer">Configuration files in Python</a></em>.</p>
------------------------------------------------------------------ <br><h3> Answer 20147869 oliland: </h3><p>If you'd like to read a file from the command line or from stdin, you can also use the <code>fileinput</code> module:</p>

<pre><code># reader.py
import fileinput

content = []
for line in fileinput.input():
    content.append(line.strip())

fileinput.close()
</code></pre>

<p>Pass files to it like so:</p>

<pre><code>$ python reader.py textfile.txt 
</code></pre>

<p>Read more here: <a href="http://docs.python.org/2/library/fileinput.html">http://docs.python.org/2/library/fileinput.html</a></p>
------------------------------------------------------------------ <br><h3> Answer 28358149 Jean-Francois T.: </h3><p><strong>The simplest way to do it</strong></p>

<p>A simple way is to:</p>

<ol>
<li>Read the whole file as a string</li>
<li>Split the string line by line</li>
</ol>

<p>In one line, that would give:</p>

<pre><code>lines = open('C:/path/file.txt').read().splitlines()
</code></pre>

<p>However, this is quite inefficient way as this will store 2 versions of the content in memory (probably not a big issue for small files, but still). [Thanks Mark Amery].</p>

<p>There are 2 easier ways:</p>

<ol>
<li>Using the file as an iterator</li>
</ol>

<pre><code>lines = list(open('C:/path/file.txt'))
# ... or if you want to have a list without EOL characters
lines = [l.rstrip() for l in open('C:/path/file.txt')]
</code></pre>

<ol start="2">
<li>If you are using Python 3.4 or above, better use <code>pathlib</code> to create a path for your file that you could use for other operations in your program:</li>
</ol>

<pre><code>from pathlib import Path
file_path = Path("C:/path/file.txt") 
lines = file_path.read_text().split_lines()
# ... or ... 
lines = [l.rstrip() for l in file_path.open()]
</code></pre>
<h4> Comment 105211280 Mark Amery: </h4>This is a bad approach. For one thing, calling <code>.read().splitlines()</code> isn&#39;t in any way &quot;simpler&quot; than just calling <code>.readlines()</code>. For another, it&#39;s memory-inefficient; you&#39;re needlessly storing two versions of the file content (the single string returned by <code>.read()</code>, and the list of strings returned by <code>splitlines()</code>) in memory at once.<br><h4> Comment 105254023 Jean-Francois T.: </h4>@MarkAmery  True. Thanks for highlighting this. I have updated my answer.<br>------------------------------------------------------------------ <br><h3> Answer 39407957 Abdullah Bilal: </h3><p>Just use the splitlines() functions. Here is an example.</p>

<pre><code>inp = "file.txt"
data = open(inp)
dat = data.read()
lst = dat.splitlines()
print lst
# print(lst) # for python 3
</code></pre>

<p>In the output you will have the list of lines.</p>
<h4> Comment 112691192 physicalattraction: </h4>But <code>data.read().splitlines()</code> is much easier to read, and memory is not always a concern compared to ease of reading the code.<br><h4> Comment 105211248 Mark Amery: </h4>Memory-inefficient compared to using <code>.readlines()</code>. This puts two copies of the file content in memory at once (one as a single huge string, one as a list of lines).<br>------------------------------------------------------------------ <br><h3> Answer 42733235 pambda: </h3><p>If you are faced with a <strong>very large / huge file</strong> and want to <strong>read faster</strong> (imagine you are in a <a href="https://en.wikipedia.org/wiki/TopCoder" rel="nofollow noreferrer">TopCoder</a> or <a href="https://en.wikipedia.org/wiki/HackerRank" rel="nofollow noreferrer">HackerRank</a> coding competition), you might read a considerably bigger chunk of lines into a memory buffer at one time, rather than just iterate line by line at file level.</p>
<pre class="lang-python prettyprint-override"><code>buffersize = 2**16
with open(path) as f:
    while True:
        lines_buffer = f.readlines(buffersize)
        if not lines_buffer:
            break
        for line in lines_buffer:
            process(line)
</code></pre>
<h4> Comment 74319300 Khanal: </h4><code>process(line)</code> is a function that you need to implement to process the data. for example, instead of that line, if you use <code>print(line)</code>, it will print each line from the lines_buffer.<br><h4> Comment 73568965 Newskooler: </h4>what does process(line) do? I get an error that there is not such variable defined. I guess something needs importing and I tried to import multiprocessing.Process, but that&#39;s not it I guess. Could you please elaborate? Thanks<br><h4> Comment 89214332 David Dehghan: </h4>f.readlines(buffersize) returns an immutable buffer. if you want to directly read into your buffer you need to use readinto() function. I will be much faster.<br>------------------------------------------------------------------ <br><h3> Answer 55165074 simhumileco: </h3><h3>The easiest ways to do that with some additional benefits are:</h3>
<pre><code>lines = list(open('filename'))
</code></pre>
<p>or</p>
<pre><code>lines = tuple(open('filename'))
</code></pre>
<p>or</p>
<pre><code>lines = set(open('filename'))
</code></pre>
<p>In the case with <code>set</code>, we must be remembered that we don't have the line order preserved and get rid of the duplicated lines.</p>
<h3>Below I added an  important supplement from <em>@MarkAmery</em>:</h3>
<blockquote>
<p>Since you're not calling <code>.close</code> on the file object nor using a <code>with</code> statement, in some <em>Python</em> implementations <strong>the file may not get closed after reading and your process will leak an open file handle</strong>.</p>
<p><strong>In <em>CPython</em> (the normal <em>Python</em> implementation that most people use), this isn't a problem since the file object will get immediately garbage-collected and this will close the file, but it's nonetheless generally considered best practice to do something like</strong>:</p>
</blockquote>
<pre><code>with open('filename') as f: lines = list(f) 
</code></pre>
<blockquote>
<p>to ensure that the file gets closed regardless of what <em>Python</em> implementation you're using.</p>
</blockquote>
<h4> Comment 105211041 Mark Amery: </h4>Since you&#39;re not calling <code>.close</code> on the file object nor using a <code>with</code> statement, in some Python implementations the file may not get closed after reading and your process will leak an open file handle. In CPython (the normal Python implementation that most people use), this isn&#39;t a problem since the file object will get immediately garbage-collected and this will close the file, but it&#39;s nonetheless generally considered best practice to do something like <code>with open(&#39;filename&#39;) as f: lines = list(f)</code> to ensure that the file gets closed regardless of what Python implementation you&#39;re using.<br><h4> Comment 105499491 AMC: </h4>@simhumileco Why have the best (correct) solution last?<br><h4> Comment 105503369 simhumileco: </h4>@AMC because first, I wanted to show the simplest ways and for consistency of reasoning.<br><h4> Comment 105504613 simhumileco: </h4>Besides, I hope my answer is made so that it is short and easy to read.<br><h4> Comment 105231050 simhumileco: </h4>Thank you for your great comment @MarkAmery! I really appreciate it.<br>------------------------------------------------------------------ <br><h3> Answer 36313833 Zero: </h3><p>Use this:</p>

<pre><code>import pandas as pd
data = pd.read_csv(filename) # You can also add parameters such as header, sep, etc.
array = data.values
</code></pre>

<p><code>data</code> is a dataframe type, and uses values to get ndarray. You can also get a list by using <code>array.tolist()</code>.</p>
<h4> Comment 105499664 AMC: </h4><code>pandas.read_csv()</code> is for reading <b>CSV</b> data, how is it appropriate here?<br>------------------------------------------------------------------ <br><h3> Answer 54225699 jeanggi90: </h3><p>In case that there are also empty lines in the document I like to read in the content and pass it through <code>filter</code> to prevent empty string elements</p>

<pre><code>with open(myFile, "r") as f:
    excludeFileContent = list(filter(None, f.read().splitlines()))
</code></pre>
<h4> Comment 105499647 AMC: </h4>This is unpythonic, be careful.<br><h4> Comment 131003128 ShadowRanger: </h4>Save some large intermediate temporaries with <code>excludeFileContent = list(filter(None, map(str.rstrip, f)))</code>, or, to preserve non-newline trailing whitespace (using <code>str.rstrip</code> as the mapper function strips any and all types of trailing whitespace), add an import (<code>from operator import methodcaller</code>) and do <code>excludeFileContent = list(filter(None, map(methodcaller(&#39;rstrip&#39;, &#39;\n&#39;), f)))</code>.<br>------------------------------------------------------------------ <br><h3> Answer 50379267 Russia Must Remove Putin: </h3><h2>Outline and Summary</h2>

<p>With a <code>filename</code>, handling the file from a <code>Path(filename)</code> object, or directly with <code>open(filename) as f</code>, do one of the following:</p>

<ul>
<li><code>list(fileinput.input(filename))</code></li>
<li>using <code>with path.open() as f</code>, call <code>f.readlines()</code> </li>
<li><code>list(f)</code></li>
<li><code>path.read_text().splitlines()</code></li>
<li><code>path.read_text().splitlines(keepends=True)</code></li>
<li>iterate over <code>fileinput.input</code> or <code>f</code> and <code>list.append</code> each line one at a time</li>
<li>pass <code>f</code> to a bound <code>list.extend</code> method</li>
<li>use <code>f</code> in a list comprehension</li>
</ul>

<p>I explain the use-case for each below.</p>

<blockquote>
  <h2>In Python, how do I read a file line-by-line?</h2>
</blockquote>

<p>This is an excellent question. First, let's create some sample data:</p>

<pre><code>from pathlib import Path
Path('filename').write_text('foo\nbar\nbaz')
</code></pre>

<p>File objects are lazy iterators, so just iterate over it.</p>

<pre><code>filename = 'filename'
with open(filename) as f:
    for line in f:
        line # do something with the line
</code></pre>

<p>Alternatively, if you have multiple files, use <code>fileinput.input</code>, another lazy iterator. With just one file:</p>

<pre><code>import fileinput

for line in fileinput.input(filename): 
    line # process the line
</code></pre>

<p>or for multiple files, pass it a list of filenames:</p>

<pre><code>for line in fileinput.input([filename]*2): 
    line # process the line
</code></pre>

<p>Again, <code>f</code> and <code>fileinput.input</code> above both are/return lazy iterators.
You can only use an iterator one time, so to provide functional code while avoiding verbosity I'll use the slightly more terse <code>fileinput.input(filename)</code> where apropos from here.</p>

<blockquote>
  <h2>In Python, how do I read a file line-by-line <strong>into a list?</strong></h2>
</blockquote>

<p>Ah but you want it in a list for some reason? I'd avoid that if possible. But if you insist... just pass the result of <code>fileinput.input(filename)</code> to <code>list</code>:</p>

<pre><code>list(fileinput.input(filename))
</code></pre>

<p>Another direct answer is to call <code>f.readlines</code>, which returns the contents of the file (up to an optional <code>hint</code> number of characters, so you <em>could</em> break this up into multiple lists that way). </p>

<p>You can get to this file object two ways. One way is to pass the filename to the <code>open</code> builtin:</p>

<pre><code>filename = 'filename'

with open(filename) as f:
    f.readlines()
</code></pre>

<p>or using the new Path object from the <code>pathlib</code> module (which I have become quite fond of, and will use from here on):</p>

<pre><code>from pathlib import Path

path = Path(filename)

with path.open() as f:
    f.readlines()
</code></pre>

<p><code>list</code> will also consume the file iterator and return a list - a quite direct method as well:</p>

<pre><code>with path.open() as f:
    list(f)
</code></pre>

<p>If you don't mind reading the entire text into memory as a single string before splitting it, you can do this as a one-liner with the <code>Path</code> object and the <code>splitlines()</code> string method. By default, <code>splitlines</code> removes the newlines:</p>

<pre><code>path.read_text().splitlines()
</code></pre>

<p>If you want to keep the newlines, pass <code>keepends=True</code>:</p>

<pre><code>path.read_text().splitlines(keepends=True)
</code></pre>

<blockquote>
  <p>I want to read the file line by line and append each line to the end of the list.</p>
</blockquote>

<p>Now this is a bit silly to ask for, given that we've demonstrated the end result easily with several methods. But you might need to filter or operate on the lines as you make your list, so let's humor this request.</p>

<p>Using <code>list.append</code> would allow you to filter or operate on each line before you append it:</p>

<pre><code>line_list = []
for line in fileinput.input(filename):
    line_list.append(line)

line_list
</code></pre>

<p>Using <code>list.extend</code> would be a bit more direct, and perhaps useful if you have a preexisting list:</p>

<pre><code>line_list = []
line_list.extend(fileinput.input(filename))
line_list
</code></pre>

<p>Or more idiomatically, we could instead use a list comprehension, and map and filter inside it if desirable:</p>

<pre><code>[line for line in fileinput.input(filename)]
</code></pre>

<p>Or even more directly, to close the circle, just pass it to list to create a new list directly without operating on the lines:</p>

<pre><code>list(fileinput.input(filename))
</code></pre>

<h2>Conclusion</h2>

<p>You've seen many ways to get lines from a file into a list, but I'd recommend you avoid materializing large quantities of data into a list and instead use Python's lazy iteration to process the data if possible.</p>

<p>That is, prefer <code>fileinput.input</code> or <code>with path.open() as f</code>.</p>
------------------------------------------------------------------ <br><h3> Answer 53843488 Siddharth Satpathy: </h3><p>I would try one of the below mentioned methods. The example file that I use has the name <code>dummy.txt</code>. You can find the file <a href="https://drive.google.com/file/d/1v7ksgTyPXTCxWKLphhzJ9pV_HnxP3Rnu/view?usp=sharing" rel="nofollow noreferrer">here</a>. I presume that the file is in the same directory as the code (you can change <code>fpath</code> to include the proper file name and folder path).</p>
<p>In both the below mentioned examples, the list that you want is given by <code>lst</code>.</p>
<h3>1. First method</h3>
<pre><code>fpath = 'dummy.txt'
with open(fpath, &quot;r&quot;) as f: lst = [line.rstrip('\n \t') for line in f]

print lst
&gt;&gt;&gt;['THIS IS LINE1.', 'THIS IS LINE2.', 'THIS IS LINE3.', 'THIS IS LINE4.']
</code></pre>
<h3>2. In the <strong>second method</strong>, one can use <strong><a href="https://docs.python.org/3/library/csv.html" rel="nofollow noreferrer">csv.reader</a> module from Python Standard Library</strong>:</h3>
<pre><code>import csv
fpath = 'dummy.txt'
with open(fpath) as csv_file:
    csv_reader = csv.reader(csv_file, delimiter='   ')
    lst = [row[0] for row in csv_reader] 

print lst
&gt;&gt;&gt;['THIS IS LINE1.', 'THIS IS LINE2.', 'THIS IS LINE3.', 'THIS IS LINE4.']
</code></pre>
<p>You can use either of the two methods. The time taken for the creation of <code>lst</code> is almost equal for the two methods.</p>
<h4> Comment 94833583 Charlie Harding: </h4>What’s the advantage of the second approach? Why invoke an additional library, which adds in edge cases (the delimiter, and quotes)?<br><h4> Comment 105499682 AMC: </h4>What is the <code>delimiter=&#39;   &#39;</code> argument for?<br>------------------------------------------------------------------ <br><h3> Answer 31522796 asampat3090: </h3><p>You could also use the loadtxt command in NumPy. This checks for fewer conditions than genfromtxt, so it may be faster.</p>

<pre><code>import numpy
data = numpy.loadtxt(filename, delimiter="\n")
</code></pre>
------------------------------------------------------------------ <br><h3> Answer 49553803 Daniel: </h3><p>I like to use the following. Reading the lines immediately.</p>

<pre><code>contents = []
for line in open(filepath, 'r').readlines():
    contents.append(line.strip())
</code></pre>

<p>Or using list comprehension:</p>

<pre><code>contents = [line.strip() for line in open(filepath, 'r').readlines()]
</code></pre>
<h4> Comment 92802727 Eric O. Lebigot: </h4>There is no need for <code>readlines()</code>, which even incurs a memory penalty. You can simply remove it, as iterating over a (text) file gives each line in turn.<br><h4> Comment 93001853 Aran-Fey: </h4>You should use a <code>with</code> statement to open (and implicitly close) the file.<br>------------------------------------------------------------------ <br><h3> Answer 55774582 Malekai: </h3><p>Here is a Python(3) helper <s>library</s> class that I use to simplify file I/O:</p>

<pre><code>import os

# handle files using a callback method, prevents repetition
def _FileIO__file_handler(file_path, mode, callback = lambda f: None):
  f = open(file_path, mode)
  try:
    return callback(f)
  except Exception as e:
    raise IOError("Failed to %s file" % ["write to", "read from"][mode.lower() in "r rb r+".split(" ")])
  finally:
    f.close()


class FileIO:
  # return the contents of a file
  def read(file_path, mode = "r"):
    return __file_handler(file_path, mode, lambda rf: rf.read())

  # get the lines of a file
  def lines(file_path, mode = "r", filter_fn = lambda line: len(line) &gt; 0):
    return [line for line in FileIO.read(file_path, mode).strip().split("\n") if filter_fn(line)]

  # create or update a file (NOTE: can also be used to replace a file's original content)
  def write(file_path, new_content, mode = "w"):
    return __file_handler(file_path, mode, lambda wf: wf.write(new_content))

  # delete a file (if it exists)
  def delete(file_path):
    return os.remove() if os.path.isfile(file_path) else None
</code></pre>

<p>You would then use the <code>FileIO.lines</code> function, like this:</p>

<pre><code>file_ext_lines = FileIO.lines("./path/to/file.ext"):
for i, line in enumerate(file_ext_lines):
  print("Line {}: {}".format(i + 1, line))
</code></pre>

<p>Remember that the <code>mode</code> (<code>"r"</code> by default) and <code>filter_fn</code> (checks for empty lines by default) parameters are optional.</p>

<p>You could even remove the <code>read</code>, <code>write</code> and <code>delete</code> methods and just leave the <code>FileIO.lines</code>, or even turn it into a separate method called <code>read_lines</code>.</p>
<h4> Comment 105210535 Mark Amery: </h4>Is <code>lines = FileIO.lines(path)</code> really enough simpler than <code>with open(path) as f: lines = f.readlines()</code> to justify this helper&#39;s existence? You&#39;re saving, like, 17 characters per call. (And most of the time, for performance and memory reasons, you&#39;ll want to loop over a file object directly instead of reading its lines into a list anyway, so you won&#39;t even want to use this often!) I&#39;m often a fan of creating little utility functions, but this one feels to me like it&#39;s just needlessly creating a new way to write something that&#39;s already short and easy with the standard library gives us.<br><h4> Comment 105499716 AMC: </h4>In addition to what @MarkAmery said, why use a class for this?<br>------------------------------------------------------------------ <br><h3> Answer 45949906 jasonleonhard: </h3><h3>Command line version</h3>

<pre><code>#!/bin/python3
import os
import sys
abspath = os.path.abspath(__file__)
dname = os.path.dirname(abspath)
filename = dname + sys.argv[1]
arr = open(filename).read().split("\n") 
print(arr)
</code></pre>

<h3>Run with:</h3>

<pre><code>python3 somefile.py input_file_name.txt
</code></pre>
<h4> Comment 117907975 mah: </h4>Why on earth would you want to require the text file be in the same directory your python script is in? Just <code>open(sys.argv[1])</code> instead and it&#39;ll work regardless of a relative path or absolute path being specified, and it won&#39;t care where your script lives.<br>