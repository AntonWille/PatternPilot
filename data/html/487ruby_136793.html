 <h2> Title: Is there a &quot;do ... while&quot; loop in Ruby? </h2> <h3> Paige Ruten, question_id: 136793 </h3>Score: 487, Tags: {ruby,loops} <br><p>I'm using this code to let the user enter in names while the program stores them in an array until they enter an empty string (they must press enter after each name):</p>

<pre><code>people = []
info = 'a' # must fill variable with something, otherwise loop won't execute

while not info.empty?
    info = gets.chomp
    people += [Person.new(info)] if not info.empty?
end
</code></pre>

<p>This code would look much nicer in a do ... while loop:</p>

<pre><code>people = []

do
    info = gets.chomp
    people += [Person.new(info)] if not info.empty?
while not info.empty?
</code></pre>

<p>In this code I don't have to assign info to some random string.</p>

<p>Unfortunately this type of loop doesn't seem to exist in Ruby. Can anybody suggest a better way of doing this?</p>
<h4> Comment 29736199 Magne: </h4>I think the normal while loop looks nicer, and is easier to read.<br><h4> Comment 35946296 David Winiecki: </h4>@Jeremy Ruten is there any chance you would be interested in changing the accepted answer to Siwei Shen&#39;s answer, <code>loop do; ...; break if ...; end</code>?<br>------------------------------------------------------------------ <br><h3> Answer 10713963 Siwei: </h3><p><strong>CAUTION</strong>:</p>
<p>The <code>begin &lt;code&gt; end while &lt;condition&gt;</code> is rejected by Ruby's author Matz. Instead he suggests using <code>Kernel#loop</code>, e.g.</p>
<pre><code>loop do 
  # some code here
  break if &lt;condition&gt;
end 
</code></pre>
<p>Here's <a href="https://web.archive.org/web/20220322235418/http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-core/6745" rel="noreferrer">an email exchange</a> in 23 Nov 2005 where Matz states:</p>
<pre><code>|&gt; Don't use it please.  I'm regretting this feature, and I'd like to
|&gt; remove it in the future if it's possible.
|
|I'm surprised.  What do you regret about it?

Because it's hard for users to tell

  begin &lt;code&gt; end while &lt;cond&gt;

works differently from

  &lt;code&gt; while &lt;cond&gt;
</code></pre>
<p><a href="http://rosettacode.org/wiki/Loops/Do-while#Ruby" rel="noreferrer">RosettaCode wiki</a> has a similar story:</p>
<blockquote>
<p>During November 2005, Yukihiro Matsumoto, the creator of Ruby, regretted this loop feature and suggested using Kernel#loop.</p>
</blockquote>
<h4> Comment 18570309 Joshua Pinter: </h4>Spot on. This <code>begin end while</code> method didn&#39;t seem right. Thanks for giving me the fodder I needed to convince the rest of the team.<br><h4> Comment 43903336 AgostinoX: </h4>So,as far as I&#39;ve understood well,begin-end-while is &quot;regretted&quot; because violates the semantic of modifiers, that is:they are checked before executing the block, for example: puts k if !k.nil?. Here &#39;if&#39; is a &#39;modifier&#39;:it is checked BEFORE,in order to determine whether executing the &#39;puts k&#39; statement.That&#39;s not the case of while/until loops that(when used as modifiers of a begin-end-block!),are evaluated AFTER the first execution.Maybe this caused the regretting,but have we something &#39;stronger&#39; than an old forum post,sort of an official deprecation like it uses to be in many other occasions?<br><h4> Comment 56430776 Connor Clark: </h4>It took me an embarrassing amount of time to figure out why my use of this ruby &#39;do-while&#39; loop wasn&#39;t working. You should use &#39;unless&#39; to more closely mimic a c-style do-while, otherwise you may end up like me and forget to invert the condition :p<br><h4> Comment 96364829 Xiong Chiamiov: </h4>@James As per the linked mail, he said he was &quot;regretting&quot; adding it.  Sometimes people make mistakes, even if they&#39;re language designers.<br><h4> Comment 24672895 user1992284: </h4>It looks like the begin-end-while loop is actually evaluating the condition before running the loop.  The difference between that and a regular while loop is that it&#39;s guaranteed to run at least once.  It&#39;s just close enough to do...while to cause problems.<br><h4> Comment 129715764 equivalent8: </h4>also preferred in Ruby style guide <a href="https://github.com/rubocop/ruby-style-guide#loop-with-break" rel="nofollow noreferrer">github.com/rubocop/ruby-style-guide#loop-with-break</a><br><h4> Comment 54634452 Rob: </h4>This is the explanation I was looking for when I wondered why there is a Rubocop check for this (Lint/Loop) <a href="https://github.com/bbatsov/rubocop/blob/v0.34.2/lib/rubocop/cop/lint/loop.rb" rel="nofollow noreferrer">github.com/bbatsov/rubocop/blob/v0.34.2/lib/rubocop/cop/lint&zwnj;&#8203;/&hellip;</a><br><h4> Comment 92148590 TheBritishAreComing: </h4>I don&#39;t understand, why would he add it to the language if he doesn&#39;t agree with its use?<br><h4> Comment 60560050 pablo: </h4>In my Ruby 2.2.3 &amp; 1.9.3 while condition is evaluated after running begin-end loop. Check out this code snippet: <a href="https://repl.it/CDJE/0" rel="nofollow noreferrer">repl.it/CDJE/0</a><br>------------------------------------------------------------------ <br><h3> Answer 136815 hubbardr: </h3><blockquote>
<p>I found the following snippet while reading the source for <code>Tempfile#initialize</code> in the Ruby core library:</p>
<pre><code>begin
  tmpname = File.join(tmpdir, make_tmpname(basename, n))
  lock = tmpname + '.lock'
  n += 1
end while @@cleanlist.include?(tmpname) or
  File.exist?(lock) or File.exist?(tmpname)
</code></pre>
<p>At first glance, I assumed the while modifier would be evaluated before the contents of begin...end, but that is not the case. Observe:</p>
<pre><code>&gt;&gt; begin
?&gt;   puts &quot;do {} while ()&quot; 
&gt;&gt; end while false
do {} while ()
=&gt; nil
</code></pre>
<p>As you would expect, the loop will continue to execute while the modifier is true.</p>
<pre><code>&gt;&gt; n = 3
=&gt; 3
&gt;&gt; begin
?&gt;   puts n
&gt;&gt;   n -= 1
&gt;&gt; end while n &gt; 0
3
2
1
=&gt; nil
</code></pre>
<p>While I would be happy to never see this idiom again, begin...end is quite powerful. The following is a common idiom to memoize a one-liner method with no params:</p>
<pre><code>def expensive
  @expensive ||= 2 + 2
end
</code></pre>
<p>Here is an ugly, but quick way to memoize something more complex:</p>
<pre><code>def expensive
  @expensive ||=
    begin
      n = 99
      buf = &quot;&quot; 
      begin
        buf &lt;&lt; &quot;#{n} bottles of beer on the wall\n&quot; 
        # ...
        n -= 1
      end while n &gt; 0
      buf &lt;&lt; &quot;no more bottles of beer&quot; 
    end
end
</code></pre>
</blockquote>
<p><em>Originally written by <a href="https://twitter.com/jvoorhis" rel="noreferrer">Jeremy Voorhis</a>.  The content has been copied here because it seems to have been taken down from the originating site.  Copies can also be found in the <a href="http://web.archive.org/web/20080206125158/http://archive.jvoorhis.com/articles/2007/06/13/ruby-hidden-do-while-loop" rel="noreferrer">Web Archive</a> and at <a href="http://www.artima.com/forums/flat.jsp?forum=123&amp;thread=208036" rel="noreferrer">Ruby Buzz Forum</a>.  -Bill the Lizard</em></p>
<h4> Comment 3866520 davr: </h4>This is why when linking to an external site, I always make sure to copy the relevant info into my answer here.<br><h4> Comment 20832516 bergie3000: </h4>Why would you expect the while modifier to be evaluated before the contents of begin...end? That&#39;s the way do..while loops are supposed to work. And why would you &quot;be happy to never see this idiom again?&quot; What&#39;s wrong with it? I&#39;m confused.<br><h4> Comment 3430619 bta: </h4>Courtesy of the Wayback Machine: <a href="http://web.archive.org/web/20080206125158/http://archive.jvoorhis.com/articles/2007/06/13/ruby-hidden-do-while-loop" rel="nofollow noreferrer">web.archive.org/web/20080206125158/http://archive.jvoorhis.c&zwnj;&#8203;om/&hellip;</a><br><h4> Comment 24556427 Victor Pudeyev: </h4>begin...end looks like a block, similarly {...}. Nothing wrong with it.<br><h4> Comment 28852863 Kevin: </h4>-1: Siwei Shen&#39;s answer explains that <code>begin .. end</code> is somewhat frowned upon. Use <code>loop do .. break if &lt;condition&gt;</code> instead.<br><h4> Comment 60353950 hubbardr: </h4>@Jacob I know :| It was originally just a link but as the commenters mention, it was taken down so an editor changed the post and copied in the content. This is not what I originally posted. :)<br><h4> Comment 51064580 choonkeat: </h4>@Fedcomp sorry, comparing with other languages is rather moot. the point is that ruby is inconsistent with itself, hence language designer regrets it. i&#39;ve expanded my gist to clarify what &quot;inconsistent&quot; means <a href="https://gist.github.com/choonkeat/9815130" rel="nofollow noreferrer">gist.github.com/choonkeat/9815130</a><br><h4> Comment 60351953 Jacob: </h4>Pretty sweet how you scored 176 upvotes for Jeremy Voorhis&#39; answer!<br><h4> Comment 51027089 Fedcomp: </h4>@choonkeat use while then? i really dont understand what&#39;s wrong with common in other languages do while expression.<br>------------------------------------------------------------------ <br><h3> Answer 136825 Blorgbeard: </h3><p>Like this:</p>

<pre><code>people = []

begin
  info = gets.chomp
  people += [Person.new(info)] if not info.empty?
end while not info.empty?
</code></pre>

<p>Reference: <a href="http://web.archive.org/web/20080206125158/http://archive.jvoorhis.com/articles/2007/06/13/ruby-hidden-do-while-loop" rel="noreferrer">Ruby's Hidden do {} while () Loop</a></p>
<h4> Comment 8224898 Andrew Grimm: </h4>You can use <code>until info.empty?</code> rather than <code>while not info.empty?</code>.<br><h4> Comment 4947967 tokland: </h4>Although it does not apply here, one problem of the begin-end-while construct is that, unlike all other ruby constructions, it does not return the value of the last expression: &quot;begin 1 end while false&quot; returns nil (not 1, not false)<br><h4> Comment 35366 AndrewR: </h4>Won&#39;t this code add an empty string to the array if there is no input?<br><h4> Comment 19163688 baash05: </h4>Actually @AndrewR that&#39;s sort of the point.. to do things before a compare..  do diplay(&quot;remaining =#{count} ) while(count &gt; 0)... I get a display of &quot;remaining = 0&quot;.. perfect!<br>------------------------------------------------------------------ <br><h3> Answer 136846 AndrewR: </h3><p>How about this?</p>

<pre><code>people = []

until (info = gets.chomp).empty?
  people += [Person.new(info)]
end
</code></pre>
<h4> Comment 35998 Alexander Prokofyev: </h4>But this isn&#39;t &quot;do ... while&quot; loop. :)<br><h4> Comment 1939488 Scott Swezey: </h4>@Blorgbeard, a do..while loop always runs once, then evaluates to see if it should continue running. A traditional while/until loop can run 0 times.  It isn&#39;t a HUGE difference, but they are different.<br><h4> Comment 2646834 Blorgbeard: </h4>@Scott, that&#39;s true - I just meant that this code is equivalent to the OP&#39;s, even though it doesn&#39;t use a do/while. Although really, this code does half of the loop&#39;s &quot;work&quot; in the condition, so it&#39;s not quite a traditional while loop either - if the condition doesn&#39;t match, some work is still done.<br><h4> Comment 45035 Blorgbeard: </h4>But it does the same thing in this case, unless I&#39;m mistaken<br><h4> Comment 6511056 Venkat D.: </h4>Just tried this. You can have a block of the form begin ... end until. Cool!<br><h4> Comment 8526786 davorb: </h4>This is a while loop, not a do..while one.<br><h4> Comment 19163810 baash05: </h4>Not a do while loop.. tis a simple while do.<br><h4> Comment 20843036 Eva: </h4>The question was whether someone could suggest a better way of writing the code, which does not necessarily require a do while. Since this answers the question elegantly, +1.<br>------------------------------------------------------------------ <br><h3> Answer 14918579 Steely Wing: </h3><p>This works correctly now:</p>

<pre><code>begin
    # statment
end until &lt;condition&gt;
</code></pre>

<p>But, it may be remove in the future, because the <code>begin</code> statement is counterintuitive. See: <a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-core/6745" rel="noreferrer">http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-core/6745</a></p>

<p>Matz (Rubyâ€™s Creator) recommended doing it this way:</p>

<pre><code>loop do
    # ...
    break if &lt;condition&gt;
end
</code></pre>
------------------------------------------------------------------ <br><h3> Answer 3310563 jvoorhis: </h3><p>Here's the full text article from hubbardr's dead link to my blog.</p>

<p>I found the following snippet while reading the source for <code>Tempfile#initialize</code> in the Ruby core library:</p>

<pre><code>begin
  tmpname = File.join(tmpdir, make_tmpname(basename, n))
  lock = tmpname + '.lock'
  n += 1
end while @@cleanlist.include?(tmpname) or
  File.exist?(lock) or File.exist?(tmpname)
</code></pre>

<p>At first glance, I assumed the <code>while</code> modifier would be evaluated before the contents of <code>begin...end</code>, but that is not the case. Observe:</p>

<pre><code>&gt;&gt; begin
?&gt;   puts "do {} while ()" 
&gt;&gt; end while false
do {} while ()
=&gt; nil
</code></pre>

<p>As you would expect, the loop will continue to execute while the modifier is true.</p>

<pre><code>&gt;&gt; n = 3
=&gt; 3
&gt;&gt; begin
?&gt;   puts n
&gt;&gt;   n -= 1
&gt;&gt; end while n &gt; 0
3
2
1
=&gt; nil
</code></pre>

<p>While I would be happy to never see this idiom again, <code>begin...end</code> is quite powerful. The following is a common idiom to memoize a one-liner method with no params:</p>

<pre><code>def expensive
  @expensive ||= 2 + 2
end
</code></pre>

<p>Here is an ugly, but quick way to memoize something more complex:</p>

<pre><code>def expensive
  @expensive ||=
    begin
      n = 99
      buf = "" 
      begin
        buf &lt;&lt; "#{n} bottles of beer on the wall\n" 
        # ...
        n -= 1
      end while n &gt; 0
      buf &lt;&lt; "no more bottles of beer" 
    end
end
</code></pre>
------------------------------------------------------------------ <br><h3> Answer 18495469 jds: </h3><p>From what I gather, Matz does not like the construct</p>

<pre><code>begin
    &lt;multiple_lines_of_code&gt;
end while &lt;cond&gt;
</code></pre>

<p>because, it's semantics is different than</p>

<pre><code>&lt;single_line_of_code&gt; while &lt;cond&gt;
</code></pre>

<p>in that the first construct executes the code first before checking the condition,
and the second construct tests the condition first before it executes the code (if ever). I take it Matz prefers to keep the second construct because it matches one line construct of if statements.</p>

<p>I never liked the second construct even for if statements. In all other cases, the computer
executes code left-to-right (eg. || and &amp;&amp;) top-to-bottom. Humans read code left-to-right
top-to-bottom.</p>

<p>I suggest the following constructs instead:</p>

<pre><code>if &lt;cond&gt; then &lt;one_line_code&gt;      # matches case-when-then statement

while &lt;cond&gt; then &lt;one_line_code&gt;

&lt;one_line_code&gt; while &lt;cond&gt;

begin &lt;multiple_line_code&gt; end while &lt;cond&gt; # or something similar but left-to-right
</code></pre>

<p>I don't know if those suggestions will parse with the rest of the language. But in any case
I prefere keeping left-to-right execution as well as language consistency.</p>
------------------------------------------------------------------ <br><h3> Answer 3410762 Paul Gillard: </h3><pre><code>a = 1
while true
  puts a
  a += 1
  break if a &gt; 10
end
</code></pre>
<h4> Comment 4638472 Gerhard: </h4>this looks a bit like a goto. The code obfusticate your intention.<br><h4> Comment 35946389 David Winiecki: </h4>Looks great to me, except <code>while true</code> can be replaced with <code>loop do</code>.<br><h4> Comment 82644392 Jochem Schulenklopper: </h4>@DavidWiniecki, indeed, <code>while true</code> can be replaced with <code>loop do</code>. But I tested both constructs with a lot of iterations inside the loop, and discovered that <code>while true</code> is at least 2x <i>faster</i> than <code>loop do</code>. Can&#39;t explain the difference, but it&#39;s definitely there. (Discovered while testing Advent of Code 2017, day 15.)<br>------------------------------------------------------------------ <br><h3> Answer 8079629 Moray: </h3><p>Here's another one:</p>

<pre><code>people = []
1.times do
  info = gets.chomp
  unless info.empty? 
    people += [Person.new(info)]
    redo
  end
end
</code></pre>
<h4> Comment 12211071 Michael Durrant: </h4>I prefer this as the <code>unless</code> is right up front and I don&#39;t read through a bunch of code (which could be more than shown here) only to find a &#39;dangling&#39; <code>unless</code> at the end.  It&#39;s a general principle in code that modifier and conditions are easier to use when they are &#39;up front&#39; like this.<br><h4> Comment 19163888 baash05: </h4>I sometimes wish we coders had to pay cash for every extra compare. And that how it &quot;looks&quot; to us was less important than how it looks to the thing that uses it a million times a day.<br>------------------------------------------------------------------ <br><h3> Answer 2044069 is_that_okay: </h3><pre><code>ppl = []
while (input=gets.chomp)
 if !input.empty?
  ppl &lt;&lt; input
 else
 p ppl; puts "Goodbye"; break
 end
end
</code></pre>
<h4> Comment 4638490 Gerhard: </h4>this looks a bit like a goto. The code obfusticate your intention and looks very unruby like.<br><h4> Comment 49051695 qedk: </h4>obfuscate* not obfusticate.<br>