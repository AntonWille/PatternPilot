 <h2> Title: What does ** (double star/asterisk) and * (star/asterisk) do for parameters? </h2> <h4> Todd, question_id: 36901 </h4>Score: 3360, Tags: {python,syntax,parameter-passing,variadic-functions,argument-unpacking} <br><p>What do <code>*args</code> and <code>**kwargs</code> mean in these function definitions?</p>
<pre><code>def foo(x, y, *args):
    pass

def bar(x, y, **kwargs):
    pass
</code></pre>
<hr />
<p><sub>See <a href="https://stackoverflow.com/questions/2921847">What do ** (double star/asterisk) and * (star/asterisk) mean in a function call?</a> for the complementary question about arguments.</sub></p>
<h4> Aran-Fey, Id: 97343204 Score: 159: </h4>This question is a very popular duplicate target, but unfortunately it&#39;s often used incorrectly. Keep in mind that this question asks about <b>defining functions with varargs</b> (<code>def func(*args)</code>). For a question asking what it means in function <i>calls</i> (<code>func(*[1,2])</code>) see <a href="https://stackoverflow.com/questions/5239856/1222951">here</a>. For a question asking <i>how</i> to unpack argument lists see <a href="https://stackoverflow.com/q/3480184/1222951">here</a>. For a question asking what the <code>*</code> means in <i>literals</i> (<code>[*[1, 2]]</code>) see <a href="https://stackoverflow.com/q/36980992/1222951">here</a>.<br><h4> Russia Must Remove Putin, Id: 85121837 Score: 14: </h4>see also <a href="https://stackoverflow.com/questions/6967632/unpacking-extended-unpacking-and-nested-extended-unpacking" title="unpacking extended unpacking and nested extended unpacking">stackoverflow.com/questions/6967632/&hellip;</a><br><h4> ShadowRanger, Id: 115318596 Score: 4: </h4>@Aran-Fey: I think a better target for &quot;what does it mean in function calls&quot; is <a href="https://stackoverflow.com/q/2921847/364696">What does the star operator mean, in a function call?</a>. <a href="https://stackoverflow.com/questions/5239856/1222951">Your link</a> doesn&#39;t really address the use of <code>**</code>, and it a much narrower question.<br><h4> Karl Knechtel, Id: 127051533 Score: 1: </h4>This question is - like many very old questions - sort of backwards; usually a question should be about how to solve a problem in new code, rather than how to understand existing code. For the latter, if you are closing something else as a duplicate, consider <a href="https://stackoverflow.com/questions/1993727/expanding-tuples-into-arguments" title="expanding tuples into arguments">stackoverflow.com/questions/1993727/&hellip;</a> (although this only covers <code>*</code> and not <code>**</code>).<br><h4> Karl Knechtel, Id: 128406992 Score: 0: </h4><a href="https://stackoverflow.com/questions/3394835/use-of-args-and-kwargs" title="use of args and kwargs">stackoverflow.com/questions/3394835/use-of-args-and-kwargs</a> was also closed as a duplicate of this, but you might find it better than this one.<br><h4> Karl Knechtel, Id: 128407014 Score: 0: </h4>There&#39;s also <a href="https://stackoverflow.com/questions/23744017/how-to-pass-through-python-args-and-kwargs" title="how to pass through python args and kwargs">stackoverflow.com/questions/23744017/&hellip;</a>, covering both parameters and arguments, with both <code>*</code> and <code>**</code>, in practical situations - but not in very much detail. (Some answers here talk about arguments, but the question is not really up to par.)<br>------------------------------------------------------------------ <br><h3> Peter Hoffmann, Id: 36908, Score: 3194: </h3><p>The <code>*args</code> and <code>**kwargs</code> are common idioms to allow an arbitrary number of arguments to functions, as described in the section <a href="http://docs.python.org/3/tutorial/controlflow.html#more-on-defining-functions" rel="noreferrer">more on defining functions</a> in the Python tutorial.</p>
<p>The <code>*args</code> will give you all positional arguments <a href="https://docs.python.org/3/tutorial/controlflow.html#arbitrary-argument-lists" rel="noreferrer">as a tuple</a>:</p>
<pre><code>def foo(*args):
    for a in args:
        print(a)        

foo(1)
# 1

foo(1, 2, 3)
# 1
# 2
# 3
</code></pre>
<p>The <code>**kwargs</code> will give you all
keyword arguments as a dictionary:</p>
<pre><code>def bar(**kwargs):
    for a in kwargs:
        print(a, kwargs[a])  

bar(name='one', age=27)
# name one
# age 27
</code></pre>
<p>Both idioms can be mixed with normal arguments to allow a set of fixed and some variable arguments:</p>
<pre><code>def foo(kind, *args, bar=None, **kwargs):
    print(kind, args, bar, kwargs)

foo(123, 'a', 'b', apple='red')
# 123 ('a', 'b') None {'apple': 'red'}
</code></pre>
<p>It is also possible to use this the other way around:</p>
<pre><code>def foo(a, b, c):
    print(a, b, c)

obj = {'b':10, 'c':'lee'}

foo(100, **obj)
# 100 10 lee
</code></pre>
<p>Another usage of the <code>*l</code> idiom is to <strong>unpack argument lists</strong> when calling a function.</p>
<pre><code>def foo(bar, lee):
    print(bar, lee)

baz = [1, 2]

foo(*baz)
# 1 2
</code></pre>
<p>In Python 3 it is possible to use <code>*l</code> on the left side of an assignment (<a href="http://www.python.org/dev/peps/pep-3132/" rel="noreferrer">Extended Iterable Unpacking</a>), though it gives a list instead of a tuple in this context:</p>
<pre><code>first, *rest = [1, 2, 3, 4]
# first = 1
# rest = [2, 3, 4]
</code></pre>
<p>Also Python 3 adds a new semantic (refer <a href="https://www.python.org/dev/peps/pep-3102/" rel="noreferrer">PEP 3102</a>):</p>
<pre><code>def func(arg1, arg2, arg3, *, kwarg1, kwarg2):
    pass
</code></pre>
<p>Such function accepts only 3 positional arguments, and everything after <code>*</code> can only be passed as keyword arguments.</p>
<h3>Note:</h3>
<p>A Python <code>dict</code>, semantically used for keyword argument passing, is arbitrarily ordered. However, in Python 3.6+, keyword arguments are guaranteed to remember insertion order.
&quot;The order of elements in <code>**kwargs</code> now corresponds to the order in which keyword arguments were passed to the function.&quot; - <a href="https://docs.python.org/3/whatsnew/3.6.html" rel="noreferrer">What’s New In Python 3.6</a>.
In fact, all dicts in CPython 3.6 will remember insertion order as an implementation detail, and this becomes standard in Python 3.7.</p>
------------------------------------------------------------------ <br><h3> Lorin Hochstein, Id: 36926, Score: 823: </h3><p>It's also worth noting that you can use <code>*</code> and <code>**</code> when calling functions as well. This is a shortcut that allows you to pass multiple arguments to a function directly using either a list/tuple or a dictionary. For example, if you have the following function:</p>

<pre><code>def foo(x,y,z):
    print("x=" + str(x))
    print("y=" + str(y))
    print("z=" + str(z))
</code></pre>

<p>You can do things like:</p>

<pre><code>&gt;&gt;&gt; mylist = [1,2,3]
&gt;&gt;&gt; foo(*mylist)
x=1
y=2
z=3

&gt;&gt;&gt; mydict = {'x':1,'y':2,'z':3}
&gt;&gt;&gt; foo(**mydict)
x=1
y=2
z=3

&gt;&gt;&gt; mytuple = (1, 2, 3)
&gt;&gt;&gt; foo(*mytuple)
x=1
y=2
z=3
</code></pre>

<p>Note: The keys in <code>mydict</code> have to be named exactly like the parameters of function <code>foo</code>. Otherwise it will throw a <code>TypeError</code>:</p>

<pre><code>&gt;&gt;&gt; mydict = {'x':1,'y':2,'z':3,'badnews':9}
&gt;&gt;&gt; foo(**mydict)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: foo() got an unexpected keyword argument 'badnews'
</code></pre>
------------------------------------------------------------------ <br><h3> nickd, Id: 36911, Score: 219: </h3><p>The single * means that there can be any number of extra positional arguments. <code>foo()</code> can be invoked like <code>foo(1,2,3,4,5)</code>. In the body of foo() param2 is a sequence containing 2-5.</p>

<p>The double ** means there can be any number of extra named parameters. <code>bar()</code> can be invoked like <code>bar(1, a=2, b=3)</code>. In the body of bar() param2 is a dictionary containing {'a':2, 'b':3 }</p>

<p>With the following code:</p>

<pre><code>def foo(param1, *param2):
    print(param1)
    print(param2)

def bar(param1, **param2):
    print(param1)
    print(param2)

foo(1,2,3,4,5)
bar(1,a=2,b=3)
</code></pre>

<p>the output is</p>

<pre><code>1
(2, 3, 4, 5)
1
{'a': 2, 'b': 3}
</code></pre>
------------------------------------------------------------------ <br><h3> Russia Must Remove Putin, Id: 26365795, Score: 212: </h3><blockquote>
<h1>What does <code>**</code> (double star) and <code>*</code> (star) do for parameters?</h1>
</blockquote>
<p>They allow for <strong>functions to be defined to accept</strong> and for <strong>users to pass</strong> any number of arguments, positional (<code>*</code>) and keyword (<code>**</code>).</p>
<h2>Defining Functions</h2>
<p><code>*args</code> allows for any number of optional positional arguments (parameters), which will be assigned to a tuple named <code>args</code>.</p>
<p><code>**kwargs</code> allows for any number of optional keyword arguments (parameters), which will be in a dict named <code>kwargs</code>.</p>
<p>You can (and should) choose any appropriate name, but if the intention is for the arguments to be of non-specific semantics, <code>args</code> and <code>kwargs</code> are standard names.</p>
<h2>Expansion, Passing any number of arguments</h2>
<p>You can also use <code>*args</code> and <code>**kwargs</code> to pass in parameters from lists (or any iterable) and dicts (or any mapping), respectively.</p>
<p>The function recieving the parameters does not have to know that they are being expanded.</p>
<p>For example, Python 2's xrange does not explicitly expect <code>*args</code>, but since it takes 3 integers as arguments:</p>
<pre><code>&gt;&gt;&gt; x = xrange(3) # create our *args - an iterable of 3 integers
&gt;&gt;&gt; xrange(*x)    # expand here
xrange(0, 2, 2)
</code></pre>
<p>As another example, we can use dict expansion in <code>str.format</code>:</p>
<pre><code>&gt;&gt;&gt; foo = 'FOO'
&gt;&gt;&gt; bar = 'BAR'
&gt;&gt;&gt; 'this is foo, {foo} and bar, {bar}'.format(**locals())
'this is foo, FOO and bar, BAR'
</code></pre>
<h2>New in Python 3: Defining functions with keyword only arguments</h2>
<p>You can have <a href="https://www.python.org/dev/peps/pep-3102/" rel="noreferrer">keyword only arguments</a> after the <code>*args</code> - for example, here, <code>kwarg2</code> must be given as a keyword argument - not positionally:</p>
<pre><code>def foo(arg, kwarg=None, *args, kwarg2=None, **kwargs): 
    return arg, kwarg, args, kwarg2, kwargs
</code></pre>
<p>Usage:</p>
<pre><code>&gt;&gt;&gt; foo(1,2,3,4,5,kwarg2='kwarg2', bar='bar', baz='baz')
(1, 2, (3, 4, 5), 'kwarg2', {'bar': 'bar', 'baz': 'baz'})
</code></pre>
<p>Also, <code>*</code> can be used by itself  to indicate that keyword only arguments follow, without allowing for unlimited positional arguments.</p>
<pre><code>def foo(arg, kwarg=None, *, kwarg2=None, **kwargs): 
    return arg, kwarg, kwarg2, kwargs
</code></pre>
<p>Here, <code>kwarg2</code> again must be an explicitly named, keyword argument:</p>
<pre><code>&gt;&gt;&gt; foo(1,2,kwarg2='kwarg2', foo='foo', bar='bar')
(1, 2, 'kwarg2', {'foo': 'foo', 'bar': 'bar'})
</code></pre>
<p>And we can no longer accept unlimited positional arguments because we don't have <code>*args*</code>:</p>
<pre><code>&gt;&gt;&gt; foo(1,2,3,4,5, kwarg2='kwarg2', foo='foo', bar='bar')
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
TypeError: foo() takes from 1 to 2 positional arguments 
    but 5 positional arguments (and 1 keyword-only argument) were given
</code></pre>
<p>Again, more simply, here we require <code>kwarg</code> to be given by name, not positionally:</p>
<pre><code>def bar(*, kwarg=None): 
    return kwarg
</code></pre>
<p>In this example, we see that if we try to pass <code>kwarg</code> positionally, we get an error:</p>
<pre><code>&gt;&gt;&gt; bar('kwarg')
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
TypeError: bar() takes 0 positional arguments but 1 was given
</code></pre>
<p>We must explicitly pass the <code>kwarg</code> parameter as a keyword argument.</p>
<pre><code>&gt;&gt;&gt; bar(kwarg='kwarg')
'kwarg'
</code></pre>
<h2>Python 2 compatible demos</h2>
<p><code>*args</code> (typically said &quot;star-args&quot;) and <code>**kwargs</code> (stars can be implied by saying &quot;kwargs&quot;, but be explicit with &quot;double-star kwargs&quot;) are common idioms of Python for using the <code>*</code> and <code>**</code> notation. These specific variable names aren't required (e.g. you could use <code>*foos</code> and <code>**bars</code>), but a departure from convention is likely to enrage your fellow Python coders.</p>
<p>We typically use these when we don't know what our function is going to receive or how many arguments we may be passing, and sometimes even when naming every variable separately would get very messy and redundant (but this is a case where usually explicit is better than implicit).</p>
<p><strong>Example 1</strong></p>
<p>The following function describes how they can be used, and demonstrates behavior. Note the named <code>b</code> argument will be consumed by the second positional argument before :</p>
<pre><code>def foo(a, b=10, *args, **kwargs):
    '''
    this function takes required argument a, not required keyword argument b
    and any number of unknown positional arguments and keyword arguments after
    '''
    print('a is a required argument, and its value is {0}'.format(a))
    print('b not required, its default value is 10, actual value: {0}'.format(b))
    # we can inspect the unknown arguments we were passed:
    #  - args:
    print('args is of type {0} and length {1}'.format(type(args), len(args)))
    for arg in args:
        print('unknown arg: {0}'.format(arg))
    #  - kwargs:
    print('kwargs is of type {0} and length {1}'.format(type(kwargs),
                                                        len(kwargs)))
    for kw, arg in kwargs.items():
        print('unknown kwarg - kw: {0}, arg: {1}'.format(kw, arg))
    # But we don't have to know anything about them 
    # to pass them to other functions.
    print('Args or kwargs can be passed without knowing what they are.')
    # max can take two or more positional args: max(a, b, c...)
    print('e.g. max(a, b, *args) \n{0}'.format(
      max(a, b, *args))) 
    kweg = 'dict({0})'.format( # named args same as unknown kwargs
      ', '.join('{k}={v}'.format(k=k, v=v) 
                             for k, v in sorted(kwargs.items())))
    print('e.g. dict(**kwargs) (same as {kweg}) returns: \n{0}'.format(
      dict(**kwargs), kweg=kweg))
</code></pre>
<p>We can check the online help for the function's signature, with <code>help(foo)</code>, which tells us</p>
<pre><code>foo(a, b=10, *args, **kwargs)
</code></pre>
<p>Let's call this function with <code>foo(1, 2, 3, 4, e=5, f=6, g=7)</code></p>
<p>which prints:</p>
<pre><code>a is a required argument, and its value is 1
b not required, its default value is 10, actual value: 2
args is of type &lt;type 'tuple'&gt; and length 2
unknown arg: 3
unknown arg: 4
kwargs is of type &lt;type 'dict'&gt; and length 3
unknown kwarg - kw: e, arg: 5
unknown kwarg - kw: g, arg: 7
unknown kwarg - kw: f, arg: 6
Args or kwargs can be passed without knowing what they are.
e.g. max(a, b, *args) 
4
e.g. dict(**kwargs) (same as dict(e=5, f=6, g=7)) returns: 
{'e': 5, 'g': 7, 'f': 6}
</code></pre>
<p><strong>Example 2</strong></p>
<p>We can also call it using another function, into which we just provide <code>a</code>:</p>
<pre><code>def bar(a):
    b, c, d, e, f = 2, 3, 4, 5, 6
    # dumping every local variable into foo as a keyword argument 
    # by expanding the locals dict:
    foo(**locals()) 
</code></pre>
<p><code>bar(100)</code> prints:</p>
<pre><code>a is a required argument, and its value is 100
b not required, its default value is 10, actual value: 2
args is of type &lt;type 'tuple'&gt; and length 0
kwargs is of type &lt;type 'dict'&gt; and length 4
unknown kwarg - kw: c, arg: 3
unknown kwarg - kw: e, arg: 5
unknown kwarg - kw: d, arg: 4
unknown kwarg - kw: f, arg: 6
Args or kwargs can be passed without knowing what they are.
e.g. max(a, b, *args) 
100
e.g. dict(**kwargs) (same as dict(c=3, d=4, e=5, f=6)) returns: 
{'c': 3, 'e': 5, 'd': 4, 'f': 6}
</code></pre>
<p><strong>Example 3: practical usage in decorators</strong></p>
<p>OK, so maybe we're not seeing the utility yet. So imagine you have several functions with redundant code before and/or after the differentiating code. The following named functions are just pseudo-code for illustrative purposes.</p>
<pre><code>def foo(a, b, c, d=0, e=100):
    # imagine this is much more code than a simple function call
    preprocess() 
    differentiating_process_foo(a,b,c,d,e)
    # imagine this is much more code than a simple function call
    postprocess()

def bar(a, b, c=None, d=0, e=100, f=None):
    preprocess()
    differentiating_process_bar(a,b,c,d,e,f)
    postprocess()

def baz(a, b, c, d, e, f):
    ... and so on
</code></pre>
<p>We might be able to handle this differently, but we can certainly extract the redundancy with a decorator, and so our below example demonstrates how <code>*args</code> and <code>**kwargs</code> can be very useful:</p>
<pre><code>def decorator(function):
    '''function to wrap other functions with a pre- and postprocess'''
    @functools.wraps(function) # applies module, name, and docstring to wrapper
    def wrapper(*args, **kwargs):
        # again, imagine this is complicated, but we only write it once!
        preprocess()
        function(*args, **kwargs)
        postprocess()
    return wrapper
</code></pre>
<p>And now every wrapped function can be written much more succinctly, as we've factored out the redundancy:</p>
<pre><code>@decorator
def foo(a, b, c, d=0, e=100):
    differentiating_process_foo(a,b,c,d,e)

@decorator
def bar(a, b, c=None, d=0, e=100, f=None):
    differentiating_process_bar(a,b,c,d,e,f)

@decorator
def baz(a, b, c=None, d=0, e=100, f=None, g=None):
    differentiating_process_baz(a,b,c,d,e,f, g)

@decorator
def quux(a, b, c=None, d=0, e=100, f=None, g=None, h=None):
    differentiating_process_quux(a,b,c,d,e,f,g,h)
</code></pre>
<p>And by factoring out our code, which <code>*args</code> and <code>**kwargs</code> allows us to do, we reduce lines of code, improve readability and maintainability, and have sole canonical locations for the logic in our program. If we need to change any part of this structure, we have one place in which to make each change.</p>
------------------------------------------------------------------ <br><h3> mrtechmaker, Id: 34899056, Score: 66: </h3><p>Let us first understand what are positional arguments and keyword arguments.
Below is an example of function definition with <strong>Positional arguments.</strong></p>

<pre><code>def test(a,b,c):
     print(a)
     print(b)
     print(c)

test(1,2,3)
#output:
1
2
3
</code></pre>

<p>So this is a function definition with positional arguments.
You can call it with keyword/named arguments as well:</p>

<pre><code>def test(a,b,c):
     print(a)
     print(b)
     print(c)

test(a=1,b=2,c=3)
#output:
1
2
3
</code></pre>

<p>Now let us study an example of function definition with <strong>keyword arguments</strong>:</p>

<pre><code>def test(a=0,b=0,c=0):
     print(a)
     print(b)
     print(c)
     print('-------------------------')

test(a=1,b=2,c=3)
#output :
1
2
3
-------------------------
</code></pre>

<p>You can call this function with positional arguments as well:</p>

<pre><code>def test(a=0,b=0,c=0):
    print(a)
    print(b)
    print(c)
    print('-------------------------')

test(1,2,3)
# output :
1
2
3
---------------------------------
</code></pre>

<p>So we now know function definitions with positional as well as keyword arguments.</p>

<p>Now let us study the '*' operator and '**' operator.</p>

<p>Please note these operators can be used in 2 areas:</p>

<p>a) <strong>function call</strong></p>

<p>b) <strong>function definition</strong></p>

<p>The use of '*' operator and '**' operator in <strong>function call.</strong> </p>

<p>Let us get straight to an example and then discuss it.</p>

<pre><code>def sum(a,b):  #receive args from function calls as sum(1,2) or sum(a=1,b=2)
    print(a+b)

my_tuple = (1,2)
my_list = [1,2]
my_dict = {'a':1,'b':2}

# Let us unpack data structure of list or tuple or dict into arguments with help of '*' operator
sum(*my_tuple)   # becomes same as sum(1,2) after unpacking my_tuple with '*'
sum(*my_list)    # becomes same as sum(1,2) after unpacking my_list with  '*'
sum(**my_dict)   # becomes same as sum(a=1,b=2) after unpacking by '**' 

# output is 3 in all three calls to sum function.
</code></pre>

<p>So remember </p>

<p>when the '*' or '**' operator is used in a <strong>function call</strong> -</p>

<p>'*' operator unpacks data structure such as a list or tuple  into arguments needed by function definition.</p>

<p>'**' operator unpacks a dictionary into arguments needed by function definition.</p>

<p>Now let us study the '*' operator use in <strong>function definition</strong>.
Example:</p>

<pre><code>def sum(*args): #pack the received positional args into data structure of tuple. after applying '*' - def sum((1,2,3,4))
    sum = 0
    for a in args:
        sum+=a
    print(sum)

sum(1,2,3,4)  #positional args sent to function sum
#output:
10
</code></pre>

<p>In function <strong>definition</strong> the '*' operator packs the received arguments into a tuple.</p>

<p>Now let us see an example of '**' used in function definition:</p>

<pre><code>def sum(**args): #pack keyword args into datastructure of dict after applying '**' - def sum({a:1,b:2,c:3,d:4})
    sum=0
    for k,v in args.items():
        sum+=v
    print(sum)

sum(a=1,b=2,c=3,d=4) #positional args sent to function sum
</code></pre>

<p>In function <strong>definition</strong> The '**' operator packs the received arguments into a dictionary.</p>

<p>So remember:</p>

<p>In a <strong>function call</strong> the '*' <strong>unpacks</strong> data structure of tuple or list into positional or keyword arguments to be received by function definition.</p>

<p>In a <strong>function call</strong> the '**' <strong>unpacks</strong> data structure of dictionary into positional or keyword arguments to be received by function definition.</p>

<p>In a <strong>function definition</strong> the '*' <strong>packs</strong> positional arguments into a tuple.</p>

<p>In a <strong>function definition</strong> the '**' <strong>packs</strong> keyword arguments into a dictionary.</p>
<h4> vadasambar, Comment 136400751 Score: 1: </h4>This is very easy to understand. Thank you. For someone coming from Golang, list/tuple packing/unpacking sounds similar to variadic parameters in Golang: <a href="https://stackoverflow.com/a/23669857/6874596">stackoverflow.com/a/23669857/6874596</a><br><h4> mrtechmaker, Comment 136404108 Score: 1: </h4>sure boss  always at your service :)  I love medu vadaa too :) cheers<br>------------------------------------------------------------------ <br><h3> Brad Solomon, Id: 47580283, Score: 47: </h3><p>This table is handy for using <code>*</code> and <code>**</code> in function <em>construction</em> and function <em>call</em>:</p>

<pre><code>            In function construction         In function call
=======================================================================
          |  def f(*args):                 |  def f(a, b):
*args     |      for arg in args:          |      return a + b
          |          print(arg)            |  args = (1, 2)
          |  f(1, 2)                       |  f(*args)
----------|--------------------------------|---------------------------
          |  def f(a, b):                  |  def f(a, b):
**kwargs  |      return a + b              |      return a + b
          |  def g(**kwargs):              |  kwargs = dict(a=1, b=2)
          |      return f(**kwargs)        |  f(**kwargs)
          |  g(a=1, b=2)                   |
-----------------------------------------------------------------------
</code></pre>

<p>This really just serves to summarize Lorin Hochstein's <a href="https://stackoverflow.com/a/36926/7954504">answer</a> but I find it helpful.</p>

<p>Relatedly: uses for the star/splat operators have been <a href="https://docs.python.org/3/whatsnew/3.5.html#pep-448-additional-unpacking-generalizations" rel="noreferrer">expanded</a> in Python 3</p>
<h4> Moberg, Comment 124788773 Score: 1: </h4>Apparently &quot;splat&quot; is jargon for asterisk <code>*</code>. <a href="http://www.catb.org/jargon/html/S/splat.html" rel="nofollow noreferrer">catb.org/jargon/html/S/splat.html</a> &quot;Name used in many places (DEC, IBM, and others) for the asterisk (*) character (ASCII 0101010). This may derive from the ‘squashed-bug’ appearance of the asterisk on many early line printers.&quot;<br>------------------------------------------------------------------ <br><h3> Meysam Sadeghi, Id: 59630576, Score: 37: </h3><p><strong>TL;DR</strong></p>
<p>Below are 6 different use cases for <code>*</code> and <code>**</code> in python programming:</p>
<ol>
<li><strong>To accept any number of positional arguments using <code>*args</code>:</strong> <code>def foo(*args): pass</code>, here <code>foo</code> accepts any number of positional arguments, i. e., the following calls are valid <code>foo(1)</code>, <code>foo(1, 'bar')</code></li>
<li><strong>To accept any number of keyword arguments using <code>**kwargs</code>:</strong> <code>def foo(**kwargs): pass</code>, here 'foo' accepts any number of keyword arguments, i. e., the following calls are valid <code>foo(name='Tom')</code>, <code>foo(name='Tom', age=33)</code></li>
<li><strong>To accept any number of positional and keyword arguments using <code>*args, **kwargs</code>:</strong> <code>def foo(*args, **kwargs): pass</code>, here <code>foo</code> accepts any number of positional and keyword arguments, i. e., the following calls are valid <code>foo(1,name='Tom')</code>, <code>foo(1, 'bar', name='Tom', age=33)</code></li>
<li><strong>To enforce keyword only arguments using <code>*</code>:</strong> <code>def foo(pos1, pos2, *, kwarg1): pass</code>, here <code>*</code> means that foo only accept keyword arguments after pos2, hence <code>foo(1, 2, 3)</code> raises TypeError but <code>foo(1, 2, kwarg1=3)</code> is ok.</li>
<li><strong>To express no further interest in more positional arguments using <code>*_</code> (Note: this is a convention only):</strong> <code>def foo(bar, baz, *_): pass</code> means (by convention) <code>foo</code> only uses <code>bar</code> and <code>baz</code> arguments in its working and will ignore others.</li>
<li><strong>To express no further interest in more keyword arguments using <code>**_</code> (Note: this is a convention only):</strong> <code>def foo(bar, baz, **_): pass</code> means (by convention) <code>foo</code> only uses <code>bar</code> and <code>baz</code> arguments in its working and will ignore others.</li>
</ol>
<p><strong>BONUS:</strong> From python 3.8 onward, one can use <code>/</code> in function definition to enforce  positional only parameters. In the following example, parameters a and b are <strong>positional-only</strong>, while c or d can be positional or keyword, and e or f are required to be keywords:</p>
<pre><code>def f(a, b, /, c, d, *, e, f):
    pass
</code></pre>
<p><strong>BONUS 2</strong>: <a href="https://stackoverflow.com/a/21809162/3484477">THIS ANSWER</a> to the same question also brings a new perspective, where it shares what does <code>*</code> and <code>**</code> means in a <code>function call</code>, <code>functions signature</code>, <code>for loops</code>, etc.</p>
<h4> Moberg, Comment 124788659 Score: 1: </h4>One reason to use <code>&#47;</code> is that it allows you to change the names of the parameters in the function and not have to update at any place where the function is called (you can be sure that no caller of the function has used the names of the parameters to supply arguments since it isn&#39;t used).<br>------------------------------------------------------------------ <br><h3> ronak, Id: 12362812, Score: 31: </h3><p><code>*</code> and <code>**</code> have special usage in the function argument list. <code>*</code>
implies that the argument is a list and <code>**</code> implies that the argument
is a dictionary. This allows functions to take arbitrary number of
arguments</p>
------------------------------------------------------------------ <br><h3> Chris Upchurch, Id: 36902, Score: 22: </h3><p>From the Python documentation:</p>

<blockquote>
  <p>If there are more positional arguments than there are formal parameter slots, a TypeError exception is raised, unless a formal parameter using the syntax "*identifier" is present; in this case, that formal parameter receives a tuple containing the excess positional arguments (or an empty tuple if there were no excess positional arguments). </p>
  
  <p>If any keyword argument does not correspond to a formal parameter name, a TypeError exception is raised, unless a formal parameter using the syntax "**identifier" is present; in this case, that formal parameter receives a dictionary containing the excess keyword arguments (using the keywords as keys and the argument values as corresponding values), or a (new) empty dictionary if there were no excess keyword arguments. </p>
</blockquote>
------------------------------------------------------------------ <br><h3> Miladiouss, Id: 50461663, Score: 26: </h3><h2>For those of you who learn by examples!</h2>

<ol>
<li>The purpose of <code>*</code>  is to give you the ability to define a function that can take an arbitrary number of arguments provided as a list (e.g. <code>f(*myList)</code> ).</li>
<li>The purpose of <code>**</code> is to give you the ability to feed a function's arguments by providing a dictionary (e.g. <code>f(**{'x' : 1, 'y' : 2})</code> ).</li>
</ol>

<p>Let us show this by defining a function that takes two normal variables <code>x</code>, <code>y</code>, and can accept more arguments as <code>myArgs</code>, and can accept even more arguments as <code>myKW</code>. Later, we will show how to feed <code>y</code> using <code>myArgDict</code>.</p>

<pre><code>def f(x, y, *myArgs, **myKW):
    print("# x      = {}".format(x))
    print("# y      = {}".format(y))
    print("# myArgs = {}".format(myArgs))
    print("# myKW   = {}".format(myKW))
    print("# ----------------------------------------------------------------------")

# Define a list for demonstration purposes
myList    = ["Left", "Right", "Up", "Down"]
# Define a dictionary for demonstration purposes
myDict    = {"Wubba": "lubba", "Dub": "dub"}
# Define a dictionary to feed y
myArgDict = {'y': "Why?", 'y0': "Why not?", "q": "Here is a cue!"}

# The 1st elem of myList feeds y
f("myEx", *myList, **myDict)
# x      = myEx
# y      = Left
# myArgs = ('Right', 'Up', 'Down')
# myKW   = {'Wubba': 'lubba', 'Dub': 'dub'}
# ----------------------------------------------------------------------

# y is matched and fed first
# The rest of myArgDict becomes additional arguments feeding myKW
f("myEx", **myArgDict)
# x      = myEx
# y      = Why?
# myArgs = ()
# myKW   = {'y0': 'Why not?', 'q': 'Here is a cue!'}
# ----------------------------------------------------------------------

# The rest of myArgDict becomes additional arguments feeding myArgs
f("myEx", *myArgDict)
# x      = myEx
# y      = y
# myArgs = ('y0', 'q')
# myKW   = {}
# ----------------------------------------------------------------------

# Feed extra arguments manually and append even more from my list
f("myEx", 4, 42, 420, *myList, *myDict, **myDict)
# x      = myEx
# y      = 4
# myArgs = (42, 420, 'Left', 'Right', 'Up', 'Down', 'Wubba', 'Dub')
# myKW   = {'Wubba': 'lubba', 'Dub': 'dub'}
# ----------------------------------------------------------------------

# Without the stars, the entire provided list and dict become x, and y:
f(myList, myDict)
# x      = ['Left', 'Right', 'Up', 'Down']
# y      = {'Wubba': 'lubba', 'Dub': 'dub'}
# myArgs = ()
# myKW   = {}
# ----------------------------------------------------------------------
</code></pre>

<h3>Caveats</h3>

<ol>
<li><code>**</code> is exclusively reserved for dictionaries.</li>
<li>Non-optional argument assignment happens first.</li>
<li>You cannot use a non-optional argument twice.</li>
<li>If applicable, <code>**</code> must come after <code>*</code>, always.</li>
</ol>
------------------------------------------------------------------ <br><h3> ishandutta2007, Id: 51733267, Score: 19: </h3><p><code>*</code> means receive variable arguments as tuple</p>

<p><code>**</code> means receive variable arguments as dictionary</p>

<p>Used like the following:</p>

<p><strong>1) single *</strong></p>

<pre><code>def foo(*args):
    for arg in args:
        print(arg)

foo("two", 3)
</code></pre>

<p><strong>Output:</strong></p>

<pre><code>two
3
</code></pre>

<p><strong>2) Now <code>**</code></strong></p>

<pre><code>def bar(**kwargs):
    for key in kwargs:
        print(key, kwargs[key])

bar(dic1="two", dic2=3)
</code></pre>

<p><strong>Output:</strong></p>

<pre><code>dic1 two
dic2 3
</code></pre>
------------------------------------------------------------------ <br><h3> leewz, Id: 34166505, Score: 14: </h3><p>In Python 3.5, you can also use this syntax in <code>list</code>, <code>dict</code>, <code>tuple</code>, and <code>set</code> displays (also sometimes called literals). See <a href="http://legacy.python.org/dev/peps/pep-0448/" rel="noreferrer">PEP 488: Additional Unpacking Generalizations</a>.</p>

<pre><code>&gt;&gt;&gt; (0, *range(1, 4), 5, *range(6, 8))
(0, 1, 2, 3, 5, 6, 7)
&gt;&gt;&gt; [0, *range(1, 4), 5, *range(6, 8)]
[0, 1, 2, 3, 5, 6, 7]
&gt;&gt;&gt; {0, *range(1, 4), 5, *range(6, 8)}
{0, 1, 2, 3, 5, 6, 7}
&gt;&gt;&gt; d = {'one': 1, 'two': 2, 'three': 3}
&gt;&gt;&gt; e = {'six': 6, 'seven': 7}
&gt;&gt;&gt; {'zero': 0, **d, 'five': 5, **e}
{'five': 5, 'seven': 7, 'two': 2, 'one': 1, 'three': 3, 'six': 6, 'zero': 0}
</code></pre>

<p>It also allows multiple iterables to be unpacked in a single function call.</p>

<pre><code>&gt;&gt;&gt; range(*[1, 10], *[2])
range(1, 10, 2)
</code></pre>

<p>(Thanks to mgilson for the PEP link.)</p>
<h4> mgilson, Comment 56080415 Score: 1: </h4>I&#39;m not sure that this is a violation of &quot;there&#39;s only one way to do it&quot;.  There&#39;s no other way to initialize a list/tuple from multiple iterables -- You currently need to chain them into a single iterable which isn&#39;t always convenient.  You can read about the rational in <a href="http://legacy.python.org/dev/peps/pep-0448/" rel="nofollow noreferrer">PEP-0448</a>.  Also, this isn&#39;t a python3.x feature, it&#39;s a python3.5+ feature :-).<br>------------------------------------------------------------------ <br><h3> Lochu&#39;an Chang, Id: 40492308, Score: 11: </h3><p>I want to give an example which others haven't  mentioned</p>
<p>* can also unpack a <strong>generator</strong></p>
<p>An example from Python3 Document</p>
<pre><code>x = [1, 2, 3]
y = [4, 5, 6]

unzip_x, unzip_y = zip(*zip(x, y))
</code></pre>
<p>unzip_x will be (1, 2, 3), unzip_y will be (4, 5, 6)</p>
<p>The zip() receives multiple iretable args, and return a generator.</p>
<pre><code>zip(*zip(x,y)) -&gt; zip((1, 4), (2, 5), (3, 6))
</code></pre>
<h4> EduardoSaverin, Comment 114888001 Score: 1: </h4>unzip_x will be <code>(1, 2, 3)</code> not <code>[1, 2, 3]</code>. Same goes for unzip_y<br>------------------------------------------------------------------ <br><h3> RBF06, Id: 55475113, Score: 11: </h3><h2>TL;DR</h2>
<p>It packs arguments passed to the function into <code>list</code> and <code>dict</code> respectively inside the function body. When you define a function signature like this:</p>
<pre class="lang-py prettyprint-override"><code>def func(*args, **kwds):
    # do stuff
</code></pre>
<p>it can be called with any number of arguments and keyword arguments. The non-keyword arguments get packed into a list called <code>args</code> inside the function body and the keyword arguments get packed into a dict called <code>kwds</code> inside the function body.</p>
<pre class="lang-py prettyprint-override"><code>func(&quot;this&quot;, &quot;is a list of&quot;, &quot;non-keyowrd&quot;, &quot;arguments&quot;, keyword=&quot;ligma&quot;, options=[1,2,3])
</code></pre>
<p>now inside the function body, when the function is called, there are two local variables, <code>args</code> which is a list having value <code>[&quot;this&quot;, &quot;is a list of&quot;, &quot;non-keyword&quot;, &quot;arguments&quot;]</code> and <code>kwds</code> which is a <code>dict</code> having value <code>{&quot;keyword&quot; : &quot;ligma&quot;, &quot;options&quot; : [1,2,3]}</code></p>
<hr />
<p>This also works in reverse, i.e. from the caller side. for example if you have a function defined as:</p>
<pre class="lang-py prettyprint-override"><code>def f(a, b, c, d=1, e=10):
    # do stuff
</code></pre>
<p>you can call it with by unpacking iterables or mappings you have in the calling scope:</p>
<pre class="lang-py prettyprint-override"><code>iterable = [1, 20, 500]
mapping = {&quot;d&quot; : 100, &quot;e&quot;: 3}
f(*iterable, **mapping)
# That call is equivalent to
f(1, 20, 500, d=100, e=3)
</code></pre>
------------------------------------------------------------------ <br><h3> Raj, Id: 56962836, Score: 10: </h3><p>Building on nickd's <a href="https://stackoverflow.com/a/36911/8588359">answer</a>...</p>

<pre><code>def foo(param1, *param2):
    print(param1)
    print(param2)


def bar(param1, **param2):
    print(param1)
    print(param2)


def three_params(param1, *param2, **param3):
    print(param1)
    print(param2)
    print(param3)


foo(1, 2, 3, 4, 5)
print("\n")
bar(1, a=2, b=3)
print("\n")
three_params(1, 2, 3, 4, s=5)
</code></pre>

<p>Output:</p>

<pre><code>1
(2, 3, 4, 5)

1
{'a': 2, 'b': 3}

1
(2, 3, 4)
{'s': 5}
</code></pre>

<p>Basically, any number of <strong>positional arguments</strong> can use *args and any <strong>named arguments</strong> (or kwargs aka keyword arguments) can use **kwargs.</p>
------------------------------------------------------------------ <br><h3> quiet_penguin, Id: 32031804, Score: 8: </h3><p>In addition to function calls, *args and **kwargs are useful in class hierarchies and also avoid having to write <code>__init__</code> method in Python. Similar usage can seen in frameworks like Django code.</p>

<p>For example,</p>

<pre><code>def __init__(self, *args, **kwargs):
    for attribute_name, value in zip(self._expected_attributes, args):
        setattr(self, attribute_name, value)
        if kwargs.has_key(attribute_name):
            kwargs.pop(attribute_name)

    for attribute_name in kwargs.viewkeys():
        setattr(self, attribute_name, kwargs[attribute_name])
</code></pre>

<p>A subclass can then be</p>

<pre><code>class RetailItem(Item):
    _expected_attributes = Item._expected_attributes + ['name', 'price', 'category', 'country_of_origin']

class FoodItem(RetailItem):
    _expected_attributes = RetailItem._expected_attributes +  ['expiry_date']
</code></pre>

<p>The subclass then be instantiated as </p>

<pre><code>food_item = FoodItem(name = 'Jam', 
                     price = 12.0, 
                     category = 'Foods', 
                     country_of_origin = 'US', 
                     expiry_date = datetime.datetime.now())
</code></pre>

<p>Also, a subclass with a new attribute which makes sense only to that subclass instance can call the Base class <code>__init__</code> to offload the attributes setting.
This is done through *args and **kwargs. kwargs mainly used so that code is readable using named arguments. For example,</p>

<pre><code>class ElectronicAccessories(RetailItem):
    _expected_attributes = RetailItem._expected_attributes +  ['specifications']
    # Depend on args and kwargs to populate the data as needed.
    def __init__(self, specifications = None, *args, **kwargs):
        self.specifications = specifications  # Rest of attributes will make sense to parent class.
        super(ElectronicAccessories, self).__init__(*args, **kwargs)
</code></pre>

<p>which can be instatiated as</p>

<pre><code>usb_key = ElectronicAccessories(name = 'Sandisk', 
                                price = '$6.00', 
                                category = 'Electronics',
                                country_of_origin = 'CN',
                                specifications = '4GB USB 2.0/USB 3.0')
</code></pre>

<p>The complete code is <a href="http://harisankar-krishnaswamy.blogspot.sg/2015/08/using-args-and-kwargs-python-code-post.html" rel="noreferrer">here</a></p>
------------------------------------------------------------------ <br><h3> etoricky, Id: 62442187, Score: 5: </h3><p>Given a function that has 3 items as argument</p>

<pre><code>sum = lambda x, y, z: x + y + z
sum(1,2,3) # sum 3 items

sum([1,2,3]) # error, needs 3 items, not 1 list

x = [1,2,3][0]
y = [1,2,3][1]
z = [1,2,3][2]
sum(x,y,z) # ok

sum(*[1,2,3]) # ok, 1 list becomes 3 items
</code></pre>

<p>Imagine this toy with a bag of a triangle, a circle and a rectangle item. That bag does not directly fit. You need to unpack the bag to take those 3 items and now they fit. The Python * operator does this unpack process.</p>

<p><a href="https://i.stack.imgur.com/9gf2j.jpg" rel="noreferrer"><img src="https://i.stack.imgur.com/9gf2j.jpg" alt="enter image description here"></a></p>
------------------------------------------------------------------ <br><h3> Hrvoje, Id: 50116852, Score: 4: </h3><p><code>*args</code> and <code>**kwargs</code>: allow you to pass a variable number of arguments to a function. </p>

<p><code>*args</code>: is used to send a non-keyworded variable length argument list to the function:</p>

<pre><code>def args(normal_arg, *argv):
    print("normal argument:", normal_arg)

    for arg in argv:
        print("Argument in list of arguments from *argv:", arg)

args('animals', 'fish', 'duck', 'bird')
</code></pre>

<p>Will produce:</p>

<pre class="lang-none prettyprint-override"><code>normal argument: animals
Argument in list of arguments from *argv: fish
Argument in list of arguments from *argv: duck
Argument in list of arguments from *argv: bird
</code></pre>

<p><code>**kwargs*</code></p>

<p><code>**kwargs</code> allows you to pass keyworded variable length of arguments to a function. You should use <code>**kwargs</code> if you want to handle named arguments in a function. </p>

<pre><code>def who(**kwargs):
    if kwargs is not None:
        for key, value in kwargs.items():
            print("Your %s is %s." % (key, value))

who(name="Nikola", last_name="Tesla", birthday="7.10.1856", birthplace="Croatia")  
</code></pre>

<p>Will produce:</p>

<pre class="lang-none prettyprint-override"><code>Your name is Nikola.
Your last_name is Tesla.
Your birthday is 7.10.1856.
Your birthplace is Croatia.
</code></pre>
------------------------------------------------------------------ <br><h3> amir jj, Id: 40262722, Score: 3: </h3><p>A good example of using both in a function is:</p>

<pre><code>&gt;&gt;&gt; def foo(*arg,**kwargs):
...     print arg
...     print kwargs
&gt;&gt;&gt;
&gt;&gt;&gt; a = (1, 2, 3)
&gt;&gt;&gt; b = {'aa': 11, 'bb': 22}
&gt;&gt;&gt;
&gt;&gt;&gt;
&gt;&gt;&gt; foo(*a,**b)
(1, 2, 3)
{'aa': 11, 'bb': 22}
&gt;&gt;&gt;
&gt;&gt;&gt;
&gt;&gt;&gt; foo(a,**b) 
((1, 2, 3),)
{'aa': 11, 'bb': 22}
&gt;&gt;&gt;
&gt;&gt;&gt;
&gt;&gt;&gt; foo(a,b) 
((1, 2, 3), {'aa': 11, 'bb': 22})
{}
&gt;&gt;&gt;
&gt;&gt;&gt;
&gt;&gt;&gt; foo(a,*b)
((1, 2, 3), 'aa', 'bb')
{}
</code></pre>
------------------------------------------------------------------ <br><h3> TNg, Id: 40823181, Score: 3: </h3><p>This example would help you remember <code>*args</code>, <code>**kwargs</code> and even <code>super</code> and inheritance in Python at once.</p>

<pre><code>class base(object):
    def __init__(self, base_param):
        self.base_param = base_param


class child1(base): # inherited from base class
    def __init__(self, child_param, *args) # *args for non-keyword args
        self.child_param = child_param
        super(child1, self).__init__(*args) # call __init__ of the base class and initialize it with a NON-KEYWORD arg

class child2(base):
    def __init__(self, child_param, **kwargs):
        self.child_param = child_param
        super(child2, self).__init__(**kwargs) # call __init__ of the base class and initialize it with a KEYWORD arg

c1 = child1(1,0)
c2 = child2(1,base_param=0)
print c1.base_param # 0
print c1.child_param # 1
print c2.base_param # 0
print c2.child_param # 1
</code></pre>
------------------------------------------------------------------ <br><h3> dreftymac, Id: 59217020, Score: 2: </h3><h2>Context</h2>

<ul>
<li>python 3.x</li>
<li>unpacking with <code>**</code></li>
<li>use with string formatting</li>
</ul>

<h2>Use with string formatting</h2>

<p>In addition to the answers in this thread, here is another detail that was not mentioned elsewhere. This expands on the <a href="https://stackoverflow.com/a/47580283/42223">answer by Brad Solomon</a></p>

<p>Unpacking with <code>**</code> is also useful when using python <code>str.format</code>.  </p>

<p>This is somewhat similar to what you can do with python <code>f-strings</code> <a href="https://stackoverflow.com/questions/tagged/f-string">f-string</a> but with the added overhead of declaring a dict to hold the variables (f-string does not require a dict).</p>

<h2>Quick Example</h2>

<pre class="lang-py prettyprint-override"><code>  ## init vars
  ddvars = dict()
  ddcalc = dict()
  pass
  ddvars['fname']     = 'Huomer'
  ddvars['lname']     = 'Huimpson'
  ddvars['motto']     = 'I love donuts!'
  ddvars['age']       = 33
  pass
  ddcalc['ydiff']     = 5
  ddcalc['ycalc']     = ddvars['age'] + ddcalc['ydiff']
  pass
  vdemo = []

  ## ********************
  ## single unpack supported in py 2.7
  vdemo.append('''
  Hello {fname} {lname}!

  Today you are {age} years old!

  We love your motto "{motto}" and we agree with you!
  '''.format(**ddvars)) 
  pass

  ## ********************
  ## multiple unpack supported in py 3.x
  vdemo.append('''
  Hello {fname} {lname}!

  In {ydiff} years you will be {ycalc} years old!
  '''.format(**ddvars,**ddcalc)) 
  pass

  ## ********************
  print(vdemo[-1])

</code></pre>
------------------------------------------------------------------ <br><h3> user15049586, Id: 66705594, Score: 2: </h3><p>*args ( or *any ) means every parameters</p>
<pre class="lang-py prettyprint-override"><code>def any_param(*param):
    pass

any_param(1)
any_param(1,1)
any_param(1,1,1)
any_param(1,...)
</code></pre>
<p><em>NOTICE</em> : you can don't pass parameters to *args</p>
<pre class="lang-py prettyprint-override"><code>def any_param(*param):
    pass

any_param() # will work correct
</code></pre>
<p>The *args is in type tuple</p>
<pre><code>def any_param(*param):
    return type(param)

any_param(1) #tuple
any_param() # tuple
</code></pre>
<p>for access to elements don't use of *</p>
<pre><code>def any(*param):
    param[0] # correct

def any(*param):
    *param[0] # incorrect
</code></pre>
<p>The **kwd</p>
<p>**kwd or **any
This is a dict type</p>
<pre><code>def func(**any):
    return type(any) # dict

def func(**any):
    return any

func(width=&quot;10&quot;,height=&quot;20&quot;) # {width=&quot;10&quot;,height=&quot;20&quot;)


</code></pre>
------------------------------------------------------------------ <br><h3> Super Kai - Kazuya Ito, Id: 74406075, Score: 1: </h3><ul>
<li><p><strong><code>*args</code></strong> is the special parameter which can take 0 or more (positional) arguments as a tuple.</p>
</li>
<li><p><strong><code>**kwargs</code></strong> is the special parameter which can take 0 or more (keyword) arguments as a dictionary.</p>
</li>
</ul>
<p>*In Python, there are 2 kinds of arguments <a href="https://docs.python.org/3/glossary.html#term-argument" rel="nofollow noreferrer"><strong>positional argument and keyword argument</strong></a>:</p>
<h2><code>*args</code>:</h2>
<p>For example, <code>*args</code> can take 0 or more arguments as a tuple as shown below:</p>
<pre class="lang-py prettyprint-override"><code>           ↓
def test(*args):
    print(args)

test() # Here
test(1, 2, 3, 4) # Here
test((1, 2, 3, 4)) # Here
test(*(1, 2, 3, 4)) # Here
</code></pre>
<p>Output:</p>
<pre class="lang-none prettyprint-override"><code>()
(1, 2, 3, 4)
((1, 2, 3, 4),)
(1, 2, 3, 4)
</code></pre>
<p>And, when printing <code>*args</code>, 4 numbers are printed without parentheses and commas:</p>
<pre class="lang-py prettyprint-override"><code>def test(*args):
    print(*args) # Here
 
test(1, 2, 3, 4)
</code></pre>
<p>Output:</p>
<pre class="lang-none prettyprint-override"><code>1 2 3 4
</code></pre>
<p>And, <code>args</code> has <strong>tuple</strong> type:</p>
<pre class="lang-py prettyprint-override"><code>def test(*args):
    print(type(args)) # Here
 
test(1, 2, 3, 4)
</code></pre>
<p>Output:</p>
<pre class="lang-none prettyprint-override"><code>&lt;class 'tuple'&gt;
</code></pre>
<p>But, <code>*args</code> has no type:</p>
<pre class="lang-py prettyprint-override"><code>def test(*args):
    print(type(*args)) # Here
 
test(1, 2, 3, 4)
</code></pre>
<p>Output(Error):</p>
<blockquote>
<p>TypeError: type() takes 1 or 3 arguments</p>
</blockquote>
<p>And, normal parameters can be put before <code>*args</code> as shown below:</p>
<pre class="lang-py prettyprint-override"><code>          ↓     ↓
def test(num1, num2, *args):
    print(num1, num2, args)
    
test(1, 2, 3, 4)
</code></pre>
<p>Output:</p>
<pre class="lang-none prettyprint-override"><code>1 2 (3, 4)
</code></pre>
<p>But, <code>**kwargs</code> cannot be put before <code>*args</code> as shown below:</p>
<pre class="lang-py prettyprint-override"><code>             ↓     
def test(**kwargs, *args):
    print(kwargs, args)
    
test(num1=1, num2=2, 3, 4)
</code></pre>
<p>Output(Error):</p>
<blockquote>
<p>SyntaxError: invalid syntax</p>
</blockquote>
<p>And, normal parameters cannot be put after <code>*args</code> as shown below:</p>
<pre class="lang-py prettyprint-override"><code>                 ↓     ↓
def test(*args, num1, num2):
    print(args, num1, num2)
    
test(1, 2, 3, 4)
</code></pre>
<p>Output(Error):</p>
<blockquote>
<p>TypeError: test() missing 2 required keyword-only arguments: 'num1' and 'num2'</p>
</blockquote>
<p>But, if normal parameters have default values, they can be put after <code>*args</code> as shown below:</p>
<pre class="lang-py prettyprint-override"><code>                      ↓         ↓
def test(*args, num1=100, num2=None):
    print(args, num1, num2)
    
test(1, 2, num1=3, num2=4)
</code></pre>
<p>Output:</p>
<pre class="lang-none prettyprint-override"><code>(1, 2) 3 4
</code></pre>
<p>And also, <code>**kwargs</code> can be put after <code>*args</code> as shown below:</p>
<pre class="lang-py prettyprint-override"><code>                    ↓
def test(*args, **kwargs):
    print(args, kwargs)
    
test(1, 2, num1=3, num2=4)
</code></pre>
<p>Output:</p>
<pre class="lang-none prettyprint-override"><code>(1, 2) {'num1': 3, 'num2': 4}
</code></pre>
<h2><code>**kwargs</code>:</h2>
<p>For example, <code>**kwargs</code> can take 0 or more arguments as a dictionary as shown below:</p>
<pre class="lang-py prettyprint-override"><code>             ↓
def test(**kwargs):
    print(kwargs)

test() # Here
test(name=&quot;John&quot;, age=27) # Here
test(**{&quot;name&quot;: &quot;John&quot;, &quot;age&quot;: 27}) # Here
</code></pre>
<p>Output:</p>
<pre class="lang-none prettyprint-override"><code>{}
{'name': 'John', 'age': 27}
{'name': 'John', 'age': 27}
</code></pre>
<p>And, when printing <code>*kwargs</code>, 2 keys are printed:</p>
<pre class="lang-py prettyprint-override"><code>def test(**kwargs):
    print(*kwargs) # Here
 
test(name=&quot;John&quot;, age=27)
</code></pre>
<p>Output:</p>
<pre class="lang-none prettyprint-override"><code>name age
</code></pre>
<p>And, <code>kwargs</code> has <strong>dict</strong> type:</p>
<pre class="lang-py prettyprint-override"><code>def test(**kwargs):
    print(type(kwargs)) # Here
 
test(name=&quot;John&quot;, age=27)
</code></pre>
<p>Output:</p>
<pre class="lang-none prettyprint-override"><code>&lt;class 'dict'&gt;
</code></pre>
<p>But, <code>*kwargs</code> and <code>**kwargs</code> have no type:</p>
<pre class="lang-py prettyprint-override"><code>def test(**kwargs):
    print(type(*kwargs)) # Here
 
test(name=&quot;John&quot;, age=27)
</code></pre>
<pre class="lang-py prettyprint-override"><code>def test(**kwargs):
    print(type(**kwargs)) # Here
 
test(name=&quot;John&quot;, age=27)
</code></pre>
<p>Output(Error):</p>
<blockquote>
<p>TypeError: type() takes 1 or 3 arguments</p>
</blockquote>
<p>And, normal parameters can be put before <code>**kwargs</code> as shown below:</p>
<pre class="lang-py prettyprint-override"><code>          ↓     ↓
def test(num1, num2, **kwargs):
    print(num1, num2, kwargs)

test(1, 2, name=&quot;John&quot;, age=27)
</code></pre>
<p>Output:</p>
<pre class="lang-none prettyprint-override"><code>1 2 {'name': 'John', 'age': 27}
</code></pre>
<p>And also, <code>*args</code> can be put before <code>**kwargs</code> as shown below:</p>
<pre class="lang-py prettyprint-override"><code>           ↓
def test(*args, **kwargs):
    print(args, kwargs)

test(1, 2, name=&quot;John&quot;, age=27)
</code></pre>
<p>Output:</p>
<pre class="lang-none prettyprint-override"><code>(1, 2) {'name': 'John', 'age': 27}
</code></pre>
<p>And, normal parameters and <code>*args</code> cannot be put after <code>**kwargs</code> as shown below:</p>
<pre class="lang-py prettyprint-override"><code>                    ↓     ↓
def test(**kwargs, num1, num2):
    print(kwargs, num1, num2)

test(name=&quot;John&quot;, age=27, 1, 2)
</code></pre>
<pre class="lang-py prettyprint-override"><code>                     ↓
def test(**kwargs, *args):
    print(kwargs, args)

test(name=&quot;John&quot;, age=27, 1, 2)
</code></pre>
<p>Output(Error):</p>
<blockquote>
<p>SyntaxError: invalid syntax</p>
</blockquote>
<h2>For both <code>*args</code> and <code>**kwargs</code>:</h2>
<p>Actually, you can use other names for <code>*args</code> and <code>**kwargs</code> as shown below. <code>*args</code> and <code>**kwargs</code> are used conventionally:</p>
<pre class="lang-py prettyprint-override"><code>            ↓        ↓
def test(*banana, **orange):
    print(banana, orange)
    
test(1, 2, num1=3, num2=4)
</code></pre>
<p>Output:</p>
<pre class="lang-none prettyprint-override"><code>(1, 2) {'num1': 3, 'num2': 4}
</code></pre>
------------------------------------------------------------------ <br><h3> Vinod Srivastav, Id: 75920670, Score: 1: </h3><pre class="lang-py prettyprint-override"><code>def foo(x, y, *args):
    pass

def bar(x, y, **kwargs):
    pass
</code></pre>
<h1><code>*args</code></h1>
<p>As far as I know, <code>*args</code> is an array of arguments separated by comma <code>,</code> so if you wanted to to <code>foo</code> above it will look like</p>
<pre class="lang-py prettyprint-override"><code>foo(&quot;x&quot;,&quot;y&quot;,1,2,3,4,5)
</code></pre>
<p>so if you run</p>
<pre class="lang-py prettyprint-override"><code>for a in args:
        print(a)  
</code></pre>
<p>it will print arguments in order of placement as 1,2,3...</p>
<blockquote>
<p>Although this is very easy to implement and use the order of arguments matters a lot here. So if the first argument is supposed to be a string and second and integer, if the caller messed with the order the function fails.</p>
</blockquote>
<hr />
<h1><code>**kwargs</code></h1>
<p>These are <code>keyword</code> arguments which are set of named arguments which are passed as <code>key/value pair</code> or <code>dictionary</code> separated by <code>,</code> if multiple. So for <code>bar</code> you can send</p>
<pre class="lang-py prettyprint-override"><code>bar(&quot;x&quot;, &quot;y&quot;, name=&quot;vinod&quot;,address=&quot;bangalore&quot;,country=&quot;india&quot;)
</code></pre>
<p>and can read it in the function individually as</p>
<pre><code>Name = kwargs['name']
Address = kwargs['address'] 

</code></pre>
<blockquote>
<p>Reading <code>kwargs</code> doesn't required to enumerate over a loop and order of arguments don't matter.</p>
</blockquote>
------------------------------------------------------------------ <br><h3> cowlinator, Id: 77047783, Score: 1: </h3><p>The asterisk '*' in a function <strong>definition</strong> <em>combines</em> multiple positional arguments into a single <em>tuple</em> argument.</p>
<pre><code>&gt;&gt;&gt; def A(*tpl):
...     print(tpl)
...
&gt;&gt;&gt; A(6, 7, 8, 9, 0)
(6, 7, 8, 9, 0)
</code></pre>
<p>The asterisk '*' in a function <strong>call</strong> <em>splits</em> a <em>sequence</em> into individual positional arguments.</p>
<pre><code>&gt;&gt;&gt; def B(a, b, c, d, e):
...     print(f&quot;{a} {b} {c} {d} {e}&quot;)
...
&gt;&gt;&gt; lst = [1,2,3,4,5]
&gt;&gt;&gt;
&gt;&gt;&gt; B(*lst)
1 2 3 4 5 
</code></pre>
<p>The <strong>double</strong> asterisk '**' in a function <strong>definition</strong> <em>combines</em> multiple keyword arguments into a single <em>dictionary</em> argument.</p>
<pre><code>&gt;&gt;&gt; def C(**dic):
...     print(dic)
...
&gt;&gt;&gt; C(a=9, b=8, c=7, d=6, e=5)
{'a': 9, 'b': 8, 'c': 7, 'd': 6, 'e': 5}
</code></pre>
<p>The <strong>double</strong> asterisk '**' in a function <strong>call</strong> <em>splits</em> a <em>dictionary</em>-like object into individual keyword arguments.</p>
<pre><code>&gt;&gt;&gt; def D(v,w,x,y,z):
...     print(f&quot;{v} {w} {x} {y} {z}&quot;)
...
&gt;&gt;&gt; dct = {'z':1, 'y':2, 'x':3, 'w':4, 'v':5}
&gt;&gt;&gt;
&gt;&gt;&gt; D(**dct)
5 4 3 2 1
</code></pre>
------------------------------------------------------------------ <br><h3> Premraj, Id: 52134172, Score: 0: </h3><ul>
<li><code>def foo(param1, *param2):</code> is a method can accept arbitrary number of values for <code>*param2</code>,</li>
<li><code>def bar(param1, **param2):</code> is a method can accept arbitrary number of values with keys for <code>*param2</code></li>
<li><code>param1</code> is a simple parameter.</li>
</ul>

<p>For example, the syntax for implementing <strong>varargs</strong> in Java as follows:</p>

<pre><code>accessModifier methodName(datatype… arg) {
    // method body
}
</code></pre>
------------------------------------------------------------------ <br><h3> Isaac Vin&#237;cius, Id: 73178373, Score: 0: </h3><h3>&quot;Infinite&quot; Args with *args and **kwargs</h3>
<p><code>*args</code> and <code>**kwargs</code> are just some way to input unlimited characters to functions, like:</p>
<pre class="lang-py prettyprint-override"><code>
def print_all(*args, **kwargs):
    print(args) # print any number of arguments like: &quot;print_all(&quot;foo&quot;, &quot;bar&quot;)&quot;
    print(kwargs.get(&quot;to_print&quot;)) # print the value of the keyworded argument &quot;to_print&quot;


# example:
print_all(&quot;Hello&quot;, &quot;World&quot;, to_print=&quot;!&quot;)
# will print:
&quot;&quot;&quot;
('Hello', 'World')
!
&quot;&quot;&quot;
</code></pre>
<h4> Isaac Vin&#237;cius, Comment 129241254 Score: 0: </h4><code>*args</code> can be anything, like <code>*something</code>, the same for <code>**kwargs</code>, example: <code>*keyworded_args</code><br>------------------------------------------------------------------ <br><h3> happymancer, Id: 75871130, Score: 0: </h3><p>The most simple explanation is just that * is *args, which passes a tuple, and ** is **kwargs, which passes a dictionary. Those are just general names that are default.</p>
<h4> bfontaine, Comment 133875190 Score: 0: </h4>There are already 25 answers to this question; why add a new one that duplicates the others?<br><h4> happymancer, Comment 133893366 Score: 0: </h4>All of the previous answers are more complicated, just simplified it....<br>