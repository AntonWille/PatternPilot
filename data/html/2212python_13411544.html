 <h2> Title: Delete a column from a Pandas DataFrame </h2> <h4> John, question_id: 13411544 </h4>Score: 2212, Tags: {python,pandas,dataframe} <br><p>To delete a column in a DataFrame, I can successfully use:</p>
<pre class="lang-py prettyprint-override"><code>del df['column_name']
</code></pre>
<p>But why can't I use the following?</p>
<pre class="lang-py prettyprint-override"><code>del df.column_name
</code></pre>
<p>Since it is possible to access the Series via <code>df.column_name</code>, I expected this to work.</p>
------------------------------------------------------------------ <br><h3> LondonRob, Id: 18145399, Score: 3552: </h3><p>The best way to do this in Pandas is to use <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.drop.html" rel="noreferrer"><code>drop</code></a>:</p>
<pre><code>df = df.drop('column_name', axis=1)
</code></pre>
<p>where <code>1</code> is the <em>axis</em> number (<code>0</code> for rows and <code>1</code> for columns.)</p>
<p>Or, the <code>drop()</code> method accepts <code>index</code>/<code>columns</code> keywords as an alternative to specifying the axis. So we can now just do:</p>
<pre><code>df = df.drop(columns=['column_nameA', 'column_nameB'])
</code></pre>
<ul>
<li><em>This was <a href="https://pandas.pydata.org/pandas-docs/stable/whatsnew/v0.21.0.html#method-drop-now-also-accepts-index-columns-keywords" rel="noreferrer">introduced in v0.21.0</a> (October 27, 2017)</em></li>
</ul>
<p>To delete the column without having to reassign <code>df</code> you can do:</p>
<pre><code>df.drop('column_name', axis=1, inplace=True)
</code></pre>
<p>Finally, to drop by column <em>number</em> instead of by column <em>label</em>, try this to delete, e.g. the 1st, 2nd and 4th columns:</p>
<pre><code>df = df.drop(df.columns[[0, 1, 3]], axis=1)  # df.columns is zero-based pd.Index
</code></pre>
<p>Also working with &quot;text&quot; syntax for the columns:</p>
<pre><code>df.drop(['column_nameA', 'column_nameB'], axis=1, inplace=True)
</code></pre>
<h4> LondonRob, Comment 36831932 Score: 164: </h4>True @Paul, but due to the title of the question, most people arriving here will do so via trying to work out how to delete a column.<br><h4> beardc, Comment 30650171 Score: 111: </h4>Is this recommended over <code>del</code> for some reason?<br><h4> hobs, Comment 60861568 Score: 40: </h4>@beardc another advantage of <code>drop</code> over <code>del</code> is that <code>drop</code> allows you to drop multiple columns at once, perform the operation inplace or not, and also delete records along any axis (especially useful for a 3-D matrix or <code>Panel</code>)<br><h4> Paul, Comment 36822157 Score: 36: </h4>Though this method of deletion has its merits, this answer does not really answer the question being asked.<br><h4> modulitos, Comment 65184788 Score: 24: </h4>Another advantage of <code>drop</code> over <code>del</code> is that <a href="http://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.drop.html" rel="nofollow noreferrer">drop</a> is part of the pandas API and contains documentation.<br><h4> Rohan, Comment 124005739 Score: 2: </h4>Note <code>df = df.drop(&#39;column_name&#39;, 1)</code> throws a <code>&quot;FutureWarning: In a future version of pandas all arguments of DataFrame.drop except for the argument &#39;labels&#39; will be keyword-only&quot;</code> in 3.7.2.   Specify <code>df = df.drop(&#39;column_name&#39;, axis=1)</code> to avoid warning,<br><h4> jimh, Comment 131851762 Score: 0: </h4>is <code>del</code> faster than dropping and saving as a new dataframe?<br><h4> mrdm, Comment 124299435 Score: 0: </h4>I have to use Python instead of R and I want to cry for its syntax.<br><h4> PatrickT, Comment 129260783 Score: 0: </h4>If you&#39;re dropping rows, the index is not reset. Something like this drops the first two rows and resets the index, in place: <code>df.drop([0,1], inplace=True)</code> and <code>df.reset_index(drop=True, inplace=True)</code><br>------------------------------------------------------------------ <br><h3> Wes McKinney, Id: 13485766, Score: 1309: </h3><p>As you've guessed, the right syntax is </p>

<pre><code>del df['column_name']
</code></pre>

<p>It's difficult to make <code>del df.column_name</code> work simply as the result of syntactic limitations in Python. <code>del df[name]</code> gets translated to <code>df.__delitem__(name)</code> under the covers by Python.</p>
<h4> dwanderson, Comment 66997381 Score: 35: </h4>I realize this is a super old &quot;answer&quot;, but my curiosity is piqued - <i>why</i> is that a syntactic limitation of Python? <code>class A(object): def __init__(self): self.var = 1</code> sets up a class, then <code>a = A(); del a.var</code> works just fine...<br><h4> Yonatan, Comment 69758926 Score: 25: </h4>@dwanderson the difference is that when a column is to be removed, the DataFrame needs to have its own handling for &quot;how to do it&quot;. In the case of <code>del df[name]</code>, it gets translated to <code>df.__delitem__(name)</code> which is a method that DataFrame can implement and modify to its needs. In the case of <code>del df.name</code>, the member variable gets removed without a chance for any custom-code running. Consider your own example - can you get <code>del a.var</code> to result in a print of &quot;deleting variable&quot;? If you can, please tell me how. I can&#39;t :)<br><h4> Eugene Pakhomov, Comment 70685558 Score: 12: </h4>@Yonatan You can use either <a href="https://docs.python.org/3/reference/datamodel.html#object.__delattr__" rel="nofollow noreferrer">docs.python.org/3/reference/datamodel.html#object.__delattr_&zwnj;&#8203;_</a> or descriptors for that: <a href="https://docs.python.org/3/howto/descriptor.html" rel="nofollow noreferrer">docs.python.org/3/howto/descriptor.html</a><br><h4> wizzwizz4, Comment 79957247 Score: 7: </h4>This answer isn&#39;t really correct - the <code>pandas</code> developers <i>didn&#39;t</i>, but that doesn&#39;t mean it is hard to do.<br><h4> C S, Comment 76291720 Score: 6: </h4>@Yonatan Eugene&#39;s comment applies to Python 2 also; descriptors have been in Python 2 since 2.2 and it is trivial to satisfy your requirement ;)<br><h4> Zeynab Rostami, Comment 112943871 Score: 2: </h4>using this answer may cause tokenizing problems when you save the csv and want to read it again. using &quot;df.drop()&quot; as @LondonRob described is the correct way.<br><h4> Yonatan, Comment 70778012 Score: 0: </h4>@EugenePakhomov good point. I was answering in python 2, indeed python 3 gives more flexibility in such matters. Thanks for clarifying.<br><h4> alper, Comment 133545927 Score: 0: </h4>How can I indicate the first column which is for <code>Time</code>?<br><h4> pedjjj, Comment 107807299 Score: 0: </h4>Still, it is correct given that panda works / used to work on Py2.7, too - where you can&#39;t<br>------------------------------------------------------------------ <br><h3> Krishna Sankar, Id: 22596982, Score: 314: </h3><p>Use:</p>

<pre><code>columns = ['Col1', 'Col2', ...]
df.drop(columns, inplace=True, axis=1)
</code></pre>

<p>This will delete one or more columns in-place. Note that <code>inplace=True</code> was added in pandas v0.13 and won't work on older versions. You'd have to assign the result back in that case:</p>

<pre><code>df = df.drop(columns, axis=1)
</code></pre>
------------------------------------------------------------------ <br><h3> jezrael, Id: 31431997, Score: 156: </h3><h2>Drop by index</h2>

<p>Delete first, second and fourth columns:</p>

<pre><code>df.drop(df.columns[[0,1,3]], axis=1, inplace=True)
</code></pre>

<p>Delete first column:</p>

<pre><code>df.drop(df.columns[[0]], axis=1, inplace=True)
</code></pre>

<p>There is an optional parameter <code>inplace</code> so that the original
data can be modified without creating a copy.</p>

<h2>Popped</h2>

<p><a href="http://pandas.pydata.org/pandas-docs/stable/dsintro.html#column-selection-addition-deletion" rel="noreferrer">Column selection, addition, deletion</a></p>

<p>Delete column <code>column-name</code>:</p>

<pre><code>df.pop('column-name')
</code></pre>

<h2>Examples:</h2>

<pre><code>df = DataFrame.from_items([('A', [1, 2, 3]), ('B', [4, 5, 6]), ('C', [7,8, 9])], orient='index', columns=['one', 'two', 'three'])
</code></pre>

<p><code>print df</code>:</p>

<pre><code>   one  two  three
A    1    2      3
B    4    5      6
C    7    8      9
</code></pre>

<p><code>df.drop(df.columns[[0]], axis=1, inplace=True)</code>
<code>print df</code>:</p>

<pre><code>   two  three
A    2      3
B    5      6
C    8      9
</code></pre>

<p><code>three = df.pop('three')</code>
<code>print df</code>:</p>

<pre><code>   two
A    2
B    5
C    8
</code></pre>
------------------------------------------------------------------ <br><h3> firelynx, Id: 37000877, Score: 100: </h3><p>The actual question posed, missed by most answers here is:</p>
<h3>Why can't I use <code>del df.column_name</code>?</h3>
<p>At first we need to understand the problem, which requires us to dive into <a href="https://rszalski.github.io/magicmethods/" rel="noreferrer"><em>Python magic methods</em></a>.</p>
<p>As <a href="https://stackoverflow.com/questions/13411544/delete-a-column-from-a-pandas-dataframe/13485766#13485766">Wes points out</a> in his answer, <code>del df['column']</code> maps to the Python <em>magic method</em> <code>df.__delitem__('column')</code> which is <a href="https://github.com/pydata/pandas/blob/c6110e25b3eceb2f25022c2aa9ccea03c0b8b359/pandas/core/generic.py#L1580" rel="noreferrer">implemented in Pandas to drop the column</a>.</p>
<p>However, as pointed out in the link above about <a href="https://rszalski.github.io/magicmethods/" rel="noreferrer"><em>Python magic methods</em></a>:</p>
<blockquote>
<p>In fact, <code>__del__</code> should almost never be used because of the precarious circumstances under which it is called; use it with caution!</p>
</blockquote>
<p>You could argue that <code>del df['column_name']</code> should not be used or encouraged, and thereby <code>del df.column_name</code> should not even be considered.</p>
<p>However, in theory, <code>del df.column_name</code> could be implemented to work in Pandas using <a href="https://rszalski.github.io/magicmethods/#access" rel="noreferrer">the <em>magic method <code>__delattr__</code></em></a>. This does however introduce certain problems, problems which the <code>del df['column_name']</code> implementation already has, but to a lesser degree.</p>
<h2>Example Problem</h2>
<p>What if I define a column in a dataframe called &quot;dtypes&quot; or &quot;columns&quot;?</p>
<p>Then assume I want to delete these columns.</p>
<p><code>del df.dtypes</code> would make the <code>__delattr__</code> method confused as if it should delete the &quot;dtypes&quot; attribute or the &quot;dtypes&quot; column.</p>
<h2>Architectural questions behind this problem</h2>
<ol>
<li>Is a dataframe a collection of <em>columns</em>?</li>
<li>Is a dataframe a collection of <em>rows</em>?</li>
<li>Is a column an <em>attribute</em> of a dataframe?</li>
</ol>
<h3>Pandas answers:</h3>
<ol>
<li>Yes, in all ways</li>
<li>No, but if you want it to be, you can use the <code>.ix</code>, <code>.loc</code> or <code>.iloc</code> methods.</li>
<li>Maybe, do you want to <em>read</em> data? Then <strong>yes</strong>, <em>unless</em> the name of the attribute is already taken by another attribute belonging to the dataframe. Do you want to <em>modify</em> data? Then <strong>no</strong>.</li>
</ol>
<h1>TLDR;</h1>
<p>You cannot do <code>del df.column_name</code>, because Pandas has a quite wildly grown architecture that needs to be reconsidered in order for this kind of <em>cognitive dissonance</em> not to occur to its users.</p>
<h3>Pro tip:</h3>
<p>Don't use df.column_name. It may be pretty, but it causes <em>cognitive dissonance</em>.</p>
<h3>Zen of Python quotes that fits in here:</h3>
<p>There are multiple ways of deleting a column.</p>
<blockquote>
<p>There should be one-- and preferably only one --obvious way to do it.</p>
</blockquote>
<p>Columns are sometimes attributes but sometimes not.</p>
<blockquote>
<p>Special cases aren't special enough to break the rules.</p>
</blockquote>
<p>Does <code>del df.dtypes</code> delete the dtypes attribute or the dtypes column?</p>
<blockquote>
<p>In the face of ambiguity, refuse the temptation to guess.</p>
</blockquote>
<h4> pauljohn32, Comment 120997103 Score: 2: </h4>Actually addresses the WHY part of original question. I&#39;ve implemented subclasses from pandas dataframe. Doing so will teach you vital part of this answer. Differentiating attributes and column names is a big problem. df.a leaves ambiguity whether a is an attribute or column name. However, as pandas is written, df[&quot;a&quot;] can only be a column.<br><h4> Joooeey, Comment 132734915 Score: 1: </h4>This is the only answer to the original question that covers all essential aspects!<br>------------------------------------------------------------------ <br><h3> eiTan LaVi, Id: 34576537, Score: 72: </h3><p>A nice addition is the ability to <strong>drop columns only if they exist</strong>. This way you can cover more use cases, and it will only drop the existing columns from the labels passed to it:</p>

<p>Simply add <strong>errors='ignore'</strong>, for example.:</p>

<pre><code>df.drop(['col_name_1', 'col_name_2', ..., 'col_name_N'], inplace=True, axis=1, errors='ignore')
</code></pre>

<ul>
<li>This is new from pandas 0.16.1 onward. Documentation is <a href="http://pandas.pydata.org/pandas-docs/version/0.17.0/generated/pandas.DataFrame.drop.html" rel="noreferrer">here</a>.</li>
</ul>
------------------------------------------------------------------ <br><h3> sushmit, Id: 36958937, Score: 49: </h3><p>From version 0.16.1, you can do</p>
<pre><code>df.drop(['column_name'], axis = 1, inplace = True, errors = 'ignore')
</code></pre>
<h4> muon, Comment 67636601 Score: 4: </h4>And this also supports dropping multiple columns, some of which need not exist (i.e. without raising error <code>errors= &#39;ignore&#39;</code>) <code>df.drop([&#39;column_1&#39;,&#39;column_2&#39;], axis=1 , inplace=True,errors= &#39;ignore&#39;)</code>, if such an application desired!<br>------------------------------------------------------------------ <br><h3> Andy Hayden, Id: 13415772, Score: 38: </h3><p>It's good practice to always use the <code>[]</code> notation. One reason is that attribute notation (<code>df.column_name</code>) does not work for numbered indices:</p>

<pre><code>In [1]: df = DataFrame([[1, 2, 3], [4, 5, 6]])

In [2]: df[1]
Out[2]:
0    2
1    5
Name: 1

In [3]: df.1
  File "&lt;ipython-input-3-e4803c0d1066&gt;", line 1
    df.1
       ^
SyntaxError: invalid syntax
</code></pre>
------------------------------------------------------------------ <br><h3> Ted Petrou, Id: 46913256, Score: 32: </h3><h1>Pandas 0.21+ answer</h1>

<p>Pandas version 0.21 has changed the <a href="https://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.drop.html" rel="noreferrer"><code>drop</code></a> method slightly to include both the <code>index</code> and <code>columns</code> parameters to match the signature of the <code>rename</code> and <code>reindex</code> methods. </p>

<pre><code>df.drop(columns=['column_a', 'column_c'])
</code></pre>

<p>Personally, I prefer using the <code>axis</code> parameter to denote columns or index because it is the predominant keyword parameter used in nearly all pandas methods. But, now you have some added choices in version 0.21.</p>
------------------------------------------------------------------ <br><h3> Alexander, Id: 35385805, Score: 28: </h3><p>In Pandas 0.16.1+, you can drop columns only if they exist per <a href="https://stackoverflow.com/questions/13411544/delete-a-column-from-a-pandas-dataframe/34576537#34576537">the solution posted by eiTan LaVi</a>.  Prior to that version, you can achieve the same result via a conditional list comprehension:</p>
<pre><code>df.drop([col for col in ['col_name_1','col_name_2',...,'col_name_N'] if col in df],
        axis=1, inplace=True)
</code></pre>
------------------------------------------------------------------ <br><h3> Praveen Bushipaka, Id: 64376652, Score: 26: </h3><p>Use:</p>
<pre><code>df.drop('columnname', axis =1, inplace = True)
</code></pre>
<p>Or else you can go with</p>
<pre><code>del df['colname']
</code></pre>
<p>To delete multiple columns based on column numbers</p>
<pre><code>df.drop(df.iloc[:,1:3], axis = 1, inplace = True)
</code></pre>
<p>To delete multiple columns based on columns names</p>
<pre><code>df.drop(['col1','col2',..'coln'], axis = 1, inplace = True)
</code></pre>
------------------------------------------------------------------ <br><h3> piRSquared, Id: 46314092, Score: 21: </h3><h1>TL;DR</h1>

<p>A lot of effort to find a marginally more efficient solution.  Difficult to justify the added complexity while sacrificing the simplicity of <code>df.drop(dlst, 1, errors='ignore')</code></p>

<pre><code>df.reindex_axis(np.setdiff1d(df.columns.values, dlst), 1)
</code></pre>

<p><strong>Preamble</strong><br>
Deleting a column is semantically the same as selecting the other columns.  I'll show a few additional methods to consider.  </p>

<p>I'll also focus on the general solution of deleting multiple columns at once and allowing for the attempt to delete columns not present.  </p>

<p>Using these solutions are general and will work for the simple case as well.</p>

<hr>

<p><strong>Setup</strong><br>
Consider the <code>pd.DataFrame</code> <code>df</code> and list to delete <code>dlst</code></p>

<pre><code>df = pd.DataFrame(dict(zip('ABCDEFGHIJ', range(1, 11))), range(3))
dlst = list('HIJKLM')
</code></pre>

<hr>

<pre><code>df

   A  B  C  D  E  F  G  H  I   J
0  1  2  3  4  5  6  7  8  9  10
1  1  2  3  4  5  6  7  8  9  10
2  1  2  3  4  5  6  7  8  9  10
</code></pre>

<hr>

<pre><code>dlst

['H', 'I', 'J', 'K', 'L', 'M']
</code></pre>

<p>The result should look like:</p>

<pre><code>df.drop(dlst, 1, errors='ignore')

   A  B  C  D  E  F  G
0  1  2  3  4  5  6  7
1  1  2  3  4  5  6  7
2  1  2  3  4  5  6  7
</code></pre>

<hr>

<p>Since I'm equating deleting a column to selecting the other columns, I'll break it into two types:</p>

<ol>
<li>Label selection</li>
<li>Boolean selection</li>
</ol>

<hr>

<h1>Label Selection</h1>

<p>We start by manufacturing the list/array of labels that represent the columns we want to keep and without the columns we want to delete.</p>

<ol>
<li><p><code>df.columns.difference(dlst)</code></p>

<pre><code>Index(['A', 'B', 'C', 'D', 'E', 'F', 'G'], dtype='object')
</code></pre></li>
<li><p><code>np.setdiff1d(df.columns.values, dlst)</code></p>

<pre><code>array(['A', 'B', 'C', 'D', 'E', 'F', 'G'], dtype=object)
</code></pre></li>
<li><p><code>df.columns.drop(dlst, errors='ignore')</code></p>

<pre><code>Index(['A', 'B', 'C', 'D', 'E', 'F', 'G'], dtype='object')
</code></pre></li>
<li><p><code>list(set(df.columns.values.tolist()).difference(dlst))</code></p>

<pre><code># does not preserve order
['E', 'D', 'B', 'F', 'G', 'A', 'C']
</code></pre></li>
<li><p><code>[x for x in df.columns.values.tolist() if x not in dlst]</code></p>

<pre><code>['A', 'B', 'C', 'D', 'E', 'F', 'G']
</code></pre>

<hr></li>
</ol>

<p><strong>Columns from Labels</strong><br>
For the sake of comparing the selection process, assume:</p>

<pre><code> cols = [x for x in df.columns.values.tolist() if x not in dlst]
</code></pre>

<p>Then we can evaluate  </p>

<ol>
<li><code>df.loc[:, cols]</code></li>
<li><code>df[cols]</code></li>
<li><code>df.reindex(columns=cols)</code></li>
<li><code>df.reindex_axis(cols, 1)</code></li>
</ol>

<p>Which all evaluate to:</p>

<pre><code>   A  B  C  D  E  F  G
0  1  2  3  4  5  6  7
1  1  2  3  4  5  6  7
2  1  2  3  4  5  6  7
</code></pre>

<hr>

<h1>Boolean Slice</h1>

<p>We can construct an array/list of booleans for slicing</p>

<ol>
<li><code>~df.columns.isin(dlst)</code></li>
<li><code>~np.in1d(df.columns.values, dlst)</code></li>
<li><code>[x not in dlst for x in df.columns.values.tolist()]</code></li>
<li><code>(df.columns.values[:, None] != dlst).all(1)</code></li>
</ol>

<p><strong>Columns from Boolean</strong><br>
For the sake of comparison  </p>

<pre><code>bools = [x not in dlst for x in df.columns.values.tolist()]
</code></pre>

<ol>
<li><code>df.loc[: bools]</code></li>
</ol>

<p>Which all evaluate to:</p>

<pre><code>   A  B  C  D  E  F  G
0  1  2  3  4  5  6  7
1  1  2  3  4  5  6  7
2  1  2  3  4  5  6  7
</code></pre>

<hr>

<p><strong>Robust Timing</strong>  </p>

<p><em>Functions</em>  </p>

<pre><code>setdiff1d = lambda df, dlst: np.setdiff1d(df.columns.values, dlst)
difference = lambda df, dlst: df.columns.difference(dlst)
columndrop = lambda df, dlst: df.columns.drop(dlst, errors='ignore')
setdifflst = lambda df, dlst: list(set(df.columns.values.tolist()).difference(dlst))
comprehension = lambda df, dlst: [x for x in df.columns.values.tolist() if x not in dlst]

loc = lambda df, cols: df.loc[:, cols]
slc = lambda df, cols: df[cols]
ridx = lambda df, cols: df.reindex(columns=cols)
ridxa = lambda df, cols: df.reindex_axis(cols, 1)

isin = lambda df, dlst: ~df.columns.isin(dlst)
in1d = lambda df, dlst: ~np.in1d(df.columns.values, dlst)
comp = lambda df, dlst: [x not in dlst for x in df.columns.values.tolist()]
brod = lambda df, dlst: (df.columns.values[:, None] != dlst).all(1)
</code></pre>

<p><strong>Testing</strong>  </p>

<pre><code>res1 = pd.DataFrame(
    index=pd.MultiIndex.from_product([
        'loc slc ridx ridxa'.split(),
        'setdiff1d difference columndrop setdifflst comprehension'.split(),
    ], names=['Select', 'Label']),
    columns=[10, 30, 100, 300, 1000],
    dtype=float
)

res2 = pd.DataFrame(
    index=pd.MultiIndex.from_product([
        'loc'.split(),
        'isin in1d comp brod'.split(),
    ], names=['Select', 'Label']),
    columns=[10, 30, 100, 300, 1000],
    dtype=float
)

res = res1.append(res2).sort_index()

dres = pd.Series(index=res.columns, name='drop')

for j in res.columns:
    dlst = list(range(j))
    cols = list(range(j // 2, j + j // 2))
    d = pd.DataFrame(1, range(10), cols)
    dres.at[j] = timeit('d.drop(dlst, 1, errors="ignore")', 'from __main__ import d, dlst', number=100)
    for s, l in res.index:
        stmt = '{}(d, {}(d, dlst))'.format(s, l)
        setp = 'from __main__ import d, dlst, {}, {}'.format(s, l)
        res.at[(s, l), j] = timeit(stmt, setp, number=100)

rs = res / dres
</code></pre>

<hr>

<pre><code>rs

                          10        30        100       300        1000
Select Label                                                           
loc    brod           0.747373  0.861979  0.891144  1.284235   3.872157
       columndrop     1.193983  1.292843  1.396841  1.484429   1.335733
       comp           0.802036  0.732326  1.149397  3.473283  25.565922
       comprehension  1.463503  1.568395  1.866441  4.421639  26.552276
       difference     1.413010  1.460863  1.587594  1.568571   1.569735
       in1d           0.818502  0.844374  0.994093  1.042360   1.076255
       isin           1.008874  0.879706  1.021712  1.001119   0.964327
       setdiff1d      1.352828  1.274061  1.483380  1.459986   1.466575
       setdifflst     1.233332  1.444521  1.714199  1.797241   1.876425
ridx   columndrop     0.903013  0.832814  0.949234  0.976366   0.982888
       comprehension  0.777445  0.827151  1.108028  3.473164  25.528879
       difference     1.086859  1.081396  1.293132  1.173044   1.237613
       setdiff1d      0.946009  0.873169  0.900185  0.908194   1.036124
       setdifflst     0.732964  0.823218  0.819748  0.990315   1.050910
ridxa  columndrop     0.835254  0.774701  0.907105  0.908006   0.932754
       comprehension  0.697749  0.762556  1.215225  3.510226  25.041832
       difference     1.055099  1.010208  1.122005  1.119575   1.383065
       setdiff1d      0.760716  0.725386  0.849949  0.879425   0.946460
       setdifflst     0.710008  0.668108  0.778060  0.871766   0.939537
slc    columndrop     1.268191  1.521264  2.646687  1.919423   1.981091
       comprehension  0.856893  0.870365  1.290730  3.564219  26.208937
       difference     1.470095  1.747211  2.886581  2.254690   2.050536
       setdiff1d      1.098427  1.133476  1.466029  2.045965   3.123452
       setdifflst     0.833700  0.846652  1.013061  1.110352   1.287831
</code></pre>

<hr>

<pre><code>fig, axes = plt.subplots(2, 2, figsize=(8, 6), sharey=True)
for i, (n, g) in enumerate([(n, g.xs(n)) for n, g in rs.groupby('Select')]):
    ax = axes[i // 2, i % 2]
    g.plot.bar(ax=ax, title=n)
    ax.legend_.remove()
fig.tight_layout()
</code></pre>

<p>This is relative to the time it takes to run <code>df.drop(dlst, 1, errors='ignore')</code>.  It seems like after all that effort, we only improve performance modestly.</p>

<p><a href="https://i.stack.imgur.com/208z6.png" rel="noreferrer"><img src="https://i.stack.imgur.com/208z6.png" alt="enter image description here"></a></p>

<p>If fact the best solutions use <code>reindex</code> or <code>reindex_axis</code> on the hack <code>list(set(df.columns.values.tolist()).difference(dlst))</code>.  A close second and still very marginally better than <code>drop</code> is <code>np.setdiff1d</code>.</p>

<pre><code>rs.idxmin().pipe(
    lambda x: pd.DataFrame(
        dict(idx=x.values, val=rs.lookup(x.values, x.index)),
        x.index
    )
)

                      idx       val
10     (ridx, setdifflst)  0.653431
30    (ridxa, setdifflst)  0.746143
100   (ridxa, setdifflst)  0.816207
300    (ridx, setdifflst)  0.780157
1000  (ridxa, setdifflst)  0.861622
</code></pre>
------------------------------------------------------------------ <br><h3> Littin Rajan, Id: 61305524, Score: 16: </h3><p>We can <strong>remove</strong> or <strong>delete</strong> a specified column or specified columns by the <strong>drop()</strong> method.</p>
<p>Suppose <strong>df</strong> is a dataframe.</p>
<p>Column to be removed = column0</p>
<blockquote>
<p>Code:</p>
</blockquote>
<pre><code>df = df.drop(column0, axis=1)
</code></pre>
<p>To remove multiple columns col1, col2, . . . , coln, we have to insert all the columns that needed to be removed in a list. Then remove them by the drop() method.</p>
<blockquote>
<p>Code:</p>
</blockquote>
<pre><code>df = df.drop([col1, col2, . . . , coln], axis=1)
</code></pre>
------------------------------------------------------------------ <br><h3> ccpizza, Id: 60695984, Score: 6: </h3><p>If your original dataframe <strong><code>df</code></strong> is not too big, you have no memory constraints, and you only need to keep a few columns, or, if you don't know beforehand the names of all the extra columns that you do not need, then you might as well create a new dataframe with only the columns you need:</p>
<pre><code>new_df = df[['spam', 'sausage']]
</code></pre>
------------------------------------------------------------------ <br><h3> S Habeeb Ullah, Id: 64840364, Score: 5: </h3><p>Deleting a column using the <code>iloc</code> function of <code>dataframe</code> and <code>slicing</code>, when we have a typical column name with unwanted values:</p>
<pre><code>df = df.iloc[:,1:] # Removing an unnamed index column
</code></pre>
<p>Here <code>0</code> is the default row and <code>1</code> is the first column, hence <code>:,1:</code> is our parameter for deleting the first column.</p>
------------------------------------------------------------------ <br><h3> Doctor, Id: 36749161, Score: 3: </h3><p>The dot syntax works in JavaScript, but not in Python.</p>

<ul>
<li>Python: <code>del df['column_name']</code></li>
<li>JavaScript: <code>del df['column_name']</code> <strong>or</strong> <code>del df.column_name</code></li>
</ul>
------------------------------------------------------------------ <br><h3> Daksh Gupta, Id: 52242125, Score: 3: </h3><p><strong>Another way of deleting a column in a Pandas DataFrame</strong></p>
<p>If you're not looking for <em>in-place</em> deletion then you can create a new DataFrame by specifying the columns using <code>DataFrame(...)</code> function as:</p>
<pre><code>my_dict = { 'name' : ['a','b','c','d'], 'age' : [10,20,25,22], 'designation' : ['CEO', 'VP', 'MD', 'CEO']}

df = pd.DataFrame(my_dict)
</code></pre>
<p>Create a new DataFrame as</p>
<pre><code>newdf = pd.DataFrame(df, columns=['name', 'age'])
</code></pre>
<p>You get a result as good as what you get with del / drop.</p>
<h4> cs95, Comment 99174415 Score: 1: </h4>This is technically correct but it seems silly to have to list every column to keep instead of just the one (or few) columns you want to delete.<br>------------------------------------------------------------------ <br><h3> Falco Alexander, Id: 73076296, Score: 2: </h3><p>Taking advantage by using Autocomplete or &quot;IntelliSense&quot; over string literals:</p>
<pre><code>del df[df.column1.name]

# or

df.drop(df.column1.name, axis=1, inplace=True)
</code></pre>
<p>It works fine with current Pandas versions.</p>
------------------------------------------------------------------ <br><h3> Jordy, Id: 75637132, Score: 1: </h3><p>If you want find the <strong>simple ways</strong> to delete <code>column_name</code> from <code>df</code> data frame, here we go:</p>
<pre class="lang-py prettyprint-override"><code>df = df[df.columns.drop('column_name')]
</code></pre>
------------------------------------------------------------------ <br><h3> cottontail, Id: 76428891, Score: 1: </h3><p>Deleting a column using <code>del</code> is not only problematic (as explained by <a href="https://stackoverflow.com/a/37000877/19123103">@firelynx</a>) but also very slow. For example, it's ~37 times slower than <code>drop()</code>.</p>
<pre class="lang-py prettyprint-override"><code>from timeit import timeit
setup = &quot;import pandas as pd; df=pd.DataFrame([range(10000)])&quot;

for _ in range(3):
    t1 = timeit(&quot;df = df.drop(columns=df.columns[0])&quot;, setup, number=10000)
    t2 = timeit(&quot;del df[df.columns[0]]&quot;, setup, number=10000)
    print(f&quot;{t2/t1:.2f}&quot;)
    
# 37.40
# 37.45
# 37.34
</code></pre>
<p>On the topic of performance, if a single column needs to be dropped, boolean indexing (create a boolean Series of <em>wanted</em> columns and <code>loc</code>-index them) is actually the fastest method for the job. However, if multiple columns need to be dropped, <code>drop()</code> is the fastest method.</p>
<p>As a refresher, the methods in question are as follows (all of the methods given on this page where tested but these two were the fastest).</p>
<pre class="lang-py prettyprint-override"><code>import pandas as pd
df = pd.DataFrame([range(10)]*5).add_prefix('col')

# drop a single column (the performance comparison is shown in LHS subplot)
df1 = df.loc[:, df.columns != 'col2']                # boolean indexing
df2 = df.drop(columns='col2')                        # drop

# drop multiple columns (the performance comparison is shown in RHS subplot)
df1 = df.loc[:, ~df.columns.isin(['col2', 'col4'])]  # boolean indexing
df2 = df.drop(columns=['col2', 'col4'])              # drop
</code></pre>
<p>The following performance comparison graph was created using the perfplot library (which performs <code>timeit</code> tests under the hood). This supports the claim made above. The main takeaway is when dropping single column, boolean indexing is faster; however, when dropping multiple columns for very wide dataframes, <code>drop()</code> is faster.</p>
<p><a href="https://i.stack.imgur.com/6V76x.png" rel="nofollow noreferrer"><img src="https://i.stack.imgur.com/6V76x.png" alt="performance" /></a></p>
<p>Code used to produce the performance plots:</p>
<pre class="lang-py prettyprint-override"><code>import pandas as pd
import perfplot
import random
import matplotlib.pyplot as plt

plt.figure(figsize=(12,5), facecolor='white')
plt.subplot(1, 2, 1)
perfplot.plot(
    setup=lambda n: pd.DataFrame([range(n+1)]),
    kernels=[lambda df: df.drop(columns=df.columns[0]), lambda df: df.loc[:, df.columns != df.columns[0]]],
    labels= ['drop', 'boolean indexing'],
    n_range=[2**k for k in range(21)],
    xlabel='Number of columns in a dataframe',
    title='Removing a single column from a dataframe',
    equality_check=pd.DataFrame.equals)

plt.subplot(1, 2, 2)
perfplot.plot(
    setup=lambda n: (pd.DataFrame([range(n+1)]), random.sample(range(n+1), k=(n+1)//2)),
    kernels=[lambda df,cols: df.drop(columns=cols), lambda df,cols: df.loc[:, ~df.columns.isin(cols)]],
    labels= ['drop', 'boolean indexing'],
    n_range=[2**k for k in range(21)],
    xlabel='Number of columns in a dataframe',
    title='Removing multiple columns from a dataframe',
    equality_check=pd.DataFrame.equals)

plt.tight_layout();
</code></pre>
------------------------------------------------------------------ <br><h3> Mykola Zotko, Id: 69461516, Score: 0: </h3><p>To remove columns before and after specific columns you can use the method <a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.truncate.html" rel="nofollow noreferrer">truncate</a>. For example:</p>
<pre><code>   A   B    C     D      E
0  1  10  100  1000  10000
1  2  20  200  2000  20000

df.truncate(before='B', after='D', axis=1)
</code></pre>
<p>Output:</p>
<pre><code>    B    C     D
0  10  100  1000
1  20  200  2000
</code></pre>
------------------------------------------------------------------ <br><h3> creanion, Id: 69910566, Score: 0: </h3><p>Viewed from a general Python standpoint,  <code>del obj.column_name</code> makes sense if the attribute <code>column_name</code> can be deleted. It needs to be a regular attribute - or a property with a defined deleter.</p>
<p>The reasons why this doesn't translate to Pandas, and does <em>not</em> make sense for Pandas Dataframes are:</p>
<ul>
<li>Consider <code>df.column_name</code> to be a “virtual attribute”, it is not a thing in its own right, it is not the “seat” of that column, it's just a way to access the column.  Much like a property with no deleter.</li>
</ul>
