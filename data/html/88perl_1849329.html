 <h2> Title: Is there a Perl shortcut to count the number of matches in a string? </h2> <h3> Geo, question_id: 1849329 </h3>Score: 88, Tags: {arrays,regex,perl,perl4} <br><p>Suppose I have:</p>

<pre><code>my $string = "one.two.three.four";
</code></pre>

<p>How should I play with context to get the number of times the pattern found a match (3)?  Can this be done using a one-liner?</p>

<p>I tried this:</p>

<pre><code>my ($number) = scalar($string=~/\./gi);
</code></pre>

<p>I thought that by putting parentheses around <code>$number</code>, I'd force array context, and by the use of <code>scalar</code>, I'd get the count. However, all I get is <code>1</code>.</p>
------------------------------------------------------------------ <br><h3> Answer 1849356 friedo: </h3><p>That puts the regex itself in scalar context, which isn't what you want. Instead, put the regex in list context (to get the number of matches) and put <em>that</em> into scalar context.</p>

<pre><code> my $number = () = $string =~ /\./gi;
</code></pre>
<h4> Comment 44613426 oalders: </h4>Well, perlsecret does propose &quot;Saturn&quot; as an alternate name. :)<br><h4> Comment 92385178 Edward Gargan: </h4>Can someone explain this bit of code to me? I&#39;m new to perl and I&#39;m still not really comfortable with contexts.<br><h4> Comment 114154069 Robert P: </h4>The first part, <code>() = $string =~ &#47;\.&#47;gi</code>, make the match operator return the results of the match in a list context. This is similar to <code>my @results = $string =~ &#47;\.&#47;gi;</code>. Next, the <code>my $number</code> part is a scalar value. Assigning the results of the list context to a scalar returns its length. This is the same as <code>my $count = @some_list</code>, which returns the length of the array. My answer below is another way of visualizing the behavior here.<br>------------------------------------------------------------------ <br><h3> Answer 1849400 Robert P: </h3><p>I think the clearest way to describe this would be to avoid the instant-cast to scalar.  First assign to an array, and then use that array in scalar context.  That's basically what the <code>= () =</code> idiom will do, but without the (rarely used) idiom:</p>

<pre><code>my $string = "one.two.three.four";
my @count = $string =~ /\./g;
print scalar @count;
</code></pre>
<h4> Comment 1743687 Matteo Riva: </h4>+1 for the most straightforward way, goatse operator is scary.<br><h4> Comment 1743690 Matteo Riva: </h4>Parentheses around <code>@count</code> are unnecessary though.<br>------------------------------------------------------------------ <br><h3> Answer 1849415 Robert P: </h3><p>Also, see <a href="http://perldoc.perl.org/perlfaq4.html#How-can-I-count-the-number-of-occurrences-of-a-substring-within-a-string%3F" rel="noreferrer">Perlfaq4</a> :</p>

<blockquote>
  <p>There are a number of ways, with varying efficiency. If you want a count of a certain single character (X) within a string, you can use the tr/// function like so:</p>

<pre><code>$string = "ThisXlineXhasXsomeXx'sXinXit";
$count = ($string =~ tr/X//);
print "There are $count X characters in the string";
</code></pre>
  
  <p>This is fine if you are just looking for a single character. However, if you are trying to count multiple character substrings within a larger string, tr/// won't work. What you can do is wrap a while() loop around a global pattern match. For example, let's count negative integers:</p>

<pre><code>$string = "-9 55 48 -2 23 -76 4 14 -44";
while ($string =~ /-\d+/g) { $count++ }
print "There are $count negative numbers in the string";
</code></pre>
  
  <p>Another version uses a global match in list context, then assigns the result to a scalar, producing a count of the number of matches.</p>

<pre><code>$count = () = $string =~ /-\d+/g;
</code></pre>
</blockquote>
------------------------------------------------------------------ <br><h3> Answer 1850686 Mike : </h3><p>Is the following code a one-liner?</p>

<pre><code>print $string =~ s/\./\./g;
</code></pre>
------------------------------------------------------------------ <br><h3> Answer 1849350 PP.: </h3><p>Try this:</p>
<pre><code>my $string = &quot;one.two.three.four&quot;;
my ($number) = scalar( @{[ $string=~/\./gi ]} );
</code></pre>
<p>It returns <code>3</code> for me. By creating a reference to an array the regular expression is evaluated in list context and the <code>@{..}</code> de-references the array reference.</p>
<h4> Comment 1743796 Brad Gilbert: </h4>You don&#39;t need any of those parenthesis.<br><h4> Comment 23443314 Wick: </h4>I must say I like this method better than goatse. In fact I like pretty much everything better than goatse.<br>------------------------------------------------------------------ <br><h3> Answer 55477492 Alastair Skeffington: </h3><p>I noticed that if you have an OR condition in your regular expression (eg <code>/(K..K)|(V.AK)/gi</code> ) then the array produced may have undefined elements which are included in the count at the end.</p>

<p>For example:</p>

<pre><code>my $seq = "TSYCSKSNKRCRRKYGDDDDWWRSQYTTYCSCYTGKSGKTKGGDSCDAYYEAYGKSGKTKGGRNNR";
my $regex = '(K..K)|(V.AK)';
my $count = () = $seq =~ /$regex/gi;
print "$count\n";
</code></pre>

<p>Gives a value of count of 6.</p>

<p>I found the solution in this post
<a href="https://stackoverflow.com/questions/11122977/how-do-i-remove-all-undefs-from-array">How do I remove all undefs from array?</a></p>

<pre><code>my $seq = "TSYCSKSNKRCRRKYGDDDDWWRSQYTTYCSCYTGKSGKTKGGDSCDAYYEAYGKSGKTKGGRNNR";
my $regex = '(K..K)|(V.AK)';
my @count = $seq =~ /$regex/gi;
@count = grep defined, @count; 
my $count = scalar @count;
print "$count\n";
</code></pre>

<p>Which then gives the correct answer of three.</p>
------------------------------------------------------------------ <br><h3> Answer 1850449 ghostdog74: </h3><p>another way,</p>

<pre><code>my $string = "one.two.three.four";
@s = split /\./,$string;
print scalar @s - 1;
</code></pre>
------------------------------------------------------------------ <br><h3> Answer 33305808 HoldOffHunger: </h3><p>Friedo's method is: <code>$a = () = $b =~ $c</code>.</p>

<p>But it's possible to simplify this even further to just <code>($a) = $b =~ $c</code>, like so :</p>

<pre><code>my ($matchcount) = $text =~ s/$findregex/ /gi;
</code></pre>

<p>You could thank just wrap this up in a function, <code>getMatchCount()</code>, and not worry about it destroying the passed string.</p>

<p>On the other hand, you can add in a swap, which may be a bit more computation, but does not result in altering the string.</p>

<pre><code>my ($matchcount) = $text =~ s/($findregex)/$1/gi;
</code></pre>
<h4> Comment 87506873 HoldOffHunger: </h4>@fishinear: This is very different than Mike.  He was capable of printing it, but not storing it to a variable.  The difference is significant.<br><h4> Comment 88864232 android.weasel: </h4>If you need nondestructive, just s/(regex)/$1/g or /(=regex)//g if you like living dangerously.<br><h4> Comment 88864623 HoldOffHunger: </h4>@android.weasel Oh, hey, good point!  Updating with that remark.  I normally wrap stuff like this in functions, so I myself don&#39;t have to worry about the destructability of passed args (not sure which is faster, because now it&#39;s doing a swap).  But that is useful info, adding!<br><h4> Comment 70299506 fishinear: </h4>Except that this is a substitution, not a match: it will destroy the original string. And it is the same idea as @Mike had 6 years earlier.<br>------------------------------------------------------------------ <br><h3> Answer 50243797 Tim Cadell: </h3><pre><code>my $count = 0;
my $pos = -1;
while (($pos = index($string, $match, $pos+1)) &gt; -1) {
  $count++;
}
</code></pre>

<p>checked with Benchmark, it's pretty fast</p>
<h4> Comment 92379808 Jim Balter: </h4>That&#39;s not a pattern match.<br>