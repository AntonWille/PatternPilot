 <h2> Title: How to extract string following a pattern with grep, regex or perl </h2> <h4> wrangler, question_id: 5080988, created_at: 2011-02-22 16:34:07+00:00 </h4>Score: 120, Tags: {regex,perl,sed,html-parsing,text-extraction} <br><p>I have a file that looks something like this:</p>

<pre class="lang-xml prettyprint-override"><code>    &lt;table name="content_analyzer" primary-key="id"&gt;
      &lt;type="global" /&gt;
    &lt;/table&gt;
    &lt;table name="content_analyzer2" primary-key="id"&gt;
      &lt;type="global" /&gt;
    &lt;/table&gt;
    &lt;table name="content_analyzer_items" primary-key="id"&gt;
      &lt;type="global" /&gt;
    &lt;/table&gt;
</code></pre>

<p>I need to extract anything within the quotes that follow <code>name=</code>, i.e., <code>content_analyzer</code>, <code>content_analyzer2</code> and <code>content_analyzer_items</code>.</p>

<p>I am doing this on a Linux box, so a solution using sed, perl, grep or bash is fine.</p>
<h4> Comment by Christoffer Hammarstr&#246;m, Score: 9, Id: 5692161, created_at: 2011-02-22 16:42:33+00:00 </h4>I feel that it would be wrong not to link to <a href="http://stackoverflow.com/questions/1732348/regex-match-open-tags-except-xhtml-self-contained-tags/1732454#1732454" title="regex match open tags except xhtml self contained tags">stackoverflow.com/questions/1732348/&hellip;</a><h4> Comment by Benoit, Score: 6, Id: 5692159, created_at: 2011-02-22 16:42:30+00:00 </h4>no need to be shy, welcome here!<h4> Comment by wrangler, Score: 1, Id: 5724715, created_at: 2011-02-24 15:20:46+00:00 </h4>Thanks everyone for the useful comments. I apologize for the XML not being properly formatted. I deleted some tags for simplification.<hr><h3> ✔️ Answer by sidyll, Id: 5081519, Score: 221, created_at: 2011-02-22 17:21:05+00:00 </h3><p>Since you need to match content without including it in the result (must
match <code>name="</code>  but it's not  part of the  desired result) some  form of
zero-width matching  or group  capturing is required.  This can  be done
easily with the following tools:</p>

<h3>Perl</h3>

<p>With Perl you  could use the <code>n</code>  option to loop line by  line and print
the content of a capturing group if it matches:</p>

<pre><code>perl -ne 'print "$1\n" if /name="(.*?)"/' filename
</code></pre>

<h3>GNU grep</h3>

<p>If you have an improved version of  grep, such as GNU grep, you may have
the  <code>-P</code> option  available. This  option will  enable Perl-like  regex,
allowing you to use <code>\K</code> which  is a shorthand lookbehind. It will reset
the match position, so anything before it is zero-width.</p>

<pre><code>grep -Po 'name="\K.*?(?=")' filename
</code></pre>

<p>The <code>o</code>  option makes grep print  only the matched text,  instead of the
whole line.</p>

<h3>Vim - Text Editor</h3>

<p>Another way  is to  use a  text editor  directly. With  Vim, one  of the
various  ways of  accomplishing this  would be  to delete  lines without
<code>name=</code> and then extract the content from the resulting lines:</p>

<pre><code>:v/.*name="\v([^"]+).*/d|%s//\1
</code></pre>

<hr>

<h3>Standard grep</h3>

<p>If you  don't have  access to  these tools,  for some  reason, something
similar could be achieved with  standard grep. However, without the look
around it will require some cleanup later:</p>

<pre><code>grep -o 'name="[^"]*"' filename
</code></pre>

<hr>

<h3>A note about saving results</h3>

<p>In all of the commands above the  results will be sent to <code>stdout</code>. It's
important to remember  that you can always  save them by piping  it to a
file by appending:</p>

<pre><code>&gt; result
</code></pre>

<p>to the end of the command.</p>
<h4> Comment by Dennis Williamson, Score: 12, Id: 5695067, created_at: 2011-02-22 19:54:58+00:00 </h4>Lookarounds (in GNU <code>grep</code>): <code>grep -Po &#39;.*name=&quot;\K.*?(?=&quot;.*)&#39;</code><h4> Comment by Dennis Williamson, Score: 3, Id: 5698537, created_at: 2011-02-23 00:59:05+00:00 </h4>Why would I be angry? Without the <code>.*</code>, you can do <code>grep -Po &#39;(?&lt;=name=&quot;).*?(?=&quot;)&#39;</code>. The <code>\K</code> can be used for shorthand, but it&#39;s really only needed if the match to its left is variable length. In cases like this, the reason for using lookarounds is fairly obvious. Ungreedy operations look a little neater (<code>[^&quot;]*</code> versus <code>.*?</code> and you don&#39;t have to repeat the anchor character. I don&#39;t know about speed. That depends a lot on the context, I think. I hope that&#39;s helpful.<h4> Comment by Per Quested Aronsson, Score: 0, Id: 44276957, created_at: 2015-01-14 10:15:14+00:00 </h4>The -P flag does not seem to be supported on OS X: grep [-abcDEFGHhIiJLlmnOoqRSsUVvwxZ] [-A num] [-B num] [-C[num]] 	[-e pattern] [-f file] [--binary-files=value] [--color=when] 	[--context[=num]] [--directories=action] [--label] [--line-buffered] 	[--null] [pattern] [file ...]<h4> Comment by sidyll, Score: 0, Id: 5698795, created_at: 2011-02-23 01:33:11+00:00 </h4>@Dennis Williamson: certainly sir, a lot of helpful information here. I think the reason I kept the <code>\K</code> (after researching on it) and removed the <code>.*</code> was the same: make it look pretty (simpler). And I&#39;ve never thought in using <code>.*?</code> instead of the &quot;traditional way&quot; I learned from somewhere. But un-greedy here really makes sense. Thanks Dennis, best wishes.<h4> Comment by sidyll, Score: 0, Id: 5697905, created_at: 2011-02-22 23:44:01+00:00 </h4>@Dennis Williamson, great. I updated the answer accordingly, but left both <code>.*</code> aside, I hope you don&#39;t get angry with me. I&#39;d like to ask, do you see any benefits from un-greedy match over &quot;anything except <code>&quot;</code>&quot;? Don&#39;t take this as a fight, I&#39;m just curious and I&#39;m not a regex expert. Also, the <code>\K</code> tip, really nice. Thanks Dennis.<h4> Comment by Andrew, Score: 0, Id: 70701624, created_at: 2017-01-20 01:30:10+00:00 </h4><code>grep -Po &#39;look-ahead \K capture&#39;</code> made my day. Slick.<h4> Comment by lreeder, Score: 0, Id: 33659865, created_at: 2014-03-04 16:04:52+00:00 </h4>+1 for describing the command.  Would appreciate it if you could update your answer to explain the &quot;[...]&quot; part of the regex.<h4> Comment by sidyll, Score: 0, Id: 33798361, created_at: 2014-03-07 15:11:53+00:00 </h4>@lreeder Thank you. That is a character class, when it begins with <code>^</code> that means it matches anything except its contents. So <code>[^&quot;]</code> means every character that&#39;s not a quote. I didn&#39;t use it in the latter answer in favor of the unready version, <code>.*?</code>. The previous was greedy, so I used that class to match everything not a quote with the intention of stopping on the first quote, which is the same as matching anything &quot;ungreedly&quot; up to a quote. Hope this helps understanding it, let me know if I can clarify better some part.<h4> Comment by Sebasti&#225;n Barschkis, Score: 0, Id: 49154534, created_at: 2015-05-29 23:43:07+00:00 </h4>On OS X, simply install <code>grep</code> via homebrew and use that instead of the default one. It should work.<h4> Comment by sidyll, Score: 0, Id: 44303199, created_at: 2015-01-14 23:02:49+00:00 </h4>@PerQuestedAronsson its is cited in the manual as extension. Not sure how documented it is, but well, I&#39;m on OS X as well and works here.<h4> Comment by Per Quested Aronsson, Score: 0, Id: 44310863, created_at: 2015-01-15 07:18:13+00:00 </h4>@sidyll: I found this article: &quot;Perl Regex Removed From Grep in Mountain Lion&quot; (<a href="http://www.dirtdon.com/?p=1452" rel="nofollow noreferrer">dirtdon.com/?p=1452</a> ). I&#39;m on Yosemite myself, but the article seems to be valid for that as well.<hr><h3>  Answer by Matt Shaver, Id: 5081049, Score: 6, created_at: 2011-02-22 16:39:26+00:00 </h3><p>The regular expression would be:</p>

<pre><code>.+name="([^"]+)"
</code></pre>

<p>Then the grouping would be in the \1 </p>
<hr><h3>  Answer by shawnhcorey, Id: 5081093, Score: 5, created_at: 2011-02-22 16:43:01+00:00 </h3><p>If you're using Perl, download a module to parse the XML: <a href="http://search.cpan.org/~grantm/XML-Simple-2.18/lib/XML/Simple.pm" rel="noreferrer">XML::Simple</a>, <a href="http://search.cpan.org/~mirod/XML-Twig-3.37/Twig_pm.slow" rel="noreferrer">XML::Twig</a>, or <a href="http://search.cpan.org/~pajas/XML-LibXML-1.70/LibXML.pod" rel="noreferrer">XML::LibXML</a>.  Don't re-invent the wheel.</p>
<h4> Comment by bvr, Score: 3, Id: 5692774, created_at: 2011-02-22 17:20:31+00:00 </h4>Note that example OP gave is not well-formed (<code>&lt;type=&quot;global&quot;</code> for instance), so most of XML parsers just complain and die.<hr><h3>  Answer by Alan Haggai Alavi, Id: 5081425, Score: 5, created_at: 2011-02-22 17:12:29+00:00 </h3><p>An HTML parser should be used for this purpose rather than regular expressions. A Perl program that makes use of <a href="http://search.cpan.org/perldoc?HTML%3a%3aTreeBuilder" rel="noreferrer"><code>HTML::TreeBuilder</code></a>:</p>

<h2>Program</h2>

<pre><code>#!/usr/bin/env perl

use strict;
use warnings;

use HTML::TreeBuilder;

my $tree = HTML::TreeBuilder-&gt;new_from_file( \*DATA );
my @elements = $tree-&gt;look_down(
    sub { defined $_[0]-&gt;attr('name') }
);

for (@elements) {
    print $_-&gt;attr('name'), "\n";
}

__DATA__
&lt;table name="content_analyzer" primary-key="id"&gt;
  &lt;type="global" /&gt;
&lt;/table&gt;
&lt;table name="content_analyzer2" primary-key="id"&gt;
  &lt;type="global" /&gt;
&lt;/table&gt;
&lt;table name="content_analyzer_items" primary-key="id"&gt;
  &lt;type="global" /&gt;
&lt;/table&gt;
</code></pre>

<h2>Output</h2>

<pre><code>content_analyzer
content_analyzer2
content_analyzer_items
</code></pre>
<hr><h3>  Answer by Benoit, Id: 5081046, Score: 2, created_at: 2011-02-22 16:39:07+00:00 </h3><p>this could do it:</p>

<pre><code>perl -ne 'if(m/name="(.*?)"/){ print $1 . "\n"; }'
</code></pre>
<hr><h3>  Answer by mitma, Id: 5329508, Score: 2, created_at: 2011-03-16 17:49:36+00:00 </h3><p>Here's a solution using HTML tidy &amp; xmlstarlet:</p>

<pre><code>htmlstr='
&lt;table name="content_analyzer" primary-key="id"&gt;
&lt;type="global" /&gt;
&lt;/table&gt;
&lt;table name="content_analyzer2" primary-key="id"&gt;
&lt;type="global" /&gt;
&lt;/table&gt;
&lt;table name="content_analyzer_items" primary-key="id"&gt;
&lt;type="global" /&gt;
&lt;/table&gt;
'

echo "$htmlstr" | tidy -q -c -wrap 0 -numeric -asxml -utf8 --merge-divs yes --merge-spans yes 2&gt;/dev/null |
sed '/type="global"/d' |
xmlstarlet sel -N x="http://www.w3.org/1999/xhtml" -T -t -m "//x:table" -v '@name' -n
</code></pre>
<hr><h3>  Answer by mitma, Id: 5329633, Score: 1, created_at: 2011-03-16 17:59:18+00:00 </h3><p>Oops, the sed command has to precede the tidy command of course:</p>

<pre><code>echo "$htmlstr" | 
sed '/type="global"/d' |
tidy -q -c -wrap 0 -numeric -asxml -utf8 --merge-divs yes --merge-spans yes 2&gt;/dev/null |
xmlstarlet sel -N x="http://www.w3.org/1999/xhtml" -T -t -m "//x:table" -v '@name' -n
</code></pre>
<hr><h3>  Answer by Carlos Lindado, Id: 47602650, Score: 0, created_at: 2017-12-01 22:56:02+00:00 </h3><p>If the structure of your xml (or text in general) is fixed, the easiest way is using <code>cut</code>. For your specific case:</p>

<pre><code>echo '&lt;table name="content_analyzer" primary-key="id"&gt;
  &lt;type="global" /&gt;
&lt;/table&gt;
&lt;table name="content_analyzer2" primary-key="id"&gt;
  &lt;type="global" /&gt;
&lt;/table&gt;
&lt;table name="content_analyzer_items" primary-key="id"&gt;
  &lt;type="global" /&gt;
&lt;/table&gt;' | grep name= | cut -f2 -d '"'
</code></pre>
