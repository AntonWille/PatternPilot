 <h2> Title: How slicing in Python works </h2> <h4> Simon, question_id: 509211 </h4>Score: 4561, Tags: {python,slice,sequence} <br><p>How does Python's <em>slice notation</em> work? That is: when I write code like <code>a[x:y:z]</code>, <code>a[:]</code>, <code>a[::2]</code> etc., how can I understand which elements end up in the slice?</p>
<hr />
<p><sub>See <a href="https://stackoverflow.com/questions/11364533">Why are slice and range upper-bound exclusive?</a> to learn why <code>xs[0:2] == [xs[0], xs[1]]</code>, <em>not</em> <code>[..., xs[2]]</code>.</sub><br />
<sub>See <a href="https://stackoverflow.com/questions/1403674/">Make a new list containing every Nth item in the original list</a> for <code>xs[::N]</code>.</sub><br />
<sub>See <a href="https://stackoverflow.com/questions/10623302">How does assignment work with list slices?</a> to learn what <code>xs[0:2] = [&quot;a&quot;, &quot;b&quot;]</code> does.</sub></p>
------------------------------------------------------------------ <br><h3> Greg Hewgill, Id: 509295, Score: 6458: </h3><p>The syntax is:</p>
<pre><code>a[start:stop]  # items start through stop-1
a[start:]      # items start through the rest of the array
a[:stop]       # items from the beginning through stop-1
a[:]           # a copy of the whole array
</code></pre>
<p>There is also the <code>step</code> value, which can be used with any of the above:</p>
<pre><code>a[start:stop:step] # start through not past stop, by step
</code></pre>
<p>The key point to remember is that the <code>:stop</code> value represents the first value that is <em>not</em> in the selected slice. So, the difference between <code>stop</code> and <code>start</code> is the number of elements selected (if <code>step</code> is 1, the default).</p>
<p>The other feature is that <code>start</code> or <code>stop</code> may be a <em>negative</em> number, which means it counts from the end of the array instead of the beginning. So:</p>
<pre><code>a[-1]    # last item in the array
a[-2:]   # last two items in the array
a[:-2]   # everything except the last two items
</code></pre>
<p>Similarly, <code>step</code> may be a negative number:</p>
<pre><code>a[::-1]    # all items in the array, reversed
a[1::-1]   # the first two items, reversed
a[:-3:-1]  # the last two items, reversed
a[-3::-1]  # everything except the last two items, reversed
</code></pre>
<p>Python is kind to the programmer if there are fewer items than you ask for. For example, if you ask for <code>a[:-2]</code> and <code>a</code> only contains one element, you get an empty list instead of an error. Sometimes you would prefer the error, so you have to be aware that this may happen.</p>
<h3>Relationship with the <code>slice</code> object</h3>
<p>A <a href="https://www.w3schools.com/python/ref_func_slice.asp" rel="noreferrer"><code>slice</code> object</a> can represent a slicing operation, i.e.:</p>
<pre><code>a[start:stop:step]
</code></pre>
<p>is equivalent to:</p>
<pre><code>a[slice(start, stop, step)]
</code></pre>
<p>Slice objects also behave slightly differently depending on the number of arguments, similar to <code>range()</code>, i.e. both <code>slice(stop)</code> and <code>slice(start, stop[, step])</code> are supported.
To skip specifying a given argument, one might use <code>None</code>, so that e.g. <code>a[start:]</code> is equivalent to <code>a[slice(start, None)]</code> or <code>a[::-1]</code> is equivalent to <code>a[slice(None, None, -1)]</code>.</p>
<p>While the <code>:</code>-based notation is very helpful for simple slicing, the explicit use of <code>slice()</code> objects simplifies the programmatic generation of slicing.</p>
<h4> Beni Cherniavsky-Paskin, Comment 27984940 Score: 198: </h4>Slicing builtin types returns a copy but that&#39;s not universal.  Notably, <a href="http://docs.scipy.org/doc/numpy/reference/arrays.indexing.html" rel="nofollow noreferrer">slicing NumPy arrays</a> returns a view that shares memory with the original.<br><h4> Mark Ransom, Comment 95272803 Score: 147: </h4>This is a beautiful answer with the votes to prove it, but it misses one thing: you can substitute <code>None</code> for any of the empty spaces. For example <code>[None:None]</code> makes a whole copy. This is useful when you need to specify the end of the range using a variable and need to include the last item.<br><h4> axell-brendow, Comment 100203434 Score: 41: </h4>And I know that &quot;abcdef&quot;[::-1] is transformed to &quot;abcdef&quot;[6:-7:-1], so, the best way to explain would be: let <i>len</i> be the length of the sequence. <b>If step is positive</b>, the defaults for start and end are 0 and <i>len</i>. <b>Else if step is negative</b>, the defaults for start and end are <i>len</i> and -<i>len</i> - 1.<br><h4> axell-brendow, Comment 100203161 Score: 34: </h4>What really annoys me is that python says that when you don&#39;t set the start and the end, they default to 0 and the length of sequence. So, in theory, when you use &quot;abcdef&quot;[::-1] it should be transformed to &quot;abcdef&quot;[0:6:-1], but these two expressions does not get the same output. I feel that something is missing in python documentation since the creation of the language.<br><h4> vreyespue, Comment 99325528 Score: 14: </h4>Note that contrary to usual Python slices (see above), in Pandas Dataframes both the start and the stop are included when present in the index. For further info see the <a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#indexing-slicing-with-labels" rel="nofollow noreferrer">Pandas indexing documentation</a>.<br><h4> mLstudent33, Comment 119801614 Score: 4: </h4>Why does it seem like start: stop are in the wrong order for these: <code>a[1::-1]   # the first two items, reversed a[:-3:-1]  # the last two items, reversed a[-3::-1]  # everything except the last two items, reversed</code> I checked on iPython console that your answer is correct but it seems to not be in line with the start:stop: step.  I would think reverse first two items would be <code>a[:2:-1]</code><br><h4> Joe, Comment 122166265 Score: 3: </h4>@James_ <code>a[-1]</code> isn&#39;t slicing, it&#39;s indexing, which is why it returns the last object in the list, instead of the sublist containing only the last object in the list, which is what <code>a[-1:]</code> returns.<br><h4> Joe, Comment 122166482 Score: 3: </h4>@mLstudent33, <code>a[:2:-1]</code> does not specify a <code>START</code>, but specifies that you want to index in reverse and <code>STOP</code> at index 2 (not inclusive), so it will return all but the first three elements, in reverse order (i.e. <code>a[-1], a[-2],...,a[3]</code>).  <code>a[1::-1]</code> specifies the <code>START</code> at index 1 (inclusive), does not specify a <code>STOP</code>, and specifies that you want to index in reverse, so it will return the first two entries in the list, in reverse order (i.e. <code>a[1], a[0]</code>).<br><h4> gaoithe, Comment 116525996 Score: 1: </h4>Somewhat interestingly the third step or stride argument was a later addition slice[start:stop:stride] <a href="http://docs.python.org/2.3/whatsnew/section-slices.html" rel="nofollow noreferrer">docs.python.org/2.3/whatsnew/section-slices.html</a><br><h4> Binh Thien, Comment 129415049 Score: 0: </h4>Does anyone see something like this <code>dc[:, i : i + 1, :]</code>?<br><h4> wjandrea, Comment 132943166 Score: 0: </h4>@axell-brendow That&#39;s documented under <a href="https://docs.python.org/3/library/stdtypes.html#common-sequence-operations" rel="nofollow noreferrer">Common Sequence Operations</a>: &quot;<code>s[i:j:k]</code> slice of <i>s</i> from <i>i</i> to <i>j</i> with step <i>k</i> ... [Note 5] ... If <i>i</i> or <i>j</i> are omitted or <code>None</code>, they become “end” values (which end depends on the sign of <code>k</code>).&quot; Also, the canonical equivalent for <code>&quot;abcdef&quot;[::-1]</code> is <code>&quot;abcdef&quot;[-1:-7:-1]</code>.<br><h4> Joe, Comment 135483187 Score: 0: </h4>One thing I was surprised to find is that &quot;the difference between stop and start is the number of elements selected (if step is 1, the default).&quot; is not necessarily true if you mix positive and negative indices. Try <code>&#39;0123456789&#39;[-8:7:1]</code><br><h4> Invictus, Comment 129609400 Score: 0: </h4>I  was trying to evaluate how slice.indices results the range and step &gt;&gt;&gt; slice(None,None,-1).indices(6) (5, -1, -1)  &gt;&gt;&gt; seq=&#39;python&#39; &gt;&gt;&gt; seq[::-1] &#39;nohtyp&#39;  But when i try and use the evaluated value from slice.indices call , it results &gt;&gt;&gt; seq[5:-1:-1] &#39;&#39; It was resulted into an empty slice rather reversing the python. Why so ?<br><h4> JustLearn, Comment 130014875 Score: 0: </h4>@Joe could you please help me out? I don&#39;t understand one thing: why does a[:2:-1] return all elements except first three of them instead of returning all elements except first two of them?  For example if I do this: a[:3] it returns first two elements (except the 3rd)<br><h4> Joe, Comment 130040094 Score: 0: </h4>@JustLearn, <code>a[:3]</code> should return the first <b><i>three</i></b> elements, i.e. elements 0, 1, and 2; stopping before returning element 3 (the fourth element).  <code>[:2:-1]</code> should return all except the first three elements (assuming there are at least 4 elements), because it should return element -1 (the last element), then the one before that, and so on, stopping before returning element 2, and therefore not returning elements 2, 1, or 0. (Python is zero indexed)<br><h4> James_, Comment 119593308 Score: 0: </h4>&quot;a[-1]    # last item in the array&quot; Is this the only way to retrieve last item using Slicing? It seems like a[-1:] doesn&#39;t work. Why?<br>------------------------------------------------------------------ <br><h3> Hans Nowak, Id: 509297, Score: 698: </h3><p>The <a href="https://docs.python.org/3/tutorial/introduction.html#text" rel="nofollow noreferrer">Python tutorial</a> talks about it (scroll down a bit until you get to the part about slicing).</p>
<p>The ASCII art diagram is helpful too for remembering how slices work:</p>
<pre><code> +---+---+---+---+---+---+
 | P | y | t | h | o | n |
 +---+---+---+---+---+---+
   0   1   2   3   4   5
  -6  -5  -4  -3  -2  -1
</code></pre>
<blockquote>
<p>One way to remember how slices work is to think of the indices as pointing <em>between</em> characters, with the left edge of the first character numbered 0. Then the right edge of the last character of a string of <em>n</em> characters has index <em>n</em>.</p>
</blockquote>
<h4> aguadopd, Comment 99270489 Score: 43: </h4>This suggestion works for positive stride, but does not for a negative stride. From the diagram, I expect <code>a[-4,-6,-1]</code> to be <code>yP</code> but it is <code>ty</code>. What always work is to think in characters or slots and use indexing as a half-open interval -- right-open if positive stride, left-open if negative stride.<br><h4> Javier Ruiz, Comment 118360396 Score: 4: </h4>@aguadopd You are absolutely right. The solution is to have the indices shifted to the right, centered just below the characters, and notice that the stop is always excluded. See another response just below.<br><h4> aguadopd, Comment 118606940 Score: 1: </h4>Addendum to my comment: see my answer with diagrams below: <a href="https://stackoverflow.com/a/56332104/2343869">stackoverflow.com/a/56332104/2343869</a><br><h4> endolith, Comment 100377224 Score: 0: </h4>But there&#39;s no way to collapse to an empty set starting from the end (like <code>x[:0]</code> does when starting from the beginning), so you have to special-case small arrays.  :/<br>------------------------------------------------------------------ <br><h3> ephemient, Id: 509377, Score: 540: </h3><p>Enumerating the possibilities allowed by the grammar for the sequence <code>x</code>:</p>
<pre><code>&gt;&gt;&gt; x[:]                # [x[0],   x[1],          ..., x[-1]    ]
&gt;&gt;&gt; x[low:]             # [x[low], x[low+1],      ..., x[-1]    ]
&gt;&gt;&gt; x[:high]            # [x[0],   x[1],          ..., x[high-1]]
&gt;&gt;&gt; x[low:high]         # [x[low], x[low+1],      ..., x[high-1]]
&gt;&gt;&gt; x[::stride]         # [x[0],   x[stride],     ..., x[-1]    ]
&gt;&gt;&gt; x[low::stride]      # [x[low], x[low+stride], ..., x[-1]    ]
&gt;&gt;&gt; x[:high:stride]     # [x[0],   x[stride],     ..., x[high-1]]
&gt;&gt;&gt; x[low:high:stride]  # [x[low], x[low+stride], ..., x[high-1]]
</code></pre>
<p>Of course, if <code>(high-low)%stride != 0</code>, then the end point will be a little lower than <code>high-1</code>.</p>
<p>If <code>stride</code> is negative, the ordering is changed a bit since we're counting down:</p>
<pre><code>&gt;&gt;&gt; x[::-stride]        # [x[-1],   x[-1-stride],   ..., x[0]    ]
&gt;&gt;&gt; x[high::-stride]    # [x[high], x[high-stride], ..., x[0]    ]
&gt;&gt;&gt; x[:low:-stride]     # [x[-1],   x[-1-stride],   ..., x[low+1]]
&gt;&gt;&gt; x[high:low:-stride] # [x[high], x[high-stride], ..., x[low+1]]
</code></pre>
<p>Extended slicing (with commas and ellipses) are mostly used only by special data structures (like NumPy); the basic sequences don't support them.</p>
<pre><code>&gt;&gt;&gt; class slicee:
...     def __getitem__(self, item):
...         return repr(item)
...
&gt;&gt;&gt; slicee()[0, 1:2, ::5, ...]
'(0, slice(1, 2, None), slice(None, None, 5), Ellipsis)'
</code></pre>
<h4> chepner, Comment 102170688 Score: 0: </h4>@liyuan The type implementing <code>__getitem__</code> is; your example is equivalent to <code>apple[slice(4, -4, -1)]</code>.<br><h4> Bananeen, Comment 124476274 Score: 0: </h4>The first two tables are pure gold.<br><h4> liyuan, Comment 83074550 Score: 0: </h4>Actually there is still something left out e.g. if I type &#39;apple&#39;[4:-4:-1] I get &#39;elp&#39;, python is translating the -4 to a 1 maybe?<br><h4> wjandrea, Comment 95581586 Score: 0: </h4>note that backticks are deprecated in favour of <code>repr</code><br>------------------------------------------------------------------ <br><h3> David M. Perlman, Id: 4729334, Score: 446: </h3><p>The answers above don't discuss slice assignment. To understand slice assignment, it's helpful to add another concept to the ASCII art:</p>

<pre><code>                +---+---+---+---+---+---+
                | P | y | t | h | o | n |
                +---+---+---+---+---+---+
Slice position: 0   1   2   3   4   5   6
Index position:   0   1   2   3   4   5

&gt;&gt;&gt; p = ['P','y','t','h','o','n']
# Why the two sets of numbers:
# indexing gives items, not lists
&gt;&gt;&gt; p[0]
 'P'
&gt;&gt;&gt; p[5]
 'n'

# Slicing gives lists
&gt;&gt;&gt; p[0:1]
 ['P']
&gt;&gt;&gt; p[0:2]
 ['P','y']
</code></pre>

<p>One heuristic is, for a slice from zero to n, think: "zero is the beginning, start at the beginning and take n items in a list".</p>

<pre><code>&gt;&gt;&gt; p[5] # the last of six items, indexed from zero
 'n'
&gt;&gt;&gt; p[0:5] # does NOT include the last item!
 ['P','y','t','h','o']
&gt;&gt;&gt; p[0:6] # not p[0:5]!!!
 ['P','y','t','h','o','n']
</code></pre>

<p>Another heuristic is, "for any slice, replace the start by zero, apply the previous heuristic to get the end of the list, then count the first number back up to chop items off the beginning"</p>

<pre><code>&gt;&gt;&gt; p[0:4] # Start at the beginning and count out 4 items
 ['P','y','t','h']
&gt;&gt;&gt; p[1:4] # Take one item off the front
 ['y','t','h']
&gt;&gt;&gt; p[2:4] # Take two items off the front
 ['t','h']
# etc.
</code></pre>

<p>The first rule of slice assignment is that since slicing <em>returns</em> a list, slice assignment <em>requires</em> a list (or other iterable):</p>

<pre><code>&gt;&gt;&gt; p[2:3]
 ['t']
&gt;&gt;&gt; p[2:3] = ['T']
&gt;&gt;&gt; p
 ['P','y','T','h','o','n']
&gt;&gt;&gt; p[2:3] = 't'
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: can only assign an iterable
</code></pre>

<p>The second rule of slice assignment, which you can also see above, is that whatever portion of the list is returned by slice indexing, that's the same portion that is changed by slice assignment:</p>

<pre><code>&gt;&gt;&gt; p[2:4]
 ['T','h']
&gt;&gt;&gt; p[2:4] = ['t','r']
&gt;&gt;&gt; p
 ['P','y','t','r','o','n']
</code></pre>

<p>The third rule of slice assignment is, the assigned list (iterable) doesn't have to have the same length; the indexed slice is simply sliced out and replaced en masse by whatever is being assigned:</p>

<pre><code>&gt;&gt;&gt; p = ['P','y','t','h','o','n'] # Start over
&gt;&gt;&gt; p[2:4] = ['s','p','a','m']
&gt;&gt;&gt; p
 ['P','y','s','p','a','m','o','n']
</code></pre>

<p>The trickiest part to get used to is assignment to empty slices. Using heuristic 1 and 2 it's easy to get your head around <em>indexing</em> an empty slice:</p>

<pre><code>&gt;&gt;&gt; p = ['P','y','t','h','o','n']
&gt;&gt;&gt; p[0:4]
 ['P','y','t','h']
&gt;&gt;&gt; p[1:4]
 ['y','t','h']
&gt;&gt;&gt; p[2:4]
 ['t','h']
&gt;&gt;&gt; p[3:4]
 ['h']
&gt;&gt;&gt; p[4:4]
 []
</code></pre>

<p>And then once you've seen that, slice assignment to the empty slice makes sense too:</p>

<pre><code>&gt;&gt;&gt; p = ['P','y','t','h','o','n']
&gt;&gt;&gt; p[2:4] = ['x','y'] # Assigned list is same length as slice
&gt;&gt;&gt; p
 ['P','y','x','y','o','n'] # Result is same length
&gt;&gt;&gt; p = ['P','y','t','h','o','n']
&gt;&gt;&gt; p[3:4] = ['x','y'] # Assigned list is longer than slice
&gt;&gt;&gt; p
 ['P','y','t','x','y','o','n'] # The result is longer
&gt;&gt;&gt; p = ['P','y','t','h','o','n']
&gt;&gt;&gt; p[4:4] = ['x','y']
&gt;&gt;&gt; p
 ['P','y','t','h','x','y','o','n'] # The result is longer still
</code></pre>

<p>Note that, since we are not changing the second number of the slice (4), the inserted items always stack right up against the 'o', even when we're assigning to the empty slice. So the position for the empty slice assignment is the logical extension of the positions for the non-empty slice assignments.</p>

<p>Backing up a little bit, what happens when you keep going with our procession of counting up the slice beginning?</p>

<pre><code>&gt;&gt;&gt; p = ['P','y','t','h','o','n']
&gt;&gt;&gt; p[0:4]
 ['P','y','t','h']
&gt;&gt;&gt; p[1:4]
 ['y','t','h']
&gt;&gt;&gt; p[2:4]
 ['t','h']
&gt;&gt;&gt; p[3:4]
 ['h']
&gt;&gt;&gt; p[4:4]
 []
&gt;&gt;&gt; p[5:4]
 []
&gt;&gt;&gt; p[6:4]
 []
</code></pre>

<p>With slicing, once you're done, you're done; it doesn't start slicing backwards. In Python you don't get negative strides unless you explicitly ask for them by using a negative number.</p>

<pre><code>&gt;&gt;&gt; p[5:3:-1]
 ['n','o']
</code></pre>

<p>There are some weird consequences to the "once you're done, you're done" rule:</p>

<pre><code>&gt;&gt;&gt; p[4:4]
 []
&gt;&gt;&gt; p[5:4]
 []
&gt;&gt;&gt; p[6:4]
 []
&gt;&gt;&gt; p[6]
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
IndexError: list index out of range
</code></pre>

<p>In fact, compared to indexing, Python slicing is bizarrely error-proof:</p>

<pre><code>&gt;&gt;&gt; p[100:200]
 []
&gt;&gt;&gt; p[int(2e99):int(1e99)]
 []
</code></pre>

<p>This can come in handy sometimes, but it can also lead to somewhat strange behavior:</p>

<pre><code>&gt;&gt;&gt; p
 ['P', 'y', 't', 'h', 'o', 'n']
&gt;&gt;&gt; p[int(2e99):int(1e99)] = ['p','o','w','e','r']
&gt;&gt;&gt; p
 ['P', 'y', 't', 'h', 'o', 'n', 'p', 'o', 'w', 'e', 'r']
</code></pre>

<p>Depending on your application, that might... or might not... be what you were hoping for there!</p>

<hr/>

<p>Below is the text of my original answer. It has been useful to many people, so I didn't want to delete it.</p>

<pre><code>&gt;&gt;&gt; r=[1,2,3,4]
&gt;&gt;&gt; r[1:1]
[]
&gt;&gt;&gt; r[1:1]=[9,8]
&gt;&gt;&gt; r
[1, 9, 8, 2, 3, 4]
&gt;&gt;&gt; r[1:1]=['blah']
&gt;&gt;&gt; r
[1, 'blah', 9, 8, 2, 3, 4]
</code></pre>

<p>This may also clarify the difference between slicing and indexing.</p>
<h4> Alex O, Comment 129107053 Score: 0: </h4>If I wanted to remove the 1st x elements of a list, what will be better: <code>l = l[6:]</code> or <code>l[:] = l[6:]</code>?<br><h4> David M. Perlman, Comment 129131819 Score: 0: </h4>The first way works for a list or a string; the second way only works for a list, because slice assignment isn&#39;t allowed for strings. Other than that I think the only difference is speed: it looks like it&#39;s a little faster the first way. Try it yourself with timeit.timeit() or preferably  timeit.repeat(). They are <i>super</i> easy to use and very educational, it&#39;s worth getting used to playing with them all the time!<br><h4> Edamame, Comment 129923223 Score: 0: </h4>Curious about what&#39;s the time complexity of doing <code>r[1:1]=[&#39;blah&#39;]</code> ? thanks!<br><h4> Simo, Comment 133957364 Score: 0: </h4>p[2:3] = &#39;t&#39; works fine ! there should be no TypeError !<br>------------------------------------------------------------------ <br><h3> Russia Must Remove Putin, Id: 24713353, Score: 293: </h3><blockquote>
<h2>Explain Python's slice notation</h2>
</blockquote>
<p>In short, the colons (<code>:</code>) in subscript notation (<code>subscriptable[subscriptarg]</code>) make slice notation, which has the optional arguments <code>start</code>, <code>stop</code>, and <code>step</code>:</p>
<pre class="lang-py prettyprint-override"><code>sliceable[start:stop:step]
</code></pre>
<p>Python slicing is a computationally fast way to methodically access parts of your data. In my opinion, to be even an intermediate Python programmer, it's one aspect of the language that it is necessary to be familiar with.</p>
<h2>Important Definitions</h2>
<p>To begin with, let's define a few terms:</p>
<blockquote>
<p><strong><code>start</code>:</strong> the beginning index of the slice, it will include the element at this index unless it is the same as <em>stop</em>, defaults to 0, i.e. the first index. If it's negative, it means to start <code>n</code> items from the end.</p>
<p><strong><code>stop</code>:</strong> the ending index of the slice, it does <em>not</em> include the element at this index, defaults to length of the sequence being sliced, that is, up to and including the end.</p>
<p><strong><code>step</code>:</strong> the amount by which the index increases, defaults to 1. If it's negative, you're slicing over the iterable in reverse.</p>
</blockquote>
<h2>How Indexing Works</h2>
<p>You can make any of these positive or negative numbers. The meaning of the positive numbers is straightforward, but for negative numbers, just like indexes in Python, you count backwards from the end for the <em>start</em> and <em>stop</em>, and for the <em>step</em>, you simply decrement your index. This example is <a href="https://docs.python.org/2/tutorial/introduction.html" rel="noreferrer">from the documentation's tutorial</a>, but I've modified it slightly to indicate which item in a sequence each index references:</p>
<pre class="lang-py prettyprint-override"><code> +---+---+---+---+---+---+
 | P | y | t | h | o | n |
 +---+---+---+---+---+---+
   0   1   2   3   4   5 
  -6  -5  -4  -3  -2  -1
</code></pre>
<h2>How Slicing Works</h2>
<p>To use slice notation with a sequence that supports it, you must include at least one colon in the square brackets that follow the sequence (which actually <a href="https://docs.python.org/2/reference/datamodel.html#object.__getitem__" rel="noreferrer">implement the <code>__getitem__</code> method of the sequence, according to the Python data model</a>.)</p>
<p>Slice notation works like this:</p>
<pre class="lang-py prettyprint-override"><code>sequence[start:stop:step]
</code></pre>
<p>And recall that there are defaults for <em>start</em>, <em>stop</em>, and <em>step</em>, so to access the defaults, simply leave out the argument.</p>
<p>Slice notation to get the last nine elements from a list (or any other sequence that supports it, like a string) would look like this:</p>
<pre class="lang-py prettyprint-override"><code>my_list[-9:]
</code></pre>
<p>When I see this, I read the part in the brackets as &quot;9th from the end, to the end.&quot; (Actually, I abbreviate it mentally as &quot;-9, on&quot;)</p>
<h2>Explanation:</h2>
<p>The full notation is</p>
<pre class="lang-py prettyprint-override"><code>my_list[-9:None:None]
</code></pre>
<p>and to substitute the defaults (actually when <code>step</code> is negative, <code>stop</code>'s default is <code>-len(my_list) - 1</code>, so <code>None</code> for stop really just means it goes to whichever end step takes it to):</p>
<pre class="lang-py prettyprint-override"><code>my_list[-9:len(my_list):1]
</code></pre>
<p>The <strong>colon</strong>, <code>:</code>,  is what tells Python you're giving it a slice and not a regular index. That's why the idiomatic way of making a shallow copy of lists in Python 2 is</p>
<pre class="lang-py prettyprint-override"><code>list_copy = sequence[:]
</code></pre>
<p>And clearing them is with:</p>
<pre class="lang-py prettyprint-override"><code>del my_list[:]
</code></pre>
<p>(Python 3 gets a <code>list.copy</code> and <code>list.clear</code> method.)</p>
<h3>When <code>step</code> is negative, the defaults for <code>start</code> and <code>stop</code> change</h3>
<p>By default, when the <code>step</code> argument is empty (or <code>None</code>), it is assigned to <code>+1</code>.</p>
<p>But you can pass in a negative integer, and the list (or most other standard sliceables) will be sliced from the end to the beginning.</p>
<p>Thus a negative slice will change the defaults for <code>start</code> and <code>stop</code>!</p>
<h3>Confirming this in the source</h3>
<p>I like to encourage users to read the source as well as the documentation. The <a href="https://github.com/python/cpython/blob/master/Objects/sliceobject.c" rel="noreferrer">source code for slice objects and this logic is found here</a>. First we determine if <code>step</code> is negative:</p>
<blockquote>
<pre class="lang-c prettyprint-override"><code>step_is_negative = step_sign &lt; 0;
</code></pre>
</blockquote>
<p>If so, the lower bound is <code>-1</code>  meaning we slice all the way up to and including the beginning, and the upper bound is the length minus 1, meaning we start at the end. (Note that the semantics of this <code>-1</code> is <em>different</em> from a <code>-1</code> that users may pass indexes in Python indicating the last item.)</p>
<blockquote>
<pre class="lang-c prettyprint-override"><code>if (step_is_negative) {
    lower = PyLong_FromLong(-1L);
    if (lower == NULL)
        goto error;

    upper = PyNumber_Add(length, lower);
    if (upper == NULL)
        goto error;
}
</code></pre>
</blockquote>
<p>Otherwise <code>step</code> is positive, and the lower bound will be zero and the upper bound (which we go up to but not including) the length of the sliced list.</p>
<blockquote>
<pre class="lang-c prettyprint-override"><code>else {
    lower = _PyLong_Zero;
    Py_INCREF(lower);
    upper = length;
    Py_INCREF(upper);
}
</code></pre>
</blockquote>
<p>Then, we may need to apply the defaults for <code>start</code> and <code>stop</code>—the default then for <code>start</code> is calculated as the upper bound when <code>step</code> is negative:</p>
<blockquote>
<pre class="lang-c prettyprint-override"><code>if (self-&gt;start == Py_None) {
    start = step_is_negative ? upper : lower;
    Py_INCREF(start);
}
</code></pre>
</blockquote>
<p>and <code>stop</code>, the lower bound:</p>
<blockquote>
<pre class="lang-c prettyprint-override"><code>if (self-&gt;stop == Py_None) {
    stop = step_is_negative ? lower : upper;
    Py_INCREF(stop);
}
</code></pre>
</blockquote>
<h1>Give your slices a descriptive name!</h1>
<p>You may find it useful to separate forming the slice from passing it to the <code>list.__getitem__</code> method (<a href="https://docs.python.org/2/reference/datamodel.html#object.__getitem__" rel="noreferrer">that's what the square brackets do</a>). Even if you're not new to it, it keeps your code more readable so that others that may have to read your code can more readily understand what you're doing.</p>
<p>However, you can't just assign some integers separated by colons to a variable. You need to use the slice object:</p>
<pre class="lang-py prettyprint-override"><code>last_nine_slice = slice(-9, None)
</code></pre>
<p>The second argument, <code>None</code>, is required, so that the first argument is interpreted as the <code>start</code> argument <a href="https://docs.python.org/2/library/functions.html#slice" rel="noreferrer">otherwise it would be the <code>stop</code> argument</a>.</p>
<p>You can then pass the slice object to your sequence:</p>
<pre class="lang-py prettyprint-override"><code>&gt;&gt;&gt; list(range(100))[last_nine_slice]
[91, 92, 93, 94, 95, 96, 97, 98, 99]
</code></pre>
<p>It's interesting that ranges also take slices:</p>
<pre class="lang-py prettyprint-override"><code>&gt;&gt;&gt; range(100)[last_nine_slice]
range(91, 100)
</code></pre>
<h1>Memory Considerations:</h1>
<p>Since slices of Python lists create new objects in memory, another important function to be aware of is <code>itertools.islice</code>. Typically you'll want to iterate over a slice, not just have it created statically in memory. <code>islice</code> is perfect for this. A caveat, it doesn't support negative arguments to <code>start</code>, <code>stop</code>, or <code>step</code>, so if that's an issue you may need to calculate indices or reverse the iterable in advance.</p>
<pre class="lang-py prettyprint-override"><code>length = 100
last_nine_iter = itertools.islice(list(range(length)), length-9, None, 1)
list_last_nine = list(last_nine_iter)
</code></pre>
<p>and now:</p>
<pre class="lang-py prettyprint-override"><code>&gt;&gt;&gt; list_last_nine
[91, 92, 93, 94, 95, 96, 97, 98, 99]
</code></pre>
<p>The fact that list slices make a copy is a feature of lists themselves. If you're slicing advanced objects like a Pandas DataFrame, it may return a view on the original, and not a copy.</p>
<h4> Russia Must Remove Putin, Comment 113403311 Score: 0: </h4>@WinEunuuchs2Unix that&#39;s great feedback - this is a standard Python behavior, but it could be made clearer in that sort of way, so I&#39;ll consider updating my material to include this semantic.<br><h4> Max, Comment 131714276 Score: 0: </h4>Your answer is the only one (?) that touches the tip of what would be interesting here, when you write &quot;slicable&quot; - the rest is triviality. I wanted to know how the slicing is done, using the <code>__getitem__</code> method. But if I understand well, you have to do all of it on your own: check whether the arg to your <code>__getitem__</code> is an int or a slice (or what else could it be?), and in that (slice) case, deal with all possible cases ((A) or (A,B) or (A,B,C), and all possible sign combinations) on your own.... is that right?<br>------------------------------------------------------------------ <br><h3> Dana, Id: 509415, Score: 161: </h3><p>And a couple of things that weren't immediately obvious to me when I first saw the slicing syntax:</p>

<pre><code>&gt;&gt;&gt; x = [1,2,3,4,5,6]
&gt;&gt;&gt; x[::-1]
[6,5,4,3,2,1]
</code></pre>

<p>Easy way to reverse sequences!</p>

<p>And if you wanted, for some reason, every second item in the reversed sequence:</p>

<pre><code>&gt;&gt;&gt; x = [1,2,3,4,5,6]
&gt;&gt;&gt; x[::-2]
[6,4,2]
</code></pre>
------------------------------------------------------------------ <br><h3> Ankur Agarwal, Id: 13005464, Score: 112: </h3><p>In Python 2.7</p>

<p>Slicing in Python</p>

<pre><code>[a:b:c]

len = length of string, tuple or list

c -- default is +1. The sign of c indicates forward or backward, absolute value of c indicates steps. Default is forward with step size 1. Positive means forward, negative means backward.

a --  When c is positive or blank, default is 0. When c is negative, default is -1.

b --  When c is positive or blank, default is len. When c is negative, default is -(len+1).
</code></pre>

<p>Understanding index assignment is very important.</p>

<pre><code>In forward direction, starts at 0 and ends at len-1

In backward direction, starts at -1 and ends at -len
</code></pre>

<p>When you say [a:b:c], you are saying depending on the sign of c (forward or backward), start at a and end at b (excluding element at bth index). Use the indexing rule above and remember you will only find elements in this range:</p>

<pre><code>-len, -len+1, -len+2, ..., 0, 1, 2,3,4 , len -1
</code></pre>

<p>But this range continues in both directions infinitely:</p>

<pre><code>...,-len -2 ,-len-1,-len, -len+1, -len+2, ..., 0, 1, 2,3,4 , len -1, len, len +1, len+2 , ....
</code></pre>

<p>For example:</p>

<pre><code>             0    1    2   3    4   5   6   7   8   9   10   11
             a    s    t   r    i   n   g
    -9  -8  -7   -6   -5  -4   -3  -2  -1
</code></pre>

<p>If your choice of a, b, and c allows overlap with the range above as you traverse using rules for a,b,c above you will either get a list with elements (touched during traversal) or you will get an empty list.</p>

<p>One last thing: if a and b are equal, then also you get an empty list:</p>

<pre><code>&gt;&gt;&gt; l1
[2, 3, 4]

&gt;&gt;&gt; l1[:]
[2, 3, 4]

&gt;&gt;&gt; l1[::-1] # a default is -1 , b default is -(len+1)
[4, 3, 2]

&gt;&gt;&gt; l1[:-4:-1] # a default is -1
[4, 3, 2]

&gt;&gt;&gt; l1[:-3:-1] # a default is -1
[4, 3]

&gt;&gt;&gt; l1[::] # c default is +1, so a default is 0, b default is len
[2, 3, 4]

&gt;&gt;&gt; l1[::-1] # c is -1 , so a default is -1 and b default is -(len+1)
[4, 3, 2]


&gt;&gt;&gt; l1[-100:-200:-1] # Interesting
[]

&gt;&gt;&gt; l1[-1:-200:-1] # Interesting
[4, 3, 2]


&gt;&gt;&gt; l1[-1:-1:1]
[]


&gt;&gt;&gt; l1[-1:5:1] # Interesting
[4]


&gt;&gt;&gt; l1[1:-7:1]
[]

&gt;&gt;&gt; l1[1:-7:-1] # Interesting
[3, 2]

&gt;&gt;&gt; l1[:-2:-2] # a default is -1, stop(b) at -2 , step(c) by 2 in reverse direction
[4]
</code></pre>
<h4> Deviacium, Comment 77001814 Score: 4: </h4>another one interesting example: <code>a = [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ]; a[:-2:-2]</code> which results to <code>[9]</code><br>------------------------------------------------------------------ <br><h3> AdrianoFerrari, Id: 7315935, Score: 103: </h3><p>Found this great table at <a href="http://wiki.python.org/moin/MovingToPythonFromOtherLanguages" rel="noreferrer">http://wiki.python.org/moin/MovingToPythonFromOtherLanguages</a></p>

<pre><code>Python indexes and slices for a six-element list.
Indexes enumerate the elements, slices enumerate the spaces between the elements.

Index from rear:    -6  -5  -4  -3  -2  -1      a=[0,1,2,3,4,5]    a[1:]==[1,2,3,4,5]
Index from front:    0   1   2   3   4   5      len(a)==6          a[:5]==[0,1,2,3,4]
                   +---+---+---+---+---+---+    a[0]==0            a[:-2]==[0,1,2,3]
                   | a | b | c | d | e | f |    a[5]==5            a[1:2]==[1]
                   +---+---+---+---+---+---+    a[-1]==5           a[1:-1]==[1,2,3,4]
Slice from front:  :   1   2   3   4   5   :    a[-2]==4
Slice from rear:   :  -5  -4  -3  -2  -1   :
                                                b=a[:]
                                                b==[0,1,2,3,4,5] (shallow copy of a)</code></pre>
------------------------------------------------------------------ <br><h3> Simon, Id: 567094, Score: 70: </h3><p>After using it a bit I realise that the simplest description is that it is exactly the same as the arguments in a <code>for</code> loop...</p>

<pre><code>(from:to:step)
</code></pre>

<p>Any of them are optional:</p>

<pre><code>(:to:step)
(from::step)
(from:to)
</code></pre>

<p>Then the negative indexing just needs you to add the length of the string to the negative indices to understand it.</p>

<p>This works for me anyway...</p>
------------------------------------------------------------------ <br><h3> Beni Cherniavsky-Paskin, Id: 9923354, Score: 55: </h3><p>I find it easier to remember how it works, and then I can figure out any specific start/stop/step combination.</p>

<p>It's instructive to understand <code>range()</code> first:</p>

<pre><code>def range(start=0, stop, step=1):  # Illegal syntax, but that's the effect
    i = start
    while (i &lt; stop if step &gt; 0 else i &gt; stop):
        yield i
        i += step
</code></pre>

<p>Begin from <code>start</code>, increment by <code>step</code>, do not reach <code>stop</code>.  Very simple.</p>

<p>The thing to remember about negative step is that <code>stop</code> is always the excluded end, whether it's higher or lower. If you want same slice in opposite order, it's much cleaner to do the reversal separately: e.g. <code>'abcde'[1:-2][::-1]</code> slices off one char from left, two from right, then reverses. (See also <a href="http://www.python.org/dev/peps/pep-0322/" rel="noreferrer"><code>reversed()</code></a>.)</p>

<p>Sequence slicing is same, except it first normalizes negative indexes, and it can never go outside the sequence:</p>

<p><strong>TODO</strong>: The code below had a bug with "never go outside the sequence" when abs(step)>1; I <em>think</em> I patched it to be correct, but it's hard to understand.</p>

<pre><code>def this_is_how_slicing_works(seq, start=None, stop=None, step=1):
    if start is None:
        start = (0 if step &gt; 0 else len(seq)-1)
    elif start &lt; 0:
        start += len(seq)
    if not 0 &lt;= start &lt; len(seq):  # clip if still outside bounds
        start = (0 if step &gt; 0 else len(seq)-1)
    if stop is None:
        stop = (len(seq) if step &gt; 0 else -1)  # really -1, not last element
    elif stop &lt; 0:
        stop += len(seq)
    for i in range(start, stop, step):
        if 0 &lt;= i &lt; len(seq):
            yield seq[i]
</code></pre>

<p>Don't worry about the <code>is None</code> details - just remember that omitting <code>start</code> and/or <code>stop</code> always does the right thing to give you the whole sequence.</p>

<p>Normalizing negative indexes first allows start and/or stop to be counted from the end independently: <code>'abcde'[1:-2] == 'abcde'[1:3] == 'bc'</code> despite <code>range(1,-2) == []</code>.
The normalization is sometimes thought of as "modulo the length", but note it adds the length just once: e.g. <code>'abcde'[-53:42]</code> is just the whole string.</p>
<h4> Eastsun, Comment 67894582 Score: 3: </h4>The <code>this_is_how_slicing_works</code> is not the same as python slice. E.G. <code>[0, 1, 2][-5:3:3]</code> will get [0] in python, but <code>list(this_is_how_slicing_works([0, 1, 2], -5, 3, 3))</code> get [1].<br><h4> Beni Cherniavsky-Paskin, Comment 67913261 Score: 0: </h4>@Eastsun Oops, you&#39;re right!  A clearer case: <code>range(4)[-200:200:3] == [0, 3]</code> but <code>list(this_is_how_slicing_works([0, 1, 2, 3], -200, 200, 3)) == [2]</code>. My <code>if 0 &lt;= i &lt; len(seq):</code> was an attempt to implement &quot;never go outside the sequence&quot; simply but is wrong for step&gt;1.  I&#39;ll rewrite it later today (with tests).<br>------------------------------------------------------------------ <br><h3> Chillar Anand, Id: 29237560, Score: 40: </h3><p>This is how I teach slices to newbies:</p>

<p><strong>Understanding the difference between indexing and slicing:</strong></p>

<p>Wiki Python has this amazing picture which clearly distinguishes indexing and slicing.</p>

<p><img src="https://i.stack.imgur.com/o99aU.png" alt="Enter image description here"></p>

<p>It is a list with six elements in it. To understand slicing better, consider that list as a set of six boxes placed together. Each box has an alphabet in it.</p>

<p>Indexing is like dealing with the contents of box. You can check contents of any box. But you can't check the contents of multiple boxes at once. You can even replace the contents of the box. But you can't place two balls in one box or replace two balls at a time.</p>

<pre><code>In [122]: alpha = ['a', 'b', 'c', 'd', 'e', 'f']

In [123]: alpha
Out[123]: ['a', 'b', 'c', 'd', 'e', 'f']

In [124]: alpha[0]
Out[124]: 'a'

In [127]: alpha[0] = 'A'

In [128]: alpha
Out[128]: ['A', 'b', 'c', 'd', 'e', 'f']

In [129]: alpha[0,1]
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
&lt;ipython-input-129-c7eb16585371&gt; in &lt;module&gt;()
----&gt; 1 alpha[0,1]

TypeError: list indices must be integers, not tuple
</code></pre>

<p>Slicing is like dealing with boxes themselves. You can pick up the first box and place it on another table. To pick up the box, all you need to know is the position of beginning and ending of the box.</p>

<p>You can even pick up the first three boxes or the last two boxes or all boxes between 1 and 4. So, you can pick any set of boxes if you know the beginning and ending. These positions are called start and stop positions.</p>

<p>The interesting thing is that you can replace multiple boxes at once. Also you can place multiple boxes wherever you like.</p>

<pre><code>In [130]: alpha[0:1]
Out[130]: ['A']

In [131]: alpha[0:1] = 'a'

In [132]: alpha
Out[132]: ['a', 'b', 'c', 'd', 'e', 'f']

In [133]: alpha[0:2] = ['A', 'B']

In [134]: alpha
Out[134]: ['A', 'B', 'c', 'd', 'e', 'f']

In [135]: alpha[2:2] = ['x', 'xx']

In [136]: alpha
Out[136]: ['A', 'B', 'x', 'xx', 'c', 'd', 'e', 'f']
</code></pre>

<p><strong>Slicing With Step:</strong></p>

<p>Till now you have picked boxes continuously. But sometimes you need to pick up discretely. For example, you can pick up every second box. You can even pick up every third box from the end. This value is called step size. This represents the gap between your successive pickups. The step size should be positive if You are picking boxes from the beginning to end and vice versa.</p>

<pre><code>In [137]: alpha = ['a', 'b', 'c', 'd', 'e', 'f']

In [142]: alpha[1:5:2]
Out[142]: ['b', 'd']

In [143]: alpha[-1:-5:-2]
Out[143]: ['f', 'd']

In [144]: alpha[1:5:-2]
Out[144]: []

In [145]: alpha[-1:-5:2]
Out[145]: []
</code></pre>

<p><strong>How Python Figures Out Missing Parameters:</strong></p>

<p>When slicing, if you leave out any parameter, Python tries to figure it out automatically.</p>

<p>If you check the source code of <a href="http://en.wikipedia.org/wiki/CPython" rel="noreferrer">CPython</a>, you will find a function called PySlice_GetIndicesEx() which figures out indices to a slice for any given parameters. Here is the logical equivalent code in Python.</p>

<p>This function takes a Python object and optional parameters for slicing and returns the start, stop, step, and slice length for the requested slice.</p>

<pre><code>def py_slice_get_indices_ex(obj, start=None, stop=None, step=None):

    length = len(obj)

    if step is None:
        step = 1
    if step == 0:
        raise Exception("Step cannot be zero.")

    if start is None:
        start = 0 if step &gt; 0 else length - 1
    else:
        if start &lt; 0:
            start += length
        if start &lt; 0:
            start = 0 if step &gt; 0 else -1
        if start &gt;= length:
            start = length if step &gt; 0 else length - 1

    if stop is None:
        stop = length if step &gt; 0 else -1
    else:
        if stop &lt; 0:
            stop += length
        if stop &lt; 0:
            stop = 0 if step &gt; 0 else -1
        if stop &gt;= length:
            stop = length if step &gt; 0 else length - 1

    if (step &lt; 0 and stop &gt;= start) or (step &gt; 0 and start &gt;= stop):
        slice_length = 0
    elif step &lt; 0:
        slice_length = (stop - start + 1)/(step) + 1
    else:
        slice_length = (stop - start - 1)/(step) + 1

    return (start, stop, step, slice_length)
</code></pre>

<p>This is the intelligence that is present behind slices. Since Python has an built-in function called slice, you can pass some parameters and check how smartly it calculates missing parameters.</p>

<pre><code>In [21]: alpha = ['a', 'b', 'c', 'd', 'e', 'f']

In [22]: s = slice(None, None, None)

In [23]: s
Out[23]: slice(None, None, None)

In [24]: s.indices(len(alpha))
Out[24]: (0, 6, 1)

In [25]: range(*s.indices(len(alpha)))
Out[25]: [0, 1, 2, 3, 4, 5]

In [26]: s = slice(None, None, -1)

In [27]: range(*s.indices(len(alpha)))
Out[27]: [5, 4, 3, 2, 1, 0]

In [28]: s = slice(None, 3, -1)

In [29]: range(*s.indices(len(alpha)))
Out[29]: [5, 4]
</code></pre>

<p><strong>Note:</strong> This post was originally written in my blog, <em><a href="https://avilpage.com/2015/03/a-slice-of-python-intelligence-behind.html" rel="noreferrer">The Intelligence Behind Python Slices</a></em>.</p>
<h4> Olivier, Comment 125358697 Score: 1: </h4>At last, I found here some explanation on why the slicing parameters <code>start</code> and <code>stop</code> and error-proof.<br>------------------------------------------------------------------ <br><h3> Steve Losh, Id: 522212, Score: 45: </h3><p>I use the "an index points between elements" method of thinking about it myself, but one way of describing it which sometimes helps others get it is this:</p>

<pre><code>mylist[X:Y]
</code></pre>

<p>X is the index of the first element you want.<br>
Y is the index of the first element you <em>don't</em> want.</p>
<h4> contactmatt, Comment 132868897 Score: 0: </h4>This is helpful; I had pondered why the ending index (in this case, Y of [X:Y]) was not included. i.e. Why [0:0] would not include the first index.<br>------------------------------------------------------------------ <br><h3> xiaoyu, Id: 14682039, Score: 43: </h3><pre><code>Index:
      ------------&gt;
  0   1   2   3   4
+---+---+---+---+---+
| a | b | c | d | e |
+---+---+---+---+---+
  0  -4  -3  -2  -1
      &lt;------------

Slice:
    &lt;---------------|
|---------------&gt;
:   1   2   3   4   :
+---+---+---+---+---+
| a | b | c | d | e |
+---+---+---+---+---+
:  -4  -3  -2  -1   :
|---------------&gt;
    &lt;---------------|
</code></pre>

<p>I hope this will help you to model the list in Python.</p>

<p>Reference: <a href="http://wiki.python.org/moin/MovingToPythonFromOtherLanguages" rel="noreferrer">http://wiki.python.org/moin/MovingToPythonFromOtherLanguages</a></p>
------------------------------------------------------------------ <br><h3> Brent Bradburn, Id: 16267103, Score: 39: </h3><p>Python slicing notation:</p>

<pre><code>a[start:end:step]
</code></pre>

<ul>
<li>For <code>start</code> and <code>end</code>, negative values are interpreted as being relative to the end of the sequence.</li>
<li>Positive indices for <code>end</code> indicate the position <em>after</em> the last element to be included.</li>
<li>Blank values are defaulted as follows: <code>[+0:-0:1]</code>.</li>
<li>Using a negative step reverses the interpretation of <code>start</code> and <code>end</code></li>
</ul>

<p>The notation extends to (numpy) matrices and multidimensional arrays.  For example, to slice entire columns you can use:</p>

<pre><code>m[::,0:2:] ## slice the first two columns
</code></pre>

<p>Slices hold references, not copies, of the array elements.  If you want to make a separate copy an array, you can use <a href="https://stackoverflow.com/questions/6532881/how-to-make-a-copy-of-a-2d-array-in-python"><code>deepcopy()</code></a>.</p>
------------------------------------------------------------------ <br><h3> Arindam Roychowdhury, Id: 9827284, Score: 34: </h3><p>This is just for some extra info...
Consider the list below </p>

<pre><code>&gt;&gt;&gt; l=[12,23,345,456,67,7,945,467]
</code></pre>

<p>Few other tricks for reversing the list:</p>

<pre><code>&gt;&gt;&gt; l[len(l):-len(l)-1:-1]
[467, 945, 7, 67, 456, 345, 23, 12]

&gt;&gt;&gt; l[:-len(l)-1:-1]
[467, 945, 7, 67, 456, 345, 23, 12]

&gt;&gt;&gt; l[len(l)::-1]
[467, 945, 7, 67, 456, 345, 23, 12]

&gt;&gt;&gt; l[::-1]
[467, 945, 7, 67, 456, 345, 23, 12]

&gt;&gt;&gt; l[-1:-len(l)-1:-1]
[467, 945, 7, 67, 456, 345, 23, 12]
</code></pre>
------------------------------------------------------------------ <br><h3> dansalmo, Id: 15824717, Score: 35: </h3><p>You can also use slice assignment to remove one or more elements from a list:</p>

<pre><code>r = [1, 'blah', 9, 8, 2, 3, 4]
&gt;&gt;&gt; r[1:4] = []
&gt;&gt;&gt; r
[1, 2, 3, 4]
</code></pre>
------------------------------------------------------------------ <br><h3> cizixs, Id: 41548529, Score: 31: </h3><h2>1. Slice Notation</h2>

<p>To make it simple, remember <strong>slice has only one form：</strong></p>

<pre><code>s[start:end:step]
</code></pre>

<p>and here is how it works:</p>

<ul>
<li><code>s</code>: an object that can be sliced</li>
<li><code>start</code>: first index to start iteration</li>
<li><code>end</code>: last index, <strong>NOTE that <code>end</code> index will not be included in the resulted slice</strong></li>
<li><code>step</code>: pick element every <code>step</code> index</li>
</ul>

<p>Another import thing: <strong>all <code>start</code>,<code>end</code>, <code>step</code> can be omitted!</strong> And if they are omitted, their default value will be used: <code>0</code>,<code>len(s)</code>,<code>1</code> accordingly.</p>

<p>So possible variations are:</p>

<pre><code># Mostly used variations
s[start:end]
s[start:]
s[:end]

# Step-related variations
s[:end:step]
s[start::step]
s[::step]

# Make a copy
s[:]
</code></pre>

<p>NOTE: If <code>start &gt;= end</code> (considering only when <code>step&gt;0</code>), Python will return a empty slice <code>[]</code>.</p>

<h2>2. Pitfalls</h2>

<p>The above part explains the core features on how slice works, and it will work on most occasions. However, there can be pitfalls you should watch out, and this part explains them.</p>

<h3>Negative indexes</h3>

<p>The very first thing that confuses Python learners is that <strong>an index can be negative!</strong>
Don't panic: <strong>a negative index means count backwards.</strong></p>

<p>For example:</p>

<pre><code>s[-5:]    # Start at the 5th index from the end of array,
          # thus returning the last 5 elements.
s[:-5]    # Start at index 0, and end until the 5th index from end of array,
          # thus returning s[0:len(s)-5].
</code></pre>

<h3>Negative step</h3>

<p>Making things more confusing is that <strong><code>step</code> can be negative too!</strong></p>

<p><strong>A negative step means iterate the array backwards: from the end to start, with the end index included, and the start index excluded from the result.</strong></p>

<p><strong>NOTE</strong>: when step is negative, the default value for <code>start</code> is <code>len(s)</code> (while <code>end</code> does not equal to <code>0</code>, because <code>s[::-1]</code> contains <code>s[0]</code>). For example:</p>

<pre><code>s[::-1]            # Reversed slice
s[len(s)::-1]      # The same as above, reversed slice
s[0:len(s):-1]     # Empty list
</code></pre>

<h3>Out of range error?</h3>

<p>Be surprised: <strong>slice does not raise an IndexError when the index is out of range!</strong></p>

<p>If the index is out of range, Python will try its best to set the index to <code>0</code> or <code>len(s)</code> according to the situation. For example:</p>

<pre><code>s[:len(s)+5]      # The same as s[:len(s)]
s[-len(s)-5::]    # The same as s[0:]
s[len(s)+5::-1]   # The same as s[len(s)::-1], and the same as s[::-1]
</code></pre>

<h2>3. Examples</h2>

<p>Let's finish this answer with examples, explaining everything we have discussed:</p>

<pre><code># Create our array for demonstration
In [1]: s = [i for i in range(10)]

In [2]: s
Out[2]: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

In [3]: s[2:]   # From index 2 to last index
Out[3]: [2, 3, 4, 5, 6, 7, 8, 9]

In [4]: s[:8]   # From index 0 up to index 8
Out[4]: [0, 1, 2, 3, 4, 5, 6, 7]

In [5]: s[4:7]  # From index 4 (included) up to index 7(excluded)
Out[5]: [4, 5, 6]

In [6]: s[:-2]  # Up to second last index (negative index)
Out[6]: [0, 1, 2, 3, 4, 5, 6, 7]

In [7]: s[-2:]  # From second last index (negative index)
Out[7]: [8, 9]

In [8]: s[::-1] # From last to first in reverse order (negative step)
Out[8]: [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]

In [9]: s[::-2] # All odd numbers in reversed order
Out[9]: [9, 7, 5, 3, 1]

In [11]: s[-2::-2] # All even numbers in reversed order
Out[11]: [8, 6, 4, 2, 0]

In [12]: s[3:15]   # End is out of range, and Python will set it to len(s).
Out[12]: [3, 4, 5, 6, 7, 8, 9]

In [14]: s[5:1]    # Start &gt; end; return empty list
Out[14]: []

In [15]: s[11]     # Access index 11 (greater than len(s)) will raise an IndexError
---------------------------------------------------------------------------
IndexError                                Traceback (most recent call last)
&lt;ipython-input-15-79ffc22473a3&gt; in &lt;module&gt;()
----&gt; 1 s[11]

IndexError: list index out of range
</code></pre>
------------------------------------------------------------------ <br><h3> Python_Dude, Id: 20443928, Score: 29: </h3><p>As a general rule, writing code with a lot of hardcoded index values leads to a readability
and maintenance mess. For example, if you come back to the code a year later, you’ll
look at it and wonder what you were thinking when you wrote it. The solution shown
is simply a way of more clearly stating what your code is actually doing.
In general, the built-in slice() creates a slice object that can be used anywhere a slice
is allowed. For example:</p>

<pre><code>&gt;&gt;&gt; items = [0, 1, 2, 3, 4, 5, 6]
&gt;&gt;&gt; a = slice(2, 4)
&gt;&gt;&gt; items[2:4]
[2, 3]
&gt;&gt;&gt; items[a]
[2, 3]
&gt;&gt;&gt; items[a] = [10,11]
&gt;&gt;&gt; items
[0, 1, 10, 11, 4, 5, 6]
&gt;&gt;&gt; del items[a]
&gt;&gt;&gt; items
[0, 1, 4, 5, 6]
</code></pre>

<p>If you have a slice instance s, you can get more information about it by looking at its
s.start, s.stop, and s.step attributes, respectively. For example:</p>

<blockquote>
<pre><code>&gt;&gt;&gt; a = slice(10, 50, 2)
&gt;&gt;&gt; a.start
10
&gt;&gt;&gt; a.stop
50
&gt;&gt;&gt; a.step
2
&gt;&gt;&gt;
</code></pre>
</blockquote>
------------------------------------------------------------------ <br><h3> Statham, Id: 42522149, Score: 29: </h3><p>The previous answers don't discuss multi-dimensional array slicing which is possible using the famous <a href="http://en.wikipedia.org/wiki/NumPy" rel="noreferrer">NumPy</a> package:</p>

<p><strong>Slicing can also be applied to multi-dimensional arrays.</strong></p>

<pre><code># Here, a is a NumPy array

&gt;&gt;&gt; a
array([[ 1,  2,  3,  4],
       [ 5,  6,  7,  8],
       [ 9, 10, 11, 12]])
&gt;&gt;&gt; a[:2, 0:3:2]
array([[1, 3],
       [5, 7]])
</code></pre>

<p>The "<code>:2</code>" before the comma operates on the first dimension and the "<code>0:3:2</code>" after the comma operates on the second dimension.</p>
<h4> Mars Lee, Comment 100958827 Score: 4: </h4>Just a friendly reminder that you cannot do this on Python <code>list</code> but only on <code>array</code> in Numpy<br>------------------------------------------------------------------ <br><h3> Anshika Singh, Id: 63047385, Score: 20: </h3><h3>The rules of slicing are as follows:</h3>
<pre><code>[lower bound : upper bound : step size]
</code></pre>
<p><strong>I-</strong> Convert <code>upper bound</code>  and <code>lower bound</code> into common signs.</p>
<p><strong>II-</strong> Then check if the <code>step size</code> is a <em>positive</em> or a <em>negative</em> value.</p>
<p><strong>(i)</strong> If the <code>step size</code> is a <strong>positive value</strong>, <code>upper bound</code> should be <strong>greater than</strong> <code>lower bound</code>, otherwise <code>empty string</code> is printed. <em>For example</em>:</p>
<pre><code>s=&quot;Welcome&quot;
s1=s[0:3:1]
print(s1)
</code></pre>
<p>The output:</p>
<pre><code>Wel
</code></pre>
<p>However if we run the following code:</p>
<pre><code>s=&quot;Welcome&quot;
s1=s[3:0:1]
print(s1)
</code></pre>
<p>It will return an <strong>empty string</strong>.</p>
<p><strong>(ii)</strong> If the <code>step size</code> if a <strong>negative value</strong>, <code>upper bound</code> should be <strong>lesser than</strong> <code>lower bound</code>, otherwise <code>empty string</code> will be printed. For example:</p>
<pre><code>s=&quot;Welcome&quot;
s1=s[3:0:-1]
print(s1)
</code></pre>
<p>The output:</p>
<pre><code>cle
</code></pre>
<p>But if we run the following code:</p>
<pre><code>s=&quot;Welcome&quot;
s1=s[0:5:-1]
print(s1)
</code></pre>
<p>The output will be an <strong>empty string</strong>.</p>
<p>Thus in the code:</p>
<pre><code>str = 'abcd'
l = len(str)
str2 = str[l-1:0:-1]    #str[3:0:-1] 
print(str2)
str2 = str[l-1:-1:-1]    #str[3:-1:-1]
print(str2)
</code></pre>
<p>In the first <code>str2=str[l-1:0:-1]</code>, the <code>upper bound</code> is <strong>lesser than</strong> the <code>lower bound</code>, thus <code>dcb</code> is printed.</p>
<p>However in <code>str2=str[l-1:-1:-1]</code>, the <code>upper bound</code> is <strong>not less than</strong> the <code>lower bound</code> (upon converting <code>lower bound</code> into <strong>negative value</strong> which is <code>-1</code>: since <code>index</code> of last element is -1 as well as 3).</p>
------------------------------------------------------------------ <br><h3> asiby, Id: 47765245, Score: 18: </h3><p>In my opinion, you will understand and memorize better the Python string slicing notation if you look at it the following way (read on).</p>

<p>Let's work with the following string ...</p>

<pre><code>azString = "abcdefghijklmnopqrstuvwxyz"
</code></pre>

<p>For those who don't know, you can create any substring from <code>azString</code> using the notation <code>azString[x:y]</code></p>

<p>Coming from other programming languages, that's when the common sense gets compromised. What are x and y?</p>

<p>I had to sit down and run several scenarios in my quest for a memorization technique that will help me remember what x and y are and help me slice strings properly at the first attempt.</p>

<p>My conclusion is that x and y should be seen as the boundary indexes that are surrounding the strings that we want to extra. So we should see the expression as <code>azString[index1, index2]</code> or even more clearer as <code>azString[index_of_first_character, index_after_the_last_character]</code>.</p>

<p>Here is an example visualization of that ...</p>

<pre class="lang-none prettyprint-override"><code>Letters   a b c d e f g h i j ...
         ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑
             ┊           ┊
Indexes  0 1 2 3 4 5 6 7 8 9 ...
             ┊           ┊
cdefgh    index1       index2
</code></pre>

<p>So all you have to do is setting index1 and index2 to the values that will surround the desired substring. For instance, to get the substring "cdefgh", you can use <code>azString[2:8]</code>, because the index on the left side of "c" is 2 and the one on the right size of "h" is 8.</p>

<p>Remember that we are setting the boundaries. And those boundaries are the positions where you could place some brackets that will be wrapped around the substring like this ...</p>

<p>a b <strong>[</strong> c d e f g h <strong>]</strong> i j</p>

<p>That trick works all the time and is easy to memorize.</p>
------------------------------------------------------------------ <br><h3> Raman, Id: 57628026, Score: 18: </h3><p>I personally think about it like a <code>for</code> loop:</p>

<pre><code>a[start:end:step]
# for(i = start; i &lt; end; i += step)
</code></pre>

<p>Also, note that negative values for <code>start</code> and <code>end</code> are relative to the end of the list and computed in the example above by <code>given_index + a.shape[0]</code>.</p>
------------------------------------------------------------------ <br><h3> mahmoh, Id: 26442691, Score: 17: </h3><pre><code>#!/usr/bin/env python

def slicegraphical(s, lista):

    if len(s) &gt; 9:
        print """Enter a string of maximum 9 characters,
    so the printig would looki nice"""
        return 0;
    # print " ",
    print '  '+'+---' * len(s) +'+'
    print ' ',
    for letter in s:
        print '| {}'.format(letter),
    print '|'
    print " ",; print '+---' * len(s) +'+'

    print " ",
    for letter in range(len(s) +1):
        print '{}  '.format(letter),
    print ""
    for letter in range(-1*(len(s)), 0):
        print ' {}'.format(letter),
    print ''
    print ''


    for triada in lista:
        if len(triada) == 3:
            if triada[0]==None and triada[1] == None and triada[2] == None:
                # 000
                print s+'[   :   :   ]' +' = ', s[triada[0]:triada[1]:triada[2]]
            elif triada[0] == None and triada[1] == None and triada[2] != None:
                # 001
                print s+'[   :   :{0:2d} ]'.format(triada[2], '','') +' = ', s[triada[0]:triada[1]:triada[2]]
            elif triada[0] == None and triada[1] != None and triada[2] == None:
                # 010
                print s+'[   :{0:2d} :   ]'.format(triada[1]) +' = ', s[triada[0]:triada[1]:triada[2]]
            elif triada[0] == None and triada[1] != None and triada[2] != None:
                # 011
                print s+'[   :{0:2d} :{1:2d} ]'.format(triada[1], triada[2]) +' = ', s[triada[0]:triada[1]:triada[2]]
            elif triada[0] != None and triada[1] == None and triada[2] == None:
                # 100
                print s+'[{0:2d} :   :   ]'.format(triada[0]) +' = ', s[triada[0]:triada[1]:triada[2]]
            elif triada[0] != None and triada[1] == None and triada[2] != None:
                # 101
                print s+'[{0:2d} :   :{1:2d} ]'.format(triada[0], triada[2]) +' = ', s[triada[0]:triada[1]:triada[2]]
            elif triada[0] != None and triada[1] != None and triada[2] == None:
                # 110
                print s+'[{0:2d} :{1:2d} :   ]'.format(triada[0], triada[1]) +' = ', s[triada[0]:triada[1]:triada[2]]
            elif triada[0] != None and triada[1] != None and triada[2] != None:
                # 111
                print s+'[{0:2d} :{1:2d} :{2:2d} ]'.format(triada[0], triada[1], triada[2]) +' = ', s[triada[0]:triada[1]:triada[2]]

        elif len(triada) == 2:
            if triada[0] == None and triada[1] == None:
                # 00
                print s+'[   :   ]    ' + ' = ', s[triada[0]:triada[1]]
            elif triada[0] == None and triada[1] != None:
                # 01
                print s+'[   :{0:2d} ]    '.format(triada[1]) + ' = ', s[triada[0]:triada[1]]
            elif triada[0] != None and triada[1] == None:
                # 10
                print s+'[{0:2d} :   ]    '.format(triada[0]) + ' = ', s[triada[0]:triada[1]]
            elif triada[0] != None and triada[1] != None:
                # 11
                print s+'[{0:2d} :{1:2d} ]    '.format(triada[0],triada[1]) + ' = ', s[triada[0]:triada[1]]

        elif len(triada) == 1:
            print s+'[{0:2d} ]        '.format(triada[0]) + ' = ', s[triada[0]]


if __name__ == '__main__':
    # Change "s" to what ever string you like, make it 9 characters for
    # better representation.
    s = 'COMPUTERS'

    # add to this list different lists to experement with indexes
    # to represent ex. s[::], use s[None, None,None], otherwise you get an error
    # for s[2:] use s[2:None]

    lista = [[4,7],[2,5,2],[-5,1,-1],[4],[-4,-6,-1], [2,-3,1],[2,-3,-1], [None,None,-1],[-5,None],[-5,0,-1],[-5,None,-1],[-1,1,-2]]

    slicegraphical(s, lista)
</code></pre>

<p>You can run this script and experiment with it, below is some samples that I got from the script.</p>

<pre><code>  +---+---+---+---+---+---+---+---+---+
  | C | O | M | P | U | T | E | R | S |
  +---+---+---+---+---+---+---+---+---+
  0   1   2   3   4   5   6   7   8   9   
 -9  -8  -7  -6  -5  -4  -3  -2  -1 

COMPUTERS[ 4 : 7 ]     =  UTE
COMPUTERS[ 2 : 5 : 2 ] =  MU
COMPUTERS[-5 : 1 :-1 ] =  UPM
COMPUTERS[ 4 ]         =  U
COMPUTERS[-4 :-6 :-1 ] =  TU
COMPUTERS[ 2 :-3 : 1 ] =  MPUT
COMPUTERS[ 2 :-3 :-1 ] =  
COMPUTERS[   :   :-1 ] =  SRETUPMOC
COMPUTERS[-5 :   ]     =  UTERS
COMPUTERS[-5 : 0 :-1 ] =  UPMO
COMPUTERS[-5 :   :-1 ] =  UPMOC
COMPUTERS[-1 : 1 :-2 ] =  SEUM
[Finished in 0.9s]
</code></pre>

<p>When using a negative step, notice that the answer is shifted to the right by 1.</p>
------------------------------------------------------------------ <br><h3> Robert, Id: 37455246, Score: 14: </h3><p>My brain seems happy to accept that <code>lst[start:end]</code> contains the <code>start</code>-th item. I might even say that it is a 'natural assumption'.</p>

<p>But occasionally a doubt creeps in and my brain asks for reassurance that it does not contain the <code>end</code>-th element.</p>

<p>In these moments I rely on this simple theorem:</p>

<pre><code>for any n,    lst = lst[:n] + lst[n:]
</code></pre>

<p>This pretty property tells me that <code>lst[start:end]</code> does not contain the <code>end</code>-th item because it is in <code>lst[end:]</code>.</p>

<p>Note that this theorem is true for any <code>n</code> at all. For example, you can check that</p>

<pre><code>lst = range(10)
lst[:-42] + lst[-42:] == lst
</code></pre>

<p>returns <code>True</code>.</p>
------------------------------------------------------------------ <br><h3> lmiguelvargasf, Id: 46040689, Score: 13: </h3><p>In Python, the most basic form for slicing is the following:</p>

<pre><code>l[start:end]
</code></pre>

<p>where <code>l</code> is some collection, <code>start</code> is an inclusive index, and <code>end</code> is an exclusive index.</p>

<pre><code>In [1]: l = list(range(10))

In [2]: l[:5] # First five elements
Out[2]: [0, 1, 2, 3, 4]

In [3]: l[-5:] # Last five elements
Out[3]: [5, 6, 7, 8, 9]
</code></pre>

<p>When slicing from the start, you can omit the zero index, and when slicing to the end, you can omit the final index since it is redundant, so do not be verbose:</p>

<pre><code>In [5]: l[:3] == l[0:3]
Out[5]: True

In [6]: l[7:] == l[7:len(l)]
Out[6]: True
</code></pre>

<p>Negative integers are useful when doing offsets relative to the end of a collection:</p>

<pre><code>In [7]: l[:-1] # Include all elements but the last one
Out[7]: [0, 1, 2, 3, 4, 5, 6, 7, 8]

In [8]: l[-3:] # Take the last three elements
Out[8]: [7, 8, 9]
</code></pre>

<p>It is possible to provide indices that are out of bounds when slicing such as:</p>

<pre><code>In [9]: l[:20] # 20 is out of index bounds, and l[20] will raise an IndexError exception
Out[9]: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

In [11]: l[-20:] # -20 is out of index bounds, and l[-20] will raise an IndexError exception
Out[11]: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
</code></pre>

<p>Keep in mind that the result of slicing a collection is a whole new collection. In addition, when using slice notation in assignments, the length of the slice assignments do not need to be the same. The values before and after the assigned slice will be kept, and the collection will shrink or grow to contain the new values:</p>

<pre><code>In [16]: l[2:6] = list('abc') # Assigning fewer elements than the ones contained in the sliced collection l[2:6]

In [17]: l
Out[17]: [0, 1, 'a', 'b', 'c', 6, 7, 8, 9]

In [18]: l[2:5] = list('hello') # Assigning more elements than the ones contained in the sliced collection l [2:5]

In [19]: l
Out[19]: [0, 1, 'h', 'e', 'l', 'l', 'o', 6, 7, 8, 9]
</code></pre>

<p>If you omit the start and end index, you will make a copy of the collection:</p>

<pre><code>In [14]: l_copy = l[:]

In [15]: l == l_copy and l is not l_copy
Out[15]: True
</code></pre>

<p>If the start and end indexes are omitted when performing an assignment operation, the entire content of the collection will be replaced with a copy of what is referenced:</p>

<pre><code>In [20]: l[:] = list('hello...')

In [21]: l
Out[21]: ['h', 'e', 'l', 'l', 'o', '.', '.', '.']
</code></pre>

<p>Besides basic slicing, it is also possible to apply the following notation:</p>

<pre><code>l[start:end:step]
</code></pre>

<p>where <code>l</code> is a collection, <code>start</code> is an inclusive index, <code>end</code> is an exclusive index, and <code>step</code> is a stride that can be used to take every <em>nth</em> item in <code>l</code>.</p>

<pre><code>In [22]: l = list(range(10))

In [23]: l[::2] # Take the elements which indexes are even
Out[23]: [0, 2, 4, 6, 8]

In [24]: l[1::2] # Take the elements which indexes are odd
Out[24]: [1, 3, 5, 7, 9]
</code></pre>

<p>Using <code>step</code> provides a useful trick to reverse a collection in Python:</p>

<pre><code>In [25]: l[::-1]
Out[25]: [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]
</code></pre>

<p>It is also possible to use negative integers for <code>step</code> as the following example:</p>

<pre><code>In[28]:  l[::-2]
Out[28]: [9, 7, 5, 3, 1]
</code></pre>

<p>However, using a negative value for <code>step</code> could become very confusing. Moreover, in order to be <a href="https://en.wiktionary.org/wiki/Pythonic#Adjective" rel="nofollow noreferrer">Pythonic</a>, you should avoid using <code>start</code>, <code>end</code>, and <code>step</code> in a single slice. In case this is required, consider doing this in two assignments (one to slice, and the other to stride).</p>

<pre><code>In [29]: l = l[::2] # This step is for striding

In [30]: l
Out[30]: [0, 2, 4, 6, 8]

In [31]: l = l[1:-1] # This step is for slicing

In [32]: l
Out[32]: [2, 4, 6]
</code></pre>
------------------------------------------------------------------ <br><h3> Jeyekomon, Id: 49647978, Score: 12: </h3><p>I want to add one <em>Hello, World!</em> example that explains the basics of slices for the very beginners. It helped me a lot.</p>

<p>Let's have a list with six values <code>['P', 'Y', 'T', 'H', 'O', 'N']</code>:</p>

<pre><code>+---+---+---+---+---+---+
| P | Y | T | H | O | N |
+---+---+---+---+---+---+
  0   1   2   3   4   5
</code></pre>

<p>Now the simplest slices of that list are its sublists. The notation is <code>[&lt;index&gt;:&lt;index&gt;]</code> and the key is to read it like this:</p>

<pre><code>[ start cutting before this index : end cutting before this index ]
</code></pre>

<p>Now if you make a slice <code>[2:5]</code> of the list above, this will happen:</p>

<pre><code>        |           |
+---+---|---+---+---|---+
| P | Y | T | H | O | N |
+---+---|---+---+---|---+
  0   1 | 2   3   4 | 5
</code></pre>

<p>You made a cut <strong>before</strong> the element with index <code>2</code> and another cut <strong>before</strong> the element with index <code>5</code>. So the result will be a slice between those two cuts, a list <code>['T', 'H', 'O']</code>.</p>
------------------------------------------------------------------ <br><h3> Roshan Bagdiya, Id: 46614773, Score: 11: </h3><p>Most of the previous answers clears up questions about slice notation.</p>

<p>The extended indexing syntax used for slicing is <code>aList[start:stop:step]</code>, and basic examples are:</p>

<p><a href="https://i.stack.imgur.com/IVkET.jpg" rel="nofollow noreferrer"><img src="https://i.stack.imgur.com/IVkET.jpg" alt="Enter image description here"></a>:</p>

<p>More slicing examples: <a href="https://docs.python.org/2.3/whatsnew/section-slices.html" rel="nofollow noreferrer">15 Extended Slices</a></p>
------------------------------------------------------------------ <br><h3> Prince Dhadwal, Id: 45370737, Score: 9: </h3><p>The below is the example of an index of a string:</p>

<pre><code> +---+---+---+---+---+
 | H | e | l | p | A |
 +---+---+---+---+---+
 0   1   2   3   4   5
-5  -4  -3  -2  -1

str="Name string"
</code></pre>

<p>Slicing example: [start:end:step]</p>

<pre><code>str[start:end] # Items start through end-1
str[start:]    # Items start through the rest of the array
str[:end]      # Items from the beginning through end-1
str[:]         # A copy of the whole array
</code></pre>

<p>Below is the example usage:</p>

<pre><code>print str[0] = N
print str[0:2] = Na
print str[0:7] = Name st
print str[0:7:2] = Nm t
print str[0:-1:2] = Nm ti
</code></pre>
------------------------------------------------------------------ <br><h3> G&#233;ry Ogam, Id: 71640042, Score: 9: </h3><p>The important idea to remember about indices of a sequence is that</p>
<ul>
<li><em>nonnegative</em> indices begin at the <em>first</em> item in the sequence;</li>
<li><em>negative</em> indices begin at the <em>last</em> item in the sequence (so only apply to finite sequences).</li>
</ul>
<p>In other words, negative indices are shifted right by the length of the sequence:</p>
<pre class="lang-none prettyprint-override"><code>              0   1   2   3   4   5   6   7   ...
            -------------------------
            | a | b | c | d | e | f |
            -------------------------
...  -8  -7  -6  -5  -4  -3  -2  -1
</code></pre>
<p>With that in mind, <a href="https://docs.python.org/3/reference/expressions.html#subscriptions" rel="nofollow noreferrer">subscription</a> and <a href="https://docs.python.org/3/reference/expressions.html#slicings" rel="nofollow noreferrer">slicing</a> are straightforward.</p>
<h3>Subscription</h3>
<p>Subscription uses the following syntax:*</p>
<pre class="lang-py prettyprint-override"><code>sequence[index]
</code></pre>
<p>Subscription selects a single item in the <code>sequence</code> at <code>index</code>:</p>
<pre class="lang-none prettyprint-override"><code>&gt;&gt;&gt; 'abcdef'[0]
'a'
&gt;&gt;&gt; 'abcdef'[-6]
'a'
</code></pre>
<p>Subscription raises an <code>IndexError</code> if <code>index</code> is out of range:</p>
<pre class="lang-none prettyprint-override"><code>&gt;&gt;&gt; 'abcdef'[7]
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
IndexError: string index out of range
&gt;&gt;&gt; 'abcdef'[-7]
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
IndexError: string index out of range
</code></pre>
<h3>Slicing</h3>
<p>Slicing uses the following syntax:**</p>
<pre class="lang-py prettyprint-override"><code>sequence[start:stop:step]
</code></pre>
<p>Slicing selects a range of items in the <code>sequence</code>, beginning at <code>start</code> <em>inclusive</em> and ending at <code>stop</code> <em>exclusive</em>:</p>
<pre class="lang-none prettyprint-override"><code>&gt;&gt;&gt; 'abcdef'[0:2:1]
'ab'
&gt;&gt;&gt; 'abcdef'[0:-4:1]
'ab'
&gt;&gt;&gt; 'abcdef'[-6:-4:1]
'ab'
&gt;&gt;&gt; 'abcdef'[-6:2:1]
'ab'
&gt;&gt;&gt; 'abcdef'[1:-7:-1]
'ba'
&gt;&gt;&gt; 'abcdef'[-5:-7:-1]
'ba'
</code></pre>
<p>Slicing defaults to the <em>fullest</em> range of items in the <code>sequence</code>, so it uses the following default values if <code>start</code>, <code>stop</code>, or <code>step</code> is omitted or <code>None</code>:***</p>
<ul>
<li><code>step</code> defaults to <code>1</code>;</li>
<li>if <code>step</code> is positive
<ul>
<li><code>start</code> defaults to <code>0</code> (first item index),</li>
<li><code>stop</code> defaults to <code>start + len(sequence)</code> (last item index plus one);</li>
</ul>
</li>
<li>if <code>step</code> is negative
<ul>
<li><code>start</code> defaults to <code>-1</code> (last item index),</li>
<li><code>stop</code> defaults to <code>start - len(sequence)</code> (first item index minus one).</li>
</ul>
</li>
</ul>
<pre class="lang-none prettyprint-override"><code>&gt;&gt;&gt; 'abcdef'[0:6:1]
'abcdef'
&gt;&gt;&gt; 'abcdef'[::]
'abcdef'
&gt;&gt;&gt; 'abcdef'[-1:-7:-1]
'fedcba'
&gt;&gt;&gt; 'abcdef'[::-1]
'fedcba'
</code></pre>
<p>Slicing raises a <code>ValueError</code> if <code>step</code> is <code>0</code>:</p>
<pre class="lang-none prettyprint-override"><code>&gt;&gt;&gt; 'abcdef'[::0]
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
ValueError: slice step cannot be zero
</code></pre>
<p>Slicing does not raise an <code>IndexError</code> if <code>start</code> or <code>stop</code> is out of range (contrary to subscription):</p>
<pre class="lang-none prettyprint-override"><code>&gt;&gt;&gt; 'abcdef'[-7:7]
'abcdef'
</code></pre>
<hr />
<p>* The expressions <code>sequence[index]</code> and <code>sequence.__getitem__(index)</code> are equivalent.</p>
<p>** The expressions <code>sequence[start:stop:step]</code>, <code>sequence[slice(start, stop, step)]</code>, and <code>sequence.__getitem__(slice(start, stop, step))</code> are equivalent, where the <a href="https://docs.python.org/3/library/functions.html#slice" rel="nofollow noreferrer">built-in class <code>slice</code></a> instance packs <code>start</code>, <code>stop</code>, and <code>step</code>.</p>
<p>*** The expressions <code>sequence[:]</code>, <code>sequence[::]</code>, and <code>sequence[None:None:None]</code> use default values for <code>start</code>, <code>stop</code>, and <code>step</code>.</p>
------------------------------------------------------------------ <br><h3> Shital Shah, Id: 47880987, Score: 8: </h3><p>If you feel negative indices in slicing is confusing, here's a very easy way to think about it: just replace the negative index with <code>len - index</code>. So for example, replace -3 with <code>len(list) - 3</code>.</p>

<p>The best way to illustrate what slicing does internally is just show it in code that implements this operation:</p>

<pre><code>def slice(list, start = None, end = None, step = 1):
  # Take care of missing start/end parameters
  start = 0 if start is None else start
  end = len(list) if end is None else end

  # Take care of negative start/end parameters
  start = len(list) + start if start &lt; 0 else start
  end = len(list) + end if end &lt; 0 else end

  # Now just execute a for-loop with start, end and step
  return [list[i] for i in range(start, end, step)]
</code></pre>
------------------------------------------------------------------ <br><h3> aguadopd, Id: 56332104, Score: 8: </h3><p>I don't think that the <a href="https://docs.python.org/3/tutorial/introduction.html#strings" rel="noreferrer">Python tutorial</a> diagram (cited in various other answers) is good as this suggestion works for positive stride, but does not for a negative stride.</p>

<p>This is the diagram:</p>

<pre><code> +---+---+---+---+---+---+
 | P | y | t | h | o | n |
 +---+---+---+---+---+---+
 0   1   2   3   4   5   6
-6  -5  -4  -3  -2  -1

</code></pre>

<p>From the diagram, I expect <code>a[-4,-6,-1]</code> to be <code>yP</code> but it is <code>ty</code>.</p>

<pre class="lang-py prettyprint-override"><code>&gt;&gt;&gt; a = "Python"
&gt;&gt;&gt; a[2:4:1] # as expected
'th'
&gt;&gt;&gt; a[-4:-6:-1] # off by 1
'ty'
</code></pre>

<p>What always work is to think in characters or slots and use indexing as a half-open interval -- right-open if positive stride, left-open if negative stride.</p>

<p>This way, I can think of <code>a[-4:-6:-1]</code> as <code>a(-6,-4]</code> in interval terminology.</p>

<pre><code> +---+---+---+---+---+---+
 | P | y | t | h | o | n |
 +---+---+---+---+---+---+
   0   1   2   3   4   5  
  -6  -5  -4  -3  -2  -1

 +---+---+---+---+---+---+---+---+---+---+---+---+
 | P | y | t | h | o | n | P | y | t | h | o | n |
 +---+---+---+---+---+---+---+---+---+---+---+---+
  -6  -5  -4  -3  -2  -1   0   1   2   3   4   5  
</code></pre>
<h4> CoolHandLouis, Comment 124872981 Score: 1: </h4>As a newbie, this is an interesting way of thinking about it.  However, the last example, counting from -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5 is a bit misleading because the string is NOT doubled like that.  Furthermore, one can refer to the positive and negate positions like the following: a[-4:-6:-1] is the same as a[-4:0:-1] since the 0th position is the same as the -6th position.  So I would just delete/ignore that example.<br><h4> aguadopd, Comment 120967561 Score: 0: </h4>Used today 2021/07/19 by myself, qu&#233; capo aguadopd del pasado<br>------------------------------------------------------------------ <br><h3> Babu Chandermani, Id: 51479594, Score: 7: </h3><p>The basic slicing technique is to define the starting point, the stopping point, and the step size—also known as stride.</p>
<p>First, we will create a list of values to use in our slicing.</p>
<p>Create two lists to slice. The first is a numeric list from 1 to 9 (List A). The second is also a numeric list, from 0 to 9 (List B):</p>
<pre><code>A = list(range(1, 10, 1)) # Start, stop, and step
B = list(range(9))

print(&quot;This is List A:&quot;, A)
print(&quot;This is List B:&quot;, B)
</code></pre>
<p>Index the number 3 from A and the number 6 from B.</p>
<pre><code>print(A[2])
print(B[6])
</code></pre>
<h3>Basic Slicing</h3>
<p>Extended indexing syntax used for slicing is <code>aList[start:stop:step]</code>. The start argument and the step argument both default to <code>None</code>—the only required argument is stop. Did you notice this is similar to how range was used to define lists A and B? This is because the slice object represents the set of indices specified by <code>range(start, stop, step)</code>.</p>
<p>As you can see, defining only stop returns one element. Since the start defaults to none, this translates into retrieving only one element.</p>
<p>It is important to note, the first element is index 0, <em>not</em> index 1. This is why we are using 2 lists for this exercise. List A's elements are numbered according to the ordinal position (the first element is 1, the second element is 2, etc.) while List B's elements are the numbers that would be used to index them (<code>[0]</code> for the first element, 0, etc.).</p>
<p>With extended indexing syntax, we retrieve a range of values. For example, all values are retrieved with a colon.</p>
<pre><code>A[:]
</code></pre>
<p>To retrieve a subset of elements, the start and stop positions need to be defined.</p>
<p>Given the pattern <code>aList[start:stop]</code>, retrieve the first two elements from List A.</p>
------------------------------------------------------------------ <br><h3> H.Elci, Id: 75061865, Score: 5: </h3><blockquote>
<p>For <strong>simple way</strong> and <strong>simple understandable</strong>:</p>
</blockquote>
<p>In Python, the slice notation <strong><code>a[start:stop:step]</code></strong> can be used to select a range of elements from a sequence (such as a list, tuple, or string).</p>
<p>The <strong><code>start</code></strong> index is the first element that is included in the slice,</p>
<p>The <strong><code>stop</code></strong> index is the first element that is excluded from the slice, and last one</p>
<p>The <strong><code>step</code></strong> value is the number of indices between slice elements.</p>
<p>For example, consider the following list:</p>
<pre><code>a = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
</code></pre>
<p>If we want to select all elements of <strong><code>a</code></strong>, we can use the slice notation <strong><code>a[:]:</code></strong></p>
<pre><code>&gt;&gt;&gt; a[:]
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
</code></pre>
<p>If we want to select all elements of <strong><code>a</code></strong>, but skip every other element, we can use the slice notation <strong><code>a[::2]:</code></strong></p>
<pre><code>&gt;&gt;&gt; a[::2]
[0, 2, 4, 6, 8]
</code></pre>
<p>If we want to select all elements from the third element (index 2) to the seventh element (index 6), we can use the slice notation <strong><code>a[2:7]</code></strong>:</p>
<pre><code>&gt;&gt;&gt; a[2:7]
[2, 3, 4, 5, 6]
</code></pre>
<p>If we want to select all elements from the third element (index 2) to the seventh element (index 6), but skip every other element, we can use the slice notation <strong><code>a[2:7:2]</code></strong>:</p>
<pre><code>&gt;&gt;&gt; a[2:7:2]
[2, 4, 6]
</code></pre>
<p>If we want to select all elements from the third element (index 2) to the end of the list, we can use the slice notation <strong><code>a[2:]</code></strong>:</p>
<pre><code>&gt;&gt;&gt; a[2:]
[2, 3, 4, 5, 6, 7, 8, 9]
</code></pre>
<p>If we want to select all elements from the beginning of the list to the seventh element (index 6), we can use the slice notation <strong><code>a[:7]</code></strong>:</p>
<pre><code>&gt;&gt;&gt; a[:7]
[0, 1, 2, 3, 4, 5, 6]
</code></pre>
<p>If you want to learn more about slice notation, you can refer to the official <strong>Python documentation</strong>:
<a href="https://docs.python.org/3/library/functions.html#slice" rel="noreferrer">Link 1</a> <a href="https://docs.python.org/3/library/stdtypes.html#sequence-types-list-tuple-range" rel="noreferrer">Link 2</a></p>
------------------------------------------------------------------ <br><h3> grbruns, Id: 56591541, Score: 4: </h3><p>I got a little frustrated in not finding an online source, or Python documentation that describes precisely what slicing does.</p>
<p>I took Aaron Hall's suggestion, read the relevant parts of the CPython source code, and wrote some Python code that performs slicing similarly to how it's done in CPython. I've tested my code in Python 3 on millions of random tests on integer lists.</p>
<p>You may find the references in my code to the relevant functions in CPython helpful.</p>
<pre><code>def slicer(x, start=None, stop=None, step=None):
    &quot;&quot;&quot; Return the result of slicing list x.  

    See the part of list_subscript() in listobject.c that pertains 
    to when the indexing item is a PySliceObject.
    &quot;&quot;&quot;

    # Handle slicing index values of None, and a step value of 0.
    # See PySlice_Unpack() in sliceobject.c, which
    # extracts start, stop, step from a PySliceObject.
    maxint = 10000000       # A hack to simulate PY_SSIZE_T_MAX
    if step is None:
        step = 1
    elif step == 0:
        raise ValueError('slice step cannot be zero')

    if start is None:
        start = maxint if step &lt; 0 else 0
    if stop is None:
        stop = -maxint if step &lt; 0 else maxint

    # Handle negative slice indexes and bad slice indexes.
    # Compute number of elements in the slice as slice_length.
    # See PySlice_AdjustIndices() in sliceobject.c
    length = len(x)
    slice_length = 0

    if start &lt; 0:
        start += length
        if start &lt; 0:
            start = -1 if step &lt; 0 else 0
    elif start &gt;= length:
        start = length - 1 if step &lt; 0 else length

    if stop &lt; 0:
        stop += length
        if stop &lt; 0:
            stop = -1 if step &lt; 0 else 0
    elif stop &gt; length:
        stop = length - 1 if step &lt; 0 else length

    if step &lt; 0:
        if stop &lt; start:
            slice_length = (start - stop - 1) // (-step) + 1
    else:
        if start &lt; stop:
            slice_length = (stop - start - 1) // step + 1

    # Cases of step = 1 and step != 1 are treated separately
    if slice_length &lt;= 0:
        return []
    elif step == 1:
        # See list_slice() in listobject.c
        result = []
        for i in range(stop - start):
            result.append(x[i+start])
        return result
    else:
        result = []
        cur = start
        for i in range(slice_length):
            result.append(x[cur])
            cur += step
        return result
</code></pre>
<h4> Andy, Comment 118125881 Score: 0: </h4>I read all the relevant documents and found that there was no description of this syntax. I doubted my ability and felt relieved after seeing this answer. Maybe there was none.<br>------------------------------------------------------------------ <br><h3> Banghua Zhao, Id: 53953716, Score: 2: </h3><p>It is easy to understand if we could relate slicing to <code>range</code>, which gives the indexes. We can categorize slicing into the following two categories:</p>

<hr>

<h2>1. No step or step > 0. For example, <code>[i:j]</code> or <code>[i:j:k]</code> (k>0)</h2>

<p>Suppose the sequence is <code>s=[1,2,3,4,5]</code>.</p>

<ul>
<li>if <code>0&lt;i&lt;len(s)</code> and <code>0&lt;j&lt;len(s)</code>, then <code>[i:j:k] -&gt; range(i,j,k)</code></li>
</ul>

<p>For example, <code>[0:3:2] -&gt; range(0,3,2) -&gt; 0, 2</code></p>

<ul>
<li>if <code>i&gt;len(s)</code> or <code>j&gt;len(s)</code>, then <code>i=len(s)</code> or <code>j=len(s)</code></li>
</ul>

<p>For example, <code>[0:100:2] -&gt; range(0,len(s),2) -&gt; range(0,5,2) -&gt; 0, 2, 4</code></p>

<ul>
<li>if <code>i&lt;0</code> or <code>j&lt;0</code>, then <code>i=max(0,len(s)+i)</code> or <code>j=max(0,len(s)+j)</code></li>
</ul>

<p>For example, <code>[0:-3:2] -&gt; range(0,len(s)-3,2) -&gt; range(0,2,2) -&gt; 0</code></p>

<p>For another example, <code>[0:-1:2] -&gt; range(0,len(s)-1,2) -&gt; range(0,4,2) -&gt; 0, 2</code></p>

<ul>
<li>if <code>i</code> is not specified, then <code>i=0</code></li>
</ul>

<p>For example, <code>[:4:2] -&gt; range(0,4,2) -&gt; range(0,4,2) -&gt; 0, 2</code></p>

<ul>
<li>if <code>j</code> is not specified, then <code>j=len(s)</code></li>
</ul>

<p>For example, <code>[0::2] -&gt; range(0,len(s),2) -&gt; range(0,5,2) -&gt; 0, 2, 4</code></p>

<hr>

<h2>2. Step &lt; 0. For example, <code>[i:j:k]</code> (k&lt;0)</h2>

<p>Suppose the sequence is <code>s=[1,2,3,4,5]</code>.</p>

<ul>
<li>if <code>0&lt;i&lt;len(s)</code> and <code>0&lt;j&lt;len(s)</code>, then <code>[i:j:k] -&gt; range(i,j,k)</code></li>
</ul>

<p>For example, <code>[5:0:-2] -&gt; range(5,0,-2) -&gt; 5, 3, 1</code></p>

<ul>
<li>if <code>i&gt;len(s)</code> or <code>j&gt;len(s)</code>, then <code>i=len(s)-1</code> or <code>j=len(s)-1</code></li>
</ul>

<p>For example, <code>[100:0:-2] -&gt; range(len(s)-1,0,-2) -&gt; range(4,0,-2) -&gt; 4, 2</code></p>

<ul>
<li>if <code>i&lt;0</code> or <code>j&lt;0</code>, then <code>i=max(-1,len(s)+i)</code> or <code>j=max(-1,len(s)+j)</code></li>
</ul>

<p>For example, <code>[-2:-10:-2] -&gt; range(len(s)-2,-1,-2) -&gt; range(3,-1,-2) -&gt; 3, 1</code></p>

<ul>
<li>if <code>i</code> is not specified, then <code>i=len(s)-1</code></li>
</ul>

<p>For example, <code>[:0:-2] -&gt; range(len(s)-1,0,-2) -&gt; range(4,0,-2) -&gt; 4, 2</code></p>

<ul>
<li>if <code>j</code> is not specified, then <code>j=-1</code></li>
</ul>

<p>For example, <code>[2::-2] -&gt; range(2,-1,-2) -&gt; 2, 0</code></p>

<p>For another example, <code>[::-1] -&gt; range(len(s)-1,-1,-1) -&gt; range(4,-1,-1) -&gt; 4, 3, 2, 1, 0</code></p>

<hr>

<h2>In summary</h2>

<p><a href="https://i.stack.imgur.com/4DLrK.png" rel="nofollow noreferrer"><img src="https://i.stack.imgur.com/4DLrK.png" alt="enter image description here"></a></p>
------------------------------------------------------------------ <br><h3> Kyle Meador, Id: 72372369, Score: 1: </h3><p>There are lots of answers already, but I wanted to add a performance comparison:</p>
<pre class="lang-none prettyprint-override"><code>python3.8 -m timeit -s 'fun = &quot;this is fun;slicer = slice(0, 3)&quot;' &quot;fun_slice = fun[slicer]&quot;
10000000 loops, best of 5: 29.8 nsec per loop

python3.8 -m timeit -s 'fun = &quot;this is fun&quot;' &quot;fun_slice = fun[0:3]&quot;
10000000 loops, best of 5: 37.9 nsec per loop

python3.8 -m timeit -s 'fun = &quot;this is fun&quot;' &quot;fun_slice = fun[slice(0, 3)]&quot;
5000000 loops, best of 5: 68.7 nsec per loop

python3.8 -m timeit -s 'fun = &quot;this is fun&quot;' &quot;slicer = slice(0, 3)&quot;
5000000 loops, best of 5: 42.8 nsec per loop
</code></pre>
<p>So, if you are using the same slice repeatedly, it would be beneficial and improve readability to use a slice object. However, if you are slicing only a handful of times, the <code>[:]</code> notation should be preferred.</p>
------------------------------------------------------------------ <br><h3> My Car, Id: 74979870, Score: 1: </h3><p>You can use slice syntax to return a sequence of characters.</p>
<p>Specify a start and end index, separated by colons, to return part of the string.</p>
<p>Example:</p>
<p>Get the characters from position 2 to position 5 (not included):</p>
<pre><code>b = &quot;Hello, World!&quot;
print(b[2:5])
</code></pre>
<p>Slice From the Start</p>
<p>By omitting the starting index, the range will start from the first character:</p>
<p>Example:</p>
<p>Get the characters from the start to position 5 (not included):</p>
<pre><code>b = &quot;Hello, World!&quot;
print(b[:5])
</code></pre>
<p>Slice To the End</p>
<p>By omitting the end index, the range will end:</p>
<p>Example:</p>
<p>Get the characters from position 2, and all the way to the end:</p>
<pre><code>b = &quot;Hello, World!&quot;
print(b[2:])
</code></pre>
<p>Negative Indexing</p>
<p>Use a negative index to start slicing from the end of the string:
example.</p>
<p>Get the characters:</p>
<p>From: &quot;o&quot; in &quot;World!&quot; (position -5)</p>
<p>To, but not included: &quot;d&quot; in &quot;World!&quot; (position -2):</p>
<pre><code>b = &quot;Hello, World!&quot;
print(b[-5:-2])
</code></pre>
------------------------------------------------------------------ <br><h3> Robert, Id: 73011643, Score: -9: </h3><p>Here's a simple mnemonic for remembering how it works:</p>
<ul>
<li><code>S L *I* C *E*</code></li>
<li>the 'i' of slice comes first and stands for <em>inclusive</em>,</li>
<li>the 'e' comes last and stands for <em>exclusive</em>.</li>
</ul>
<p>So <code>array[j:k]</code> will <em>include</em> the <code>j</code>th element and <em>exclude</em> the <code>k</code>th element.</p>
<h4> OneCricketeer, Comment 128986129 Score: 1: </h4>You forgot the <code>step</code> like <code>[j:k:s]</code>. And slicing wraps around the list<br><h4> OneCricketeer, Comment 128998986 Score: 1: </h4>Your answer is incomplete, though, as it doesn&#39;t completely answer about different ways to slice. Other answers given already specify the inclusive/exclusive details<br><h4> Robert, Comment 128993361 Score: 0: </h4>But for the case I cover, <code>array[j:k]</code>, I believe my mnemonic is correct and helpful. I don&#39;t believe it is wrong in any way. Please reconsider your downvote.<br>