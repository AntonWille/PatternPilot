 <h2> Title: How do I read from stdin? </h2> <h4> tehryan, question_id: 1450393 </h4>Score: 1769, Tags: {python,stdin} <br><p>How do I read from <a href="https://en.wikipedia.org/wiki/Standard_streams#Standard_input_(stdin)" rel="noreferrer"><code>stdin</code></a>? Some <a href="https://en.wikipedia.org/wiki/Code_golf" rel="noreferrer">code golf</a> challenges require using <code>stdin</code> for input.</p>
------------------------------------------------------------------ <br><h3> Russia Must Remove Putin, Id: 38670261, Score: 191: </h3><blockquote>
<h2>How do you read from stdin in Python?</h2>
<p>I'm trying to do some of the code golf challenges, but they all require the input to be taken from stdin. How do I get that in Python?</p>
</blockquote>
<p>You can use:</p>
<ul>
<li><a href="https://docs.python.org/3/library/sys.html#sys.stdin" rel="noreferrer"><code>sys.stdin</code></a> - A file-like object - call <code>sys.stdin.read()</code> to read everything.</li>
<li><a href="https://docs.python.org/3/library/functions.html#input" rel="noreferrer"><code>input(prompt)</code></a> - pass it an optional prompt to output, it reads from stdin up to the first newline, which it strips. You'd have to do this repeatedly to get more lines, at the end of the input it raises EOFError. (Probably not great for golfing.) In Python 2, this is <code>raw_input(prompt)</code>.</li>
<li><a href="https://docs.python.org/3/library/functions.html#open" rel="noreferrer"><code>open(0).read()</code></a> - In Python 3, the builtin function <code>open</code> accepts <a href="https://en.wikipedia.org/wiki/File_descriptor" rel="noreferrer">file descriptors</a> (integers representing operating system IO resources), and 0 is the descriptor of <code>stdin</code>. It returns a file-like object like <code>sys.stdin</code> - probably your best bet for golfing. In Python 2, this is <a href="https://docs.python.org/2/library/io.html#io.open" rel="noreferrer"><code>io.open</code></a>.</li>
<li><code>open('/dev/stdin').read()</code> - similar to <code>open(0)</code>, works on Python 2 and 3, but not on Windows (or even Cygwin).</li>
<li><a href="https://docs.python.org/2/library/fileinput.html#fileinput.input" rel="noreferrer"><code>fileinput.input()</code></a> - returns an iterator over lines in all files listed in <code>sys.argv[1:]</code>, or stdin if not given. Use like <code>''.join(fileinput.input())</code>.</li>
</ul>
<p>Both <code>sys</code> and <code>fileinput</code> must be imported, respectively, of course.</p>
<h3>Quick <code>sys.stdin</code> examples compatible with Python 2 and 3, Windows, Unix</h3>
<p>You just need to <code>read</code> from <code>sys.stdin</code>, for example, if you pipe data to stdin:</p>
<pre><code>$ echo foo | python -c &quot;import sys; print(sys.stdin.read())&quot;
foo
</code></pre>
<p>We can see that <code>sys.stdin</code> is in default text mode:</p>
<pre class="lang-py prettyprint-override"><code>&gt;&gt;&gt; import sys
&gt;&gt;&gt; sys.stdin
&lt;_io.TextIOWrapper name='&lt;stdin&gt;' mode='r' encoding='UTF-8'&gt;
</code></pre>
<h3>file example</h3>
<p>Say you have a file, <code>inputs.txt</code>, we can accept that file and write it back out:</p>
<pre><code>python -c &quot;import sys; sys.stdout.write(sys.stdin.read())&quot; &lt; inputs.txt
</code></pre>
<h2>Longer answer</h2>
<p>Here's a complete, easily replicable demo, using two methods, the builtin function, <code>input</code> (use <code>raw_input</code> in Python 2), and <code>sys.stdin</code>. The data is unmodified, so the processing is a non-operation.</p>
<p>To begin with, let's create a file for inputs:</p>
<pre><code>$ python -c &quot;print('foo\nbar\nbaz')&quot; &gt; inputs.txt
</code></pre>
<p>And using the code we've already seen, we can check that we've created the file:</p>
<pre><code>$ python -c &quot;import sys; sys.stdout.write(sys.stdin.read())&quot; &lt; inputs.txt 
foo
bar
baz
</code></pre>
<p>Here's the help on <code>sys.stdin.read</code> from Python 3:</p>
<pre><code>read(size=-1, /) method of _io.TextIOWrapper instance
    Read at most n characters from stream.
    
    Read from underlying buffer until we have n characters or we hit EOF.
    If n is negative or omitted, read until EOF.
</code></pre>
<h3>Builtin function, <code>input</code> (<code>raw_input</code> in Python 2)</h3>
<p>The builtin function <code>input</code> reads from standard input up to a newline, which is stripped (complementing <code>print</code>, which adds a newline by default.) This occurs until it gets EOF (End Of File), at which point it raises <code>EOFError</code>.</p>
<p>Thus, here's how you can use <code>input</code> in Python 3 (or <code>raw_input</code> in Python 2) to read from stdin - so we create a Python module we call stdindemo.py:</p>
<pre><code>$ python -c &quot;print('try:\n    while True:\n        print(input())\nexcept EOFError:\n    pass')&quot; &gt; stdindemo.py 
</code></pre>
<p>And let's print it back out to ensure it's as we expect:</p>
<pre><code>$ python -c &quot;import sys; sys.stdout.write(sys.stdin.read())&quot; &lt; stdindemo.py 
try:
    while True:
        print(input())
except EOFError:
    pass
</code></pre>
<p>Again, <code>input</code> reads up until the newline and essentially strips it from the line. <code>print</code> adds a newline. So while they both modify the input, their modifications cancel. (So they are essentially each other's complement.)</p>
<p>And when <code>input</code> gets the end-of-file character, it raises EOFError, which we ignore and then exit from the program.</p>
<p>And on Linux/Unix, we can pipe from cat:</p>
<pre><code>$ cat inputs.txt | python -m stdindemo
foo
bar
baz
</code></pre>
<p>Or we can just redirect the file from stdin:</p>
<pre><code>$ python -m stdindemo &lt; inputs.txt 
foo
bar
baz
</code></pre>
<p>We can also execute the module as a script:</p>
<pre><code>$ python stdindemo.py &lt; inputs.txt 
foo
bar
baz
</code></pre>
<p>Here's the help on the builtin <code>input</code> from Python 3:</p>
<pre><code>input(prompt=None, /)
    Read a string from standard input.  The trailing newline is stripped.
    
    The prompt string, if given, is printed to standard output without a
    trailing newline before reading input.
    
    If the user hits EOF (*nix: Ctrl-D, Windows: Ctrl-Z+Return), raise EOFError.
    On *nix systems, readline is used if available.
</code></pre>
<h2><code>sys.stdin</code></h2>
<p>Here we make a demo script using <code>sys.stdin</code>. The efficient way to iterate over a file-like object is to use the file-like object as an iterator. The complementary method to write to stdout from this input is to simply use <code>sys.stdout.write</code>:</p>
<pre><code>$ python -c &quot;print('import sys\nfor line in sys.stdin:\n    sys.stdout.write(line)')&quot; &gt; stdindemo2.py
</code></pre>
<p>Print it back out to make sure it looks right:</p>
<pre><code>$ python -c &quot;import sys; sys.stdout.write(sys.stdin.read())&quot; &lt; stdindemo2.py 
import sys
for line in sys.stdin:
    sys.stdout.write(line)
</code></pre>
<p>And redirecting the inputs into the file:</p>
<pre><code>$ python -m stdindemo2 &lt; inputs.txt
foo
bar
baz
</code></pre>
<p>Golfed into a command:</p>
<pre><code>$ python -c &quot;import sys; sys.stdout.write(sys.stdin.read())&quot; &lt; inputs.txt
foo
bar
baz
</code></pre>
<h2>File Descriptors for Golfing</h2>
<p>Since the file descriptors for <code>stdin</code> and <code>stdout</code> are 0 and 1 respectively, we can also pass those to <code>open</code> in Python 3 (not 2, and note that we still need the 'w' for writing to stdout).</p>
<p>If this works on your system, it will shave off more characters.</p>
<pre><code>$ python -c &quot;open(1,'w').write(open(0).read())&quot; &lt; inputs.txt
baz
bar
foo
</code></pre>
<p>Python 2's <code>io.open</code> does this as well, but the import takes a lot more space:</p>
<pre><code>$ python -c &quot;from io import open; open(1,'w').write(open(0).read())&quot; &lt; inputs.txt 
foo
bar
baz
</code></pre>
<h3>Addressing other comments and answers</h3>
<p>One comment suggests <code>''.join(sys.stdin)</code> for golfing but that's actually longer than sys.stdin.read() - plus Python must create an extra list in memory (that's how <code>str.join</code> works when not given a list) - for contrast:</p>
<pre><code>''.join(sys.stdin)
sys.stdin.read()
</code></pre>
<p>The top answer suggests:</p>
<pre><code>import fileinput

for line in fileinput.input():
    pass
</code></pre>
<p>But, since <code>sys.stdin</code> implements the file API, including the iterator protocol, that's just the same as this:</p>
<pre><code>import sys

for line in sys.stdin:
    pass
</code></pre>
<p>Another answer <em>does</em> suggest this. Just remember that if you do it in an interpreter, you'll need to do <kbd>Ctrl</kbd>-<kbd>d</kbd> if you're on Linux or Mac, or <kbd>Ctrl</kbd>-<kbd>z</kbd> on Windows (after <kbd>Enter</kbd>) to send the end-of-file character to the process. Also, that answer suggests <code>print(line)</code> - which adds a <code>'\n'</code> to the end - use <code>print(line, end='')</code> instead (if in Python 2, you'll need <code>from __future__ import print_function</code>).</p>
<p>The real use-case for <code>fileinput</code> is for reading in a series of files.</p>
<h4> Chameleon, Comment 132203167 Score: 0: </h4>+1 for <code>open(0)</code>. I have an <code>open(filename)</code> but with a command line parameter I want to use <code>stdin</code> as file. So I do not want to write extra code.<br>------------------------------------------------------------------ <br><h3> u0b34a0f6ae, Id: 1454400, Score: 1137: </h3><p>Use the <a href="http://docs.python.org/library/fileinput.html" rel="noreferrer"><code>fileinput</code></a> module:</p>
<pre><code>import fileinput

for line in fileinput.input():
    pass
</code></pre>
<p><a href="http://docs.python.org/library/fileinput.html" rel="noreferrer"><code>fileinput</code></a> will loop through all the lines in the input specified as file names given in command-line arguments, or the standard input if no arguments are provided.</p>
<p>Note: <code>line</code> will contain a trailing newline; to remove it use <a href="https://docs.python.org/3/library/stdtypes.html#str.rstrip" rel="noreferrer"><code>line.rstrip()</code></a>.</p>
<h4> user3064538, Comment 118442565 Score: 9: </h4>@AmirrezaRiahi <code>input()</code> reads a single line from stdin, whereas <code>fileinput.input()</code> will loop through <i>all</i> the lines in the input specified as file names given in command-line arguments, or the standard input if no arguments are provided<br><h4> Amir reza Riahi, Comment 117960826 Score: 7: </h4>what&#39;s difference between <code>input()</code> and <code>fileinput.input()</code>?<br><h4> storm_m2138, Comment 128768937 Score: 3: </h4>if you want the lines as a list you can use <code>list(fileinput.input())</code><br><h4> chepner, Comment 131502672 Score: 1: </h4>The <code>fileinput</code> module is more about providing a single interface to reading from <i>either</i> standard input <i>or</i> named files, depending on what the user provides.<br><h4> anderium, Comment 134523259 Score: 0: </h4>Since all lines will contain a newline you can also remove it with <code>line[:-1]</code>.  (Shorter, so better for CodeGolf.)<br><h4> Martin Braun, Comment 130960069 Score: 0: </h4>And what is the difference between <code>fileinput.input()</code> and <code>sys.stdin</code>?<br><h4> chepner, Comment 131502650 Score: 0: </h4><code>sys.stdin</code> is the file handle that <code>input</code> reads from and what <code>fileinput.input()</code> reads from if there are not command-line arguments.<br><h4> Sridhar Sarnobat, Comment 124322839 Score: 0: </h4>Thanks for asking this. I was stuck when one of the fileinput.input() lines was my a command line arg when I wanted to just read stdin.<br><h4> Thorsten Staerk, Comment 125294987 Score: 0: </h4>why not use input? Otherwise you are in a for loop, while I only want one input.<br>------------------------------------------------------------------ <br><h3> Mark Rushakoff, Id: 1450398, Score: 828: </h3><p>There's a few ways to do it.</p>

<ul>
<li><p><a href="http://docs.python.org/library/sys.html#sys.stdin" rel="noreferrer"><code>sys.stdin</code></a> is a file-like object on which you can call functions <code>read</code> or <code>readlines</code> if you want to read everything or you want to read everything and split it by newline automatically. (You need to <code>import sys</code> for this to work.)</p></li>
<li><p>If you want to <em>prompt</em> the user for input, you can use <a href="https://docs.python.org/2.7/library/functions.html?highlight=raw_input#raw_input" rel="noreferrer"><code>raw_input</code></a> in Python 2.X, and just <a href="https://docs.python.org/3/library/functions.html#input" rel="noreferrer"><code>input</code></a> in Python 3.  </p></li>
<li><p>If you actually just want to read command-line options, you can access them via the <a href="http://docs.python.org/library/sys.html#sys.argv" rel="noreferrer">sys.argv</a> list.</p></li>
</ul>

<p>You will probably find <a href="http://en.wikibooks.org/wiki/Python_Programming/Input_and_output" rel="noreferrer">this Wikibook article on I/O in Python</a> to be a useful reference as well.</p>
<h4> bobsbeenjamin, Comment 115283535 Score: 0: </h4>The 3rd option is what I was looking for to handle the input at code.golf<br><h4> milahu, Comment 135006087 Score: 0: </h4><code>sys.stdin.read()</code> returns a string. <code>sys.stdin.buffer.read()</code> returns bytes.<br>------------------------------------------------------------------ <br><h3> user303110, Id: 3289051, Score: 588: </h3><pre><code>import sys

for line in sys.stdin:
    print(line)
</code></pre>

<p>Note that this will include a newline character at the end. To remove the newline at the end, use <code>line.rstrip()</code> as @brittohalloran said.</p>
<h4> avp, Comment 93114362 Score: 26: </h4>line.rstrip(&#39;\n&#39;), otherwise it will drop all the whitespaces<br><h4> ks1322, Comment 118328576 Score: 4: </h4>Another way to remove extra newline at the end is to use <code>print(line, end=&#39;&#39;)</code>.<br><h4> josch, Comment 100435722 Score: 3: </h4>@avp this will not correctly deal with <code>\r\n</code> line endings<br><h4> John Allsup, Comment 131797453 Score: 1: </h4>@KaiPetzke You&#39;re right.<br><h4> addicted, Comment 94504810 Score: 1: </h4>using this method, how do we know when the input stream ends? I want to add comma after every line <i>excepts</i> for the last line.<br><h4> Diego Queiroz, Comment 95383288 Score: 0: </h4>I receive: TypeError: &#39;FileWrapper&#39; object is not iterable.<br><h4> John Allsup, Comment 123252553 Score: 0: </h4>line = line.rstrip(&#39;\n&#39;).rstrip(&#39;\r&#39;) if you are worried about possible &#39;\r\n&#39; endings. I find if opening a file in text mode, python automatically converts &quot;\r\n&quot; to &quot;\n&quot; anyhow, so you only need to worry about this if you open as binary.<br><h4> Kai Petzke, Comment 131779430 Score: 0: </h4>@JohnAllsup <code>line.rstrip(&#39;\r\n&#39;)</code> should be enough, instead of calling <code>rstrip()</code> twice.<br>------------------------------------------------------------------ <br><h3> Pat Notz, Id: 5185255, Score: 278: </h3><p>Python also has built-in functions <code>input()</code> and <code>raw_input()</code>. See the Python documentation under <a href="http://docs.python.org/library/functions.html" rel="noreferrer">Built-in Functions</a>.</p>

<p>For example,</p>

<pre><code>name = raw_input("Enter your name: ")   # Python 2.x
</code></pre>

<p>or</p>

<pre><code>name = input("Enter your name: ")   # Python 3
</code></pre>
<h4> tripleee, Comment 56564591 Score: 8: </h4>This reads a single line, which isn&#39;t really what the OP asked about. I interpret the question as &quot;how do I read a bunch of lines from an open file handle until EOF?&quot;<br><h4> chrisfs, Comment 86957923 Score: 5: </h4>The OP isn&#39;t asking to read input from a keyboard, He is asking to read from stdin which in a contest situation is usually provided to the contestants.<br><h4> clockw0rk, Comment 100643001 Score: 4: </h4>this is what i needed, google brought me here. interestingly i managed to code rfid tags, datetime, databases, but never bothered to read input from the user lol<br>------------------------------------------------------------------ <br><h3> Eugene Yokota, Id: 1450396, Score: 246: </h3><p>Here's from <a href="http://web.archive.org/web/20140928083217/http://oreilly.com/catalog/lpython/chapter/ch09.html#16308" rel="noreferrer">Learning Python</a>:</p>

<pre><code>import sys
data = sys.stdin.readlines()
print "Counted", len(data), "lines."
</code></pre>

<hr>

<p>On Unix, you could test it by doing something like:</p>

<pre><code>% cat countlines.py | python countlines.py 
Counted 3 lines.
</code></pre>

<p>On Windows or DOS, you'd do:</p>

<pre><code>C:\&gt; type countlines.py | python countlines.py 
Counted 3 lines.
</code></pre>
<h4> Russia Must Remove Putin, Comment 64781648 Score: 21: </h4>&quot;Learning Python&quot; is wrong in directing users to use <code>readlines()</code>. File objects are intended to be iterated over without materializing all of the data in memory.<br><h4> istepaniuk, Comment 55278510 Score: 17: </h4>The use of <code>cat</code> here is redundant. The correct invocation for Unix systems is <code>python countlines.py &lt; countlines.py</code>.<br><h4> GeePokey, Comment 119476173 Score: 4: </h4>@istepaniuk Regarding &quot;use of cat&quot;, I find using <code>cat filespec | filters</code> more convenient in general when I am tweaking command line parameters to the filters, since they will be at the end of the line each time.<br><h4> jfs, Comment 18323521 Score: 4: </h4>Here&#39;s a more memory efficient (and maybe faster) way to count lines in Python: <code>print(sum(chunk.count(&#39;\n&#39;) for chunk in iter(partial(sys.stdin.read, 1 &lt;&lt; 15), &#39;&#39;)))</code>. <a href="http://stackoverflow.com/questions/9371238/why-is-reading-lines-from-stdin-much-slower-in-c-than-python#comment11966378_9371238">see <code>wc-l.py</code></a><br><h4> Panki, Comment 123271967 Score: 2: </h4>@GeePokey The input redirection can also be placed infront: <code>&lt; filespec filters</code><br>------------------------------------------------------------------ <br><h3> Massimiliano Torromeo, Id: 7608205, Score: 105: </h3><p>The answer proposed by others:</p>

<pre><code>for line in sys.stdin:
  print line
</code></pre>

<p>is very simple and pythonic, but it must be noted that the script will wait until EOF before starting to iterate on the lines of input.</p>

<p>This means that <code>tail -f error_log | myscript.py</code> will not process lines as expected.</p>

<p>The correct script for such a use case would be:</p>

<pre><code>while 1:
    try:
        line = sys.stdin.readline()
    except KeyboardInterrupt:
        break

    if not line:
        break

    print line
</code></pre>

<p><strong>UPDATE</strong><br>
From the comments it has been cleared that on python 2 only there might be buffering involved, so that you end up waiting for the buffer to fill or EOF before the print call is issued.</p>
<h4> jfs, Comment 57652603 Score: 9: </h4>@Sean: <b>wrong</b>. <code>for line in sys.stdin:</code> does not &quot;block till EOF&quot;. There is a <a href="https://bugs.python.org/issue3907" rel="nofollow noreferrer">read-ahead bug in Python 2</a> that delays the lines until the corresponding buffer is full. It is a buffering issue that is unrelated to EOF. To workaround, use <code>for line in iter(sys.stdin.readline, &#39;&#39;):</code> (use <code>io.open()</code> for ordinary files). You don&#39;t need it in Python 3.<br><h4> mb., Comment 15070444 Score: 9: </h4>The <code>for line in sys.stdin:</code> pattern <b>does not</b> wait for EOF.  But if you test on very small files, responses may get buffered.  Test with more data to see that it reads intermediate results.<br><h4> M&#226;tt Fr&#235;&#235;man, Comment 46255858 Score: 2: </h4>I suspect this is related to detection of tty in libc, so when you pipe it detects on a interactive shell it  detects none tty, unbuffer from expect-dev is a handy util that I believe injects a shim via ld_preload so is_atty returns true (I suspect that&#39;s how it is handing it)<br><h4> jfs, Comment 57652724 Score: 0: </h4>@MattFreeman: it is unrelated to &quot;line- vs. block-buffering depending on whether stdout is tty&quot; in this case. The read-ahead bug in Python 2 delays the input even if <code>tail</code> were to flush its output in time. <code>for line in sys.stdin</code> works fine on Python 3.<br><h4> musiphil, Comment 96591160 Score: 0: </h4><code>for line in sys.stdin:</code> is not meant for truly interactive input (e.g. getting input from the terminal after prompts), anyway. In most cases, you should not care whether the input is buffered or not.<br><h4> Sean, Comment 28720139 Score: 0: </h4>my python 2.7.5 &quot;for line in sys.stdin&quot;, blocks till EOF or some reasonable amount of data has buffered. Fine for stream processing. Not fine for line by line processing or user input.<br><h4> ctrl-alt-delor, Comment 16526304 Score: 0: </h4>I get wait for End Of File or buffering, when taking input from a stream when using python 2.6.6, but with 3.1.3 I don&#39;t. Note <code>print line</code> does not woke in 3.1.3, but <code>print(line)</code> does.<br>------------------------------------------------------------------ <br><h3> Bouni, Id: 58797037, Score: 8: </h3><p>I use the following method, it returns a string from stdin (I use it for json parsing).
It works with pipe and prompt on Windows (not tested on Linux yet).
When prompting, two line breaks indicate end of input.</p>

<pre><code>def get_from_stdin():

  lb = 0
  stdin = ''

  for line in sys.stdin:
    if line == "\n":
        lb += 1
        if lb == 2:
            break
    else:
        lb = 0
        stdin += line

  return stdin
</code></pre>
------------------------------------------------------------------ <br><h3> rlib, Id: 11887913, Score: 39: </h3><p>This will echo standard input to standard output:</p>

<pre><code>import sys
line = sys.stdin.readline()
while line:
    print line,
    line = sys.stdin.readline()
</code></pre>
------------------------------------------------------------------ <br><h3> Emil Lundberg, Id: 17927520, Score: 36: </h3><p>Building on all the anwers using <code>sys.stdin</code>, you can also do something like the following to read from an argument file if at least one argument exists, and fall back to stdin otherwise:</p>

<pre><code>import sys
f = open(sys.argv[1]) if len(sys.argv) &gt; 1 else sys.stdin    
for line in f:
#     Do your stuff
</code></pre>

<p>and use it as either</p>

<pre><code>$ python do-my-stuff.py infile.txt
</code></pre>

<p>or</p>

<pre><code>$ cat infile.txt | python do-my-stuff.py
</code></pre>

<p>or even</p>

<pre><code>$ python do-my-stuff.py &lt; infile.txt
</code></pre>

<p>That would make your Python script behave like many GNU/Unix programs such as <code>cat</code>, <code>grep</code> and <code>sed</code>.</p>
------------------------------------------------------------------ <br><h3> oHo, Id: 52538426, Score: 21: </h3><h2><a href="https://docs.python.org/3/library/argparse.html?highlight=stdin#filetype-objects" rel="noreferrer"><code>argparse</code></a> is an easy solution</h2>

<p>Example compatible with both Python versions 2 and 3:</p>

<pre><code>#!/usr/bin/python

import argparse
import sys

parser = argparse.ArgumentParser()

parser.add_argument('infile',
                    default=sys.stdin,
                    type=argparse.FileType('r'),
                    nargs='?')

args = parser.parse_args()

data = args.infile.read()
</code></pre>

<p>You can run this script in many ways:</p>

<p><strong>1. Using <code>stdin</code></strong></p>

<pre><code>echo 'foo bar' | ./above-script.py
</code></pre>

<p>&emsp; or shorter by replacing <code>echo</code> by <a href="https://stackoverflow.com/q/25797252/938111">here</a> <a href="https://unix.stackexchange.com/a/80368/13999">string</a>:</p>

<pre><code>./above-script.py &lt;&lt;&lt; 'foo bar'
</code></pre>

<p><strong>2. Using a filename argument</strong></p>

<pre><code>echo 'foo bar' &gt; my-file.data
./above-script.py my-file.data
</code></pre>

<p><strong>3. Using <code>stdin</code> through the special filename <code>-</code></strong></p>

<pre><code>echo 'foo bar' | ./above-script.py -
</code></pre>
<h4> tommy.carstensen, Comment 94089832 Score: 0: </h4>Here is an answer on what to do, if the input file is compressed: <a href="https://stackoverflow.com/a/33621549/778533">stackoverflow.com/a/33621549/778533</a> One can also do <code>add_argument(&#39;--in&#39;</code> and then pipe to the script and add <code>--in -</code> to the command line. P.S. <code>in</code> is not a very good name for a variable/attribute.<br><h4> Ken Colton, Comment 94659324 Score: 0: </h4><code>in</code> isn&#39;t just a bad name for a variable, it is illegal. <code>args.in.read()</code> will raise InvalidSyntax error because of the <code>in</code> reserved keyword. Can simply rename to <code>infile</code> like the python argparse docs do: <a href="https://docs.python.org/3/library/argparse.html?highlight=stdin#filetype-objects" rel="nofollow noreferrer">docs.python.org/3/library/&hellip;</a><br><h4> oHo, Comment 94740542 Score: 0: </h4>Thank you @tommy.carstensen for your feedback, I have just improved the answer. Merry Christmas and Happy New Year ;-)<br>------------------------------------------------------------------ <br><h3> Chandan Kumar, Id: 34990251, Score: 16: </h3><p>The following chip of code will help you (it will read all of stdin blocking unto <code>EOF</code>, into one string):</p>

<pre><code>import sys
input_str = sys.stdin.read()
print input_str.split()
</code></pre>
------------------------------------------------------------------ <br><h3> Uri Goren, Id: 40462515, Score: 12: </h3><p>I am pretty amazed no one had mentioned this hack so far:</p>
<pre><code>python -c &quot;import sys; set(map(sys.stdout.write,sys.stdin))&quot;
</code></pre>
<p>in python2 you can drop the <code>set()</code> call, but it would work either way</p>
<h4> musiphil, Comment 96590942 Score: 2: </h4>Why use <code>readlines</code> that split into lines and then <code>join</code> again? You can just write <code>print(sys.stdin.read())</code><br><h4> Harry Moreno, Comment 108382476 Score: 0: </h4>This is will use more memory than needed because python needs to build an extra array.<br><h4> Uri Goren, Comment 109722823 Score: 0: </h4>Well, not really, because <code>write</code> returns <code>None</code>, and the set size would never be greater than 1 (<code>=len(set([None]))</code>)<br>------------------------------------------------------------------ <br><h3> Bacara, Id: 18470058, Score: 7: </h3><p>Try this:</p>

<pre><code>import sys

print sys.stdin.read().upper()
</code></pre>

<p>and check it with:</p>

<pre><code>$ echo "Hello World" | python myFile.py
</code></pre>
------------------------------------------------------------------ <br><h3> Wei, Id: 24855121, Score: 7: </h3><p>You can read from stdin and then store inputs into <strong>"data"</strong> as follows:</p>

<pre><code>data = ""
for line in sys.stdin:
    data += line
</code></pre>
<h4> Russia Must Remove Putin, Comment 74521189 Score: 3: </h4><a href="https://www.python.org/dev/peps/pep-0008/#programming-recommendations" rel="nofollow noreferrer">&quot;do not rely on CPython&#39;s efficient implementation of in-place string concatenation for statements in the form a += b or a = a + b . This optimization is fragile even in CPython&quot;</a><br><h4> musiphil, Comment 96591021 Score: 0: </h4>The same thing can be done with <code>data = sys.stdin.read()</code>, without the problem of repeated string concatenations.<br>------------------------------------------------------------------ <br><h3> anatoly techtonik, Id: 38939362, Score: 7: </h3><p>Read from <code>sys.stdin</code>, but to <strong>read binary data on Windows</strong>, you need to be extra careful, because <code>sys.stdin</code> there is opened in text mode and it will corrupt <code>\r\n</code> replacing them with <code>\n</code>.</p>

<p>The solution is to set mode to binary if Windows + Python 2 is detected, and on Python 3 use <code>sys.stdin.buffer</code>.</p>

<pre><code>import sys

PY3K = sys.version_info &gt;= (3, 0)

if PY3K:
    source = sys.stdin.buffer
else:
    # Python 2 on Windows opens sys.stdin in text mode, and
    # binary data that read from it becomes corrupted on \r\n
    if sys.platform == "win32":
        # set sys.stdin to binary mode
        import os, msvcrt
        msvcrt.setmode(sys.stdin.fileno(), os.O_BINARY)
    source = sys.stdin

b = source.read()
</code></pre>
------------------------------------------------------------------ <br><h3> AdamKalisz, Id: 55985594, Score: 5: </h3><p>For <strong>Python 3</strong> that would be:</p>

<pre><code># Filename e.g. cat.py
import sys

for line in sys.stdin:
    print(line, end="")
</code></pre>

<p>This is basically a simple form of cat(1), since it doesn't add a newline after each line. You can use this (after You marked the file executable using <code>chmod +x cat.py</code> such as:</p>

<pre><code>echo Hello | ./cat.py
</code></pre>
------------------------------------------------------------------ <br><h3> hant0508, Id: 70028311, Score: 5: </h3><p>Since Python 3.8 you can use <a href="https://www.python.org/dev/peps/pep-0572/" rel="noreferrer">assignment expression</a>:</p>
<pre><code>while (line := input()):
    print(line)
</code></pre>
<h4> Dato, Comment 126578183 Score: 0: </h4>Doesn’t this produce an <code>EOFError</code> when stdin ends? I can’t get around that by using <code>input()</code>.<br><h4> Dereckson, Comment 126684139 Score: 0: </h4>On Python 3.8 it indeed produces <code>EOFError: EOF when reading a line</code>. To get around you can use <code>try ... except EOFError: pass</code><br>------------------------------------------------------------------ <br><h3> Tomas Tomecek, Id: 47071016, Score: 4: </h3><p>The problem I have with solution</p>

<pre><code>import sys

for line in sys.stdin:
    print(line)
</code></pre>

<p>is that if you don't pass any data to stdin, it will block forever. That's why I love <a href="https://stackoverflow.com/a/3763257/909579">this answer</a>: check if there is some data on stdin first, and then read it. This is what I ended up doing:</p>

<pre><code>import sys
import select

# select(files to read from, files to write to, magic, timeout)
# timeout=0.0 is essential b/c we want to know the asnwer right away
if select.select([sys.stdin], [], [], 0.0)[0]:
    help_file_fragment = sys.stdin.read()
else:
    print("No data passed to stdin", file=sys.stderr)
    sys.exit(2)
</code></pre>
<h4> musiphil, Comment 96590716 Score: 1: </h4>This method limits the applicability of the program seriously: for example, you cannot use this for interactive input from the terminal, because the input will almost never be &quot;ready&quot; when <code>select</code> is called; or you could also face problems if stdin is connected to a file on a slow medium (network, CD, tape, etc.). You said that &quot;if you don&#39;t pass any data to stdin, it will block forever.&quot; is a <i>problem</i>, but I would say it&#39;s a <i>feature</i>. Most CLI programs (e.g. <code>cat</code>) work this way, and they are expected to. EOF is the only thing you should depend on to detect the end of the input.<br><h4> tiktak, Comment 81163620 Score: 0: </h4>I&#39;d seriously recommend hiding this hideous if condition into a method though.<br>------------------------------------------------------------------ <br><h3> Mazdak, Id: 56821940, Score: 3: </h3><p>When using <code>-c</code> command, as a tricky way, instead of reading the <code>stdin</code> (and more flexible in some cases) you can pass a shell script command as well to your python command by putting the shell command in quotes within a parenthesis started by <code>$</code> sign.</p>
<p>e.g.</p>
<pre><code>python3 -c &quot;import sys; print(len(sys.argv[1].split('\n')))&quot; &quot;$(cat ~/.goldendict/history)&quot;
</code></pre>
<p>This will count the number of lines from goldendict's history file.</p>
<h4> catleeball, Comment 111694622 Score: 1: </h4>This is clever, I was piping into <code>python -c</code> this way and this was an interesting workaround. Thank you for sharing. :)<br>------------------------------------------------------------------ <br><h3> estani, Id: 26633637, Score: 2: </h3><p>I had some issues when getting this to work for reading over sockets piped to it. When the socket got closed it started returning empty string in an active loop. So this is my solution to it (which I only tested in linux, but hope it works in all other systems)</p>

<pre><code>import sys, os
sep=os.linesep

while sep == os.linesep:
    data = sys.stdin.readline()               
    sep = data[-len(os.linesep):]
    print '&gt; "%s"' % data.strip()
</code></pre>

<p>So if you start listening on a socket it will work properly (e.g. in bash):</p>

<pre><code>while :; do nc -l 12345 | python test.py ; done
</code></pre>

<p>And you can call it with telnet or just point a browser to localhost:12345</p>
------------------------------------------------------------------ <br><h3> szeitlin, Id: 37714330, Score: 2: </h3><p>Regarding this:</p>

<p><code>for line in sys.stdin:</code></p>

<p>I just tried it on python 2.7 (following someone else's suggestion) for a very large file, and I don't recommend it, precisely for the reasons mentioned above (nothing happens for a long time). </p>

<p>I ended up with a slightly more pythonic solution (and it works on bigger files):</p>

<pre><code>with open(sys.argv[1], 'r') as f:
    for line in f:
</code></pre>

<p>Then I can run the script locally as:</p>

<pre><code>python myscript.py "0 1 2 3 4..." # can be a multi-line string or filename - any std.in input will work
</code></pre>
<h4> DeFazer, Comment 66398123 Score: 1: </h4>How could you pass <code>sys.stdin</code> as a command-line argument to the script? Arguments are strings and streams are file-like objects, they are not the same.<br><h4> szeitlin, Comment 66403078 Score: 0: </h4>@DeFazer edited to show how to use it. Arguments are strings, yes, but as the python docs and I mentioned in an earlier comment above, <code>sys.stdin</code> is a file-like object<br><h4> Russia Must Remove Putin, Comment 64778047 Score: 0: </h4>Opening a file is not reading from stdin, like the question asks. -1<br><h4> szeitlin, Comment 64796209 Score: 0: </h4>In this case I am passing in <code>sys.stdin</code> as a command-line argument to the script.<br>------------------------------------------------------------------ <br><h3> Jay, Id: 55694475, Score: 1: </h3><p>There is 
<code>os.read(0, x)</code>
which reads xbytes from 0 which represents stdin. This is an unbuffered read, more low level than sys.stdin.read()</p>
------------------------------------------------------------------ <br><h3> andronick83, Id: 73989552, Score: 1: </h3><h5>Nonblocking, bytemode, stdin -&gt; stdout:</h5>
<pre><code># pipe.py

import os, sys, time

os.set_blocking(0, False)
sys.stdin = os.fdopen(0, 'rb', 0)
sys.stdout = os.fdopen(1, 'wb', 0)

while 1:
    time.sleep(.1)
    try: out = sys.stdin.read()
    except:
        sys.stdout.write(b&quot;E&quot;)
        continue
    if out is None:
        sys.stdout.write(b&quot;N&quot;)
        continue
    if not out:
        sys.stdout.write(b&quot;_&quot;)
        break
    # working..
    out = b&quot;&lt;&quot; + out + b&quot;&gt;&quot;
    sys.stdout.write(out)

sys.stdout.write(b&quot;.\n&quot;)
</code></pre>
<h5>Usage:</h5>
<pre><code>$ for i in 1 2 3; do sleep 1; printf &quot;===$i===&quot;; done | python3 pipe.py
NNNNNNNNN&lt;===1===&gt;NNNNNNNNN&lt;===2===&gt;NNNNNNNNN&lt;===3===&gt;_.
</code></pre>
<h5>Minimal code:</h5>
<pre><code>import os, sys

os.set_blocking(0, False)
fd0 = os.fdopen(0, 'rb', 0)
fd1 = os.fdopen(1, 'wb', 0)

while 1:
    bl = fd0.read()
    if bl is None: continue
    if not bl: break
    fd1.write(bl)
</code></pre>
<p>Tested on Linux, Python 3.9.2</p>
------------------------------------------------------------------ <br><h3> Meitham, Id: 75436473, Score: 1: </h3><p>Worth saying for short command line chaining <code>input</code> is preferred over <code>fileinput</code> and <code>sys.stdin</code> as it requires no import, and is shorter to type.</p>
<pre><code>$ echo hello world | python3 -c &quot;print(input().upper())&quot;
HELLO WORLD
</code></pre>
