 <h2> Title: What is the meaning of single and double underscore before an object name? </h2> <h3> Ram Rachum, question_id: 1301346 </h3>Score: 1823, Tags: {python,oop,naming-conventions,identifier} <br><p>What do single and double leading underscores before an object's name represent in Python?</p>
<h4> Comment 82191530 Anton Tarasenko: </h4>A great short answer from another thread: <a href="https://stackoverflow.com/a/8689983/911945">stackoverflow.com/a/8689983/911945</a><br><h4> Comment 118003730 Gabriel Staples: </h4>See also this <i>excellent</i> answer here, which discusses single vs double leading underscores, and demonstrates &quot;name mangling&quot;!: <a href="https://stackoverflow.com/a/2064212/4561887">Answer to &quot;Private members in Python&quot;</a><br>------------------------------------------------------------------ <br><h3> Answer 1301369 Andrew Keeton: </h3><h2>Single Underscore</h2>
<p>In a class, names with a leading underscore indicate to other programmers that the attribute or method is intended to be be used inside that class. However, privacy is not <em>enforced</em> in any way.
Using leading underscores for functions in a module indicates it should not be imported from somewhere else.</p>
<p>From the <a href="http://www.python.org/dev/peps/pep-0008/" rel="noreferrer">PEP-8</a> style guide:</p>
<blockquote>
<p><code>_single_leading_underscore</code>: weak &quot;internal use&quot; indicator. E.g. <code>from M import *</code> does not import objects whose name starts with an underscore.</p>
</blockquote>
<h2>Double Underscore (Name Mangling)</h2>
<p>From <a href="https://docs.python.org/3/tutorial/classes.html#private-variables" rel="noreferrer">the Python docs</a>:</p>
<blockquote>
<p>Any identifier of the form <code>__spam</code> (at least two leading underscores, at most one trailing underscore) is textually replaced with <code>_classname__spam</code>, where <code>classname</code> is the current class name with leading underscore(s) stripped. This mangling is done without regard to the syntactic position of the identifier, so it can be used to define class-private instance and class variables, methods, variables stored in globals, and even variables stored in instances. private to this class on instances of other classes.</p>
</blockquote>
<p>And a warning from the same page:</p>
<blockquote>
<p>Name mangling is intended to give classes an easy way to define “private” instance variables and methods, without having to worry about instance variables defined by derived classes, or mucking with instance variables by code outside the class. Note that the mangling rules are designed mostly to avoid accidents; <em>it still is possible for a determined soul to access or modify a variable that is considered private.</em></p>
</blockquote>
<h2>Example</h2>
<pre><code>&gt;&gt;&gt; class MyClass():
...     def __init__(self):
...             self.__superprivate = &quot;Hello&quot;
...             self._semiprivate = &quot;, world!&quot;
...
&gt;&gt;&gt; mc = MyClass()
&gt;&gt;&gt; print mc.__superprivate
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
AttributeError: myClass instance has no attribute '__superprivate'
&gt;&gt;&gt; print mc._semiprivate
, world!
&gt;&gt;&gt; print mc.__dict__
{'_MyClass__superprivate': 'Hello', '_semiprivate': ', world!'}
</code></pre>
<h4> Comment 62071537 Markus Meskanen: </h4>This answer is extremely misleading, as it leads the reader to believe that dunderscore is used to make instance attributes &quot;superprivate&quot;. This is <i>not</i> the case, as <a href="https://www.youtube.com/watch?v=HTLu2DFOdTg&amp;t=33m8s" rel="nofollow noreferrer">explained here</a> by Raymond Hettinger, who explicitly states that dunderscore is incorrrectly used to mark members private, while it was designed to be the opposite of private.<br><h4> Comment 51241678 Dhruv Ramani: </h4>What if there&#39;s a variable name declared with 2 underscores which is not in the class? It&#39;s just a normal variable then right?<br><h4> Comment 63837942 arewm: </h4>@MarkusMeskanen I disagree, the answer explicitly states the use of a dunderscore to make instances of class-private variables and methods. While the dunderscore was designed to make these methods and variables easily overwritten by subclasses (making them public), use of a dunderscore preserves a private instance for use within that class.<br><h4> Comment 87611684 flow2k: </h4>For a single underscore, the answer says &quot;nothing special is done with the name itself&quot; but then goes on to say <code>from M import *</code> treats it differently...so something special <i>is</i> done...<br><h4> Comment 64212729 Ethan Furman: </h4>@MarkusMeskanen: The freedom is for the subclasses to use the same names as the superclass does without clobbering the superclass -- in otherwords, the superclasses&#39; dunder names become private to itself.<br><h4> Comment 55872015 A.J.: </h4>what is the meaning of simply <code>__</code> double underscore as a variable name? like <code>a, __ = foo()</code><br><h4> Comment 102141075 variable: </h4>Please can you update your answer with an example of double underscore with respect to inheritence?<br><h4> Comment 77506383 kiwicomb123: </h4>Seriously, I think it&#39;s a mistake to use _ ahead of private variables.  _ is far too ambiguous.  That&#39;s why it throws off so many people.   A more appropriate convention would be &quot;privateVarName&quot; because it leaves without question what the intended visibility is supposed to be.  I realize it&#39;s extra typing, however, clarity is far more important than elegance when it comes to programming.   Use variable names that are self-explanatory, don&#39;t make people have to come to StackOverflow to read your code.  That&#39;s a good sign your code is unreadable.<br><h4> Comment 118003379 Gabriel Staples: </h4>Aha! A single leading underscore indicates the author intended it to be a seldom-used function outside the class implementation, but &quot;private&quot; is NOT enforced in Python here like it is in C++, so I can still use this &quot;semi-private&quot; method call anywhere I want outside the class! That&#39;s what I needed to know. Voil&#225;!  I now know I can call &quot;semi-private&quot; methods in tests.<br><h4> Comment 126521890 Greg7000: </h4>Lets say you have private constant _BOB in module_to_test.py. Now assuming I want to test this module in test_module.py. What do you do if you want to make some asserts which imply the _BOB constant value. Would you import _BOB from module_to_test.py (meaning you ignore the fact that _BOB should be viewed as private) so your test code will be automatically updated if at some point in the future _BOB get reassigned a new value) OR would you create a new constant in module_to_test.py (Ex: _BOB_FOR_TEST) this way you don&#39;t use an external private variable but you would need to updated your test ?<br><h4> Comment 94250156 Advait Saravade: </h4>If you did want to access variable names with a double underscore, just reference it with the class name like so: mc._MyClass__superprivate rather than me.__superprivate. The reason for this is the name mangling by the compiler.<br>------------------------------------------------------------------ <br><h3> Answer 1301409 Ned Batchelder: </h3><ul>
<li><p><code>_foo</code>: Only a convention. A way for the programmer to indicate that the variable is private (whatever that means in Python).</p>
</li>
<li><p><code>__foo</code>: This has real meaning. The interpreter replaces this name with <code>_classname__foo</code> as a way to ensure that the name will not overlap with a similar name in another class.</p>
</li>
<li><p><code>__foo__</code>: Only a convention. A way for the Python system to use names that won't conflict with user names.</p>
</li>
</ul>
<p>No other form of underscores have meaning in the Python world. Also, there's no difference between class, variable, global, etc in these conventions.</p>
<h4> Comment 24717175 dotancohen: </h4><a href="http://stackoverflow.com/questions/551038/private-implementation-class-in-python">This guy</a> states that <code>from module import *</code> does not import underscore-prefixed objects. Therefore, <code>_foo</code> is more than just a convention.<br><h4> Comment 106716256 wim: </h4>For <code>__dunder__</code> names, implicit invocations skip the instance dictionary, so it&#39;s perhaps a little more than just a naming convention in some cases (see <a href="https://docs.python.org/3/reference/datamodel.html#special-method-lookup" rel="nofollow noreferrer"><i>special method lookup</i></a> section in datamodel).<br><h4> Comment 23608501 Bibhas Debnath: </h4>Just came across <code>__foo</code> and curious. How can it overlap with similar method names with other Classes? I mean you still have to access it like <code>instance.__foo()</code>(if it were not renamed by interpreter), right?<br><h4> Comment 44660333 naught101: </h4>@Bibhas: if class <code>B</code> subclasses class <code>A</code>, and both implement <code>foo()</code>, then <code>B.foo()</code> overrides the <code>.foo()</code> inherited from <code>A</code>. An instance of <code>B</code> will only be able to access <code>B.foo()</code>, except via <code>super(B).foo()</code>.<br>------------------------------------------------------------------ <br><h3> Answer 1301557 Alex Martelli: </h3><p>Excellent answers so far but some tidbits are missing. A single leading underscore isn't exactly <em>just</em> a convention: if you use <code>from foobar import *</code>, and module <code>foobar</code> does not define an <code>__all__</code> list, the names imported from the module <strong>do not</strong> include those with a leading underscore. Let's say it's <em>mostly</em> a convention, since this case is a pretty obscure corner;-).</p>

<p>The leading-underscore convention is widely used not just for <em>private</em> names, but also for what C++ would call <em>protected</em> ones -- for example, names of methods that are fully intended to be overridden by subclasses (even ones that <strong>have</strong> to be overridden since in the base class they <code>raise NotImplementedError</code>!-) are often single-leading-underscore names to indicate to code <strong>using</strong> instances of that class (or subclasses) that said methods are not meant to be called directly.</p>

<p>For example, to make a thread-safe queue with a different queueing discipline than FIFO, one imports Queue, subclasses Queue.Queue, and overrides such methods as <code>_get</code> and <code>_put</code>; "client code" never calls those ("hook") methods, but rather the ("organizing") public methods such as <code>put</code> and <code>get</code> (this is known as the <a href="http://en.wikipedia.org/wiki/Template_method_pattern" rel="noreferrer">Template Method</a> design pattern -- see e.g. <a href="http://www.catonmat.net/blog/learning-python-design-patterns-through-video-lectures/" rel="noreferrer">here</a> for an interesting presentation based on a video of a talk of mine on the subject, with the addition of synopses of the transcript).</p>

<p>Edit: The video links in the description of the talks are now broken. You can find the first two videos <a href="https://www.youtube.com/watch?v=1Sbzmz1Nxvo" rel="noreferrer">here</a> and <a href="https://www.youtube.com/watch?v=tJXhtncDBu4" rel="noreferrer">here</a>.</p>
<h4> Comment 105410684 Hybrid web dev: </h4>While a decent answer, it&#39;s also heavily self promotional.<br><h4> Comment 87071951 abarnert: </h4>@endolith Use leading underscore to signal to the reader of your code that they probably shouldn’t use this (e.g., because you might change it in version 2.0, or even 1.1); use explicit <code>__all__</code> whenever you want to make the module <code>from spam import *</code> friendly (including at the interactive interpreter). So most of the time, the answer is <i>both</i>.<br><h4> Comment 99493034 Marius Mucenicu: </h4>I like the C++ analogy. Firstly, I dislike it when people call the <code>_</code> <b>private</b>. Evidently I&#39;m talking about analogies, since nothing&#39;s truly <b>private</b> in Python. When diving into semantics I&#39;d say we can tie the <code>_</code> to Java&#39;s <b>protected</b> since <b>proctected</b> in Java means &quot;derived classes and/or within same package&quot;. Replace package with module since PEP8 already tells us that <code>_</code> is not just a convention when talking about <code>*</code> imports and there you have it. And definitely <code>__</code> would be equivalent to Java&#39;s <b>private</b> when talking about identifiers within a class.<br><h4> Comment 71059810 endolith: </h4>So how do you decide whether to use <code>_var_name</code> or use <code>var_name</code> + excluding it from <code>__all__</code>?<br><h4> Comment 91183070 Vicrobot: </h4>@AlexMartelli  Is this import related rule discussed legally somewhere in docs or elsewhere?<br><h4> Comment 91184146 Vicrobot: </h4>@AlexMartelli And why it doesn&#39;t import them? i mean; which processes are stopping the import of &#39;em?<br><h4> Comment 108086254 463035818_is_not_an_ai: </h4>I was a little confused by &quot;for example, names of methods that are fully intended to be overridden by subclasses [,,,]  that said methods are not meant to be called directly&quot; because when you override a method the name does not change. Only reading the next paragraph I understood what you mean<br><h4> Comment 101375621 Soren Bjornstad: </h4>@AlexMartelli: The links to your lectures presented here no longer work (after clicking on the link in this answer, the links on that page are broken). Is there an updated source?<br><h4> Comment 102141079 variable: </h4>Please can you update your answer with an example of double underscore with respect to inheritence?<br><h4> Comment 114234907 Mike mik: </h4>C++ <b>protected</b> members are not &quot;fully intended to be overridden by subclasses&quot;. They are member that can be accessed by same class or any derived classes (if public or protected derive access specifier is declared)<br><h4> Comment 132279929 The_spider: </h4>Just a question: Does <code>from module import _leading_underscore_name</code> still work?<br>------------------------------------------------------------------ <br><h3> Answer 12629901 NickCSE: </h3><p><code>._variable</code> is semiprivate and meant just for convention</p>

<p><code>.__variable</code> is often incorrectly considered superprivate, while it's actual meaning is just to namemangle to <strong>prevent accidental access</strong><a href="https://www.youtube.com/watch?v=HTLu2DFOdTg&amp;t=33m8s" rel="noreferrer">[1]</a></p>

<p><code>.__variable__</code> is typically reserved for builtin methods or variables</p>

<p>You can still access <code>.__mangled</code> variables if you desperately want to. The double underscores just namemangles, or renames, the variable to something like <code>instance._className__mangled</code></p>

<p>Example:</p>

<pre><code>class Test(object):
    def __init__(self):
        self.__a = 'a'
        self._b = 'b'

&gt;&gt;&gt; t = Test()
&gt;&gt;&gt; t._b
'b'
</code></pre>

<p>t._b is accessible because it is only hidden by convention</p>

<pre><code>&gt;&gt;&gt; t.__a
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
AttributeError: 'Test' object has no attribute '__a'
</code></pre>

<p>t.__a isn't found because it no longer exists due to namemangling</p>

<pre><code>&gt;&gt;&gt; t._Test__a
'a'
</code></pre>

<p>By accessing <code>instance._className__variable</code> instead of just the double underscore name, you can access the hidden value</p>
<h4> Comment 119072384 pdaawr: </h4><code>._variable</code>, according to the posts above and PEP-8, is not only a convention: &quot;<code>from M import *</code> does not import objects whose names start with an underscore.&quot;. However, in the presented case showing it as a class attribute, it doesn&#39;t change anything.<br><h4> Comment 76859658 Vitaliy Terziev: </h4>but how about if &quot;__a&quot; was a class variable, then you cannot access it even with the instructions from python docs..<br><h4> Comment 102141084 variable: </h4>Please can you update your answer with an example of double underscore with respect to inheritence?<br><h4> Comment 133414382 Amorphous: </h4><code>.__variable is often incorrectly considered superprivate</code> this is somewhat misleading. The double underscores, whiles does name mangle, does so in an attempt to make it <a href="https://docs.python.org/3/tutorial/classes.html#private-variables" rel="nofollow noreferrer">properly private</a>.<br><h4> Comment 136953851 Rubem Pacelli: </h4>@Amorphous this is not misleading since, as you said, it is just an attempt to make it private, but it is not really private as Python has no real private methods/attributes. Name mangling changes the variable namespace to avoid overwrite, but it is still accessible and modifiable.<br>------------------------------------------------------------------ <br><h3> Answer 27481645 PythonDev: </h3><p><strong>Single underscore at the beginning:</strong></p>
<p>Python doesn't have real private methods. Instead, one underscore at the start of a method or attribute name means you shouldn't access this method, because it's not part of the API.</p>
<pre><code>class BaseForm(StrAndUnicode):
    
    def _get_errors(self):
        &quot;Returns an ErrorDict for the data provided for the form&quot;
        if self._errors is None:
            self.full_clean()
        return self._errors

    errors = property(_get_errors)
</code></pre>
<p>(This code snippet was taken from Django source code: django/forms/forms.py). In this code, <code>errors</code> is a public property, but the method this property calls, _get_errors, is &quot;private&quot;, so you shouldn't access it.</p>
<p><strong>Two underscores at the beginning:</strong></p>
<p>This causes a lot of confusion. It should not be used to create a private method. It should be used to avoid your method being overridden by a subclass or accessed accidentally. Let's see an example:</p>
<pre><code>class A(object):
    def __test(self):
        print &quot;I'm a test method in class A&quot;

    def test(self):
        self.__test()
 
a = A()
a.test()
# a.__test() # This fails with an AttributeError
a._A__test() # Works! We can access the mangled name directly!
</code></pre>
<p>Output:</p>
<pre><code>$ python test.py
I'm test method in class A
I'm test method in class A
</code></pre>
<p>Now create a subclass B and do customization for __test method</p>
<pre><code>class B(A):
    def __test(self):
        print &quot;I'm test method in class B&quot;

b = B()
b.test()
</code></pre>
<p>The output will be...</p>
<pre><code>$ python test.py
I'm test method in class A
</code></pre>
<p>As we have seen, B.test() didn't call B.__test() methods, as we might expect. But in fact, this is the correct behavior for __. The two methods called __test() are automatically renamed (mangled) to _A__test() and _B__test(), so they do not accidentally override.  When you create a method starting with __ it means that you don't want anyone to be able to override it, and you only intend to access it from inside its own class.</p>
<p><strong>Two underscores at the beginning and at the end:</strong></p>
<p>When we see a method like <code>__this__</code>, don't call it. This is a method which Python is meant to call, not you. Let's take a look:</p>
<pre><code>&gt;&gt;&gt; name = &quot;test string&quot;
&gt;&gt;&gt; name.__len__()
11
&gt;&gt;&gt; len(name)
11

&gt;&gt;&gt; number = 10
&gt;&gt;&gt; number.__add__(40)
50
&gt;&gt;&gt; number + 50
60
</code></pre>
<p>There is always an operator or native function which calls these magic methods. Sometimes it's just a hook Python calls in specific situations. For example <code>__init__()</code> is called when the object is created after <code>__new__()</code> is called to build the instance...</p>
<p>Let's take an example...</p>
<pre><code>class FalseCalculator(object):

    def __init__(self, number):
        self.number = number

    def __add__(self, number):
        return self.number - number

    def __sub__(self, number):
        return self.number + number

number = FalseCalculator(20)
print number + 10      # 10
print number - 20      # 40
</code></pre>
<p>For more details, see the <a href="https://www.python.org/dev/peps/pep-0008/#method-names-and-instance-variables" rel="noreferrer">PEP-8 guide</a>. For more magic methods, see <a href="//github.com/RafeKettler/magicmethods/blob/master/magicmethods.pdf" rel="noreferrer">this PDF</a>.</p>
<h4> Comment 90861457 Josiah Yoder: </h4>After editing this answer myself, I prefer <a href="https://stackoverflow.com/a/8689983/1048186">stackoverflow.com/a/8689983/1048186</a><br><h4> Comment 102140261 variable: </h4>What do you mean by &quot;As we have seen, A.test() didn&#39;t call B.__test() methods&quot; - where have you called A.test()?<br><h4> Comment 132548353 adkl: </h4>@variable He meant B.test(), I corrected it!<br>------------------------------------------------------------------ <br><h3> Answer 59066258 Feuda: </h3><p>According to <a href="https://dbader.org/blog/meaning-of-underscores-in-python" rel="noreferrer">Meaning of Underscores in Python</a></p>
<ul>
<li><strong>Single Leading Underscore(<code>_var</code>)</strong>: Naming convention indicating a name is meant for internal use. Generally not enforced by the Python interpreter (except in wildcard imports) and meant as a hint to the programmer only.</li>
<li><strong>Single Trailing Underscore(<code>var_</code>)</strong>: Used by convention to avoid naming conflicts with Python keywords.</li>
<li><strong>Double Leading Underscore(<code>__var</code>)</strong>: Triggers name mangling when used in a class context. Enforced by the Python interpreter.</li>
<li><strong>Double Leading and Trailing Underscore(<code>__var__</code>)</strong>: Indicates special methods defined by the Python language. Avoid this naming scheme for your own attributes.</li>
<li><strong>Single Underscore(<code>_</code>)</strong>: Sometimes used as a name for temporary or insignificant variables (“don’t care”). Also: The result of the last expression in a Python <a href="https://pythonprogramminglanguage.com/repl/" rel="noreferrer">REPL</a>.</li>
</ul>
------------------------------------------------------------------ <br><h3> Answer 8822881 Tim D: </h3><p>Sometimes you have what appears to be a tuple with a leading underscore as in </p>

<pre><code>def foo(bar):
    return _('my_' + bar)
</code></pre>

<p>In this case, what's going on is that _() is an alias for a localization function that operates on text to put it into the proper language, etc. based on the locale. For example, Sphinx does this, and you'll find among the imports</p>

<pre><code>from sphinx.locale import l_, _
</code></pre>

<p>and in sphinx.locale, _() is assigned as an alias of some localization function.</p>
<h4> Comment 133827847 Nate Anderson: </h4>Yes this answer is helpful ; the <a href="https://pymotw.com/3/gettext/" rel="nofollow noreferrer"><code>gettext</code> module</a> describes this pattern &quot;gettext works by looking up literal strings in a database of translations, and pulling out the appropriate translated string. The usual pattern is to bind the appropriate lookup function to the name “_” (a single underscore character) so that the code is not cluttered with a lot of calls to functions with longer names.&quot; Maybe that&#39;s what sphinx is doing &quot;under the hood&quot;; soemthing like the example<code>t = gettext.translation(&#39;example_domain&#39;, &#39;locale&#39;, fallback=True);  _ = t.gettext</code><br><h4> Comment 133828187 Nate Anderson: </h4>I <b>could not find the import or creation of the <code>_</code> localization function</b> in my project. I realized my project uses <a href="https://docs.python.org/3/library/gettext.html#gettext.install" rel="nofollow noreferrer"><code>gettext.install(...)</code></a>, which &quot;installs the function _() <b>in Python’s builtins namespace</b>...&quot;, a technique of the <a href="https://docs.python.org/3/library/gettext.html#class-based-api" rel="nofollow noreferrer">&quot;class-based API&quot;</a> of the <code>gettext</code> module (vs using the API directly <code>gettext.gettext(...)</code>). More on built-ins vs a module&#39;s global namespace <a href="https://docs.python.org/3/library/gettext.html#gettext.NullTranslations.install" rel="nofollow noreferrer">here</a><br>------------------------------------------------------------------ <br><h3> Answer 52903693 laike9m: </h3><p>Since so many people are referring to Raymond's <a href="https://www.youtube.com/watch?v=HTLu2DFOdTg&amp;t=33m8s" rel="noreferrer">talk</a>, I'll just make it a little easier by writing down what he said:</p>

<blockquote>
  <p>The intention of the double underscores was not about privacy. The intention was to use it exactly like this</p>

<pre><code>class Circle(object):

    def __init__(self, radius):
        self.radius = radius

    def area(self):
        p = self.__perimeter()
        r = p / math.pi / 2.0
        return math.pi * r ** 2.0

    def perimeter(self):
        return 2.0 * math.pi * self.radius

    __perimeter = perimeter  # local reference


class Tire(Circle):

    def perimeter(self):
        return Circle.perimeter(self) * 1.25
</code></pre>
  
  <p><strong>It's actually the opposite of privacy, it's all about freedom. It makes your subclasses free to override any one method without breaking the others</strong>.</p>
</blockquote>

<p>Say you don't keep a local reference of <code>perimeter</code> in <code>Circle</code>. Now, a derived class <code>Tire</code> overrides the implementation of <code>perimeter</code>, without touching <code>area</code>. When you call <code>Tire(5).area()</code>, in theory it should still be using <code>Circle.perimeter</code> for computation, but in reality it's using <code>Tire.perimeter</code>, which is not the intended behavior. That's why we need a local reference in Circle.</p>

<p>But why <code>__perimeter</code> instead of <code>_perimeter</code>? Because <code>_perimeter</code> still gives derived class the chance to override:</p>

<pre><code>class Tire(Circle):

    def perimeter(self):
        return Circle.perimeter(self) * 1.25

    _perimeter = perimeter
</code></pre>

<p>Double underscores has name mangling, so there's a very little chance that the local reference in parent class get override in derived class. thus "<strong>makes your subclasses free to override any one method without breaking the others</strong>".</p>

<p>If your class won't be inherited, or method overriding does not break anything, then you simply don't need <code>__double_leading_underscore</code>.</p>
<h4> Comment 103509808 cgte: </h4>Thank you, the slide did not display properly so i ended up not untersanting why my code would fail.<br><h4> Comment 118124593 Gringo Suave: </h4>Hmm, I got the same answer whether perimeter had leading dunder or not.<br>------------------------------------------------------------------ <br><h3> Answer 65597366 Mathieu Rollet: </h3><ul>
<li><p><code>_var</code>: variables with a leading single underscore in python are classic variables, intended to inform others using your code that this variable should be reserved for internal use. They differ on one point from classic variables: they are not imported when doing a wildcard import of an object/module where they are defined (exceptions when defining the <a href="https://stackoverflow.com/a/64130/3922534"><code>__all__</code> variable</a>). Eg:</p>
<pre class="lang-py prettyprint-override"><code># foo.py

var = &quot;var&quot;
_var = &quot;_var&quot;
</code></pre>
<pre class="lang-py prettyprint-override"><code># bar.py

from foo import *

print(dir())  # list of defined objects, contains 'var' but not '_var'
print(var)    # var
print(_var)   # NameError: name '_var' is not defined
</code></pre>
</li>
<li><p><code>_</code> : the single underscore is a special case of the leading single underscore variables. It is used by convention as a trash variable, to store a value that is not intended to be later accessed. It is also not imported by wildcard imports. Eg: this <code>for</code> loop prints &quot;I must not talk in class&quot; 10 times, and never needs to access the <code>_</code> variable.</p>
<pre class="lang-py prettyprint-override"><code>for _ in range(10):
    print(&quot;I must not talk in class&quot;)
</code></pre>
</li>
<li><p><code>var_</code>: single trailing underscore variables. They are classic variables used by convention to avoid conflicts with Python keyword. Eg:</p>
<pre class="lang-py prettyprint-override"><code>class_ = &quot;MyClassName&quot;
</code></pre>
</li>
<li><p><code>__var</code>: double leading underscore variables (at least two leading underscores, at most one trailing underscore). When used as class attributes (variables and methods), these variables are subject to name mangling: outside of the class, python will rename the attribute to <code>_&lt;Class_name&gt;__&lt;attribute_name&gt;</code>. Example:</p>
<pre class="lang-py prettyprint-override"><code>class MyClass:
    __an_attribute = &quot;attribute_value&quot;

my_class = MyClass()
print(my_class._MyClass__an_attribute)  # &quot;attribute_value&quot;
print(my_class.__an_attribute)  # AttributeError: 'MyClass' object has no attribute '__an_attribute'
</code></pre>
<p>When used as variables outside a class, they behave like single leading underscore variables.</p>
</li>
<li><p><code>__var__</code>: double leading and trailing underscore variables (at least two leading and trailing underscores). Also called <em>dunders</em>. This naming convention is used by python to define variables internally. Avoid using this convention to prevent name conflicts that could arise with python updates. Dunder variables behave like single leading underscore variables: they are not subject to name mangling when used inside classes, but are not imported in wildcard imports.</p>
</li>
</ul>
------------------------------------------------------------------ <br><h3> Answer 16006566 Dev Maha: </h3><p>If one really wants to make a variable read-only, IMHO the best way would be to use property() with only getter passed to it. With property() we can have complete control over the data.</p>

<pre><code>class PrivateVarC(object):

    def get_x(self):
        pass

    def set_x(self, val):
        pass

    rwvar = property(get_p, set_p)  

    ronly = property(get_p) 
</code></pre>

<p>I understand that OP asked a little different question but since I found another question asking for 'how to set private variables' marked duplicate with this one, I thought of adding this additional info here.</p>
<h4> Comment 135477444 TheLizzard: </h4>Just to add: using <code>propeety</code> as a method decorator is a bit cleaner.<br>------------------------------------------------------------------ <br><h3> Answer 54298590 grepit: </h3><p>Great answers and all are correct.I have provided simple example along with simple definition/meaning. </p>

<p>Meaning:</p>

<p>some_variable --► it's public anyone can see this.</p>

<p>_some_variable --► it's public anyone can see this but it's a convention to indicate private...<strong>warning</strong> no enforcement is done by Python.</p>

<p>__some_varaible  --► Python replaces the variable name with _classname__some_varaible (AKA name mangling) and it reduces/hides it's visibility and be more like private variable.</p>

<p>Just to be honest here <a href="https://docs.python.org/3/tutorial/classes.html#tut-private" rel="noreferrer">According to Python documentation</a> </p>

<blockquote>
  <p>"“Private” instance variables that cannot be accessed except from
  inside an object don’t exist in Python"</p>
</blockquote>

<p>The example:</p>

<pre><code>class A():
    here="abc"
    _here="_abc"
    __here="__abc"


aObject=A()
print(aObject.here) 
print(aObject._here)
# now if we try to print __here then it will fail because it's not public variable 
#print(aObject.__here)
</code></pre>
<h4> Comment 106431117 AMC: </h4>_ <i>_some_varaible --</i> .... <i>and it reduces/hides it&#39;s visibility and be more like private variable.</i> No, name mangling is the point, it doesn&#39;t hide the method.<br>------------------------------------------------------------------ <br><h3> Answer 25454077 Marc: </h3><p>Here is a simple illustrative example on how double underscore properties can affect an inherited class. So with the following setup:</p>

<pre><code>class parent(object):
    __default = "parent"
    def __init__(self, name=None):
        self.default = name or self.__default

    @property
    def default(self):
        return self.__default

    @default.setter
    def default(self, value):
        self.__default = value


class child(parent):
    __default = "child"
</code></pre>

<p>if you then create a child instance in the python REPL, you will see the below</p>

<pre><code>child_a = child()
child_a.default            # 'parent'
child_a._child__default    # 'child'
child_a._parent__default   # 'parent'

child_b = child("orphan")
## this will show 
child_b.default            # 'orphan'
child_a._child__default    # 'child'
child_a._parent__default   # 'orphan'
</code></pre>

<p>This may be obvious to some, but it caught me off guard in a much more complex environment</p>
------------------------------------------------------------------ <br><h3> Answer 1301384 SilentGhost: </h3><p>Single leading underscores is a convention. there is no difference from the interpreter's point of view if whether names starts with a single underscore or not. </p>

<p>Double leading and trailing underscores are used for built-in methods, such as <code>__init__</code>, <code>__bool__</code>, etc.</p>

<p>Double leading underscores w/o trailing counterparts are a convention too, however, the class methods will be <a href="http://docs.python.org/tutorial/classes.html#private-variables" rel="noreferrer">mangled</a> by the interpreter. For variables or basic function names no difference exists.</p>
------------------------------------------------------------------ <br><h3> Answer 1301456 u0b34a0f6ae: </h3><p>Your question is good, it is not only about methods. Functions and objects in modules are commonly prefixed with one underscore as well, and can be prefixed by two.</p>

<p>But __double_underscore names are not name-mangled in modules, for example. What happens is that names beginning with one (or more) underscores are not imported if you import all from a module (from module import *), nor are the names shown in help(module).</p>
<h4> Comment 12867691 Bentley4: </h4>Furthermore, names beginning with one or more underscores that have two or more trailing underscores behave as any other name again.<br>------------------------------------------------------------------ <br><h3> Answer 28385489 aptro: </h3><p>“Private” instance variables that cannot be accessed except from inside an object don’t exist in Python. However, there is a convention that is followed by most Python code: a name prefixed with an underscore (e.g. _spam) should be treated as a non-public part of the API (whether it is a function, a method or a data member). It should be considered an implementation detail and subject to change without notice.</p>

<p>reference
<a href="https://docs.python.org/2/tutorial/classes.html#private-variables-and-class-local-references" rel="nofollow">https://docs.python.org/2/tutorial/classes.html#private-variables-and-class-local-references</a></p>
<h4> Comment 81163003 Ini: </h4>_ is much more similar to for example internal in c# then to private. Double underscore it much more similar to private then underscore is to private I would say.<br>------------------------------------------------------------------ <br><h3> Answer 47113678 Ini: </h3><p>Getting the facts of _ and __ is pretty easy; the other answers express them pretty well. The usage is much harder to determine. </p>

<p>This is how I see it:</p>

<pre><code>_
</code></pre>

<p>Should be used to indicate that a function is not for public use as for example an API. This and the import restriction make it behave much like <code>internal</code> in c#.</p>

<pre><code>__
</code></pre>

<p>Should be used to avoid name collision in the inheritace hirarchy and to avoid latebinding. Much like private in c#.</p>

<p>==> </p>

<p>If you want to indicate that something is not for public use, but it should act like <code>protected</code> use <code>_</code>.
If you want to indicate that something is not for public use, but it should act like <code>private</code> use <code>__</code>.</p>

<p>This is also a quote that I like very much:</p>

<blockquote>
  <p>The problem is that the author of a class may legitimately think "this
  attribute/method name should be private, only accessible from within
  this class definition" and use the __private convention. But later on,
  a user of that class may make a subclass that legitimately needs
  access to that name. So either the superclass has to be modified
  (which may be difficult or impossible), or the subclass code has to
  use manually mangled names (which is ugly and fragile at best).</p>
</blockquote>

<p>But the problem with that is in my opinion that if there's no IDE that warns you when you override methods, finding the error might take you a while if you have accidentially overriden a method from a base-class.</p>
------------------------------------------------------------------ <br><h3> Answer 65415422 Timothy C. Quinn: </h3><p>In the case of methods, you can use the double underscore to hide away private 'methods' with the following pattern:</p>
<pre><code># Private methods of MyClass
def _MyClass__do_something(obj:'MyClass'):
    print('_MyClass__do_something() called. type(obj) = {}'.format(type(obj)))

class MyClass():
    def __init__(self):
        __do_something(self)

mc = MyClass()
</code></pre>
<p>Output:</p>
<pre><code>_MyClass__do_something() called. type(obj) = &lt;class '__main__.MyClass'&gt;
</code></pre>
<p>I stumbled across this today when I tried using double underscore for class methods and got the <code>NameError: name '_&lt;class&gt;&lt;method&gt;' is not defined</code> error.</p>
------------------------------------------------------------------ <br><h3> Answer 74291418 Karim Baidar: </h3><p>To frame it in simple words, let us compare python's variables' accessibility conventions to access modifiers in Java:</p>
<pre><code>(Python)                                     =   (Java)
_single_underscore_variable                  =   Protected (Accessible to class and its subclasses)
__double_underscore_variable                 =   Private (Accessible to class itself only)
no_underscore_variable                       =   Public (Accessible anywhere)
</code></pre>
<p><strong>Reference</strong>: <a href="https://www.tutorialsteacher.com/python/public-private-protected-modifiers" rel="nofollow noreferrer">https://www.tutorialsteacher.com/python/public-private-protected-modifiers</a></p>
