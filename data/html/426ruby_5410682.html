 <h2> Title: Parsing a JSON string in Ruby </h2> <h4> Rod, question_id: 5410682, created_at: 2011-03-23 19:39:08+00:00 </h4>Score: 426, Tags: {ruby,json} <br><p>I have a string that I want to parse in Ruby:</p>

<pre><code>string = '{"desc":{"someKey":"someValue","anotherKey":"value"},"main_item":{"stats":{"a":8,"b":12,"c":10}}}'
</code></pre>

<p>Is there an easy way to extract the data?</p>
<h4> Comment by the Tin Man, Score: 27, Id: 55004101, created_at: 2015-11-09 17:41:17+00:00 </h4><i>JSON is directly supported in Ruby, and has been since at least Ruby v1.9.3, so there is no need to install a gem unless you&#39;re using something older. Simply use <code>require &#39;json&#39;</code> in your code.</i><hr><h3>  Answer by keymone, Id: 5410710, Score: 18, created_at: 2011-03-23 19:41:13+00:00 </h3><p>It looks like a JSON string.  You can use one of many JSON libraries and it's as simple as doing:</p>

<pre><code>JSON.parse(string)
</code></pre>
<hr><h3> ✔️ Answer by Greg, Id: 5410713, Score: 642, created_at: 2011-03-23 19:41:42+00:00 </h3><p>This looks like <a href="http://www.json.org" rel="noreferrer">JavaScript Object Notation (JSON)</a>. You can parse JSON that resides in some variable, e.g. <code>json_string</code>, like so:</p>

<pre><code>require 'json'
JSON.parse(json_string)
</code></pre>

<p>If you’re using an older Ruby, you may need to install the <a href="https://rubygems.org/gems/json" rel="noreferrer">json gem</a>.</p>

<hr>

<p>There are also other implementations of JSON for Ruby that may fit some use-cases better:</p>

<ul>
<li><a href="https://rubygems.org/gems/yajl-ruby" rel="noreferrer">YAJL C Bindings for Ruby</a></li>
<li><a href="https://rubygems.org/gems/json-stream" rel="noreferrer">JSON::Stream</a></li>
</ul>
<h4> Comment by Nando, Score: 43, Id: 34766758, created_at: 2014-04-02 00:25:22+00:00 </h4>Also you can sets the option symbolize_names to true, in order to get keys as symbols. Exemple: <code>JSON.parse(string, symbolize_names: true) #=&gt; {key: :value}</code><h4> Comment by the Tin Man, Score: 33, Id: 55004218, created_at: 2015-11-09 17:44:48+00:00 </h4><i>JSON is directly supported in Ruby, and has been since at least Ruby v1.9.3, so there is no need to install a gem unless you&#39;re using something older. Simply use <code>require &#39;json&#39;</code> in your code.</i><hr><h3>  Answer by nevan king, Id: 13625633, Score: 239, created_at: 2012-11-29 12:15:37+00:00 </h3><p>Just to extend the answers a bit with what to do with the parsed object:</p>

<pre><code># JSON Parsing example
require "rubygems" # don't need this if you're Ruby v1.9.3 or higher
require "json"

string = '{"desc":{"someKey":"someValue","anotherKey":"value"},"main_item":{"stats":{"a":8,"b":12,"c":10}}}'
parsed = JSON.parse(string) # returns a hash

p parsed["desc"]["someKey"]
p parsed["main_item"]["stats"]["a"]

# Read JSON from a file, iterate over objects
file = open("shops.json")
json = file.read

parsed = JSON.parse(json)

parsed["shop"].each do |shop|
  p shop["id"]
end
</code></pre>
<h4> Comment by Ziggy, Score: 9, Id: 31805353, created_at: 2014-01-15 10:33:08+00:00 </h4>Important note: <code>&#39;{ &quot;a&quot;: &quot;bob&quot; }&#39;</code> is valid. <code>&quot;{ &#39;a&#39;: &#39;bob&#39; }&quot;</code> is not.<h4> Comment by endorama, Score: 7, Id: 35156699, created_at: 2014-04-11 14:46:31+00:00 </h4>@LinusAn because JSON requires double quotes around strings. See string in the JSON definition ( <a href="http://www.json.org/" rel="nofollow noreferrer">json.org</a> ): &quot;A string is a sequence of zero or more Unicode characters, wrapped in double quotes, using backslash escapes.&quot;<h4> Comment by johnml, Score: 1, Id: 37246948, created_at: 2014-06-10 10:48:59+00:00 </h4>In many cases you want to wrap <code>JSON.parse</code> within a rescue block for <code>JSON::ParserError</code>.<h4> Comment by barlop, Score: 1, Id: 99388001, created_at: 2019-05-31 12:04:50+00:00 </h4>Can you make your answer complete by including a sample example data from shops.json?<h4> Comment by Rivenfall, Score: 0, Id: 59736251, created_at: 2016-03-16 18:14:14+00:00 </h4><code>JSON.parse(&quot;[#{value}]&quot;)[0]</code> to avoid the error <code>A JSON text must at least contain two octets!</code><hr><h3>  Answer by dav_i, Id: 34295262, Score: 42, created_at: 2015-12-15 17:07:49+00:00 </h3><p>As of Ruby v1.9.3 you don't need to install any Gems in order to parse JSON, simply use <code>require 'json'</code>:</p>

<pre><code>require 'json'

json = JSON.parse '{"foo":"bar", "ping":"pong"}'
puts json['foo'] # prints "bar"
</code></pre>

<p>See <a href="http://ruby-doc.org/stdlib-2.0.0/libdoc/json/rdoc/JSON.html" rel="noreferrer">JSON</a> at Ruby-Doc.</p>
<hr><h3>  Answer by Adverbly, Id: 64065140, Score: 10, created_at: 2020-09-25 13:30:40+00:00 </h3><p>Don't see any answers here that mention parsing directly to an object other than a Hash, but it is possible using the poorly-documented object_class option(see <a href="https://ruby-doc.org/stdlib-2.7.1/libdoc/json/rdoc/JSON.html" rel="noreferrer">https://ruby-doc.org/stdlib-2.7.1/libdoc/json/rdoc/JSON.html</a>):</p>
<pre><code>JSON.parse('{&quot;foo&quot;:{&quot;bar&quot;: 2}}', object_class: OpenStruct).foo.bar
=&gt; 2
</code></pre>
<p>The better way to read that option is &quot;The ruby class that a json object turns into&quot;, which explains why it defaults to Hash. Likewise, there is an array_class option for json arrays.</p>
<hr><h3>  Answer by guy mograbi, Id: 26493639, Score: 7, created_at: 2014-10-21 18:25:03+00:00 </h3><p>This is a bit late but I ran into something interesting that seems important to contribute. </p>

<p>I accidentally wrote this code, and it seems to work:</p>

<pre><code>require 'yaml'
CONFIG_FILE = ENV['CONFIG_FILE'] # path to a JSON config file 
configs = YAML.load_file("#{CONFIG_FILE}")
puts configs['desc']['someKey']
</code></pre>

<p>I was surprised to see it works since I am using the YAML library, but it works. </p>

<p>The reason why it is important is that <code>yaml</code> comes built-in with Ruby so there's no gem install.</p>

<p>I am using versions 1.8.x and 1.9.x - so the <code>json</code> library is not built in, but it is in version 2.x. </p>

<p>So technically - this is the easiest way to extract the data in version lower than 2.0. </p>
<h4> Comment by Justin Ohms, Score: 3, Id: 64299880, created_at: 2016-07-18 23:05:30+00:00 </h4>The reason this works is that semantically (most) JSON is valid YAML (particularly YAML 1.2)<h4> Comment by Nakilon, Score: 0, Id: 132044018, created_at: 2022-12-16 02:47:47+00:00 </h4>I get &quot;undefined method `load_file&#39; for JSON:Module&quot; on ruby 2.3.8<h4> Comment by the Tin Man, Score: 0, Id: 55004141, created_at: 2015-11-09 17:42:21+00:00 </h4>Yes, JSON is actually parsed by the Psych code, which also parses YAML in Ruby. And JSON parsing was introduced in <a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/json/rdoc/index.html" rel="nofollow noreferrer">Ruby v1.9.3</a>.<hr><h3>  Answer by damianmr, Id: 25850734, Score: 4, created_at: 2014-09-15 14:45:13+00:00 </h3><p>I suggest Oj as it is waaaaaay faster than the standard JSON library.</p>

<p><a href="https://github.com/ohler55/oj" rel="nofollow">https://github.com/ohler55/oj</a></p>

<p>(<a href="https://github.com/ohler55/oj#performance-comparisons" rel="nofollow">see performance comparisons here</a>)</p>
<hr><h3>  Answer by Erik Madsen, Id: 69773628, Score: 3, created_at: 2021-10-29 18:58:58+00:00 </h3><p>If you want to deserialise to your own class instead of OpenStruct it doesn't take a lot of work to make the following possible:</p>
<pre class="lang-rb prettyprint-override"><code>require 'json'
# result is an instance of MyClass
result = JSON.parse(some_json_string, object_class: MyClass)
</code></pre>
<p>All you have to do is to provide a zero-argument constructor and implement the <code>#[]=</code> method which <code>JSON.parse</code> will call. If you don't want to expose it, it's sufficient to let it be private:</p>
<pre class="lang-rb prettyprint-override"><code>class MyClass
  attr_reader :a, :b

  private

  def []=(key, value)
    case key
    when 'a' then @a = value
    when 'b' then @b = value
    end
  end
end
</code></pre>
<p>Trying it out in irb:</p>
<pre><code>&gt; JSON.parse('{&quot;a&quot;:1, &quot;b&quot;:2}', object_class: MyClass)
=&gt; #&lt;MyClass:0x00007fe00913ae98 @a=1, @b=2&gt;
</code></pre>
<p>A caveat with this approach is that it only works for flat structures, because the <code>object_class</code> argument really tells the parser what class it should use to deserialise JSON objects in the string instead of <code>Hash</code> (see the similar argument <code>array_class</code> for the analogous operation for JSON arrays). For nested structures this will mean you will use the same class to represent all layers:</p>
<pre><code>&gt; JSON.parse('{&quot;a&quot;:1, &quot;b&quot;:{ &quot;a&quot;: 32 }}', object_class: MyClass)
=&gt; #&lt;MyClass:0x00007fb5110b2b38 @a=1, @b=#&lt;MyClass:0x00007fb5110b2908 @a=32&gt;&gt;
</code></pre>
