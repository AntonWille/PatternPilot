 <h2> Title: How do I tell if a variable has a numeric value in Perl? </h2> <h3> Derek Park, question_id: 12647 </h3>Score: 101, Tags: {perl,numbers} <br><p>Is there a simple way in Perl that will allow me to determine if a given variable is numeric?  Something along the lines of:</p>

<pre><code>if (is_number($x))
{ ... }
</code></pre>

<p>would be ideal.  A technique that won't throw warnings when the <code>-w</code> switch is being used is certainly preferred.</p>
------------------------------------------------------------------ <br><h3> Answer 28589 nohat: </h3><p>Use <code>Scalar::Util::looks_like_number()</code> which uses the internal Perl C API's looks_like_number() function, which is probably the most efficient way to do this.
Note that the strings "inf" and "infinity" are treated as numbers.</p>

<h2>Example:</h2>

<pre><code>#!/usr/bin/perl

use warnings;
use strict;

use Scalar::Util qw(looks_like_number);

my @exprs = qw(1 5.25 0.001 1.3e8 foo bar 1dd inf infinity);

foreach my $expr (@exprs) {
    print "$expr is", looks_like_number($expr) ? '' : ' not', " a number\n";
}
</code></pre>

<p>Gives this output:</p>

<pre><code>1 is a number
5.25 is a number
0.001 is a number
1.3e8 is a number
foo is not a number
bar is not a number
1dd is not a number
inf is a number
infinity is a number
</code></pre>

<h2>See also:</h2>

<ul>
<li><a href="http://perldoc.perl.org/Scalar/Util.html" rel="noreferrer">perldoc Scalar::Util</a></li>
<li><a href="http://perldoc.perl.org/perlapi.html#SV-Body-Allocation" rel="noreferrer">perldoc perlapi</a> for <code>looks_like_number</code></li>
</ul>
<h4> Comment 17554461 MkV: </h4>The description in Scalar::Util is fine, looks_like_number tells you if your input is something that Perl would treat as a number, which is not necessarily the best answer for this question.  The mention of atof is irrelevant, atof isn&#39;t part of CORE:: or POSIX (you should be looking at strtod which has subsumed atof and /is/ part of POSIX) and assuming that what Perl thinks is a number is valid numeric input to C functions is obviously very wrong.<br><h4> Comment 4099338 Day: </h4>And as usual with perl docs, finding the actual <i>definition</i> of what the function does is rather difficult. Following the trail <code>perldoc perlapi</code> tells us: Test if the content of an SV looks like a number (or is a number).  &quot;Inf&quot; and &quot;Infinity&quot; are treated as numbers (so will not issue a non-numeric warning), even if your atof() doesn&#39;t grok them. Hardly a testable spec...<br><h4> Comment 67210904 Adam Katz: </h4>Note: hexadecimal strings like <code>0x12</code> are <i>not</i> considered numbers by this test.<br><h4> Comment 84514894 haukex: </h4><code>looks_like_number</code> exposes the <a href="http://perldoc.perl.org/perlapi.html#looks_like_number" rel="nofollow noreferrer">internal function</a> that is the same as what Perl uses to magically convert strings to numbers. Underscores, hex, octal, and binary numbers are only allowed as literals in the source, not strings, so e.g. <code>0+&quot;0x15&quot;</code> does not work right. (Note that <code>looks_like_number(&quot;0 but true&quot;)</code> is true! :-) <a href="http://perldoc.perl.org/functions/fcntl.html" rel="nofollow noreferrer">reference</a>)<br><h4> Comment 50542364 Dave Jacoby: </h4>I like this function in general, but consider large ints. 1000000 is a lot of zeros to keep track of, begging for error, but 1,000,000 is seen as a three-element array, so Perl accepts 1_000_000, but looks_like_number() says no. Makes me sad.<br><h4> Comment 48579514 Znik: </h4>very nice function :) for undef and non number strings returns 0, for number strings returns 1, for integers returns 4352 and for floats returns 8704  :) generally &gt;0 number is detected. I have tested it under linux.<br>------------------------------------------------------------------ <br><h3> Answer 12742 naumcho: </h3><p>Check out the CPAN module <a href="http://search.cpan.org/dist/Regexp-Common" rel="noreferrer">Regexp::Common</a>. I think it does exactly what you need and handles all the edge cases (e.g. real numbers, scientific notation, etc). e.g.</p>

<pre><code>use Regexp::Common;
if ($var =~ /$RE{num}{real}/) { print q{a number}; }
</code></pre>
------------------------------------------------------------------ <br><h3> Answer 3806159 ysth: </h3><p>The original question was how to tell if a variable was numeric, not if it "has a numeric value".</p>

<p>There are a few operators that have separate modes of operation for numeric and string operands, where "numeric" means anything that was originally a number or was ever used in a numeric context (e.g. in <code>$x = "123"; 0+$x</code>, before the addition, <code>$x</code> is a string, afterwards it is considered numeric).</p>

<p>One way to tell is this:</p>

<pre><code>if ( length( do { no warnings "numeric"; $x &amp; "" } ) ) {
    print "$x is numeric\n";
}
</code></pre>

<p>If the bitwise feature is enabled, that makes <code>&amp;</code> only a numeric operator and adds a separate string <code>&amp;.</code> operator, you must disable it:</p>

<pre><code>if ( length( do { no if $] &gt;= 5.022, "feature", "bitwise"; no warnings "numeric"; $x &amp; "" } ) ) {
    print "$x is numeric\n";
}
</code></pre>

<p>(bitwise is available in perl 5.022 and above, and enabled by default if you <code>use 5.028;</code> or above.)</p>
<h4> Comment 102019424 ysth: </h4>@yogibimbi seems most likely to me you weren&#39;t running the code you thought you were<br><h4> Comment 23156374 yogibimbi: </h4>If I package your routine into a sub, I get  a strange behaviour in that it detects non-numeric values correctly, until I try out the first numeric value, which is also detected correctly as true, but then, everything else from there on out is also true. When I put an eval around the length(...) part, however, it works fine all of the time. Any idea what I was missing? <code>sub numeric {       $obj = shift;     no warnings &quot;numeric&quot;;     return eval(&#39;length($obj &amp; &quot;&quot;)&#39;); }</code><br><h4> Comment 23159480 ysth: </h4>@yogibimbi: you are reusing the same $obj variable each time; try <code>my $obj = shift;</code>.  Why the eval?<br><h4> Comment 23201881 yogibimbi: </h4>oops, my bad, I used <code>my $obj = shift</code>, of course, just did not transfer it correctly from my code to the comment, I edited it a bit. However, <code>sub numeric { my $obj = shift; no warnings &quot;numeric&quot;; return length($obj &amp; &quot;&quot;); }</code> produces the same error. Of course, having a clandestine global variable would explain the behaviour, it is exactly what I would expect in that case, but unfortunately, it&#39;s not that simple. Also, that would be caught by <code>strict</code> &amp; <code>warnings</code>. I tried the eval in a rather desperate attempt to get rid of the error, and it worked. No deeper reasoning, just trial &amp; error.<br><h4> Comment 23202243 yogibimbi: </h4>Check it out: <code>sub numeric { my $obj = shift; no warnings &quot;numeric&quot;; return length($obj &amp; &quot;&quot;); }</code>  <code>print numeric(&quot;w&quot;) . &quot;\n&quot;; #=&gt;0</code>, <code>print numeric(&quot;x&quot;) . &quot;\n&quot;; #=&gt;0</code>, <code>print numeric(&quot;1&quot;) . &quot;\n&quot;; #=&gt;0</code>, <code>print numeric(3) . &quot;\n&quot;; #=&gt;1</code>, <code>print numeric(&quot;w&quot;) . &quot;\n&quot;; #=&gt;1</code>. If you put an eval(&#39;&#39;) around the length, the last print would give a 0, like it should. Go figure.<br>------------------------------------------------------------------ <br><h3> Answer 12667 andrewrk: </h3><p>Usually number validation is done with regular expressions. This code will determine if something is numeric as well as check for undefined variables as to not throw warnings:</p>

<pre><code>sub is_integer {
   defined $_[0] &amp;&amp; $_[0] =~ /^[+-]?\d+$/;
}

sub is_float {
   defined $_[0] &amp;&amp; $_[0] =~ /^[+-]?\d+(\.\d+)?$/;
}
</code></pre>

<p>Here's some <a href="http://www.perl.com/doc/FMTEYEWTK/is_numeric.html" rel="noreferrer">reading material</a> you should look at.</p>
<h4> Comment 41989242 osirisgothra: </h4>I do think this digresses a bit, especially when the asker said /simple/. Many cases, including scientific notation, are hardly simple. Unless using this for a module, i would not worry about such details. Sometimes simplicity is best. Don&#39;t put the chocolate syrup in the cow to make chocolate milk!<br><h4> Comment 66095423 Adam Katz: </h4>The <code>\d*\.?\d+</code> part introduces a <a href="https://en.wikipedia.org/wiki/ReDoS" rel="nofollow noreferrer">ReDoS</a> risk.  I recommend <code>&#47;^[+-]?(?!\.(?!\d)|$)\d*(?:\.\d*)?$&#47;</code> or <code>&#47;^[+-]?(?!\.(?!\d)|$)\d*(?:\.\d*)?(?:(?&lt;=[\d.])e[+-]?\d+)?$&#47;&zwnj;&#8203;i</code> to include scientific notation (<a href="https://regex101.com/r/fX6cW5/3" rel="nofollow noreferrer">explanation and examples</a>) instead.  This uses a doubled negative lookahead to also prevent strings like <code>.</code> and <code>.e0</code> from passing as numbers.  It also uses a positive lookbehind to ensure the <code>e</code> follows a number.<br><h4> Comment 46788905 Aconcagua: </h4>&#39;.7&#39; is probably one of the most simple cases that still is missed... better try /^[+-]?\d*\.?\d+$/ for float. My variant, considering scientific notation, too: /^[+-]?\d*\.?\d+(?:(?:e|E)\d+)?$/<br>------------------------------------------------------------------ <br><h3> Answer 12937508 Peter Vanroose: </h3><p>A simple (and maybe simplistic) answer to the question <em>is the content of <code>$x</code> numeric</em> is the following:</p>

<pre><code>if ($x  eq  $x+0) { .... }
</code></pre>

<p>It does a textual comparison of the original <code>$x</code> with the <code>$x</code> converted to a numeric value.</p>
<h4> Comment 17786003 Derek Park: </h4>That will throw warnings if you use &quot;-w&quot; or &quot;use warnings;&quot;.<br><h4> Comment 44053059 Eponymous: </h4>The warnings can be removed <code>$x eq (($x+0).&quot;&quot;)</code> however a worse problem is that under this function, &quot;1.0&quot; is not numeric<br><h4> Comment 48579661 Znik: </h4>it is enough testing $x+0 ne &#39;&#39;   . when you will text 0001, then correct number will be checked as non number. the same is when you will test &#39;.05&#39; text value.<br><h4> Comment 132929046 Skeeve: </h4>$x eq $x+0 fails for &quot;0.0&quot;, &quot;.5&quot;, &quot;0x1&quot;…<br>------------------------------------------------------------------ <br><h3> Answer 12654 farmerchris: </h3><p>Not perfect, but you can use a regex:</p>

<pre><code>sub isnumber 
{
    shift =~ /^-?\d+\.?\d*$/;
}
</code></pre>
<h4> Comment 46788951 Aconcagua: </h4>Same problem as andrewrk&#39;s answer: misses many even simple cases, e. g. &#39;.7&#39;<br>------------------------------------------------------------------ <br><h3> Answer 12736 Jon Ericson: </h3><p>A slightly more robust regex can be found in <a href="http://search.cpan.org/dist/Regexp-Common" rel="nofollow noreferrer">Regexp::Common</a>.</p>

<p>It sounds like you want to know if Perl thinks a variable is numeric.  Here's a function that  traps that warning:</p>

<pre><code>sub is_number{
  my $n = shift;
  my $ret = 1;
  $SIG{"__WARN__"} = sub {$ret = 0};
  eval { my $x = $n + 1 };
  return $ret
}
</code></pre>

<p>Another option is to turn off the warning locally:</p>

<pre><code>{
  no warnings "numeric"; # Ignore "isn't numeric" warning
  ...                    # Use a variable that might not be numeric
}
</code></pre>

<p>Note that non-numeric variables will be silently converted to 0, which is probably what you wanted anyway.</p>
------------------------------------------------------------------ <br><h3> Answer 4412308 fringd: </h3><p>rexep not perfect... this is:</p>

<pre><code>use Try::Tiny;

sub is_numeric {
  my ($x) = @_;
  my $numeric = 1;
  try {
    use warnings FATAL =&gt; qw/numeric/;
    0 + $x;
  }
  catch {
    $numeric = 0;
  };
  return $numeric;
}
</code></pre>
------------------------------------------------------------------ <br><h3> Answer 16861447 CDC: </h3><p>Try this:</p>

<pre><code>If (($x !~ /\D/) &amp;&amp; ($x ne "")) { ... }
</code></pre>
------------------------------------------------------------------ <br><h3> Answer 32889849 Swadhikar: </h3><p>I found this interesting though</p>

<pre><code>if ( $value + 0 eq $value) {
    # A number
    push @args, $value;
} else {
    # A string
    push @args, "'$value'";
}
</code></pre>
<h4> Comment 53609674 Kumar Saurabh: </h4>you need to explain a better , you are saying u find it interesting but does it answer the op? Try to explain why your answer is the solution for the question asked<br><h4> Comment 53611333 Swadhikar: </h4>For example my $value is 1, $value + 0 remains same 1. By comparing against $value 1 equals 1. If the $value is a string say &quot;swadhi&quot; then $value + 0 becomes ascii value of the string &quot;swadhi&quot; + 0 = some other number.<br><h4> Comment 134560671 soger: </h4>Doesn&#39;t work for ex. if $value is &#39;10.0&#39;.<br>------------------------------------------------------------------ <br><h3> Answer 34547363 zagrimsan: </h3><p>Personally I think that the way to go is to rely on Perl's internal context to make the solution bullet-proof. A good regexp could match all the valid numeric values and none of the non-numeric ones (or vice versa), but as there is a way of employing the same logic the interpreter is using it should be safer to rely on that directly.</p>

<p>As I tend to run my scripts with <code>-w</code>, I had to combine the idea of comparing the result of "value plus zero" to the original value with the <code>no warnings</code> based approach of @ysth:</p>

<pre><code>do { 
    no warnings "numeric";
    if ($x + 0 ne $x) { return "not numeric"; } else { return "numeric"; }
}
</code></pre>
------------------------------------------------------------------ <br><h3> Answer 35657449 bLIGU: </h3><p>You can use Regular Expressions to determine if $foo is a number (or not).</p>

<p>Take a look here:
<a href="http://perldoc.perl.org/perlfaq4.html#How-do-I-determine-whether-a-scalar-is-a-number%2fwhole%2finteger%2ffloat%3f" rel="nofollow">How do I determine whether a scalar is a number</a></p>
------------------------------------------------------------------ <br><h3> Answer 72480461 Kevin: </h3><p>There is a highly upvoted accepted answer around using a library function, but it includes the caveat that &quot;inf&quot; and &quot;infinity&quot; are accepted as numbers.  I see some regex stuff for answers too, but they seem to have issues.  I tried my hand at writing some regex that would work better (I'm sorry it's long)...</p>
<pre><code>/^0$|^[+-]?[1-9][0-9]*$|^[+-]?[1-9][0-9]*(\.[0-9]+)?([eE]-?[1-9][0-9]*)?$|^[+-]?[0-9]?\.[0-9]+$|^[+-]?[1-9][0-9]*\.[0-9]+$/
</code></pre>
<p>That's really 5 patterns separated by &quot;or&quot;...</p>
<p><strong>Zero:</strong> <code>^0$</code><br>
It's a kind of special case.  It's the only integer that can start with 0.</p>
<p><strong>Integers:</strong> <code>^[+-]?[1-9][0-9]*$</code><br>
That makes sure the first digit is 1 to 9 and allows 0 to 9 for any of the following digits.</p>
<p><strong>Scientific Numbers:</strong> <code>^[+-]?[1-9][0-9]*(\.[0-9]+)?([eE]-?[1-9][0-9]*)?$</code><br>
Uses the same idea that the base number can't start with zero since in proper scientific notation you start with the highest significant bit (meaning the first number won't be zero).  However, my pattern allows for multiple digits left of the decimal point.  That's incorrect, but I've already spent too much time on this... you could replace the <code>[1-9][0-9]*</code> with just <code>[0-9]</code> to force a single digit before the decimal point and allow for zeroes.</p>
<p><strong>Short Float Numbers:</strong> <code>^[+-]?[0-9]?\.[0-9]+$</code><br>
This is like a zero integer.  It's special in that it can start with 0 if there is only one digit left of the decimal point.  It does overlap the next pattern though...</p>
<p><strong>Long Float Numbers:</strong> <code>^[+-]?[1-9][0-9]*\.[0-9]+$</code><br>
This handles most float numbers and allows more than one digit left of the decimal point while still enforcing that the higher number of digits can't start with 0.</p>
<p><strong>The simple function...</strong><br></p>
<pre><code>sub is_number {
    my $testVal = shift;
    return $testVal =~ /^0$|^[+-]?[1-9][0-9]*$|^[+-]?[1-9][0-9]*(\.[0-9]+)?([eE]-?[1-9][0-9]*)?$|^[+-]?[0-9]?\.[0-9]+$|^[+-]?[1-9][0-9]*\.[0-9]+$/;
}
</code></pre>
------------------------------------------------------------------ <br><h3> Answer 77260407 Rich: </h3><p>I use this to check for positive integers (though it is destructive)...</p>
<pre><code>$value =~ s/[0-9]+//;
$is_numeric = ($value eq '');
</code></pre>
<p>(This question highlights perfectly my love-hate relationship with Perl - &quot;makes difficult things easy, impossible things possible ...and what should be trivial things stupidly difficult and expensive&quot;)</p>
------------------------------------------------------------------ <br><h3> Answer 18934806 Jason Van Patten: </h3><p>if ( defined $x &amp;&amp; $x !~ m/\D/ ) {}
or
$x = 0 if ! $x;
if ( $x !~ m/\D/) {}</p>

<p>This is a slight variation on Veekay's answer but let me explain my reasoning for the change.</p>

<p>Performing a regex on an undefined value will cause error spew and will cause the code to exit in many if not most environments. Testing if the value is defined or setting a default case like i did in the alternative example before running the expression will, at a minimum, save your error log.</p>
