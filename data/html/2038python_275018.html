 <h2> Title: How can I remove a trailing newline? </h2> <h3> RidingThisToTheTop, question_id: 275018 </h3>Score: 2038, Tags: {python,newline,trailing} <br><p>How can I remove the last character of a string if it is a newline?</p>
<pre><code>&quot;abc\n&quot;  --&gt;  &quot;abc&quot;
</code></pre>
<h4> Comment 82725646 smci: </h4>The A+ answer is, if this was due to forgetting to <code>open()</code> a file with the appropriate <a href="https://docs.python.org/3/library/functions.html#open" rel="nofollow noreferrer">&#39;newline=...&#39;</a> parameter for your platform (universal newline support), you might not need to explicitly remove it.<br><h4> Comment 53441901 Ciro Santilli OurBigBook.com: </h4>Superset: any string instead of just newline: <a href="http://stackoverflow.com/questions/1038824/how-do-i-remove-a-substring-from-the-end-of-a-string-in-python" title="how do i remove a substring from the end of a string in python">stackoverflow.com/questions/1038824/&hellip;</a><br>------------------------------------------------------------------ <br><h3> Answer 275025 Rich Bradshaw: </h3><p>Try the method <code>rstrip()</code> (see doc <a href="http://docs.python.org/2/library/stdtypes.html#str.rstrip" rel="noreferrer">Python 2</a> and <a href="https://docs.python.org/3/library/stdtypes.html#str.rstrip" rel="noreferrer">Python 3</a>)</p>
<pre><code>&gt;&gt;&gt; 'test string\n'.rstrip()
'test string'
</code></pre>
<p>Python's <code>rstrip()</code> method strips <em>all</em> kinds of trailing whitespace by default, not just one newline as Perl does with <a href="http://perldoc.perl.org/functions/chomp.html" rel="noreferrer"><code>chomp</code></a>.</p>
<pre><code>&gt;&gt;&gt; 'test string \n \r\n\n\r \n\n'.rstrip()
'test string'
</code></pre>
<p>To strip only newlines:</p>
<pre><code>&gt;&gt;&gt; 'test string \n \r\n\n\r \n\n'.rstrip('\n')
'test string \n \r\n\n\r '
</code></pre>
<p>In addition to <code>rstrip()</code>, there are also the methods <code>strip()</code> and <code>lstrip()</code>. Here is an example with the three of them:</p>
<pre><code>&gt;&gt;&gt; s = &quot;   \n\r\n  \n  abc   def \n\r\n  \n  &quot;
&gt;&gt;&gt; s.strip()
'abc   def'
&gt;&gt;&gt; s.lstrip()
'abc   def \n\r\n  \n  '
&gt;&gt;&gt; s.rstrip()
'   \n\r\n  \n  abc   def'
</code></pre>
<h4> Comment 127997 brian d foy: </h4>I&#39;m not a Python person so I don&#39;t have the answer to this, but Perl&#39;s chomp() actually removes the input record separator from the end. That&#39;s a newline on Unixy things, but may be different (e.g. Windows) and it&#39;s mutable. Is there a way to remove that value only once from the end of a string?<br><h4> Comment 60724137 Script Kitty: </h4>I&#39;m going to go ahead and spell this out because I&#39;m a noob and I spent a while wondering why it wasn&#39;t working. <code>.strip()</code> does not alter the string (probably has something to do with immutable strings). If not in command line, you&#39;ll want <code>&quot;string = string.strip()&quot;</code><br><h4> Comment 18080084 AlcubierreDrive: </h4>@briandfoy Python has built-in support for Universal newlines (only when reading, not when writing). You open the file in either &quot;U&quot; or &quot;rU&quot; mode, and then regardless of Windows, Linux, Mac, whatever, by the time the text reaches your python code, any style of newline has been replaced with &quot;\n&quot;. See: <a href="http://www.python.org/dev/peps/pep-0278/" rel="nofollow noreferrer">python.org/dev/peps/pep-0278</a><br><h4> Comment 18007513 skue: </h4>@csde_rats, that&#39;s not true: OS X uses <code>\n</code> for newlines just like Unix. (Prior to OS X, MacOS did use <code>\r</code> as a line separator, but that ended 10 years ago.)<br><h4> Comment 128360 Peter Hosey: </h4>brian d foy: Python doesn&#39;t have an input record separator like awk and Perl have.<br><h4> Comment 890357 Andrew Grimm: </h4>Is \n sufficient?  &gt;&gt;&gt; &quot;test string\r\n&quot;.rstrip(&quot;\n&quot;) &#39;test string\r&#39;<br><h4> Comment 79905488 Robert Sim: </h4>rstrip() on its own is going to give you a lot of headaches if you&#39;re processing TSVs with some empty columns.  For example &quot;foo\tbar\t\t\n&quot;.rstrip() will remove the last two empty columns from your data.<br><h4> Comment 44962902 Colin D Bennett: </h4>@AlixAxel As stated above by @AlcubierreDrive, handling newlines in a portable way means they are converted to the canonical <code>\n</code> form when they are read from the file.  Then, your program working with strings will never see the <code>\r</code> characters.<br><h4> Comment 41022680 fbicknel: </h4>@yegle, I think you mean &#39;ded&#39;, not &#39;def&#39;.  :)<br><h4> Comment 21311831 yegle: </h4>Just in case someone misunderstand the example: the argument for <code>strip</code>, <code>rstrip</code>, <code>lstrip</code> is used as a list of characters, not a string. So <code>&#39;abcdedcba&#39;.strip(&quot;abc&quot;)</code> gives <code>def</code>, not <code>cdedcba</code>!<br><h4> Comment 59372755 sethmlarson: </h4>I know this isn&#39;t really a question but is brought up in the comments.  Is there any reason why <code>text.rstrip(os.linesep)</code> would not work in an OS-independent way to achieve this?<br><h4> Comment 13738469 dom0: </h4>\r itself won&#39;t trigger a newline anywhere (except for OSX, but who cares about OSX?)<br><h4> Comment 23732477 Alix Axel: </h4>@skue: What about Windows? If you remove the <code>\n</code> you still get <code>\r</code>.<br><h4> Comment 20586316 Alex Bitek: </h4>This only removes the first \n not all the \n&#39;s. What if I have a string as: &quot;sadsa\nsadas\nsadsad\n&quot; <b>How can I remove ALL the newlines?</b> replace(&#39;\n&#39;, &#39;&#39;) doesn&#39;t work either.<br><h4> Comment 135358163 iomv: </h4>wondering why this isn&#39;t the accepted answer?<br><h4> Comment 104537026 Alex Hall: </h4>Necessary to get clean string variables passed via argsparse. Windows newlines made them not even show up at all in string concatenation.<br>------------------------------------------------------------------ <br><h3> Answer 275659 Ryan Ginstrom: </h3><p>And I would say the "pythonic" way to get lines without trailing newline characters is splitlines().</p>

<pre><code>&gt;&gt;&gt; text = "line 1\nline 2\r\nline 3\nline 4"
&gt;&gt;&gt; text.splitlines()
['line 1', 'line 2', 'line 3', 'line 4']
</code></pre>
<h4> Comment 57701817 jfs: </h4>note: <a href="https://docs.python.org/3/library/stdtypes.html#str.splitlines" rel="nofollow noreferrer"><code>str.splitlines()</code> treats as newlines many characters (not just <code>\r</code>, <code>\n</code>)</a><br><h4> Comment 124703544 Gert van den Berg: </h4>This also gives unexpected results if you have a multi-line string and only want to strip the last line-terminator.... (although it can probably by joined back again for that)<br><h4> Comment 127438818 SvenS: </h4>@GertvandenBerg the method is called <code>splitlines()</code>. If I give it a multi-<i>line</i> string, I don&#39;t expect it to strip only the last line, because I literaly told it to split my multi-line string into multiple strings at the line breaks ;) Using it to strip line endings off a single-line string is actually just a useful corner case.<br>------------------------------------------------------------------ <br><h3> Answer 275401 Mike: </h3><p>The canonical way to strip end-of-line (EOL) characters is to use the string rstrip() method removing any trailing \r or \n.  Here are examples for Mac, Windows, and Unix EOL characters.</p>

<pre><code>&gt;&gt;&gt; 'Mac EOL\r'.rstrip('\r\n')
'Mac EOL'
&gt;&gt;&gt; 'Windows EOL\r\n'.rstrip('\r\n')
'Windows EOL'
&gt;&gt;&gt; 'Unix EOL\n'.rstrip('\r\n')
'Unix EOL'
</code></pre>

<p>Using '\r\n' as the parameter to rstrip means that it will strip out any trailing combination of '\r' or '\n'.  That's why it works in all three cases above.</p>

<p>This nuance matters in rare cases.  For example, I once had to process a text file which contained an HL7 message.  The HL7 standard requires a trailing '\r' as its EOL character.  The Windows machine on which I was using this message had appended its own '\r\n' EOL character.  Therefore, the end of each line looked like '\r\r\n'.  Using rstrip('\r\n') would have taken off the entire '\r\r\n' which is not what I wanted.  In that case, I simply sliced off the last two characters instead.</p>

<p>Note that unlike Perl's <code>chomp</code> function, this will strip all specified characters at the end of the string, not just one:</p>

<pre><code>&gt;&gt;&gt; "Hello\n\n\n".rstrip("\n")
"Hello"
</code></pre>
<h4> Comment 8452428 Eli Collins: </h4>There&#39;s also <a href="http://docs.python.org/library/os.html#os.linesep" rel="nofollow noreferrer"><code>os.linesep</code></a>, which contains the EOL sequence for the current OS.<br><h4> Comment 128361 Peter Hosey: </h4>Note that modern Mac OS X apps use \n. Only old Carbon apps originally written for Mac OS use \r.<br><h4> Comment 128477 Mike: </h4>Thanks for the clarification.  Of course, the rstrip(&#39;\r\n&#39;) still works in that case too.<br><h4> Comment 45263177 kevinarpe: </h4>This is the best answer: It <i>only</i> strips newlines, and does it correctly for the most common platforms.<br><h4> Comment 49097543 fechnert: </h4>plus +1 For using <code>\n</code> and <code>\r</code><br><h4> Comment 57701793 jfs: </h4>@Tim: normally, you won&#39;t see <code>\r</code> in in the input because Python uses universal newlines mode by default (<a href="https://docs.python.org/3/library/functions.html#open" rel="nofollow noreferrer"><code>&#39;\n&#39;</code>, <code>&#39;\r&#39;</code>, or <code>&#39;\r\n&#39;</code> are translated to <code>&#39;\n&#39;</code> while reading</a>). If you want to take into account Unicode newlines; see <a href="https://docs.python.org/3/library/stdtypes.html#str.splitlines" rel="nofollow noreferrer"><code>str.splitlines()</code></a>.<br><h4> Comment 79905626 Robert Sim: </h4>Upvoting because this is much safer than rstrip() with no arguments.<br><h4> Comment 127438935 SvenS: </h4>@Tim that may be true for reading files, but I&#39;m processing stdout of a batch script called by my python script (don&#39;t ask...) so I have plenty of <code>\r\n</code>s. Which of course is done line by line, so <code>splitlines()</code> is a bit overkill.<br>------------------------------------------------------------------ <br><h3> Answer 326279 Sameer Siruguri: </h3><p>Note that rstrip doesn't act exactly like Perl's chomp() because it doesn't modify the string. That is, in Perl:</p>

<pre><code>$x="a\n";

chomp $x
</code></pre>

<p>results in <code>$x</code> being <code>"a"</code>.</p>

<p>but in Python:</p>

<pre><code>x="a\n"

x.rstrip()
</code></pre>

<p>will mean that the value of <code>x</code> is <strong>still</strong> <code>"a\n"</code>. Even <code>x=x.rstrip()</code> doesn't always give the same result, as it strips all whitespace from the end of the string, not just one newline at most.</p>
<h4> Comment 2541537 kostmo: </h4>Also, strip() removes repeated characters, whereas chop/chomp only removes one newline<br>------------------------------------------------------------------ <br><h3> Answer 2396894 Jamie: </h3><p>I might use something like this:</p>

<pre><code>import os
s = s.rstrip(os.linesep)
</code></pre>

<p>I think the problem with <code>rstrip("\n")</code> is that you'll probably want to make sure the line separator is portable. (some antiquated systems are rumored to use <code>"\r\n"</code>). The other gotcha is that <code>rstrip</code> will strip out repeated whitespace. Hopefully <code>os.linesep</code> will contain the right characters. the above works for me.</p>
<h4> Comment 11153015 apiguy: </h4>This won&#39;t work however if you are trying to clean up user submitted content in a web application. The user content could come from any source and contain any newline chars.<br><h4> Comment 58188048 ChuckCottrill: </h4>Good point, except that you may be processing &#39;foreign&#39; files (from antiquated systems) on your modern os.<br><h4> Comment 74422072 Mad Physicist: </h4>Keep in mind also that if you are reading a file in text mode, this won&#39;t work on a Windows system either, because the trailing character will always be converted to &#39;\n&#39;.<br><h4> Comment 98182538 dtauxe: </h4>@MadPhysicist You are right that it does convert it, but it still works because it is the same as <code>rstrip(&#39;\r\n&#39;)</code> and <code>rstrip()</code> will strip any characters that are in the argument.<br>------------------------------------------------------------------ <br><h3> Answer 5764202 ingydotnet: </h3><p>rstrip doesn't do the same thing as chomp, on so many levels. Read <a href="http://perldoc.perl.org/functions/chomp.html" rel="noreferrer">http://perldoc.perl.org/functions/chomp.html</a> and see that chomp is very complex indeed.</p>

<p>However, my main point is that chomp removes at most 1 line ending, whereas rstrip will remove as many as it can.</p>

<p>Here you can see rstrip removing all the newlines:</p>

<pre><code>&gt;&gt;&gt; 'foo\n\n'.rstrip(os.linesep)
'foo'
</code></pre>

<p>A much closer approximation of typical Perl chomp usage can be accomplished with re.sub, like this:</p>

<pre><code>&gt;&gt;&gt; re.sub(os.linesep + r'\Z','','foo\n\n')
'foo\n'
</code></pre>
<h4> Comment 15943164 brianmearns: </h4>Kudos, you&#39;re the only one that pointed out this very important detail. However, as someone above noted, using os.linesep won&#39;t work if you&#39;re reading files from a different system. This might take a bit more work in Python, actually inspecting the end of the line.<br>------------------------------------------------------------------ <br><h3> Answer 16527062 kiriloff: </h3><p>You may use <code>line = line.rstrip('\n')</code>. This will strip all newlines from the end of the string, not just one.</p>
------------------------------------------------------------------ <br><h3> Answer 28937424 slec: </h3><pre><code>s = s.rstrip()
</code></pre>

<p>will remove all newlines at the end of the string <code>s</code>. The assignment is needed because <code>rstrip</code> returns a new string instead of modifying the original string. </p>
------------------------------------------------------------------ <br><h3> Answer 9507807 mihaicc: </h3><pre><code>&quot;line 1\nline 2\r\n...&quot;.replace('\n', '').replace('\r', '')
&gt;&gt;&gt; 'line 1line 2...'
</code></pre>
<p>or you could always get geekier with regexps</p>
<h4> Comment 32728097 Taylor D. Edmiston: </h4>Just in case anyone else wants to use the idea from @DoorknobofSnow, it&#39;s just a small change to use the regex module: <code>import re</code> <code>re.sub(&#39;\n|\r&#39;, &#39;&#39;, &#39;\nx\n\r\n&#39;)</code> ==&gt; <code>&#39;x&#39;</code>.<br><h4> Comment 25465852 tckmn: </h4>Why not just use one replace statement, like <code>.replace(&#39;\n|\r&#39;, &#39;&#39;)</code>?<br><h4> Comment 20081938 Steve Koch: </h4>This worked great for me trying to quickly turn a text file with line endings into one line of text.  I&#39;m a newbie, so not sure if there&#39;s a better way to do it, but it worked, thanks!  (Strip seemed to only work from the ends, not internally)<br><h4> Comment 77575798 Bhargav: </h4>Using this and regex technique as @TaylorEdmiston mentioned should be the proper answer.<br><h4> Comment 77645503 Taylor D. Edmiston: </h4>@Bhargav I&#39;ve added an answer to this question based upon this comment as you suggested while also exploring a few other related options.  I also clarified why I think regex is a better solution to this problem than str.rstrip since that&#39;s what most answers use.<br>------------------------------------------------------------------ <br><h3> Answer 32882948 Alien Life Form: </h3><p>This would replicate exactly perl's chomp (minus behavior on arrays) for "\n" line terminator:</p>

<pre><code>def chomp(x):
    if x.endswith("\r\n"): return x[:-2]
    if x.endswith("\n") or x.endswith("\r"): return x[:-1]
    return x
</code></pre>

<p>(Note: it does not modify string 'in place'; it does not strip extra trailing whitespace; takes \r\n in account)</p>
<h4> Comment 127908316 Eric: </h4>how could it modify the string at all... they&#39;re immutable objects.<br><h4> Comment 127957323 Alien Life Form: </h4>@eric It does not modify the string. It returns a modified copy of x. Modifying strings in place is a perl thing, not a python one.<br><h4> Comment 128069574 Eric: </h4>my point is that your <b>Note</b> is confusing: by stating the code doesn&#39;t modify strings, beginners may assume this is a thing in Python.<br><h4> Comment 128120186 Alien Life Form: </h4>@eric. OK, the note is a qualification to the preceding statement &quot;This would replicate exactly perl&#39;s chomp&quot;. An exact replica of perl&#39;s chomp is not possible in python.<br><h4> Comment 128445699 Eric: </h4>Whatever man...<br>------------------------------------------------------------------ <br><h3> Answer 27054136 Hackaholic: </h3><p>you can use strip:</p>

<pre><code>line = line.strip()
</code></pre>

<p>demo:</p>

<pre><code>&gt;&gt;&gt; "\n\n hello world \n\n".strip()
'hello world'
</code></pre>
<h4> Comment 45856493 Tarik: </h4>Tried this solution but it strips off leading blanks in the line.<br><h4> Comment 45998513 Hackaholic: </h4>@Tarik you can use rstrip<br><h4> Comment 63688279 Flimm: </h4>rstrip will delete all trailing whitespace, unlike chomp which only deletes at most one newline.<br>------------------------------------------------------------------ <br><h3> Answer 5803510 Carlos Valiente: </h3><p>Careful with <code>"foo".rstrip(os.linesep)</code>: That will only chomp the newline characters for the platform where your Python is being executed. Imagine you're chimping the lines of a Windows file under Linux, for instance:</p>

<pre><code>$ python
Python 2.7.1 (r271:86832, Mar 18 2011, 09:09:48) 
[GCC 4.5.0 20100604 [gcc-4_5-branch revision 160292]] on linux2
Type "help", "copyright", "credits" or "license" for more information.
&gt;&gt;&gt; import os, sys
&gt;&gt;&gt; sys.platform
'linux2'
&gt;&gt;&gt; "foo\r\n".rstrip(os.linesep)
'foo\r'
&gt;&gt;&gt;
</code></pre>

<p>Use <code>"foo".rstrip("\r\n")</code> instead, as Mike says above.</p>
<h4> Comment 63688194 Flimm: </h4>The other thing to note is that it does not remove at most one newline, but all newlines, unlike <code>chomp</code>.<br>------------------------------------------------------------------ <br><h3> Answer 19531239 minopret: </h3><p>An <a href="http://docs.python.org/2/library/stdtypes.html#file.next" rel="noreferrer">example in Python's documentation</a> simply uses <code>line.strip()</code>.</p>

<p>Perl's <code>chomp</code> function removes one linebreak sequence from the end of a string only if it's actually there.</p>

<p>Here is how I plan to do that in Python, if <code>process</code> is conceptually the function that I need in order to do something useful to each line from this file:</p>

<pre><code>import os
sep_pos = -len(os.linesep)
with open("file.txt") as f:
    for line in f:
        if line[sep_pos:] == os.linesep:
            line = line[:sep_pos]
        process(line)
</code></pre>
<h4> Comment 53441880 Ciro Santilli OurBigBook.com: </h4>Finally, an answer that only removes it <i>once</i> (like the actual chomp...) and is OS portable!<br>------------------------------------------------------------------ <br><h3> Answer 1077495 Andrew Grimm: </h3><p>I don't program in Python, but I came across an <a href="http://www.python.org/doc/faq/programming/#is-there-an-equivalent-to-perl-s-chomp-for-removing-trailing-newlines-from-strings" rel="nofollow noreferrer">FAQ</a> at python.org advocating S.rstrip("\r\n") for python 2.2 or later.</p>
------------------------------------------------------------------ <br><h3> Answer 21242117 user1151618: </h3><pre><code>import re

r_unwanted = re.compile("[\n\t\r]")
r_unwanted.sub("", your_text)
</code></pre>
<h4> Comment 42269956 NoahR: </h4>This is also going to remove tab whitespace, which the original question does not request. ( Due to the \t character )<br>------------------------------------------------------------------ <br><h3> Answer 58499321 user1464878: </h3><pre><code>s = '''Hello  World \t\n\r\tHi There'''
# import the module string   
import string
# use the method translate to convert 
s.translate({ord(c): None for c in string.whitespace}
&gt;&gt;'HelloWorldHiThere'
</code></pre>

<p>With regex</p>

<pre><code>s = '''  Hello  World 
\t\n\r\tHi '''
print(re.sub(r"\s+", "", s), sep='')  # \s matches all white spaces
&gt;HelloWorldHi
</code></pre>

<p>Replace \n,\t,\r</p>

<pre><code>s.replace('\n', '').replace('\t','').replace('\r','')
&gt;'  Hello  World Hi '
</code></pre>

<p>With regex</p>

<pre><code>s = '''Hello  World \t\n\r\tHi There'''
regex = re.compile(r'[\n\r\t]')
regex.sub("", s)
&gt;'Hello  World Hi There'
</code></pre>

<p>with Join</p>

<pre><code>s = '''Hello  World \t\n\r\tHi There'''
' '.join(s.split())
&gt;'Hello  World Hi There'
</code></pre>
------------------------------------------------------------------ <br><h3> Answer 19317570 Leozj: </h3><p>If your question is to clean up all the line breaks in a multiple line str object (oldstr), you can split it into a list according to the delimiter '\n' and then join this list into a new str(newstr).</p>

<p><code>newstr = "".join(oldstr.split('\n'))</code>    </p>
------------------------------------------------------------------ <br><h3> Answer 27890752 kuzzooroo: </h3><p>I find it convenient to have be able to get the chomped lines via in iterator, parallel to the way you can get the un-chomped lines from a file object. You can do so with the following code:</p>

<pre><code>def chomped_lines(it):
    return map(operator.methodcaller('rstrip', '\r\n'), it)
</code></pre>

<p>Sample usage:</p>

<pre><code>with open("file.txt") as infile:
    for line in chomped_lines(infile):
        process(line)
</code></pre>
<h4> Comment 78237208 ShadowRanger: </h4>Note: With <code>operator.methodcaller</code> and <code>map</code> (<code>itertools.imap</code> on Py2) you can push this work to the C layer, avoiding Python level generator code (and thereby running a bit faster, though admittedly I/O overhead is likely to mask small gains): <code>for line in map(operator.methodcaller(&#39;rstrip&#39;, &#39;\r\n&#39;), infile):</code>. It could be still be factored out as <code>def chomped_lines(it): return map(operator.methodcaller(&#39;rstrip&#39;, &#39;\r\n&#39;), it)</code>.<br>------------------------------------------------------------------ <br><h3> Answer 45342003 Taylor D. Edmiston: </h3><p>I'm bubbling up my regular expression based answer from one I posted earlier in the comments of another answer.  I think using <code>re</code> is a clearer more explicit solution to this problem than <code>str.rstrip</code>.</p>

<pre><code>&gt;&gt;&gt; import re
</code></pre>

<p>If you want to remove one or more <em>trailing</em> newline chars:</p>

<pre><code>&gt;&gt;&gt; re.sub(r'[\n\r]+$', '', '\nx\r\n')
'\nx'
</code></pre>

<p>If you want to remove newline chars everywhere (not just trailing):</p>

<pre><code>&gt;&gt;&gt; re.sub(r'[\n\r]+', '', '\nx\r\n')
'x'
</code></pre>

<p>If you want to remove only 1-2 trailing newline chars (i.e., <code>\r</code>, <code>\n</code>, <code>\r\n</code>, <code>\n\r</code>, <code>\r\r</code>, <code>\n\n</code>)</p>

<pre><code>&gt;&gt;&gt; re.sub(r'[\n\r]{1,2}$', '', '\nx\r\n\r\n')
'\nx\r'
&gt;&gt;&gt; re.sub(r'[\n\r]{1,2}$', '', '\nx\r\n\r')
'\nx\r'
&gt;&gt;&gt; re.sub(r'[\n\r]{1,2}$', '', '\nx\r\n')
'\nx'
</code></pre>

<p>I have a feeling what most people really want here, is to remove just <em>one</em> occurrence of a trailing newline character, either <code>\r\n</code> or <code>\n</code> and nothing more.</p>

<pre><code>&gt;&gt;&gt; re.sub(r'(?:\r\n|\n)$', '', '\nx\n\n', count=1)
'\nx\n'
&gt;&gt;&gt; re.sub(r'(?:\r\n|\n)$', '', '\nx\r\n\r\n', count=1)
'\nx\r\n'
&gt;&gt;&gt; re.sub(r'(?:\r\n|\n)$', '', '\nx\r\n', count=1)
'\nx'
&gt;&gt;&gt; re.sub(r'(?:\r\n|\n)$', '', '\nx\n', count=1)
'\nx'
</code></pre>

<p>(The <code>?:</code> is to create a non-capturing group.)</p>

<p>(By the way this is <em>not</em> what <code>'...'.rstrip('\n', '').rstrip('\r', '')</code> does which may not be clear to others stumbling upon this thread.  <code>str.rstrip</code> strips as many of the trailing characters as possible, so a string like <code>foo\n\n\n</code> would result in a false positive of <code>foo</code> whereas you may have wanted to preserve the other newlines after stripping a single trailing one.)</p>
<h4> Comment 78237428 ShadowRanger: </h4>Also, side-note: Since you&#39;re trying to match the <code>\n</code> directly, you might want to use <code>\Z</code> over <code>$</code> (or just match <code>\r?$</code>, since <code>$</code> implicitly can match just before the newline at the end of a string).<br><h4> Comment 78236916 ShadowRanger: </h4>You could skip the non-capturing group, even for your final approach, with the regex <code>r&#39;\r?\n$&#39;</code>. Likely more efficient, since regex engines have a harder time optimizing alternations. Also note that if you&#39;re going to do this many times, it will be significantly faster (especially if you&#39;re intermingling with other <code>re</code> uses) to <code>re.compile</code> the expression once up front, then use the <code>sub</code> method of the compiled regex object; module functions are Python level and check a cache for compiled regexes first (creating/caching if missing), then call the matching method; skipping that lookup helps.<br>------------------------------------------------------------------ <br><h3> Answer 8327143 Chij: </h3><p>workaround solution for special case:</p>

<p>if the newline character is the last character (as is the case with most file inputs), then for any element in the collection you can index as follows: </p>

<pre><code>foobar= foobar[:-1]
</code></pre>

<p>to slice out your newline character. </p>
<h4> Comment 14140640 Cacovsky: </h4>Sometimes the newline is not <i>a</i> last character, but the last ones, specially on windows, as others have pointed out.<br>------------------------------------------------------------------ <br><h3> Answer 43641376 teichert: </h3><p>It looks like there is not a perfect analog for perl's <a href="http://perldoc.perl.org/functions/chomp.html" rel="noreferrer">chomp</a>.  In particular, <a href="https://docs.python.org/3/library/stdtypes.html#str.rstrip" rel="noreferrer">rstrip</a> cannot handle multi-character newline delimiters like <code>\r\n</code>. However, <a href="https://docs.python.org/3/library/stdtypes.html#str.splitlines" rel="noreferrer">splitlines</a> does <a href="https://stackoverflow.com/a/275659/3780389">as pointed out here</a>.
Following <a href="https://stackoverflow.com/a/43641128/3780389">my answer</a> on a different question, you can combine <a href="https://docs.python.org/3/library/stdtypes.html#str.join" rel="noreferrer">join</a> and <a href="https://docs.python.org/3/library/stdtypes.html#str.splitlines" rel="noreferrer">splitlines</a> to remove/replace all newlines from a string <code>s</code>:</p>

<pre><code>''.join(s.splitlines())
</code></pre>

<p>The following removes <em>exactly one <strong>trailing</em></strong> newline (as chomp would, I believe). Passing <code>True</code> as the <code>keepends</code> argument to splitlines retain the delimiters.  Then, splitlines is called again to remove the delimiters on just the last "line": </p>

<pre><code>def chomp(s):
    if len(s):
        lines = s.splitlines(True)
        last = lines.pop()
        return ''.join(lines + last.splitlines())
    else:
        return ''
</code></pre>
------------------------------------------------------------------ <br><h3> Answer 37346773 Help me: </h3><p>Just use : </p>

<pre><code>line = line.rstrip("\n")
</code></pre>

<p>or</p>

<pre><code>line = line.strip("\n")
</code></pre>

<p>You don't need any of this complicated stuff</p>
<h4> Comment 63688331 Flimm: </h4>Note that this is not the same as chomp.<br>------------------------------------------------------------------ <br><h3> Answer 40749138 user7121455: </h3><pre><code>&gt;&gt;&gt; '   spacious   '.rstrip()
'   spacious'
&gt;&gt;&gt; "AABAA".rstrip("A")
  'AAB'
&gt;&gt;&gt; "ABBA".rstrip("AB") # both AB and BA are stripped
   ''
&gt;&gt;&gt; "ABCABBA".rstrip("AB")
   'ABC'
</code></pre>
<h4> Comment 75003569 Agostino: </h4>@olibre the code you suggest will also strip other blank/space characters, which might not be what one needs. In fact, I only needed to strip combinations of eol characters. Still, thanks for pointing this out.<br><h4> Comment 68729531 Agostino: </h4>The example I needed! So rstrip(&quot;\r\n&quot;) will strip both &#39;\n&#39; and &#39;\r&#39; in any combination at the end of the line!<br><h4> Comment 74881263 oHo: </h4>@Agostino No need to provide <code>&quot;\r\n&quot;</code> For example: <code>&#39;     spacious   \n\r\n\r  \n\n&#39;.rstrip()</code> produces <code>&#39;     spacious&#39;</code><br>------------------------------------------------------------------ <br><h3> Answer 40750864 internetional: </h3><p>There are three types of line endings that we normally encounter: <code>\n</code>, <code>\r</code> and <code>\r\n</code>. A rather simple regular expression in <a href="https://docs.python.org/2/library/re.html#re.sub" rel="nofollow noreferrer"><code>re.sub</code></a>, namely <code>r"\r?\n?$"</code>, is able to catch them all.</p>

<p>(And we <em>gotta catch 'em all</em>, am I right?)</p>

<pre><code>import re

re.sub(r"\r?\n?$", "", the_text, 1)
</code></pre>

<p>With the last argument, we limit the number of occurences replaced to one, mimicking chomp to some extent. Example:</p>

<pre><code>import re

text_1 = "hellothere\n\n\n"
text_2 = "hellothere\n\n\r"
text_3 = "hellothere\n\n\r\n"

a = re.sub(r"\r?\n?$", "", text_1, 1)
b = re.sub(r"\r?\n?$", "", text_2, 1)
c = re.sub(r"\r?\n?$", "", text_3, 1)
</code></pre>

<p>... where <code>a == b == c</code> is <code>True</code>.</p>
<h4> Comment 68729815 Agostino: </h4>You don&#39;t even need full fledged regular expressions. <code>rstrip(&quot;\r\n&quot;)</code> is a catch-all. Try <code>print(text_2.rstrip(&#39;\r\n&#39;))</code>.<br><h4> Comment 68730343 internetional: </h4>@Agostino : True, given that <code>str.rstrip()</code> solves the problem. It depends on which needs you have. This solution is specifically made for the cases when you need to remove just the last <code>&quot;\n&quot;</code>, <code>&quot;\r&quot;</code> or <code>&quot;\r\n&quot;</code> but not all of them (if there are multiple <code>&quot;\n&quot;</code> in the string). <code>re.sub(r&quot;\r?\n?$&quot;, &quot;&quot;, text_1, 1)</code> returns <code>&quot;hellothere\n\n&quot;</code> and <code>text_1.rstrip(&quot;\r\n&quot;)</code> returns <code>&quot;hellothere&quot;</code> which is a different string.<br><h4> Comment 68730463 internetional: </h4>What I  am trying to say is: that <code>str.strip()</code> is a catch-all is sometimes the very problem.<br>------------------------------------------------------------------ <br><h3> Answer 33392998 Stephen Miller: </h3><p>If you are concerned about speed (say you have a looong list of strings) and you know the nature of the newline char, string slicing is actually faster than rstrip. A little test to illustrate this:</p>

<pre><code>import time

loops = 50000000

def method1(loops=loops):
    test_string = 'num\n'
    t0 = time.time()
    for num in xrange(loops):
        out_sting = test_string[:-1]
    t1 = time.time()
    print('Method 1: ' + str(t1 - t0))

def method2(loops=loops):
    test_string = 'num\n'
    t0 = time.time()
    for num in xrange(loops):
        out_sting = test_string.rstrip()
    t1 = time.time()
    print('Method 2: ' + str(t1 - t0))

method1()
method2()
</code></pre>

<p>Output:</p>

<pre><code>Method 1: 3.92700004578
Method 2: 6.73000001907
</code></pre>
<h4> Comment 54578438 Stephen Miller: </h4>I know I should probably use &quot;global loops&quot; inside of the functions, but this works as well.<br><h4> Comment 62353303 spky: </h4>This test is wrong and not fair.. In <code>method1</code> you are just chopping off the last character, no matter what, in <code>method2</code> the <code>.rstrip()</code> first checks, if the end of the String contains undesired characters and chops them off, only if some were found. Please implement some check for characters in <code>method1</code> and test agin!<br><h4> Comment 62514702 Stephen Miller: </h4>As I said in the intro to the answer: If you know the nature of the newline char, then this is useful. If you don&#39;t then yes, you obviously need to implement some sort of character check - or just use rstrip. I did not mean to be &quot;unfair&quot; to rstrip, but simply illustrate a not so insignificant difference that may be worth considering in some situations.<br>------------------------------------------------------------------ <br><h3> Answer 50870896 Venfah Nazir: </h3><hr>

<p>This will work both for windows and linux (bit expensive with re sub if you are looking for only re solution)</p>

<pre><code>import re 
if re.search("(\\r|)\\n$", line):
    line = re.sub("(\\r|)\\n$", "", line)
</code></pre>

<hr>
<h4> Comment 95598782 wjandrea: </h4>Why use <code>re.search</code> where you just need <code>re.sub</code>?<br>------------------------------------------------------------------ <br><h3> Answer 77447518 Lyle Z: </h3><p>How about:</p>
<pre><code>line = line.rstrip('\r*\n')
</code></pre>
<h4> Comment 136547100 Mark Rotteveel: </h4>You are aware this will also remove trailing <code>*</code> characters as well. The argument of <code>rstrip</code> is not a regex, but the characters to strip from the end. In addition, this question already has a load of answers suggesting using <code>rstrip</code>, so it doesn&#39;t add anything new.<br><h4> Comment 136561068 Lyle Z: </h4>You&#39;re right. Thanks for letting me know this.<br>------------------------------------------------------------------ <br><h3> Answer 26554128 user4178860: </h3><p>A catch all:</p>

<pre><code>line = line.rstrip('\r|\n')
</code></pre>
<h4> Comment 63688322 Flimm: </h4><code>rstrip</code> does not take regular expression. <code>&quot;hi|||\n\n&quot;.rstrip(&quot;\r|\n&quot;)</code> returns <code>&quot;hi&quot;</code><br>