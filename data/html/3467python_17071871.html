 <h2> Title: How do I select rows from a DataFrame based on column values? </h2> <h4> szli, question_id: 17071871 </h4>Score: 3467, Tags: {python,pandas,dataframe} <br><p>How can I select rows from a DataFrame based on values in some column in Pandas?</p>
<p>In SQL, I would use:</p>
<pre class="lang-sql prettyprint-override"><code>SELECT *
FROM table
WHERE column_name = some_value
</code></pre>
------------------------------------------------------------------ <br><h3> unutbu, Id: 17071908, Score: 6377: </h3><p>To select rows whose column value equals a scalar, <code>some_value</code>, use <code>==</code>:</p>
<pre><code>df.loc[df['column_name'] == some_value]
</code></pre>
<p>To select rows whose column value is in an iterable, <code>some_values</code>, use <code>isin</code>:</p>
<pre><code>df.loc[df['column_name'].isin(some_values)]
</code></pre>
<p>Combine multiple conditions with <code>&amp;</code>:</p>
<pre><code>df.loc[(df['column_name'] &gt;= A) &amp; (df['column_name'] &lt;= B)]
</code></pre>
<p>Note the parentheses. Due to Python's <a href="https://docs.python.org/3/reference/expressions.html#operator-precedence" rel="noreferrer">operator precedence rules</a>, <code>&amp;</code> binds more tightly than <code>&lt;=</code> and <code>&gt;=</code>. Thus, the parentheses in the last example are necessary. Without the parentheses</p>
<pre><code>df['column_name'] &gt;= A &amp; df['column_name'] &lt;= B
</code></pre>
<p>is parsed as</p>
<pre><code>df['column_name'] &gt;= (A &amp; df['column_name']) &lt;= B
</code></pre>
<p>which results in a <a href="https://stackoverflow.com/questions/36921951/truth-value-of-a-series-is-ambiguous-use-a-empty-a-bool-a-item-a-any-o">Truth value of a Series is ambiguous error</a>.</p>
<hr />
<p>To select rows whose column value <em>does not equal</em> <code>some_value</code>, use <code>!=</code>:</p>
<pre><code>df.loc[df['column_name'] != some_value]
</code></pre>
<p>The <code>isin</code> returns a boolean Series, so to select rows whose value is <em>not</em> in <code>some_values</code>, negate the boolean Series using <code>~</code>:</p>
<pre><code>df = df.loc[~df['column_name'].isin(some_values)] # .loc is not in-place replacement
</code></pre>
<hr />
<p>For example,</p>
<pre><code>import pandas as pd
import numpy as np
df = pd.DataFrame({'A': 'foo bar foo bar foo bar foo foo'.split(),
                   'B': 'one one two three two two one three'.split(),
                   'C': np.arange(8), 'D': np.arange(8) * 2})
print(df)
#      A      B  C   D
# 0  foo    one  0   0
# 1  bar    one  1   2
# 2  foo    two  2   4
# 3  bar  three  3   6
# 4  foo    two  4   8
# 5  bar    two  5  10
# 6  foo    one  6  12
# 7  foo  three  7  14

print(df.loc[df['A'] == 'foo'])
</code></pre>
<p>yields</p>
<pre><code>     A      B  C   D
0  foo    one  0   0
2  foo    two  2   4
4  foo    two  4   8
6  foo    one  6  12
7  foo  three  7  14
</code></pre>
<hr />
<p>If you have multiple values you want to include, put them in a
list (or more generally, any iterable) and use <code>isin</code>:</p>
<pre><code>print(df.loc[df['B'].isin(['one','three'])])
</code></pre>
<p>yields</p>
<pre><code>     A      B  C   D
0  foo    one  0   0
1  bar    one  1   2
3  bar  three  3   6
6  foo    one  6  12
7  foo  three  7  14
</code></pre>
<hr />
<p>Note, however, that if you wish to do this many times, it is more efficient to
make an index first, and then use <code>df.loc</code>:</p>
<pre><code>df = df.set_index(['B'])
print(df.loc['one'])
</code></pre>
<p>yields</p>
<pre><code>       A  C   D
B              
one  foo  0   0
one  bar  1   2
one  foo  6  12
</code></pre>
<p>or, to include multiple values from the index use <code>df.index.isin</code>:</p>
<pre><code>df.loc[df.index.isin(['one','two'])]
</code></pre>
<p>yields</p>
<pre><code>       A  C   D
B              
one  foo  0   0
one  bar  1   2
two  foo  2   4
two  foo  4   8
two  bar  5  10
one  foo  6  12
</code></pre>
<h4> user3871, Comment 132858069 Score: 3: </h4>Do you know how to do this if you don&#39;t have column labels, i.e., by column index? For example, return rows where Col 0 = &quot;some value&quot;. <code>df.iloc[df[0] == some_value]</code> doesn&#39;t work, giving error <code>Cannot index by location index with a non-integer key.</code> Though <code>df.loc[df.iloc[:, 0] == &#39;some_value&#39;]</code> seems to work.<br><h4> hobs, Comment 135217477 Score: 1: </h4>@user3871 as the error message explains (and the examples in the answer show), you need to use <code>df.loc[...]</code> when the ... is a boolean Series (which is what the <code>==</code> binary operator on a pair of <code>Series</code> returns.  And all <code>DataFrame</code> s have column labels, even if you never set any. You can find out what they are with <code>df.columns</code> . So wherever you have <code>df[0]</code> you could use <code>df[df.columns[0]]</code> .<br>------------------------------------------------------------------ <br><h3> piRSquared, Id: 46165056, Score: 811: </h3><p>There are several ways to select rows from a Pandas dataframe:</p>
<ol>
<li><strong>Boolean indexing (<code>df[df['col'] == value</code>] )</strong></li>
<li><strong>Positional indexing (<code>df.iloc[...]</code>)</strong></li>
<li><strong>Label indexing (<code>df.xs(...)</code>)</strong></li>
<li><strong><code>df.query(...)</code> API</strong></li>
</ol>
<p>Below I show you examples of each, with advice when to use certain techniques. Assume our criterion is column <code>'A'</code> == <code>'foo'</code></p>
<p>(Note on performance: For each base type, we can keep things simple by using the Pandas API or we can venture outside the API, usually into NumPy, and speed things up.)</p>
<hr />
<p><strong>Setup</strong></p>
<p>The first thing we'll need is to identify a condition that will act as our criterion for selecting rows. We'll start with the OP's case <code>column_name == some_value</code>, and include some other common use cases.</p>
<p>Borrowing from @unutbu:</p>
<pre><code>import pandas as pd, numpy as np

df = pd.DataFrame({'A': 'foo bar foo bar foo bar foo foo'.split(),
                   'B': 'one one two three two two one three'.split(),
                   'C': np.arange(8), 'D': np.arange(8) * 2})
</code></pre>
<hr />
<h1><strong>1. Boolean indexing</strong></h1>
<p>... Boolean indexing requires finding the true value of each row's <code>'A'</code> column being equal to <code>'foo'</code>, then using those truth values to identify which rows to keep.  Typically, we'd name this series, an array of truth values, <code>mask</code>.  We'll do so here as well.</p>
<pre><code>mask = df['A'] == 'foo'
</code></pre>
<p>We can then use this mask to slice or index the data frame</p>
<pre><code>df[mask]

     A      B  C   D
0  foo    one  0   0
2  foo    two  2   4
4  foo    two  4   8
6  foo    one  6  12
7  foo  three  7  14
</code></pre>
<p>This is one of the simplest ways to accomplish this task and if performance or intuitiveness isn't an issue, this should be your chosen method.  However, if performance is a concern, then you might want to consider an alternative way of creating the <code>mask</code>.</p>
<hr />
<h1><strong>2. Positional indexing</strong></h1>
<p>Positional indexing (<code>df.iloc[...]</code>) has its use cases, but this isn't one of them.  In order to identify where to slice, we first need to perform the same boolean analysis we did above.  This leaves us performing one extra step to accomplish the same task.</p>
<pre><code>mask = df['A'] == 'foo'
pos = np.flatnonzero(mask)
df.iloc[pos]

     A      B  C   D
0  foo    one  0   0
2  foo    two  2   4
4  foo    two  4   8
6  foo    one  6  12
7  foo  three  7  14
</code></pre>
<h1><strong>3. Label indexing</strong></h1>
<p><em>Label</em> indexing can be very handy, but in this case, we are again doing more work for no benefit</p>
<pre><code>df.set_index('A', append=True, drop=False).xs('foo', level=1)

     A      B  C   D
0  foo    one  0   0
2  foo    two  2   4
4  foo    two  4   8
6  foo    one  6  12
7  foo  three  7  14
</code></pre>
<h1><strong>4. <code>df.query()</code> API</strong></h1>
<p><em><code>pd.DataFrame.query</code></em> is a very elegant/intuitive way to perform this task, but is often slower. <strong>However</strong>, if you pay attention to the timings below, for large data, the query is very efficient. More so than the standard approach and of similar magnitude as my best suggestion.</p>
<pre><code>df.query('A == &quot;foo&quot;')

     A      B  C   D
0  foo    one  0   0
2  foo    two  2   4
4  foo    two  4   8
6  foo    one  6  12
7  foo  three  7  14
</code></pre>
<hr />
<p>My preference is to use the <code>Boolean</code> <code>mask</code></p>
<p>Actual improvements can be made by modifying how we create our <code>Boolean</code> <code>mask</code>.</p>
<p><strong><code>mask</code> alternative 1</strong>
<em>Use the underlying NumPy array and forgo the overhead of creating another <code>pd.Series</code></em></p>
<pre><code>mask = df['A'].values == 'foo'
</code></pre>
<p>I'll show more complete time tests at the end, but just take a look at the performance gains we get using the sample data frame.  First, we look at the difference in creating the <code>mask</code></p>
<pre><code>%timeit mask = df['A'].values == 'foo'
%timeit mask = df['A'] == 'foo'

5.84 µs ± 195 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)
166 µs ± 4.45 µs per loop (mean ± std. dev. of 7 runs, 10000 loops each)
</code></pre>
<p>Evaluating the <code>mask</code> with the NumPy array is ~ 30 times faster.  This is partly due to NumPy evaluation often being faster. It is also partly due to the lack of overhead necessary to build an index and a corresponding <code>pd.Series</code> object.</p>
<p>Next, we'll look at the timing for slicing with one <code>mask</code> versus the other.</p>
<pre><code>mask = df['A'].values == 'foo'
%timeit df[mask]
mask = df['A'] == 'foo'
%timeit df[mask]

219 µs ± 12.3 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each)
239 µs ± 7.03 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each)
</code></pre>
<p>The performance gains aren't as pronounced.  We'll see if this holds up over more robust testing.</p>
<hr />
<p><strong><code>mask</code> alternative 2</strong>
We could have reconstructed the data frame as well.  There is a big caveat when reconstructing a dataframe—you must take care of the <code>dtypes</code> when doing so!</p>
<p>Instead of <code>df[mask]</code> we will do this</p>
<pre><code>pd.DataFrame(df.values[mask], df.index[mask], df.columns).astype(df.dtypes)
</code></pre>
<p>If the data frame is of mixed type, which our example is, then when we get <code>df.values</code> the resulting array is of <code>dtype</code> <code>object</code> and consequently, all columns of the new data frame will be of <code>dtype</code> <code>object</code>.  Thus requiring the <code>astype(df.dtypes)</code> and killing any potential performance gains.</p>
<pre><code>%timeit df[m]
%timeit pd.DataFrame(df.values[mask], df.index[mask], df.columns).astype(df.dtypes)

216 µs ± 10.4 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each)
1.43 ms ± 39.6 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each)
</code></pre>
<p>However, if the data frame is not of mixed type, this is a very useful way to do it.</p>
<p>Given</p>
<pre><code>np.random.seed([3,1415])
d1 = pd.DataFrame(np.random.randint(10, size=(10, 5)), columns=list('ABCDE'))

d1

   A  B  C  D  E
0  0  2  7  3  8
1  7  0  6  8  6
2  0  2  0  4  9
3  7  3  2  4  3
4  3  6  7  7  4
5  5  3  7  5  9
6  8  7  6  4  7
7  6  2  6  6  5
8  2  8  7  5  8
9  4  7  6  1  5
</code></pre>
<hr />
<pre><code>%%timeit
mask = d1['A'].values == 7
d1[mask]

179 µs ± 8.73 µs per loop (mean ± std. dev. of 7 runs, 10000 loops each)
</code></pre>
<p>Versus</p>
<pre><code>%%timeit
mask = d1['A'].values == 7
pd.DataFrame(d1.values[mask], d1.index[mask], d1.columns)

87 µs ± 5.12 µs per loop (mean ± std. dev. of 7 runs, 10000 loops each)
</code></pre>
<p>We cut the time in half.</p>
<hr />
<p><strong><code>mask</code> alternative 3</strong></p>
<p>@unutbu also shows us how to use <code>pd.Series.isin</code> to account for each element of <code>df['A']</code> being in a set of values.  This evaluates to the same thing if our set of values is a set of one value, namely <code>'foo'</code>.  But it also generalizes to include larger sets of values if needed.  Turns out, this is still pretty fast even though it is a more general solution.  The only real loss is in intuitiveness for those not familiar with the concept.</p>
<pre><code>mask = df['A'].isin(['foo'])
df[mask]

     A      B  C   D
0  foo    one  0   0
2  foo    two  2   4
4  foo    two  4   8
6  foo    one  6  12
7  foo  three  7  14
</code></pre>
<p>However, as before, we can utilize NumPy to improve performance while sacrificing virtually nothing. We'll use <code>np.in1d</code></p>
<pre><code>mask = np.in1d(df['A'].values, ['foo'])
df[mask]

     A      B  C   D
0  foo    one  0   0
2  foo    two  2   4
4  foo    two  4   8
6  foo    one  6  12
7  foo  three  7  14
</code></pre>
<hr />
<p><strong>Timing</strong></p>
<p>I'll include other concepts mentioned in other posts as well for reference.</p>
<p><em>Code Below</em></p>
<p>Each <em>column</em> in this table represents a different length data frame over which we test each function. Each column shows relative time taken, with the fastest function given a base index of <code>1.0</code>.</p>
<pre><code>res.div(res.min())

                         10        30        100       300       1000      3000      10000     30000
mask_standard         2.156872  1.850663  2.034149  2.166312  2.164541  3.090372  2.981326  3.131151
mask_standard_loc     1.879035  1.782366  1.988823  2.338112  2.361391  3.036131  2.998112  2.990103
mask_with_values      1.010166  1.000000  1.005113  1.026363  1.028698  1.293741  1.007824  1.016919
mask_with_values_loc  1.196843  1.300228  1.000000  1.000000  1.038989  1.219233  1.037020  1.000000
query                 4.997304  4.765554  5.934096  4.500559  2.997924  2.397013  1.680447  1.398190
xs_label              4.124597  4.272363  5.596152  4.295331  4.676591  5.710680  6.032809  8.950255
mask_with_isin        1.674055  1.679935  1.847972  1.724183  1.345111  1.405231  1.253554  1.264760
mask_with_in1d        1.000000  1.083807  1.220493  1.101929  1.000000  1.000000  1.000000  1.144175
</code></pre>
<p>You'll notice that the fastest times seem to be shared between <code>mask_with_values</code> and <code>mask_with_in1d</code>.</p>
<pre><code>res.T.plot(loglog=True)
</code></pre>
<p><a href="https://i.stack.imgur.com/ljeTd.png" rel="noreferrer"><img src="https://i.stack.imgur.com/ljeTd.png" alt="Enter image description here" /></a></p>
<p><strong>Functions</strong></p>
<pre><code>def mask_standard(df):
    mask = df['A'] == 'foo'
    return df[mask]

def mask_standard_loc(df):
    mask = df['A'] == 'foo'
    return df.loc[mask]

def mask_with_values(df):
    mask = df['A'].values == 'foo'
    return df[mask]

def mask_with_values_loc(df):
    mask = df['A'].values == 'foo'
    return df.loc[mask]

def query(df):
    return df.query('A == &quot;foo&quot;')

def xs_label(df):
    return df.set_index('A', append=True, drop=False).xs('foo', level=-1)

def mask_with_isin(df):
    mask = df['A'].isin(['foo'])
    return df[mask]

def mask_with_in1d(df):
    mask = np.in1d(df['A'].values, ['foo'])
    return df[mask]
</code></pre>
<hr />
<p><strong>Testing</strong></p>
<pre><code>res = pd.DataFrame(
    index=[
        'mask_standard', 'mask_standard_loc', 'mask_with_values', 'mask_with_values_loc',
        'query', 'xs_label', 'mask_with_isin', 'mask_with_in1d'
    ],
    columns=[10, 30, 100, 300, 1000, 3000, 10000, 30000],
    dtype=float
)

for j in res.columns:
    d = pd.concat([df] * j, ignore_index=True)
    for i in res.index:a
        stmt = '{}(d)'.format(i)
        setp = 'from __main__ import d, {}'.format(i)
        res.at[i, j] = timeit(stmt, setp, number=50)
</code></pre>
<hr />
<p><strong>Special Timing</strong></p>
<p>Looking at the special case when we have a single non-object <code>dtype</code> for the entire data frame.</p>
<p><em>Code Below</em></p>
<pre><code>spec.div(spec.min())

                     10        30        100       300       1000      3000      10000     30000
mask_with_values  1.009030  1.000000  1.194276  1.000000  1.236892  1.095343  1.000000  1.000000
mask_with_in1d    1.104638  1.094524  1.156930  1.072094  1.000000  1.000000  1.040043  1.027100
reconstruct       1.000000  1.142838  1.000000  1.355440  1.650270  2.222181  2.294913  3.406735
</code></pre>
<p>Turns out, reconstruction isn't worth it past a few hundred rows.</p>
<pre><code>spec.T.plot(loglog=True)
</code></pre>
<p><a href="https://i.stack.imgur.com/K1bNc.png" rel="noreferrer"><img src="https://i.stack.imgur.com/K1bNc.png" alt="Enter image description here" /></a></p>
<p><strong>Functions</strong></p>
<pre><code>np.random.seed([3,1415])
d1 = pd.DataFrame(np.random.randint(10, size=(10, 5)), columns=list('ABCDE'))

def mask_with_values(df):
    mask = df['A'].values == 'foo'
    return df[mask]

def mask_with_in1d(df):
    mask = np.in1d(df['A'].values, ['foo'])
    return df[mask]

def reconstruct(df):
    v = df.values
    mask = np.in1d(df['A'].values, ['foo'])
    return pd.DataFrame(v[mask], df.index[mask], df.columns)

spec = pd.DataFrame(
    index=['mask_with_values', 'mask_with_in1d', 'reconstruct'],
    columns=[10, 30, 100, 300, 1000, 3000, 10000, 30000],
    dtype=float
)
</code></pre>
<p><strong>Testing</strong></p>
<pre><code>for j in spec.columns:
    d = pd.concat([df] * j, ignore_index=True)
    for i in spec.index:
        stmt = '{}(d)'.format(i)
        setp = 'from __main__ import d, {}'.format(i)
        spec.at[i, j] = timeit(stmt, setp, number=50)
</code></pre>
<h4> Confounded, Comment 136068206 Score: 0: </h4>I personally like to use <code>groupby</code> and <code>filter</code> as in <code>df.groupby([&#39;column_name&#39;]).filter(lambda x: x.name == column_value)</code>.<br>------------------------------------------------------------------ <br><h3> imolit, Id: 31296878, Score: 352: </h3><h3>tl;dr</h3>
<p>The Pandas equivalent to</p>
<pre><code>select * from table where column_name = some_value
</code></pre>
<p>is</p>
<pre><code>table[table.column_name == some_value]
</code></pre>
<p>Multiple conditions:</p>
<pre><code>table[(table.column_name == some_value) | (table.column_name2 == some_value2)]
</code></pre>
<p>or</p>
<pre><code>table.query('column_name == some_value | column_name2 == some_value2')
</code></pre>
<h3>Code example</h3>
<pre><code>import pandas as pd

# Create data set
d = {'foo':[100, 111, 222],
     'bar':[333, 444, 555]}
df = pd.DataFrame(d)

# Full dataframe:
df

# Shows:
#    bar   foo
# 0  333   100
# 1  444   111
# 2  555   222

# Output only the row(s) in df where foo is 222:
df[df.foo == 222]

# Shows:
#    bar  foo
# 2  555  222
</code></pre>
<p>In the above code it is the line <code>df[df.foo == 222]</code> that gives the rows based on the column value, <code>222</code> in this case.</p>
<p>Multiple conditions are also possible:</p>
<pre><code>df[(df.foo == 222) | (df.bar == 444)]
#    bar  foo
# 1  444  111
# 2  555  222
</code></pre>
<p>But at that point I would recommend using the <a href="https://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.query.html" rel="noreferrer">query</a> function, since it's less verbose and yields the same result:</p>
<pre><code>df.query('foo == 222 | bar == 444')
</code></pre>
------------------------------------------------------------------ <br><h3> fredcallaway, Id: 35282530, Score: 94: </h3><p>I find the syntax of the previous answers to be redundant and difficult to remember. Pandas introduced the <code>query()</code> method in v0.13 and I much prefer it. For your question, you could do <code>df.query('col == val')</code>.</p>
<p>Reproduced from <em><a href="http://pandas.pydata.org/pandas-docs/version/0.17.0/indexing.html#indexing-query" rel="noreferrer">The query() Method (Experimental)</a></em>:</p>
<pre><code>In [167]: n = 10

In [168]: df = pd.DataFrame(np.random.rand(n, 3), columns=list('abc'))

In [169]: df
Out[169]:
          a         b         c
0  0.687704  0.582314  0.281645
1  0.250846  0.610021  0.420121
2  0.624328  0.401816  0.932146
3  0.011763  0.022921  0.244186
4  0.590198  0.325680  0.890392
5  0.598892  0.296424  0.007312
6  0.634625  0.803069  0.123872
7  0.924168  0.325076  0.303746
8  0.116822  0.364564  0.454607
9  0.986142  0.751953  0.561512

# pure python
In [170]: df[(df.a &lt; df.b) &amp; (df.b &lt; df.c)]
Out[170]:
          a         b         c
3  0.011763  0.022921  0.244186
8  0.116822  0.364564  0.454607

# query
In [171]: df.query('(a &lt; b) &amp; (b &lt; c)')
Out[171]:
          a         b         c
3  0.011763  0.022921  0.244186
8  0.116822  0.364564  0.454607
</code></pre>
<p>You can also access variables in the environment by prepending an <code>@</code>.</p>
<pre><code>exclude = ('red', 'orange')
df.query('color not in @exclude')
</code></pre>
------------------------------------------------------------------ <br><h3> Erfan, Id: 57338153, Score: 73: </h3><h3>More flexibility using <code>.query</code> with pandas &gt;= 0.25.0:</h3>
<p>Since pandas &gt;= 0.25.0 we can use the <code>query</code> method to filter dataframes with pandas methods and even column names which have spaces. Normally the spaces in column names would give an error, but now we can solve that using a backtick (`) - see <a href="https://github.com/pandas-dev/pandas/issues/6508" rel="noreferrer">GitHub</a>:</p>
<pre><code># Example dataframe
df = pd.DataFrame({'Sender email':['ex@example.com', &quot;reply@shop.com&quot;, &quot;buy@shop.com&quot;]})

     Sender email
0  ex@example.com
1  reply@shop.com
2    buy@shop.com
</code></pre>
<p>Using <code>.query</code> with method <code>str.endswith</code>:</p>
<pre><code>df.query('`Sender email`.str.endswith(&quot;@shop.com&quot;)')
</code></pre>
<p><strong>Output</strong></p>
<pre><code>     Sender email
1  reply@shop.com
2    buy@shop.com
</code></pre>
<hr />
<p>Also we can use local variables by prefixing it with an <code>@</code> in our query:</p>
<pre><code>domain = 'shop.com'
df.query('`Sender email`.str.endswith(@domain)')
</code></pre>
<p><strong>Output</strong></p>
<pre><code>     Sender email
1  reply@shop.com
2    buy@shop.com
</code></pre>
------------------------------------------------------------------ <br><h3> SP001, Id: 47693145, Score: 43: </h3><p>For selecting only specific columns out of multiple columns for a given value in Pandas:</p>
<pre><code>select col_name1, col_name2 from table where column_name = some_value.
</code></pre>
<p>Options <a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.loc.html" rel="noreferrer"><code>loc</code></a>:</p>
<pre><code>df.loc[df['column_name'] == some_value, [col_name1, col_name2]]
</code></pre>
<p>or <a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.query.html" rel="noreferrer"><code>query</code></a>:</p>
<pre><code>df.query('column_name == some_value')[[col_name1, col_name2]]
</code></pre>
------------------------------------------------------------------ <br><h3> shivsn, Id: 44931669, Score: 36: </h3><p>Faster results can be achieved using <a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.where.html" rel="noreferrer">numpy.where</a>. </p>

<p>For example, with <a href="https://stackoverflow.com/questions/17071871/select-rows-from-a-dataframe-based-on-values-in-a-column-in-pandas/17071908#17071908">unubtu's setup</a> -</p>

<pre><code>In [76]: df.iloc[np.where(df.A.values=='foo')]
Out[76]: 
     A      B  C   D
0  foo    one  0   0
2  foo    two  2   4
4  foo    two  4   8
6  foo    one  6  12
7  foo  three  7  14
</code></pre>

<p>Timing comparisons:</p>

<pre><code>In [68]: %timeit df.iloc[np.where(df.A.values=='foo')]  # fastest
1000 loops, best of 3: 380 µs per loop

In [69]: %timeit df.loc[df['A'] == 'foo']
1000 loops, best of 3: 745 µs per loop

In [71]: %timeit df.loc[df['A'].isin(['foo'])]
1000 loops, best of 3: 562 µs per loop

In [72]: %timeit df[df.A=='foo']
1000 loops, best of 3: 796 µs per loop

In [74]: %timeit df.query('(A=="foo")')  # slowest
1000 loops, best of 3: 1.71 ms per loop
</code></pre>
------------------------------------------------------------------ <br><h3> Punnerud, Id: 65578196, Score: 36: </h3><p>In newer versions of Pandas, inspired by the documentation (<em><a href="https://pandas.pydata.org/docs/user_guide/10min.html#viewing-data" rel="noreferrer">Viewing data</a></em>):</p>
<pre><code>df[df[&quot;colume_name&quot;] == some_value] #Scalar, True/False..

df[df[&quot;colume_name&quot;] == &quot;some_value&quot;] #String
</code></pre>
<p>Combine multiple conditions by putting the clause in parentheses, <code>()</code>, and combining them with <code>&amp;</code> and <code>|</code> (and/or). Like this:</p>
<pre><code>df[(df[&quot;colume_name&quot;] == &quot;some_value1&quot;) &amp; (pd[pd[&quot;colume_name&quot;] == &quot;some_value2&quot;])]
</code></pre>
<p>Other filters</p>
<pre><code>pandas.notna(df[&quot;colume_name&quot;]) == True # Not NaN
df['colume_name'].str.contains(&quot;text&quot;) # Search for &quot;text&quot;
df['colume_name'].str.lower().str.contains(&quot;text&quot;) # Search for &quot;text&quot;, after converting  to lowercase
</code></pre>
------------------------------------------------------------------ <br><h3> DataByDavid, Id: 17086321, Score: 31: </h3><p>Here is a simple example  </p>

<pre><code>from pandas import DataFrame

# Create data set
d = {'Revenue':[100,111,222], 
     'Cost':[333,444,555]}
df = DataFrame(d)


# mask = Return True when the value in column "Revenue" is equal to 111
mask = df['Revenue'] == 111

print mask

# Result:
# 0    False
# 1     True
# 2    False
# Name: Revenue, dtype: bool


# Select * FROM df WHERE Revenue = 111
df[mask]

# Result:
#    Cost    Revenue
# 1  444     111
</code></pre>
------------------------------------------------------------------ <br><h3> TuanDT, Id: 40676816, Score: 20: </h3><p>To add: You can also do <code>df.groupby('column_name').get_group('column_desired_value').reset_index()</code> to make a new data frame with specified column having a particular value. E.g.,</p>
<pre><code>import pandas as pd
df = pd.DataFrame({'A': 'foo bar foo bar foo bar foo foo'.split(),
                   'B': 'one one two three two two one three'.split()})
print(&quot;Original dataframe:&quot;)
print(df)

b_is_two_dataframe = pd.DataFrame(df.groupby('B').get_group('two').reset_index()).drop('index', axis = 1) 
#NOTE: the final drop is to remove the extra index column returned by groupby object
print('Sub dataframe where B is two:')
print(b_is_two_dataframe)
</code></pre>
<p>Running this gives:</p>
<pre class="lang-none prettyprint-override"><code>Original dataframe:
     A      B
0  foo    one
1  bar    one
2  foo    two
3  bar  three
4  foo    two
5  bar    two
6  foo    one
7  foo  three
Sub dataframe where B is two:
     A    B
0  foo  two
1  foo  two
2  bar  two
</code></pre>
<h4> ali bakhtiari, Comment 132360483 Score: 0: </h4>Instead of ` .drop(&#39;index&#39;, axis = 1)` and creating a new dataframe, you could simply set <code>drop=True</code> in <code>.reset_index()</code><br>------------------------------------------------------------------ <br><h3> cottontail, Id: 73762002, Score: 13: </h3><h2>1. Use f-strings inside <code>query()</code> calls</h2>
<p>If the column name used to filter your dataframe comes from a local variable, f-strings may be useful. For example,</p>
<pre class="lang-py prettyprint-override"><code>col = 'A'
df.query(f&quot;{col} == 'foo'&quot;)
</code></pre>
<p>In fact, f-strings can be used for the query variable as well (except for datetime):</p>
<pre class="lang-py prettyprint-override"><code>col = 'A'
my_var = 'foo'
df.query(f&quot;{col} == '{my_var}'&quot;) # if my_var is a string

my_num = 1
df.query(f&quot;{col} == {my_num}&quot;) # if my_var is a number

my_date = '2022-12-10'
df.query(f&quot;{col} == @my_date&quot;) # must use @ for datetime though
</code></pre>
<h2>2. Install <code>numexpr</code> to speed up <code>query()</code> calls</h2>
<p>The pandas documentation <a href="https://pandas.pydata.org/docs/getting_started/install.html#install-recommended-dependencies" rel="noreferrer">recommends installing numexpr</a> to speed up numeric calculation when using <code>query()</code>. Use <code>pip install numexpr</code> (or <code>conda</code>, <code>sudo</code> etc. depending on your environment) to install it.</p>
<p>For larger dataframes (where performance actually matters), <code>df.query()</code> with <code>numexpr</code> engine performs much faster than <code>df[mask]</code>. In particular, it performs better for the following cases.</p>
<p><strong>Logical and/or comparison operators on columns of strings</strong></p>
<p>If a column of strings are compared to some other string(s) and matching rows are to be selected, even for a single comparison operation, <code>query()</code> performs faster than <code>df[mask]</code>. For example, for a dataframe with 80k rows, it's 30% faster<sup>1</sup> and for a dataframe with 800k rows, it's 60% faster.<sup>2</sup></p>
<pre class="lang-py prettyprint-override"><code>df[df.A == 'foo']
df.query(&quot;A == 'foo'&quot;)  # &lt;--- performs 30%-60% faster
</code></pre>
<p>This gap increases as the number of operations increases (if 4 comparisons are chained <code>df.query()</code> is 2-2.3 times faster than <code>df[mask]</code>)<sup>1,2</sup> and/or the dataframe length increases.<sup>2</sup></p>
<p><strong>Multiple operations on numeric columns</strong></p>
<p>If multiple arithmetic, logical or comparison operations need to be computed to create a boolean mask to filter <code>df</code>, <code>query()</code> performs faster. For example, for a frame with 80k rows, it's 20% faster<sup>1</sup> and for a frame with 800k rows, it's 2 times faster.<sup>2</sup></p>
<pre class="lang-py prettyprint-override"><code>df[(df.B % 5) **2 &lt; 0.1]
df.query(&quot;(B % 5) **2 &lt; 0.1&quot;)  # &lt;--- performs 20%-100% faster.
</code></pre>
<p>This gap in performance increases as the number of operations increases and/or the dataframe length increases.<sup>2</sup></p>
<p>The following plot shows how the methods perform as the dataframe length increases.<sup>3</sup></p>
<p><a href="https://i.stack.imgur.com/AgEhg.png" rel="noreferrer"><img src="https://i.stack.imgur.com/AgEhg.png" alt="perfplot" /></a></p>
<h2>3. Call pandas methods inside <code>query()</code></h2>
<p><code>Numexpr</code> <a href="https://numexpr.readthedocs.io/projects/NumExpr3/en/latest/user_guide.html#supported-operators" rel="noreferrer">currently supports</a> only logical (<code>&amp;</code>, <code>|</code>, <code>~</code>), comparison (<code>==</code>, <code>&gt;</code>, <code>&lt;</code>, <code>&gt;=</code>, <code>&lt;=</code>, <code>!=</code>) and basic arithmetic operators (<code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>**</code>, <code>%</code>).</p>
<p>For example, it doesn't support integer division (<code>//</code>). However, calling the equivalent pandas method (<code>floordiv()</code>) works.</p>
<pre class="lang-py prettyprint-override"><code>df.query('B.floordiv(2) &lt;= 3')  # or 
df.query('B.floordiv(2).le(3)')

# for pandas &lt; 1.4, need `.values`
df.query('B.floordiv(2).values &lt;= 3')
</code></pre>
<br>
<hr />
<p><sup>1</sup> Benchmark code using a frame with 80k rows</p>
<pre class="lang-py prettyprint-override"><code>import numpy as np
df = pd.DataFrame({'A': 'foo bar foo baz foo bar foo foo'.split()*10000, 
                   'B': np.random.rand(80000)})

%timeit df[df.A == 'foo']
# 8.5 ms ± 104.5 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)
%timeit df.query(&quot;A == 'foo'&quot;)
# 6.36 ms ± 95.7 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)

%timeit df[((df.A == 'foo') &amp; (df.A != 'bar')) | ((df.A != 'baz') &amp; (df.A != 'buz'))]
# 29 ms ± 554 µs per loop (mean ± std. dev. of 10 runs, 100 loops each)
%timeit df.query(&quot;A == 'foo' &amp; A != 'bar' | A != 'baz' &amp; A != 'buz'&quot;)
# 16 ms ± 339 µs per loop (mean ± std. dev. of 10 runs, 100 loops each)

%timeit df[(df.B % 5) **2 &lt; 0.1]
# 5.35 ms ± 37.6 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)
%timeit df.query(&quot;(B % 5) **2 &lt; 0.1&quot;)
# 4.37 ms ± 46.3 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)
</code></pre>
<p><sup>2</sup> Benchmark code using a frame with 800k rows</p>
<pre class="lang-py prettyprint-override"><code>df = pd.DataFrame({'A': 'foo bar foo baz foo bar foo foo'.split()*100000, 
                   'B': np.random.rand(800000)})

%timeit df[df.A == 'foo']
# 87.9 ms ± 873 µs per loop (mean ± std. dev. of 10 runs, 100 loops each)
%timeit df.query(&quot;A == 'foo'&quot;)
# 54.4 ms ± 726 µs per loop (mean ± std. dev. of 10 runs, 100 loops each)

%timeit df[((df.A == 'foo') &amp; (df.A != 'bar')) | ((df.A != 'baz') &amp; (df.A != 'buz'))]
# 310 ms ± 3.4 ms per loop (mean ± std. dev. of 10 runs, 100 loops each)
%timeit df.query(&quot;A == 'foo' &amp; A != 'bar' | A != 'baz' &amp; A != 'buz'&quot;)
# 132 ms ± 2.43 ms per loop (mean ± std. dev. of 10 runs, 100 loops each)

%timeit df[(df.B % 5) **2 &lt; 0.1]
# 54 ms ± 488 µs per loop (mean ± std. dev. of 10 runs, 100 loops each)
%timeit df.query(&quot;(B % 5) **2 &lt; 0.1&quot;)
# 26.3 ms ± 320 µs per loop (mean ± std. dev. of 10 runs, 100 loops each)
</code></pre>
<p><sup>3</sup>: Code used to produce the performance graphs of the two methods for strings and numbers.</p>
<pre class="lang-py prettyprint-override"><code>from perfplot import plot
constructor = lambda n: pd.DataFrame({'A': 'foo bar foo baz foo bar foo foo'.split()*n, 'B': np.random.rand(8*n)})
plot(
    setup=constructor,
    kernels=[lambda df: df[(df.B%5)**2&lt;0.1], lambda df: df.query(&quot;(B%5)**2&lt;0.1&quot;)],
    labels= ['df[(df.B % 5) **2 &lt; 0.1]', 'df.query(&quot;(B % 5) **2 &lt; 0.1&quot;)'],
    n_range=[2**k for k in range(4, 24)],
    xlabel='Rows in DataFrame',
    title='Multiple mathematical operations on numbers',
    equality_check=pd.DataFrame.equals);
plot(
    setup=constructor,
    kernels=[lambda df: df[df.A == 'foo'], lambda df: df.query(&quot;A == 'foo'&quot;)],
    labels= [&quot;df[df.A == 'foo']&quot;, &quot;&quot;&quot;df.query(&quot;A == 'foo'&quot;)&quot;&quot;&quot;],
    n_range=[2**k for k in range(4, 24)],
    xlabel='Rows in DataFrame',
    title='Comparison operation on strings',
    equality_check=pd.DataFrame.equals);
</code></pre>
------------------------------------------------------------------ <br><h3> vahid, Id: 53674430, Score: 11: </h3><p>You can also use .apply:</p>

<pre><code>df.apply(lambda row: row[df['B'].isin(['one','three'])])
</code></pre>

<p>It actually works row-wise (i.e., applies the function to each row).</p>

<p>The output is </p>

<pre><code>   A      B  C   D
0  foo    one  0   0
1  bar    one  1   2
3  bar  three  3   6
6  foo    one  6  12
7  foo  three  7  14
</code></pre>

<p>The results is the same as using as mentioned by @unutbu</p>

<pre><code>df[[df['B'].isin(['one','three'])]]
</code></pre>
------------------------------------------------------------------ <br><h3> lord-hasan, Id: 70120429, Score: 5: </h3><p>If you want to make query to your dataframe repeatedly and speed is important to you, the best thing is to convert your dataframe to dictionary and then by doing this you can make query thousands of times faster.</p>
<pre><code>my_df = df.set_index(column_name)
my_dict = my_df.to_dict('index')
</code></pre>
<p>After make my_dict dictionary you can go through:</p>
<pre><code>if some_value in my_dict.keys():
   my_result = my_dict[some_value]
</code></pre>
<p>If you have duplicated values in column_name you can't make a dictionary. but you can use:</p>
<pre><code>my_result = my_df.loc[some_value]
</code></pre>
------------------------------------------------------------------ <br><h3> Erfan, Id: 71952267, Score: 5: </h3><h3>SQL statements on DataFrames to select rows using DuckDB</h3>
<p>With <a href="https://duckdb.org/docs/guides/python/sql_on_pandas" rel="nofollow noreferrer">DuckDB</a> we can query pandas DataFrames with SQL statements, in a <a href="https://duckdb.org/2021/05/14/sql-on-pandas.html" rel="nofollow noreferrer">highly performant way</a>.</p>
<p>Since the question is <em>How do I select rows from a DataFrame based on column values?</em>, and the example in the question is a SQL query, this answer looks logical in this topic.</p>
<p><strong>Example</strong>:</p>
<pre class="lang-py prettyprint-override"><code>In [1]: import duckdb

In [2]: import pandas as pd

In [3]: con = duckdb.connect()

In [4]: df = pd.DataFrame({&quot;A&quot;: range(11), &quot;B&quot;: range(11, 22)})

In [5]: df
Out[5]:
     A   B
0    0  11
1    1  12
2    2  13
3    3  14
4    4  15
5    5  16
6    6  17
7    7  18
8    8  19
9    9  20
10  10  21

In [6]: results = con.execute(&quot;SELECT * FROM df where A &gt; 2&quot;).df()

In [7]: results
Out[7]:
    A   B
0   3  14
1   4  15
2   5  16
3   6  17
4   7  18
5   8  19
6   9  20
7  10  21
</code></pre>
------------------------------------------------------------------ <br><h3> Mykola Zotko, Id: 73213567, Score: 5: </h3><p>You can use <code>loc</code> (square brackets) with a function:</p>
<pre><code># Series
s = pd.Series([1, 2, 3, 4]) 
s.loc[lambda x: x &gt; 1]
# s[lambda x: x &gt; 1]
</code></pre>
<p>Output:</p>
<pre><code>1    2
2    3
3    4
dtype: int64
</code></pre>
<p>or</p>
<pre><code># DataFrame
df = pd.DataFrame({'A': [1, 2, 3], 'B': [10, 20, 30]})
df[lambda x: (x['A'] != 1) &amp; (x['B'] != 30)]
</code></pre>
<p>Output:</p>
<pre><code>   A   B
1  2  20
</code></pre>
<h4> Artem Sokolov, Comment 132744640 Score: 1: </h4>In my opinion, this is the best answer, because a) it does not repeat the variable name twice, making it less error-prone, and b) it is chain-friendly, making it much more streamlined with other data frame operations.<br>------------------------------------------------------------------ <br><h3> Panagiotis Drakatos, Id: 75960482, Score: 1: </h3><p>Here are options using pandas built-in functions, similar to <code>isin</code>.</p>
<pre><code> df = pd.DataFrame({'cost': [250, 150, 100], 'revenue': [100, 250, 300]},index=['A', 'B', 'C'])

   cost  revenue
A   250      100
B   150      250
C   100      300
</code></pre>
<p>Compare DataFrames for equality elementwise</p>
<pre><code> df[df[&quot;cost&quot;].eq(250)]

   cost  revenue
A   250      100
</code></pre>
<p>Compare DataFrames for greater than inequality or equality elementwise.</p>
<pre><code>df[df[&quot;cost&quot;].ge(100)]

   cost  revenue
A   250      100
B   150      250
C   100      300
</code></pre>
<p>Compare DataFrames for strictly less than inequality elementwise.</p>
<pre><code>df[df[&quot;cost&quot;].lt(200)]

   cost  revenue
B   150      250
C   100      300
</code></pre>
------------------------------------------------------------------ <br><h3> L. Astola, Id: 71149332, Score: 0: </h3><p>Great answers. Only, when the <strong>size of the dataframe approaches million rows</strong>, many of the methods tend to take ages when using <code>df[df['col']==val]</code>. I wanted to have all possible values of &quot;another_column&quot; that correspond to specific values in &quot;some_column&quot; (in this case in a dictionary). This worked and fast.</p>
<pre><code>s=datetime.datetime.now()

my_dict={}

for i, my_key in enumerate(df['some_column'].values): 
    if i%100==0:
        print(i)  # to see the progress
    if my_key not in my_dict.keys():
        my_dict[my_key]={}
        my_dict[my_key]['values']=[df.iloc[i]['another_column']]
    else:
        my_dict[my_key]['values'].append(df.iloc[i]['another_column'])
        
e=datetime.datetime.now()

print('operation took '+str(e-s)+' seconds')```

</code></pre>
