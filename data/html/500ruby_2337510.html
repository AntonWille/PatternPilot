 <h2> Title: Ruby: Can I write multi-line string with no concatenation? </h2> <h4> Zombies, question_id: 2337510 </h4>Score: 500, Tags: {ruby,code-formatting} <br><p>Is there a way to make this look a little better?</p>

<pre><code>conn.exec 'select attr1, attr2, attr3, attr4, attr5, attr6, attr7 ' +
          'from table1, table2, table3, etc, etc, etc, etc, etc, ' +
          'where etc etc etc etc etc etc etc etc etc etc etc etc etc'
</code></pre>

<p>Like, is there a way to imply concatenation?</p>
------------------------------------------------------------------ <br><h3> Christopher Oezbek, Id: 60765131, Score: 68: </h3><p><em>This question made me go off a rabbit hole to understand how HEREDOC works. Excuse me if the answer became too long.</em></p>
<p>The <strong><a href="https://ruby-doc.org/core-2.5.0/doc/syntax/literals_rdoc.html#label-Here+Documents" rel="noreferrer">squiggly HEREDOC</a></strong> <code>&lt;&lt;~</code> is what you are looking for when you want to define a <strong>multi-line string with newlines and proper indentation</strong> (available since Ruby 2.3):</p>
<pre><code>conn.exec &lt;&lt;~EOS
            select attr1, attr2, attr3, attr4, attr5, attr6, attr7
            from table1, table2, table3, etc, etc, etc, etc, etc
            where etc etc etc etc etc etc etc etc etc etc etc etc etc
          EOS

# -&gt; &quot;select...\nfrom...\nwhere...&quot;
</code></pre>
<p>If proper indentation is not a concern, then <strong>single and double quotes</strong> can span multiple lines in Ruby:</p>
<pre><code>conn.exec &quot;select attr1, attr2, attr3, attr4, attr5, attr6, attr7 
           from table1, table2, table3, etc, etc, etc, etc, etc, 
           where etc etc etc etc etc etc etc etc etc etc etc etc etc&quot;    

# -&gt; &quot;select...\n           from...\n           where...&quot;
      
</code></pre>
<p>If single or double quotes are cumbersome because that would need lots of escaping, then the <strong>percent string literal notation</strong> <code>%</code> is the most flexible solution:</p>
<pre><code>conn.exec %(select attr1, attr2, attr3, attr4, attr5, attr6, attr7
            from table1, table2, table3, etc, etc, etc, etc, etc
            where (ProductLine = 'R' OR ProductLine = &quot;S&quot;) AND Country = &quot;...&quot;)
# -&gt; &quot;select...\n            from...\n            where...&quot;
</code></pre>
<p>If the aim is to avoid the newlines (which both the squiggly HEREDOC, quotes and the percent string literal will cause), then a <strong>line continuation</strong> can be used by putting a backslash <code>\</code> as the last non-whitespace character in a line. This will continue the line and will cause Ruby to concatenate the Strings back to back (watch out for those spaces inside the quoted string):</p>
<pre><code>conn.exec 'select attr1, attr2, attr3, attr4, attr5, attr6, attr7 ' \
          'from table1, table2, table3, etc, etc, etc, etc, etc, ' \
          'where etc etc etc etc etc etc etc etc etc etc etc etc etc'

# -&gt; &quot;select...from...where...&quot;
</code></pre>
<p>If you use Rails, then <strong><a href="https://docs.ruby-lang.org/en/2.0.0/syntax/literals_rdoc.html#label-Strings" rel="noreferrer"><code>String.squish</code></a></strong> will strip the string of leading and trailing space and collapse all consecutive whitespaces (newlines, tabs, and all) into a single space:</p>
<pre><code>conn.exec &quot;select attr1, attr2, attr3, attr4, attr5, attr6, attr7 
           from table1, table2, table3, etc, etc, etc, etc, etc, 
           where etc etc etc etc etc etc etc etc etc etc etc etc etc&quot;.squish

# -&gt; &quot;select...attr7 from...etc, where...&quot;
</code></pre>
<p>More details:</p>
<h3>Ruby HEREDOC Syntax</h3>
<p>The <strong>Here Document Notation for Strings</strong> is a way to designate long blocks of text inline in code. It is started by <code>&lt;&lt;</code> followed by a user-defined String (the End of String terminator). All following lines are concatenated until the End of String terminator is found at the <em>very beginning</em> of a line:</p>
<pre><code>puts &lt;&lt;HEREDOC 
Text Text Text Text
Bla Bla
HEREDOC
# -&gt; &quot;Text Text Text Text\nBlaBla&quot;
</code></pre>
<p>The End of String terminator can be chosen freely, but it is common to use something like &quot;EOS&quot; (End of String) or something that matches the domain of the String such as &quot;SQL&quot;.</p>
<p>HEREDOC supports <a href="https://docs.ruby-lang.org/en/2.0.0/syntax/literals_rdoc.html#label-Strings" rel="noreferrer">interpolation</a> by default or when the EOS terminator is double quoted:</p>
<pre><code>price = 10
print &lt;&lt;&quot;EOS&quot;  # comments can be put here
1.) The price is #{price}.
EOS
# -&gt; &quot;1.) The price is 10.&quot;
</code></pre>
<p>Interpolation can be disabled if the EOS terminator is single quoted:</p>
<pre><code>print &lt;&lt;'EOS' # Disabled interpolation
3.) The price is #{price}.
EOS
# -&gt; &quot;3.) The price is #{price}.&quot;
</code></pre>
<p>One important restriction of the <code>&lt;&lt;HEREDOC</code> is that the End of String terminator needs to be at the beginning of the line:</p>
<pre><code>  puts &lt;&lt;EOS 
    def foo
      print &quot;foo&quot;
    end
  EOS
EOS
#-&gt; &quot;....def foo\n......print &quot;foo&quot;\n....end\n..EOS&quot;
</code></pre>
<p>To get around this, the <code>&lt;&lt;-</code> syntax was created. It allows the EOS terminator to be indented to make the code look nicer. The lines between the <code>&lt;&lt;-</code> and EOS terminator are still used in their full extend including all indentation:</p>
<pre><code>def printExample
  puts &lt;&lt;-EOS # Use &lt;&lt;- to indent End of String terminator
    def foo
      print &quot;foo&quot;
    end
  EOS
end
# -&gt; &quot;....def foo\n......print &quot;foo&quot;\n....end&quot;
</code></pre>
<p>Since Ruby 2.3, we now have the squiggly HEREDOC <code>&lt;&lt;~</code> which removes leading whitespace:</p>
<pre><code>puts &lt;&lt;~EOS # Use the squiggly HEREDOC &lt;&lt;~ to remove leading whitespace (since Ruby 2.3!)
  def foo
    print &quot;foo&quot;
  end
EOS
# -&gt; &quot;def foo\n..print &quot;foo&quot;\nend&quot;
</code></pre>
<p>Empty lines and lines which only contains tabs and space are ignored by &lt;&lt;~</p>
<pre><code>puts &lt;&lt;~EOS.inspect 
  Hello

    World!
EOS
#-&gt; &quot;Hello\n..World!&quot;
</code></pre>
<p>If both tabs and spaces are used, tabs are considered as equal to 8 spaces.
If the least-indented line is in the middle of a tab, this tab is not removed.</p>
<pre><code>puts &lt;&lt;~EOS.inspect
&lt;tab&gt;One Tab
&lt;space&gt;&lt;space&gt;Two Spaces
EOS
# -&gt; &quot;\tOne Tab\nTwoSpaces&quot;
</code></pre>
<p>HEREDOC can do some crazy stuff such as executing commands using backticks:</p>
<pre><code>puts &lt;&lt;`EOC`            
echo #{price}
echo #{price * 2}
EOC
</code></pre>
<p>HEREDOC String definitions can be &quot;stacked&quot;, which means that the first EOS terminator (EOSFOO below) will end the first string and start the second (EOSBAR below):</p>
<pre><code>print &lt;&lt;EOSFOO, &lt;&lt;EOSBAR    # you can stack them
I said foo.
EOSFOO
I said bar.
EOSBAR
</code></pre>
<p>I don't think anybody would ever use it as such, but the <code>&lt;&lt;EOS</code> is really just a string literal and can be put whereever a string can normally be put:</p>
<pre><code>def func(a,b,c)
  puts a
  puts b
  puts c
end

func(&lt;&lt;THIS, 23, &lt;&lt;THAT) 
Here's a line
or two.
THIS
and here's another.
THAT
</code></pre>
<p>If you don't have Ruby 2.3, but Rails <code>&gt;=</code> 3.0 then you can use <code>String.strip_heredoc</code> which does the same as <code>&lt;&lt;~</code></p>
<pre><code># File activesupport/lib/active_support/core_ext/string/strip.rb, line 22
class String
  def strip_heredoc
    gsub(/^#{scan(/^[ \t]*(?=\S)/).min}/, &quot;&quot;.freeze)
  end
end

puts &lt;&lt;-USAGE.strip_heredoc # If no Ruby 2.3, but Rails &gt;= 3.0
  This command does such and such.

  Supported options are:
    -h         This message
    ...
USAGE
</code></pre>
<h3>Troubleshooting</h3>
<p>If you see errors when Ruby parses your file, then it is most likely that you either have extra leading or trailing spaces with a HEREDOC or extra trailing spaces with a squiggly HEREDOC. For example:</p>
<p>What you see:</p>
<pre><code>    database_yml = &lt;&lt;~EOS
      production:
        database: #{fetch(:user)}
        adapter: postgresql
        pool: 5
        timeout: 5000
    EOS  
</code></pre>
<p>What Ruby tells you:</p>
<pre><code>SyntaxError: .../sample.rb:xx: can't find string &quot;EOS&quot; anywhere before EOF
...sample.rb:xx: syntax error, unexpected end-of-input, expecting `end'
</code></pre>
<p>What is at fault:</p>
<p><a href="https://i.stack.imgur.com/Gmzwg.png" rel="noreferrer"><img src="https://i.stack.imgur.com/Gmzwg.png" alt="Spot the extra spaces after the terminating EOS" /></a></p>
<p>Spot the extra spaces after the terminating EOS.</p>
<h3>Percent String Literals</h3>
<p>See <a href="https://docs.ruby-lang.org/en/2.5.0/syntax/literals_rdoc.html#label-Percent+Strings" rel="noreferrer">RubyDoc</a> for how to use the percentage sign followed by a string in a parentheses pair such as a <code>%(...)</code>, <code>%[...]</code>, <code>%{...}</code>, etc. or a pair of any non-alphanumeric character such as <code>%+...+</code></p>
<h3>Last Words</h3>
<p>Last, to get the answer to the original question &quot;Is there a way to imply concatenation?&quot;
answered: Ruby always implies concatenation if two strings (single and double quoted) are found back to back:</p>
<pre><code>puts &quot;select...&quot; 'from table...' &quot;where...&quot;
# -&gt; &quot;select...from table...where...&quot;
</code></pre>
<p>The caveat is that this does not work across line-breaks, because Ruby is interpreting an end of statement and the consequitive line of just strings alone on a line doesn't do anything.</p>
<h4> Rael Gugelmin Cunha, Comment 133242833 Score: 1: </h4>This is the proper answer. Thanks for all the details! It clarified a lot of things with HEREDOC.<br><h4> berezovskyi, Comment 135317022 Score: 0: </h4>I think it will be obvious for many, but took me a while to understand that there is no difference between how <code>%{}</code>, <code>%()</code>, <code>%[]</code> strings are processed. You simply chose the terminators that are the least likely to be used in the string inside, removing (or almost eliminating) the need to do any escaping. For example, in SPARQL queries <code>{}</code> and <code>()</code> are common, and <code>[]</code> could be used for lists, it makes sense to use <code>%$$</code>. In SQL, <code>[]</code> and <code>()</code> are common, <code>%{}</code> could be a good pick (except for T-SQL, maybe). I also like to pick chars that one needs to escape in Bash, <code>\$</code> looks natural.<br>------------------------------------------------------------------ <br><h3> A. Wilson, Id: 6032910, Score: 700: </h3><p>There are pieces to this answer that helped me get what I needed (easy multi-line concatenation WITHOUT extra whitespace), but since none of the actual answers had it, I'm compiling them here:</p>

<pre><code>str = 'this is a multi-line string'\
  ' using implicit concatenation'\
  ' to prevent spare \n\'s'

=&gt; "this is a multi-line string using implicit concatenation to eliminate spare
\\n's"
</code></pre>

<p>As a bonus, here's a version using funny HEREDOC syntax (via <a href="http://graysoftinc.com/ruby-voodoo/working-with-multiline-strings" rel="noreferrer">this link</a>):</p>

<pre><code>p &lt;&lt;END_SQL.gsub(/\s+/, " ").strip
SELECT * FROM     users
         ORDER BY users.id DESC
END_SQL
# &gt;&gt; "SELECT * FROM users ORDER BY users.id DESC"
</code></pre>

<p>The latter would mostly be for situations that required more flexibility in the processing. I personally don't like it, it puts the processing in a weird place w.r.t. the string (i.e., in front of it, but using instance methods that usually come afterward), but it's there. Note that if you are indenting the last <code>END_SQL</code> identifier (which is common, since this is probably inside a function or module), you will need to use the hyphenated syntax (that is, <code>p &lt;&lt;-END_SQL</code> instead of <code>p &lt;&lt;END_SQL</code>). Otherwise, the indenting whitespace causes the identifier to be interpreted as a continuation of the string.</p>

<p>This doesn't save much typing, but it looks nicer than using + signs, to me.</p>

<p>Also (I say in an edit, several years later), if you're using Ruby 2.3+, the operator &lt;&lt;~ <a href="https://www.rubyguides.com/2018/11/ruby-heredoc/" rel="noreferrer">is also available</a>, which removes extra indentation from the final string. You should be able to remove the <code>.gsub</code> invocation, in that case (although it might depend on both the starting indentation and your final needs).</p>

<p>EDIT: Adding one more:</p>

<pre><code>p %{
SELECT * FROM     users
         ORDER BY users.id DESC
}.gsub(/\s+/, " ").strip
# &gt;&gt; "SELECT * FROM users ORDER BY users.id DESC"
</code></pre>
<h4> user483040, Comment 62126224 Score: 5: </h4>This is an old question BUT there either is an error in the answer or has been a change in syntax since then. <code>p &lt;&lt;END_SQL</code> should be <code>p &lt;&lt;-END_SQL</code> Otherwise this is The Answer. optionally you can strip leading whitespace with the squiggly HEREDOC operator, <code>&lt;&lt;~END_SQL</code><br><h4> A. Wilson, Comment 108773443 Score: 1: </h4>When I wrote this answer (nine years ago, sheesh!), Ruby was on 1.9, and &lt;&lt;~ (evidently) wasn&#39;t introduced until 2.3. Anyway, ancient history aside, I&#39;ll put it in, thanks for bringing it up.<br><h4> Josh, Comment 109326172 Score: 0: </h4><i>Thank you</i> for being one of the few answers which doesn&#39;t add extra newlines, which is what I was trying to avoid when I found this question.<br><h4> cegprakash, Comment 132384823 Score: 0: </h4>This solution causes me FrozenError: can&#39;t modify frozen String<br><h4> A. Wilson, Comment 132416005 Score: 0: </h4><code>.gsub</code> and <code>.strip</code> mutate their targets, and frozen strings are immutable; this probably means you&#39;re using the frozen_string_literal pragma in a Rails 2.3+ project (and doing this operation to a literal string). Using one of the other answers that relies on concatenation rather than mutation should work for you (removing extra whitespaces will still require un-freezing the strings, though).<br><h4> Qortex, Comment 108631350 Score: 0: </h4>Adding <code>&lt;&lt;~</code> to the answer would be nice, ended up researching that from there. Personnally, I use <code>&lt;&lt;~MSG.strip ... MSG</code> which also strips the last <code>\n</code>.<br><h4> A. Wilson, Comment 62137927 Score: 0: </h4>It&#39;s only an error if the ending identifier is indented (the hyphen tells the ruby interpreter to trim whitespace before making the ending identifier determination). I can put a note mentioning that, though. Also, the ~ is unnecessary, gsub \s+ and strip are already removing leading whitespace.<br>------------------------------------------------------------------ <br><h3> Kamil Lelonek, Id: 24774150, Score: 31: </h3><p>Sometimes is worth to remove new line characters <code>\n</code> like:</p>

<pre><code>conn.exec &lt;&lt;-eos.squish
 select attr1, attr2, attr3, attr4, attr5, attr6, attr7
 from table1, table2, table3, etc, etc, etc, etc, etc,
 where etc etc etc etc etc etc etc etc etc etc etc etc etc
eos
</code></pre>
<h4> a14m, Comment 64698172 Score: 5: </h4>this is rails based not ruby<br>------------------------------------------------------------------ <br><h3> Robbie Guilfoyle, Id: 18478045, Score: 227: </h3><p>In ruby 2.0 you can now just use <code>%</code></p>
<p>For example:</p>
<pre class="lang-sql prettyprint-override"><code>    SQL = %{
      SELECT user, name
      FROM users
      WHERE users.id = #{var}
      LIMIT #{var2}
    }
</code></pre>
<h4> James, Comment 48289114 Score: 50: </h4>A string created with this syntax will include both newlines and any indention added to subsequent lines.<br><h4> Andy Stewart, Comment 27922290 Score: 14: </h4>Works in Ruby 1.9.3 too.<br><h4> Jignesh Gohel, Comment 69331131 Score: 6: </h4>If using Rails invoking <code>squish</code> on the output should be helpful.<br><h4> anon, Comment 60378379 Score: 2: </h4>@Nasser A heredoc does interpolation as well.<br><h4> Nasser, Comment 50014788 Score: 0: </h4>This is even better than &lt;&lt;EOT ......EOT (here document)! it also does interpolation if needed.<br><h4> Mig, Comment 114143085 Score: 0: </h4>The thing to note is that many commenters are talking about stripping/compacting commas. If you do so, then do not interpolate variables in there. Because it will obviously compact white space in your variables. Bad idea to use interpolation anyway because of injection. Use your driver placeholder system instead which escapes the variables and possibly formats them for each type.<br><h4> luky, Comment 136102487 Score: 0: </h4>speak correclty. it is not % but %{}<br>------------------------------------------------------------------ <br><h3> Mark Byers, Id: 2337519, Score: 181: </h3><p>Yes, if you don't mind the extra newlines being inserted:</p>

<pre><code> conn.exec 'select attr1, attr2, attr3, attr4, attr5, attr6, attr7
            from table1, table2, table3, etc, etc, etc, etc, etc,
            where etc etc etc etc etc etc etc etc etc etc etc etc etc'
</code></pre>

<p>Alternatively you can use a <a href="http://www.ruby-doc.org/docs/ruby-doc-bundle/Manual/man-1.4/syntax.html#here_doc" rel="noreferrer">heredoc</a>:</p>

<pre><code>conn.exec &lt;&lt;-eos
   select attr1, attr2, attr3, attr4, attr5, attr6, attr7
   from table1, table2, table3, etc, etc, etc, etc, etc,
   where etc etc etc etc etc etc etc etc etc etc etc etc etc
eos
</code></pre>
<h4> BaroqueBobcat, Comment 2309022 Score: 93: </h4>You could also use <code>%Q(...)</code><br><h4> zero-divisor, Comment 41559345 Score: 8: </h4>You could also use <code>%(...)</code><br><h4> Mark Byers, Comment 2309221 Score: 3: </h4>@Zombies: Newlines are typically allowed in SQL statements and are just treated as ordinary whitespace.<br><h4> Robbie Guilfoyle, Comment 27161227 Score: 2: </h4>see my answer below for an example, you can just use % now.<br><h4> Dennis, Comment 44473071 Score: 1: </h4>Something important to keep in mind if you intentionally add trailing whitespace and use one of these solutions is that <b>your editor may automatically remove trailing space</b> when saving the file. While I normally prefer this behaviour, it has caused unexpected issues for me a few times. A solution is to write your multi-line string like how the OP did in the question.<br><h4> Josh, Comment 109325916 Score: 1: </h4>&quot;if you don&#39;t mind the extra newlines being inserted&quot; but the question asks for no newlines...<br>------------------------------------------------------------------ <br><h3> Hongli, Id: 2340488, Score: 50: </h3><p>There are multiple syntaxes for multi-line strings as you've already read. My favorite is Perl-style:</p>

<pre><code>conn.exec %q{select attr1, attr2, attr3, attr4, attr5, attr6, attr7
      from table1, table2, table3, etc, etc, etc, etc, etc,
      where etc etc etc etc etc etc etc etc etc etc etc etc etc}
</code></pre>

<p>The multi-line string starts with %q, followed by a {, [ or (, and then terminated by the corresponding reversed character. %q does not allow interpolation; %Q does so you can write things like this:</p>

<pre><code>conn.exec %Q{select attr1, attr2, attr3, attr4, attr5, attr6, attr7
      from #{table_names},
      where etc etc etc etc etc etc etc etc etc etc etc etc etc}
</code></pre>

<p>I actually have no idea how these kinds of multi-line strings are called so let's just call them Perl multilines.</p>

<p>Note however that whether you use Perl multilines or heredocs as Mark and Peter have suggested, you'll end up with potentially unnecessary whitespaces. Both in my examples and their examples, the "from" and "where" lines contain leading whitespaces because of their indentation in the code. If this whitespace is not desired then you must use concatenated strings as you are doing now.</p>
<h4> MatthewFord, Comment 7468047 Score: 4: </h4>from #{table_names} would not work in this example, as you used %q{}, it would work if you used %q[] or ()<br><h4> Duke, Comment 9564694 Score: 2: </h4>My favorite in this vein is just %{ super multiline string with interpolation support }<br><h4> Josh, Comment 109325936 Score: 0: </h4>strings produced from the <code>%q</code> family will include the newlines which is not equivilent to the original code.<br>------------------------------------------------------------------ <br><h3> juliangonzalez, Id: 43098101, Score: 25: </h3><p>You can also use double quotes</p>

<pre><code>x = """
this is 
a multiline
string
"""

2.3.3 :012 &gt; x
 =&gt; "\nthis is\na multiline\nstring\n"
</code></pre>

<p>If needed to remove line breaks "\n" use backslash "\" at the end of each line</p>
<h4> rakvium, Comment 87448994 Score: 6: </h4>You can achieve the same result with the singular double quotes. There is no such thing like triple double quotes in Ruby. It just interprets them as <code>&quot;&quot; + &quot;double quotes with some content&quot; + &quot;&quot;</code>.<br><h4> rakvium, Comment 93400844 Score: 1: </h4>Yes, it looks weird, and this is why there is no reason to add extra double quotes when you can just use the singular double quotes with the same result.<br><h4> rakvium, Comment 93880158 Score: 1: </h4>I mean that just <code>&quot;x&quot;</code> looks better and works faster than <code>&quot;&quot;&quot;x&quot;&quot;&quot;</code> (which is basically the same as <code>&quot;&quot;+&quot;x&quot;+&quot;&quot;</code>) or <code>&quot;&quot;&quot;&quot;&quot;x&quot;&quot;&quot;&quot;&quot;</code> (which is the same as <code>&quot;&quot; + &quot;&quot; + &quot;x&quot; + &quot;&quot; + &quot;&quot;</code>). It&#39;s Ruby, not Python, where you use <code>&quot;&quot;&quot;</code> instead of <code>&quot;</code> when you need a multi-line string.<br><h4> Josh, Comment 109325941 Score: 0: </h4>double quotes will include the newlines which is not equivalent to the original code.<br><h4> juliangonzalez, Comment 109359043 Score: 0: </h4>@Josh that&#39;s why I put a not at the end to use `\` if no new lines are needed. You didn&#39;t need to downvote.<br><h4> Josh, Comment 109359787 Score: 0: </h4>Apologies, I missed that while scouring this page for an answer which did what I needed.<br><h4> juliangonzalez, Comment 93406628 Score: 0: </h4>Yes, I meant the plus sign. The double quotes without it look just fine, its readable and and easier to spot instead of a single quote, which should be used on single line strings.<br><h4> juliangonzalez, Comment 93252316 Score: 0: </h4>Yeah, but ` &quot;&quot;+&quot;\n hello\n &quot;+&quot;&quot; Does look weird<br>------------------------------------------------------------------ <br><h3> Alex Cohen, Id: 41368206, Score: 17: </h3><p>Other options:</p>

<pre><code>#multi line string
multiline_string = &lt;&lt;EOM
This is a very long string
that contains interpolation
like #{4 + 5} \n\n
EOM

puts multiline_string

#another option for multiline string
message = &lt;&lt;-EOF
asdfasdfsador #{2+2} this month.
asdfadsfasdfadsfad.
EOF

puts message
</code></pre>
<h4> kingPuppy, Comment 84747236 Score: 1: </h4>Should change <code>&lt;&lt;EOM</code> to <code>&lt;&lt;-EOM</code>, no?<br><h4> Alex Cohen, Comment 89376169 Score: 0: </h4>Maybe, it seemed to work for my <code>&lt;&lt;-EOF</code> example. My guess is that either way works.<br><h4> Josh, Comment 109325954 Score: 0: </h4>heredoc will include the newlines which is not equivalent to the original code.<br>------------------------------------------------------------------ <br><h3> Mshka, Id: 46512037, Score: 16: </h3><p>Recently with the new features in Ruby 2.3 the new <code>squiggly HEREDOC</code> will let you write our multiline strings in a nice manner with a minimal change so using this combined with the <code>.squish</code> (if you are using rails) will let you write multiline in a nice way!
in case of just using ruby, you can do a <code>&lt;&lt;~SQL.split.join(" ")</code> which is <strong><em>almost</em></strong> the same</p>

<pre><code>[1] pry(main)&gt; &lt;&lt;~SQL.squish
[1] pry(main)*   select attr1, attr2, attr3, attr4, attr5, attr6, attr7
[1] pry(main)*   from table1, table2, table3, etc, etc, etc, etc, etc,
[1] pry(main)*   where etc etc etc etc etc etc etc etc etc etc etc etc etc
[1] pry(main)* SQL
=&gt; "select attr1, attr2, attr3, attr4, attr5, attr6, attr7 from table1, table2, table3, etc, etc, etc, etc, etc, where etc etc etc etc etc etc etc etc etc etc etc etc etc"
</code></pre>

<p>ref: <a href="https://infinum.co/the-capsized-eight/multiline-strings-ruby-2-3-0-the-squiggly-heredoc" rel="noreferrer">https://infinum.co/the-capsized-eight/multiline-strings-ruby-2-3-0-the-squiggly-heredoc</a></p>
<h4> Josh, Comment 109325960 Score: 1: </h4>squish is rails, not ruby<br>------------------------------------------------------------------ <br><h3> Peter, Id: 2337523, Score: 15: </h3><pre><code>conn.exec = &lt;&lt;eos
  select attr1, attr2, attr3, attr4, attr5, attr6, attr7
  from table1, table2, table3, etc, etc, etc, etc, etc,
  where etc etc etc etc etc etc etc etc etc etc etc etc etc
eos
</code></pre>
<h4> ives, Comment 58008399 Score: 3: </h4>using heredoc without the &#39;-&#39;, as in &#39;&lt;&lt;-eos&#39;, will include the additional leader spaces. see Mark Byers&#39; response.<br><h4> Josh, Comment 109325946 Score: 1: </h4>heredoc will include the newlines which is not equivalent to the original code.<br>------------------------------------------------------------------ <br><h3> Pwnrar, Id: 37841042, Score: 9: </h3><p>To avoid closing the parentheses for each line you can simply use double quotes with a backslash to escape the newline:</p>

<pre><code>"select attr1, attr2, attr3, attr4, attr5, attr6, attr7 \
from table1, table2, table3, etc, etc, etc, etc, etc, \
where etc etc etc etc etc etc etc etc etc etc etc etc etc"
</code></pre>
<h4> Josh, Comment 109325894 Score: 1: </h4>This is one of the few answers on this page which actually answers the question!<br>------------------------------------------------------------------ <br><h3> Dom Brezinski, Id: 2337538, Score: 6: </h3><pre><code>conn.exec 'select attr1, attr2, attr3, attr4, attr5, attr6, attr7 ' &lt;&lt;
        'from table1, table2, table3, etc, etc, etc, etc, etc, ' &lt;&lt;
        'where etc etc etc etc etc etc etc etc etc etc etc etc etc'
</code></pre>

<p>&lt;&lt; is the concatenation operator for strings</p>
<h4> Beni Cherniavsky-Paskin, Comment 60973212 Score: 3: </h4><code>+</code> is the regular concatenation operator, <code>&lt;&lt;</code> is the <i>in-place</i> append operator.  Using side effects on a literal happens to work here (the first string is modified twice and returned) but IMHO it&#39;s weird and makes me do a double-take, where <code>+</code> would be perfectly clear.  But maybe I&#39;m just new to Ruby...<br><h4> Raido, Comment 76874092 Score: 1: </h4>This won&#39;t work if <code>frozen_string_literal</code> is enabled<br>------------------------------------------------------------------ <br><h3> UncleGene, Id: 15373202, Score: 6: </h3><p>If you <em>do</em> mind extra spaces and newlines, you can use</p>

<pre><code>conn.exec %w{select attr1, attr2, attr3, attr4, attr5, attr6, attr7
  from table1, table2, table3, etc, etc, etc, etc, etc,
  where etc etc etc etc etc etc etc etc etc etc etc etc etc} * ' '
</code></pre>

<p>(use %W for interpolated strings)</p>
<h4> Beni Cherniavsky-Paskin, Comment 60972897 Score: 1: </h4>This will squish multiple adjacent spaces into one.  (Its squishing of newline+following indentation is a win here but in middle of line it might be surprising.)<br><h4> schmijos, Comment 54500423 Score: 0: </h4>I like this one very much because it allows much more combinations of usage.<br>------------------------------------------------------------------ <br><h3> Aidan Cully, Id: 2337564, Score: 5: </h3><pre><code>conn.exec [
  "select attr1, attr2, attr3, ...",
  "from table1, table2, table3, ...",
  "where ..."
].join(' ')
</code></pre>

<p>This suggestion has the advantage over here-documents and long strings that auto-indenters can indent each part of the string appropriately.  But it comes at an efficiency cost.</p>
<h4> Wayne Conrad, Comment 2314468 Score: 1: </h4>@Aidan, You can replace the commas with backslashes (a la C) and no join (or array) will be needed: The interpreter will concatenate the strings at (I think) parse time, making it pretty quick compared to most of the alternatives.  One advantage, though, of joining an array of strings is that some auto-indenters do nicer work than they do with, for example, here-doc strings or with \.<br><h4> A. Wilson, Comment 6993077 Score: 1: </h4>One note, the heredoc syntax &lt;&lt;- will allow appropriate indentation.<br>------------------------------------------------------------------ <br><h3> Sandip Mane, Id: 60096346, Score: 5: </h3><h3>Elegant Answer Today:</h3>

<pre><code>&lt;&lt;~TEXT
Hi #{user.name}, 

Thanks for raising the flag, we're always happy to help you.
Your issue will be resolved within 2 hours.
Please be patient!

Thanks again,
Team #{user.organization.name}
TEXT
</code></pre>

<p>Theres a difference in <code>&lt;&lt;-TEXT</code> and <code>&lt;&lt;~TEXT</code>, former retains the spacing inside block and latter doesn't.</p>

<p>There are other options as well.
Like concatenation etc. but this one makes more sense in general.</p>

<p>If I am wrong here, let me know how...</p>
<h4> Josh, Comment 109325985 Score: 0: </h4>heredoc will include the newlines which is not equivalent to the original code.<br>------------------------------------------------------------------ <br><h3> Josh, Id: 61808560, Score: 4: </h3><p>Like you, I was also looking for a solution which <strong>does not include newlines</strong>. (While they may be safe in SQL, they're not safe in my case and I have a large block of text to deal with)</p>

<p>This is arguably just as ugly, but you can backslash-escape newlines in a heredoc to omit them from the resulting string:</p>

<pre><code>conn.exec &lt;&lt;~END_OF_INPUT
    select attr1, attr2, attr3, attr4, attr5, attr6, attr7 \
    from table1, table2, table3, etc, etc, etc, etc, etc, \
    where etc etc etc etc etc etc etc etc etc etc etc etc etc
  END_OF_INPUT
</code></pre>

<p>Note that you cannot due this without interpolation (I.E. <code>&lt;&lt;~'END_OF_INPUT'</code>) so be careful. <code>#{expressions}</code> will be evaluated here, whereas they will not in your original code. <a href="https://stackoverflow.com/a/6032910/75801">A. Wilson's answer</a> may be better for that reason.</p>
