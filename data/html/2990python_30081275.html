 <h2> Title: Why is &quot;1000000000000000 in range(1000000000000001)&quot; so fast in Python 3? </h2> <h4> Rick, question_id: 30081275 </h4>Score: 2990, Tags: {python,performance,python-3.x,range,python-internals} <br><p>It is my understanding that the <code>range()</code> function, which is actually <a href="https://docs.python.org/3/library/stdtypes.html#typesseq-range" rel="noreferrer">an object type in Python 3</a>, generates its contents on the fly, similar to a generator.</p>
<p>This being the case, I would have expected the following line to take an inordinate amount of time because, in order to determine whether 1 quadrillion is in the range, a quadrillion values would have to be generated:</p>
<pre><code>1_000_000_000_000_000 in range(1_000_000_000_000_001)
</code></pre>
<p>Furthermore: it seems that no matter how many zeroes I add on, the calculation more or less takes the same amount of time (basically instantaneous).</p>
<p>I have also tried things like this, but the calculation is still almost instant:</p>
<pre><code># count by tens
1_000_000_000_000_000_000_000 in range(0,1_000_000_000_000_000_000_001,10)
</code></pre>
<p>If I try to implement my own range function, the result is not so nice!</p>
<pre><code>def my_crappy_range(N):
    i = 0
    while i &lt; N:
        yield i
        i += 1
    return
</code></pre>
<p>What is the <code>range()</code> object doing under the hood that makes it so fast?</p>
<hr />
<p><a href="https://stackoverflow.com/a/30081318/2437514">Martijn Pieters's answer</a> was chosen for its completeness, but also see <a href="https://stackoverflow.com/a/30081894/2437514">abarnert's first answer</a> for a good discussion of what it means for <code>range</code> to be a full-fledged <em>sequence</em> in Python 3, and some information/warning regarding potential inconsistency for <code>__contains__</code> function optimization across Python implementations. <a href="https://stackoverflow.com/a/30088140/2437514">abarnert's other answer</a> goes into some more detail and provides links for those interested in the history behind the optimization in Python 3 (and lack of optimization of <code>xrange</code> in Python 2). Answers <a href="https://stackoverflow.com/a/30081467/2437514">by poke</a> and <a href="https://stackoverflow.com/a/30081470/2437514">by wim</a> provide the relevant C source code and explanations for those who are interested.</p>
<h4> Ashwini Chaudhary, Id: 48276269 Score: 165: </h4>Note that this is the case only if the item we are checking is a <code>bool</code> or <code>long</code> type, with other object types it will go crazy. Try with: <code>100000000000000.0 in range(1000000000000001)</code><br><h4> Ashwini Chaudhary, Id: 48289355 Score: 40: </h4>@Superbest <code>xrange()</code> objects have no <code>__contains__</code> method, so the item check has to loop through all the items. Plus there are few other changes in <code>range()</code>, like it supports slicing(which again returns a <code>range</code> object) and now also has <code>count</code> and <code>index</code> methods to make it compatible with <a href="https://docs.python.org/2/library/collections.html#collections-abstract-base-classes" rel="nofollow noreferrer"><code>collections.Sequence</code></a> ABC.<br><h4> abarnert, Id: 48277619 Score: 16: </h4>One last thing: Does Python 3 actually <i>guarantee</i> this behavior? I know every version of CPython at least 3.1+ and PyPy3 from the first beta on provided it, but I think it would be perfectly valid if, say, IronPython 3.4 came out tomorrow and had an O(N) <code>__contains__</code> method.<br><h4> Superbest, Id: 48286601 Score: 8: </h4>@AshwiniChaudhary isn&#39;t <a href="http://stackoverflow.com/a/95100">Python2 <code>xrange</code> the same as Python3 <code>range</code></a>?<br><h4> jfs, Id: 84894856 Score: 2: </h4>Here&#39;s <a href="https://github.com/zed/lrange/blob/c30c91831515918661ad48516b1b75ff53f81ecb/lrange.py#L167-L182" rel="nofollow noreferrer">Python 3 <code>range.__contains__</code> method implemented in pure Python</a><br><h4> Rick, Id: 48286817 Score: 1: </h4>@Superbest This might be part of what abarnert is getting at above? That the implementation of <code>range</code> (and presumably <code>xrange</code>) has never been specced anywhere, so the specific details - including how <code>__contains__</code>, <code>__item__</code>, etc, are calculated, is up to the different language implementors? So it&#39;s possible <code>xrange</code> was implemented differently in the past. I&#39;m just guessing here.<br><h4> abarnert, Id: 48288650 Score: 1: </h4>@RickTeachey: Pretty much. That still raises the <i>practical</i> question of why the 3.0 <code>range.__contains__</code> optimization wasn&#39;t backported to 2.6 <code>xrange.__contains__</code> (the 2.x C API had <code>sq_contains</code> in the <code>tp_as_sequence</code> struct, etc., so there&#39;s no reason it couldn&#39;t have been…), but for that, you&#39;d probably have to track down the hg change where the optimization was added to the py3k branch, and see if there&#39;s a corresponding bug and/or thread…<br><h4> abarnert, Id: 48277784 Score: 0: </h4>@RickTeachey: Actually, I&#39;m pretty sure I already know the answer; when I first started telling people they can just use <code>2 in r</code> in Python 3 (but not Python 2), someone challenged me to find that in the docs, and it&#39;s not there, and when I asked (on python-ideas or the bug tracker? I forget…) whether it should be guaranteed, nobody seemed to have much interest in answering one way or the other until there was another Python 3 implementor to talk to.<br><h4> Deepak Verma, Id: 85341336 Score: 0: </h4>bottom line , range in python supports membership checking out of the box with generating elements and infact it is faster than the membership checking in list. membership checking in range is done in constant time.<br><h4> Walter Tross, Id: 109270202 Score: 0: </h4>so in the end the point is that the <code>in</code> keyword has (at least) two different meanings in Python<br><h4> Rick, Id: 109284635 Score: 0: </h4>@WalterTross that&#39;s certainly one way to look at it! <code>in</code> can be a signal for starting iteration, or it can be a signal for testing membership.<br><h4> Abhishek Choudhary, Id: 126004973 Score: 0: </h4><code>1_000_000_000_000_000 in list(range(1_000_000_000_000_001))</code> causes memory error, obviously.<br><h4> noɥʇʎԀʎzɐɹƆ, Id: 50938206 Score: 0: </h4>@abarnert It wasn&#39;t backported because python 2 is in a life-support mode, no updates other than bugfixes. They considered giving it all the performance goodies, but they said they wouldn&#39;t in a PEP (don&#39;t remember which). That prompted me to migrate to python 3.<br>------------------------------------------------------------------ <br><h3> abarnert, Id: 30088140, Score: 134: </h3><p>If you're wondering <em>why</em> this optimization was added to <code>range.__contains__</code>, and why it <em>wasn't</em> added to <code>xrange.__contains__</code> in 2.7:</p>
<p>First, as Ashwini Chaudhary discovered, <a href="http://bugs.python.org/issue1766304" rel="noreferrer">issue 1766304</a> was opened explicitly to optimize <code>[x]range.__contains__</code>. A patch for this was <a href="https://hg.python.org/cpython/rev/d599a3f2e72d/" rel="noreferrer">accepted and checked in for 3.2</a>, but not backported to 2.7 because &quot;<code>xrange</code> has behaved like this for such a long time that I don't see what it buys us to commit the patch this late.&quot; (2.7 was nearly out at that point.)</p>
<p>Meanwhile:</p>
<p>Originally, <code>xrange</code> was a not-quite-sequence object. As <a href="https://docs.python.org/3.1/library/stdtypes.html#range-type" rel="noreferrer">the 3.1 docs</a> say:</p>
<blockquote>
<p>Range objects have very little behavior: they only support indexing, iteration, and the <code>len</code> function.</p>
</blockquote>
<p>This wasn't quite true; an <code>xrange</code> object actually supported a few other things that come automatically with indexing and <code>len</code>,<sup>*</sup> including <code>__contains__</code> (via linear search). But nobody thought it was worth making them full sequences at the time.</p>
<p>Then, as part of implementing the <a href="https://www.python.org/dev/peps/pep-3119/" rel="noreferrer">Abstract Base Classes</a> PEP, it was important to figure out which builtin types should be marked as implementing which ABCs, and <code>xrange</code>/<code>range</code> claimed to implement <code>collections.Sequence</code>, even though it still only handled the same &quot;very little behavior&quot;. Nobody noticed that problem until <a href="http://bugs.python.org/issue9213" rel="noreferrer">issue 9213</a>. The patch for that issue not only added <code>index</code> and <code>count</code> to 3.2's <code>range</code>, it also re-worked the optimized <code>__contains__</code> (which shares the same math with <code>index</code>, and is directly used by <code>count</code>).<sup>**</sup> <a href="https://github.com/python/cpython/commit/8ee11f7e599b2c5b4de39047bf11bde2246e968f" rel="noreferrer">This change</a> went in for 3.2 as well, and was not backported to 2.x, because &quot;it's a bugfix that adds new methods&quot;. (At this point, 2.7 was already past rc status.)</p>
<p>So, there were two chances to get this optimization backported to 2.7, but they were both rejected.</p>
<hr />
<p><sub>* In fact, you even get iteration for free with indexing alone, but <a href="https://docs.python.org/2/whatsnew/2.3.html#optimizations" rel="noreferrer">in 2.3</a> <code>xrange</code> objects got a custom iterator.</sub></p>
<p><sub>** The first version actually reimplemented it, and got the details wrong—e.g., it would give you <code>MyIntSubclass(2) in range(5) == False</code>. But Daniel Stutzbach's updated version of the patch restored most of the previous code, including the fallback to the generic, slow <code>_PySequence_IterSearch</code> that pre-3.2 <code>range.__contains__</code> was implicitly using when the optimization doesn't apply.</sub></p>
<h4> wim, Comment 48294204 Score: 14: </h4>I have a sinister suspicion that some core python devs are partial to &quot;tough love&quot; for python 2.x because they want to encourage people to switch to the far-superior python3  :)<br><h4> Rob Grant, Comment 48439489 Score: 9: </h4>Also I bet it&#39;s a huge burden to have to add new features to old versions. Imagine if you went to Oracle and said, &quot;Look, I&#39;m on Java 1.4 and I deserve lambda expressions! Backport them for nothing.&quot;<br><h4> Ashwini Chaudhary, Comment 48290185 Score: 4: </h4>From the comments here: <a href="http://bugs.python.org/issue1766304" rel="nofollow noreferrer">improve <code>xrange.__contains__</code></a>, it looks like they didn&#39;t backport it to Python 2 just to leave an element of surprise for users and it was too late o_O. The <code>count</code> and <code>index</code> <a href="https://hg.python.org/cpython/file/e2dec9c0d13c/Objects/rangeobject.c" rel="nofollow noreferrer">patch</a> was added later on. File at that time: <a href="https://hg.python.org/cpython/file/d599a3f2e72d/Objects/rangeobject.c" rel="nofollow noreferrer">hg.python.org/cpython/file/d599a3f2e72d/Objects/rangeobject.&zwnj;&#8203;c</a><br><h4> abarnert, Comment 48646526 Score: 3: </h4>@RickTeachey: 2.7 was between 3.1 and 3.2, not around 3.3. And that means 2.7 was in rc when the last changes to 3.2 went in, which makes the bug comments easier to understand. Anyway, I think they made a few mistakes in retrospect (especially assuming people would migrate via <code>2to3</code> instead of via dual-version code with the help of libraries like <code>six</code>, which is why we got things like <code>dict.viewkeys</code> that nobody&#39;s ever going to use), and there were a few changes that just came too late in 3.2, but for the most part 2.7 was a pretty impressive &quot;last 2.x ever&quot; release.<br><h4> Rob Grant, Comment 48490283 Score: 2: </h4>@RickTeachey yeah it&#39;s just an example. If I said 1.7 it would still apply. It&#39;s a quantitative difference not qualitative. Basically the (unpaid) devs can&#39;t forever make cool new stuff in 3.x and backport it to 2.x for those who don&#39;t want to upgrade. It&#39;s a huge and ridiculous burden. Do you think there&#39;s still something wrong with my reasoning?<br><h4> Rick, Comment 48488857 Score: 1: </h4>@RobertGrant Well the problem with that explanation is, 2.7 isn&#39;t old. It was released around the same time as 3.3, I believe.<br><h4> abarnert, Comment 48295121 Score: 1: </h4>@wim: A couple of them, definitely, but I don&#39;t think that&#39;s the case with Benjamin Peterson. He seems more in the camp of &quot;people still on 2.7 are doing so because they want to make sure we don&#39;t fix what ain&#39;t broke, so change as little as possible&quot;. But the most common (or at least vocal) attitude at the moment seems to be &quot;making it easy to port from 2.x to 3.x is priority #1, #2, and #3&quot;, possibly because multiple people paid to work on Python are also currently paid to work on Fedora and Ubuntu porting to 3.5.<br><h4> Rick, Comment 48495545 Score: 1: </h4>@RobertGrant no not at all, your reasoning is sound, and i&#39;m not strenuously differing. i&#39;m just saying it doesn&#39;t <i>fully</i> explain why there was no <code>xrange</code> optimization done for 2.7 (i understand that&#39;s not what you were saying). 2.7 was new, not an old version - people were excited about all the new stuff 2.7 would bring as with any other new release. and there was definitely the opportunity to do it during development. it just didn&#39;t make the cut.<br>------------------------------------------------------------------ <br><h3> Martijn Pieters, Id: 30081318, Score: 3062: </h3><p>The Python 3 <code>range()</code> object doesn't produce numbers immediately; it is a smart <a href="https://docs.python.org/3/library/collections.abc.html#collections.abc.Sequence" rel="noreferrer">sequence object</a> that produces numbers <em>on demand</em>. All it contains is your start, stop and step values, then as you iterate over the object the next integer is calculated each iteration.</p>
<p>The object also implements the <a href="https://docs.python.org/3/reference/datamodel.html#object.__contains__" rel="noreferrer"><code>object.__contains__</code> hook</a>, and <em>calculates</em> if your number is part of its range. Calculating is a (near) constant time operation <sup>*</sup>. There is never a need to scan through all possible integers in the range.</p>
<p>From the <a href="https://docs.python.org/3/library/stdtypes.html#range" rel="noreferrer"><code>range()</code> object documentation</a>:</p>
<blockquote>
<p>The advantage of the <code>range</code> type over a regular <code>list</code> or <code>tuple</code> is that a range object will always take the same (small) amount of memory, no matter the size of the range it represents (as it only stores the <code>start</code>, <code>stop</code> and <code>step</code> values, calculating individual items and subranges as needed).</p>
</blockquote>
<p>So at a minimum, your <code>range()</code> object would do:</p>
<pre><code>class my_range:
    def __init__(self, start, stop=None, step=1, /):
        if stop is None:
            start, stop = 0, start
        self.start, self.stop, self.step = start, stop, step
        if step &lt; 0:
            lo, hi, step = stop, start, -step
        else:
            lo, hi = start, stop
        self.length = 0 if lo &gt; hi else ((hi - lo - 1) // step) + 1

    def __iter__(self):
        current = self.start
        if self.step &lt; 0:
            while current &gt; self.stop:
                yield current
                current += self.step
        else:
            while current &lt; self.stop:
                yield current
                current += self.step

    def __len__(self):
        return self.length

    def __getitem__(self, i):
        if i &lt; 0:
            i += self.length
        if 0 &lt;= i &lt; self.length:
            return self.start + i * self.step
        raise IndexError('my_range object index out of range')

    def __contains__(self, num):
        if self.step &lt; 0:
            if not (self.stop &lt; num &lt;= self.start):
                return False
        else:
            if not (self.start &lt;= num &lt; self.stop):
                return False
        return (num - self.start) % self.step == 0
</code></pre>
<p>This is still missing several things that a real <code>range()</code> supports (such as the <code>.index()</code> or <code>.count()</code> methods, hashing, equality testing, or slicing), but should give you an idea.</p>
<p>I also simplified the <code>__contains__</code> implementation to only focus on integer tests; if you give a real <code>range()</code> object a non-integer value (including subclasses of <code>int</code>), a slow scan is initiated to see if there is a match, just as if you use a containment test against a list of all the contained values. This was done to continue to support other numeric types that just happen to support equality testing with integers but are not expected to support integer arithmetic as well. See the original <a href="http://bugs.python.org/issue1766304" rel="noreferrer">Python issue</a> that implemented the containment test.</p>
<hr />
<p>* <em>Near</em> constant time because Python integers are unbounded and so math operations also grow in time as N grows, making this a O(log N) operation. Since it’s all executed in optimised C code and Python stores integer values in 30-bit chunks, you’d run out of memory before you saw any performance impact due to the size of the integers involved here.</p>
<h4> Lucretiel, Comment 48287970 Score: 190: </h4>Fun fact: because you have a working implementation of <code>__getitem__</code> and <code>__len__</code>, the <code>__iter__</code> implementation is actually unnecessary.<br><h4> abarnert, Comment 48289871 Score: 9: </h4>@Lucretiel: <a href="https://docs.python.org/2/whatsnew/2.3.html#optimizations" rel="nofollow noreferrer">In Python 2.3</a>, a special <code>xrangeiterator</code> was added specifically because that wasn&#39;t fast enough. And then somewhere in 3.x (I&#39;m not sure if it was 3.0 or 3.2) it was tossed and they use the same <code>listiterator</code> type that <code>list</code> uses.<br><h4> Martijn Pieters, Comment 100570391 Score: 6: </h4>@KarlKnechtel you can’t predict how other types behave, full stop. There is no guarantee that range was passed an actual numeric type. It is not enough to just convert the argument to <code>int</code> because why bother with a custom type then? It is up to the developer to make the call on whether or not to use <code>int(custom_type) in range(....)</code>.<br><h4> abarnert, Comment 48646902 Score: 3: </h4>@CodyPiersall: Actually, here&#39;s a quote from Guido the <code>argclinic</code> discussion, when Nick Coghlan came up with a way to allow defining <code>range</code> unambiguously: &quot;Please don&#39;t make it easier for people to copy my worst design decision.&quot; So, I&#39;m pretty sure he agrees that <code>range</code> is confusing as written.<br><h4> Gloweye, Comment 103196781 Score: 1: </h4>Even if <code>__getitem__</code> + <code>__len__</code> allows for iteration, a good <code>__iter__</code> implementation can be faster or otherwise straight up <b>better</b> at it. I consider getitem iteration to be a fallback at best.<br><h4> Martijn Pieters, Comment 103200656 Score: 1: </h4>@Gloweye: <code>__iter__</code> returns an iterator object, which has to provide individual elements when calling the <code>__next__</code> method. For sequences, the best way to do that is to use <code>__getitem__</code> with an incremented index until you reach the length. The only reason the <code>listiterator</code> is better here is that it can access the list object array directly and so has a little less indirection. For pure-python code, yes, a generator function for <code>__iter__</code> can be more efficient as it avoids creating a new stack frame for each <code>__next__</code> call, a relatively expensive op.<br><h4> Martijn Pieters, Comment 132004266 Score: 1: </h4>@FaCoffee: see <a href="https://stackoverflow.com/q/24735311">What does the slash mean in help() output?</a><br><h4> Cody Piersall, Comment 48364221 Score: 1: </h4>I would define the constructor as <code>def __init__(self, *start_stop_step)</code> and parse it out from there; the way the arguments are labelled now are now are kind of confusing.  Nevertheless, +1; you still definitely explained the behavior.<br><h4> abarnert, Comment 48646862 Score: 1: </h4>@CodyPiersall: Unfortunately, that&#39;s the signature of the real class&#39;s initializer. <code>range</code> is older than <code>*args</code> (much less the <code>argclinic</code> API that lets C-API functions have complete Python signatures). A few other old functions (and a few newer functions, like <code>xrange</code>, <code>slice</code>, and <code>itertools.islice</code>, for consistency) work the same way, but for the most part, Guido and the rest of the core devs seem to agree with you. The 2.0+ docs even describe <code>range</code> and friends as if they were C++-style overloads rather than show the actual confusing signature.<br><h4> Karl Knechtel, Comment 100569940 Score: 0: </h4>What on earth sort of numeric type actually demands this slow-scan treatment? I would expect the following logic to work: <code>try</code> to determine <code>int(num)</code>; if an exception is raised return False; if the resulting integer doesn&#39;t compare equal to <code>num</code> return False; otherwise proceed to check whether that integer is in the <code>range</code>. Do you know of a non-contrived counterexample?<br><h4> FaCoffee, Comment 132003442 Score: 0: </h4>What does that <code>&#47;</code> symbol represent in the <code>__init__</code> method?<br><h4> Mike Williamson, Comment 135440760 Score: 0: </h4>I think it also helps to think of a <code>range</code> as a set. I took a Scala course that had us create sets by creating a data class with methods. Eg, the &quot;set&quot; of real numbers is infinite, but all you need to know is if something is in it. In this case, is <code>num % 2 == 0</code>.  The range does something similar with the <code>__contains__</code> method: it just tests to see if the number is in there.<br><h4> Martijn Pieters, Comment 135512645 Score: 0: </h4>@MikeWilliamson: I&#39;m not sure how helpful it is to do that as sets are <i>unordered</i>, while a range is definitely ordered; <code>range(1, 10)</code> and <code>range(9, 0, -1) contain the same values but their order is very different. Containment testing is not limited to sets here, you can apply that to [any *container*](https:&#47;&#47;docs.python.org&#47;3&#47;library&#47;collections.a&zwnj;&#8203;bc.html#collections.&zwnj;&#8203;abc.Container). Because a range is a sequence, you can also use _indexing_, where </code>range(9, 0, -1)[3]` gives you <code>6</code>.<br><h4> PixelMaster, Comment 130222556 Score: 0: </h4>so therefore, using &quot;list(range(x,y))&quot; would result in the performance hit OP was expecting, correct?<br><h4> Martijn Pieters, Comment 130241135 Score: 0: </h4>@PixelMaster: <code>list(range(...))</code> would create a list with all the integers in the range and if the range is large, you&#39;d indeed see performance issues as that would require a lot of memory. The performance hit the OP was expecting would only apply if you then used a containment test on the resulting list.<br>------------------------------------------------------------------ <br><h3> abarnert, Id: 30081894, Score: 1197: </h3><p>The fundamental misunderstanding here is in thinking that <code>range</code> is a generator. It's not. In fact, it's not any kind of iterator.</p>
<p>You can tell this pretty easily:</p>
<pre><code>&gt;&gt;&gt; a = range(5)
&gt;&gt;&gt; print(list(a))
[0, 1, 2, 3, 4]
&gt;&gt;&gt; print(list(a))
[0, 1, 2, 3, 4]
</code></pre>
<p>If it were a generator, iterating it once would exhaust it:</p>
<pre><code>&gt;&gt;&gt; b = my_crappy_range(5)
&gt;&gt;&gt; print(list(b))
[0, 1, 2, 3, 4]
&gt;&gt;&gt; print(list(b))
[]
</code></pre>
<p>What <code>range</code> actually is, is a sequence, just like a list. You can even test this:</p>
<pre><code>&gt;&gt;&gt; import collections.abc
&gt;&gt;&gt; isinstance(a, collections.abc.Sequence)
True
</code></pre>
<p>This means it has to follow all the rules of being a sequence:</p>
<pre><code>&gt;&gt;&gt; a[3]         # indexable
3
&gt;&gt;&gt; len(a)       # sized
5
&gt;&gt;&gt; 3 in a       # membership
True
&gt;&gt;&gt; reversed(a)  # reversible
&lt;range_iterator at 0x101cd2360&gt;
&gt;&gt;&gt; a.index(3)   # implements 'index'
3
&gt;&gt;&gt; a.count(3)   # implements 'count'
1
</code></pre>
<hr />
<p>The difference between a <code>range</code> and a <code>list</code> is that a <code>range</code> is a <em>lazy</em> or <em>dynamic</em> sequence; it doesn't remember all of its values, it just remembers its <code>start</code>, <code>stop</code>, and <code>step</code>, and creates the values on demand on <code>__getitem__</code>.</p>
<p>(As a side note, if you <code>print(iter(a))</code>, you'll notice that <code>range</code> uses the same <code>listiterator</code> type as <code>list</code>. How does that work? A <code>listiterator</code> doesn't use anything special about <code>list</code> except for the fact that it provides a C implementation of <code>__getitem__</code>, so it works fine for <code>range</code> too.)</p>
<hr />
<p>Now, there's nothing that says that <code>Sequence.__contains__</code> has to be constant time—in fact, for obvious examples of sequences like <code>list</code>, it isn't. But there's nothing that says it <em>can't</em> be. And it's easier to implement <code>range.__contains__</code> to just check it mathematically (<code>(val - start) % step</code>, but with some extra complexity to deal with negative steps) than to actually generate and test all the values, so why <em>shouldn't</em> it do it the better way?</p>
<p>But there doesn't seem to be anything in the language that <em>guarantees</em> this will happen. As Ashwini Chaudhari points out, if you give it a non-integral value, instead of converting to integer and doing the mathematical test, it will fall back to iterating all the values and comparing them one by one. And just because CPython 3.2+ and PyPy 3.x versions happen to contain this optimization, and it's an obvious good idea and easy to do, there's no reason that IronPython or NewKickAssPython 3.x couldn't leave it out. (And in fact, CPython 3.0-3.1 <em>didn't</em> include it.)</p>
<hr />
<p>If <code>range</code> actually were a generator, like <code>my_crappy_range</code>, then it wouldn't make sense to test <code>__contains__</code> this way, or at least the way it makes sense wouldn't be obvious. If you'd already iterated the first 3 values, is <code>1</code> still <code>in</code> the generator? Should testing for <code>1</code> cause it to iterate and consume all the values up to <code>1</code> (or up to the first value <code>&gt;= 1</code>)?</p>
<h4> Rick, Comment 48277088 Score: 29: </h4>This is a pretty important thing to get straight. I suppose the differences between Python 2 and 3 may have lead to my confusion on this point. In any case, I should have realized <a href="https://docs.python.org/3/library/stdtypes.html#typesseq" rel="nofollow noreferrer">since <code>range</code> is listed (along with <code>list</code> and <code>tuple</code>) as a sequence type</a>.<br><h4> ShadowRanger, Comment 67445969 Score: 10: </h4>@ThomasAhle: Because <code>range</code> isn&#39;t checking types when it&#39;s not an integer, since it&#39;s always possible a type has a <code>__eq__</code> that is compatible with <code>int</code>. Sure, <code>str</code> obviously won&#39;t work, but they didn&#39;t want to slow things down by explicitly checking all the types that <i>can&#39;t</i> be in there (and after all, a <code>str</code> subclass could override <code>__eq__</code> and be contained in the <code>range</code>).<br><h4> abarnert, Comment 48277532 Score: 8: </h4>@RickTeachey: Actually, in 2.6+ (I think; maybe 2.5+), <code>xrange</code> is a sequence too. See <a href="https://docs.python.org/2/library/stdtypes.html#sequence-types-str-unicode-list-tuple-bytearray-buffer-xrange" rel="nofollow noreferrer">2.7 docs</a>. In fact, it was always an almost-sequence.<br><h4> abarnert, Comment 48289938 Score: 7: </h4>@RickTeachey: Actually, I was wrong; in 2.6-2.7 (and 3.0-3.1), it <i>claims</i> to be a sequence, but it&#39;s still just an almost-sequence. See my other answer.<br><h4> Smit Johnth, Comment 63254890 Score: 4: </h4>It&#39;s not an iterator, it&#39;s a sequence (Iterable in terms of Java, IEnumerable of C#) - something with an <code>.__iter__()</code> method that will return an iterator. It in its turn can be used only once.<br><h4> Thomas Ahle, Comment 65748139 Score: 1: </h4>seems strange that <code>&#39;s&#39; in range(10**10)</code> isn&#39;t optimized to immediately return False.<br><h4> Sven Marnach, Comment 94410212 Score: 1: </h4>&quot;And it&#39;s easier to implement <code>range.__contains__</code> to just check it mathematically […] than to actually generate and test all the values&quot; – I dispute this, since you could simply <i>omit</i> the implementation of <code>__contains__</code> to get the latter behaviour, and that&#39;s certainly easier than any implementation you need to explicitly write. :)<br><h4> jez, Comment 93640845 Score: 0: </h4>For simplicity (as well as python 2 compatibility since some of these points generalize to python 2, even if the question itself doesn&#39;t) maybe cite <code>collections.Sequence</code> instead of <code>collections.abc.Sequence</code> ?<br>------------------------------------------------------------------ <br><h3> wim, Id: 30081470, Score: 508: </h3><p>Use the <a href="https://github.com/python/cpython/blob/cff677abe1823900e954592035a170eb67840971/Objects/rangeobject.c#L364-L413" rel="noreferrer">source</a>, Luke!</p>
<p>In CPython, <code>range(...).__contains__</code> (a method wrapper) will eventually delegate to a simple calculation which checks if the value can possibly be in the range.  The reason for the speed here is we're using <strong>mathematical reasoning about the bounds, rather than a direct iteration of the range object</strong>.  To explain the logic used:</p>
<ol>
<li>Check that the number is between <code>start</code> and <code>stop</code>, and</li>
<li>Check that the stride value doesn't &quot;step over&quot; our number.</li>
</ol>
<p>For example, <code>994</code> is in <code>range(4, 1000, 2)</code> because:</p>
<ol>
<li><code>4 &lt;= 994 &lt; 1000</code>, and</li>
<li><code>(994 - 4) % 2 == 0</code>.</li>
</ol>
<p>The full C code is included below, which is a bit more verbose because of memory management and reference counting details, but the basic idea is there:</p>
<pre class="lang-c prettyprint-override"><code>static int
range_contains_long(rangeobject *r, PyObject *ob)
{
    int cmp1, cmp2, cmp3;
    PyObject *tmp1 = NULL;
    PyObject *tmp2 = NULL;
    PyObject *zero = NULL;
    int result = -1;

    zero = PyLong_FromLong(0);
    if (zero == NULL) /* MemoryError in int(0) */
        goto end;

    /* Check if the value can possibly be in the range. */

    cmp1 = PyObject_RichCompareBool(r-&gt;step, zero, Py_GT);
    if (cmp1 == -1)
        goto end;
    if (cmp1 == 1) { /* positive steps: start &lt;= ob &lt; stop */
        cmp2 = PyObject_RichCompareBool(r-&gt;start, ob, Py_LE);
        cmp3 = PyObject_RichCompareBool(ob, r-&gt;stop, Py_LT);
    }
    else { /* negative steps: stop &lt; ob &lt;= start */
        cmp2 = PyObject_RichCompareBool(ob, r-&gt;start, Py_LE);
        cmp3 = PyObject_RichCompareBool(r-&gt;stop, ob, Py_LT);
    }

    if (cmp2 == -1 || cmp3 == -1) /* TypeError */
        goto end;
    if (cmp2 == 0 || cmp3 == 0) { /* ob outside of range */
        result = 0;
        goto end;
    }

    /* Check that the stride does not invalidate ob's membership. */
    tmp1 = PyNumber_Subtract(ob, r-&gt;start);
    if (tmp1 == NULL)
        goto end;
    tmp2 = PyNumber_Remainder(tmp1, r-&gt;step);
    if (tmp2 == NULL)
        goto end;
    /* result = ((int(ob) - start) % step) == 0 */
    result = PyObject_RichCompareBool(tmp2, zero, Py_EQ);
  end:
    Py_XDECREF(tmp1);
    Py_XDECREF(tmp2);
    Py_XDECREF(zero);
    return result;
}

static int
range_contains(rangeobject *r, PyObject *ob)
{
    if (PyLong_CheckExact(ob) || PyBool_Check(ob))
        return range_contains_long(r, ob);

    return (int)_PySequence_IterSearch((PyObject*)r, ob,
                                       PY_ITERSEARCH_CONTAINS);
}
</code></pre>
<p>The &quot;meat&quot; of the idea is mentioned in the comment lines:</p>
<pre><code>/* positive steps: start &lt;= ob &lt; stop */
/* negative steps: stop &lt; ob &lt;= start */
/* result = ((int(ob) - start) % step) == 0 */ 
</code></pre>
<p>As a final note - look at the <code>range_contains</code> function at the bottom of the code snippet.  If the exact type check fails then we don't use the clever algorithm described, instead falling back to a dumb iteration search of the range using <code>_PySequence_IterSearch</code>!  You can check this behaviour in the interpreter (I'm using v3.5.0 here):</p>
<pre><code>&gt;&gt;&gt; x, r = 1000000000000000, range(1000000000000001)
&gt;&gt;&gt; class MyInt(int):
...     pass
... 
&gt;&gt;&gt; x_ = MyInt(x)
&gt;&gt;&gt; x in r  # calculates immediately :) 
True
&gt;&gt;&gt; x_ in r  # iterates for ages.. :( 
^\Quit (core dumped)
</code></pre>
<h4> Ben L, Comment 135281260 Score: 1: </h4>This one should be the answer.<br>------------------------------------------------------------------ <br><h3> poke, Id: 30081467, Score: 199: </h3><p>To add to Martijn’s answer, this is the relevant part of <a href="https://hg.python.org/cpython/file/7f8cd879687b/Objects/rangeobject.c#l415" rel="noreferrer">the source</a> (in C, as the range object is written in native code):</p>
<pre class="lang-c prettyprint-override"><code>static int
range_contains(rangeobject *r, PyObject *ob)
{
    if (PyLong_CheckExact(ob) || PyBool_Check(ob))
        return range_contains_long(r, ob);

    return (int)_PySequence_IterSearch((PyObject*)r, ob,
                                       PY_ITERSEARCH_CONTAINS);
}
</code></pre>
<p>So for <code>PyLong</code> objects (which is <code>int</code> in Python 3), it will use the <code>range_contains_long</code> function to determine the result. And that function essentially checks if <code>ob</code> is in the specified range (although it looks a bit more complex in C).</p>
<p>If it’s not an <code>int</code> object, it falls back to iterating until it finds the value (or not).</p>
<p>The whole logic could be translated to pseudo-Python like this:</p>
<pre><code>def range_contains (rangeObj, obj):
    if isinstance(obj, int):
        return range_contains_long(rangeObj, obj)

    # default logic by iterating
    return any(obj == x for x in rangeObj)

def range_contains_long (r, num):
    if r.step &gt; 0:
        # positive step: r.start &lt;= num &lt; r.stop
        cmp2 = r.start &lt;= num
        cmp3 = num &lt; r.stop
    else:
        # negative step: r.start &gt;= num &gt; r.stop
        cmp2 = num &lt;= r.start
        cmp3 = r.stop &lt; num

    # outside of the range boundaries
    if not cmp2 or not cmp3:
        return False

    # num must be on a valid step inside the boundaries
    return (num - r.start) % r.step == 0
</code></pre>
------------------------------------------------------------------ <br><h3> Stefan Pochmann, Id: 30081959, Score: 61: </h3><p>The other answers explained it well already, but I'd like to offer another experiment illustrating the nature of range objects:</p>
<pre><code>&gt;&gt;&gt; r = range(5)
&gt;&gt;&gt; for i in r:
        print(i, 2 in r, list(r))
        
0 True [0, 1, 2, 3, 4]
1 True [0, 1, 2, 3, 4]
2 True [0, 1, 2, 3, 4]
3 True [0, 1, 2, 3, 4]
4 True [0, 1, 2, 3, 4]
</code></pre>
<p>As you can see, a <code>range</code> object is an object that remembers its range and can be used many times (even while iterating over it), not just a one-time generator.</p>
------------------------------------------------------------------ <br><h3> Sławomir Lenart, Id: 49318899, Score: 48: </h3><p>It's all about a <strong>lazy approach</strong> to the evaluation and some <strong>extra optimization</strong> of <code>range</code>.
Values in ranges don't need to be computed until real use, or even further due to extra optimization.</p>
<p>By the way, your integer is not such big, consider <code>sys.maxsize</code></p>
<p><code>sys.maxsize in range(sys.maxsize)</code> <em>is pretty fast</em></p>
<p>due to optimization - it's easy to compare given integer just with min and max of range.</p>
<p>but:</p>
<p><code>Decimal(sys.maxsize) in range(sys.maxsize)</code> <em>is pretty slow</em>.</p>
<p>(in this case, there is no optimization in <code>range</code>, so if python receives unexpected Decimal, python will compare all numbers)</p>
<p>You should be aware of an implementation detail but should not be relied upon, because this may change in the future.</p>
<h4> holdenweb, Comment 102279705 Score: 4: </h4>Be careful floating large integers. On most machines, <code>float(sys.maxsize) != sys.maxsize)</code> even though <code>sys.maxsize-float(sys.maxsize) == 0</code>.<br>------------------------------------------------------------------ <br><h3> RBF06, Id: 54203493, Score: 31: </h3><h2>TL;DR</h2>
<p>The object returned by <code>range()</code> is actually a <code>range</code> object. This object implements the iterator interface so you can iterate over its values sequentially, just like a generator, list, or tuple.</p>
<p>But it <strong>also</strong> implements the <a href="https://docs.python.org/3/reference/datamodel.html#object.__contains__" rel="noreferrer"><code>__contains__</code></a> interface which is actually what gets called when an object appears on the right-hand side of the <code>in</code> operator. The <code>__contains__()</code> method returns a <code>bool</code> of whether or not the item on the left-hand side of the <code>in</code> is in the object. Since <code>range</code> objects know their bounds and stride, this is very easy to implement in O(1).</p>
------------------------------------------------------------------ <br><h3> Naruto, Id: 59037501, Score: 6: </h3><ol>
<li>Due to optimization, it is very easy to compare given integers just with min and max range.</li>
<li>The reason that the <strong>range()</strong> function is so fast in Python3 is that here we use mathematical reasoning for the bounds, rather than a direct iteration of the range object.</li>
<li>So for explaining the logic here:</li>
</ol>
<ul>
<li>Check whether the number is between the start and stop.</li>
<li>Check whether the step precision value doesn't go over our number.</li>
</ul>
<ol start="4">
<li><p>Take an example, <strong>997 is in range(4, 1000, 3)</strong> because:</p>
<p><code>4 &lt;= 997 &lt; 1000, and (997 - 4) % 3 == 0.</code></p>
</li>
</ol>
<h4> Nico Haase, Comment 104625599 Score: 1: </h4>Can you share source for that? Even if that sounds legit, it would be good to back these claims by actual code<br><h4> Mohammed Shareef C, Comment 105836441 Score: 0: </h4>I think this is an example of it could be implemented. Not the exact way it is implemented. Although no reference provided it is good hint good enough to understand why inclusion checking for range can be much faster than list or tuple<br>------------------------------------------------------------------ <br><h3> benjimin, Id: 60628550, Score: 5: </h3><p>Try <code>x-1 in (i for i in range(x))</code> for large <code>x</code> values, which uses a generator comprehension to avoid invoking the <code>range.__contains__</code> optimisation.</p>
------------------------------------------------------------------ <br><h3> Matej Novosad, Id: 64283933, Score: 4: </h3><p><strong>TLDR;</strong>
the <code>range</code> is an arithmetic series so it can very easily calculate whether the object is there. It could even get the index of it if it were list like really quickly.</p>
------------------------------------------------------------------ <br><h3> Mahmoud Salhab, Id: 73609795, Score: -4: </h3><p><code>__contains__</code> method compares directly with the start and end of the range</p>
<h4> wjandrea, Comment 130243498 Score: 2: </h4>That&#39;s not really the whole story, because the <code>step</code> is important too. <a href="/a/30081470/4518341">wim&#39;s answer</a> covers the actual math involved and <a href="/a/54203493/4518341">RBF06&#39;s answer</a> includes a shorter version. I don&#39;t see any reason to duplicate that information in this answer.<br>