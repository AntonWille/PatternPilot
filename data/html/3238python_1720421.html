 <h2> Title: How do I concatenate two lists in Python? </h2> <h3> y2k, question_id: 1720421 </h3>Score: 3238, Tags: {python,list,concatenation} <br><p>How do I concatenate two lists in Python?</p>

<p>Example:</p>

<pre><code>listone = [1, 2, 3]
listtwo = [4, 5, 6]
</code></pre>

<p>Expected outcome:</p>

<pre><code>&gt;&gt;&gt; joinedlist
[1, 2, 3, 4, 5, 6]
</code></pre>
<h4> Comment 52930914 smci: </h4>Do you want to simply <b>append</b>, or do you want to <b>merge the two lists in sorted order</b>? What output do you expect for [1,3,6] and [2,4,5]? Can we assume both sublists are already sorted (as in your example)?<br><h4> Comment 110673394 Brendan Metcalfe: </h4>I made a youtube tutorial on 6 ways to concatenate lists if anyone finds it useful <a href="https://www.youtube.com/watch?v=O5kJ1v9XrDw" rel="nofollow noreferrer">youtube.com/watch?v=O5kJ1v9XrDw</a><br><h4> Comment 105567640 smci: </h4>...also what if the lists have duplicates e.g. <code>[1,2,5] and [2,4,5,6]</code>? Do you want the duplicates included, excluded, or don&#39;t-care?<br>------------------------------------------------------------------ <br><h3> Answer 1724975 Robert Rossney: </h3><p>It's also possible to create a generator that simply iterates over the items in both lists using <a href="https://docs.python.org/library/itertools.html#itertools.chain" rel="noreferrer"><code>itertools.chain()</code></a>. This allows you to chain lists (or any iterable) together for processing without copying the items to a new list:</p>

<pre class="lang-python prettyprint-override"><code>import itertools
for item in itertools.chain(listone, listtwo):
    # Do something with each list item
</code></pre>
<h4> Comment 99484795 cs95: </h4><code>chain</code> is on the slower side (but not by much) for two lists, but is the fastest solution for chaining multiple lists (n &gt;&gt; 2).<br><h4> Comment 128562022 Roel Schroeven: </h4>@cs95 Your benchmarks uses <code>chain</code> to make an iterator over all the elements but the converts the result to a list. Sometimes that&#39;s exactly what you want, but if you simply want to iterate over all the elements you can simply use the iterator from <code>chain</code>. That&#39;s probably a lot faster.<br><h4> Comment 109057020 cs95: </h4>@Moberg Compared to other ways of concatenating lists, for reference please see my benchmarks <a href="https://stackoverflow.com/a/56407963/4909087">here</a>.<br><h4> Comment 108171718 Moberg: </h4>@cs95 slow compared to what?<br>------------------------------------------------------------------ <br><h3> Answer 1720432 Daniel G: </h3><p>Use the <code>+</code> operator to combine the lists:</p>
<pre><code>listone = [1, 2, 3]
listtwo = [4, 5, 6]

joinedlist = listone + listtwo
</code></pre>
<p>Output:</p>
<pre><code>&gt;&gt;&gt; joinedlist
[1, 2, 3, 4, 5, 6]
</code></pre>
<h4> Comment 32343061 rickcnagy: </h4>another useful detail here: <code>listone += listtwo</code> results in <code>listone == [1, 2, 3, 4, 5, 6]</code><br><h4> Comment 13144572 Daniel G: </h4>@Daniel it will create a new list with a shallow copy of the items in the first list, followed by a shallow copy of the items in the second list. Use copy.deepcopy to get deep copies of lists.<br><h4> Comment 13140322 Daniel F: </h4>does this create a deep copy of listone and appends listtwo?<br><h4> Comment 33114031 MikeH: </h4>@br1ckb0t will that change what listone is pointing at?  So:<code>list3 = listone</code>   <code>listone+=listtwo</code>       Is list3 changed as well?<br><h4> Comment 47484886 153957: </h4>@Pygmalion That is not Python3 specific, but specific to how NumPy arrays handle operators. See the answer by J.F. Sebastian in the answer by Robert Rossney for concatenating NumPy arrays.<br><h4> Comment 47199563 Pygmalion: </h4>WARNING: I don&#39;t know if this is Python3 specifics, but on certain occasions (numpy array) [1,2,3]+[4] gives [5,6,7]!!!<br><h4> Comment 33145219 Guy: </h4>@MikeH Yes it changes list3.<br><h4> Comment 116431385 Epsi95: </h4>@rickcnagy <code>listone += listtwo</code> should be avoided. <code>list.extend()</code> should be used. <code>listone.extend(listtwo)</code><br><h4> Comment 118844332 Anvita Shukla: </h4>this solution does have a problem that if sort() or other list functions are used, they work on the individual lists within this newly created list<br><h4> Comment 127548741 netotz: </h4>@Epsi95 both <code>.extend()</code> and <code>.append()</code> are slightly faster than using concatenation with <code>+=</code>. See <a href="https://carbon.now.sh/pHtgygDCw06DMvDX8741" rel="nofollow noreferrer">carbon.now.sh/pHtgygDCw06DMvDX8741</a><br><h4> Comment 128484166 creanion: </h4>@netotz That benchmark does check out. But it&#39;s a tricky strategy since it&#39;s only valid if timeit picks the same iteration count for both operations (the list grows during the benchmark, and this has a memory effect).<br><h4> Comment 125375195 user16829600: </h4>@Epsi95 actually <code>a+=b</code> should be faster than <code>a.extend(b)</code> because it avoids the &quot;dot&quot; operator and a function call. <code>a+=b</code> invokes python&#39;s operator overloading mechanism and concats the lists<br><h4> Comment 125375217 user16829600: </h4>@Epsi95 timeit.timeit(&quot;a.extend(b)&quot;,&quot;a = [];b = []&quot;)-&gt;0.04359608100003243 , 0.22803364200001397 , 0.20996602899998607 &gt;&gt;&gt; timeit.timeit(&quot;a += b&quot;,&quot;a = [1,2,3,4,5];b = [1,2,3,4,5]&quot;) -&gt;  0.19983457000000726 , 0.203829810000002 , 0.19291130599998496<br>------------------------------------------------------------------ <br><h3> Answer 35631185 Dimitris Fasarakis Hilliard: </h3><p>Python &gt;= 3.5 alternative: <code>[*l1, *l2]</code></p>
<p>Another alternative has been introduced via the acceptance of <a href="https://www.python.org/dev/peps/pep-0448/" rel="noreferrer">PEP 448</a> which deserves mentioning.</p>
<p>The PEP, titled <em><strong>Additional Unpacking Generalizations</strong></em>, generally reduced some syntactic restrictions when using the starred <code>*</code> expression in Python; with it, joining two lists (applies to any iterable) can now also be done with:</p>
<pre><code>&gt;&gt;&gt; l1 = [1, 2, 3]
&gt;&gt;&gt; l2 = [4, 5, 6]
&gt;&gt;&gt; joined_list = [*l1, *l2]  # unpack both iterables in a list literal
&gt;&gt;&gt; print(joined_list)
[1, 2, 3, 4, 5, 6]
</code></pre>
<p>This functionality <em>was defined</em> for Python 3.5, but it hasn't been backported to previous versions in the 3.x family. In unsupported versions a <code>SyntaxError</code> is going to be raised.</p>
<p>As with the other approaches, this too <em>creates as shallow copy</em> of the elements in the corresponding lists.</p>
<hr />
<p>The <strong>upside</strong> to this approach is that you really don't need lists in order to perform it; anything that is iterable will do. As stated in the PEP:</p>
<blockquote>
<p>This is also useful as a more readable way of summing iterables into a
list, such as <code>my_list + list(my_tuple) + list(my_range)</code> which is now
equivalent to just <code>[*my_list, *my_tuple, *my_range]</code>.</p>
</blockquote>
<p>So while addition with <code>+</code> would raise a <code>TypeError</code> due to type mismatch:</p>
<pre><code>l = [1, 2, 3]
r = range(4, 7)
res = l + r
</code></pre>
<p>The following won't:</p>
<pre><code>res = [*l, *r]
</code></pre>
<p>because it will first unpack the contents of the iterables and then simply create a <code>list</code> from the contents.</p>
<h4> Comment 97890754 alan: </h4>A nice example of the unpacking approach working on iterable types is functions that return an iterator over one of the lists you&#39;re concatenating. For example, you could reverse one of the lists you&#39;re concatenating: <code>res = [*l1, *reversed(l2)]</code>. Since <code>reversed</code> returns an iterator, <code>res = l1 + reversed(l2)</code> would throw an error.<br><h4> Comment 98735215 Kevin S: </h4>It&#39;s worth noting that this is analogous to combining dictionary&#39;s in python.  dict3 = {**dict1, **dict2}.  Notice that we use ** to unpack the dictionary&#39;s whereas with lists we use * to unpack.<br><h4> Comment 117330649 Marcello Romani: </h4>The grammar nazy in me has to point out: *dictionaries<br><h4> Comment 127017791 AlexandreBorowczyk: </h4>Very interesting. Do you have I idea of what is the performance of this method compare to the addition?<br><h4> Comment 125375229 user16829600: </h4>@KevinS This only works with string keys, since the <code>**</code> syntax only supports string keys.<br><h4> Comment 133785042 NeilG: </h4>Good on you for raising the edge case @user16829600 but watch this: <code>a, b, c = {&quot;a&quot;:1}, {&quot;b&quot;:1}, {3:3}</code> then <code>{**a, **b, **c}  # {&#39;a&#39;: 1, &#39;b&#39;: 1, 3: 3}</code> and <code>[*a,*b,*c]  # [&#39;a&#39;, &#39;b&#39;, 3]</code> (Python 3.10)<br><h4> Comment 125243247 Amichay Oren: </h4>It&#39;s an excellent solution. However, it won&#39;t work in a list comprehension.<br>------------------------------------------------------------------ <br><h3> Answer 56407963 cs95: </h3><blockquote>
<h3><strong>How do I concatenate two lists in Python?</strong></h3>
</blockquote>
<p>As of 3.9, these are the most popular stdlib methods for concatenating two (or more) lists in Python.</p>
<div class="s-table-container">
<table class="s-table">
<thead>
<tr>
<th></th>
<th>Version Restrictions</th>
<th>In-Place?</th>
<th>Generalize?<sup>*</sup></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>a + b</code></td>
<td>-</td>
<td>No</td>
<td><code>sum(list_of_lists, [])</code><sup>1</sup></td>
</tr>
<tr>
<td><code>list(chain(a, b))</code><sup>2</sup></td>
<td>&gt;=2.3</td>
<td>No</td>
<td><code>list(chain(*list_of_lists))</code></td>
</tr>
<tr>
<td><code>[*a, *b]</code><sup>3</sup></td>
<td>&gt;=3.5</td>
<td>No</td>
<td>No</td>
</tr>
<tr>
<td><code>a += b</code></td>
<td>-</td>
<td>Yes</td>
<td>No</td>
</tr>
<tr>
<td><code>a.extend(b)</code></td>
<td>-</td>
<td>Yes</td>
<td>No</td>
</tr>
</tbody>
</table>
</div>
<p><sub>* A solution will qualify as a generalized solution if it works for an unknown number of lists (say, inside a loop or list comprehension) </sub></p>
<blockquote>
<p><strong>Footnotes</strong></p>
<ol>
<li><p>This is a slick solution because of its succinctness. But <code>sum</code> performs concatenation in a pairwise fashion, which means this is a
quadratic operation as memory has to be allocated for each step. DO
NOT USE if your lists are large.</p>
</li>
<li><p>See <a href="https://docs.python.org/3/library/itertools.html#itertools.chain" rel="noreferrer"><code>chain</code></a>
and
<a href="https://docs.python.org/3/library/itertools.html#itertools.chain.from_iterable" rel="noreferrer"><code>chain.from_iterable</code></a>
from the docs. You will need to <code>from itertools import chain</code> first.
Concatenation is linear in memory, so this is the best in terms of
performance and version compatibility. <code>chain.from_iterable</code> was introduced in 2.6.</p>
</li>
<li><p>This method uses <a href="https://www.python.org/dev/peps/pep-0448/" rel="noreferrer">Additional Unpacking Generalizations (PEP 448)</a>, but cannot
generalize to N lists unless you manually unpack each one yourself.</p>
</li>
<li><p><code>a += b</code> and <code>a.extend(b)</code> are more or less equivalent for all practical purposes. <code>+=</code> when called on a list will internally call
<code>list.__iadd__</code>, which extends the first list by the second.</p>
</li>
</ol>
</blockquote>
<hr />
<h1>Performance</h1>
<p><strong>2-List Concatenation</strong><sup>1</sup></p>
<p><a href="https://i.stack.imgur.com/mfQTe.png" rel="noreferrer"><img src="https://i.stack.imgur.com/mfQTe.png" alt="enter image description here" /></a></p>
<p>There's not much difference between these methods but that makes sense given they all have the same order of complexity (linear). There's no particular reason to prefer one over the other except as a matter of style.</p>
<p><strong>N-List Concatenation</strong></p>
<p><a href="https://i.stack.imgur.com/XcX7A.png" rel="noreferrer"><img src="https://i.stack.imgur.com/XcX7A.png" alt="enter image description here" /></a></p>
<p>Plots have been generated using the <a href="https://github.com/nschloe/perfplot" rel="noreferrer">perfplot</a> module. <a href="https://gist.github.com/Coldsp33d/0a0e0e0eee8377489aed01358fe33a47" rel="noreferrer">Code, for your reference.</a></p>
<p><sub>1. The <code>iadd</code> (<code>+=</code>) and <code>extend</code> methods operate in-place, so a copy has to be generated each time before testing. To keep things fair, all methods have a pre-copy step for the left-hand list which can be ignored.</sub></p>
<hr />
<h1>Comments on Other Solutions</h1>
<ul>
<li><p>DO NOT USE THE DUNDER METHOD <code>list.__add__</code> directly in any way, shape or form. In fact, stay clear of dunder methods, and use the operators and <code>operator</code> functions like they were designed for. Python has careful semantics baked into these which are more complicated than just calling the dunder directly. Here is <a href="https://stackoverflow.com/a/53984203/4909087">an example</a>. So, to summarise, <code>a.__add__(b)</code> =&gt; BAD; <code>a + b</code> =&gt; GOOD.</p>
</li>
<li><p>Some answers here offer <code>reduce(operator.add, [a, b])</code> for pairwise concatenation -- this is the same as <code>sum([a, b], [])</code> only more wordy.</p>
</li>
<li><p>Any method that uses <code>set</code> will drop duplicates and lose ordering. Use with caution.</p>
</li>
<li><p><code>for i in b: a.append(i)</code> is more wordy, and slower than <code>a.extend(b)</code>, which is single function call and more idiomatic. <code>append</code> is slower because of the semantics with which memory is allocated and grown for lists. See <a href="https://stackoverflow.com/questions/537086/reserve-memory-for-list-in-python">here</a> for a similar discussion.</p>
</li>
<li><p><code>heapq.merge</code> will work, but its use case is for merging sorted lists in linear time. Using it in any other situation is an anti-pattern.</p>
</li>
<li><p><code>yield</code>ing list elements from a function is an acceptable method, but <code>chain</code> does this faster and better (it has a code path in C, so it is fast).</p>
</li>
<li><p><code>operator.add(a, b)</code> is an acceptable functional equivalent to <code>a + b</code>. It's use cases are mainly for dynamic method dispatch. Otherwise, prefer <code>a + b</code> which is shorter and more readable, <em>in my opinion</em>. YMMV.</p>
</li>
</ul>
<h4> Comment 109483528 cs95: </h4>@ganeshdeshmukh The TL;DR is they&#39;re all good and which one you pick is mostly a matter of style. <code>&quot;There&#39;s not much difference between these methods but that makes sense given they all have the same order of complexity (linear). There&#39;s no particular reason to prefer one over the other except as a matter of style.</code>&quot; Solutions not listed in my answer, or critized in &quot;Comments&quot; I recommend to not use.<br><h4> Comment 109454457 GD- Ganesh Deshmukh: </h4>which is the best method then performance wise, faster one? please tell.<br><h4> Comment 101625545 endolith: </h4>the answers to <a href="https://stackoverflow.com/q/36863404/125507">stackoverflow.com/q/36863404/125507</a> could use a perfplot plot (including the numba solution)<br><h4> Comment 101650913 cs95: </h4>@endolith bit swamped with work but I&#39;ll take a look and see if I can chip in. Ty.<br><h4> Comment 130308756 mousetail: </h4>@cs95 I make some significant corrections to the table. You can revert if you don&#39;t agree<br><h4> Comment 134144109 cs95: </h4>@mousetail thanks for updating the post! The only thing I noticed was that the list unpacking syntax was listed as a generalizable solution, when in fact you can&#39;t do something like <code>[*l for l in unknown_number_of_lists]</code> whereas you can with <code>chain.iterable</code>, for example. I&#39;ve updated the table to make that clearer.<br><h4> Comment 136230837 Feuermurmel: </h4>There&#39;s also <code>[i for ls in list_of_lists for i in ls]</code>. Would be nice that include that in the list and the plots. :)<br>------------------------------------------------------------------ <br><h3> Answer 14453876 Gourneau: </h3><p>You could also use the <a href="https://docs.python.org/2.7/tutorial/datastructures.html#more-on-lists" rel="noreferrer"><code>list.extend()</code></a> method in order to add a <code>list</code> to the end of another one:</p>

<pre><code>listone = [1,2,3]
listtwo = [4,5,6]

listone.extend(listtwo)
</code></pre>

<p>If you want to keep the original list intact, you can create a new <code>list</code> object, and <code>extend</code> both lists to it:</p>

<pre><code>mergedlist = []
mergedlist.extend(listone)
mergedlist.extend(listtwo)
</code></pre>
<h4> Comment 120907141 Gourneau: </h4>It does an in place update to <code>listone</code>. So check that is in the list <code>listone</code><br><h4> Comment 125011881 Andrew: </h4>@Ayush the extend method updates listone with the values from listtwo and returns None. You want to do: listone.extend(listtwo) followed by return listone<br><h4> Comment 120868620 Ayush: </h4>Why does this method returns <code>None</code> in my case?<br><h4> Comment 120868762 Ayush: </h4><code>listone = [1,2,3]; listtwo = [4,5,6]; listone.extend(listtwo)</code> this returns me <code>None</code><br><h4> Comment 120923859 Ayush: </h4>actually I&#39;m returning a expression where I&#39;m extending a list using the method you&#39;ve mentioned. I&#39;m not re-assigning the list as said in <a href="https://stackoverflow.com/questions/29998421/extending-list-returns-none">this</a> post. My expression is something like <code>return list1.extend(list2)</code> and the this expression returns <code>None</code> to me.<br>------------------------------------------------------------------ <br><h3> Answer 3749835 Radagast: </h3><p>You can use sets to obtain merged list of unique values</p>

<pre><code>mergedlist = list(set(listone + listtwo))
</code></pre>
<h4> Comment 35703584 Nir Alfasi: </h4>+1 IMHO this is the correct way to &quot;merge&quot; (union) lists while the &quot;approved&quot; answer describes how to combine/add lists (multiset)<br><h4> Comment 16084697 metasoarous: </h4>True, however, it will also remove duplicates, if that&#39;s what you are interested in. List addition along would not do that.<br><h4> Comment 20354840 Natim: </h4>Better than <code>listone + [x for x in listtwo if x not in listone]</code><br><h4> Comment 69545404 SethMMorton: </h4>If you care about maintaining input order, then <code>import collections; mergedlist = list(collections.OrderedDict.fromkeys(listone + listtwo))</code> will do the trick.<br><h4> Comment 20354812 Natim: </h4>What is the way to do that and keep the ordering information?<br><h4> Comment 104239352 user3064538: </h4>If you care about maintaining order, on CPython 3.6+ you can do <code>mergedlist = list(dict.fromkeys(listone + listtwo))</code><br>------------------------------------------------------------------ <br><h3> Answer 1720436 Tuure Laurinolli: </h3><p>This is quite simple, and I think it was even shown in <a href="http://docs.python.org/tutorial/" rel="noreferrer">the tutorial</a>:</p>

<pre><code>&gt;&gt;&gt; listone = [1,2,3]
&gt;&gt;&gt; listtwo = [4,5,6]
&gt;&gt;&gt;
&gt;&gt;&gt; listone + listtwo
[1, 2, 3, 4, 5, 6]
</code></pre>
------------------------------------------------------------------ <br><h3> Answer 33048483 wonder.mice: </h3><p>This question directly asks about joining two lists. However it's pretty high in search even when you are looking for a way of joining many lists (including the case when you joining zero lists).</p>

<p>I think the best option is to use list comprehensions:</p>

<pre><code>&gt;&gt;&gt; a = [[1,2,3], [4,5,6], [7,8,9]]
&gt;&gt;&gt; [x for xs in a for x in xs]
[1, 2, 3, 4, 5, 6, 7, 8, 9]
</code></pre>

<p>You can create generators as well:</p>

<pre><code>&gt;&gt;&gt; map(str, (x for xs in a for x in xs))
['1', '2', '3', '4', '5', '6', '7', '8', '9']
</code></pre>

<p><strong>Old Answer</strong></p>

<p>Consider this more generic approach:</p>

<pre><code>a = [[1,2,3], [4,5,6], [7,8,9]]
reduce(lambda c, x: c + x, a, [])
</code></pre>

<p>Will output:</p>

<pre><code>[1, 2, 3, 4, 5, 6, 7, 8, 9]
</code></pre>

<p>Note, this also works correctly when <code>a</code> is <code>[]</code> or <code>[[1,2,3]]</code>.</p>

<p>However, this can be done more efficiently with <code>itertools</code>:</p>

<pre><code>a = [[1,2,3], [4,5,6], [7,8,9]]
list(itertools.chain(*a))
</code></pre>

<p>If you don't need a <code>list</code>, but just an iterable, omit <code>list()</code>.</p>

<p><strong>Update</strong></p>

<p>Alternative suggested by Patrick Collins in the comments could also work for you:</p>

<pre><code>sum(a, [])
</code></pre>
<h4> Comment 77536577 Dimitris Fasarakis Hilliard: </h4>Python 3 note: <code>reduce</code> is now in <code>functools</code> so you&#39;ll need to import it first.<br>------------------------------------------------------------------ <br><h3> Answer 15219904 Amyth: </h3><p>You could simply use the <code>+</code> or <code>+=</code> operator as follows:</p>

<pre><code>a = [1, 2, 3]
b = [4, 5, 6]

c = a + b
</code></pre>

<p>Or:</p>

<pre><code>c = []
a = [1, 2, 3]
b = [4, 5, 6]

c += (a + b)
</code></pre>

<p>Also, if you want the values in the merged list to be unique you can do:</p>

<pre><code>c = list(set(a + b))
</code></pre>
<h4> Comment 104275680 user3064538: </h4>The last part can arbitrarily re-order the items. If you want to preserve order, on CPython 3.6+ you can do <code>list(dict.fromkeys(a + b))</code><br>------------------------------------------------------------------ <br><h3> Answer 14700501 Dariusz Walczak: </h3><p>It's worth noting that the <code>itertools.chain</code> function accepts variable number of arguments:</p>

<pre><code>&gt;&gt;&gt; l1 = ['a']; l2 = ['b', 'c']; l3 = ['d', 'e', 'f']
&gt;&gt;&gt; [i for i in itertools.chain(l1, l2)]
['a', 'b', 'c']
&gt;&gt;&gt; [i for i in itertools.chain(l1, l2, l3)]
['a', 'b', 'c', 'd', 'e', 'f']
</code></pre>

<p>If an iterable (tuple, list, generator, etc.) is the input, the <code>from_iterable</code> class method may be used:</p>

<pre><code>&gt;&gt;&gt; il = [['a'], ['b', 'c'], ['d', 'e', 'f']]
&gt;&gt;&gt; [i for i in itertools.chain.from_iterable(il)]
['a', 'b', 'c', 'd', 'e', 'f']
</code></pre>
------------------------------------------------------------------ <br><h3> Answer 31254671 Mazdak: </h3><p>For cases with a low number of lists you can simply add the lists together or use in-place unpacking (available in Python-3.5+):</p>
<pre><code>In [1]: listone = [1, 2, 3] 
   ...: listtwo = [4, 5, 6]                                                                                                                                                                                 

In [2]: listone + listtwo                                                                                                                                                                                   
Out[2]: [1, 2, 3, 4, 5, 6]
                                                                                                                                                                                     
In [3]: [*listone, *listtwo]                                                                                                                                                                                
Out[3]: [1, 2, 3, 4, 5, 6]
</code></pre>
<p>As a more general way for cases with more number of lists you can use <code>chain.from_iterable()</code><sup>1</sup> function from <code>itertools</code> module. Also, based on <a href="https://stackoverflow.com/a/953097/2867928"><em>this</em> answer</a> this function is the best; or at least a very good way for flatting a nested list as well.</p>
<pre><code>&gt;&gt;&gt; l=[[1, 2, 3], [4, 5, 6], [7, 8, 9]]
&gt;&gt;&gt; import itertools
&gt;&gt;&gt; list(itertools.chain.from_iterable(l))
[1, 2, 3, 4, 5, 6, 7, 8, 9]
</code></pre>
<hr />
<sub>
1. Note that `chain.from_iterable()` is available in Python 2.6 and later. In other versions, use `chain(*l)`.
</sub>
------------------------------------------------------------------ <br><h3> Answer 24856361 user688635: </h3><p>With Python 3.3+ you can use <a href="https://docs.python.org/3/whatsnew/3.3.html#pep-380" rel="noreferrer">yield from</a>:</p>

<pre><code>listone = [1,2,3]
listtwo = [4,5,6]

def merge(l1, l2):
    yield from l1
    yield from l2

&gt;&gt;&gt; list(merge(listone, listtwo))
[1, 2, 3, 4, 5, 6]
</code></pre>

<p>Or, if you want to support an arbitrary number of iterators:</p>

<pre><code>def merge(*iters):
    for it in iters:
        yield from it

&gt;&gt;&gt; list(merge(listone, listtwo, 'abcd', [20, 21, 22]))
[1, 2, 3, 4, 5, 6, 'a', 'b', 'c', 'd', 20, 21, 22]
</code></pre>
<h4> Comment 104239636 user3064538: </h4>You can use <a href="https://docs.python.org/library/itertools.html#itertools.chain" rel="nofollow noreferrer"><code>itertools.chain</code></a> (which is equivalent) instead of defining your own function.<br>------------------------------------------------------------------ <br><h3> Answer 31270002 lavee_singh: </h3><p>If you want to merge the two lists in sorted form, you can use the <code>merge</code> function from the <code>heapq</code> library.</p>

<pre><code>from heapq import merge

a = [1, 2, 4]
b = [2, 4, 6, 7]

print list(merge(a, b))
</code></pre>
------------------------------------------------------------------ <br><h3> Answer 26462448 jpihl: </h3><p>If you can't use the plus operator (<code>+</code>),  you can use the <code>operator</code> import:</p>

<pre><code>import operator

listone = [1,2,3]
listtwo = [4,5,6]

result = operator.add(listone, listtwo)
print(result)

&gt;&gt;&gt; [1, 2, 3, 4, 5, 6]
</code></pre>

<p>Alternatively, you could also use the <code>__add__</code> <a href="https://wiki.python.org/moin/DunderAlias" rel="noreferrer">dunder</a> function:</p>

<pre><code>listone = [1,2,3]
listtwo = [4,5,6]

result = list.__add__(listone, listtwo)
print(result)

&gt;&gt;&gt; [1, 2, 3, 4, 5, 6]
</code></pre>
<h4> Comment 76787762 Dimitris Fasarakis Hilliard: </h4>grabbing dunders is generally not the best approach. If <code>+</code> is off the table, use <code>operator.add</code>.<br><h4> Comment 89053658 cs01: </h4>Why would the plus operator be unavailable?<br><h4> Comment 89061763 jpihl: </h4>Normally it wouldn&#39;t :) but if you are doing list concatenation with the map function or want to store the add function in a variable, you can&#39;t use +.<br>------------------------------------------------------------------ <br><h3> Answer 19843368 Mr Shark: </h3><p>If you need to merge two ordered lists with complicated sorting rules, you might have to roll it yourself like in the following code (using a simple sorting rule for readability :-) ).</p>

<pre><code>list1 = [1,2,5]
list2 = [2,3,4]
newlist = []

while list1 and list2:
    if list1[0] == list2[0]:
        newlist.append(list1.pop(0))
        list2.pop(0)
    elif list1[0] &lt; list2[0]:
        newlist.append(list1.pop(0))
    else:
        newlist.append(list2.pop(0))

if list1:
    newlist.extend(list1)
if list2:
    newlist.extend(list2)

assert(newlist == [1, 2, 3, 4, 5])
</code></pre>
<h4> Comment 99468361 cs95: </h4>Or just use <a href="https://docs.python.org/3/library/heapq.html#heapq.merge" rel="nofollow noreferrer"><code>heapq.merge</code></a>.<br>------------------------------------------------------------------ <br><h3> Answer 48819774 JamesVeug: </h3><p>All the possible ways to join lists that I could find</p>
<pre><code>import itertools

A = [1,3,5,7,9] + [2,4,6,8,10]

B = [1,3,5,7,9]
B.append([2,4,6,8,10])

C = [1,3,5,7,9]
C.extend([2,4,6,8,10])

D = list(zip([1,3,5,7,9],[2,4,6,8,10]))
E = [1,3,5,7,9]+[2,4,6,8,10]
F = list(set([1,3,5,7,9] + [2,4,6,8,10]))

G = []
for a in itertools.chain([1,3,5,7,9], [2,4,6,8,10]):
    G.append(a)


print(&quot;A: &quot; + str(A))
print(&quot;B: &quot; + str(B))
print(&quot;C: &quot; + str(C))
print(&quot;D: &quot; + str(D))
print(&quot;E: &quot; + str(E))
print(&quot;F: &quot; + str(F))
print(&quot;G: &quot; + str(G))
</code></pre>
<p>Output</p>
<pre><code>A: [1, 3, 5, 7, 9, 2, 4, 6, 8, 10]
B: [1, 3, 5, 7, 9, [2, 4, 6, 8, 10]]
C: [1, 3, 5, 7, 9, 2, 4, 6, 8, 10]
D: [(1, 2), (3, 4), (5, 6), (7, 8), (9, 10)]
E: [1, 3, 5, 7, 9, 2, 4, 6, 8, 10]
F: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
G: [1, 3, 5, 7, 9, 2, 4, 6, 8, 10]
</code></pre>
------------------------------------------------------------------ <br><h3> Answer 50681038 z33k: </h3><p>Use a simple list comprehension:</p>

<pre><code>joined_list = [item for list_ in [list_one, list_two] for item in list_]
</code></pre>

<p>It has all the advantages of the newest approach of using <a href="https://www.python.org/dev/peps/pep-0448/" rel="noreferrer">Additional Unpacking Generalizations</a> - i.e. you can concatenate an arbitrary number of different iterables (for example, lists, tuples, ranges, and generators) that way - and it's not limited to Python 3.5 or later.</p>
------------------------------------------------------------------ <br><h3> Answer 51688033 Michael Grossmann: </h3><p>If you are using NumPy, you can concatenate two arrays of compatible dimensions with this command:</p>
<pre><code>numpy.concatenate([a,b])
</code></pre>
<h4> Comment 116755029 Aaron John Sabu: </h4>@cs95 it doesn&#39;t &#39;not ask&#39; for numpy as well. I should say this actually helped me since the plus operator wasn&#39;t working for my application<br>------------------------------------------------------------------ <br><h3> Answer 67802980 surya: </h3><p><strong>Another way:</strong></p>
<pre><code>&gt;&gt;&gt; listone = [1, 2, 3]
&gt;&gt;&gt; listtwo = [4, 5, 6]
&gt;&gt;&gt; joinedlist = [*listone, *listtwo]
&gt;&gt;&gt; joinedlist
[1, 2, 3, 4, 5, 6]
&gt;&gt;&gt; 
</code></pre>
<h4> Comment 125625503 Konchog: </h4>How does [*a, *b] improve on a + b?<br>------------------------------------------------------------------ <br><h3> Answer 38240019 SuperNova: </h3><pre><code>list(set(listone) | set(listtwo))
</code></pre>
<p>The above code does not preserve order and removes duplicates from each list (but not from the concatenated list).</p>
------------------------------------------------------------------ <br><h3> Answer 17666852 mingxiao: </h3><p>You could use the <code>append()</code> method defined on <code>list</code> objects: </p>

<pre><code>mergedlist =[]
for elem in listone:
    mergedlist.append(elem)
for elem in listtwo:
    mergedlist.append(elem)
</code></pre>
<h4> Comment 25733478 Ryan Haining: </h4>just so you know, if this is what you&#39;re doing in practice, this is much, much slower than the other proposed methods. see <a href="http://stackoverflow.com/questions/17479361/iterating-vs-list-concatenation/17479468#17479468" title="iterating vs list concatenation">stackoverflow.com/questions/17479361/&hellip;</a><br>------------------------------------------------------------------ <br><h3> Answer 33484904 Francesco Marchetti-Stasi: </h3><p>As already pointed out by many, <code>itertools.chain()</code> is the way to go if one needs to apply <em>exactly the same treatment</em> to both lists. In my case, I had a label and a flag which were different from one list to the other, so I needed something slightly more complex. As it turns out, behind the scenes <code>itertools.chain()</code> simply does the following:</p>

<pre><code>for it in iterables:
    for element in it:
        yield element
</code></pre>

<p>(see <a href="https://docs.python.org/2/library/itertools.html" rel="noreferrer">https://docs.python.org/2/library/itertools.html</a>), so I took inspiration from here and wrote something along these lines:</p>

<pre><code>for iterable, header, flag in ( (newList, 'New', ''), (modList, 'Modified', '-f')):
    print header + ':'
    for path in iterable:
        [...]
        command = 'cp -r' if os.path.isdir(srcPath) else 'cp'
        print &gt;&gt; SCRIPT , command, flag, srcPath, mergedDirPath
        [...]
</code></pre>

<p>The main points to understand here are that lists are just a special case of iterable, which are objects like any other; and that <code>for ... in</code> loops in python can work with tuple variables, so it is simple to loop on multiple variables at the same time. </p>
------------------------------------------------------------------ <br><h3> Answer 62778742 Crystalline Core: </h3><pre><code> a = [1, 2, 3]
 b = [4, 5, 6]
     
 c = a + b
 print(c)
</code></pre>
<h3>Output</h3>
<pre class="lang-none prettyprint-override"><code>&gt;&gt;&gt; [1, 2, 3, 4, 5, 6]
</code></pre>
<p>In the above code, the &quot;+&quot; operator is used to concatenate the two lists into a single list.</p>
<h3>Another solution</h3>
<pre><code> a = [1, 2, 3]
 b = [4, 5, 6]
 c = [] # Empty list in which we are going to append the values of list (a) and (b)

 for i in a:
     c.append(i)
 for j in b:
     c.append(j)

 print(c)
</code></pre>
<h3>Output</h3>
<pre class="lang-none prettyprint-override"><code>&gt;&gt;&gt; [1, 2, 3, 4, 5, 6]
</code></pre>
------------------------------------------------------------------ <br><h3> Answer 52008429 Vishvajit Pathak: </h3><p>So there are two easy ways.</p>

<ol>
<li><strong>Using <code>+</code></strong>: It creates a new list from provided lists</li>
</ol>

<p>Example:</p>

<pre><code>In [1]: a = [1, 2, 3]

In [2]: b = [4, 5, 6]

In [3]: a + b
Out[3]: [1, 2, 3, 4, 5, 6]

In [4]: %timeit a + b
10000000 loops, best of 3: 126 ns per loop
</code></pre>

<ol start="2">
<li><strong>Using extend</strong>: It appends new list to existing list. That means it does not create a separate list.</li>
</ol>

<p>Example:</p>

<pre><code>In [1]: a = [1, 2, 3]

In [2]: b = [4, 5, 6]

In [3]: %timeit a.extend(b)
10000000 loops, best of 3: 91.1 ns per loop
</code></pre>

<p>Thus we see that out of two of most popular methods, <code>extend</code> is efficient.</p>
<h4> Comment 96964572 Tweakimp: </h4>What if i need to add multiple lists, like a+b+c+d+e?<br><h4> Comment 99468081 cs95: </h4>@Tweakimp See <a href="https://stackoverflow.com/a/56407963/4909087">this answer</a> which has a couple of options (I recommend <code>chain.from_iterable</code>).<br>------------------------------------------------------------------ <br><h3> Answer 69423586 Dilshan Madhuranga: </h3><p>I recommend three methods to concatenate the list, but the first method is most recommended,</p>
<pre><code># Easiest and least complexity method &lt;= recommended

listone = [1, 2, 3]
listtwo = [4, 5, 6]

newlist = listone + listtwo
print(newlist)

# Second-easiest method
newlist = listone.copy()
newlist.extend(listtwo)
print(newlist)
</code></pre>
<p>In the second method, I assign <code>newlist</code> to a copy of the <code>listone</code>, because I don't want to change <code>listone</code>.</p>
<pre><code># Third method
newlist = listone.copy()
for j in listtwo:
    newlist.append(j)

print(newlist)
</code></pre>
<p>This is not a good way to concatenate lists because we are using a <em>for</em> loop to concatenate the lists. So time complexity is much higher than with the other two methods.</p>
------------------------------------------------------------------ <br><h3> Answer 70524677 Franz Gastring: </h3><p>The most common method used to concatenate lists are the <strong>plus operator</strong> and the built-in method <strong>append</strong>, for example:</p>
<pre><code>list = [1,2]

list = list + [3]
# list = [1,2,3]

list.append(3)
# list = [1,2,3]

list.append([3,4])
# list = [1,2,[3,4]]
</code></pre>
<p>For most of the cases, this will work, but the <strong>append</strong> function will not extend a list if one was added. Because that is not expected, you can use another method called <strong>extend</strong>. It should work with structures:</p>
<pre><code>list = [1,2]
list.extend([3,4])
# list = [1,2,3,4]
</code></pre>
------------------------------------------------------------------ <br><h3> Answer 49497578 Akash Singh: </h3><p>A really concise way to combine a list of lists is</p>

<pre><code>list_of_lists = [[1,2,3], [4,5,6], [7,8,9]]
reduce(list.__add__, list_of_lists)
</code></pre>

<p>which gives us</p>

<pre><code>[1, 2, 3, 4, 5, 6, 7, 8, 9]
</code></pre>
<h4> Comment 99467314 cs95: </h4>Please do not use <code>list.__add__</code>, use <code>operator.add</code> instead. This is the more wordy equivalent of <code>sum(list_of_lists, [])</code> which is just as bad. DO NOT USE!<br><h4> Comment 99561823 cs95: </h4>dunder methods are &quot;private methods&quot; and should typically not be used directly (they are called by other functions). Exceptions are <code>obj.__class__</code> and <code>obj.__dict__</code>.<br><h4> Comment 122513177 mirekphd: </h4>And if <code>__add__</code> seems too low-level and unstable (prone to change), you can use <code>np.union1d</code> instead.<br><h4> Comment 99561789 Akash Singh: </h4>@cs95 can you explain what’s the issue by using list.__add__<br>------------------------------------------------------------------ <br><h3> Answer 69147880 U13-Forward: </h3><p>You could also just use <a href="https://docs.python.org/3.8/library/functions.html#sum" rel="nofollow noreferrer">sum</a>.</p>
<pre><code>&gt;&gt;&gt; a = [1, 2, 3]
&gt;&gt;&gt; b = [4, 5, 6]
&gt;&gt;&gt; sum([a, b], [])
[1, 2, 3, 4, 5, 6]
&gt;&gt;&gt;
</code></pre>
<p>This works for any length and any element type of list:</p>
<pre><code>&gt;&gt;&gt; a = ['a', 'b', 'c', 'd']
&gt;&gt;&gt; b = [1, 2, 3, 4]
&gt;&gt;&gt; c = [1, 2]
&gt;&gt;&gt; sum([a, b, c], [])
['a', 'b', 'c', 'd', 1, 2, 3, 4, 1, 2]
&gt;&gt;&gt;
</code></pre>
<p>The reason I add <code>[]</code>, is because the <code>start</code> argument is set to <code>0</code> by default, so it loops through the list and adds to <code>start</code>, but <code>0 + [1, 2, 3]</code> would give an error, so if we set the <code>start</code> to <code>[]</code>. It would add to <code>[]</code>, and <code>[] + [1, 2, 3]</code> would work as expected.</p>
------------------------------------------------------------------ <br><h3> Answer 64830302 Satyajit: </h3><p>I assume you want one of the two methods:</p>
<p><strong>Keep duplicate elements</strong></p>
<p>It is very easy. Just concatenate like a string:</p>
<pre><code>def concat_list(l1,l2):
    l3 = l1+l2
    return l3
</code></pre>
<p><strong>Next, if you want to eliminate duplicate elements</strong></p>
<pre><code>def concat_list(l1,l2):
   l3 = []
   for i in [l1,l2]:
     for j in i:
       if j not in l3:
         # Check if element exists in final list, if no then add element to list
         l3.append(j)
   return l3
</code></pre>
------------------------------------------------------------------ <br><h3> Answer 69808422 Khan: </h3><p>The solutions provided are for a single list. In case there are lists within a list and the merging of corresponding lists is required, the &quot;+&quot; operation through a <em>for</em> loop does the work.</p>
<pre><code>a = [[1,2,3], [4,5,6]]

b = [[0,1,2], [7,8,9]]

for i in range(len(a)):
    cc.append(a[i] + b[i])
</code></pre>
<p>Output: [[1, 2, 3, 0, 1, 2], [4, 5, 6, 7, 8, 9]]</p>
------------------------------------------------------------------ <br><h3> Answer 65756144 mr potato head: </h3><p>You can use the union() function in Python.</p>
<pre><code>joinedlist = union(listone, listtwo)
print(joinedlist)
</code></pre>
<p>Essentially, it’s removing one of every duplicate in the two lists. Since your lists don't have any duplicates it, it just returns the concatenated version of the two lists.</p>
<h4> Comment 116419881 maczos: </h4><code>union</code> does not work with lists, you could use it with sets or dict<br><h4> Comment 116436356 mr potato head: </h4>oh yeah sorry i haven&#39;t used it in a long time my bad<br>