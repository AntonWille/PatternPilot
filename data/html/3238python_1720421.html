 <h2> Title: How do I concatenate two lists in Python? </h2> <h4> y2k, question_id: 1720421, created_at: 2009-11-12 07:04:09+00:00 </h4>Score: 3238, Tags: {python,list,concatenation} <br><p>How do I concatenate two lists in Python?</p>

<p>Example:</p>

<pre><code>listone = [1, 2, 3]
listtwo = [4, 5, 6]
</code></pre>

<p>Expected outcome:</p>

<pre><code>&gt;&gt;&gt; joinedlist
[1, 2, 3, 4, 5, 6]
</code></pre>
<h4> Comment by smci, Score: 13, Id: 52930914, created_at: 2015-09-12 07:51:44+00:00 </h4>Do you want to simply <b>append</b>, or do you want to <b>merge the two lists in sorted order</b>? What output do you expect for [1,3,6] and [2,4,5]? Can we assume both sublists are already sorted (as in your example)?<h4> Comment by Brendan Metcalfe, Score: 8, Id: 110673394, created_at: 2020-06-25 18:48:21+00:00 </h4>I made a youtube tutorial on 6 ways to concatenate lists if anyone finds it useful <a href="https://www.youtube.com/watch?v=O5kJ1v9XrDw" rel="nofollow noreferrer">youtube.com/watch?v=O5kJ1v9XrDw</a><h4> Comment by smci, Score: 3, Id: 105567640, created_at: 2020-01-12 20:15:12+00:00 </h4>...also what if the lists have duplicates e.g. <code>[1,2,5] and [2,4,5,6]</code>? Do you want the duplicates included, excluded, or don&#39;t-care?<hr><h3>  Answer by Robert Rossney, Id: 1724975, Score: 405, created_at: 2009-11-12 20:01:50+00:00 </h3><p>It's also possible to create a generator that simply iterates over the items in both lists using <a href="https://docs.python.org/library/itertools.html#itertools.chain" rel="noreferrer"><code>itertools.chain()</code></a>. This allows you to chain lists (or any iterable) together for processing without copying the items to a new list:</p>

<pre class="lang-python prettyprint-override"><code>import itertools
for item in itertools.chain(listone, listtwo):
    # Do something with each list item
</code></pre>
<h4> Comment by cs95, Score: 11, Id: 99484795, created_at: 2019-06-04 14:10:17+00:00 </h4><code>chain</code> is on the slower side (but not by much) for two lists, but is the fastest solution for chaining multiple lists (n &gt;&gt; 2).<h4> Comment by Moberg, Score: 0, Id: 108171718, created_at: 2020-04-10 17:09:16+00:00 </h4>@cs95 slow compared to what?<h4> Comment by cs95, Score: 1, Id: 109057020, created_at: 2020-05-07 09:00:46+00:00 </h4>@Moberg Compared to other ways of concatenating lists, for reference please see my benchmarks <a href="https://stackoverflow.com/a/56407963/4909087">here</a>.<h4> Comment by Roel Schroeven, Score: 1, Id: 128562022, created_at: 2022-06-28 11:43:21+00:00 </h4>@cs95 Your benchmarks uses <code>chain</code> to make an iterator over all the elements but the converts the result to a list. Sometimes that&#39;s exactly what you want, but if you simply want to iterate over all the elements you can simply use the iterator from <code>chain</code>. That&#39;s probably a lot faster.<hr><h3> ✔️ Answer by Daniel G, Id: 1720432, Score: 5447, created_at: 2009-11-12 07:07:06+00:00 </h3><p>Use the <code>+</code> operator to combine the lists:</p>
<pre><code>listone = [1, 2, 3]
listtwo = [4, 5, 6]

joinedlist = listone + listtwo
</code></pre>
<p>Output:</p>
<pre><code>&gt;&gt;&gt; joinedlist
[1, 2, 3, 4, 5, 6]
</code></pre>
<p>NOTE: This will create a new list with a shallow copy of the items in the first list, followed by a shallow copy of the items in the second list. Use <a href="https://docs.python.org/3/library/copy.html#copy.deepcopy" rel="noreferrer">copy.deepcopy()</a> to get deep copies of lists.</p>
<h4> Comment by rickcnagy, Score: 312, Id: 32343061, created_at: 2014-01-29 16:14:49+00:00 </h4>another useful detail here: <code>listone += listtwo</code> results in <code>listone == [1, 2, 3, 4, 5, 6]</code><h4> Comment by Daniel G, Score: 212, Id: 13144572, created_at: 2012-04-19 14:51:41+00:00 </h4>@Daniel it will create a new list with a shallow copy of the items in the first list, followed by a shallow copy of the items in the second list. Use copy.deepcopy to get deep copies of lists.<h4> Comment by Daniel F, Score: 161, Id: 13140322, created_at: 2012-04-19 12:34:36+00:00 </h4>does this create a deep copy of listone and appends listtwo?<h4> Comment by MikeH, Score: 22, Id: 33114031, created_at: 2014-02-19 05:01:13+00:00 </h4>@br1ckb0t will that change what listone is pointing at?  So:<code>list3 = listone</code>   <code>listone+=listtwo</code>       Is list3 changed as well?<h4> Comment by 153957, Score: 9, Id: 47484886, created_at: 2015-04-16 11:42:16+00:00 </h4>@Pygmalion That is not Python3 specific, but specific to how NumPy arrays handle operators. See the answer by J.F. Sebastian in the answer by Robert Rossney for concatenating NumPy arrays.<h4> Comment by Pygmalion, Score: 5, Id: 47199563, created_at: 2015-04-08 18:27:39+00:00 </h4>WARNING: I don&#39;t know if this is Python3 specifics, but on certain occasions (numpy array) [1,2,3]+[4] gives [5,6,7]!!!<h4> Comment by Epsi95, Score: 4, Id: 116431385, created_at: 2021-01-22 19:55:45+00:00 </h4>@rickcnagy <code>listone += listtwo</code> should be avoided. <code>list.extend()</code> should be used. <code>listone.extend(listtwo)</code><h4> Comment by Guy, Score: 4, Id: 33145219, created_at: 2014-02-19 18:11:50+00:00 </h4>@MikeH Yes it changes list3.<h4> Comment by user16829600, Score: 0, Id: 125375195, created_at: 2022-01-31 03:47:43+00:00 </h4>@Epsi95 actually <code>a+=b</code> should be faster than <code>a.extend(b)</code> because it avoids the &quot;dot&quot; operator and a function call. <code>a+=b</code> invokes python&#39;s operator overloading mechanism and concats the lists<h4> Comment by user16829600, Score: 0, Id: 125375217, created_at: 2022-01-31 03:50:42+00:00 </h4>@Epsi95 timeit.timeit(&quot;a.extend(b)&quot;,&quot;a = [];b = []&quot;)-&gt;0.04359608100003243 , 0.22803364200001397 , 0.20996602899998607 &gt;&gt;&gt; timeit.timeit(&quot;a += b&quot;,&quot;a = [1,2,3,4,5];b = [1,2,3,4,5]&quot;) -&gt;  0.19983457000000726 , 0.203829810000002 , 0.19291130599998496<h4> Comment by netotz, Score: 0, Id: 127548741, created_at: 2022-05-10 17:43:27+00:00 </h4>@Epsi95 both <code>.extend()</code> and <code>.append()</code> are slightly faster than using concatenation with <code>+=</code>. See <a href="https://carbon.now.sh/pHtgygDCw06DMvDX8741" rel="nofollow noreferrer">carbon.now.sh/pHtgygDCw06DMvDX8741</a><h4> Comment by creanion, Score: 0, Id: 128484166, created_at: 2022-06-24 08:39:38+00:00 </h4>@netotz That benchmark does check out. But it&#39;s a tricky strategy since it&#39;s only valid if timeit picks the same iteration count for both operations (the list grows during the benchmark, and this has a memory effect).<h4> Comment by Anvita Shukla, Score: 0, Id: 118844332, created_at: 2021-04-23 19:13:24+00:00 </h4>this solution does have a problem that if sort() or other list functions are used, they work on the individual lists within this newly created list<hr><h3>  Answer by Dimitris Fasarakis Hilliard, Id: 35631185, Score: 648, created_at: 2016-02-25 15:13:10+00:00 </h3><p>Python &gt;= 3.5 alternative: <code>[*l1, *l2]</code></p>
<p>Another alternative has been introduced via the acceptance of <a href="https://www.python.org/dev/peps/pep-0448/" rel="noreferrer">PEP 448</a> which deserves mentioning.</p>
<p>The PEP, titled <em><strong>Additional Unpacking Generalizations</strong></em>, generally reduced some syntactic restrictions when using the starred <code>*</code> expression in Python; with it, joining two lists (applies to any iterable) can now also be done with:</p>
<pre><code>&gt;&gt;&gt; l1 = [1, 2, 3]
&gt;&gt;&gt; l2 = [4, 5, 6]
&gt;&gt;&gt; joined_list = [*l1, *l2]  # unpack both iterables in a list literal
&gt;&gt;&gt; print(joined_list)
[1, 2, 3, 4, 5, 6]
</code></pre>
<p>This functionality <em>was defined</em> for Python 3.5, but it hasn't been backported to previous versions in the 3.x family. In unsupported versions a <code>SyntaxError</code> is going to be raised.</p>
<p>As with the other approaches, this too <em>creates as shallow copy</em> of the elements in the corresponding lists.</p>
<hr />
<p>The <strong>upside</strong> to this approach is that you really don't need lists in order to perform it; anything that is iterable will do. As stated in the PEP:</p>
<blockquote>
<p>This is also useful as a more readable way of summing iterables into a
list, such as <code>my_list + list(my_tuple) + list(my_range)</code> which is now
equivalent to just <code>[*my_list, *my_tuple, *my_range]</code>.</p>
</blockquote>
<p>So while addition with <code>+</code> would raise a <code>TypeError</code> due to type mismatch:</p>
<pre><code>l = [1, 2, 3]
r = range(4, 7)
res = l + r
</code></pre>
<p>The following won't:</p>
<pre><code>res = [*l, *r]
</code></pre>
<p>because it will first unpack the contents of the iterables and then simply create a <code>list</code> from the contents.</p>
<h4> Comment by alan, Score: 23, Id: 97890754, created_at: 2019-04-09 16:15:00+00:00 </h4>A nice example of the unpacking approach working on iterable types is functions that return an iterator over one of the lists you&#39;re concatenating. For example, you could reverse one of the lists you&#39;re concatenating: <code>res = [*l1, *reversed(l2)]</code>. Since <code>reversed</code> returns an iterator, <code>res = l1 + reversed(l2)</code> would throw an error.<h4> Comment by Kevin S, Score: 13, Id: 98735215, created_at: 2019-05-08 18:16:03+00:00 </h4>It&#39;s worth noting that this is analogous to combining dictionary&#39;s in python.  dict3 = {**dict1, **dict2}.  Notice that we use ** to unpack the dictionary&#39;s whereas with lists we use * to unpack.<h4> Comment by Marcello Romani, Score: 8, Id: 117330649, created_at: 2021-02-25 10:39:57+00:00 </h4>The grammar nazy in me has to point out: *dictionaries<h4> Comment by AlexandreBorowczyk, Score: 3, Id: 127017791, created_at: 2022-04-15 01:35:08+00:00 </h4>Very interesting. Do you have I idea of what is the performance of this method compare to the addition?<h4> Comment by user16829600, Score: 1, Id: 125375229, created_at: 2022-01-31 03:51:59+00:00 </h4>@KevinS This only works with string keys, since the <code>**</code> syntax only supports string keys.<h4> Comment by NeilG, Score: 0, Id: 133785042, created_at: 2023-03-26 04:44:04+00:00 </h4>Good on you for raising the edge case @user16829600 but watch this: <code>a, b, c = {&quot;a&quot;:1}, {&quot;b&quot;:1}, {3:3}</code> then <code>{**a, **b, **c}  # {&#39;a&#39;: 1, &#39;b&#39;: 1, 3: 3}</code> and <code>[*a,*b,*c]  # [&#39;a&#39;, &#39;b&#39;, 3]</code> (Python 3.10)<h4> Comment by Amichay Oren, Score: 0, Id: 125243247, created_at: 2022-01-25 08:25:37+00:00 </h4>It&#39;s an excellent solution. However, it won&#39;t work in a list comprehension.<hr><h3>  Answer by cs95, Id: 56407963, Score: 359, created_at: 2019-06-01 15:20:58+00:00 </h3><blockquote>
<h3><strong>How do I concatenate two lists in Python?</strong></h3>
</blockquote>
<p>As of 3.9, these are the most popular stdlib methods for concatenating two (or more) lists in Python.</p>
<div class="s-table-container">
<table class="s-table">
<thead>
<tr>
<th></th>
<th>Version Restrictions</th>
<th>In-Place?</th>
<th>Generalize?<sup>*</sup></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>a + b</code></td>
<td>-</td>
<td>No</td>
<td><code>sum(list_of_lists, [])</code><sup>1</sup></td>
</tr>
<tr>
<td><code>list(chain(a, b))</code><sup>2</sup></td>
<td>&gt;=2.3</td>
<td>No</td>
<td><code>list(chain(*list_of_lists))</code></td>
</tr>
<tr>
<td><code>[*a, *b]</code><sup>3</sup></td>
<td>&gt;=3.5</td>
<td>No</td>
<td>No</td>
</tr>
<tr>
<td><code>a += b</code></td>
<td>-</td>
<td>Yes</td>
<td>No</td>
</tr>
<tr>
<td><code>a.extend(b)</code></td>
<td>-</td>
<td>Yes</td>
<td>No</td>
</tr>
</tbody>
</table>
</div>
<p><sub>* A solution will qualify as a generalized solution if it works for an unknown number of lists (say, inside a loop or list comprehension) </sub></p>
<blockquote>
<p><strong>Footnotes</strong></p>
<ol>
<li><p>This is a slick solution because of its succinctness. But <code>sum</code> performs concatenation in a pairwise fashion, which means this is a
quadratic operation as memory has to be allocated for each step. DO
NOT USE if your lists are large.</p>
</li>
<li><p>See <a href="https://docs.python.org/3/library/itertools.html#itertools.chain" rel="noreferrer"><code>chain</code></a>
and
<a href="https://docs.python.org/3/library/itertools.html#itertools.chain.from_iterable" rel="noreferrer"><code>chain.from_iterable</code></a>
from the docs. You will need to <code>from itertools import chain</code> first.
Concatenation is linear in memory, so this is the best in terms of
performance and version compatibility. <code>chain.from_iterable</code> was introduced in 2.6.</p>
</li>
<li><p>This method uses <a href="https://www.python.org/dev/peps/pep-0448/" rel="noreferrer">Additional Unpacking Generalizations (PEP 448)</a>, but cannot
generalize to N lists unless you manually unpack each one yourself.</p>
</li>
<li><p><code>a += b</code> and <code>a.extend(b)</code> are more or less equivalent for all practical purposes. <code>+=</code> when called on a list will internally call
<code>list.__iadd__</code>, which extends the first list by the second.</p>
</li>
</ol>
</blockquote>
<hr />
<h1>Performance</h1>
<p><strong>2-List Concatenation</strong><sup>1</sup></p>
<p><a href="https://i.stack.imgur.com/mfQTe.png" rel="noreferrer"><img src="https://i.stack.imgur.com/mfQTe.png" alt="enter image description here" /></a></p>
<p>There's not much difference between these methods but that makes sense given they all have the same order of complexity (linear). There's no particular reason to prefer one over the other except as a matter of style.</p>
<p><strong>N-List Concatenation</strong></p>
<p><a href="https://i.stack.imgur.com/XcX7A.png" rel="noreferrer"><img src="https://i.stack.imgur.com/XcX7A.png" alt="enter image description here" /></a></p>
<p>Plots have been generated using the <a href="https://github.com/nschloe/perfplot" rel="noreferrer">perfplot</a> module. <a href="https://gist.github.com/Coldsp33d/0a0e0e0eee8377489aed01358fe33a47" rel="noreferrer">Code, for your reference.</a></p>
<p><sub>1. The <code>iadd</code> (<code>+=</code>) and <code>extend</code> methods operate in-place, so a copy has to be generated each time before testing. To keep things fair, all methods have a pre-copy step for the left-hand list which can be ignored.</sub></p>
<hr />
<h1>Comments on Other Solutions</h1>
<ul>
<li><p>DO NOT USE THE DUNDER METHOD <code>list.__add__</code> directly in any way, shape or form. In fact, stay clear of dunder methods, and use the operators and <code>operator</code> functions like they were designed for. Python has careful semantics baked into these which are more complicated than just calling the dunder directly. Here is <a href="https://stackoverflow.com/a/53984203/4909087">an example</a>. So, to summarise, <code>a.__add__(b)</code> =&gt; BAD; <code>a + b</code> =&gt; GOOD.</p>
</li>
<li><p>Some answers here offer <code>reduce(operator.add, [a, b])</code> for pairwise concatenation -- this is the same as <code>sum([a, b], [])</code> only more wordy.</p>
</li>
<li><p>Any method that uses <code>set</code> will drop duplicates and lose ordering. Use with caution.</p>
</li>
<li><p><code>for i in b: a.append(i)</code> is more wordy, and slower than <code>a.extend(b)</code>, which is single function call and more idiomatic. <code>append</code> is slower because of the semantics with which memory is allocated and grown for lists. See <a href="https://stackoverflow.com/questions/537086/reserve-memory-for-list-in-python">here</a> for a similar discussion.</p>
</li>
<li><p><code>heapq.merge</code> will work, but its use case is for merging sorted lists in linear time. Using it in any other situation is an anti-pattern.</p>
</li>
<li><p><code>yield</code>ing list elements from a function is an acceptable method, but <code>chain</code> does this faster and better (it has a code path in C, so it is fast).</p>
</li>
<li><p><code>operator.add(a, b)</code> is an acceptable functional equivalent to <code>a + b</code>. It's use cases are mainly for dynamic method dispatch. Otherwise, prefer <code>a + b</code> which is shorter and more readable, <em>in my opinion</em>. YMMV.</p>
</li>
</ul>
<h4> Comment by cs95, Score: 3, Id: 109483528, created_at: 2020-05-19 20:21:30+00:00 </h4>@ganeshdeshmukh The TL;DR is they&#39;re all good and which one you pick is mostly a matter of style. <code>&quot;There&#39;s not much difference between these methods but that makes sense given they all have the same order of complexity (linear). There&#39;s no particular reason to prefer one over the other except as a matter of style.</code>&quot; Solutions not listed in my answer, or critized in &quot;Comments&quot; I recommend to not use.<h4> Comment by GD- Ganesh Deshmukh, Score: 2, Id: 109454457, created_at: 2020-05-19 05:06:08+00:00 </h4>which is the best method then performance wise, faster one? please tell.<h4> Comment by endolith, Score: 0, Id: 101625545, created_at: 2019-08-21 01:31:48+00:00 </h4>the answers to <a href="https://stackoverflow.com/q/36863404/125507">stackoverflow.com/q/36863404/125507</a> could use a perfplot plot (including the numba solution)<h4> Comment by cs95, Score: 0, Id: 101650913, created_at: 2019-08-21 17:52:08+00:00 </h4>@endolith bit swamped with work but I&#39;ll take a look and see if I can chip in. Ty.<h4> Comment by Feuermurmel, Score: 0, Id: 136230837, created_at: 2023-10-11 16:57:22+00:00 </h4>There&#39;s also <code>[i for ls in list_of_lists for i in ls]</code>. Would be nice that include that in the list and the plots. :)<h4> Comment by mousetail, Score: 0, Id: 130308756, created_at: 2022-09-21 07:22:40+00:00 </h4>@cs95 I make some significant corrections to the table. You can revert if you don&#39;t agree<h4> Comment by cs95, Score: 0, Id: 134144109, created_at: 2023-04-20 07:53:12+00:00 </h4>@mousetail thanks for updating the post! The only thing I noticed was that the list unpacking syntax was listed as a generalizable solution, when in fact you can&#39;t do something like <code>[*l for l in unknown_number_of_lists]</code> whereas you can with <code>chain.iterable</code>, for example. I&#39;ve updated the table to make that clearer.<hr><h3>  Answer by Gourneau, Id: 14453876, Score: 309, created_at: 2013-01-22 07:51:41+00:00 </h3><p>You could also use the <a href="https://docs.python.org/2.7/tutorial/datastructures.html#more-on-lists" rel="noreferrer"><code>list.extend()</code></a> method in order to add a <code>list</code> to the end of another one:</p>

<pre><code>listone = [1,2,3]
listtwo = [4,5,6]

listone.extend(listtwo)
</code></pre>

<p>If you want to keep the original list intact, you can create a new <code>list</code> object, and <code>extend</code> both lists to it:</p>

<pre><code>mergedlist = []
mergedlist.extend(listone)
mergedlist.extend(listtwo)
</code></pre>
<h4> Comment by Gourneau, Score: 8, Id: 120907141, created_at: 2021-07-16 17:33:09+00:00 </h4>It does an in place update to <code>listone</code>. So check that is in the list <code>listone</code><h4> Comment by Andrew, Score: 3, Id: 125011881, created_at: 2022-01-14 18:06:54+00:00 </h4>@Ayush the extend method updates listone with the values from listtwo and returns None. You want to do: listone.extend(listtwo) followed by return listone<h4> Comment by Ayush, Score: 2, Id: 120868620, created_at: 2021-07-15 09:10:23+00:00 </h4>Why does this method returns <code>None</code> in my case?<h4> Comment by Ayush, Score: 1, Id: 120868762, created_at: 2021-07-15 09:15:07+00:00 </h4><code>listone = [1,2,3]; listtwo = [4,5,6]; listone.extend(listtwo)</code> this returns me <code>None</code><h4> Comment by Ayush, Score: 1, Id: 120923859, created_at: 2021-07-17 17:45:55+00:00 </h4>actually I&#39;m returning a expression where I&#39;m extending a list using the method you&#39;ve mentioned. I&#39;m not re-assigning the list as said in <a href="https://stackoverflow.com/questions/29998421/extending-list-returns-none">this</a> post. My expression is something like <code>return list1.extend(list2)</code> and the this expression returns <code>None</code> to me.<hr><h3>  Answer by Radagast, Id: 3749835, Score: 264, created_at: 2010-09-20 08:43:58+00:00 </h3><p>You can use sets to obtain merged list of unique values</p>

<pre><code>mergedlist = list(set(listone + listtwo))
</code></pre>
<h4> Comment by user3064538, Score: 1, Id: 104239352, created_at: 2019-11-22 12:40:59+00:00 </h4>If you care about maintaining order, on CPython 3.6+ you can do <code>mergedlist = list(dict.fromkeys(listone + listtwo))</code><h4> Comment by metasoarous, Score: 64, Id: 16084697, created_at: 2012-08-21 00:28:28+00:00 </h4>True, however, it will also remove duplicates, if that&#39;s what you are interested in. List addition along would not do that.<h4> Comment by Natim, Score: 16, Id: 20354840, created_at: 2013-01-29 13:13:40+00:00 </h4>Better than <code>listone + [x for x in listtwo if x not in listone]</code><h4> Comment by Nir Alfasi, Score: 9, Id: 35703584, created_at: 2014-04-27 04:07:50+00:00 </h4>+1 IMHO this is the correct way to &quot;merge&quot; (union) lists while the &quot;approved&quot; answer describes how to combine/add lists (multiset)<h4> Comment by SethMMorton, Score: 5, Id: 69545404, created_at: 2016-12-15 20:11:24+00:00 </h4>If you care about maintaining input order, then <code>import collections; mergedlist = list(collections.OrderedDict.fromkeys(listone + listtwo))</code> will do the trick.<h4> Comment by Natim, Score: 2, Id: 20354812, created_at: 2013-01-29 13:12:50+00:00 </h4>What is the way to do that and keep the ordering information?<hr><h3>  Answer by Tuure Laurinolli, Id: 1720436, Score: 95, created_at: 2009-11-12 07:07:37+00:00 </h3><p>This is quite simple, and I think it was even shown in <a href="http://docs.python.org/tutorial/" rel="noreferrer">the tutorial</a>:</p>

<pre><code>&gt;&gt;&gt; listone = [1,2,3]
&gt;&gt;&gt; listtwo = [4,5,6]
&gt;&gt;&gt;
&gt;&gt;&gt; listone + listtwo
[1, 2, 3, 4, 5, 6]
</code></pre>
<hr><h3>  Answer by wonder.mice, Id: 33048483, Score: 72, created_at: 2015-10-09 23:21:27+00:00 </h3><p>This question directly asks about joining two lists. However it's pretty high in search even when you are looking for a way of joining many lists (including the case when you joining zero lists).</p>

<p>I think the best option is to use list comprehensions:</p>

<pre><code>&gt;&gt;&gt; a = [[1,2,3], [4,5,6], [7,8,9]]
&gt;&gt;&gt; [x for xs in a for x in xs]
[1, 2, 3, 4, 5, 6, 7, 8, 9]
</code></pre>

<p>You can create generators as well:</p>

<pre><code>&gt;&gt;&gt; map(str, (x for xs in a for x in xs))
['1', '2', '3', '4', '5', '6', '7', '8', '9']
</code></pre>

<p><strong>Old Answer</strong></p>

<p>Consider this more generic approach:</p>

<pre><code>a = [[1,2,3], [4,5,6], [7,8,9]]
reduce(lambda c, x: c + x, a, [])
</code></pre>

<p>Will output:</p>

<pre><code>[1, 2, 3, 4, 5, 6, 7, 8, 9]
</code></pre>

<p>Note, this also works correctly when <code>a</code> is <code>[]</code> or <code>[[1,2,3]]</code>.</p>

<p>However, this can be done more efficiently with <code>itertools</code>:</p>

<pre><code>a = [[1,2,3], [4,5,6], [7,8,9]]
list(itertools.chain(*a))
</code></pre>

<p>If you don't need a <code>list</code>, but just an iterable, omit <code>list()</code>.</p>

<p><strong>Update</strong></p>

<p>Alternative suggested by Patrick Collins in the comments could also work for you:</p>

<pre><code>sum(a, [])
</code></pre>
<h4> Comment by Dimitris Fasarakis Hilliard, Score: 7, Id: 77536577, created_at: 2017-07-24 18:00:52+00:00 </h4>Python 3 note: <code>reduce</code> is now in <code>functools</code> so you&#39;ll need to import it first.<hr><h3>  Answer by Amyth, Id: 15219904, Score: 50, created_at: 2013-03-05 09:15:56+00:00 </h3><p>You could simply use the <code>+</code> or <code>+=</code> operator as follows:</p>

<pre><code>a = [1, 2, 3]
b = [4, 5, 6]

c = a + b
</code></pre>

<p>Or:</p>

<pre><code>c = []
a = [1, 2, 3]
b = [4, 5, 6]

c += (a + b)
</code></pre>

<p>Also, if you want the values in the merged list to be unique you can do:</p>

<pre><code>c = list(set(a + b))
</code></pre>
<h4> Comment by user3064538, Score: 2, Id: 104275680, created_at: 2019-11-24 02:29:09+00:00 </h4>The last part can arbitrarily re-order the items. If you want to preserve order, on CPython 3.6+ you can do <code>list(dict.fromkeys(a + b))</code><hr><h3>  Answer by Dariusz Walczak, Id: 14700501, Score: 36, created_at: 2013-02-05 05:01:34+00:00 </h3><p>It's worth noting that the <code>itertools.chain</code> function accepts variable number of arguments:</p>

<pre><code>&gt;&gt;&gt; l1 = ['a']; l2 = ['b', 'c']; l3 = ['d', 'e', 'f']
&gt;&gt;&gt; [i for i in itertools.chain(l1, l2)]
['a', 'b', 'c']
&gt;&gt;&gt; [i for i in itertools.chain(l1, l2, l3)]
['a', 'b', 'c', 'd', 'e', 'f']
</code></pre>

<p>If an iterable (tuple, list, generator, etc.) is the input, the <code>from_iterable</code> class method may be used:</p>

<pre><code>&gt;&gt;&gt; il = [['a'], ['b', 'c'], ['d', 'e', 'f']]
&gt;&gt;&gt; [i for i in itertools.chain.from_iterable(il)]
['a', 'b', 'c', 'd', 'e', 'f']
</code></pre>
<hr><h3>  Answer by Mazdak, Id: 31254671, Score: 35, created_at: 2015-07-06 20:06:35+00:00 </h3><p>For cases with a low number of lists you can simply add the lists together or use in-place unpacking (available in Python-3.5+):</p>
<pre><code>In [1]: listone = [1, 2, 3] 
   ...: listtwo = [4, 5, 6]                                                                                                                                                                                 

In [2]: listone + listtwo                                                                                                                                                                                   
Out[2]: [1, 2, 3, 4, 5, 6]
                                                                                                                                                                                     
In [3]: [*listone, *listtwo]                                                                                                                                                                                
Out[3]: [1, 2, 3, 4, 5, 6]
</code></pre>
<p>As a more general way for cases with more number of lists you can use <code>chain.from_iterable()</code><sup>1</sup> function from <code>itertools</code> module. Also, based on <a href="https://stackoverflow.com/a/953097/2867928"><em>this</em> answer</a> this function is the best; or at least a very good way for flatting a nested list as well.</p>
<pre><code>&gt;&gt;&gt; l=[[1, 2, 3], [4, 5, 6], [7, 8, 9]]
&gt;&gt;&gt; import itertools
&gt;&gt;&gt; list(itertools.chain.from_iterable(l))
[1, 2, 3, 4, 5, 6, 7, 8, 9]
</code></pre>
<hr />
<sub>
1. Note that `chain.from_iterable()` is available in Python 2.6 and later. In other versions, use `chain(*l)`.
</sub>
<hr><h3>  Answer by user688635, Id: 24856361, Score: 34, created_at: 2014-07-21 00:53:24+00:00 </h3><p>With Python 3.3+ you can use <a href="https://docs.python.org/3/whatsnew/3.3.html#pep-380" rel="noreferrer">yield from</a>:</p>

<pre><code>listone = [1,2,3]
listtwo = [4,5,6]

def merge(l1, l2):
    yield from l1
    yield from l2

&gt;&gt;&gt; list(merge(listone, listtwo))
[1, 2, 3, 4, 5, 6]
</code></pre>

<p>Or, if you want to support an arbitrary number of iterators:</p>

<pre><code>def merge(*iters):
    for it in iters:
        yield from it

&gt;&gt;&gt; list(merge(listone, listtwo, 'abcd', [20, 21, 22]))
[1, 2, 3, 4, 5, 6, 'a', 'b', 'c', 'd', 20, 21, 22]
</code></pre>
<h4> Comment by user3064538, Score: 2, Id: 104239636, created_at: 2019-11-22 12:49:32+00:00 </h4>You can use <a href="https://docs.python.org/library/itertools.html#itertools.chain" rel="nofollow noreferrer"><code>itertools.chain</code></a> (which is equivalent) instead of defining your own function.<hr><h3>  Answer by lavee_singh, Id: 31270002, Score: 27, created_at: 2015-07-07 13:30:48+00:00 </h3><p>If you want to merge the two lists in sorted form, you can use the <code>merge</code> function from the <code>heapq</code> library.</p>

<pre><code>from heapq import merge

a = [1, 2, 4]
b = [2, 4, 6, 7]

print list(merge(a, b))
</code></pre>
<hr><h3>  Answer by jpihl, Id: 26462448, Score: 23, created_at: 2014-10-20 09:32:32+00:00 </h3><p>If you can't use the plus operator (<code>+</code>),  you can use the <code>operator</code> import:</p>

<pre><code>import operator

listone = [1,2,3]
listtwo = [4,5,6]

result = operator.add(listone, listtwo)
print(result)

&gt;&gt;&gt; [1, 2, 3, 4, 5, 6]
</code></pre>

<p>Alternatively, you could also use the <code>__add__</code> <a href="https://wiki.python.org/moin/DunderAlias" rel="noreferrer">dunder</a> function:</p>

<pre><code>listone = [1,2,3]
listtwo = [4,5,6]

result = list.__add__(listone, listtwo)
print(result)

&gt;&gt;&gt; [1, 2, 3, 4, 5, 6]
</code></pre>
<h4> Comment by Dimitris Fasarakis Hilliard, Score: 4, Id: 76787762, created_at: 2017-07-04 12:00:19+00:00 </h4>grabbing dunders is generally not the best approach. If <code>+</code> is off the table, use <code>operator.add</code>.<h4> Comment by cs01, Score: 4, Id: 89053658, created_at: 2018-06-25 19:36:56+00:00 </h4>Why would the plus operator be unavailable?<h4> Comment by jpihl, Score: 2, Id: 89061763, created_at: 2018-06-26 04:30:52+00:00 </h4>Normally it wouldn&#39;t :) but if you are doing list concatenation with the map function or want to store the add function in a variable, you can&#39;t use +.<hr><h3>  Answer by Mr Shark, Id: 19843368, Score: 16, created_at: 2013-11-07 18:04:54+00:00 </h3><p>If you need to merge two ordered lists with complicated sorting rules, you might have to roll it yourself like in the following code (using a simple sorting rule for readability :-) ).</p>

<pre><code>list1 = [1,2,5]
list2 = [2,3,4]
newlist = []

while list1 and list2:
    if list1[0] == list2[0]:
        newlist.append(list1.pop(0))
        list2.pop(0)
    elif list1[0] &lt; list2[0]:
        newlist.append(list1.pop(0))
    else:
        newlist.append(list2.pop(0))

if list1:
    newlist.extend(list1)
if list2:
    newlist.extend(list2)

assert(newlist == [1, 2, 3, 4, 5])
</code></pre>
<h4> Comment by cs95, Score: 1, Id: 99468361, created_at: 2019-06-04 04:21:28+00:00 </h4>Or just use <a href="https://docs.python.org/3/library/heapq.html#heapq.merge" rel="nofollow noreferrer"><code>heapq.merge</code></a>.<hr><h3>  Answer by JamesVeug, Id: 48819774, Score: 12, created_at: 2018-02-16 03:46:31+00:00 </h3><p>All the possible ways to join lists that I could find</p>
<pre><code>import itertools

A = [1,3,5,7,9] + [2,4,6,8,10]

B = [1,3,5,7,9]
B.append([2,4,6,8,10])

C = [1,3,5,7,9]
C.extend([2,4,6,8,10])

D = list(zip([1,3,5,7,9],[2,4,6,8,10]))
E = [1,3,5,7,9]+[2,4,6,8,10]
F = list(set([1,3,5,7,9] + [2,4,6,8,10]))

G = []
for a in itertools.chain([1,3,5,7,9], [2,4,6,8,10]):
    G.append(a)


print(&quot;A: &quot; + str(A))
print(&quot;B: &quot; + str(B))
print(&quot;C: &quot; + str(C))
print(&quot;D: &quot; + str(D))
print(&quot;E: &quot; + str(E))
print(&quot;F: &quot; + str(F))
print(&quot;G: &quot; + str(G))
</code></pre>
<p>Output</p>
<pre><code>A: [1, 3, 5, 7, 9, 2, 4, 6, 8, 10]
B: [1, 3, 5, 7, 9, [2, 4, 6, 8, 10]]
C: [1, 3, 5, 7, 9, 2, 4, 6, 8, 10]
D: [(1, 2), (3, 4), (5, 6), (7, 8), (9, 10)]
E: [1, 3, 5, 7, 9, 2, 4, 6, 8, 10]
F: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
G: [1, 3, 5, 7, 9, 2, 4, 6, 8, 10]
</code></pre>
<hr><h3>  Answer by Michael Grossmann, Id: 51688033, Score: 11, created_at: 2018-08-04 17:29:48+00:00 </h3><p>If you are using NumPy, you can concatenate two arrays of compatible dimensions with this command:</p>
<pre><code>numpy.concatenate([a,b])
</code></pre>
<h4> Comment by Aaron John Sabu, Score: 1, Id: 116755029, created_at: 2021-02-03 21:30:47+00:00 </h4>@cs95 it doesn&#39;t &#39;not ask&#39; for numpy as well. I should say this actually helped me since the plus operator wasn&#39;t working for my application<hr><h3>  Answer by z33k, Id: 50681038, Score: 10, created_at: 2018-06-04 12:49:09+00:00 </h3><p>Use a simple list comprehension:</p>

<pre><code>joined_list = [item for list_ in [list_one, list_two] for item in list_]
</code></pre>

<p>It has all the advantages of the newest approach of using <a href="https://www.python.org/dev/peps/pep-0448/" rel="noreferrer">Additional Unpacking Generalizations</a> - i.e. you can concatenate an arbitrary number of different iterables (for example, lists, tuples, ranges, and generators) that way - and it's not limited to Python 3.5 or later.</p>
<hr><h3>  Answer by surya, Id: 67802980, Score: 9, created_at: 2021-06-02 10:04:02+00:00 </h3><p><strong>Another way:</strong></p>
<pre><code>&gt;&gt;&gt; listone = [1, 2, 3]
&gt;&gt;&gt; listtwo = [4, 5, 6]
&gt;&gt;&gt; joinedlist = [*listone, *listtwo]
&gt;&gt;&gt; joinedlist
[1, 2, 3, 4, 5, 6]
&gt;&gt;&gt; 
</code></pre>
<h4> Comment by Konchog, Score: 3, Id: 125625503, created_at: 2022-02-10 12:40:51+00:00 </h4>How does [*a, *b] improve on a + b?<hr><h3>  Answer by SuperNova, Id: 38240019, Score: 8, created_at: 2016-07-07 07:42:00+00:00 </h3><pre><code>list(set(listone) | set(listtwo))
</code></pre>
<p>The above code does not preserve order and removes duplicates from each list (but not from the concatenated list).</p>
<hr><h3>  Answer by mingxiao, Id: 17666852, Score: 7, created_at: 2013-07-16 02:02:49+00:00 </h3><p>You could use the <code>append()</code> method defined on <code>list</code> objects: </p>

<pre><code>mergedlist =[]
for elem in listone:
    mergedlist.append(elem)
for elem in listtwo:
    mergedlist.append(elem)
</code></pre>
<h4> Comment by Ryan Haining, Score: 10, Id: 25733478, created_at: 2013-07-16 02:10:42+00:00 </h4>just so you know, if this is what you&#39;re doing in practice, this is much, much slower than the other proposed methods. see <a href="http://stackoverflow.com/questions/17479361/iterating-vs-list-concatenation/17479468#17479468" title="iterating vs list concatenation">stackoverflow.com/questions/17479361/&hellip;</a><hr><h3>  Answer by Francesco Marchetti-Stasi, Id: 33484904, Score: 7, created_at: 2015-11-02 18:59:02+00:00 </h3><p>As already pointed out by many, <code>itertools.chain()</code> is the way to go if one needs to apply <em>exactly the same treatment</em> to both lists. In my case, I had a label and a flag which were different from one list to the other, so I needed something slightly more complex. As it turns out, behind the scenes <code>itertools.chain()</code> simply does the following:</p>

<pre><code>for it in iterables:
    for element in it:
        yield element
</code></pre>

<p>(see <a href="https://docs.python.org/2/library/itertools.html" rel="noreferrer">https://docs.python.org/2/library/itertools.html</a>), so I took inspiration from here and wrote something along these lines:</p>

<pre><code>for iterable, header, flag in ( (newList, 'New', ''), (modList, 'Modified', '-f')):
    print header + ':'
    for path in iterable:
        [...]
        command = 'cp -r' if os.path.isdir(srcPath) else 'cp'
        print &gt;&gt; SCRIPT , command, flag, srcPath, mergedDirPath
        [...]
</code></pre>

<p>The main points to understand here are that lists are just a special case of iterable, which are objects like any other; and that <code>for ... in</code> loops in python can work with tuple variables, so it is simple to loop on multiple variables at the same time. </p>
<hr><h3>  Answer by Crystalline Core, Id: 62778742, Score: 7, created_at: 2020-07-07 15:30:08+00:00 </h3><pre><code> a = [1, 2, 3]
 b = [4, 5, 6]
     
 c = a + b
 print(c)
</code></pre>
<h3>Output</h3>
<pre class="lang-none prettyprint-override"><code>&gt;&gt;&gt; [1, 2, 3, 4, 5, 6]
</code></pre>
<p>In the above code, the &quot;+&quot; operator is used to concatenate the two lists into a single list.</p>
<h3>Another solution</h3>
<pre><code> a = [1, 2, 3]
 b = [4, 5, 6]
 c = [] # Empty list in which we are going to append the values of list (a) and (b)

 for i in a:
     c.append(i)
 for j in b:
     c.append(j)

 print(c)
</code></pre>
<h3>Output</h3>
<pre class="lang-none prettyprint-override"><code>&gt;&gt;&gt; [1, 2, 3, 4, 5, 6]
</code></pre>
<hr><h3>  Answer by Dilshan Madhuranga, Id: 69423586, Score: 6, created_at: 2021-10-03 09:28:21+00:00 </h3><p>I recommend three methods to concatenate the list, but the first method is most recommended,</p>
<pre><code># Easiest and least complexity method &lt;= recommended

listone = [1, 2, 3]
listtwo = [4, 5, 6]

newlist = listone + listtwo
print(newlist)

# Second-easiest method
newlist = listone.copy()
newlist.extend(listtwo)
print(newlist)
</code></pre>
<p>In the second method, I assign <code>newlist</code> to a copy of the <code>listone</code>, because I don't want to change <code>listone</code>.</p>
<pre><code># Third method
newlist = listone.copy()
for j in listtwo:
    newlist.append(j)

print(newlist)
</code></pre>
<p>This is not a good way to concatenate lists because we are using a <em>for</em> loop to concatenate the lists. So time complexity is much higher than with the other two methods.</p>
<hr><h3>  Answer by Franz Gastring, Id: 70524677, Score: 6, created_at: 2021-12-29 20:28:54+00:00 </h3><p>The most common method used to concatenate lists are the <strong>plus operator</strong> and the built-in method <strong>append</strong>, for example:</p>
<pre><code>list = [1,2]

list = list + [3]
# list = [1,2,3]

list.append(3)
# list = [1,2,3]

list.append([3,4])
# list = [1,2,[3,4]]
</code></pre>
<p>For most of the cases, this will work, but the <strong>append</strong> function will not extend a list if one was added. Because that is not expected, you can use another method called <strong>extend</strong>. It should work with structures:</p>
<pre><code>list = [1,2]
list.extend([3,4])
# list = [1,2,3,4]
</code></pre>
<hr><h3>  Answer by U13-Forward, Id: 69147880, Score: 4, created_at: 2021-09-12 01:48:33+00:00 </h3><p>You could also just use <a href="https://docs.python.org/3.8/library/functions.html#sum" rel="nofollow noreferrer">sum</a>.</p>
<pre><code>&gt;&gt;&gt; a = [1, 2, 3]
&gt;&gt;&gt; b = [4, 5, 6]
&gt;&gt;&gt; sum([a, b], [])
[1, 2, 3, 4, 5, 6]
&gt;&gt;&gt;
</code></pre>
<p>This works for any length and any element type of list:</p>
<pre><code>&gt;&gt;&gt; a = ['a', 'b', 'c', 'd']
&gt;&gt;&gt; b = [1, 2, 3, 4]
&gt;&gt;&gt; c = [1, 2]
&gt;&gt;&gt; sum([a, b, c], [])
['a', 'b', 'c', 'd', 1, 2, 3, 4, 1, 2]
&gt;&gt;&gt;
</code></pre>
<p>The reason I add <code>[]</code>, is because the <code>start</code> argument is set to <code>0</code> by default, so it loops through the list and adds to <code>start</code>, but <code>0 + [1, 2, 3]</code> would give an error, so if we set the <code>start</code> to <code>[]</code>. It would add to <code>[]</code>, and <code>[] + [1, 2, 3]</code> would work as expected.</p>
<hr><h3>  Answer by Akash Singh, Id: 49497578, Score: 5, created_at: 2018-03-26 17:48:29+00:00 </h3><p>A really concise way to combine a list of lists is</p>

<pre><code>list_of_lists = [[1,2,3], [4,5,6], [7,8,9]]
reduce(list.__add__, list_of_lists)
</code></pre>

<p>which gives us</p>

<pre><code>[1, 2, 3, 4, 5, 6, 7, 8, 9]
</code></pre>
<h4> Comment by cs95, Score: 1, Id: 99467314, created_at: 2019-06-04 02:38:06+00:00 </h4>Please do not use <code>list.__add__</code>, use <code>operator.add</code> instead. This is the more wordy equivalent of <code>sum(list_of_lists, [])</code> which is just as bad. DO NOT USE!<h4> Comment by cs95, Score: 1, Id: 99561823, created_at: 2019-06-06 22:33:29+00:00 </h4>dunder methods are &quot;private methods&quot; and should typically not be used directly (they are called by other functions). Exceptions are <code>obj.__class__</code> and <code>obj.__dict__</code>.<h4> Comment by mirekphd, Score: 0, Id: 122513177, created_at: 2021-09-24 13:02:15+00:00 </h4>And if <code>__add__</code> seems too low-level and unstable (prone to change), you can use <code>np.union1d</code> instead.<h4> Comment by Akash Singh, Score: 0, Id: 99561789, created_at: 2019-06-06 22:31:05+00:00 </h4>@cs95 can you explain what’s the issue by using list.__add__<hr><h3>  Answer by Vishvajit Pathak, Id: 52008429, Score: 4, created_at: 2018-08-24 16:25:58+00:00 </h3><p>So there are two easy ways.</p>

<ol>
<li><strong>Using <code>+</code></strong>: It creates a new list from provided lists</li>
</ol>

<p>Example:</p>

<pre><code>In [1]: a = [1, 2, 3]

In [2]: b = [4, 5, 6]

In [3]: a + b
Out[3]: [1, 2, 3, 4, 5, 6]

In [4]: %timeit a + b
10000000 loops, best of 3: 126 ns per loop
</code></pre>

<ol start="2">
<li><strong>Using extend</strong>: It appends new list to existing list. That means it does not create a separate list.</li>
</ol>

<p>Example:</p>

<pre><code>In [1]: a = [1, 2, 3]

In [2]: b = [4, 5, 6]

In [3]: %timeit a.extend(b)
10000000 loops, best of 3: 91.1 ns per loop
</code></pre>

<p>Thus we see that out of two of most popular methods, <code>extend</code> is efficient.</p>
<h4> Comment by Tweakimp, Score: 2, Id: 96964572, created_at: 2019-03-11 21:49:01+00:00 </h4>What if i need to add multiple lists, like a+b+c+d+e?<h4> Comment by cs95, Score: 2, Id: 99468081, created_at: 2019-06-04 03:53:07+00:00 </h4>@Tweakimp See <a href="https://stackoverflow.com/a/56407963/4909087">this answer</a> which has a couple of options (I recommend <code>chain.from_iterable</code>).<hr><h3>  Answer by Satyajit, Id: 64830302, Score: 3, created_at: 2020-11-14 02:15:07+00:00 </h3><p>I assume you want one of the two methods:</p>
<p><strong>Keep duplicate elements</strong></p>
<p>It is very easy. Just concatenate like a string:</p>
<pre><code>def concat_list(l1,l2):
    l3 = l1+l2
    return l3
</code></pre>
<p><strong>Next, if you want to eliminate duplicate elements</strong></p>
<pre><code>def concat_list(l1,l2):
   l3 = []
   for i in [l1,l2]:
     for j in i:
       if j not in l3:
         # Check if element exists in final list, if no then add element to list
         l3.append(j)
   return l3
</code></pre>
<hr><h3>  Answer by Khan, Id: 69808422, Score: 1, created_at: 2021-11-02 09:54:44+00:00 </h3><p>The solutions provided are for a single list. In case there are lists within a list and the merging of corresponding lists is required, the &quot;+&quot; operation through a <em>for</em> loop does the work.</p>
<pre><code>a = [[1,2,3], [4,5,6]]

b = [[0,1,2], [7,8,9]]

for i in range(len(a)):
    cc.append(a[i] + b[i])
</code></pre>
<p>Output: [[1, 2, 3, 0, 1, 2], [4, 5, 6, 7, 8, 9]]</p>
<hr><h3>  Answer by mr potato head, Id: 65756144, Score: -10, created_at: 2021-01-17 00:30:50+00:00 </h3><p>You can use the union() function in Python.</p>
<pre><code>joinedlist = union(listone, listtwo)
print(joinedlist)
</code></pre>
<p>Essentially, it’s removing one of every duplicate in the two lists. Since your lists don't have any duplicates it, it just returns the concatenated version of the two lists.</p>
<h4> Comment by maczos, Score: 3, Id: 116419881, created_at: 2021-01-22 13:05:44+00:00 </h4><code>union</code> does not work with lists, you could use it with sets or dict<h4> Comment by mr potato head, Score: 2, Id: 116436356, created_at: 2021-01-23 00:58:22+00:00 </h4>oh yeah sorry i haven&#39;t used it in a long time my bad