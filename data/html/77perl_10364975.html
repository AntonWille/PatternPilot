 <h2> Title: Is Try::Tiny still recommended for exception handling in Perl 5.14 or later? </h2> <h4> Eugene Yarmash, question_id: 10364975 </h4>Score: 77, Tags: {perl,exception} <br><p>The consensus of the Perl community seems to be that <a href="http://search.cpan.org/perldoc?Try::Tiny"><code>Try::Tiny</code></a> is the preferred way to handle exceptions. </p>

<p>Perl 5.14 (which is the version I use) <a href="http://perldoc.perl.org/perl5140delta.html#Exception-Handling">seems to solve</a> the <a href="https://metacpan.org/pod/Try::Tiny#BACKGROUND">issues</a> with <code>eval</code> that <code>Try::Tiny</code> addresses. Will <code>Try::Tiny</code> still provide any benefits for me? </p>
<h4> Joel Berger, Id: 13357966 Score: 6: </h4>I&#39;m interested in the community&#39;s answer to this as well! Good question!<br>------------------------------------------------------------------ <br><h3> brian d foy, Id: 10374265, Score: 34: </h3><p>My answer is unpopular, but I don't think Perl programmers should be trying to use the exceedingly poor notion of the thing we call "exceptions" in Perl. These are essentially a side channel return value. However, still being enamored with the idea of exceptions, even with all the complexities of using a global variable to pass around state, people keep trying to make it work.</p>

<p>Practically, however, people use <code>die</code> to signal failure. Some will say that you can <code>die</code> with a reference and pass back error objects, but you don't need <code>die</code> for that. We have objects, so we should use all the power of objects:</p>

<pre><code> sub some_sub {
    ...
    return Result-&gt;new( error =&gt; 1, description =&gt; ... ) if $something_went_wrong;
    return Result-&gt;new( error =&gt; 0, ... );
    }

 my $result = some_sub( ... );
 if( $result-&gt;is_error ) { ... };
</code></pre>

<p>That doesn't involve global variables, action at a distance, scoping headaches, or require special specials. You create a tiny class <code>Result</code>, or whatever you want to call it, to wrap your return values so you have structured data instead of single values with no identity. There's no more wondering what a return value means. Is that <code>undef</code> a real value or an indication of failure? Is the return value good if it's defined or if it's true? Your object can tell you these things. And, you can use the same object with <code>die</code>. If you're already using the object with <code>die</code> and using it as the return value, there's very little to recommend all the extra stuff you have to do to tolerate <code>$@</code>.</p>

<p>I talk more about this in <a href="http://www.effectiveperlprogramming.com/2011/10/return-error-objects-instead-of-throwing-exceptions/" rel="noreferrer">"Return error objects instead of throwing exceptions"</a></p>

<p>However, I know that you can't help what other people do, so you still have to pretend Perl has exceptions.</p>
<h4> msztolcman, Comment 13381140 Score: 8: </h4>Very poor? I don&#39;t think so. Errors should be handled there, where we can say what to do with them. Many of errors shouldn&#39;t be handled - just logged, and show some message to user (this must be in GUI, not in lowest level functions). It is just design assumption, and have some pros and cons (like always).<br><h4> Ovid, Comment 13916506 Score: 6: </h4>I can understand why you make your arguments, but it requires that a programmer <i>never</i> forget to check for errors. We know they should, but what we should do in theory and what we do in practice when under the gun of a tight deadline aren&#39;t the same thing. Thus, we could forget to check for that <i>one</i> critical error and have our code continue on, blithely unaware that it&#39;s corrupting its data everywhere.<br><h4> msztolcman, Comment 13376172 Score: 6: </h4>Very good solution, but die/exception has one big advantage: propagation through sub calls stack. I mean: do not test for pass or fail of some subroutine call - just don&#39;t catch an exception. It will propagate up, until someone catch it.<br><h4> Joel Berger, Comment 13376041 Score: 2: </h4>I agree, but as you said at the end, there are modules that <code>die</code> when they shouldn&#39;t, so we still need to know which mechanism to trap those exceptions. Future module designers, consider this approach!<br><h4> brian d foy, Comment 13377294 Score: 2: </h4>That propagation stuff is a very poor way to design a program. What are those higher levels supposed to do to handle an error? In Perl, you can&#39;t handle it and pick up where you left off, so you&#39;re not really handling it at all. The method I show can propagate just as well. Each level can add to the result it gets and passes on.<br><h4> Schwern, Comment 43511532 Score: 1: </h4>@briandfoy If you choose to trap and ignore an exception, you have to write explicit code to do that, which is good because you rarely want to do that.  Overwhelmingly you want something to be done with an error, even just the default to crash the program with a message, so that should be the default.  Having to check for a returned error and die every single time inverts this, the default is to do the rare thing, ignore the error.  If you forget and slip up... it&#39;s silent.  If you find code that doesn&#39;t check for a return error, did they mean to do that, or did they forget?  Who knows?<br><h4> brian d foy, Comment 43525553 Score: 0: </h4>You don&#39;t have to write code to ignore an exception. There&#39;s nothing extra required for that. But, consider the converse. Did you check that everything worked? I don&#39;t find it all that bad and it&#39;s what Mojo does, among many others.<br><h4> brian d foy, Comment 14495957 Score: 0: </h4>I&#39;m not saying not to check for errors. You can just as easily use &quot;exceptions&quot;, not check the result, and let the program continue.<br><h4> brian d foy, Comment 13389474 Score: 0: </h4>Nothing you are saying necessitates &quot;exceptions&quot;, but that by defending &quot;exceptions&quot; in Perl, note everything you have to accept and live with. Accepting all that is a pretty poor way to start.<br>------------------------------------------------------------------ <br><h3> ikegami, Id: 10366209, Score: 31: </h3><p>It was always a case of personal preference. Do you prefer</p>

<pre><code>my $rv;
if (!eval { $rv = f(); 1 } ) {
   ...
}
</code></pre>

<p>or</p>

<pre><code>my $rv = try {
   f();
} catch {
   ...
};
</code></pre>

<p>But keep in mind the latter uses anon subs, so it messes with <code>return</code>, as well as <code>next</code> and the like. Try::Tiny's try-catch might well end up far more complicated as you add communication channels between the catch block and outside of it.</p>

<p>The best case (simplest) scenario for returning on exception is if <code>$rv</code> is always true when there is no exception. It would look like the following:</p>

<pre><code>my $rv;
if ($rv = eval { f() }) {
   ...
   return;
}
</code></pre>

<p>vs</p>

<pre><code>my $rv = try {
   f();
} catch {
   ...
};

if (!$rv) {
   return;
}
</code></pre>

<p>That's why I would use <a href="http://search.cpan.org/perldoc?TryCatch">TryCatch</a> instead of <a href="http://search.cpan.org/perldoc?Try%3a%3aTiny">Try::Tiny</a> were I to use such a module.</p>

<p>The change to Perl simply means that you can do <code>if ($@)</code> again. In other words,</p>

<pre><code>my $rv;
if (!eval { $rv = f(); 1 } ) {
   ...
}
</code></pre>

<p>can be written</p>

<pre><code>my $rv = eval { f() };
if ($@) {
   ...
}
</code></pre>
<h4> zby, Comment 13360217 Score: 4: </h4>If you don&#39;t need to catch the value returned by the eval (which for me at least is the most common case) - then the eval version becomes quite a bit simpler.<br><h4> ikegami, Comment 43520236 Score: 1: </h4>@Schwern, A solution based on Devel::CallParser should load faster.<br><h4> Schwern, Comment 43533397 Score: 1: </h4>@ikegami No, the problem is its reliance on Moose and Parse::Method::Signatures (the guts of MooseX::Method::Signatures).<br><h4> ikegami, Comment 43534169 Score: 1: </h4>@Schwen, That&#39;s why Devel::CallParser would help. It would allow you to use <code>perl</code>&#39;s builtin parsing functions.<br><h4> Schwern, Comment 43511807 Score: 0: </h4>TryCatch has far fewer caveats than Try::Tiny, and it is much faster.  There is one caveat, it is abominably slow to load.<br><h4> Patrick B&#246;ker, Comment 54054291 Score: 0: </h4><a href="https://metacpan.org/pod/Devel::Declare" rel="nofollow noreferrer">Devel::Declare</a> (on which <a href="https://metacpan.org/pod/TryCatch" rel="nofollow noreferrer">TryCatch</a> is based) is <a href="https://metacpan.org/pod/MooseX::Declare#WARNING" rel="nofollow noreferrer">deprecated</a>. Since the advent of the <a href="http://perldoc.perl.org/perlapi.html#PL_keyword_plugin" rel="nofollow noreferrer">Keyword API</a> in Perl 5.14 and the seemingly more stable <a href="https://metacpan.org/pod/Devel::CallParser" rel="nofollow noreferrer">Devel::CallParser</a>, other, from my experience more robust, alternatives have emerged: <a href="https://metacpan.org/pod/Syntax::Feature::Try" rel="nofollow noreferrer">Syntax::Feature::Try</a> and <a href="https://metacpan.org/pod/Try" rel="nofollow noreferrer">Try</a>.<br><h4> ikegami, Comment 54071024 Score: 0: </h4>@patszim, Devel::Declare is not deprecated. It&#39;s not perfect, sure, but that doesn&#39;t make it deprecated. Your alternatives aren&#39;t much better. Keyword API is &quot;broken by design&quot;. Devel::CallParser has issues as well: Backwards compatibility, portability issues (didn&#39;t work on Windows, but might now), bad error messages on syntax errors. (I think I was the first to release modules using D::CP: Syntax::Feature::Loop and Syntax::Feature::QwComments).<br>------------------------------------------------------------------ <br><h3> user149341, Id: 10366267, Score: 14: </h3><p>If nothing else, <code>Try::Tiny</code> is still nice syntactic sugar. If you want something a little more heavyweight, there's also <a href="http://search.cpan.org/~ash/TryCatch/"><code>TryCatch</code></a>, which solves some issues related to the fact that the clauses in <code>Try::Tiny</code> are subroutines (for instance, that <code>return</code> doesn't leave the enclosing function).</p>
------------------------------------------------------------------ <br><h3> msztolcman, Id: 10366615, Score: 11: </h3><p><code>Try::Tiny</code> is easy and lightweight. Too easy. We had two problems:</p>

<ul>
<li><strong>anonymous</strong> subs - there was always problems with '<code>return</code>' statement inside</li>
<li>catching always and everything</li>
</ul>

<p>So I did some changes to <code>Try::Tiny</code>, that helps us. Now we have:</p>

<pre><code>try sub {},
catch 'SomeException' =&gt; sub {},
catch [qw/Exception1 Exception2/] =&gt; sub {},
catch_all sub {};
</code></pre>

<p>I know - this syntax is a little exotic, but thanks to evident '<code>sub</code>', our programmers now know that '<code>return</code>' statement exits just from exception handler, and we always catch only this exceptions that we want to catch :)</p>
<h4> ikegami, Comment 13360740 Score: 3: </h4>But more importantly, note that other modules (e.g. <a href="http://search.cpan.org/perldoc?TryCatch" rel="nofollow noreferrer">TryCatch</a>) use real blocks, not anon subs, avoiding the noise.<br><h4> ikegami, Comment 13366179 Score: 3: </h4>Depends on what you mean by light. In terms of CPU, Try::Tiny loses heavily. On the other hand, TryCatch has more complex dependencies.<br><h4> msztolcman, Comment 13366062 Score: 2: </h4>@hobbs: of course :) but if rethrow is made without your participation in it... it&#39;s much better ;) The most important thing here is different keyword for catching all exceptions then for catching just few of them :)<br><h4> ikegami, Comment 13360720 Score: 1: </h4>Note that you could have used <code>sub{}</code> without any change to Try::Tiny: <code>perl -MTry::Tiny -E&quot;&amp;try(sub { say &#39;A&#39;; die qq{B\n} if $ARGV[0] }, &amp;catch(sub { print; }));&quot; 1</code><br><h4> hobbs, Comment 13363854 Score: 1: </h4>There&#39;s no way to <i>not</i> catch everything in Perl, unless you write code that re-throws exceptions that aren&#39;t recognized :)<br><h4> msztolcman, Comment 13366042 Score: 0: </h4>@ikegami: yes, I can, but it&#39;s easy to forget it, if syntax doesn&#39;t require it. TryCatch of course have better solutions, but <code>Try::Tiny</code> with my modifications is lightest I think :)<br>------------------------------------------------------------------ <br><h3> Jacques, Id: 62145201, Score: 1: </h3><p>Try::Tiny is great, but requires semi colon on the last brace and does not permit the use of exception variable assignment and let alone the catching of exception class. <a href="https://metacpan.org/pod/TryCatch" rel="nofollow noreferrer">TryCatch</a> used to do a great job, but <a href="https://rt.cpan.org/Ticket/Display.html?id=97089" rel="nofollow noreferrer">has been broken with the new version 0.006020</a> of <a href="https://metacpan.org/pod/Devel::Declare" rel="nofollow noreferrer">Devel::Declare</a>. Another great implementation is <a href="https://metacpan.org/pod/Syntax::Keyword::Try" rel="nofollow noreferrer">Syntax::Keyword::Try</a> but it does not implement exception variable assignments or catching exception class.</p>

<p>There is a new module <a href="https://metacpan.org/pod/Nice::Try" rel="nofollow noreferrer">Nice::Try</a>, which is a perfect replacement.</p>

<p>There is no need to have semi colon on the last brace like Try::Tiny.</p>

<p>You can also do exception variable assignment like</p>

<pre><code>  try
  {
    # something
  }
  catch( $e )
  {
    # catch this in $e
  }
</code></pre>

<p>It also works using class exception like</p>

<pre><code>  try
  {
    # something
  }
  catch( Exception $e )
  {
    # catch this in $e
  }
</code></pre>

<p>And it also supports <code>finally</code>. Its features set make it quite unique.</p>

<p>Full disclosure: I have developed this module when TryCatch got broken.</p>
------------------------------------------------------------------ <br><h3> PeregrineYankee, Id: 39083586, Score: 0: </h3><p>Either do:</p>

<pre><code>local $@;
eval { … }
</code></pre>

<p>… to prevent changes to $@ from affecting global scope, or use Try::Tiny.</p>

<p>Syntactically, there are situations where I prefer one or the other.</p>
