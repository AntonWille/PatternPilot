 <h2> Title: What are the differences between Perl, Python, AWK and sed? </h2> <h3> Khaled Al Hourani, question_id: 366980 </h3>Score: 290, Tags: {python,perl,sed,awk,language-comparisons} <br><p>What are the main differences among them? And in which typical scenarios is it better to use each language?</p>
<h4> Comment 26751582 Steam: </h4>These type of so called un-constructive questions are really helpful.<br><h4> Comment 30292553 user1115652: </h4>Sure, a tab on the front page to find them would be handy...<br><h4> Comment 63889722 Neil McGuigan: </h4>For usefulness of python on the command line, see pyp<br>------------------------------------------------------------------ <br><h3> Answer 367014 Jonathan Leffler: </h3><p>In order of appearance, the languages are <code>sed</code>, <code>awk</code>, <code>perl</code>, <code>python</code>.</p>

<p>The <code>sed</code> program is a stream editor and is designed to apply the actions from a script to each line (or, more generally, to specified ranges of lines) of the input file or files. Its language is based on <code>ed</code>, the Unix editor, and although it has conditionals and so on, it is hard to work with for complex tasks. You can work minor miracles with it - but at a cost to the hair on your head. However, it is probably the fastest of the programs when attempting tasks within its remit. (It has the least powerful regular expressions of the programs discussed - adequate for many purposes, but certainly not PCRE - Perl-Compatible Regular Expressions)</p>

<p>The <code>awk</code> program (name from the initials of its authors - Aho, Weinberger, and Kernighan) is a tool initially for formatting reports. It can be used as a souped-up <code>sed</code>; in its more recent versions, it is computationally complete. It uses an interesting idea - the program is based on 'patterns matched' and 'actions taken when the pattern matches'. The patterns are fairly powerful (Extended Regular Expressions). The language for the actions is similar to C. One of the key features of <code>awk</code> is that it splits the input automatically into records and each record into fields.</p>

<p>Perl was written in part as an awk-killer and sed-killer. Two of the programs provided with it are <code>a2p</code> and <code>s2p</code> for converting <code>awk</code> scripts and <code>sed</code> scripts into Perl. Perl is one of the earliest of the next generation of scripting languages (Tcl/Tk can probably claim primacy). It has powerful integrated regular expression handling with a vastly more powerful language. It provides access to almost all system calls and has the extensibility of the CPAN modules. (Neither <code>awk</code> nor <code>sed</code> is extensible.) One of Perl's mottos is "TMTOWTDI - There's more than one way to do it" (pronounced "tim-toady"). Perl has 'objects', but it is more of an add-on than a fundamental part of the language.</p>

<p>Python was written last, and probably in part as a reaction to Perl. It has some interesting syntactic ideas (indenting to indicate levels - no braces or equivalents). It is more fundamentally object-oriented than Perl; it is just as extensible as Perl.</p>

<p>OK - when to use each?</p>

<ul>
<li>Sed - when you need to do simple text transforms on files.</li>
<li>Awk - when you only need simple formatting and summarisation or transformation of data.</li>
<li>Perl - for almost any task, but especially when the task needs complex regular expressions.</li>
<li>Python - for the same tasks that you could use Perl for.</li>
</ul>

<p>I'm not aware of anything that Perl can do that Python can't, nor vice versa. The choice between the two would depend on other factors. I learned Perl before there was a Python, so I tend to use it. Python has less accreted syntax and is generally somewhat simpler to learn. Perl 6, when it becomes available, will be a fascinating development.</p>

<p>(Note that the 'overviews' of Perl and Python, in particular, are woefully incomplete; whole books could be written on the topic.)</p>
<h4> Comment 2643039 jk.: </h4>note the zen of python is basically the antithesis of TMTOWTDI so i would say it could be a reaction to perl. iirc TCL was slightly after perl and is also fairly reactionary against perl, though TCLs reaction is in syntax and language complexity, not ways to do things<br><h4> Comment 2955830 Martin Beckett: </h4>Whatever the original intentions, it&#39;s clear that later Python development and the python community have preferred readability and consistency over Perl&#39;s more flexible but terse syntax.   Excellent post Jonathan<br><h4> Comment 26928065 Jonathan Leffler: </h4>@blasto: For ETL, I&#39;d prioritize <code>awk</code> over <code>sed</code> for learning (though both still have their uses).  As to size of task: <code>sed</code> is at its finest when it processes one line at a time, with no storage from line to line.  <code>awk</code> is often used to build up associative arrays with data accumulated from all the sources; it uses more memory, and is therefore much more likely to run into problems with large data sets than <code>sed</code> is. I&#39;ve not heard of <code>tsawk</code> before you linked to it. I tend to fall back on Perl (but you might do better with Python) when a task is too much for <code>awk</code>.<br><h4> Comment 2643773 Jonathan Leffler: </h4>@jk: Tcl/Tk was under development in 1987 and first released in 1988; Perl 1.000 was released in December 1987.  I don&#39;t think Tcl/Tk was a reaction to Perl - it was an independent invention.  Python was started in 1989.  Perl may not have had much influence on the basics of Python (or Tcl/Tk) after all - except to the extent that any language developments are aware of the existence of other languages (C++, Java, C#, ...).<br><h4> Comment 196448 ConcernedOfTunbridgeWells: </h4>I don&#39;t think Python was a reaction to Perl.  My understanding is that it started life as a scripting language for Amoeba (a unix-ish research O/S) and was pretty much independent.<br><h4> Comment 2266165 Matt Joiner: </h4>Lol Python and Perl have nothing in common. They share a lot of common features like any other languages, and then don&#39;t.<br><h4> Comment 58441196 Olivier Dulac: </h4>Nice post. However I&#39;d mention that page ( <a href="https://swtch.com/~rsc/regexp/regexp1.html" rel="nofollow noreferrer">swtch.com/~rsc/regexp/regexp1.html</a> ) when talking about using regexp with perl (Perl&#39;s regexp are more flexible, and can be much more legible, but awk &amp; grep (&amp; sed?) are infinitely faster for some use cases (and as fast for the others) than their perl/ruby/python equivalents)<br><h4> Comment 30292529 user1115652: </h4>Some slimmed down versions of unix (on routers for example) might not have python or even perl installed. Portability to such systems might be a reason to use something more primitive.<br><h4> Comment 26926256 Jonathan Leffler: </h4>@blasto: If you can, learn both; they both still have their uses as far as I&#39;m concerned, and somewhat different uses. There are things that are easy in <code>sed</code> that are not so easy in <code>awk</code>, and many more things that are doable in <code>awk</code> that aren&#39;t doable in <code>sed</code>. Apparently, <a href="http://www.catonmat.net/blog/proof-that-sed-is-turing-complete/" rel="nofollow noreferrer"><code>sed</code> is Turing complete</a>, but that doesn&#39;t make it easy to use as a general purpose language. It depends in part on what work you need to do more — editing to transform data (<code>sed</code>) or summarizing and formatting data (<code>awk</code>). Learning both is best, though.<br><h4> Comment 26927568 Steam: </h4>@JonathanLeffler - What would be most useful to an ETL developer ? ETL or Extract Transform and Load is a data-warehousing term. Put crudely, the job involves EXTRACTION of data from different disparate sources (such as DB&#39;s, excel files, csv files etc), TRANSFORMATION of the same and then LOADING into a datawarehouse (DW) for analysis, finding patterns in data, or just historical records. eg. End use of a DW - Algorithms applied to a DW of a grocery store which has data from the past 10 years might reveal that people who tend to buy apples also buy oranges or something similar.<br><h4> Comment 26927967 Steam: </h4>A link says - <a href="http://www.vectorsite.net/tsawk_1.html" rel="nofollow noreferrer">vectorsite.net/tsawk_1.html</a> - &quot;There are, however, things that Awk is not. It is not really well suited for extremely large, complicated tasks.&quot;  Now, how &quot;large&quot; a task can awk handle ? How does sed compare in that respect ?<br><h4> Comment 26924657 Steam: </h4>@JonathanLeffler - If its only sed vs awk, which one should i learn ? should i do both ?<br><h4> Comment 196462 Robert Gamble: </h4>I agree with NXC, aside from regular expressions there is little similarity between Python and Perl and nothing I have seen to suggest any real relation, inspiration, etc.  I see a much closer connection between Ruby and Perl than Python and Perl.<br><h4> Comment 196650 Jonathan Leffler: </h4>@NXC and Robert Gamble: my intention was to indicate that Python was independent of Perl. I&#39;m not sure how much Guido van Rossum knew about Perl as he was designing Python, but perhaps there&#39;s a case for saying that where there were two choices and Perl had taken option A, then Python took option B.<br>------------------------------------------------------------------ <br><h3> Answer 2905791 Charlie: </h3><p>After mastering a few dozen languages, one gets tired of absolute recommendations against tools, like in <a href="https://stackoverflow.com/a/367082/2057969">this answer</a> regarding <code>sed</code> and <code>awk</code>.</p>
<p>Sed is the best tool for extremely simple command-line pipelines.  In the hands of a sed master, it's suitable for one-offs of arbitrary complexity, but it should not be used in production code except in very simple substitution pipelines.  Stuff like 's/this/that/.'</p>
<p>Gawk (the GNU awk) is by far the best choice for complex data reformatting when there is only a single input source and a single output (or, multiple outputs sequentially written).  Since a great deal of real-world work conforms to this description, and a good programmer can learn gawk in two hours, it is the best choice.  On this planet, simpler and faster is better!</p>
<p>Perl or Python are far better than any version of awk or sed when you have very complex input/output scenarios.  The more complex the problem is, the better off you are using python, from a maintenance and readability standpoint.  Note, however, that a good programmer can write readable code in any language, and a bad programmer can write unmaintainable crap in any useful language, so the choice of perl or python can safely be left to the preferences of the programmer if said programmer is skilled and clever.</p>
<h4> Comment 9531195 ata: </h4>100% agreed. Knowing most, if not all the tools AND when to use each is what distinguishes a good technician from a mediocre one.<br><h4> Comment 11377795 sorpigal: </h4>I will add that another reason to choose Python or Perl instead of awk is when your transformation requirements involve complex validation or logic for which another language has an existing, robust module. Think about what it would take to properly handle e.g. email or street addresses in awk and you&#39;ll see what I mean: perl and python have libraries that make things like this trivial, in awk these are uncommon or unavailable.<br><h4> Comment 28871390 Brad Gilbert: </h4>Actually as Perl was designed to encompass both Sed and Awk; I find it easier to just write it in Perl, rather than learning Sed or Awk.<br><h4> Comment 58441257 Olivier Dulac: </h4>@BradGilbert: like I just mentionned in the top answer, a caveat of Perl(&amp;Python, ruby, etc) over awk is that some kind of regexp are reaaaaaaaaaally slower in the former : <a href="https://swtch.com/~rsc/regexp/regexp1.html" rel="nofollow noreferrer">swtch.com/~rsc/regexp/regexp1.html</a><br><h4> Comment 58443684 Brad Gilbert: </h4>@OlivierDulac Yes that shows a pathologic case. If you change from <code>a?ⁿaⁿ</code> to <code>a??ⁿaⁿ</code> then run that in Perl 5 with an <code>ⁿ</code> of 1,000,000 it runs in less than two seconds. <code>time perl -E &#39;$x=1_000_000;$_=&quot;a&quot;x$x;$m=(&quot;a??&quot;x$x).(&quot;a&quot;x$x);say $_=~$m&#39;</code> If you run the naive one it takes more than two seconds for an <code>ⁿ</code> of just 25. The thing you have to realize is Perl has more regex features than those faster ones including allowing you to have Perl code inside of the regex that alters what it matches. You could implement a module that swaps the built-in for one of those others if you want.<br>------------------------------------------------------------------ <br><h3> Answer 367002 Robert Gamble: </h3><p>I wouldn't call sed a fully-fledged programming language, it is a stream editor with language constructs aimed at editing text files programmatically.</p>

<p>Awk is a little more of a general purpose language but it is still best suited for text processing.</p>

<p>Perl and Python are fully fledged, general purpose programming languages.  Perl has its roots in text processing and has a number of awk-like constructs (there is even an awk-to-perl script floating around on the net).  There are many differences between Perl and Python, your best bet is probably to read the summaries of both languages on something like Wikipedia to get a good grasp on what they are.</p>
<h4> Comment 2266516 Dennis Williamson: </h4>@Sam: Wow! I didn&#39;t know a printer&#39;s laser could be cranked up enough to cut wood! Oh, sorry, wrong kind of router.<br><h4> Comment 196666 Sam Kington: </h4>I worked with a guy once who wrote PostScript to turn a laser printer into a router.<br><h4> Comment 196450 ConcernedOfTunbridgeWells: </h4>I&#39;ve seen a sed implementation of Sokoban, which would imply Turing Completeness.  However, that can also be said of sendmail.cf and TeX.<br><h4> Comment 21055534 bernard paulus: </h4>sed, not a full-fledged language? Well, that&#39;s not entirely true, as <a href="http://www.catonmat.net/blog/proof-that-sed-is-turing-complete/" rel="nofollow noreferrer">sed is turing complete</a> ;)<br><h4> Comment 41304931 Tatjana Heuser: </h4>I&#39;ve seen an implementation of the forth language in awk. (Since awk can be regarded as a parser by its own right, it is rather straightforward to implement an interpreter in it).<br><h4> Comment 28871248 Brad Gilbert: </h4>The Awk to Perl script comes with Perl <a href="http://perldoc.perl.org/a2p.html" rel="nofollow noreferrer">(a2p)</a>, so does the Sed to Perl script <a href="http://perldoc.perl.org/s2p.html" rel="nofollow noreferrer">(s2p)</a>.<br>------------------------------------------------------------------ <br><h3> Answer 367082 S.Lott: </h3><p>First, there are two unrelated things in the list "Perl, Python awk and sed".</p>

<p>Thing 1 - simplistic text manipulation tools.</p>

<ul>
<li><p>sed.  It has a fixed, relatively simple scope of work defined by the idea of reading and examining each line of a file.  sed is not designed to be particularly readable.  It is designed to be very small and very efficient on very tiny unix servers.</p></li>
<li><p>awk.  It has a slightly less fixed, less simple scope of work.  However, the main loop of an awk program is defined by the implicit reading of lines of a source file. </p></li>
</ul>

<p>These are not "complete" programming languages.  While you can -- with some work -- write fairly sophisticated programs in awk, it rapidly gets complicated and difficult to read.</p>

<p>Thing 2 - general-purposes programming languages.  These have a rich variety of statement types, numerous built-in data structures, and no wired-in assumptions or shortcuts to speak of.</p>

<ul>
<li><p>Perl.</p></li>
<li><p>Python. </p></li>
</ul>

<p>When to use them.</p>

<ul>
<li><p>sed.  Never.  It really doesn't have any value in the modern era of computers with more than 32K of memory.  Perl or Python do the same things more clearly.</p></li>
<li><p>awk.  Never.  Like sed, it reflects an earlier era of computing.  Rather than maintain this language (in addition to all the other required for a successful system), it's more pleasant to simply do everything in one pleasant language.</p></li>
<li><p>Perl.  Any programming problem of any kind.  If you like free-thinking syntax, where there are many, many ways to do the same thing, perl is fun.</p></li>
<li><p>Python.   Any programming problem of any kind.  If you like fairly limited syntax, where there are fewer choices, less subtlety, and (perhaps) more clarity.  Python's object-oriented nature makes it more suitable for large, complex problems.</p></li>
</ul>

<p>Background -- I'm not bashing sed and awk out of ignorance.  I learned awk over 20 years ago.  Did many things with it; used to teach it as a core unix skill.  I learned Perl about 15 years ago.  Did many sophisticated things with it.  I've left both behind because I can do the same things in Python -- and it is simpler and more clear.</p>

<p>There are two serious problems with sed and awk, neither of which are their age.</p>

<ol>
<li><p>The incompleteness of their implementation. Everything sed and awk do can be done in Python or Perl, often more simply and sometimes faster, too.  A shell pipeline has some performance advantages because of its multi-processing.   Python offers a <code>subprocess</code> module to allow me to recover those advantages.</p></li>
<li><p>The need to learn yet another language.  By doing things in Python (or Perl) your implementation depends on fewer languages, with a resulting increase in clarity.</p></li>
</ol>
<h4> Comment 196441 RET: </h4>Some pretty fatuous arguments against awk/sed. The adjustable wrench has not supplanted the open spanner for the same reason sed and awk still ship. Sometimes the simple tool is the best for the job. I write a lot of perl, but for a simple chain of piped commands, awk/sed are quicker than perl -e<br><h4> Comment 196658 Jeremy Cantrell: </h4>Half of my shell scripts use either sed or awk. They are far from dead. Python is my preferred scripting language, but sometimes sed and awk are the best tool for the job. Just because they have been in use for many years, does not mean they are obsolete.<br><h4> Comment 196452 ConcernedOfTunbridgeWells: </h4>You can&#39;t assume availability of anything but sh, sed and awk on most non-linux unix systems.  If you want something to work on an out-of-the-box Solaris, HP/UX or AIX install, you&#39;re stuck with sed and awk.<br><h4> Comment 9531115 ata: </h4>I don&#39;t like answers like this. Sed and awk are easy to understand in a few hours and much more lightweight and widely available than a full fledged language. Shell programming is as relevant as ever.<br><h4> Comment 196771 RET: </h4>@S.Lott: I&#39;m not suggesting that anyone should attempt to build a web-app in awk, but to say they should never be used is a bit outrageous. For a simple s&amp;r and/or tweak (especially to a delimited text file), perl -e or python -c is never going to be as efficient as a sed/awk one-liner.<br><h4> Comment 9531387 S.Lott: </h4>@Juaco: &quot;Sed and awk are easy to understand&quot; and they clutter up my limited brain space with yet more syntax and yet more semantic rules.  They may be &quot;simple&quot;, but it&#39;s just two more languages that don&#39;t add significant value. &quot;widely available&quot;?  Python is available everywhere but Windows by default.  Same as sed and awk.  The answer never mentioned shell programming.  &quot;Never&quot; is an important word.  It makes people think about exceptions and special cases that can never be fully enumerated.<br><h4> Comment 51434467 runrig: </h4>Nothing beats awk for something like <code>awk &#39;$5 &gt; 100&#39; file.txt</code><br><h4> Comment 36014721 Brōtsyorfuzthrāx: </h4>People keep talking about Python like it&#39;s Assembly or something. I haven&#39;t used Perl, Awk or SED much, but Python&#39;s syntax is a whole lot more flexible than anything else I&#39;ve used (Java, C++, C#, Vala, Visual Basic, etc.), except for maybe Lua. Lua&#39;s pretty flexible. Saying Python&#39;s syntax isn&#39;t flexible is like saying grass isn&#39;t green unless it&#39;s in England. Maybe it&#39;s less flexible than some languages, but it&#39;s still really flexible compared to probably most of the stuff out there.<br><h4> Comment 197137 S.Lott: </h4>@RET:  I&#39;m taking a strong position for a reason.  They should be looked at as different from perl and python; unrelated.  They don&#39;t solve a problem I ever have anymore since I started using Python for all scripting.<br><h4> Comment 2266194 Matt Joiner: </h4>I fully support this answer! I&#39;ve used sed, Perl and Python heavily. Let sed have peace in its coffin.<br><h4> Comment 58444652 Brad Gilbert: </h4>@runrig That would be <code>perl -ane &#39;print if $F[4] &gt; 100&#39; file.txt</code> in Perl. Granted it is a little more verbose, but since I already know Perl from using it in much larger projects; I don&#39;t have to learn another language to write it. I just have to know a few command line switches. I could also add a separate <code>-i</code> switch to cause it to edit the file in place with the Perl version. So you still haven&#39;t convinced me that learning another language that has very limited usefulness is worth my time. ( I only figured out what your awk code was doing from running it through <code>a2p</code> )<br><h4> Comment 196466 S.Lott: </h4>@NXC: not really.  Perl and Python are available from the vendors.  For example, see <a href="http://www-03.ibm.com/systems/p/os/aix/linux/" rel="nofollow noreferrer">www-03.ibm.com/systems/p/os/aix/linux</a><br><h4> Comment 196501 S.Lott: </h4>@RET: &quot;for a simple chain of piped commands&quot; -- sometimes it&#39;s quicker to replace the pipe with a simple Python program.<br><h4> Comment 196572 S.Lott: </h4>@RET: Tried to provide my justification -- been using awk and perl for decades -- I&#39;m not sure what more I can provide for evidence other than my experience.<br><h4> Comment 9871971 ata: </h4>Not going to continue arguing, I believe &quot;subjective&quot; stuff really isn&#39;t a goal here. And this conversation is very it. Good luck<br><h4> Comment 197135 S.Lott: </h4>@Jeremy Cantrell:  I don&#39;t believe I said age was the issue.  I believe I said incompleteness was the issue.  I&#39;ll update the answer to emphasize that.<br><h4> Comment 58582053 runrig: </h4>@BradGilbert I&#39;m not saying you should go learn awk. I was just refuting the &#39;never use awk&#39; in the post above. I learned awk long before perl, it&#39;s in my toolbox, and I&#39;ll use it if I think it solves the problem best. Granted, for anything more complicated, I&#39;ll use perl. If a problem becomes more complicated and I need to rewrite in Perl, then at least there&#39;s not much to rewrite.<br>------------------------------------------------------------------ <br><h3> Answer 2629882 tao quam : </h3><p>When to use them: awk - never - S. Lott.</p>

<p>I think S. Lott slightly missed the mark with this recommendation.  The fact is, on Linux and the other UNIX environments, awk is a useful tool to be used with bash, sh, and ksh for quick text processings.  The idea of scripting itself is you solve your problem by gluing together this tool, that tool.  Hence in admin scripts, it is common to has ls, grep, |, awk, time, ps, etc.  Each is a tool that the scripter combines like a builder brick by brick to finish the building (to solve the problem at hand). </p>

<p>For instance I am a team member of the team managing <a href="http://www.paintball-gear-supplies.com/" rel="noreferrer">paintball gear supplies</a> dotcom. This e-commerce site is based on the LAMP stack. For automated processing and normalizing data feeds from various suppliers into the back end database, we employ and maintain a diversified mix of scripts, including bash, perl, php, and even expect.  Each has its strengths based on the available modules and API.  In the bash scripts we do quick patterns match and appropriate actions on the patterns as needed using awk without the need to switch to PERL.  One thing I would also like to point out, which has not been emphasized in the thread, is that a fair number of these scripts were purchased, or gotten from the open source. If the script came as Perl, we maintain it as Perl; if the script came as Php, we maintain it as Php; if it came as bash, we maintain it as bash; we do not re-write it in another language just because we think it is less efficient in the original language.</p>
<h4> Comment 14826966 user529649: </h4>as side note on this fairly old answer: never parse the output of <code>ls</code>, use glob instead. <a href="http://mywiki.wooledge.org/ParsingLs" rel="nofollow noreferrer">read this.</a><br>