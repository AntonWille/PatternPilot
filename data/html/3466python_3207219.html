 <h2> Title: How do I list all files of a directory? </h2> <h4> duhhunjonn, question_id: 3207219, created_at: 2010-07-08 19:31:22+00:00 </h4>Score: 3466, Tags: {python,directory} <br><p>How can I list all files of a directory in Python and add them to a <code>list</code>?</p>
<h4> Comment by rds, Score: 27, Id: 10886246, created_at: 2012-01-05 09:32:47+00:00 </h4>Related to <a href="http://stackoverflow.com/questions/973473/getting-a-list-of-all-subdirectories-in-the-current-directory">How to get a list of subdirectories</a><hr><h3>  Answer by pycruft, Id: 3207973, Score: 6364, created_at: 2010-07-08 21:01:11+00:00 </h3><p><strong><a href="https://docs.python.org/3/library/os.html#os.listdir" rel="noreferrer" title="os.listdir"><code>os.listdir()</code></a></strong> returns everything inside a directory -- including both <strong>files</strong> and <strong>directories</strong>.</p>
<p><a href="https://docs.python.org/3/library/os.path.html#module-os.path" rel="noreferrer" title="os.path"><strong><code>os.path</code></strong></a>'s <code>isfile()</code> can be used to only list files:</p>
<pre><code>from os import listdir
from os.path import isfile, join
onlyfiles = [f for f in listdir(mypath) if isfile(join(mypath, f))]
</code></pre>
<p>Alternatively, <strong><a href="https://docs.python.org/3/library/os.html#os.walk" rel="noreferrer" title="os.walk"><code>os.walk()</code></a></strong> <strong>yields two lists</strong> for each directory it visits -- one for <strong>files</strong> and one for <strong>dirs</strong>. If you only want the top directory you can break the first time it yields:</p>
<pre><code>from os import walk

f = []
for (dirpath, dirnames, filenames) in walk(mypath):
    f.extend(filenames)
    break
</code></pre>
<p>or, shorter:</p>
<pre class="lang-py prettyprint-override"><code>from os import walk

filenames = next(walk(mypath), (None, None, []))[2]  # [] if no file
</code></pre>
<h4> Comment by Nir, Score: 17, Id: 128971338, created_at: 2022-07-18 12:39:37+00:00 </h4>To get all the full paths of the files in the sub-folders, recursively: <code>[os.path.join(dirpath,f) for (dirpath, dirnames, filenames) in os.walk(mypath) for f in filenames] </code><h4> Comment by OrOrg, Score: 3, Id: 131820040, created_at: 2022-12-05 09:33:00+00:00 </h4>@Jo&#227;o V&#237;ctor Melo <code>os.walk()</code> recursively visits all subdirectories, their subdirectories, and so on. By breaking, we only visit the first directory <code>mypath</code>.<h4> Comment by Jo&#227;o V&#237;ctor Melo, Score: 0, Id: 129754186, created_at: 2022-08-24 15:36:30+00:00 </h4>Why the need of the break?<hr><h3>  Answer by adamk, Id: 3215392, Score: 2545, created_at: 2010-07-09 18:13:37+00:00 </h3><p>I prefer using the <a href="https://docs.python.org/library/glob.html" rel="noreferrer"><code>glob</code></a> module, as it does pattern matching and expansion.</p>
<pre><code>import glob
print(glob.glob(&quot;/home/adam/*&quot;))
</code></pre>
<p>It does pattern matching intuitively</p>
<pre><code>import glob
# All files and directories ending with .txt and that don't begin with a dot:
print(glob.glob(&quot;/home/adam/*.txt&quot;)) 
# All files and directories ending with .txt with depth of 2 folders, ignoring names beginning with a dot:
print(glob.glob(&quot;/home/adam/*/*.txt&quot;)) 
</code></pre>
<p>It will return a list with the queried files and directories:</p>
<pre><code>['/home/adam/file1.txt', '/home/adam/file2.txt', .... ]
</code></pre>
<p>Note that <code>glob</code> ignores files and directories that begin with a dot <code>.</code>, as those are considered hidden files and directories, unless the pattern is something like <code>.*</code>.</p>
<p>Use <a href="https://docs.python.org/3/library/glob.html#glob.escape" rel="noreferrer"><code>glob.escape</code></a> to escape strings that are not meant to be patterns:</p>
<pre><code>print(glob.glob(glob.escape(directory_name) + &quot;/*.txt&quot;))
</code></pre>
<h4> Comment by Cedric H., Score: 7, Id: 131326064, created_at: 2022-11-10 14:18:32+00:00 </h4><code>from glob import glob as g</code> replaces <code>glob()</code> by <code>g()</code>.<h4> Comment by mcp, Score: 3, Id: 130997046, created_at: 2022-10-25 14:03:08+00:00 </h4><code>from glob import glob</code> replaces <code>glob.glob()</code> with <code>glob()</code>.<hr><h3>  Answer by PythonProgrammi, Id: 41447012, Score: 1560, created_at: 2017-01-03 15:36:12+00:00 </h3><p>list in the current directory</p>
<p>With <code>listdir</code> in <code>os</code> module you get the files and the folders in the current dir</p>
<pre><code>import os

arr = os.listdir()
</code></pre>
<p>Looking in a directory</p>
<pre><code>arr = os.listdir('c:\\files')
</code></pre>
<p>with <code>glob</code> you can specify a type of file to list like this</p>
<pre><code>import glob

txtfiles = []
for file in glob.glob(&quot;*.txt&quot;):
    txtfiles.append(file)
</code></pre>
<p>or</p>
<pre><code>mylist = [f for f in glob.glob(&quot;*.txt&quot;)]
</code></pre>
<p>get the full path of only files in the current directory</p>
<pre><code>import os
from os import listdir
from os.path import isfile, join

cwd = os.getcwd()
onlyfiles = [os.path.join(cwd, f) for f in os.listdir(cwd) if 
os.path.isfile(os.path.join(cwd, f))]
print(onlyfiles) 

['G:\\getfilesname\\getfilesname.py', 'G:\\getfilesname\\example.txt']
</code></pre>
<p>Getting the full path name with <code>os.path.abspath</code></p>
<p>You get the full path in return</p>
<pre><code> import os
 files_path = [os.path.abspath(x) for x in os.listdir()]
 print(files_path)
 
 ['F:\\documenti\applications.txt', 'F:\\documenti\collections.txt']
</code></pre>
<p>Walk: going through sub directories</p>
<p>os.walk returns the root, the directories list and the files list, that is why I unpacked them in r, d, f in the for loop; it, then, looks for other files and directories in the subfolders of the root and so on until there are no subfolders.</p>
<pre><code>import os

# Getting the current work directory (cwd)
thisdir = os.getcwd()

# r=root, d=directories, f = files
for r, d, f in os.walk(thisdir):
    for file in f:
        if file.endswith(&quot;.docx&quot;):
            print(os.path.join(r, file))
</code></pre>
<p>To go up in the directory tree</p>
<pre><code># Method 1
x = os.listdir('..')

# Method 2
x= os.listdir('/')
</code></pre>
<p>Get files of a particular subdirectory with <code>os.listdir()</code></p>
<pre><code>import os

x = os.listdir(&quot;./content&quot;)
</code></pre>
<p>os.walk('.') - current directory</p>
<pre><code> import os
 arr = next(os.walk('.'))[2]
 print(arr)
 
 &gt;&gt;&gt; ['5bs_Turismo1.pdf', '5bs_Turismo1.pptx', 'esperienza.txt']
</code></pre>
<p>next(os.walk('.')) and os.path.join('dir', 'file')</p>
<pre><code> import os
 arr = []
 for d,r,f in next(os.walk(&quot;F:\\_python&quot;)):
     for file in f:
         arr.append(os.path.join(r,file))

 for f in arr:
     print(files)

&gt;&gt;&gt; F:\\_python\\dict_class.py
&gt;&gt;&gt; F:\\_python\\programmi.txt
</code></pre>
<p>next... walk</p>
<pre><code> [os.path.join(r,file) for r,d,f in next(os.walk(&quot;F:\\_python&quot;)) for file in f]
 
 &gt;&gt;&gt; ['F:\\_python\\dict_class.py', 'F:\\_python\\programmi.txt']
</code></pre>
<p>os.walk</p>
<pre><code>x = [os.path.join(r,file) for r,d,f in os.walk(&quot;F:\\_python&quot;) for file in f]
print(x)

&gt;&gt;&gt; ['F:\\_python\\dict.py', 'F:\\_python\\progr.txt', 'F:\\_python\\readl.py']
</code></pre>
<p>os.listdir() - get only txt files</p>
<pre><code> arr_txt = [x for x in os.listdir() if x.endswith(&quot;.txt&quot;)]
 
</code></pre>
<p>Using <code>glob</code> to get the full path of the files</p>
<pre><code>from path import path
from glob import glob

x = [path(f).abspath() for f in glob(&quot;F:\\*.txt&quot;)]
</code></pre>
<p>Using <code>os.path.isfile</code> to avoid directories in the list</p>
<pre><code>import os.path
listOfFiles = [f for f in os.listdir() if os.path.isfile(f)]
</code></pre>
<p>Using <code>pathlib</code> from Python 3.4</p>
<pre><code>import pathlib

flist = []
for p in pathlib.Path('.').iterdir():
    if p.is_file():
        print(p)
        flist.append(p)
</code></pre>
<p>With <code>list comprehension</code>:</p>
<pre><code>flist = [p for p in pathlib.Path('.').iterdir() if p.is_file()]
</code></pre>
<p>Use glob method in pathlib.Path()</p>
<pre><code>import pathlib

py = pathlib.Path().glob(&quot;*.py&quot;)
</code></pre>
<p>Get all and only files with os.walk: checks only in the third element returned, i.e. the list of the files</p>
<pre><code>import os
x = [i[2] for i in os.walk('.')]
y=[]
for t in x:
    for f in t:
        y.append(f)
</code></pre>
<p>Get only files with next in a directory: returns only the file in the root folder</p>
<pre><code> import os
 x = next(os.walk('F://python'))[2]
</code></pre>
<p>Get only directories with next and walk in a directory, because in the [1] element there are the folders only</p>
<pre><code> import os
 next(os.walk('F://python'))[1] # for the current dir use ('.')
 
 &gt;&gt;&gt; ['python3','others']
</code></pre>
<p>Get all the <code>subdir</code> names with <code>walk</code></p>
<pre><code>for r,d,f in os.walk(&quot;F:\\_python&quot;):
    for dirs in d:
        print(dirs)
</code></pre>
<p><code>os.scandir()</code> from Python 3.5 and greater</p>
<pre><code>import os
x = [f.name for f in os.scandir() if f.is_file()]

# Another example with `scandir` (a little variation from docs.python.org)
# This one is more efficient than `os.listdir`.
# In this case, it shows the files only in the current directory
# where the script is executed.

import os
with os.scandir() as i:
    for entry in i:
        if entry.is_file():
            print(entry.name)
</code></pre>
<hr><h3>  Answer by sepp2k, Id: 3207254, Score: 990, created_at: 2010-07-08 19:35:33+00:00 </h3><pre><code>import os
os.listdir("somedirectory")
</code></pre>

<p>will return a list of all files and directories in "somedirectory".</p>
<h4> Comment by russhoppa, Score: 0, Id: 136368268, created_at: 2023-10-24 14:57:56+00:00 </h4>Why isn&#39;t this number one? Are there any drawbacks to this method? Seems by far the most simple.<h4> Comment by CoffeeSyntax, Score: 0, Id: 137110464, created_at: 2024-01-07 09:43:13+00:00 </h4>it lists both directories and files.<hr><h3>  Answer by Remi, Id: 21207590, Score: 194, created_at: 2014-01-18 17:42:29+00:00 </h3><p>A one-line solution to get <strong>only list of files</strong> (no subdirectories):</p>

<pre class="lang-py prettyprint-override"><code>filenames = next(os.walk(path))[2]
</code></pre>

<p>or absolute pathnames:</p>

<pre class="lang-py prettyprint-override"><code>paths = [os.path.join(path, fn) for fn in next(os.walk(path))[2]]
</code></pre>
<hr><h3>  Answer by Johnny, Id: 19308592, Score: 162, created_at: 2013-10-11 00:55:16+00:00 </h3><p><strong>Getting Full File Paths From a Directory and All Its Subdirectories</strong></p>

<pre><code>import os

def get_filepaths(directory):
    """
    This function will generate the file names in a directory 
    tree by walking the tree either top-down or bottom-up. For each 
    directory in the tree rooted at directory top (including top itself), 
    it yields a 3-tuple (dirpath, dirnames, filenames).
    """
    file_paths = []  # List which will store all of the full filepaths.

    # Walk the tree.
    for root, directories, files in os.walk(directory):
        for filename in files:
            # Join the two strings in order to form the full filepath.
            filepath = os.path.join(root, filename)
            file_paths.append(filepath)  # Add it to the list.

    return file_paths  # Self-explanatory.

# Run the above function and store its results in a variable.   
full_file_paths = get_filepaths("/Users/johnny/Desktop/TEST")
</code></pre>

<hr>

<ul>
<li>The path I provided in the above function contained 3 files— two of them in the root directory, and another in a subfolder called "SUBFOLDER."  You can now do things like:</li>
<li><p><code>print full_file_paths</code> which will print the list:</p>

<ul>
<li><code>['/Users/johnny/Desktop/TEST/file1.txt', '/Users/johnny/Desktop/TEST/file2.txt', '/Users/johnny/Desktop/TEST/SUBFOLDER/file3.dat']</code></li>
</ul></li>
</ul>

<p>If you'd like, you can open and read the contents, or focus only on files with the extension ".dat" like in the code below:</p>

<pre><code>for f in full_file_paths:
  if f.endswith(".dat"):
    print f
</code></pre>

<p><code>/Users/johnny/Desktop/TEST/SUBFOLDER/file3.dat</code></p>
<hr><h3>  Answer by SZIEBERTH &#193;d&#225;m, Id: 30925692, Score: 116, created_at: 2015-06-18 20:58:21+00:00 </h3><p>Since version 3.4 there are builtin <em>iterators</em> for this which are a lot more efficient than <a href="http://docs.python.org/3/library/os.html#os.listdir" rel="noreferrer"><code>os.listdir()</code></a>:</p>

<p><a href="http://docs.python.org/3/library/pathlib.html" rel="noreferrer"><code>pathlib</code></a>: <em>New in version 3.4.</em></p>

<pre><code>&gt;&gt;&gt; import pathlib
&gt;&gt;&gt; [p for p in pathlib.Path('.').iterdir() if p.is_file()]
</code></pre>

<p>According to <a href="http://www.python.org/dev/peps/pep-0428/" rel="noreferrer">PEP 428</a>, the aim of the <a href="http://docs.python.org/3/library/pathlib.html" rel="noreferrer"><code>pathlib</code></a> library is to provide a simple hierarchy of classes to handle filesystem paths and the common operations users do over them.</p>

<p><a href="http://docs.python.org/3/library/os.html#os.scandir" rel="noreferrer"><code>os.scandir()</code></a>: <em>New in version 3.5.</em></p>

<pre><code>&gt;&gt;&gt; import os
&gt;&gt;&gt; [entry for entry in os.scandir('.') if entry.is_file()]
</code></pre>

<p>Note that <a href="http://docs.python.org/3/library/os.html#os.walk" rel="noreferrer"><code>os.walk()</code></a> uses <a href="http://docs.python.org/3/library/os.html#os.scandir" rel="noreferrer"><code>os.scandir()</code></a> instead of <a href="http://docs.python.org/3/library/os.html#os.listdir" rel="noreferrer"><code>os.listdir()</code></a> from version 3.5, and its speed got increased by 2-20 times according to <a href="http://www.python.org/dev/peps/pep-0471/" rel="noreferrer">PEP 471</a>.</p>

<p>Let me also recommend reading ShadowRanger's comment below.</p>
<h4> Comment by ShadowRanger, Score: 10, Id: 55439897, created_at: 2015-11-20 22:38:37+00:00 </h4>Note: The <code>os.scandir</code> solution is going to be more efficient than <code>os.listdir</code> with an <code>os.path.is_file</code> check or the like, even if you need a <code>list</code> (so you don&#39;t benefit from lazy iteration), because <code>os.scandir</code> uses OS provided APIs that give you the <code>is_file</code> information for free as it iterates, no per-file round trip to the disk to <code>stat</code> them at all (on Windows, the <code>DirEntry</code>s get you complete <code>stat</code> info for free, on *NIX systems it needs to <code>stat</code> for info beyond <code>is_file</code>, <code>is_dir</code>, etc., but <code>DirEntry</code> caches on first <code>stat</code> for convenience).<hr><h3>  Answer by CristiFati, Id: 48393588, Score: 75, created_at: 2018-01-23 03:09:57+00:00 </h3><h2>Preliminary notes</h2>
<ul>
<li><p>Although there's a clear differentiation between <em>file</em> and <em>directory</em> terms in the question text, some may argue that directories are actually special files</p>
</li>
<li><p>The statement: &quot;<em>all files of a directory</em>&quot; can be interpreted in two ways:</p>
<ol>
<li><p>All <strong>direct</strong> (or level 1) descendants <strong>only</strong></p>
</li>
<li><p>All descendants in the whole directory tree (including the ones in sub-directories)</p>
</li>
</ol>
</li>
<li><p>When the question was asked, I imagine that <em>Python <strong>2</strong></em>, was the <em>LTS</em> version, however the code samples will be run by <em>Python <strong>3</strong>(<strong>.5</strong>)</em> (I'll keep them as <em>Python 2</em> compliant as possible; also, any code belonging to <em>Python</em> that I'm going to post, is from <em><strong>v3.5.4</strong></em> - unless otherwise specified).<br>
That has consequences related to another keyword in the question: &quot;<em>add them into a <strong>list</strong></em>&quot;:</p>
<ul>
<li><p>In pre <em>Python 2.2</em> versions, sequences (iterables) were mostly represented by lists (tuples, sets, ...)</p>
</li>
<li><p>In <em>Python 2.2</em>, the concept of <strong>generator</strong> (<a href="https://wiki.python.org/moin/Generators" rel="noreferrer">[Python.Wiki]: Generators</a>) - courtesy of <a href="https://docs.python.org/reference/simple_stmts.html#the-yield-statement" rel="noreferrer">[Python.Docs]: Simple statements - The yield statement</a>) - was introduced. As time passed, generator counterparts started to appear for functions that returned / worked with lists</p>
</li>
<li><p>In <em>Python 3</em>, generator is the default behavior</p>
</li>
<li><p>Not sure if returning a list is still mandatory (or a generator would do as well), but passing a generator to the <em>list</em> constructor, will create a list out of it (and also consume it). The example below illustrates the differences on <a href="https://docs.python.org/library/functions.html#map" rel="noreferrer">[Python.Docs]: Built-in functions - map(function, iterable, *iterables)</a></p>
</li>
</ul>
<blockquote>
<pre class="lang-py prettyprint-override"><code>&gt;&gt;&gt; import sys
&gt;&gt;&gt;
&gt;&gt;&gt; sys.version
'2.7.10 (default, Mar  8 2016, 15:02:46) [MSC v.1600 64 bit (AMD64)]'
&gt;&gt;&gt; m = map(lambda x: x, [1, 2, 3])  # Just a dummy lambda function
&gt;&gt;&gt; m, type(m)
([1, 2, 3], &lt;type 'list'&gt;)
&gt;&gt;&gt; len(m)
3
</code></pre>
</blockquote>
  <br>
<blockquote>
<pre class="lang-py prettyprint-override"><code>&gt;&gt;&gt; import sys
&gt;&gt;&gt;
&gt;&gt;&gt; sys.version
'3.5.4 (v3.5.4:3f56838, Aug  8 2017, 02:17:05) [MSC v.1900 64 bit (AMD64)]'
&gt;&gt;&gt; m = map(lambda x: x, [1, 2, 3])
&gt;&gt;&gt; m, type(m)
(&lt;map object at 0x000001B4257342B0&gt;, &lt;class 'map'&gt;)
&gt;&gt;&gt; len(m)
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
TypeError: object of type 'map' has no len()
&gt;&gt;&gt; lm0 = list(m)  # Build a list from the generator
&gt;&gt;&gt; lm0, type(lm0)
([1, 2, 3], &lt;class 'list'&gt;)
&gt;&gt;&gt;
&gt;&gt;&gt; lm1 = list(m)  # Build a list from the same generator
&gt;&gt;&gt; lm1, type(lm1)  # Empty list now - generator already exhausted
([], &lt;class 'list'&gt;)
</code></pre>
</blockquote>
</li>
<li><p>The examples will be based on a directory called <em>root_dir</em> with the following structure (this example is for <em>Win</em>, but I'm using the same tree on <em>Nix</em> as well). Note that I'll be reusing the console:</p>
<blockquote>
<pre class="lang-bat prettyprint-override"><code>[cfati@CFATI-5510-0:e:\Work\Dev\StackOverflow\q003207219]&gt; sopr.bat
### Set shorter prompt to better fit when pasted in StackOverflow (or other) pages ###

[prompt]&gt; 
[prompt]&gt; tree /f &quot;root_dir&quot;
Folder PATH listing for volume Work
Volume serial number is 00000029 3655:6FED
E:\WORK\DEV\STACKOVERFLOW\Q003207219\ROOT_DIR
¦   file0
¦   file1
¦
+---dir0
¦   +---dir00
¦   ¦   ¦   file000
¦   ¦   ¦
¦   ¦   +---dir000
¦   ¦           file0000
¦   ¦
¦   +---dir01
¦   ¦       file010
¦   ¦       file011
¦   ¦
¦   +---dir02
¦       +---dir020
¦           +---dir0200
+---dir1
¦       file10
¦       file11
¦       file12
¦
+---dir2
¦   ¦   file20
¦   ¦
¦   +---dir20
¦           file200
¦
+---dir3
</code></pre>
</blockquote>
</li>
</ul>
<br>
<h2>Solutions</h2>
<h3>Programmatic approaches</h3>
<h4>1. <a href="https://docs.python.org/library/os.html#os.listdir" rel="noreferrer">[Python.Docs]: os.listdir(path='.')</a></h4>
<blockquote>
<p>Return a list containing the names of the entries in the directory given by <em>path</em>. The list is in arbitrary order, and does not include the special entries <code>'.'</code> and <code>'..'</code> ...</p>
</blockquote>
<br>
<blockquote>
<pre class="lang-py prettyprint-override"><code>&gt;&gt;&gt; import os
&gt;&gt;&gt;
&gt;&gt;&gt; root_dir = &quot;root_dir&quot;  # Path relative to current dir (os.getcwd())
&gt;&gt;&gt;
&gt;&gt;&gt; os.listdir(root_dir)  # List all the items in root_dir
['dir0', 'dir1', 'dir2', 'dir3', 'file0', 'file1']
&gt;&gt;&gt;
&gt;&gt;&gt; [item for item in os.listdir(root_dir) if os.path.isfile(os.path.join(root_dir, item))]  # Filter items and only keep files (strip out directories)
['file0', 'file1']
</code></pre>
</blockquote>
<p>A more elaborate example (<em>code_os_listdir.py</em>):</p>
<pre class="lang-py prettyprint-override"><code>#!/usr/bin/env python

import os
import sys
from pprint import pformat as pf


def _get_dir_content(path, include_folders, recursive):
    entries = os.listdir(path)
    for entry in entries:
        entry_with_path = os.path.join(path, entry)
        if os.path.isdir(entry_with_path):
            if include_folders:
                yield entry_with_path
            if recursive:
                for sub_entry in _get_dir_content(entry_with_path, include_folders, recursive):
                    yield sub_entry
        else:
            yield entry_with_path


def get_dir_content(path, include_folders=True, recursive=True, prepend_folder_name=True):
    path_len = len(path) + len(os.path.sep)
    for item in _get_dir_content(path, include_folders, recursive):
        yield item if prepend_folder_name else item[path_len:]


def _get_dir_content_old(path, include_folders, recursive):
    entries = os.listdir(path)
    ret = list()
    for entry in entries:
        entry_with_path = os.path.join(path, entry)
        if os.path.isdir(entry_with_path):
            if include_folders:
                ret.append(entry_with_path)
            if recursive:
                ret.extend(_get_dir_content_old(entry_with_path, include_folders, recursive))
        else:
            ret.append(entry_with_path)
    return ret


def get_dir_content_old(path, include_folders=True, recursive=True, prepend_folder_name=True):
    path_len = len(path) + len(os.path.sep)
    return [item if prepend_folder_name else item[path_len:] for item in _get_dir_content_old(path, include_folders, recursive)]


def main(*argv):
    root_dir = &quot;root_dir&quot;
    ret0 = get_dir_content(root_dir, include_folders=True, recursive=True, prepend_folder_name=True)
    lret0 = list(ret0)
    print(&quot;{:} {:d}\n{:s}&quot;.format(ret0, len(lret0), pf(lret0)))
    ret1 = get_dir_content_old(root_dir, include_folders=False, recursive=True, prepend_folder_name=False)
    print(&quot;\n{:d}\n{:s}&quot;.format(len(ret1), pf(ret1)))


if __name__ == &quot;__main__&quot;:
    print(&quot;Python {:s} {:03d}bit on {:s}\n&quot;.format(&quot; &quot;.join(elem.strip() for elem in sys.version.split(&quot;\n&quot;)),
                                                   64 if sys.maxsize &gt; 0x100000000 else 32, sys.platform))
    rc = main(*sys.argv[1:])
    print(&quot;\nDone.\n&quot;)
    sys.exit(rc)
</code></pre>
<p><strong>Notes</strong>:</p>
<ul>
<li><p>There are two implementations:</p>
<ol>
<li><p>One that uses generators (of course here it seems useless, since I immediately convert the result to a list)</p>
</li>
<li><p>The classic one (function names ending in <strong>_old</strong>)</p>
</li>
</ol>
</li>
<li><p>Recursion is used (to get into subdirectories)</p>
</li>
<li><p>For each implementation there are two functions:</p>
<ul>
<li><p>One that starts with an <em>underscore</em> (<strong>_</strong>): &quot;private&quot; (should not be called directly) - that does all the work</p>
</li>
<li><p>The public one (wrapper over previous): it just strips off the initial path (if required) from the returned entries. It's an ugly implementation, but it's the only idea that I could come with at this point</p>
</li>
</ul>
</li>
<li><p>In terms of performance, generators are generally a little bit faster (considering both <em>creation</em> and  <em>iteration</em> times), but I didn't test them in recursive functions, and also I am iterating inside the function over inner generators - don't know how performance friendly is that</p>
</li>
<li><p>Play with the arguments to get different results</p>
</li>
</ul>
<p><strong>Output</strong>:</p>
<blockquote>
<pre><code>[prompt]&gt; &quot;e:\Work\Dev\VEnvs\py_pc064_03.05.04_test0\Scripts\python.exe&quot; &quot;.\code_os_listdir.py&quot;
Python 3.5.4 (v3.5.4:3f56838, Aug  8 2017, 02:17:05) [MSC v.1900 64 bit (AMD64)] 064bit on win32

&lt;generator object get_dir_content at 0x000002C080418F68&gt; 22
['root_dir\\dir0',
 'root_dir\\dir0\\dir00',
 'root_dir\\dir0\\dir00\\dir000',
 'root_dir\\dir0\\dir00\\dir000\\file0000',
 'root_dir\\dir0\\dir00\\file000',
 'root_dir\\dir0\\dir01',
 'root_dir\\dir0\\dir01\\file010',
 'root_dir\\dir0\\dir01\\file011',
 'root_dir\\dir0\\dir02',
 'root_dir\\dir0\\dir02\\dir020',
 'root_dir\\dir0\\dir02\\dir020\\dir0200',
 'root_dir\\dir1',
 'root_dir\\dir1\\file10',
 'root_dir\\dir1\\file11',
 'root_dir\\dir1\\file12',
 'root_dir\\dir2',
 'root_dir\\dir2\\dir20',
 'root_dir\\dir2\\dir20\\file200',
 'root_dir\\dir2\\file20',
 'root_dir\\dir3',
 'root_dir\\file0',
 'root_dir\\file1']

11
['dir0\\dir00\\dir000\\file0000',
 'dir0\\dir00\\file000',
 'dir0\\dir01\\file010',
 'dir0\\dir01\\file011',
 'dir1\\file10',
 'dir1\\file11',
 'dir1\\file12',
 'dir2\\dir20\\file200',
 'dir2\\file20',
 'file0',
 'file1']

Done.
</code></pre>
</blockquote>
<h4>2. <a href="https://docs.python.org/library/os.html#os.scandir" rel="noreferrer">[Python.Docs]: os.scandir(path='.')</a></h4>
<p>In <em>Python <strong>3.5+</strong></em> only, backport: <a href="https://pypi.org/project/scandir" rel="noreferrer">[PyPI]: scandir</a>:</p>
<blockquote>
<p>Return an iterator of <a href="https://docs.python.org/library/os.html#os.DirEntry" rel="noreferrer">os.DirEntry</a> objects corresponding to the entries in the directory given by <em>path</em>. The entries are yielded in arbitrary order, and the special entries <code>'.'</code> and <code>'..'</code> are not included.</p>
<p>Using <a href="https://docs.python.org/library/os.html#os.scandir" rel="noreferrer">scandir()</a> instead of <a href="https://docs.python.org/library/os.html#os.listdir" rel="noreferrer">listdir()</a> can significantly increase the performance of code that also needs file type or file attribute information, because <a href="https://docs.python.org/library/os.html#os.DirEntry" rel="noreferrer">os.DirEntry</a> objects expose this information if the operating system provides it when scanning a directory. All <a href="https://docs.python.org/library/os.html#os.DirEntry" rel="noreferrer">os.DirEntry</a> methods may perform a system call, but <a href="https://docs.python.org/library/os.html#os.DirEntry.is_dir" rel="noreferrer">is_dir()</a> and <a href="https://docs.python.org/library/os.html#os.DirEntry.is_file" rel="noreferrer">is_file()</a> usually only require a system call for symbolic links; <a href="https://docs.python.org/library/os.html#os.DirEntry.stat" rel="noreferrer">os.DirEntry.stat()</a> always requires a system call on Unix but only requires one for symbolic links on Windows.</p>
</blockquote>
<br>
<blockquote>
<pre class="lang-py prettyprint-override"><code>&gt;&gt;&gt; import os
&gt;&gt;&gt;
&gt;&gt;&gt; root_dir = os.path.join(&quot;.&quot;, &quot;root_dir&quot;)  # Explicitly prepending current directory
&gt;&gt;&gt; root_dir
'.\\root_dir'
&gt;&gt;&gt;
&gt;&gt;&gt; scandir_iterator = os.scandir(root_dir)
&gt;&gt;&gt; scandir_iterator
&lt;nt.ScandirIterator object at 0x00000268CF4BC140&gt;
&gt;&gt;&gt; [item.path for item in scandir_iterator]
['.\\root_dir\\dir0', '.\\root_dir\\dir1', '.\\root_dir\\dir2', '.\\root_dir\\dir3', '.\\root_dir\\file0', '.\\root_dir\\file1']
&gt;&gt;&gt;
&gt;&gt;&gt; [item.path for item in scandir_iterator]  # Will yield an empty list as it was consumed by previous iteration (automatically performed by the list comprehension)
[]
&gt;&gt;&gt;
&gt;&gt;&gt; scandir_iterator = os.scandir(root_dir)  # Reinitialize the generator
&gt;&gt;&gt; for item in scandir_iterator :
...     if os.path.isfile(item.path):
...             print(item.name)
...
file0
file1
</code></pre>
</blockquote>
<p><strong>Notes</strong>:</p>
<ul>
<li><p>Similar to <em>os.listdir</em></p>
</li>
<li><p>But it's also more flexible (and offers more functionality), more <em>Python</em>ic (and in some cases, faster)</p>
</li>
</ul>
<h4>3. <a href="https://docs.python.org/library/os.html#os.walk" rel="noreferrer">[Python.Docs]: os.walk(top, topdown=True, onerror=None, followlinks=False)</a></h4>
<blockquote>
<p>Generate the file names in a directory tree by walking the tree either top-down or bottom-up. For each directory in the tree rooted at directory <em>top</em> (including <em>top</em> itself), it yields a 3-tuple (<code>dirpath</code>, <code>dirnames</code>, <code>filenames</code>).</p>
</blockquote>
<br>
<blockquote>
<pre class="lang-py prettyprint-override"><code>&gt;&gt;&gt; import os
&gt;&gt;&gt;
&gt;&gt;&gt; root_dir = os.path.join(os.getcwd(), &quot;root_dir&quot;)  # Specify the full path
&gt;&gt;&gt; root_dir
'E:\\Work\\Dev\\StackOverflow\\q003207219\\root_dir'
&gt;&gt;&gt;
&gt;&gt;&gt; walk_generator = os.walk(root_dir)
&gt;&gt;&gt; root_dir_entry = next(walk_generator)  # First entry corresponds to the root dir (passed as an argument)
&gt;&gt;&gt; root_dir_entry
('E:\\Work\\Dev\\StackOverflow\\q003207219\\root_dir', ['dir0', 'dir1', 'dir2', 'dir3'], ['file0', 'file1'])
&gt;&gt;&gt;
&gt;&gt;&gt; root_dir_entry[1] + root_dir_entry[2]  # Display dirs and files (direct descendants) in a single list
['dir0', 'dir1', 'dir2', 'dir3', 'file0', 'file1']
&gt;&gt;&gt;
&gt;&gt;&gt; [os.path.join(root_dir_entry[0], item) for item in root_dir_entry[1] + root_dir_entry[2]]  # Display all the entries in the previous list by their full path
['E:\\Work\\Dev\\StackOverflow\\q003207219\\root_dir\\dir0', 'E:\\Work\\Dev\\StackOverflow\\q003207219\\root_dir\\dir1', 'E:\\Work\\Dev\\StackOverflow\\q003207219\\root_dir\\dir2', 'E:\\Work\\Dev\\StackOverflow\\q003207219\\root_dir\\dir3', 'E:\\Work\\Dev\\StackOverflow\\q003207219\\root_dir\\file0', 'E:\\Work\\Dev\\StackOverflow\\q003207219\\root_dir\\file1']
&gt;&gt;&gt;
&gt;&gt;&gt; for entry in walk_generator:  # Display the rest of the elements (corresponding to every subdir)
...     print(entry)
...
('E:\\Work\\Dev\\StackOverflow\\q003207219\\root_dir\\dir0', ['dir00', 'dir01', 'dir02'], [])
('E:\\Work\\Dev\\StackOverflow\\q003207219\\root_dir\\dir0\\dir00', ['dir000'], ['file000'])
('E:\\Work\\Dev\\StackOverflow\\q003207219\\root_dir\\dir0\\dir00\\dir000', [], ['file0000'])
('E:\\Work\\Dev\\StackOverflow\\q003207219\\root_dir\\dir0\\dir01', [], ['file010', 'file011'])
('E:\\Work\\Dev\\StackOverflow\\q003207219\\root_dir\\dir0\\dir02', ['dir020'], [])
('E:\\Work\\Dev\\StackOverflow\\q003207219\\root_dir\\dir0\\dir02\\dir020', ['dir0200'], [])
('E:\\Work\\Dev\\StackOverflow\\q003207219\\root_dir\\dir0\\dir02\\dir020\\dir0200', [], [])
('E:\\Work\\Dev\\StackOverflow\\q003207219\\root_dir\\dir1', [], ['file10', 'file11', 'file12'])
('E:\\Work\\Dev\\StackOverflow\\q003207219\\root_dir\\dir2', ['dir20'], ['file20'])
('E:\\Work\\Dev\\StackOverflow\\q003207219\\root_dir\\dir2\\dir20', [], ['file200'])
('E:\\Work\\Dev\\StackOverflow\\q003207219\\root_dir\\dir3', [], [])
</code></pre>
</blockquote>
<p><strong>Notes</strong>:</p>
<ul>
<li><p>Under the scenes, it uses <em>os.scandir</em> (<em>os.listdir</em> on older (<em>Python</em>) versions)</p>
</li>
<li><p>It does the heavy lifting by recurring in subfolders</p>
</li>
</ul>
<h4>4. <a href="https://docs.python.org/library/glob.html#glob.glob" rel="noreferrer">[Python.Docs]: glob.glob(pathname, *, root_dir=None, dir_fd=None, recursive=False, include_hidden=False)</a></h4>
<p>Or <em>glob.<strong>i</strong>glob</em>:</p>
<blockquote>
<p>Return a possibly-empty list of path names that match <em>pathname</em>, which must be a string containing a path specification. <em>pathname</em> can be either absolute (like <code>/usr/src/Python-1.5/Makefile</code>) or relative (like <code>../../Tools/*/*.gif</code>), and can contain shell-style wildcards. Broken symlinks are included in the results (as in the shell).<br>...<br><strong><em>Changed in version 3.5</em></strong>: Support for recursive globs using “<code>**</code>”.</p>
</blockquote>
<br>
<blockquote>
<pre class="lang-py prettyprint-override"><code>&gt;&gt;&gt; import glob, os
&gt;&gt;&gt;
&gt;&gt;&gt; wildcard_pattern = &quot;*&quot;
&gt;&gt;&gt; root_dir = os.path.join(&quot;root_dir&quot;, wildcard_pattern)  # Match every file/dir name
&gt;&gt;&gt; root_dir
'root_dir\\*'
&gt;&gt;&gt;
&gt;&gt;&gt; glob_list = glob.glob(root_dir)
&gt;&gt;&gt; glob_list
['root_dir\\dir0', 'root_dir\\dir1', 'root_dir\\dir2', 'root_dir\\dir3', 'root_dir\\file0', 'root_dir\\file1']
&gt;&gt;&gt;
&gt;&gt;&gt; [item.replace(&quot;root_dir&quot; + os.path.sep, &quot;&quot;) for item in glob_list]  # Strip the dir name and the path separator from begining
['dir0', 'dir1', 'dir2', 'dir3', 'file0', 'file1']
&gt;&gt;&gt;
&gt;&gt;&gt; for entry in glob.iglob(root_dir + &quot;*&quot;, recursive=True):
...     print(entry)
...
root_dir\
root_dir\dir0
root_dir\dir0\dir00
root_dir\dir0\dir00\dir000
root_dir\dir0\dir00\dir000\file0000
root_dir\dir0\dir00\file000
root_dir\dir0\dir01
root_dir\dir0\dir01\file010
root_dir\dir0\dir01\file011
root_dir\dir0\dir02
root_dir\dir0\dir02\dir020
root_dir\dir0\dir02\dir020\dir0200
root_dir\dir1
root_dir\dir1\file10
root_dir\dir1\file11
root_dir\dir1\file12
root_dir\dir2
root_dir\dir2\dir20
root_dir\dir2\dir20\file200
root_dir\dir2\file20
root_dir\dir3
root_dir\file0
root_dir\file1
</code></pre>
</blockquote>
<p><strong>Notes</strong>:</p>
<ul>
<li><p>Uses <em>os.listdir</em></p>
</li>
<li><p>For large trees (especially if <em>recursive</em> is on), <em>iglob</em> is preferred</p>
</li>
<li><p>Allows advanced filtering based on name (due to the wildcard)</p>
</li>
</ul>
<h4>5. <a href="https://docs.python.org/library/pathlib.html#pathlib.Path" rel="noreferrer">[Python.Docs]: class pathlib.Path(*pathsegments)</a></h4>
<p><em>Python <strong>3.4</strong></em>+, backport: <a href="https://pypi.org/project/pathlib2" rel="noreferrer">[PyPI]: pathlib2</a>.</p>
<blockquote>
<pre class="lang-py prettyprint-override"><code>&gt;&gt;&gt; import pathlib
&gt;&gt;&gt;
&gt;&gt;&gt; root_dir = &quot;root_dir&quot;
&gt;&gt;&gt; root_dir_instance = pathlib.Path(root_dir)
&gt;&gt;&gt; root_dir_instance
WindowsPath('root_dir')
&gt;&gt;&gt; root_dir_instance.name
'root_dir'
&gt;&gt;&gt; root_dir_instance.is_dir()
True
&gt;&gt;&gt;
&gt;&gt;&gt; [item.name for item in root_dir_instance.glob(&quot;*&quot;)]  # Wildcard searching for all direct descendants
['dir0', 'dir1', 'dir2', 'dir3', 'file0', 'file1']
&gt;&gt;&gt;
&gt;&gt;&gt; [os.path.join(item.parent.name, item.name) for item in root_dir_instance.glob(&quot;*&quot;) if not item.is_dir()]  # Display paths (including parent) for files only
['root_dir\\file0', 'root_dir\\file1']
</code></pre>
</blockquote>
<p><strong>Notes</strong>:</p>
<ul>
<li><p>This is <em>one</em> way of achieving our goal</p>
</li>
<li><p>It's the <em>OOP</em> style of handling paths</p>
</li>
<li><p>Offers lots of functionalities</p>
</li>
</ul>
<h4>6. <a href="https://docs.python.org/2/library/dircache.html#dircache.listdir" rel="noreferrer">[Python 2.Docs]: dircache.listdir(path)</a></h4>
<ul>
<li><p><em>Python <strong>2</strong></em> <strong>only</strong></p>
</li>
<li><p>But, according to <a href="https://github.com/python/cpython/blob/2.7/Lib/dircache.py" rel="noreferrer">[GitHub]: python/cpython - (2.7) cpython/Lib/dircache.py</a>, it's just a (thin) wrapper over <em>os.listdir</em> with caching</p>
</li>
</ul>
<br>
<blockquote>
<pre class="lang-py prettyprint-override"><code>def listdir(path):
    &quot;&quot;&quot;List directory contents, using cache.&quot;&quot;&quot;
    try:
        cached_mtime, list = cache[path]
        del cache[path]
    except KeyError:
        cached_mtime, list = -1, []
    mtime = os.stat(path).st_mtime
    if mtime != cached_mtime:
        list = os.listdir(path)
        list.sort()
    cache[path] = mtime, list
    return list
</code></pre>
</blockquote>
<h4>7. Native <em>OS</em> <em>API</em>s</h4>
<p><em>POSIX</em> specific:</p>
<ul>
<li><p><a href="http://man7.org/linux/man-pages/man3/opendir.3.html" rel="noreferrer">[Man7]: OPENDIR(3)</a></p>
</li>
<li><p><a href="http://man7.org/linux/man-pages/man3/readdir.3.html" rel="noreferrer">[Man7]: READDIR(3)</a></p>
</li>
<li><p><a href="http://man7.org/linux/man-pages/man3/closedir.3.html" rel="noreferrer">[Man7]: CLOSEDIR(3)</a></p>
</li>
</ul>
<p>Available via <a href="https://docs.python.org/library/ctypes.html#module-ctypes" rel="noreferrer">[Python.Docs]: ctypes - A foreign function library for Python</a>:</p>
<blockquote>
<p><a href="https://docs.python.org/library/ctypes.html#module-ctypes" rel="noreferrer">ctypes</a> is a foreign function library for Python. It provides C compatible data types, and allows calling functions in DLLs or shared libraries. It can be used to wrap these libraries in pure Python.</p>
</blockquote>
<p>Not directly related, but check <a href="https://stackoverflow.com/a/58611011/4788546">[SO]: C function called from Python via ctypes returns incorrect value (@CristiFati's answer)</a> out before working with <em>CTypes</em>.</p>
<p><em>code_ctypes.py</em>:</p>
<pre class="lang-py prettyprint-override"><code>#!/usr/bin/env python3

import ctypes as cts
import sys


DT_DIR = 4
DT_REG = 8


class NixDirent64(cts.Structure):
    _fields_ = (
        (&quot;d_ino&quot;, cts.c_ulonglong),
        (&quot;d_off&quot;, cts.c_longlong),
        (&quot;d_reclen&quot;, cts.c_ushort),
        (&quot;d_type&quot;, cts.c_ubyte),
        (&quot;d_name&quot;, cts.c_char * 256),
    )

NixDirent64Ptr = cts.POINTER(NixDirent64)


libc = this_process = cts.CDLL(None, use_errno=True)

opendir = libc.opendir
opendir.argtypes = (cts.c_char_p,)
opendir.restype = cts.c_void_p
readdir = libc.readdir
readdir.argtypes = (cts.c_void_p,)
readdir.restype = NixDirent64Ptr
closedir = libc.closedir
closedir.argtypes = (cts.c_void_p,)


def get_dir_content(path):
    ret = [path, [], []]
    pdir = opendir(cts.create_string_buffer(path.encode()))
    if not pdir:
        print(&quot;opendir returned NULL (errno: {:d})&quot;.format(cts.get_errno()))
        return ret
    cts.set_errno(0)
    while True:
        pdirent = readdir(pdir)
        if not pdirent:
            break
        dirent = pdirent.contents
        name = dirent.d_name.decode()
        if dirent.d_type &amp; DT_DIR:
            if name not in (&quot;.&quot;, &quot;..&quot;):
                ret[1].append(name)
        elif dirent.d_type &amp; DT_REG:
            ret[2].append(name)
    if cts.get_errno():
        print(&quot;readdir returned NULL (errno: {:d})&quot;.format(cts.get_errno()))
    closedir(pdir)
    return ret


def main(*argv):
    root_dir = &quot;root_dir&quot;
    entries = get_dir_content(root_dir)
    print(&quot;Entries:\n{:}&quot;.format(entries))


if __name__ == &quot;__main__&quot;:
    print(&quot;Python {:s} {:03d}bit on {:s}\n&quot;.format(&quot; &quot;.join(elem.strip() for elem in sys.version.split(&quot;\n&quot;)),
                                                   64 if sys.maxsize &gt; 0x100000000 else 32, sys.platform))
    rc = main(*sys.argv[1:])
    print(&quot;\nDone.\n&quot;)
    sys.exit(rc)
</code></pre>
<p><strong>Notes</strong>:</p>
<ul>
<li><p>It loads the three functions from <em>LibC</em> (<em>libc.so</em> - loaded in the current process) and calls them (for more details check <a href="https://stackoverflow.com/a/44661513/4788546">[SO]: How do I check whether a file exists without exceptions? (@CristiFati's answer)</a> - last notes from item <em><strong>#4.</strong></em>). That would place this approach very close to the <em>Python</em> / <em>C</em> edge</p>
</li>
<li><p><em>NixDirent64</em> is the <em>CTypes</em> representation of <em>struct dirent64</em> from <a href="http://man7.org/linux/man-pages/man0/dirent.h.0p.html" rel="noreferrer">[Man7]: dirent.h(0P)</a> (so are the <em>DT_</em> constants) from my <em>Ubuntu</em> <em>OS</em>. On other flavors / versions, the structure definition might differ, and if so, the <em>CTypes</em> alias should be updated, otherwise it will yield <em><strong>U</strong>ndefined <strong>B</strong>ehavior</em></p>
</li>
<li><p>It returns data in the <em>os.walk</em>'s format. I didn't bother to make it recursive, but starting from the existing code, that would be a fairly trivial task</p>
</li>
<li><p>Everything is doable on <em>Win</em> as well, the data (libraries, functions, structs, constants, ...) differ</p>
</li>
</ul>
<p><strong>Output</strong>:</p>
<blockquote>
<pre><code>[cfati@cfati-5510-0:/mnt/e/Work/Dev/StackOverflow/q003207219]&gt; python3.5 ./code_ctypes.py
Python 3.5.10 (default, Jan 15 2022, 19:53:00) [GCC 9.3.0] 064bit on linux

Entries:
['root_dir', ['dir0', 'dir1', 'dir2', 'dir3'], ['file0', 'file1']]

Done.
</code></pre>
</blockquote>
<h4>8. <a href="http://timgolden.me.uk/pywin32-docs/win32file__FindFilesW_meth.html" rel="noreferrer">[TimGolden]: win32file.FindFilesW</a></h4>
<p><em>Win</em> specific:</p>
<blockquote>
<p>Retrieves a list of matching filenames, using the Windows Unicode API. An interface to the API FindFirstFileW/FindNextFileW/Find close functions.</p>
</blockquote>
<br>
<blockquote>
<pre class="lang-py prettyprint-override"><code>&gt;&gt;&gt; import os, win32file as wfile, win32con as wcon
&gt;&gt;&gt;
&gt;&gt;&gt; root_dir = &quot;root_dir&quot;
&gt;&gt;&gt; root_dir_wildcard = os.path.join(root_dir, &quot;*&quot;)
&gt;&gt;&gt; entry_list = wfile.FindFilesW(root_dir_wildcard)
&gt;&gt;&gt; len(entry_list)  # Don't display the whole content as it's too long
8
&gt;&gt;&gt; [entry[-2] for entry in entry_list]  # Only display the entry names
['.', '..', 'dir0', 'dir1', 'dir2', 'dir3', 'file0', 'file1']
&gt;&gt;&gt;
&gt;&gt;&gt; [entry[-2] for entry in entry_list if entry[0] &amp; wcon.FILE_ATTRIBUTE_DIRECTORY and entry[-2] not in (&quot;.&quot;, &quot;..&quot;)]  # Filter entries and only display dir names (except self and parent)
['dir0', 'dir1', 'dir2', 'dir3']
&gt;&gt;&gt;
&gt;&gt;&gt; [os.path.join(root_dir, entry[-2]) for entry in entry_list if entry[0] &amp; (wcon.FILE_ATTRIBUTE_NORMAL | wcon.FILE_ATTRIBUTE_ARCHIVE)]  # Only display file &quot;full&quot; names
['root_dir\\file0', 'root_dir\\file1']
</code></pre>
</blockquote>
<p><strong>Notes</strong>:</p>
<ul>
<li><em>win32file.FindFilesW</em> is part of <a href="https://github.com/mhammond/pywin32" rel="noreferrer">[GitHub]: mhammond/pywin32 - Python for Windows (pywin32) Extensions</a>, which is a <em>Python</em> wrapper over <em>WinAPI</em>s</li>
</ul>
<h4>9. Use some (other) 3<sup>rd</sup>-party package that does the trick</h4>
<p>Most likely, will rely on one (or more) of the above (maybe with slight customizations).</p>
<h4>Notes:</h4>
<ul>
<li><p>Code is meant to be portable (except places that target a specific area - which are marked) or cross:</p>
<ul>
<li><p><em>OS</em> (<em>Nix</em>, <em>Win</em>, )</p>
</li>
<li><p><em>Python</em> version (2, 3, )</p>
</li>
</ul>
</li>
<li><p>Multiple path styles (absolute, relatives) were used across the above variants, to illustrate the fact that the &quot;tools&quot; used are flexible in this direction</p>
</li>
<li><p><em>os.listdir</em> and <em>os.scandir</em> use <em>opendir</em> / <em>readdir</em> / <em>closedir</em> (<a href="https://learn.microsoft.com/en-gb/windows/desktop/api/fileapi/nf-fileapi-findfirstfilew" rel="noreferrer">[MS.Learn]: FindFirstFileW function (fileapi.h)</a> / <a href="https://learn.microsoft.com/en-gb/windows/desktop/api/fileapi/nf-fileapi-findnextfilew" rel="noreferrer">[MS.Learn]: FindNextFileW function (fileapi.h)</a> / <a href="https://learn.microsoft.com/en-gb/windows/desktop/api/fileapi/nf-fileapi-findclose" rel="noreferrer">[MS.Learn]: FindClose function (fileapi.h)</a>) (via <a href="https://github.com/python/cpython/blob/main/Modules/posixmodule.c" rel="noreferrer">[GitHub]: python/cpython - (main) cpython/Modules/posixmodule.c</a>)</p>
</li>
<li><p><em>win32file.FindFilesW</em> uses those (<em>Win</em> specific) functions as well (via <a href="https://github.com/mhammond/pywin32/blob/main/win32/src/win32file.i" rel="noreferrer">[GitHub]: mhammond/pywin32 - (main) pywin32/win32/src/win32file.i</a>)</p>
</li>
<li><p><em>_get_dir_content</em> (from point <em><strong>#1.</strong></em>) can be implemented using any of these approaches (some will require more work and some less)</p>
<ul>
<li>Some advanced filtering (instead of just file <em>vs.</em> <em>dir</em>) could be done: <em>e.g.</em> the <em>include_folders</em> argument could be replaced by another one (e.g. <em>filter_func</em>) which would be a function that takes a path as an argument: <code>filter_func=lambda x: True</code> (this doesn't strip out anything) and inside <em>_get_dir_content</em> something like: <code>if not filter_func(entry_with_path): continue</code> (if the function fails for one entry, it will be skipped), but the more complex the code becomes, the longer it will take to execute</li>
</ul>
</li>
<li><p><strong>Nota Bene!</strong> Since recursion is used, I must mention that I did some tests on my laptop (<em>Win 10 pc064</em>), totally unrelated to this problem, and when the recursion level was reaching values somewhere in the <em>(990 .. 1000)</em> range (<em>recursionlimit</em> - 1000 (default)), I got <em>StackOverflow</em> :). If the directory tree exceeds that limit (I am not an <em>FS</em> expert, so I don't know if that is even possible), that could be a problem.<br>
I must also mention that I didn't try to increase <em>recursionlimit</em>, but in theory there will always be the possibility for failure, if the <em>dir</em> depth is larger than the highest possible <em>recursionlimit</em> (on that machine).<br>
Check <a href="https://stackoverflow.com/a/54517228/4788546">[SO]: _csv.Error: field larger than field limit (131072) (@CristiFati's answer)</a> for more details on the topic</p>
</li>
<li><p>Code samples are for demonstrative purposes only. That means that I didn't take into account error handling (I don't think there's any <em><strong>try</strong></em> / <em><strong>except</strong></em> / <em><strong>else</strong></em> / <em><strong>finally</strong></em> block), so the code is not robust (the reason is: to keep it as simple and short as possible). For production, error handling should be added as well</p>
</li>
</ul>
<h3>Other approaches:</h3>
<h4>1. Use <em>Python</em> only as a wrapper</h4>
<ul>
<li><p>Everything is done using another technology</p>
</li>
<li><p>That technology is invoked from <em>Python</em></p>
</li>
<li><p>The most famous flavor that I know is what I call the <em>SysAdmin</em> approach:</p>
<ul>
<li><p>Use <em>Python</em> (or any programming language for that matter) in order to execute <em>Shell</em> commands (and parse their outputs)</p>
</li>
<li><p>Some consider this a neat hack</p>
</li>
<li><p>I consider it more like a lame workaround (<em>gainarie</em>), as the action <em>per se</em> is performed from <em>Shell</em> (<em>Cmd</em> in this case), and thus doesn't have anything to do with <em>Python</em></p>
</li>
<li><p>Filtering (<em>grep</em> / <em>findstr</em>) or output formatting could be done on both sides, but I'm not going to insist on it. Also, I deliberately used <em>os.system</em> instead of <a href="https://docs.python.org/library/subprocess.html#module-subprocess" rel="noreferrer">[Python.Docs]: subprocess - Subprocess management</a> routines (<em>run</em>, <em>check_output</em>, ...)</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<pre><code>[prompt]&gt; &quot;e:\Work\Dev\VEnvs\py_pc064_03.05.04_test0\Scripts\python.exe&quot; -c &quot;import os;os.system(\&quot;dir /b root_dir\&quot;)&quot;
dir0
dir1
dir2
dir3
file0
file1
</code></pre>
</blockquote>
<br>
<blockquote>
<pre><code>[cfati@cfati-5510-0:/mnt/e/Work/Dev/StackOverflow/q003207219]&gt; python3.5 -c &quot;import os;os.system(\&quot;ls root_dir\&quot;)&quot;
dir0  dir1  dir2  dir3  file0  file1
</code></pre>
</blockquote>
<p>In general, this approach is to be avoided, since if some command output format slightly differs between <em>OS</em> versions / flavors, the parsing code should be adapted as well - not to mention differences between locales.</p>
<hr><h3>  Answer by ArtOfWarfare, Id: 24652788, Score: 50, created_at: 2014-07-09 11:43:58+00:00 </h3><p>I really liked <a href="https://stackoverflow.com/a/3215392/901641">adamk's answer</a>, suggesting that you use <code>glob()</code>, from the module of the same name. This allows you to have pattern matching with <code>*</code>s.</p>

<p>But as other people pointed out in the comments, <code>glob()</code> can get tripped up over inconsistent slash directions. To help with that, I suggest you use the <code>join()</code> and <code>expanduser()</code> functions in the <code>os.path</code> module, and perhaps the <code>getcwd()</code> function in the <code>os</code> module, as well.</p>

<p>As examples:</p>

<pre><code>from glob import glob

# Return everything under C:\Users\admin that contains a folder called wlp.
glob('C:\Users\admin\*\wlp')
</code></pre>

<p>The above is terrible - the path has been hardcoded and will only ever work on Windows between the drive name and the <code>\</code>s being hardcoded into the path.</p>

<pre><code>from glob    import glob
from os.path import join

# Return everything under Users, admin, that contains a folder called wlp.
glob(join('Users', 'admin', '*', 'wlp'))
</code></pre>

<p>The above works better, but it relies on the folder name <code>Users</code> which is often found on Windows and not so often found on other OSs. It also relies on the user having a specific name, <code>admin</code>.</p>

<pre><code>from glob    import glob
from os.path import expanduser, join

# Return everything under the user directory that contains a folder called wlp.
glob(join(expanduser('~'), '*', 'wlp'))
</code></pre>

<p>This works perfectly across all platforms.</p>

<p>Another great example that works perfectly across platforms and does something a bit different:</p>

<pre><code>from glob    import glob
from os      import getcwd
from os.path import join

# Return everything under the current directory that contains a folder called wlp.
glob(join(getcwd(), '*', 'wlp'))
</code></pre>

<p>Hope these examples help you see the power of a few of the functions you can find in the standard Python library modules.</p>
<h4> Comment by ArtOfWarfare, Score: 4, Id: 44660535, created_at: 2015-01-26 03:24:41+00:00 </h4>Extra glob fun: starting in Python 3.5, <code>**</code> works as long as you set <code>recursive = True</code>. See the docs here: <a href="https://docs.python.org/3.5/library/glob.html#glob.glob" rel="nofollow noreferrer">docs.python.org/3.5/library/glob.html#glob.glob</a><hr><h3>  Answer by Apogentus, Id: 24145985, Score: 40, created_at: 2014-06-10 16:16:30+00:00 </h3><pre><code>def list_files(path):
    # returns a list of names (with extension, without full path) of all files 
    # in folder path
    files = []
    for name in os.listdir(path):
        if os.path.isfile(os.path.join(path, name)):
            files.append(name)
    return files 
</code></pre>
<hr><h3>  Answer by Yauhen Yakimovich, Id: 22990477, Score: 26, created_at: 2014-04-10 14:09:06+00:00 </h3><p>If you are looking for a Python implementation of <strong>find</strong>, this is a recipe I use rather frequently:</p>

<pre><code>from findtools.find_files import (find_files, Match)

# Recursively find all *.sh files in **/usr/bin**
sh_files_pattern = Match(filetype='f', name='*.sh')
found_files = find_files(path='/usr/bin', match=sh_files_pattern)

for found_file in found_files:
    print found_file
</code></pre>

<p>So I made a PyPI <a href="https://pypi.python.org/pypi/findtools/" rel="noreferrer">package</a> out of it and there is also a <a href="https://github.com/ewiger/findtools" rel="noreferrer">GitHub repository</a>. I hope that someone finds it potentially useful for this code.</p>
<hr><h3>  Answer by Andy Jazz, Id: 54107684, Score: 16, created_at: 2019-01-09 10:11:57+00:00 </h3><p>For greater results, you can use <code>listdir()</code> method of the <code>os</code> module along with a generator (a generator is a powerful iterator that keeps its state, remember?). The following code works fine with both versions: Python 2 and Python 3.</p>

<p>Here's a code:</p>

<pre><code>import os

def files(path):  
    for file in os.listdir(path):
        if os.path.isfile(os.path.join(path, file)):
            yield file

for file in files("."):  
    print (file)
</code></pre>

<p>The <code>listdir()</code> method returns the list of entries for the given directory. The method <code>os.path.isfile()</code> returns <code>True</code> if the given entry is a file. And the <code>yield</code> operator quits the func but keeps its current state, and it returns only the name of the entry detected as a file. All the above allows us to loop over the generator function.</p>
<hr><h3>  Answer by The2ndSon, Id: 24209884, Score: 12, created_at: 2014-06-13 16:26:01+00:00 </h3><p><strong>Returning a list of absolute filepaths, does not recurse into subdirectories</strong></p>

<pre><code>L = [os.path.join(os.getcwd(),f) for f in os.listdir('.') if os.path.isfile(os.path.join(os.getcwd(),f))]
</code></pre>
<h4> Comment by ShadowRanger, Score: 2, Id: 74670067, created_at: 2017-05-06 00:14:04+00:00 </h4>Note: <code>os.path.abspath(f)</code> would be a somewhat cheaper substitute for <code>os.path.join(os.getcwd(),f)</code>.<h4> Comment by Martijn Pieters, Score: 1, Id: 94120391, created_at: 2018-12-05 10:46:34+00:00 </h4>I&#39;d be more efficient still if you started with <code>cwd = os.path.abspath(&#39;.&#39;)</code>, then used <code>cwd</code> instead of <code>&#39;.&#39;</code> and <code>os.getcwd()</code> throughout to avoid loads of redundant system calls.<hr><h3>  Answer by fralau, Id: 55321475, Score: 12, created_at: 2019-03-24 07:07:20+00:00 </h3><p>A wise teacher told me once that:</p>

<blockquote>
  <p>When there are several established ways to do something, none of them is good for all cases.</p>
</blockquote>

<p>I will thus add a solution for a <strong>subset</strong> of the problem: quite often, we only want to check whether a file matches a start string and an end string, without going into subdirectories. We would thus like a function that returns a list of filenames, like:</p>

<pre><code>filenames = dir_filter('foo/baz', radical='radical', extension='.txt')
</code></pre>

<p>If you care to first declare two functions, this can be done:</p>

<pre><code>def file_filter(filename, radical='', extension=''):
    "Check if a filename matches a radical and extension"
    if not filename:
        return False
    filename = filename.strip()
    return(filename.startswith(radical) and filename.endswith(extension))

def dir_filter(dirname='', radical='', extension=''):
    "Filter filenames in directory according to radical and extension"
    if not dirname:
        dirname = '.'
    return [filename for filename in os.listdir(dirname)
                if file_filter(filename, radical, extension)]
</code></pre>

<p>This solution could be easily generalized with regular expressions (and you might want to add a <code>pattern</code> argument, if you do not want your patterns to always stick to the start or end of the filename).</p>
<hr><h3>  Answer by pah8J, Id: 50927977, Score: 11, created_at: 2018-06-19 12:03:14+00:00 </h3><pre><code>import os
import os.path


def get_files(target_dir):
    item_list = os.listdir(target_dir)

    file_list = list()
    for item in item_list:
        item_dir = os.path.join(target_dir,item)
        if os.path.isdir(item_dir):
            file_list += get_files(item_dir)
        else:
            file_list.append(item_dir)
    return file_list
</code></pre>

<p>Here I use a recursive structure.</p>
<h4> Comment by Georgy, Score: 1, Id: 98992717, created_at: 2019-05-17 09:37:12+00:00 </h4>The same can be achieved just in one line with <a href="https://docs.python.org/3/library/pathlib.html" rel="nofollow noreferrer"><code>pathlib</code></a>: <code>filter(Path.is_file, Path().rglob(&#39;*&#39;))</code><hr><h3>  Answer by shantanoo, Id: 40926538, Score: 8, created_at: 2016-12-02 07:01:16+00:00 </h3><p>Using generators</p>

<pre><code>import os
def get_files(search_path):
     for (dirpath, _, filenames) in os.walk(search_path):
         for filename in filenames:
             yield os.path.join(dirpath, filename)
list_files = get_files('.')
for filename in list_files:
    print(filename)
</code></pre>
<hr><h3>  Answer by fhchl, Id: 49534391, Score: 7, created_at: 2018-03-28 12:20:13+00:00 </h3><p>Another very readable variant for Python 3.4+ is using pathlib.Path.glob:</p>

<pre><code>from pathlib import Path
folder = '/foo'
[f for f in Path(folder).glob('*') if f.is_file()]
</code></pre>

<p>It is simple to make more specific, e.g. only look for Python source files which are not symbolic links, also in all subdirectories:</p>

<pre><code>[f for f in Path(folder).glob('**/*.py') if not f.is_symlink()]
</code></pre>
<hr><h3>  Answer by shaji, Id: 11647676, Score: 2, created_at: 2012-07-25 10:25:54+00:00 </h3><p><em><a href="http://docs.python.org/release/2.6.7/library/dircache.html" rel="nofollow noreferrer">dircache</a> is  "Deprecated since version 2.6: The dircache module has been removed in Python 3.0."</em></p>

<pre><code>import dircache
list = dircache.listdir(pathname)
i = 0
check = len(list[0])
temp = []
count = len(list)
while count != 0:
  if len(list[i]) != check:
     temp.append(list[i-1])
     check = len(list[i])
  else:
    i = i + 1
    count = count - 1

print temp
</code></pre>
<hr><h3>  Answer by chris-piekarski, Id: 52885096, Score: 4, created_at: 2018-10-19 02:34:15+00:00 </h3><p>For Python 2:</p>
<pre><code>pip install rglob
</code></pre>
<p>Then do</p>
<pre><code>import rglob
file_list = rglob.rglob(&quot;/home/base/dir/&quot;, &quot;*&quot;)
print file_list
</code></pre>
<h4> Comment by Eric, Score: 4, Id: 118208005, created_at: 2021-03-30 13:45:05+00:00 </h4>When an external dep can be avoided, do it. What is the added value of using an external dependency when all you need is already in the language?<hr><h3>  Answer by MarredCheese, Id: 47703002, Score: 3, created_at: 2017-12-07 20:10:58+00:00 </h3><p>Here's my general-purpose function for this.  It returns a list of file paths rather than filenames since I found that to be more useful.  It has a few optional arguments that make it versatile.  For instance, I often use it with arguments like <code>pattern='*.txt'</code> or <code>subfolders=True</code>.</p>

<pre><code>import os
import fnmatch

def list_paths(folder='.', pattern='*', case_sensitive=False, subfolders=False):
    """Return a list of the file paths matching the pattern in the specified 
    folder, optionally including files inside subfolders.
    """
    match = fnmatch.fnmatchcase if case_sensitive else fnmatch.fnmatch
    walked = os.walk(folder) if subfolders else [next(os.walk(folder))]
    return [os.path.join(root, f)
            for root, dirnames, filenames in walked
            for f in filenames if match(f, pattern)]
</code></pre>
<hr><h3>  Answer by Vinodh Krishnaraju, Id: 47758562, Score: 3, created_at: 2017-12-11 17:51:11+00:00 </h3><p>I will provide a sample one liner where sourcepath and file type can be provided as input. The code returns a list of filenames with csv extension. Use <em>.</em> in case all files needs to be returned. This will also recursively scans the subdirectories. </p>

<p><code>[y for x in os.walk(sourcePath) for y in glob(os.path.join(x[0], '*.csv'))]</code></p>

<p>Modify file extensions and source path as needed. </p>
<h4> Comment by Martijn Pieters, Score: 2, Id: 94121214, created_at: 2018-12-05 11:09:48+00:00 </h4>If you are going to use <code>glob</code>, then just use <code>glob(&#39;**&#47;*.csv&#39;, recursive=True)</code>. No need to combine this with <code>os.walk()</code> to recurse (<code>recursive</code> and <code>**</code> are supported since Python 3.5).