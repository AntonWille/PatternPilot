 <h2> Title: How do I make a flat list out of a list of lists? </h2> <h4> Emma, question_id: 952914 </h4>Score: 5275, Tags: {python,list,multidimensional-array,flatten} <br><p>I have a list of lists like</p>
<pre><code>[
    [1, 2, 3],
    [4, 5, 6],
    [7],
    [8, 9]
]
</code></pre>
<p>How can I flatten it to get <code>[1, 2, 3, 4, 5, 6, 7, 8, 9]</code>?</p>
<hr />
<p><sub>If your list of lists comes from a nested list comprehension, the problem can be solved more simply/directly by fixing the comprehension; please see <a href="https://stackoverflow.com/questions/1077015">How can I get a flat result from a list comprehension instead of a nested list?</a>.</sub></p>
<p><sub>The most popular solutions here generally only flatten one &quot;level&quot; of the nested list. See <a href="https://stackoverflow.com/questions/2158395">Flatten an irregular (arbitrarily nested) list of lists</a> for solutions that completely flatten a deeply nested structure (recursively, in general).</sub></p>
<h4> RichieHindle, Id: 24914362 Score: 57: </h4>There&#39;s an in-depth discussion of this here: <a href="http://rightfootin.blogspot.com/2006/09/more-on-python-flatten.html" rel="nofollow noreferrer">rightfootin.blogspot.com/2006/09/more-on-python-flatten.html</a>&zwnj;&#8203;, discussing several methods of flattening arbitrarily nested lists of lists. An interesting read!<br>------------------------------------------------------------------ <br><h3> Alex Martelli, Id: 952952, Score: 7256: </h3><p>A list of lists named <code>xss</code> can be flattened using a <a href="https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions" rel="noreferrer">list comprehension</a>:</p>
<pre><code>flat_list = [
    x
    for xs in xss
    for x in xs
]
</code></pre>
<p>The above is equivalent to:</p>
<pre><code>flat_list = []

for xs in xss:
    for x in xs:
        flat_list.append(x)
</code></pre>
<p>Here is the corresponding function:</p>
<pre><code>def flatten(xss):
    return [x for xs in xss for x in xs]
</code></pre>
<p>This is the fastest method.
As evidence, using the <a href="https://docs.python.org/3/library/timeit.html" rel="noreferrer"><code>timeit</code></a> module in the standard library, we see:</p>
<pre class="lang-bash prettyprint-override"><code>$ python -mtimeit -s'xss=[[1,2,3],[4,5,6],[7],[8,9]]*99' '[x for xs in xss for x in xs]'
10000 loops, best of 3: 143 usec per loop

$ python -mtimeit -s'xss=[[1,2,3],[4,5,6],[7],[8,9]]*99' 'sum(xss, [])'
1000 loops, best of 3: 969 usec per loop

$ python -mtimeit -s'xss=[[1,2,3],[4,5,6],[7],[8,9]]*99' 'reduce(lambda xs, ys: xs + ys, xss)'
1000 loops, best of 3: 1.1 msec per loop
</code></pre>
<p>Explanation: the methods based on <code>+</code> (including the implied use in <code>sum</code>) are, of necessity, <code>O(L**2)</code> when there are L sublists -- as the intermediate result list keeps getting longer, at each step a new intermediate result list object gets allocated, and all the items in the previous intermediate result must be copied over (as well as a few new ones added at the end). So, for simplicity and without actual loss of generality, say you have L sublists of M items each: the first M items are copied back and forth <code>L-1</code> times, the second M items <code>L-2</code> times, and so on; total number of copies is M times the sum of x for x from 1 to L excluded, i.e., <code>M * (L**2)/2</code>.</p>
<p>The list comprehension just generates one list, once, and copies each item over (from its original place of residence to the result list) also exactly once.</p>
<h4> intuited, Comment 4204394 Score: 651: </h4>I tried a test with the same data, using <code>itertools.chain.from_iterable</code> :         <code>$ python -mtimeit -s&#39;from itertools import chain; l=[[1,2,3],[4,5,6], [7], [8,9]]*99&#39; &#39;list(chain.from_iterable(l))&#39;</code>.   It runs a bit more than twice as fast as the nested list comprehension that&#39;s the fastest of the alternatives shown here.<br><h4> Rob Crowell, Comment 8141656 Score: 366: </h4>I found the syntax hard to understand until I realized you can think of it exactly like nested for loops.  for sublist in l: for item in sublist: yield item<br><h4> John Mee, Comment 27201346 Score: 266: </h4>[leaf for tree in forest for leaf in tree] might be easier to comprehend and apply.<br><h4> Gilthans, Comment 121485817 Score: 86: </h4>I kept looking here every time I wanted to flatten a list, but this gif is what drove it home: <a href="https://i.stack.imgur.com/0GoV5.gif" rel="nofollow noreferrer">i.stack.imgur.com/0GoV5.gif</a><br><h4> Sнаđошƒаӽ, Comment 120800302 Score: 53: </h4>@RobCrowell Same here. To me the list comprehension one doesn&#39;t <i>read right</i>, something feels off about it - I always seem to get it wrong and end up googling. To me this reads right <code>[leaf for leaf in tree for tree in forest]</code>. I wish this is how it was. I am sure I am missing something about the grammar here, and I would appreciate if anyone could point that out.<br><h4> diatomicDisaster, Comment 127705456 Score: 5: </h4>@Sнаđошƒаӽ it makes sense if you consider a list comprehension as a flattened series of for loops. Ignore the first <code>leaf</code>, as this is just the item you want to populate the list with, and then look at the series of <code>for</code> loops, which would be nested as: line 1: <code>for tree in forest:</code>, line 2: <code>for leaf in tree:</code>. If you just append the second for loop to the first, you get the syntax of a list comprehension.<br><h4> PythoNic, Comment 129460508 Score: 4: </h4>The solution fails if your list elements are strings, as they are flattened to single chars too...<br><h4> Skippy le Grand Gourou, Comment 123215183 Score: 2: </h4>@Sнаđошƒаӽ I have the same feeling, but think about it like this : variables have to be defined before they are accessible.  In <code>[leaf for leaf in tree for tree in forest]</code>, <code>tree</code> does not exist yet when first accessed with <code>in</code>.  It is only defined by <code>for tree in forest</code>.  Therefore one needs to write <code>[leaf for tree in forest for leaf in tree]</code>.  Yes, I know, this doesn’t apply to the first <code>leaf</code>, though…  (Also I’m not saying it’s how things actually work inside.)<br><h4> Clayton C., Comment 131991387 Score: 1: </h4>The way I like to think of it for memorization purposes is: [a for b in c for a in b].<br><h4> V. Rubinetti, Comment 136846523 Score: 0: </h4>Coming from Javascript, list comprehension continues to trip me up. I&#39;d expect the <code>leaf</code> to be at the end, or maybe even for the <code>for</code>s to be nested sorta like <code>.map()</code>s would be in JS, e.g. <code>for tree in forest (for leaf in tree (leaf * 2))</code>. Not sure what the best answer is, but by the looks of the upvotes on these other comments, the syntax they chose was a mistake.<br>------------------------------------------------------------------ <br><h3> Shawn Chin, Id: 953097, Score: 2339: </h3><p>You can use <a href="http://docs.python.org/library/itertools.html#itertools.chain" rel="noreferrer"><code>itertools.chain()</code></a>:</p>
<pre><code>&gt;&gt;&gt; import itertools
&gt;&gt;&gt; list2d = [[1,2,3], [4,5,6], [7], [8,9]]
&gt;&gt;&gt; merged = list(itertools.chain(*list2d))
</code></pre>
<p>Or you can use <a href="http://docs.python.org/library/itertools.html#itertools.chain.from_iterable" rel="noreferrer"><code>itertools.chain.from_iterable()</code></a> which doesn't require unpacking the list with the <code>*</code> operator:</p>
<pre><code>&gt;&gt;&gt; import itertools
&gt;&gt;&gt; list2d = [[1,2,3], [4,5,6], [7], [8,9]]
&gt;&gt;&gt; merged = list(itertools.chain.from_iterable(list2d))
</code></pre>
<p>This approach is arguably more readable than <code>[item for sublist in l for item in sublist]</code> and appears to be faster too:</p>
<pre><code>$ python3 -mtimeit -s'l=[[1,2,3],[4,5,6], [7], [8,9]]*99;import itertools' 'list(itertools.chain.from_iterable(l))'
20000 loops, best of 5: 10.8 usec per loop
$ python3 -mtimeit -s'l=[[1,2,3],[4,5,6], [7], [8,9]]*99' '[item for sublist in l for item in sublist]'
10000 loops, best of 5: 21.7 usec per loop
$ python3 -mtimeit -s'l=[[1,2,3],[4,5,6], [7], [8,9]]*99' 'sum(l, [])'
1000 loops, best of 5: 258 usec per loop
$ python3 -mtimeit -s'l=[[1,2,3],[4,5,6], [7], [8,9]]*99;from functools import reduce' 'reduce(lambda x,y: x+y,l)'
1000 loops, best of 5: 292 usec per loop
$ python3 --version
Python 3.7.5rc1
</code></pre>
<h4> ShadowRanger, Comment 55134388 Score: 144: </h4>@TimDierks: I&#39;m not sure &quot;this requires you to understand Python syntax&quot; is an argument against using a given technique in Python. Sure, complex usage could confuse, but the &quot;splat&quot; operator is generally useful in many circumstances, and this isn&#39;t using it in a particularly obscure way; rejecting all language features that aren&#39;t necessarily obvious to beginning users means you&#39;re tying one hand behind your back. May as well throw out list comprehensions too while you&#39;re at it; users from other backgrounds would find a <code>for</code> loop that repeatedly <code>append</code>s more obvious.<br><h4> Tim Dierks, Comment 40073357 Score: 28: </h4>The <code>*</code> is the tricky thing that makes <code>chain</code> less straightforward than the list comprehension. You have to know that chain only joins together the iterables passed as parameters, and the * causes the top-level list to be expanded into parameters, so <code>chain</code> joins together all those iterables, but doesn&#39;t descend further. I think this makes the comprehension more readable than the use of chain in this case.<br><h4> nadapez, Comment 123121115 Score: 4: </h4>* creates an intermediary tuple.! <code>from_iterable</code> fetch the nested lists directly from the top list.<br><h4> Lukas Juhrich, Comment 133579892 Score: 3: </h4>Even shorter is <code>[*chain(*l)]</code> <i>(<a href="https://docs.python.org/3/whatsnew/3.5.html#pep-448-additional-unpacking-generalizations" rel="nofollow noreferrer"><code>python3.5+</code></a>, released 2015)</i><br><h4> Chris Collett, Comment 123218191 Score: 2: </h4>To make this more readable, you can make a simple function: <code>def flatten_list(deep_list: list[list[object]]):</code> <code>return list(chain.from_iterable(deep_list))</code>. The type hinting improves the clarity of what&#39;s going on (modern IDEs would interpret this as returning a <code>list[object]</code> type).<br>------------------------------------------------------------------ <br><h3> Kenan Banks, Id: 952946, Score: 1372: </h3><p><strong>Note from the author</strong>: This is very inefficient. But fun, because <a href="https://en.wikipedia.org/wiki/Monoid#Monoids_in_computer_science" rel="noreferrer">monoids</a> are awesome.</p>
<pre><code>&gt;&gt;&gt; xss = [[1, 2, 3], [4, 5, 6], [7], [8, 9]]
&gt;&gt;&gt; sum(xss, [])
[1, 2, 3, 4, 5, 6, 7, 8, 9]
</code></pre>
<p><code>sum</code> sums the elements of the iterable <code>xss</code>, and uses the second argument as the initial value <code>[]</code> for the sum. (The default initial value is <code>0</code>, which is not a list.)</p>
<p>Because you are summing nested lists, you actually get <code>[1,3]+[2,4]</code> as a result of <code>sum([[1,3],[2,4]],[])</code>, which is equal to <code>[1,3,2,4]</code>.</p>
<p>Note that only works on lists of lists. For lists of lists of lists, you'll need another solution.</p>
<h4> andrewrk, Comment 3119589 Score: 162: </h4>that&#39;s pretty neat and clever but I wouldn&#39;t use it because it&#39;s confusing to read.<br><h4> Mike Graham, Comment 13288147 Score: 115: </h4>This is a Shlemiel the painter&#39;s algorithm <a href="http://www.joelonsoftware.com/articles/fog0000000319.html" rel="nofollow noreferrer">joelonsoftware.com/articles/fog0000000319.html</a> -- unnecessarily inefficient as well as unnecessarily ugly.<br><h4> ulidtko, Comment 43009171 Score: 68: </h4>The append operation on lists forms a <b><a href="http://en.wikipedia.org/wiki/Monoid#Monoids_in_computer_science" rel="nofollow noreferrer"><code>Monoid</code></a></b>, which is one of the most convenient abstractions for thinking of a <code>+</code> operation in a general sense (not limited to numbers only). So this answer deserves a +1 from me for (correct) treatment of lists as a monoid. <i>The performance is concerning though...</i><br><h4> Jean-Fran&#231;ois Fabre, Comment 77806270 Score: 22: </h4>this is a very inefficient way because of the quadratic aspect of the sum.<br><h4> ds4940, Comment 83174685 Score: 13: </h4>This article explains the maths of the inefficiency <a href="https://mathieularose.com/how-not-to-flatten-a-list-of-lists-in-python/" rel="nofollow noreferrer">mathieularose.com/how-not-to-flatten-a-list-of-lists-in-pyth&zwnj;&#8203;on</a><br>------------------------------------------------------------------ <br><h3> Nico Schl&#246;mer, Id: 45323085, Score: 889: </h3><p>I tested most suggested solutions with <a href="https://github.com/nschloe/perfplot" rel="noreferrer">perfplot</a> (a pet project of mine, essentially a wrapper around <code>timeit</code>), and found</p>
<pre class="lang-py prettyprint-override"><code>import functools
import operator
functools.reduce(operator.iconcat, a, [])
</code></pre>
<p>to be the fastest solution, both when many small lists and few long lists are concatenated. (<code>operator.iadd</code> is equally fast.)</p>
<p>A simpler and also acceptable variant is</p>
<pre class="lang-py prettyprint-override"><code>out = []
for sublist in a:
    out.extend(sublist)
</code></pre>
<p>If the number of sublists is large, this performs a little worse than the above suggestion.</p>
<p><a href="https://i.stack.imgur.com/82YEG.png" rel="noreferrer"><img src="https://i.stack.imgur.com/82YEG.png" alt="enter image description here" /></a></p>
<p><a href="https://i.stack.imgur.com/Mo7iy.png" rel="noreferrer"><img src="https://i.stack.imgur.com/Mo7iy.png" alt="enter image description here" /></a></p>
<hr />
<p>Code to reproduce the plot:</p>
<pre class="lang-py prettyprint-override"><code>import functools
import itertools
import operator

import numpy as np
import perfplot


def forfor(a):
    return [item for sublist in a for item in sublist]


def sum_brackets(a):
    return sum(a, [])


def functools_reduce(a):
    return functools.reduce(operator.concat, a)


def functools_reduce_iconcat(a):
    return functools.reduce(operator.iconcat, a, [])


def itertools_chain(a):
    return list(itertools.chain.from_iterable(a))


def numpy_flat(a):
    return list(np.array(a).flat)


def numpy_concatenate(a):
    return list(np.concatenate(a))


def extend(a):
    out = []
    for sublist in a:
        out.extend(sublist)
    return out


b = perfplot.bench(
    setup=lambda n: [list(range(10))] * n,
    # setup=lambda n: [list(range(n))] * 10,
    kernels=[
        forfor,
        sum_brackets,
        functools_reduce,
        functools_reduce_iconcat,
        itertools_chain,
        numpy_flat,
        numpy_concatenate,
        extend,
    ],
    n_range=[2 ** k for k in range(16)],
    xlabel=&quot;num lists (of length 10)&quot;,
    # xlabel=&quot;len lists (10 lists total)&quot;
)
b.save(&quot;out.png&quot;)
b.show()
</code></pre>
<h4> Sara, Comment 95376198 Score: 57: </h4>For huge nested lists,&#39; list(numpy.array(a).flat)&#39; is the fastest among all functions above.<br><h4> mirekphd, Comment 115190113 Score: 6: </h4>Tried <code>numpy_flat</code> on the test example from Rossetta Code (<a href="https://rosettacode.org/wiki/Flatten_a_list#Python" rel="nofollow noreferrer">link</a>) and got <code>VisibleDeprecationWarning: Creating an ndarray from ragged nested sequences (which is a list-or-tuple of lists-or-tuples-or ndarrays with different lengths or shapes) is deprecated. If you meant to do this, you must specify &#39;dtype=object&#39; when creating the ndarray</code><br><h4> Chau Pham, Comment 125035098 Score: 4: </h4>For different sublist lengths, np.array <code>flat</code> <b>doesn&#39;t work</b>. E.g., <code>a = [ [1,2], [1,2,3]]</code> <code>list(np.array(a).flat)</code> will return the original list. It&#39;s safer to use <code>list(np.concatenate(a))</code><br><h4> user3064538, Comment 114624129 Score: 3: </h4>@Sara can you define &quot;huge&quot; please?<br><h4> Leo, Comment 108814312 Score: 2: </h4>Is there a way to do a 3-d perfplot? number of arrays by average size of array?<br><h4> Oscar Benjamin, Comment 122896619 Score: 2: </h4>One option missed above which shows up faster for my particular case i just <code>items = []; for sublist in a: items.extend(sublist); return sublist</code><br><h4> CuCaRot, Comment 122908357 Score: 2: </h4>@Sara the solution fails in case the length of the elements list is not the same. For example: <code>[[1, 2], [3, 4], [5]]</code><br><h4> Kelly Bundy, Comment 134371307 Score: 0: </h4><code>out += sublist</code> is faster than <code>out.extend(sublist)</code> (in the first plot, with many short lists). See <a href="https://i.stack.imgur.com/jeihJ.png" rel="nofollow noreferrer">iadd vs extend</a>.<br>------------------------------------------------------------------ <br><h3> Greg Hewgill, Id: 952943, Score: 333: </h3><p>Using <a href="https://docs.python.org/3/library/functools.html#functools.reduce" rel="noreferrer"><code>functools.reduce</code></a>, which adds an accumulated list <code>xs</code> to the next list <code>ys</code>:</p>
<pre><code>from functools import reduce
xss = [[1,2,3], [4,5,6], [7], [8,9]]
out = reduce(lambda xs, ys: xs + ys, xss)
</code></pre>
<p>Output:</p>
<pre><code>[1, 2, 3, 4, 5, 6, 7, 8, 9]
</code></pre>
<hr />
<p>A faster way using <a href="https://docs.python.org/3/library/operator.html#operator.concat" rel="noreferrer"><code>operator.concat</code></a>:</p>
<pre><code>from functools import reduce
import operator
xss = [[1,2,3], [4,5,6], [7], [8,9]]
out = reduce(operator.concat, xss)
</code></pre>
<p>Output:</p>
<pre><code>[1, 2, 3, 4, 5, 6, 7, 8, 9]
</code></pre>
<h4> Mike Graham, Comment 13288184 Score: 12: </h4>This is a Shlemiel the painter&#39;s algorithm joelonsoftware.com/articles/fog0000000319.html<br><h4> gntskn, Comment 113483883 Score: 1: </h4><code>reduce</code> is <i>very</i> inefficient for this use case as it will repeat copies and generate many unused temporary lists (O(n^2) in both time and possibly space, depending on how the GC decides to clean). It&#39;s better to use append or extend.<br><h4> dark_ruby, Comment 134223207 Score: 0: </h4>this fails if either inner or outer list is empty<br>------------------------------------------------------------------ <br><h3> pylang, Id: 40857703, Score: 196: </h3><p>Here is a general approach that applies to <strong>numbers</strong>, <strong>strings</strong>, <strong>nested</strong> lists and <strong>mixed</strong> containers.  This can flatten both simple and complicated containers (see also <em>Demo</em>).</p>
<p><strong>Code</strong></p>
<pre><code>from typing import Iterable 
#from collections import Iterable                            # &lt; py38


def flatten(items):
    &quot;&quot;&quot;Yield items from any nested iterable; see Reference.&quot;&quot;&quot;
    for x in items:
        if isinstance(x, Iterable) and not isinstance(x, (str, bytes)):
            for sub_x in flatten(x):
                yield sub_x
        else:
            yield x
</code></pre>
<p><em>Notes</em>:</p>
<ul>
<li>In Python 3, <code>yield from flatten(x)</code> can replace <code>for sub_x in flatten(x): yield sub_x</code></li>
<li>In Python 3.8, <a href="https://docs.python.org/3/library/collections.abc.html#module-collections.abc" rel="noreferrer">abstract base classes</a> are <a href="https://docs.python.org/3/whatsnew/3.7.html#id3" rel="noreferrer">moved</a> from <code>collection.abc</code> to the <code>typing</code> module.</li>
</ul>
<p><strong>Demo</strong></p>
<pre><code>simple = [[1, 2, 3], [4, 5, 6], [7], [8, 9]]
list(flatten(simple))
# [1, 2, 3, 4, 5, 6, 7, 8, 9]

complicated = [[1, [2]], (3, 4, {5, 6}, 7), 8, &quot;9&quot;]              # numbers, strs, nested &amp; mixed
list(flatten(complicated))
# [1, 2, 3, 4, 5, 6, 7, 8, '9']
</code></pre>
<p><strong>Reference</strong></p>
<ul>
<li>This solution is modified from a recipe in <em>Beazley, D. and B. Jones.  Recipe 4.14, Python Cookbook 3rd Ed., O'Reilly Media Inc. Sebastopol, CA: 2013.</em></li>
<li>Found an earlier <a href="https://stackoverflow.com/a/2158532/4531270">SO post</a>, possibly the original demonstration.</li>
</ul>
<h4> Martin Thoma, Comment 73124614 Score: 8: </h4>I just wrote pretty much the same, because I didn&#39;t see your solution ... here is what I looked for  &quot;recursively flatten complete multiple lists&quot; ... (+1)<br><h4> pylang, Comment 73127697 Score: 5: </h4>@MartinThoma Much appreciated.  FYI, if flattening nested iterables is a common practice for you, there are some third-party packages that handle this well.  This may save from reinventing the wheel. I&#39;ve mentioned <code>more_itertools</code> among others discussed in this post.  Cheers.<br><h4> sunnyX, Comment 99720250 Score: 0: </h4>the above code doesnt seem to work for if one of the nested lists is having a list of strings. [1, 2, [3, 4], [4], [], 9, 9.5, &#39;ssssss&#39;, [&#39;str&#39;, &#39;sss&#39;, &#39;ss&#39;], [3, 4, 5]] output:- [1, 2, 3, 4, 4, 9, 9.5, &#39;ssssss&#39;, 3, 4, 5]<br><h4> pylang, Comment 99721409 Score: 0: </h4>@sunnyX It seems to work when I try your input, even with a deeply nested list of strings, e.g. <code>list(flatten([[&quot;a&quot;, &quot;b&quot;, [&quot;c&quot;,  &quot;d&quot;, [&quot;e&quot;, &quot;f&quot;, [&quot;g&quot;]]]]]))</code> -&gt; <code>[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;, &#39;g&#39;]</code>.  What version of Python are you using?<br><h4> WestCoastProjects, Comment 120204456 Score: 0: </h4>Strings are a PITA : they act like lists when we do NOT want them to . so yes this code is needed<br><h4> Wolf, Comment 76118634 Score: 0: </h4>Maybe <code>traverse</code> could also be a good name for this way of a tree, whereas I&#39;d keep it less <i>universal</i> for this answer by sticking to nested lists.<br><h4> Ryan Allen, Comment 87226797 Score: 0: </h4>You can check <code>if hasattr(x, &#39;__iter__&#39;)</code> instead of importing/checking against <code>Iterable</code> and that will exclude strings as well.<br>------------------------------------------------------------------ <br><h3> MSeifert, Id: 40813764, Score: 120: </h3><p>To flatten a data-structure that is deeply nested, use <a href="https://iteration-utilities.readthedocs.io/en/latest/generated/deepflatten.html" rel="noreferrer"><code>iteration_utilities.deepflatten</code></a><sup>1</sup>:</p>
<pre><code>&gt;&gt;&gt; from iteration_utilities import deepflatten

&gt;&gt;&gt; l = [[1, 2, 3], [4, 5, 6], [7], [8, 9]]
&gt;&gt;&gt; list(deepflatten(l, depth=1))
[1, 2, 3, 4, 5, 6, 7, 8, 9]

&gt;&gt;&gt; l = [[1, 2, 3], [4, [5, 6]], 7, [8, 9]]
&gt;&gt;&gt; list(deepflatten(l))
[1, 2, 3, 4, 5, 6, 7, 8, 9]
</code></pre>
<p>It's a generator so you need to cast the result to a <code>list</code> or explicitly iterate over it.</p>
<hr />
<p>To flatten only one level and if each of the items is itself iterable you can also use <a href="https://iteration-utilities.readthedocs.io/en/latest/generated/flatten.html" rel="noreferrer"><code>iteration_utilities.flatten</code></a> which itself is just a thin wrapper around <a href="https://docs.python.org/library/itertools.html#itertools.chain.from_iterable" rel="noreferrer"><code>itertools.chain.from_iterable</code></a>:</p>
<pre><code>&gt;&gt;&gt; from iteration_utilities import flatten
&gt;&gt;&gt; l = [[1, 2, 3], [4, 5, 6], [7], [8, 9]]
&gt;&gt;&gt; list(flatten(l))
[1, 2, 3, 4, 5, 6, 7, 8, 9]
</code></pre>
<hr />
<p>Just to add some timings (based on <a href="https://stackoverflow.com/questions/952914/how-to-make-a-flat-list-out-of-a-list-of-lists/45323085#45323085">Nico Schlömer's answer</a> that didn't include the function presented in this answer):</p>
<p><a href="https://i.stack.imgur.com/3D8uN.png" rel="noreferrer"><img src="https://i.stack.imgur.com/3D8uN.png" alt="Enter image description here" /></a></p>
<p>It's a log-log plot to accommodate for the huge range of values spanned. For qualitative reasoning: Lower is better.</p>
<p>The results show that if the iterable contains only a few inner iterables then <code>sum</code> will be fastest, however for long iterables only the <code>itertools.chain.from_iterable</code>, <code>iteration_utilities.deepflatten</code> or the nested comprehension have reasonable performance with <code>itertools.chain.from_iterable</code> being the fastest (as already noticed by Nico Schlömer).</p>
<pre><code>from itertools import chain
from functools import reduce
from collections import Iterable  # or from collections.abc import Iterable
import operator
from iteration_utilities import deepflatten

def nested_list_comprehension(lsts):
    return [item for sublist in lsts for item in sublist]

def itertools_chain_from_iterable(lsts):
    return list(chain.from_iterable(lsts))

def pythons_sum(lsts):
    return sum(lsts, [])

def reduce_add(lsts):
    return reduce(lambda x, y: x + y, lsts)

def pylangs_flatten(lsts):
    return list(flatten(lsts))

def flatten(items):
    &quot;&quot;&quot;Yield items from any nested iterable; see REF.&quot;&quot;&quot;
    for x in items:
        if isinstance(x, Iterable) and not isinstance(x, (str, bytes)):
            yield from flatten(x)
        else:
            yield x

def reduce_concat(lsts):
    return reduce(operator.concat, lsts)

def iteration_utilities_deepflatten(lsts):
    return list(deepflatten(lsts, depth=1))


from simple_benchmark import benchmark

b = benchmark(
    [nested_list_comprehension, itertools_chain_from_iterable, pythons_sum, reduce_add,
     pylangs_flatten, reduce_concat, iteration_utilities_deepflatten],
    arguments={2**i: [[0]*5]*(2**i) for i in range(1, 13)},
    argument_name='number of inner lists'
)

b.plot()
</code></pre>
<hr />
<p><sup>1 Disclaimer: I'm the author of that library</sup></p>
------------------------------------------------------------------ <br><h3> devil in the detail, Id: 44917489, Score: 53: </h3><p>The following seems simplest to me:</p>
<pre><code>&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; l = [[1, 2, 3], [4, 5, 6], [7], [8, 9]]
&gt;&gt;&gt; print(np.concatenate(l))
[1 2 3 4 5 6 7 8 9]
</code></pre>
<h4> kylebebak, Comment 122701969 Score: 4: </h4>OP doesn&#39;t mention they want to use numpy. Python has good ways of doing this without relying on a library<br>------------------------------------------------------------------ <br><h3> pylang, Id: 40938883, Score: 50: </h3><p>Consider installing the <a href="https://github.com/erikrose/more-itertools" rel="noreferrer"><code>more_itertools</code></a> package.</p>
<pre><code>&gt; pip install more_itertools
</code></pre>
<p>It ships with an implementation for <a href="https://more-itertools.readthedocs.io/en/latest/api.html#more_itertools.flatten" rel="noreferrer"><code>flatten</code></a> (<a href="https://more-itertools.readthedocs.io/en/stable/_modules/more_itertools/recipes.html#flatten" rel="noreferrer">source</a>, from the <a href="https://docs.python.org/3/library/itertools.html#itertools-recipes" rel="noreferrer">itertools recipes</a>):</p>
<pre><code>import more_itertools


lst = [[1, 2, 3], [4, 5, 6], [7], [8, 9]]
list(more_itertools.flatten(lst))
# [1, 2, 3, 4, 5, 6, 7, 8, 9]
</code></pre>
<p><em>Note: as mentioned in the <a href="https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.flatten" rel="noreferrer">docs</a>, <code>flatten</code> requires a list of lists.  See below on flattening more irregular inputs.</em></p>
<hr />
<p>As of version 2.4, you can flatten more complicated, nested iterables with <a href="https://more-itertools.readthedocs.io/en/latest/api.html#more_itertools.collapse" rel="noreferrer"><code>more_itertools.collapse</code></a> (<a href="https://more-itertools.readthedocs.io/en/stable/_modules/more_itertools/more.html#collapse" rel="noreferrer">source</a>, contributed by  abarnet).</p>
<pre><code>lst = [[1, 2, 3], [4, 5, 6], [7], [8, 9]]
list(more_itertools.collapse(lst)) 
# [1, 2, 3, 4, 5, 6, 7, 8, 9]

lst = [[1, 2, 3], [[4, 5, 6]], [[[7]]], 8, 9]              # complex nesting
list(more_itertools.collapse(lst))
# [1, 2, 3, 4, 5, 6, 7, 8, 9]
</code></pre>
<h4> mirekphd, Comment 134138364 Score: 1: </h4>I&#39;d reverse the answer, emphasizing <code>collapse</code> over <code>flatten</code> (leaving it for special case of pure lists of lists).<br><h4> viddik13, Comment 114227872 Score: 1: </h4>also, mind that list of strings will be flattened to a list of characters<br><h4> Sajad.sni, Comment 112801523 Score: 0: </h4>it fails when all elements are not list. (e.g. lst=[1, [2,3]]). of course integer is not iterable.<br><h4> viddik13, Comment 107119592 Score: 0: </h4>If you can afford adding a package to your project - this answer is best<br>------------------------------------------------------------------ <br><h3> Igor Krivokon, Id: 952997, Score: 36: </h3><p>The reason your function didn't work is because the <em>extend</em> extends an array in-place and doesn't return it. You can still return x from lambda, using something like this:</p>

<pre><code>reduce(lambda x,y: x.extend(y) or x, l)
</code></pre>

<p>Note: extend is more efficient than + on lists.</p>
<h4> agf, Comment 9133640 Score: 9: </h4><code>extend</code> is better used as <code>newlist = []</code>, <code>extend = newlist.extend</code>, <code>for sublist in l: extend(l)</code> as it avoids the (rather large) overhead of the <code>lambda</code>, the attribute lookup on <code>x</code>, and the <code>or</code>.<br><h4> Markus Dutschke, Comment 100254746 Score: 0: </h4>for python 3 add <code>from functools import reduce</code><br>------------------------------------------------------------------ <br><h3> dtlam26, Id: 70287313, Score: 34: </h3><p>According your list <code>[[1, 2, 3], [4, 5, 6], [7], [8, 9]]</code> which is 1 list level, we can simply use <code>sum(list,[])</code> without using any libraries</p>
<pre><code>sum([[1, 2, 3], [4, 5, 6], [7], [8, 9]],[])
# [1, 2, 3, 4, 5, 6, 7, 8, 9]
</code></pre>
<p>To extend the advantage of this method when there is a tuple or number existing inside. Simply adding a mapping function for each element by <code>map</code> to the list</p>
<pre><code>#For only tuple
sum(list(map(list,[[1, 2, 3], (4, 5, 6), (7,), [8, 9]])),[])
# [1, 2, 3, 4, 5, 6, 7, 8, 9]

#In general

def convert(x):
    if type(x) is int or type(x) is float:
           return [x]
    else:
           return list(x)

sum(list(map(convert,[[1, 2, 3], (4, 5, 6), 7, [8, 9]])),[])
# [1, 2, 3, 4, 5, 6, 7, 8, 9]
</code></pre>
<p>In <a href="https://mathieularose.com/how-not-to-flatten-a-list-of-lists-in-python" rel="noreferrer">here</a>, there is a clear explanation of the drawback in terms of memory for this approach. In short, it recursively creates list objects, which should be avoided :(</p>
<h4> Uriya Harpeness, Comment 124248747 Score: 5: </h4>This answer is already up in this question: <a href="https://stackoverflow.com/a/952946/14273548">stackoverflow.com/a/952946/14273548</a><br><h4> Arel, Comment 124666065 Score: 3: </h4>Neat! Though the other answer here, <a href="https://stackoverflow.com/a/952946/14273548">stackoverflow.com/a/952946/14273548</a>, explains the reasons this solution <b>should generally be avoided</b> (it&#39;s inefficient and confusing.)<br><h4> Culpepper, Comment 125392905 Score: 2: </h4>Will also give a TypeError if your list contains a tuple<br>------------------------------------------------------------------ <br><h3> EL_DON, Id: 48569389, Score: 29: </h3><p><code>matplotlib.cbook.flatten()</code> will work for nested lists even if they nest more deeply than the example.</p>
<pre><code>import matplotlib
l = [[1, 2, 3], [4, 5, 6], [7], [8, 9]]
print(list(matplotlib.cbook.flatten(l)))
l2 = [[1, 2, 3], [4, 5, 6], [7], [8, [9, 10, [11, 12, [13]]]]]
print(list(matplotlib.cbook.flatten(l2)))
</code></pre>
<p>Result:</p>
<pre><code>[1, 2, 3, 4, 5, 6, 7, 8, 9]
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13]
</code></pre>
<p>This is 18x faster than underscore._.flatten:</p>
<pre><code>Average time over 1000 trials of matplotlib.cbook.flatten: 2.55e-05 sec
Average time over 1000 trials of underscore._.flatten: 4.63e-04 sec
(time for underscore._)/(time for matplotlib.cbook) = 18.1233394636
</code></pre>
------------------------------------------------------------------ <br><h3> mdh, Id: 38421470, Score: 22: </h3><p>One can also use NumPy's <a href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.flat.html" rel="noreferrer">flat</a>:</p>
<pre><code>import numpy as np
list(np.array(l).flat)
</code></pre>
<p>It only works when sublists have identical dimensions.</p>
------------------------------------------------------------------ <br><h3> kederrac, Id: 59913424, Score: 14: </h3><p>You can use the <code>list</code> <code>extend</code> method. It shows to be the fastest:</p>
<pre><code>flat_list = []
for sublist in l:
    flat_list.extend(sublist)
</code></pre>
<p>Performance:</p>
<pre><code>import functools
import itertools
import numpy
import operator
import perfplot


def functools_reduce_iconcat(a):
    return functools.reduce(operator.iconcat, a, [])


def itertools_chain(a):
    return list(itertools.chain.from_iterable(a))


def numpy_flat(a):
    return list(numpy.array(a).flat)


def extend(a):
    n = []

    list(map(n.extend, a))

    return n


perfplot.show(
    setup = lambda n: [list(range(10))] * n,
    kernels = [
        functools_reduce_iconcat, extend, itertools_chain, numpy_flat
        ],
    n_range = [2**k for k in range(16)],
    xlabel = 'num lists',
    )
</code></pre>
<p><strong>Output:</strong></p>
<p><a href="https://i.stack.imgur.com/xMrjA.png" rel="nofollow noreferrer"><img src="https://i.stack.imgur.com/xMrjA.png" alt="Enter image description here" /></a></p>
------------------------------------------------------------------ <br><h3> mmj, Id: 63316751, Score: 12: </h3><p>There are several answers with the same recursive appending scheme as below, but none makes use of <code>try</code>, which makes the solution more robust and <em>Pythonic</em>.</p>
<pre><code>def flatten(itr):
    for x in itr:
        try:
            yield from flatten(x)
        except TypeError:
            yield x
</code></pre>
<p><strong>Usage</strong>: this is a generator, and you typically want to enclose it in an iterable builder like <code>list()</code> or <code>tuple()</code> or use it in a <code>for</code> loop.</p>
<p>Advantages of this solution are:</p>
<ul>
<li>works with any kind of iterable (even future ones!)</li>
<li>works with any combination and deepness of nesting</li>
<li>works also if top level contains bare items</li>
<li>no dependencies</li>
<li>fast and efficient (you can flatten the nested iterable partially, without wasting time on the remaining part you don't need)</li>
<li>versatile (you can use it to build an iterable of your choice or in a loop)</li>
</ul>
<p>N.B.: Since <em>all</em> iterables are flattened, strings are decomposed into sequences of single characters. If you don't like/want such behavior, you can use the following version which filters out from flattening iterables like strings and bytes:</p>
<pre><code>def flatten(itr):
    if type(itr) in (str,bytes):
        yield itr
    else:
        for x in itr:
            try:
                yield from flatten(x)
            except TypeError:
                yield x
</code></pre>
<h4> Vladimir Vilimaitis, Comment 133454299 Score: 0: </h4>Wouldn&#39;t it be marginally faster if the tuple of types was a hash set?<br><h4> mmj, Comment 133479331 Score: 0: </h4>@VladimirVilimaitis As stated in answer, the code returns a generator, you can use it directly or create with it a sequence whose type is unrelated to the flattening process, it depends on your needs.<br>------------------------------------------------------------------ <br><h3> Brad Solomon, Id: 48569551, Score: 10: </h3><p><strong>Note</strong>: Below applies to Python 3.3+ because it uses <a href="https://docs.python.org/3/whatsnew/3.3.html" rel="noreferrer"><code>yield_from</code></a>.  <code>six</code> is also a third-party package, though it is stable.  Alternately, you could use <code>sys.version</code>.</p>

<hr>

<p>In the case of <code>obj = [[1, 2,], [3, 4], [5, 6]]</code>, all of the solutions here are good, including list comprehension and <code>itertools.chain.from_iterable</code>.</p>

<p>However, consider this slightly more complex case:</p>

<pre><code>&gt;&gt;&gt; obj = [[1, 2, 3], [4, 5], 6, 'abc', [7], [8, [9, 10]]]
</code></pre>

<p>There are several problems here:</p>

<ul>
<li>One element, <code>6</code>, is just a scalar; it's not iterable, so the above routes will fail here.</li>
<li>One element, <code>'abc'</code>, <em>is</em> technically iterable (all <code>str</code>s are).  However, reading between the lines a bit, you don't want to treat it as such--you want to treat it as a single element.</li>
<li>The final element, <code>[8, [9, 10]]</code> is itself a nested iterable.  Basic list comprehension and <code>chain.from_iterable</code> only extract "1 level down."</li>
</ul>

<p>You can remedy this as follows:</p>

<pre><code>&gt;&gt;&gt; from collections import Iterable
&gt;&gt;&gt; from six import string_types

&gt;&gt;&gt; def flatten(obj):
...     for i in obj:
...         if isinstance(i, Iterable) and not isinstance(i, string_types):
...             yield from flatten(i)
...         else:
...             yield i


&gt;&gt;&gt; list(flatten(obj))
[1, 2, 3, 4, 5, 6, 'abc', 7, 8, 9, 10]
</code></pre>

<p>Here, you check that the sub-element (1) is iterable with <a href="https://github.com/python/cpython/blob/master/Lib/_collections_abc.py#L243" rel="noreferrer"><code>Iterable</code></a>, an ABC from <code>itertools</code>, but also want to ensure that (2) the element is <em>not</em> "string-like."</p>
<h4> pylang, Comment 88869305 Score: 1: </h4>If you are still interested in Python 2 compatibility, change <code>yield from</code> to a <code>for</code> loop, e.g. <code>for x in flatten(i): yield x</code><br>------------------------------------------------------------------ <br><h3> mkultra, Id: 40275594, Score: 8: </h3><p>If you are willing to give up a tiny amount of speed for a cleaner look, then you could use <code>numpy.concatenate().tolist()</code> or <code>numpy.concatenate().ravel().tolist()</code>:</p>
<pre><code>import numpy

l = [[1, 2, 3], [4, 5, 6], [7], [8, 9]] * 99

%timeit numpy.concatenate(l).ravel().tolist()
1000 loops, best of 3: 313 µs per loop

%timeit numpy.concatenate(l).tolist()
1000 loops, best of 3: 312 µs per loop

%timeit [item for sublist in l for item in sublist]
1000 loops, best of 3: 31.5 µs per loop
</code></pre>
<p>You can find out more here in the documentation, <a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.concatenate.html" rel="nofollow noreferrer">numpy.concatenate</a> and <a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ravel.html" rel="nofollow noreferrer">numpy.ravel</a>.</p>
<h4> EL_DON, Comment 98271614 Score: 2: </h4>Doesn&#39;t work for unevenly nested lists like <code>[1, 2, [3], [[4]], [5, [6]]]</code><br><h4> EL_DON, Comment 121283549 Score: 0: </h4>@juanpa.arrivillaga it&#39;s a simple and natural extension of the question, though. Answers that can handle greater depth of nesting are more likely to be useful to someone who finds this question.<br>------------------------------------------------------------------ <br><h3> englealuze, Id: 45571781, Score: 5: </h3><pre><code>def flatten(alist):
    if alist == []:
        return []
    elif type(alist) is not list:
        return [alist]
    else:
        return flatten(alist[0]) + flatten(alist[1:])
</code></pre>
<h4> EL_DON, Comment 98271527 Score: 0: </h4>Fails for python2.7 for the example nested list in the question: <code>[[1, 2, 3], [4, 5, 6], [7], [8, 9]]</code><br>------------------------------------------------------------------ <br><h3> phoxis, Id: 50367409, Score: 4: </h3><p>This may not be the most efficient way, but I thought to put a one-liner (actually a two-liner). Both versions will work on arbitrary hierarchy nested lists, and exploits language features (Python 3.5) and recursion.</p>
<pre><code>def make_list_flat (l):
    flist = []
    flist.extend ([l]) if (type (l) is not list) else [flist.extend (make_list_flat (e)) for e in l]
    return flist

a = [[1, 2], [[[[3, 4, 5], 6]]], 7, [8, [9, [10, 11], 12, [13, 14, [15, [[16, 17], 18]]]]]]
flist = make_list_flat(a)
print (flist)
</code></pre>
<p>The output is</p>
<pre><code>[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18]
</code></pre>
<p>This works in a depth first manner. The recursion goes down until it finds a non-list element, then extends the local variable <code>flist</code> and then rolls back it to the parent. Whenever <code>flist</code> is returned, it is extended to the parent's <code>flist</code> in the list comprehension. Therefore, at the root, a flat list is returned.</p>
<p>The above one creates several local lists and returns them which are used to extend the parent's list. I think the way around for this may be creating a gloabl <code>flist</code>, like below.</p>
<pre><code>a = [[1, 2], [[[[3, 4, 5], 6]]], 7, [8, [9, [10, 11], 12, [13, 14, [15, [[16, 17], 18]]]]]]
flist = []
def make_list_flat (l):
    flist.extend ([l]) if (type (l) is not list) else [make_list_flat (e) for e in l]

make_list_flat(a)
print (flist)
</code></pre>
<p>The output is again</p>
<pre><code>[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18]
</code></pre>
<p>Although I am not sure at this time about the efficiency.</p>
<h4> Maciek, Comment 108142281 Score: 2: </h4>Why extend([l]) instead of append(l)?<br>------------------------------------------------------------------ <br><h3> Alon Gouldman, Id: 69485553, Score: 4: </h3><p>I wanted a solution which can deal with multiple nesting (<code>[[1], [[[2]], [3]]], [1, 2, 3]</code> for example), but would also not be recursive (I had a big level of recursion and I got a recursion error.</p>
<p>This is what I came up with:</p>
<pre><code>def _flatten(l) -&gt; Iterator[Any]:
    stack = l.copy()
    while stack:
        item = stack.pop()
        if isinstance(item, list):
            stack.extend(item)
        else:
            yield item


def flatten(l) -&gt; Iterator[Any]:
    return reversed(list(_flatten(l)))
</code></pre>
<p>and tests:</p>
<pre><code>@pytest.mark.parametrize('input_list, expected_output', [
    ([1, 2, 3], [1, 2, 3]),
    ([[1], 2, 3], [1, 2, 3]),
    ([[1], [2], 3], [1, 2, 3]),
    ([[1], [2], [3]], [1, 2, 3]),
    ([[1], [[2]], [3]], [1, 2, 3]),
    ([[1], [[[2]], [3]]], [1, 2, 3]),
])
def test_flatten(input_list, expected_output):
    assert list(flatten(input_list)) == expected_output
</code></pre>
------------------------------------------------------------------ <br><h3> tharndt, Id: 48170454, Score: 2: </h3><p>Another unusual approach that works for hetero- and homogeneous lists of integers:</p>

<pre><code>from typing import List


def flatten(l: list) -&gt; List[int]:
    """Flatten an arbitrary deep nested list of lists of integers.

    Examples:
        &gt;&gt;&gt; flatten([1, 2, [1, [10]]])
        [1, 2, 1, 10]

    Args:
        l: Union[l, Union[int, List[int]]

    Returns:
        Flatted list of integer
    """
    return [int(i.strip('[ ]')) for i in str(l).split(',')]
</code></pre>
<h4> Darkonaut, Comment 83465577 Score: 0: </h4>Can you tell us which book? I contemplated a lot about this because it&#39;s so effective and beautiful. Will hit recursion limit inevitably in general but for cases like this with few recursions it seems perfect.<br><h4> tharndt, Comment 83500849 Score: 2: </h4>Unfortunately no. But I saw this code recently here: <a href="http://anandology.com/python-practice-book/functional-programming.html" rel="nofollow noreferrer">Python Practice Book</a> 6.1.2<br><h4> Darkonaut, Comment 83404760 Score: 1: </h4>You are indeed right +1, ᴡʜᴀᴄᴋᴀᴍᴀᴅᴏᴏᴅʟᴇ3000&#39;s proposal won&#39;t work with multiple digit numbers, I also didn&#39;t test this before although it should be obvious. You could simplify your code and write <code>[int(e.strip(&#39;[ ]&#39;)) for e in str(deep_list).split(&#39;,&#39;)]</code>. But I&#39;d suggest to stick with Deleet&#39;s proposal for real use cases. It doesn&#39;t contain hacky type transformations, it&#39;s faster and more versatile because it naturally also handles lists with mixed types.<br><h4> Darkonaut, Comment 83374712 Score: 0: </h4>That&#39;s just a more complicated and a bit slower way of what ᴡʜᴀᴄᴋᴀᴍᴀᴅᴏᴏᴅʟᴇ3000 already posted before. I reinvented his proposal yesterday, so this approach seems quite popular these days ;)<br><h4> tharndt, Comment 83385783 Score: 0: </h4>Not quite:  <code>wierd_list = [[1, 2, 3], [4, 5, 6], [7], [8, 9], 10]</code> &gt;&gt; <code>nice_list=[1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 0]</code><br><h4> tharndt, Comment 83386255 Score: 0: </h4>my code as one liner would be :  <code>flat_list = [int(e.replace(&#39;[&#39;,&#39;&#39;).replace(&#39;]&#39;,&#39;&#39;)) for e in str(deep_list).split(&#39;,&#39;)]</code><br>------------------------------------------------------------------ <br><h3> Vincent Aranega, Id: 71468284, Score: 2: </h3><p>Not a one-liner, but seeing all the answers here, I guess this long list missed some pattern matching, so here it is :)</p>
<p>The two methods are probably not efficient, but anyway, it's easy to read (to me at least; perhaps I'm spoiled by functional programming):</p>
<pre class="lang-py prettyprint-override"><code>def flat(x):
    match x:
        case []:
            return []
        case [[*sublist], *r]:
            return [*sublist, *flat(r)]
</code></pre>
<p>The second version considers lists of lists of lists... whatever the nesting:</p>
<pre class="lang-py prettyprint-override"><code>def flat(x):
    match x:
        case []:
            return []
        case [[*sublist], *r]:
            return [*flat(sublist), *flat(r)]
        case [h, *r]:
            return [h, *flat(r)]
</code></pre>
------------------------------------------------------------------ <br><h3> Letsios Matthaios, Id: 73106867, Score: 2: </h3><p>If you want to unnest everything and keep a distinct list of elements, you could use this as well.</p>
<pre class="lang-py prettyprint-override"><code>list_of_lists = [[1,2], [2,3], [3,4]]
list(set.union(*[set(s) for s in list_of_lists]))
</code></pre>
------------------------------------------------------------------ <br><h3> user7864386, Id: 70285413, Score: 1: </h3><p>A non-recursive function to flatten lists of lists of any depth:</p>
<pre><code>def flatten_list(list1):
    out = []
    inside = list1
    while inside:
        x = inside.pop(0)
        if isinstance(x, list):
            inside[0:0] = x
        else:
            out.append(x)
    return out

l = [[[1,2],3,[4,[[5,6],7],[8]]],[9,10,11]]
flatten_list(l)
# [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]
</code></pre>
------------------------------------------------------------------ <br><h3> Vasantha Ganesh, Id: 74069856, Score: 1: </h3><p>If you have a numpy array <code>a</code>:</p>
<pre><code>a = np.array([[1,2], [3,4]])
a.flatten('C')
</code></pre>
<p>produces:</p>
<pre><code>[1, 2, 3, 4]
</code></pre>
<p><code>np.flatten</code> also accepts other parameters:</p>
<ul>
<li><code>C</code>:</li>
<li><code>F</code></li>
<li><code>A</code></li>
<li><code>K</code></li>
</ul>
<p>More details about parameters are available <a href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.flatten.html" rel="nofollow noreferrer">here</a>.</p>
<h4> Alexander, Comment 134138759 Score: 3: </h4>This answer only works for rectangular array (matrix) structures and not when the lengths of contained lists are not equal.<br>------------------------------------------------------------------ <br><h3> Alain T., Id: 75806647, Score: 1: </h3><p>Here's an approach I didn't see in the other answers. It supports any level of nesting, works iteratively and without libraries:</p>
<pre><code>mylist = [[1,2,4,5],[[0,8,9],5,7],[3,11,[44,45,46],25]]

for i,_ in enumerate(mylist):          # indexes, including extended positions
    while isinstance(mylist[i],list):  # drill down/extend current position
        mylist[i:i+1] = mylist[i]      # as long as item is a list

print(mylist)
[1, 2, 4, 5, 0, 8, 9, 5, 7, 3, 11, 44, 45, 46, 25]
</code></pre>
<h4> Ry-, Comment 133721941 Score: 0: </h4>Nice not to use stack, but it has very bad time complexity.<br>------------------------------------------------------------------ <br><h3> S.B, Id: 70669715, Score: 0: </h3><p>If I want to add something to the great previous answers, here is my recursive <code>flatten</code> function which can flatten not only nested lists, but also any given container or any generally any object which can throw out items. This does also work for any depth of nesting and it is a lazy iterator which yields the items as requested:</p>
<pre class="lang-py prettyprint-override"><code>def flatten(iterable):
    # These types won't considered a sequence or generally a container
    exclude = str, bytes

    for i in iterable:
        try:
            if isinstance(i, exclude):
                raise TypeError
            iter(i)
        except TypeError:
            yield i
        else:
            yield from flatten(i)
</code></pre>
<p>This way, you can exclude types you don't want to be flattened, like <code>str</code> or what else.</p>
<p>The idea is if an object can pass the <code>iter()</code> it's ready to yield items. So the iterable can have even generator expressions as an item.</p>
<p>Someone could argue: Why did you write this that generic when the OP didn't ask for it? OK, you're right. I just felt like this might help someone (like it did for myself).</p>
<p>Test cases:</p>
<pre class="lang-py prettyprint-override"><code>lst1 = [1, {3}, (1, 6), [[3, 8]], [[[5]]], 9, ((((2,),),),)]
lst2 = ['3', B'A', [[[(i ** 2 for i in range(3))]]], range(3)]

print(list(flatten(lst1)))
print(list(flatten(lst2)))
</code></pre>
<p>Output:</p>
<pre class="lang-none prettyprint-override"><code>[1, 3, 1, 6, 3, 8, 5, 9, 2]
['3', b'A', 0, 1, 4, 0, 1, 2]
</code></pre>
------------------------------------------------------------------ <br><h3> Vova, Id: 72250465, Score: 0: </h3><p>I would suggest using generators with <strong>yield</strong> statement and <strong>yield from</strong>.
Here's an example:</p>
<pre><code>from collections.abc import Iterable

def flatten(items, ignore_types=(bytes, str)):
    &quot;&quot;&quot;
       Flatten all of the nested lists to the one. Ignoring flatting of iterable types str and bytes by default.
    &quot;&quot;&quot;
    for x in items:
        if isinstance(x, Iterable) and not isinstance(x, ignore_types):
            yield from flatten(x)
        else:
            yield x

values = [7, [4, 3, 5, [7, 3], (3, 4), ('A', {'B', 'C'})]]

for v in flatten(values):
    print(v)
</code></pre>
------------------------------------------------------------------ <br><h3> X0-user-0X, Id: 73304338, Score: 0: </h3><p>For a list containing multiple list here a recursive solution that work for me and that i hope is correct:</p>
<pre><code># Question 4
def flatten(input_ls=[]) -&gt; []:
    res_ls = []
    res_ls = flatten_recursive(input_ls, res_ls)

    print(&quot;Final flatten list solution is: \n&quot;, res_ls)

    return res_ls


def flatten_recursive(input_ls=[], res_ls=[]) -&gt; []:
    tmp_ls = []

    for i in input_ls:
        if isinstance(i, int):
            res_ls.append(i)
        else:
            tmp_ls = i
            tmp_ls.append(flatten_recursive(i, res_ls))

    print(res_ls)
    return res_ls


flatten([0, 1, [2, 3], 4, [5, 6]])  # test
flatten([0, [[[1]]], [[2, 3], [4, [[5, 6]]]]])
</code></pre>
<p>Output:</p>
<pre><code>[0, 1, 2, 3]
[0, 1, 2, 3, 4, 5, 6]
[0, 1, 2, 3, 4, 5, 6]
Final flatten list solution is: 
 [0, 1, 2, 3, 4, 5, 6]
[0, 1]
[0, 1]
[0, 1]
[0, 1, 2, 3]
[0, 1, 2, 3, 4, 5, 6]
[0, 1, 2, 3, 4, 5, 6]
[0, 1, 2, 3, 4, 5, 6]
[0, 1, 2, 3, 4, 5, 6]
[0, 1, 2, 3, 4, 5, 6]
Final flatten list solution is: 
 [0, 1, 2, 3, 4, 5, 6]
</code></pre>
------------------------------------------------------------------ <br><h3> B.R., Id: 75709744, Score: 0: </h3><p>I like to add a high performant generator solution which can fatten nested lists (or any kind of iterable) of <strong>any depth</strong> not (only 2D-lists):</p>
<pre><code>from itertools import chain

def flatten_deep_generator(iterable):
    iterator = iter(iterable)
    try:
        while 1: # StopIteration will break the loop
            item = next(iterator)
            # check if item contains sub-items
            if not hasattr(item,'__trunc__'):
                iterator = chain(iter(item), iterator)
            else:
                yield item
    except StopIteration:
        pass
</code></pre>
<p>Depending on your needs a generators have huge advantages over lists. E.g. If you want add <code>filter()</code> functions afterwards. The resulting list should be instanced only at the end after you have constructed the full generator incl. the filtering by this you avoid multiple iterations over the items.</p>
<p>Remark: Compaired to the other proposed generator solution this is an iterative and not a recursive solution which avoids RecursionErrors in case of deep nested iterables.</p>
<h4> Nik O&#39;Lai, Comment 134992669 Score: 0: </h4>what is the role of <code>__trunc__</code> in this &quot;high performant generator solution&quot;? and why<br><h4> B.R., Comment 135012463 Score: 0: </h4>The <code>__trunc__</code> attribute is used to identify a numerical item or in other words a no more iterable item.  It can be that we have some cornercases not covered then you must switch to the slower but more secured way: <code>hastattr(item,&#39;__iter__&#39;) or hasattr(item,&#39;__next__&#39;)</code> The solution should work on any iterable object so we cannot use a checlk like <code>type(item) is list</code>. E.g. the solution works on nested iterators, tuples and even strings would be flattend to single characters.<br>------------------------------------------------------------------ <br><h3> BhushanD, Id: 71718885, Score: -2: </h3><p>Considering the list has just integers:</p>
<pre><code>import re
l = [[1, 2, 3], [4, 5, 6], [7], [8, 9]]
list(map(int,re.sub('(\[|\])','',str(l)).split(',')))
</code></pre>
------------------------------------------------------------------ <br><h3> Hans, Id: 73576067, Score: -6: </h3><p>I created a little function which can basically flatten anything.
You can get it with pip: <strong>pip install flatten-everything</strong></p>
<pre><code>from flatten_everything import flatten_everything
withoutprotection=list(
    flatten_everything(
        [
            1,
            1,
            2,
            [3, 4, 5, [6, 3, [2, 5, [&quot;sfs&quot;, &quot;sdfsfdsf&quot;,]]]],
            1,
            3,
            34,
            [
                55,
                {&quot;brand&quot;: &quot;Ford&quot;, &quot;model&quot;: &quot;Mustang&quot;, &quot;year&quot;: 1964, &quot;yearxx&quot;: 2020},
                pd.DataFrame({&quot;col1&quot;: [1, 2], &quot;col2&quot;: [3, 4]}),
                {&quot;col1&quot;: [1, 2], &quot;col2&quot;: [3, 4]},
                55,
                {&quot;k32&quot;, 34},
                np.array([[[1, 2], [3, 4]], [[5, 6], [7, 8]]]),
                (np.arange(22), np.eye(2, 2), 33),
            ],
        ]
    )
)
print(withoutprotection)
output:
[1, 1, 2, 3, 4, 5, 6, 3, 2, 5, 'sfs', 'sdfsfdsf', 1, 3, 34, 55, 'Ford', 'Mustang', 1964, 2020, 1, 2, 3, 4, 1, 2, 3, 4, 55, 34, 'k32', 1, 2, 3, 4, 5, 6, 7, 8, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 1.0, 0.0, 0.0, 1.0, 33]
</code></pre>
<p>You can even protect objects from getting flattened:</p>
<pre><code>from flatten_everything import ProtectedDict,ProtectedList,ProtectedTuple
withprotection=list(
    flatten_everything(
        [
            1,
            1,
            2,
            [3, 4, 5, [6, 3, [2, 5, ProtectedList([&quot;sfs&quot;, &quot;sdfsfdsf&quot;,])]]],
            1,
            3,
            34,
            [
                55,
                ProtectedDict({&quot;brand&quot;: &quot;Ford&quot;, &quot;model&quot;: &quot;Mustang&quot;, &quot;year&quot;: 1964, &quot;yearxx&quot;: 2020}),
                pd.DataFrame({&quot;col1&quot;: [1, 2], &quot;col2&quot;: [3, 4]}),
                {&quot;col1&quot;: [1, 2], &quot;col2&quot;: [3, 4]},
                55,
                {&quot;k32&quot;, 34},
                np.array([[[1, 2], [3, 4]], [[5, 6], [7, 8]]]),
                ProtectedTuple((np.arange(22), np.eye(2, 2), 33)),
            ],
        ]
    )
)
print(withprotection)
output:
[1, 1, 2, 3, 4, 5, 6, 3, 2, 5, ['sfs', 'sdfsfdsf'], 1, 3, 34, 55, {'brand': 'Ford', 'model': 'Mustang', 'year': 1964, 'yearxx': 2020}, 1, 2, 3, 4, 1, 2, 3, 4, 55, 34, 'k32', 1, 2, 3, 4, 5, 6, 7, 8, (array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16,17, 18, 19, 20, 21]), array([[1., 0.], [0., 1.]]), 33)]
</code></pre>
