 <h2> Title: How do I pass a variable by reference? </h2> <h3> David Sykes, question_id: 986006 </h3>Score: 3283, Tags: {python,reference,parameter-passing,pass-by-reference} <br><p>I wrote this class for testing:</p>
<pre><code>class PassByReference:
    def __init__(self):
        self.variable = 'Original'
        self.change(self.variable)
        print(self.variable)

    def change(self, var):
        var = 'Changed'
</code></pre>
<p>When I tried creating an instance, the output was <code>Original</code>. So it seems like parameters in Python are passed by value. Is that correct? How can I modify the code to get the effect of pass-by-reference, so that the output is <code>Changed</code>?</p>
<hr />
<p><sub>Sometimes people are surprised that code like <code>x = 1</code>, where <code>x</code> is a parameter name, doesn't impact on the caller's argument, but code like <code>x[0] = 1</code> does. This happens because <em>item assignment</em> and <em>slice assignment</em> are ways to <strong>mutate</strong> an existing object, rather than reassign a variable, despite the <code>=</code> syntax. See <a href="https://stackoverflow.com/questions/575196/">Why can a function modify some arguments as perceived by the caller, but not others?</a> for details.</sub></p>
<p><sub>See also <a href="https://stackoverflow.com/questions/373419/">What&#39;s the difference between passing by reference vs. passing by value?</a> for important, language-agnostic terminology discussion.</sub></p>
<h4> Comment 18288970 lqc: </h4>Before reading the selected answer, please consider reading this short text <a href="http://python.net/~goodger/projects/pycon/2007/idiomatic/handout.html#other-languages-have-variables" rel="nofollow noreferrer">Other languages have &quot;variables&quot;, Python has &quot;names&quot;</a>. Think about &quot;names&quot; and &quot;objects&quot; instead of &quot;variables&quot; and &quot;references&quot; and you should avoid a lot of similar problems.<br><h4> Comment 20442132 PhilS: </h4>For a short explanation/clarification see the first answer to <a href="http://stackoverflow.com/questions/534375/passing-values-in-python">this stackoverflow question</a>. As strings are immutable, they won&#39;t be changed and a new variable will be created, thus the &quot;outer&quot; variable still has the same value.<br><h4> Comment 110167008 Ray Hulha: </h4>New official how of Iqc&#39;s link: <a href="https://david.goodger.org/projects/pycon/2007/idiomatic/handout.html#other-languages-have-variables" rel="nofollow noreferrer">david.goodger.org/projects/pycon/2007/idiomatic/&hellip;</a><br><h4> Comment 10928917 Ethan Furman: </h4>The code in BlairConrad&#39;s answer is good, but the explanation provided by DavidCournapeau and DarenThomas is correct.<br><h4> Comment 108578216 Abraham Sangha: </h4>Working link: <a href="https://web.archive.org/web/20180411011411/http://python.net/~goodger/projects/pycon/2007/idiomatic/handout.html#other-languages-have-variables" rel="nofollow noreferrer">Other languages have &quot;variables&quot;, Python has &quot;names&quot;</a><br><h4> Comment 42135694 robert: </h4>another workaround is to create a wrapper &#39;reference&#39; like this: ref = type(&#39;&#39;, (), {&#39;n&#39;:1}) <a href="http://stackoverflow.com/a/1123054/409638">stackoverflow.com/a/1123054/409638</a><br><h4> Comment 58049934 Terry Jan Reedy: </h4>For global names, pass by reference can be simulated by passing the name as a string and using globals().  <code>def change(s): globals()[s] = &#39;changed&#39;</code> followed by <code>a = &#39;orig&#39;; change(&#39;a&#39;); print(a)</code> prints <code>&#39;changed&#39;</code>.<br><h4> Comment 65976371 Elazar: </h4>Python has variables. There&#39;s no conceptual problem with this term at all, and it is in common use.<br><h4> Comment 125230684 juanpa.arrivillaga: </h4>@Naren no, it <i>doesn&#39;t behave like either call by reference or call by value</i>. Assignment to a parameter, regardless of the type used, will <b>never</b> be seen in the caller, therefore it is not call by reference. Similarly, objects <i>are not copied</i>, again, regardless of the type used, when they are passed in to a function, that is why mutator methods will affect those objects everywhere they are referenced.<br><h4> Comment 118134906 Naren: </h4>I come from C# &amp; am trying to understand the question better. In Python everything is an object and objects can be mutable or immutable. The code here uses &quot;string&quot; which is an immutable object and attempting to change it within function scope is not going to change caller&#39;s value (behaves like pass-by-value) &amp; if the code used a mutable custom class object - changing within function scope will change the caller&#39;s value (behaves like pass-by-ref). You&#39;ll see the exact same end result in C# (but the way it achieves is pass-by-value/ref). So isn&#39;t the net effect same? so isn&#39;t the question moot?<br><h4> Comment 118996396 KulaGGin: </h4>@PeterR because OOP &gt; 70s programming without classes and objects. It&#39;s just easier to write and understand programs when it&#39;s object-oriented. I think everything in the Universe can be represented as an object, even non-existing in real life programming concepts.<br><h4> Comment 132535017 Karl Knechtel: </h4>The original version of this question said something about the documentation being unclear on this point. I wish I knew what part of the documentation was being referenced, exactly. The documentation for 2.6 includes <a href="https://docs.python.org/2.6/faq/programming.html#how-do-i-write-a-function-with-output-parameters-call-by-reference" rel="nofollow noreferrer">a detailed section on this exact topic</a>, but I can&#39;t tell for sure when it was added.<br><h4> Comment 103315821 gseattle: </h4>For the dataframe named &#39;bob&#39; (from a string variable, and that&#39;s the tricky part), give me its current contents. Should be easy. Sadly I&#39;m not getting it.<br><h4> Comment 64551220 MrRolling: </h4>Some immutable types:     {int, float, long, complex, str, bytes, tuple, frozen set}  Some mutable types:     {byte array, list, set, dict}<br><h4> Comment 75161544 akki: </h4><a href="https://jeffknupp.com/blog/2012/11/13/is-python-callbyvalue-or-callbyreference-neither/" rel="nofollow noreferrer">jeff Knupp&#39;s blog</a> and <a href="http://stupidpythonideas.blogspot.in/2013/11/does-python-pass-by-value-or-by.html" rel="nofollow noreferrer">stupidpythonideas</a> are some good explanations for this.<br>------------------------------------------------------------------ <br><h3> Answer 986145 Blair Conrad: </h3><p>Arguments are <a href="http://docs.python.org/3/faq/programming.html#how-do-i-write-a-function-with-output-parameters-call-by-reference" rel="noreferrer">passed by assignment</a>. The rationale behind this is twofold:</p>

<ol>
<li>the parameter passed in is actually a <em>reference</em> to an object (but the reference is passed by value)</li>
<li>some data types are mutable, but others aren't</li>
</ol>

<p>So:</p>

<ul>
<li><p>If you pass a <em>mutable</em> object into a method, the method gets a reference to that same object and you can mutate it to your heart's delight, but if you rebind the reference in the method, the outer scope will know nothing about it, and after you're done, the outer reference will still point at the original object. </p></li>
<li><p>If you pass an <em>immutable</em> object to a method, you still can't rebind the outer reference, and you can't even mutate the object.</p></li>
</ul>

<p>To make it even more clear, let's have some examples. </p>

<h2>List - a mutable type</h2>

<p><strong>Let's try to modify the list that was passed to a method:</strong></p>

<pre><code>def try_to_change_list_contents(the_list):
    print('got', the_list)
    the_list.append('four')
    print('changed to', the_list)

outer_list = ['one', 'two', 'three']

print('before, outer_list =', outer_list)
try_to_change_list_contents(outer_list)
print('after, outer_list =', outer_list)
</code></pre>

<p>Output:</p>

<pre class="lang-none prettyprint-override"><code>before, outer_list = ['one', 'two', 'three']
got ['one', 'two', 'three']
changed to ['one', 'two', 'three', 'four']
after, outer_list = ['one', 'two', 'three', 'four']
</code></pre>

<p>Since the parameter passed in is a reference to <code>outer_list</code>, not a copy of it, we can use the mutating list methods to change it and have the changes reflected in the outer scope.</p>

<p><strong>Now let's see what happens when we try to change the reference that was passed in as a parameter:</strong></p>

<pre><code>def try_to_change_list_reference(the_list):
    print('got', the_list)
    the_list = ['and', 'we', 'can', 'not', 'lie']
    print('set to', the_list)

outer_list = ['we', 'like', 'proper', 'English']

print('before, outer_list =', outer_list)
try_to_change_list_reference(outer_list)
print('after, outer_list =', outer_list)
</code></pre>

<p>Output:</p>

<pre class="lang-none prettyprint-override"><code>before, outer_list = ['we', 'like', 'proper', 'English']
got ['we', 'like', 'proper', 'English']
set to ['and', 'we', 'can', 'not', 'lie']
after, outer_list = ['we', 'like', 'proper', 'English']
</code></pre>

<p>Since the <code>the_list</code> parameter was passed by value, assigning a new list to it had no effect that the code outside the method could see. The <code>the_list</code> was a copy of the <code>outer_list</code> reference, and we had <code>the_list</code> point to a new list, but there was no way to change where <code>outer_list</code> pointed.</p>

<h2>String - an immutable type</h2>

<p><strong>It's immutable, so there's nothing we can do to change the contents of the string</strong></p>

<p><strong>Now, let's try to change the reference</strong></p>

<pre><code>def try_to_change_string_reference(the_string):
    print('got', the_string)
    the_string = 'In a kingdom by the sea'
    print('set to', the_string)

outer_string = 'It was many and many a year ago'

print('before, outer_string =', outer_string)
try_to_change_string_reference(outer_string)
print('after, outer_string =', outer_string)
</code></pre>

<p>Output:</p>

<pre class="lang-none prettyprint-override"><code>before, outer_string = It was many and many a year ago
got It was many and many a year ago
set to In a kingdom by the sea
after, outer_string = It was many and many a year ago
</code></pre>

<p>Again, since the <code>the_string</code> parameter was passed by value, assigning a new string to it had no effect that the code outside the method could see. The <code>the_string</code> was a copy of the <code>outer_string</code> reference, and we had <code>the_string</code> point to a new string, but there was no way to change where <code>outer_string</code> pointed.</p>

<p>I hope this clears things up a little.</p>

<p><strong>EDIT:</strong> It's been noted that this doesn't answer the question that @David originally asked, "Is there something I can do to pass the variable by actual reference?". Let's work on that.</p>

<h2>How do we get around this?</h2>

<p>As @Andrea's answer shows, you could return the new value. This doesn't change the way things are passed in, but does let you get the information you want back out:</p>

<pre><code>def return_a_whole_new_string(the_string):
    new_string = something_to_do_with_the_old_string(the_string)
    return new_string

# then you could call it like
my_string = return_a_whole_new_string(my_string)
</code></pre>

<p>If you really wanted to avoid using a return value, you could create a class to hold your value and pass it into the function or use an existing class, like a list:</p>

<pre><code>def use_a_wrapper_to_simulate_pass_by_reference(stuff_to_change):
    new_string = something_to_do_with_the_old_string(stuff_to_change[0])
    stuff_to_change[0] = new_string

# then you could call it like
wrapper = [my_string]
use_a_wrapper_to_simulate_pass_by_reference(wrapper)

do_something_with(wrapper[0])
</code></pre>

<p>Although this seems a little cumbersome.</p>
<h4> Comment 794601 Andrea Ambu: </h4>Then the same is in C, when you pass &quot;by reference&quot; you&#39;re actually passing <i>by value</i> the reference... Define &quot;by reference&quot; :P<br><h4> Comment 794645 Blair Conrad: </h4>I&#39;m not sure I understand your terms. I&#39;ve been out of the C game for a while, but back when I was in it, there was no &quot;pass by reference&quot; - you could pass things, and it was always pass by value, so whatever was in the parameter list was copied. But sometimes the thing was a pointer, which one could follow to the piece of memory (primitive, array, struct, whatever), but you couldn&#39;t change the pointer that was copied from the outer scope - when you were done with the function, the original pointer still pointed to the same address. C++ introduced references, which behaved differently.<br><h4> Comment 10928887 Ethan Furman: </h4>-1. The code shown is good, the explanation as to how is completely wrong.  See the answers by DavidCournapeau or DarenThomas for correct explanations as to why.<br><h4> Comment 8874950 Cam Jackson: </h4>@Zac Bowling I don&#39;t really get how what you&#39;re saying is relevant, in a practical sense, to this answer. If a Python newcomer wanted to know about passing by ref/val, then the takeaway from this answer is: <b>1-</b> You <i>can</i> use the reference that a function receives as its arguments, to modify the &#39;outside&#39; value of a variable, as long as you don&#39;t reassign the parameter to refer to a new object. <b>2-</b> Assigning to an immutable type will <i>always</i> create a new object, which breaks the reference that you had to the outside variable.<br><h4> Comment 9988567 Mark Ransom: </h4>@CamJackson, you need a better example - numbers are also immutable objects in Python. Besides, wouldn&#39;t it be true to say that <i>any</i> assignment without subscripting on the left side of the equals will reassign the name to a new object whether it is immutable or not? <code>def Foo(alist): alist = [1,2,3]</code> will <b>not</b> modify the contents of the list from the callers perspective.<br><h4> Comment 9988724 Mark Ransom: </h4>@BlairConrad, passing &quot;by reference&quot; in C is just a commonly recognized convention whereby you pass the pointer to something rather than the value of something. In that respect it behaves exactly like Python: you may update the value pointed to by the pointer but updating the pointer itself has no effect outside the function, since the pointer was passed by value.<br><h4> Comment 29836434 Richard Fung: </h4>@Lennart Regebro, just because the value is a reference to something doesn&#39;t make it pass by reference. In C++ you can actually pass by reference, and when you do, if you reassign the reference, the parameter you passed will actually be modified. In Python, if you try to reassign the parameter you will just be changing the mapping of the name in the namespace of your function, something which is fundamentally different.  Still, the whole idea of pass by reference is so screwed up now because everyone is using it to describe a different thing.<br><h4> Comment 8870135 Zac Bowling: </h4>@Cam Jackson actually it&#39;s not relevant. Passing by reference means giving the ability to change the pointer that the calling reference was using. Talking about changing the data the destination of that pointer adds confusion and just an implementation detail.<br><h4> Comment 23429390 Lennart Regebro: </h4>Oh, that&#39;s sad. &quot;It&#39;s passed by value, but the value is a reference&quot;. Sigh. Well, <i>everything</i> is a value. When the value is a reference, that&#39;s pass by reference. The difference in Python is minimal as Pythons variables aren&#39;t like C&#39;s variables, but calling it pass by value is definitely incorrect.<br><h4> Comment 4931966 Zac Bowling: </h4>bring up mutability is just adding confusion. it actually doesn&#39;t have anything to with the issue. you state it correct at first in that you can change the reference for something not in your scope (like a pointer pointer).<br><h4> Comment 8816540 Cam Jackson: </h4>@Zac Bowling Mutability is totally relevant. If strings were mutable, then the first string example would have a different output. It&#39;s important to know that setting the value of a passed-in string will create a new string object, not modify the passed one. Mutability is what prevents a string argument from behaving the same as say, an integer argument in this case.<br><h4> Comment 32792158 Honest Abe: </h4><i>&quot;...parameter passed in...&quot;</i> is incorrect use of terminology. A <a href="http://docs.python.org/3/glossary.html#term-parameter" rel="nofollow noreferrer">parameter</a> is a named entity in a function (or method) definition that specifies an argument (or in some cases, arguments) that the function can accept. An <a href="http://docs.python.org/3/glossary.html#term-argument" rel="nofollow noreferrer">argument</a> is a value passed to a function (or method) when calling the function.<br><h4> Comment 795404 David Cournapeau: </h4>@andrea, not it is not like C at all. Conrad is correct, but the terms reference/values are confusing in python. That&#39;s why you should really use another term (see my link to effbot for a good explanation)<br><h4> Comment 117763907 juanpa.arrivillaga: </h4>@HappyAhmad it absolutely <i>is</i> different to call by reference. If Python supported call by reference, you could do something like <code>def foo(&amp;var): var = 2</code> then <code>x = 0; y = 1; foo(x); foo(y)</code> then <code>print(x, y)</code> would print <code>2 2</code><br><h4> Comment 30279774 Richard Fung: </h4>@Lennart Regebro: I realize that, but in the end you could also consider Python to be pass by value with the values being references. Of course, that is why I added that last line anyway. Defining terms to mean different things for different languages is by all means useless, because the whole point of defining those terms is to make it clear what you are saying.<br><h4> Comment 30286887 Lennart Regebro: </h4>This answer is hence factually incorrect, and have been upvotes as &quot;thanks&quot; by newbies who don&#39;t understand the internals of Python. Which is why it makes me sad.<br><h4> Comment 30480352 Richard Fung: </h4>@Lennart Regebro &quot;it is a reference passed as a value the type is a reference/pointer and you would have to dereference it to access it.&quot; I don&#39;t see how that is true. Java uses references but is pass by value, and behaves identically to Python in that it has objects and variables are names referencing these objects. The statement you made earlier &quot;When the value is a reference, that&#39;s pass by reference.&quot; is incorrect, because if it&#39;s pass by value, you can reassign the reference. However, in pass by reference, if you try to reassign the variable you are actually modifying it.<br><h4> Comment 30480933 Lennart Regebro: </h4>@Synderesis: Once again, then: <a href="http://effbot.org/zone/call-by-object.htm" rel="nofollow noreferrer">effbot.org/zone/call-by-object.htm</a> See Davids answer. With your definition of pass-by-value, then EVERYTHING IS PASS BY VALUE. There exists no pass-by-reference with that wording of it, since pass-by-reference is when the value you pass is a reference, but you don&#39;t have to treat the value as a reference inside the function. What Java calls &quot;pass-by-value, and the value is a reference&quot; is <b>exactly what pass-by-reference is.</b> The whole point is that what Python <b>and Java</b> does <b><i>does not exactly fit either concept as used in other languages</i></b>.<br><h4> Comment 30557586 Richard Fung: </h4>@Lennart Regebro &quot;There exists no pass-by-reference with that wording of it, since pass-by-reference is when the value you pass is a reference&quot; In C++ you can have true pass by reference. Java is pass by value: <a href="http://stackoverflow.com/questions/40480/is-java-pass-by-reference" title="is java pass by reference">stackoverflow.com/questions/40480/is-java-pass-by-reference</a><br><h4> Comment 24660869 tom: </h4>I down voted because the code(where you do assignment in function body) given for string and list is basically the same and has the same behavior. And list is mutable a string is not. Your answer did not cleared a thing for me. It just made me realize that I totally don&#39;t understand Python.<br><h4> Comment 29837454 Lennart Regebro: </h4>@Synderesis: <i>&quot;In C++&quot;...</i> - Well, yeah, but now we are talking about Python. Python is passing references. Since it is passing reference, that&#39;s reasonably &quot;pass by reference&quot;. <i>&quot;In Python, if you try to reassign the parameter&quot;</i> - Yes, but that&#39;s a completely different issue. This is because Python doesn&#39;t have variables that point to a memory location like C/C++. It has objects, and variables are names for these objects.<br><h4> Comment 89462859 Happy Ahmad: </h4>@EthanFurman You are wrong. Even if you read the link in DavidCournapeau&#39;s answer that is <a href="http://effbot.org/zone/call-by-object.htm" rel="nofollow noreferrer">Call By Object</a>, you will see that all of the expressions “call by object”, “call by sharing“ or “call by object reference“, have the same meaning that is using an address to access the object. And for sure the address has to be determined from namespace. I can&#39;t accept that &quot;Call by object reference&quot; is different from &quot;Call by reference&quot;.<br><h4> Comment 90331111 Blair Conrad: </h4>@ML_Pro, &quot;pass by assignment&quot; seems to be a term made up by the Python documenters to describe &quot;pass by value&quot;. For the user, I see no functional difference between passing a value that is a reference (or handle) as happens in languages such as Java or C# and what Python does, and I&#39;d never use the term &quot;pass by assignment&quot;; it was edited into the answer, I assume to align with the documentation.<br><h4> Comment 117763925 juanpa.arrivillaga: </h4>@BlairConrad because that is simply confusing the implementation for the semantics. It isn&#39;t pass by value because the value isn&#39;t copied. The <i>value is the object</i>, python doesn&#39;t support reference types like pointers. The fact that CPython uses pointers is irrelevant, I could write a Python interpreter in Fortran using only call by reference internally, and that wouldn&#39;t make Python call by reference. Yes, &quot;pass by assignment&quot; is a Pythonism, but academically, it is known as <a href="https://en.wikipedia.org/wiki/Evaluation_strategy#Call_by_sharing" rel="nofollow noreferrer">call by sharing</a><br><h4> Comment 124477837 juanpa.arrivillaga: </h4>@MuhammadZubair no, <b>in neither case is pass by reference occurring</b>.  These terms have well understood meanings in programming languages, and Python <i>never supports call by reference</i>. If it <i>were</i> pass by reference, and a new list were assigned to the parameter, that change would be <i>visible in the caller</i>. That is a key feature of pass-by-reference. You&#39;ve essentially proven your own point incorrect.\<br><h4> Comment 117763939 juanpa.arrivillaga: </h4>@NoName <b>no</b>. That isn&#39;t how it works at all. Assignment doesn&#39;t work like in C/C++. An assignment statement merely changes what a name refers to in a namespace. Often, it is <i>literally</i> just chaning the value of a key in a dict (global namespaces and module namespaces are implemented as python <code>dict</code> objects)<br><h4> Comment 30559661 Lennart Regebro: </h4>@Synderesis: I wish the &quot;move this to chat&quot; option was always available, coomments are really not the place for me to repeat the same thing over and over.<br><h4> Comment 90299942 GeorgeOfTheRF: </h4>@BlairConrad &quot;The parameter passed in is actually a reference to an object (but the reference is passed by value)&quot;. This sounds similar to pass by reference. How is pass by reference and assignment different? Can you give an example to explain &quot;pass by assignment&quot;?<br><h4> Comment 65976346 Elazar: </h4>Unless you look at <code>locals()</code> etc., this is exactly like Java. In Java the address-space of references is an implementation detail, but in Python is a string in some scope (<code>__dict__</code>). In C it would be numbers in a global scope. Also, there is only one type of primitive in Python (reference to object) and several primitives in Java, one of which is reference to Object. Pass-by-reference in Python would mean &quot;pass the scope and the name of the variable&quot; but currently there is no such thing. it can be done explicitly - and it is, when emulating this mechanism using a class (which is a scope).<br><h4> Comment 66082232 Tommy: </h4>I&#39;ve  most often seen the term &quot;call-by-object-reference&quot;  not &quot;by assignment&quot;<br><h4> Comment 70028111 Bill: </h4>As a means to pass a reference to a name, why not pass the name itself as a string?  Then use <code>eval(name)</code> to get the current object that the name references.<br><h4> Comment 75161498 akki: </h4><a href="https://jeffknupp.com/blog/2012/11/13/is-python-callbyvalue-or-callbyreference-neither/" rel="nofollow noreferrer">jeffknupp.com/blog/2012/11/13/&hellip;</a> <a href="http://stupidpythonideas.blogspot.in/2013/11/does-python-pass-by-value-or-by.html" rel="nofollow noreferrer">stupidpythonideas.blogspot.in/2013/11/&hellip;</a> ^These are also some nice explanations.<br><h4> Comment 78891921 rkachach: </h4>&quot;but if you rebind the reference in the method, the outer scope will know nothing about it&quot;, well the if the passed reference is mutable and you performed some operations (let say appended some values to the list) then these operations will be visible by the outer scope. The outer-scope will stop seeing changes only once the rebind is performed. All the previous operations do affect the original object.<br><h4> Comment 11385601 Johan Lundberg: </h4>&quot;..., but if you rebind the reference in the method, the outer scope will know nothing about it, and after you&#39;re done, the outer reference will still point at the original object.&quot; This is wrong or at least not relevant - you can never rebind a reference.<br><h4> Comment 10470543 John Doe: </h4>Cue the <code>sys._getframe(1).f_locals[&#39;new_string&#39;] = &#39;foo&#39;</code> hack. Or just using ctypes.. :)<br><h4> Comment 102987642 NoName: </h4>Okay, so when you pass a list reference variable into the method, you&#39;re actually giving it a &quot;copy&quot; of the list reference. That&#39;s why changing what the &quot;list reference copy&quot; is pointing to doesn&#39;t change what the &quot;original list reference&quot; is pointing to.<br><h4> Comment 124921921 gast128: </h4>Good explanation. The confusing part for me (as C++) developer is that a function can change the contents (&#39;pass by reference&#39;) but it depends on the argument passed in.<br><h4> Comment 123053792 Muhammad Zubair: </h4>Confusing language used on lists passed into the two functions. In both cases, the list is passed by reference, however, in the first case, the list is modified so changes are visible outside the function. On the other hand, in the second case, a new list is assigned to the passed parameter, so it makes a new list without making changes to the list passed to the function. That&#39;s why changes are not visible outside the function<br><h4> Comment 135177935 Karl Knechtel: </h4>@gast128 C++&#39;s references implement actual pass-by-reference. &quot;The reference&quot; itself is not an object in C++; it isn&#39;t required to have storage and you aren&#39;t allowed to take its address (attempting to gives you the address of the reference). However, C++ variables have value <i>semantics</i>, whereas Python&#39;s have <i>reference semantics</i> (in C++ terms, everything is implicitly indirected once). A value passing from an argument to a parameter in Python works <b>the same way</b> that assigning to a new name works <b>in Python</b>, which <b>is not</b> the way it works in C++.<br><h4> Comment 135177952 Karl Knechtel: </h4>The indirection that Python automatically uses for everything is the same reason that, for example, it can natively and effortlessly support heterogeneous lists (the underlying storage for the list object just contains pointers, so the size of the underlying storage for the elements doesn&#39;t matter).<br>------------------------------------------------------------------ <br><h3> Answer 8140747 Mark Ransom: </h3><p>The problem comes from a misunderstanding of what variables are in Python. If you're used to most traditional languages, you have a mental model of what happens in the following sequence:</p>

<pre><code>a = 1
a = 2
</code></pre>

<p>You believe that <code>a</code> is a memory location that stores the value <code>1</code>, then is updated to store the value <code>2</code>. That's not how things work in Python. Rather, <code>a</code> starts as a reference to an object with the value <code>1</code>, then gets reassigned as a reference to an object with the value <code>2</code>. Those two objects may continue to coexist even though <code>a</code> doesn't refer to the first one anymore; in fact they may be shared by any number of other references within the program.</p>

<p>When you call a function with a parameter, a new reference is created that refers to the object passed in. This is separate from the reference that was used in the function call, so there's no way to update that reference and make it refer to a new object. In your example:</p>

<pre><code>def __init__(self):
    self.variable = 'Original'
    self.Change(self.variable)

def Change(self, var):
    var = 'Changed'
</code></pre>

<p><code>self.variable</code> is a reference to the string object <code>'Original'</code>. When you call <code>Change</code> you create a second reference <code>var</code> to the object. Inside the function you reassign the reference <code>var</code> to a different string object <code>'Changed'</code>, but the reference <code>self.variable</code> is separate and does not change.</p>

<p>The only way around this is to pass a mutable object. Because both references refer to the same object, any changes to the object are reflected in both places.</p>

<pre><code>def __init__(self):         
    self.variable = ['Original']
    self.Change(self.variable)

def Change(self, var):
    var[0] = 'Changed'
</code></pre>
<h4> Comment 9996492 Cam Jackson: </h4>Good succinct explanation. Your paragraph &quot;When you call a function...&quot; is one of the best explanations I&#39;ve heard of the rather cryptic phrase that &#39;Python function parameters are references, passed by value.&#39; I think if you understand that paragraph alone, everything else kind of just makes sense and flows as a logical conclusion from there. Then you just have to be aware of when you&#39;re creating a new object and when you&#39;re modifying an existing one.<br><h4> Comment 13535380 Mark Ransom: </h4>@Glassjawed, I think you&#39;re getting it. &quot;Changed&quot; and &quot;Original&quot; are two different string objects at different memory addresses and &#39;var&#39; changes from pointing to one to pointing to the other.<br><h4> Comment 85424727 Mark Ransom: </h4>@TonySuffolk66 <code>id</code> gives the identity of the object referenced, not the reference itself.<br><h4> Comment 13535104 Kashif: </h4>But how can you reassign the reference? I thought you can&#39;t change the address of &#39;var&#39; but that your string &quot;Changed&quot; was now going to be stored in the &#39;var&#39; memory address. Your description makes it seem like &quot;Changed&quot; and &quot;Original&quot; belong to different places in memory instead and you just switch &#39;var&#39; to a different address. Is that correct?<br><h4> Comment 85421130 Tony Suffolk 66: </h4>Function calls do not create new references - use the id function inside and outside of the function to confirm that. The difference is what happens to the object when you attempt to change it inside the function.<br><h4> Comment 92716352 Mark Ransom: </h4>@MinhTran in the simplest terms, a reference is something that &quot;refers&quot; to an object. The physical representation of that is most likely a pointer, but that&#39;s simply an implementation detail. It really is an abstract notion at heart.<br><h4> Comment 134868222 Mark Ransom: </h4>@JamesM.Lay some operations, such ass assigning to a list slice or dictionary key, are just defined that way.  They&#39;re generally secretly converted to function calls such as <code>__setitem__</code>.<br><h4> Comment 123513318 marc_r: </h4>One should perhaps note that in the second example (mutable object), you cannot update the reference either: var = [&#39;Changed&#39;] won&#39;t have the desired effect. WIth var[0] = &#39;Changed&#39;, the object identity is the same; we just use the object&#39;s interface to make changes to it. It would be interesting to have a notation like var[] = ... that updates the actual reference (replaces the object as a whole).<br><h4> Comment 123518311 Mark Ransom: </h4>@marc_r I thought that was obvious from the way I explained the mechanics.  Mutating a list isn&#39;t a real answer to the question, it&#39;s just a workaround - the closest thing that Python allows.<br><h4> Comment 134891679 James M. Lay: </h4>@MarkRansom your answer is consistent with the one I got from a certain popular chat engine.  Basically, it&#39;s the operation that defines the creation-of or reference-to objects.  Addition, for example, always creates a new object.<br><h4> Comment 134899069 Mark Ransom: </h4>@JamesM.Lay even that may depend on whether the object is mutable or not. I haven&#39;t tested it but I think addition in <code>numpy</code> might work different.<br><h4> Comment 134914614 James M. Lay: </h4>@MarkRansom that&#39;s right, I forgot to consider operator overloading.  Yikes.<br><h4> Comment 134863633 James M. Lay: </h4>Okay, so everything is a reference under the hood. So, how does python determine when to create a new object and when to refer to an already existing one?<br><h4> Comment 55069879 Tim Richardson: </h4>using the id() function helps clarify matters, because it makes it clear when Python creates a new object (so I think, anyway).<br><h4> Comment 72367453 akki: </h4>This answer and <a href="http://effbot.org/zone/python-objects.htm" rel="nofollow noreferrer">this blog post by effbot on python-objects</a> together make things as clear as they can be.<br><h4> Comment 70325453 Luke Davis: </h4>Woah... so it makes sense that lists are mutable because one can imagine saying &quot;ok python, make these boxes for me&quot;... then the contents of the boxes can be modified. <b>But</b> things like strings and numbers can without complication point to a series of 1s and 0s in your memory, so it makes more sense to &quot;tag&quot; them with names.<br><h4> Comment 85444968 Tony Suffolk 66: </h4>Mark - I took your use of reference to mean a object; when a function is called a new binding is created of an existing object to a new name (with a increase in the Ref count). Most documentation I have seen talks about this as a new binding, and not a new reference. Apologies for misunderstanding.<br><h4> Comment 85454259 Mark Ransom: </h4>@TonySuffolk66 I come from a C++ background, so I might be a little loose on the terminology. A C++ reference is the closest thing to a Python variable.<br><h4> Comment 85504317 Tony Suffolk 66: </h4>@MarkRansom - strictly speaking Python doesn&#39;t have &#39;variables&#39; - well not in a C/C++ way of having a memory location which is known by that name. What Python has is one or more names which are bound to a reference to object - or sometime a name is bound to a container of object references. Oh the joys of terminology :-)<br><h4> Comment 92088803 Yasir Jan: </h4>So, can we say that a mutable object is passed by reference and an immutable object is not ?<br><h4> Comment 92094467 Mark Ransom: </h4>@YasirJan no, they&#39;re both passed by reference. It&#39;s just that for an immutable object the reference doesn&#39;t help you.<br><h4> Comment 92716062 Minh Tran: </h4>@MarkRansom What exactly is a <code>reference</code>? Your definition doesn&#39;t go beyond suggesting that it is &quot;something&quot; that points/refers to an object (which is a helpful definition to aid in describing what a reference <code>does</code> but not necessarily what it <i>is</i>).<br>------------------------------------------------------------------ <br><h3> Answer 25670170 Zenadix: </h3><p>I found the other answers rather long and complicated, so I created this simple diagram to explain the way Python treats variables and parameters.
<a href="https://i.stack.imgur.com/FdaCu.png"><img src="https://i.stack.imgur.com/FdaCu.png" alt="enter image description here"></a></p>
<h4> Comment 63811790 Hatshepsut: </h4>&quot;A is assigned to B.&quot; Is that not ambiguous? I think in ordinary English that can mean either <code>A=B</code> or <code>B=A</code>.<br><h4> Comment 62388292 Martijn Pieters: </h4>Thanks for the update, much better! What confuses most people is assignment to a subscription; e.g. <code>B[0] = 2</code>, vs. direct assignment, <code>B = 2</code>.<br><h4> Comment 64321833 Madivad: </h4>I do like the visual representation, but still misses the point of <code>mutable</code> vs <code>immutable</code> which makes the right leg moot since there will be no <code>append</code> available. (still got an upvote for the visual rep though) :)<br><h4> Comment 126017493 timgeb: </h4>&quot;Something else is assigned to B&quot; should be &quot;B is assigned to something else&quot;. Names are assigned to values, not the other way around. Names refer to values, values don&#39;t know what names they have.<br><h4> Comment 118055360 Mark Ransom: </h4>@Abhinav in Python, EVERYTHING is an object - even simple integers.  But some objects can be modified (mutable) and some can&#39;t.  If the object has an <code>append</code> method then it must be mutable.<br><h4> Comment 118055513 Mark Ransom: </h4>This is a great answer that illustrates a key core concept of Python, but I think somewhere along the way you lost the connection to the original question.<br><h4> Comment 103273846 Abhinav: </h4>What do you mean by B is modified in-place?B is not an object<br><h4> Comment 132535036 Karl Knechtel: </h4>At this level of simplicity, I don&#39;t see how the diagram is helpful vs. a plain-text explanation.<br>------------------------------------------------------------------ <br><h3> Answer 986495 David Cournapeau: </h3><p>It is neither pass-by-value or pass-by-reference - it is call-by-object. See this, by Fredrik Lundh:</p>
<p><em><a href="http://web.archive.org/web/20201111195827/http://www.effbot.org/zone/call-by-object.htm" rel="noreferrer">Call By Object</a></em></p>
<p>Here is a significant quote:</p>
<blockquote>
<p>&quot;...variables [names] are <em>not</em> objects; they cannot be denoted by other variables or referred to by objects.&quot;</p>
</blockquote>
<p>In your example, when the <code>Change</code> method is called--a <a href="http://docs.python.org/2/tutorial/classes.html#python-scopes-and-namespaces" rel="noreferrer">namespace</a> is created for it; and <code>var</code> becomes a name, within that namespace, for the string object <code>'Original'</code>. That object then has a name in two namespaces. Next, <code>var = 'Changed'</code> binds <code>var</code> to a new string object, and thus the method's namespace forgets about <code>'Original'</code>. Finally, that namespace is forgotten, and the string <code>'Changed'</code> along with it.</p>
<h4> Comment 18284481 Mike Graham: </h4>No, it&#39;s <i>exactly</i> like Java&#39;s semantics for objects. I&#39;m not sure what you mean by &quot;In the first case, the returned value will be a copy of the input, and identical in the second case.&quot; but that statement seems to be plainly incorrect.<br><h4> Comment 19264776 cayhorstmann: </h4>It is exactly the same as in Java. Object references are passed by value. Anyone who thinks differently should attach the Python code for a <code>swap</code> function that can swap two references, like this:  <code>a = [42] ; b = &#39;Hello&#39;; swap(a, b) # Now a is &#39;Hello&#39;, b is [42]</code><br><h4> Comment 25806292 Claudiu: </h4>It is exactly the same as Java when you pass objects in Java. However, Java also have primitives, which are passed by copying the value of the primitive. Thus they differ in that case.<br><h4> Comment 10494915 Luciano: </h4>I find it hard to buy. To me is just as Java, the parameters are pointers to objects in memory, and those pointers are passed via the stack, or registers.<br><h4> Comment 10518161 David Cournapeau: </h4>This is not like java. One of the case where it is not the same is immutable objects. Think about the trivial function lambda x: x. Apply this for x = [1, 2, 3] and x = (1, 2, 3). In the first case, the returned value will be a copy of the input, and identical in the second case.<br><h4> Comment 19304356 David Cournapeau: </h4>Whether something is an object or not is irrelevant (especially since almost everything is an object in python, e.g. int, float, etc...). The mutability matters. You can write a swap function that would work for lists (mutable), but not for tuples or strings (immutable). See also this: <a href="http://www.python-course.eu/passing_arguments.php" rel="nofollow noreferrer">python-course.eu/passing_arguments.php</a>, which clearly shows a different behavior than java in some cases.<br><h4> Comment 18325338 David Cournapeau: </h4>My comment is indeed incorrect, but I stand on the fact that python semantics are different from java, as explained in the referred article. In python, whether changes within a function are visible outside it for its argument depends on the mutability, not on being a special type (say object vs primitive types in java), and the argument passing &#39;protocol&#39; is the same for everything in python.<br><h4> Comment 65976442 Elazar: </h4>@Claudiu you are 100% right, except Java does not differ with the <i>behavior</i> of the additional primitives - it merely <i>does</i> have additional primitives, where Python don&#39;t. Other differences are visible when you look at <code>locals()</code> and some other meta-stuff - the scopes are implemented in a different way, and this implementation detail is visible in Python.<br><h4> Comment 129241260 MattSt: </h4>It&#39;s literally pass by reference, as what is being passed is the address. Passing the number 1 passes the address of the object with value 1 to the function argument by assignment. The thing is that even if it is  passed by reference, 1 is an integer which is immutable and hence you will never be able to change it.<br><h4> Comment 38394242 brain storm: </h4>@Claudiu: Its not only in the case of Java primitives, any immutable object in Java will behave same as primitives such as String which is a Java object<br>------------------------------------------------------------------ <br><h3> Answer 986339 Daren Thomas: </h3><p>Think of stuff being passed <strong>by assignment</strong> instead of by reference/by value. That way, it is always clear, what is happening as long as you understand what happens during the normal assignment.</p>

<p>So, when passing a list to a function/method, the list is assigned to the parameter name. Appending to the list will result in the list being modified. Reassigning the list <em>inside</em> the function will not change the original list, since:</p>

<pre><code>a = [1, 2, 3]
b = a
b.append(4)
b = ['a', 'b']
print a, b      # prints [1, 2, 3, 4] ['a', 'b']
</code></pre>

<p>Since immutable types cannot be modified, they <em>seem</em> like being passed by value - passing an int into a function means assigning the int to the function's parameter. You can only ever reassign that, but it won't change the original variables value.</p>
<h4> Comment 81843915 Christian Groleau: </h4>At first glance this answer seems to sidestep the original question. After a second read I&#39;ve come to realize that this makes the matter quite clear. A good follow up to this &quot;name assignment&quot; concept may be found  here: <a href="http://python.net/~goodger/projects/pycon/2007/idiomatic/handout.html#other-languages-have-variables" rel="nofollow noreferrer">Code Like a Pythonista: Idiomatic Python</a><br><h4> Comment 136627262 Egret: </h4>So, can it be summarized as: assigning an immutable type is essentially re-assigning it, because assigning a type that can&#39;t be modified is meaningless?<br>------------------------------------------------------------------ <br><h3> Answer 21700609 Lutz Prechelt: </h3><h1>There are no variables in Python</h1>

<p>The key to understanding parameter passing is to stop thinking about "variables". There are names and objects in Python and together they
appear like variables, but it is useful to always distinguish the three.</p>

<ol>
<li>Python has names and objects.</li>
<li>Assignment binds a name to an object.</li>
<li>Passing an argument into a function also binds a name (the parameter name of the function) to an object.</li>
</ol>

<p>That is all there is to it. Mutability is irrelevant to this question.</p>

<p>Example:</p>

<pre><code>a = 1
</code></pre>

<p>This binds the name <code>a</code> to an object of type integer that holds the value 1.</p>

<pre><code>b = x
</code></pre>

<p>This binds the name <code>b</code> to the same object that the name <code>x</code> is currently bound to.
Afterward, the name <code>b</code> has nothing to do with the name <code>x</code> anymore.</p>

<p>See sections <a href="https://docs.python.org/3/reference/datamodel.html#objects-values-and-types" rel="noreferrer">3.1</a> and <a href="https://docs.python.org/3/reference/executionmodel.html#naming-and-binding" rel="noreferrer">4.2</a> in the Python 3 language reference.</p>

<h1>How to read the example in the question</h1>

<p>In the code shown in the question, the statement <code>self.Change(self.variable)</code> binds the name <code>var</code> (in the scope of function <code>Change</code>) to the object that holds the value <code>'Original'</code> and the assignment <code>var = 'Changed'</code> (in the body of function <code>Change</code>) assigns that same name again: to some other object (that happens to hold a string as well but could have been something else entirely).</p>

<h1>How to pass by reference</h1>

<p>So if the thing you want to change is a mutable object, there is no problem, as everything is effectively passed by reference.</p>

<p>If it is an <a href="https://docs.python.org/3/reference/datamodel.html#objects-values-and-types" rel="noreferrer">immutable</a> object (e.g. a bool, number, string), the way to go is to wrap it in a mutable object.<br>
The quick-and-dirty solution for this is a one-element list (instead of <code>self.variable</code>, pass <code>[self.variable]</code> and in the function modify <code>var[0]</code>).<br>
The more <a href="https://www.python.org/dev/peps/pep-0020/" rel="noreferrer">pythonic</a> approach would be to introduce a trivial, one-attribute class. The function receives an instance of the class and manipulates the attribute.</p>
<h4> Comment 37695746 Ned Batchelder: </h4>&quot;Python has no variables&quot; is a silly and confusing slogan, and I really wish people would stop saying it... :(   The rest of this answer is good!<br><h4> Comment 37755336 Ned Batchelder: </h4>would you also say that Javascript has no variables? They work the same as Python&#39;s.  Also, Java, Ruby, PHP, ....   I think a better teaching technique is, &quot;Python&#39;s variables work differently than C&#39;s.&quot;<br><h4> Comment 37747455 Lutz Prechelt: </h4>It may be shocking, but it is not silly. And I don&#39;t think it is confusing either: It hopefully opens up the recipient&#39;s mind for the explanation that is coming and puts her in a useful &quot;I wonder what they have instead of variables&quot; attitude. (Yes, your mileage may vary.)<br><h4> Comment 41878922 Ned Batchelder: </h4>Yes, Java has variables. So does Python, and JavaScript, Ruby, PHP, etc.  You wouldn&#39;t say in Java that <code>int</code> declares a variable, but <code>Integer</code> does not.  They both declare variables.  The <code>Integer</code> variable is an object, the <code>int</code> variable is a primitive.  As an example, you demonstrated how your variables work by showing <code>a = 1; b = a; a++ # doesn&#39;t modify b</code>.  That&#39;s exactly true in Python also (using <code>+= 1</code> since there is no <code>++</code> in Python)!<br><h4> Comment 53893736 Lutz Prechelt: </h4>The concept of &quot;variable&quot; is complex and often vague: <b>A variable is a container for a value, identified by a name.</b> In Python, the values are objects, the containers are objects (see the problem?) and the names are actually separate things. I believe it is much tougher to get an <i>accurate</i> understanding of variables in this manner. The names-and-objects explanation appears more difficult, but is actually simpler.<br><h4> Comment 63088305 Sherlock70: </h4>I really don&#39;t see how this answer could be helpful in light of the question. No solution is given, only the status quo of python is recited. How can you pass an argument, so that it can be changed? Most of the answers here don&#39;t give a solution. But this one, denies the existence of the obvious in the first lines, so it stands out of the pack. Sorry for the downvote, but it just made me a bit mad.<br><h4> Comment 132542220 sam hocevar: </h4>The last section gives the false impression that passing <code>[self.variable]</code> and modifying <code>var[0]</code> will modify <code>self.variable</code>, which will never happen. One way this could work would be to store <code>[&#39;Original&#39;]</code> instead of <code>&#39;Original&#39;</code>, modify <code>var[0]</code> as suggested, and then print <code>self.variable[0]</code> instead of <code>self.variable</code>.<br><h4> Comment 78700107 Erich: </h4><i>var&#183;i&#183;a&#183;ble ˈverēəb(ə)l/Submit adjective 1. not consistent or having a fixed pattern; liable to change.</i>  I would argue that python does have &quot;Variables&quot;<br><h4> Comment 125941822 iperov: </h4>&quot;Assignment binds a name to an object.&quot; - this is why properties must be deleted from python, because &#39;obj.some_prop = val&#39; does some hidden non-obvious logic instead of binding object to name.<br><h4> Comment 126215166 Lutz Prechelt: </h4>@iperov Why? <code>some_prop</code> is a perfectly fine name like any other. No problem and nothing non-obvious there at all. (Except maybe that there is more than a single <a href="https://docs.python.org/3/glossary.html#term-namespace" rel="nofollow noreferrer">namespace</a> in Python and the question and answer do not talk about that aspect.)<br><h4> Comment 126215444 iperov: </h4>@Lutz Prechelt it is not clear to those who have not designed complex architectures. Any non-obvious thing to the &quot;external user of a class&quot; is a pitfall, or a shot in the leg.<br><h4> Comment 78892241 rkachach: </h4>&quot;That is all there is to it. Mutability is irrelevant for this question.&quot; yes it does. If the self.variable were mutable then it could be changed inside the function self.change(). Thus, passing an immutable type as parameter function will never affect the passed &quot;variable&quot;.<br><h4> Comment 81843862 Christian Groleau: </h4>I like this answer. To further the idea of &quot;variables&quot; vs &quot;names&quot; (emphasis on the quotes) may be found here: <a href="http://python.net/~goodger/projects/pycon/2007/idiomatic/handout.html#other-languages-have-variables" rel="nofollow noreferrer">Code Like a Pythonista: Idiomatic Python</a><br>------------------------------------------------------------------ <br><h3> Answer 15697476 Raymond Hettinger: </h3><p>Effbot (aka Fredrik Lundh) has described Python's variable passing style as call-by-object:  <a href="http://effbot.org/zone/call-by-object.htm" rel="nofollow noreferrer">http://effbot.org/zone/call-by-object.htm</a></p>
<p>Objects are allocated on the heap and pointers to them can be passed around anywhere.</p>
<ul>
<li><p>When you make an assignment such as <code>x = 1000</code>, a dictionary entry is created that maps the string &quot;x&quot; in the current namespace to a pointer to the integer object containing one thousand.</p>
</li>
<li><p>When you update &quot;x&quot; with <code>x = 2000</code>, a new integer object is created and the dictionary is updated to point at the new object.  The old one thousand object is unchanged (and may or may not be alive depending on whether anything else refers to the object).</p>
</li>
<li><p>When you do a new assignment such as <code>y = x</code>, a new dictionary entry &quot;y&quot; is created that points to the same object as the entry for &quot;x&quot;.</p>
</li>
<li><p>Objects like strings and integers are <em>immutable</em>.  This simply means that there are no methods that can change the object after it has been created.  For example, once the integer object one-thousand is created, it will never change.  Math is done by creating new integer objects.</p>
</li>
<li><p>Objects like lists are <em>mutable</em>.  This means that the contents of the object can be changed by anything pointing to the object.  For example, <code>x = []; y = x; x.append(10); print y</code> will print <code>[10]</code>.  The empty list was created.  Both &quot;x&quot; and &quot;y&quot; point to the same list.  The <em>append</em> method mutates (updates) the list object (like adding a record to a database) and the result is visible to both &quot;x&quot; and &quot;y&quot; (just as a database update would be visible to every connection to that database).</p>
</li>
</ul>
<p>Hope that clarifies the issue for you.</p>
<h4> Comment 31758965 Raymond Hettinger: </h4>@HonestAbe Yes, in CPython the <i>id()</i> returns the address.  But in other pythons such as PyPy and Jython, the <i>id()</i> is just a unique object identifier.<br><h4> Comment 31747271 Honest Abe: </h4>I really appreciate learning about this from a developer. Is it true that the <code>id()</code> function returns the pointer&#39;s (object reference&#39;s) value, as pepr&#39;s answer suggests?<br><h4> Comment 135178000 Karl Knechtel: </h4>The dictionary is a reasonable mental model, and pretty accurate for 2.x; but in 3.x, <i>local</i> variables have optimized storage that doesn&#39;t work like a dictionary, and the <code>locals()</code> function needs to create a <code>dict</code> on the fly.<br>------------------------------------------------------------------ <br><h3> Answer 12440140 pepr: </h3><p>Technically, <strong>Python always uses pass by reference values</strong>. I am going to repeat <a href="https://stackoverflow.com/a/12438316/1346705">my other answer</a> to support my statement.</p>

<p>Python always uses pass-by-reference values. There isn't any exception. Any variable assignment means copying the reference value. No exception. Any variable is the name bound to the reference value. Always.</p>

<p>You can think about a reference value as the address of the target object. The address is automatically dereferenced when used. This way, working with the reference value, it seems you work directly with the target object. But there always is a reference in between, one step more to jump to the target.</p>

<p>Here is the example that proves that Python uses passing by reference:</p>

<p><img src="https://i.stack.imgur.com/uzXcP.png" alt="Illustrated example of passing the argument"></p>

<p>If the argument was passed by value, the outer <code>lst</code> could not be modified. The green are the target objects (the black is the value stored inside, the red is the object type), the yellow is the memory with the reference value inside -- drawn as the arrow. The blue solid arrow is the reference value that was passed to the function (via the dashed blue arrow path). The ugly dark yellow is the internal dictionary. (It actually could be drawn also as a green ellipse. The colour and the shape only says it is internal.)</p>

<p>You can use the <a href="http://docs.python.org/3.3/library/functions.html#id" rel="noreferrer"><code>id()</code></a> built-in function to learn what the reference value is (that is, the address of the target object).</p>

<p>In compiled languages, a variable is a memory space that is able to capture the value of the type. In Python, a variable is a name (captured internally as a string) bound to the reference variable that holds the reference value to the target object. The name of the variable is the key in the internal dictionary, the value part of that dictionary item stores the reference value to the target.</p>

<p>Reference values are hidden in Python. There isn't any explicit user type for storing the reference value. However, you can use a list element (or element in any other suitable container type) as the reference variable, because all containers do store the elements also as references to the target objects. In other words, elements are actually not contained inside the container -- only the references to elements are.</p>
<h4> Comment 19264948 cayhorstmann: </h4>Inventing new terminology (such as &quot;pass by reference value&quot; or &quot;call by object&quot; is not helpful). &quot;Call by (value|reference|name)&quot; are standard terms. &quot;reference&quot; is a standard term. Passing references by value accurately describes the behavior of Python, Java, and a host of other languages, using standard terminology.<br><h4> Comment 19270112 pepr: </h4>@cayhorstmann: The problem is that <i>Python variable</i> has not the same terminology meaning as in other languages. This way, <i>call by reference</i> does not fit well here. Also, how do you <i>exactly</i> define the term <i>reference</i>? Informally, the Python way could be easily described as passing the address of the object. But it does not fit with a potentially distributed implementation of Python.<br><h4> Comment 31841961 Honest Abe: </h4>There is a footnote indicated at the end of that quote, which reads: <i>&quot;Actually, <b>call by object reference</b> would be a better description, since if a mutable object is passed, the caller will see any changes the callee makes to it...&quot;</i> I agree with you that confusion is caused by trying to fit terminology established with other languages. Semantics aside, the things that need to be understood are: dictionaries / namespaces, <a href="http://docs.python.org/3.3/reference/executionmodel.html" rel="nofollow noreferrer">name binding operations</a> and the relationship of name→pointer→object (as you already know).<br><h4> Comment 112514005 Myridium: </h4>This answer is at best misleading, and at worst outright false.<br><h4> Comment 112579982 Myridium: </h4>@pepr - it may technically correct (I cannot understand 50% of it) but it offers no clarification to a beginner who is trying to fit the behaviour of python into a conceptual model where something is either passed by reference or passed by value. This is a pragmatic question, let alone a theoretical one. The answer is that Python &#39;passes by assignment&#39;, behaving differently for mutable and immutable types. I was surprised to learn that <code>id(x)</code> is the same as what was passed in, because assigning a new value to the parameter has a different result than assigning a value to the <code>x</code> before input.<br><h4> Comment 112580079 Myridium: </h4>The example given leads the reader to believe Python behaves one way, and yet if you give the example of an integer (immutable type) it will appear to behave the other way! How is the mutable type behaviour reconciled with your assertion that everything is passed by reference, and with the fact that <code>id</code> is preserved? This needs to be explained.<br><h4> Comment 31746972 Honest Abe: </h4>I like this answer, but you might consider if the example is really helping or hurting the flow. Also, if you replaced &#39;reference value&#39; with &#39;object reference&#39; you would be using terminology that we could consider &#39;official&#39;, as seen here: <a href="http://docs.python.org/3.3/tutorial/controlflow.html#defining-functions" rel="nofollow noreferrer">Defining Functions</a><br><h4> Comment 31790229 pepr: </h4>Well, but the official says... &quot;<i>arguments are passed using <b>call by value</b> (where the <b>value</b> is always an object <b>reference</b>, not the value of the object).</i>&quot; This way, you may be tempted to substitute it textually as ... <i>arguments are passed using <b>call by reference</i></b>, which is a bit confusing beacuse it is not true. The confusion is caused by a bit more complex situation where none of the classical terms fits perfectly. I did not find any simpler example that would illustrate the behaviour.<br><h4> Comment 112789380 pepr: </h4>@Myridium: Python does not use the pass by value (as compiled languages do). It always passes the address (the id) of the target object. Of course, if the object is mutable, its content can be changed by assigning it the new value. If the object is immutable, then the assignment creates new object and the other one is untouched. However, it is not caused by how the object was passed into the procedure. It is the feature related to mutable/immutable in general.<br><h4> Comment 113092945 Myridium: </h4>@pepr - okay, thanks, I think I understand. I suppose the difference in behaviour between assigning the variable inside or outside a function is that inside a function, the &#39;labels&#39; for the variables have a restricted scope.<br><h4> Comment 113126736 pepr: </h4>@Myridium: Well, not exactly. After passing the argument, both outer and inner variable point to the same target object.<br><h4> Comment 119117489 Charlie Parker: </h4>apologies for the question, especially since the discussion seems to complain about using new terminology, but it&#39;s unclear to me. What does <code>pass by reference values</code> mean? Perhaps defining it in your answer would be useful :) Is a reference a pointer like thing?<br><h4> Comment 119149185 pepr: </h4>@CharlieParker: I the third paragraph: &quot;You can think about a reference value as the address of the target object.&quot; Anyway, this holds only for C-Python. Technically the function <code>id()</code> can return a different kind of unique identifier -- then that would be the reference value. Yes, I consider reference as equal to pointer that is never <code>null</code>. But pointers in compiled languages store the address. In Python, the reference/pointer is hidden and can possibly generalized for other kind of id&#39;s.<br><h4> Comment 135178039 Karl Knechtel: </h4>&quot;The problem is that Python variable has not the same terminology meaning as in other languages.&quot; We have perfectly standard terminology for it: Python variables (or, if you prefer, &quot;names&quot; - as Python documentation calls them) have <i>reference semantics</i>. And those variables are <i>passed</i> by value (some newer sources use the term &quot;pass by assignment&quot;, but this <b>means the same thing</b>, it&#39;s just thought to be clearer in the presence of variables with reference semantics). We know this because <i>plain assignment</i> inside the function <i>cannot affect</i> the caller&#39;s variable.<br><h4> Comment 135201402 pepr: </h4>@KarlKnechtel: As I wrote above, that is only playing on words. Python <i>reference semantics</i> differs from the C++ <i>reference semantics</i>. What is the <i>plain assignment</i> in your comment?<br><h4> Comment 135205126 Karl Knechtel: </h4>No, they do not. &quot;reference semantics&quot; is a property <b>of variables, not of parameters or parameter passing</b>. Python&#39;s names <i>have</i> reference semantics: they are hidden behind a layer of indirection. C++&#39;s variables do not: they are not. But there is only one kind of &quot;reference semantics&quot;. C++ references are not objects (in the general CS sense, not the OOP sense), so they cannot have either reference or value semantics. By &quot;plain assignment&quot;, I mean the use of the <code>=</code> operator (distinguished from augmented assignment such as <code>+=</code>).<br><h4> Comment 135217204 pepr: </h4>@KarlKnechtel: Ok. When you speak about the <i>value of a variable</i> with someone else (who possibly do not knows internals of Python)... What is the value of a variable? The &quot;plain assignment&quot; <i>can</i> affect the caller&#39;s variable, because you can pass the object that defines its own operator <code>=</code> .<br><h4> Comment 135217221 Karl Knechtel: </h4>&quot;because you can pass the object that defines its own operator <code>=</code>&quot; - not in Python, you can&#39;t. That&#39;s <i>fundamentally</i> not possible (and therefore, not designed for) because assignment <i>binds names to objects</i> - it does not mutate objects to have the state of other objects. &quot;When you speak about the value of a variable&quot; - well, I <i>didn&#39;t</i>; but clearly in Python it means the indirected contents that represent the state of the object, and does not mean the layer of indirection itself. In C++, it still means the memory representing the state of the object - there just isn&#39;t that indirection.<br><h4> Comment 135217257 Karl Knechtel: </h4>If you&#39;re still skeptical, please try to write the Python equivalent of <code>void swap(T&amp; x, T&amp; y) { T z = x; x = y; y = z; }</code>. You will find that no matter what you try, it does not actually swap anything for the caller, unless you wrap <code>x</code> and <code>y</code> in some other mutable object and mutate that.<br><h4> Comment 135227421 pepr: </h4>@KarlKnechtel: OK. I was wrong about the <code>operator=</code>. Anyway, <i>passing by value</i> is kind of equivalent with &quot;no possibility to modify the original object&quot;. And that includes also passing objects. Do you agree? And a <i>variable</i>--typically in compiled languages--are considered <i>a space to store a value</i> rather than a <i>name</i>.<br><h4> Comment 135235446 Karl Knechtel: </h4>&quot;Anyway, passing by value is kind of equivalent with &quot;no possibility to modify the original object&quot;. &quot; No; it&#39;s equivalent with &quot;no possibility to modify the <i>caller&#39;s variable</i>. Passing a pointer in C isn&#39;t &quot;pass-by-reference&quot; either. &quot;And a variable--typically in compiled languages--are considered a space to store a value rather than a name.&quot; Python chose the terminology &quot;name&quot; to avoid old baggage, but the only reason people see the term &quot;variable&quot; this way&quot; is because of all the older languages that used value semantics for variables.<br>------------------------------------------------------------------ <br><h3> Answer 6963425 AmanicA: </h3><p>A simple trick I normally use is to just wrap it in a list:</p>

<pre><code>def Change(self, var):
    var[0] = 'Changed'

variable = ['Original']
self.Change(variable)      
print variable[0]
</code></pre>

<p>(Yeah I know this can be inconvenient, but sometimes it is simple enough to do this.)</p>
<h4> Comment 44877350 Justas: </h4>Nice. To pass by ref, wrap in [ ]&#39;s.<br>------------------------------------------------------------------ <br><h3> Answer 986335 bobobobo: </h3><p>You got some really good answers here.</p>

<pre><code>x = [ 2, 4, 4, 5, 5 ]
print x  # 2, 4, 4, 5, 5

def go( li ) :
  li = [ 5, 6, 7, 8 ]  # re-assigning what li POINTS TO, does not
  # change the value of the ORIGINAL variable x

go( x ) 
print x  # 2, 4, 4, 5, 5  [ STILL! ]


raw_input( 'press any key to continue' )
</code></pre>
<h4> Comment 37877580 laycat: </h4>yea, however if you do   x = [ 2, 4, 4, 5, 5],  y = x,  X[0] = 1 , print x # [1, 4 ,4, 5, 5]  print y # [1, 4, 4, 5, 5]<br><h4> Comment 121249518 pippo1980: </h4>X[0]   or x[0] ? don&#39;t get it<br>------------------------------------------------------------------ <br><h3> Answer 986044 Mike Mazur: </h3><p>In this case the variable titled <code>var</code> in the method <code>Change</code> is assigned a reference to <code>self.variable</code>, and you immediately assign a string to <code>var</code>. It's no longer pointing to <code>self.variable</code>. The following code snippet shows what would happen if you modify the data structure pointed to by <code>var</code> and <code>self.variable</code>, in this case a list:</p>

<pre><code>&gt;&gt;&gt; class PassByReference:
...     def __init__(self):
...         self.variable = ['Original']
...         self.change(self.variable)
...         print self.variable
...         
...     def change(self, var):
...         var.append('Changed')
... 
&gt;&gt;&gt; q = PassByReference()
['Original', 'Changed']
&gt;&gt;&gt; 
</code></pre>

<p>I'm sure someone else could clarify this further.</p>
------------------------------------------------------------------ <br><h3> Answer 29293411 ajknzhol: </h3><p>Python’s pass-by-assignment scheme isn’t quite the same as C++’s reference parameters option, but it turns out to be very similar to the argument-passing model of the C language (and others) in practice:</p>

<ul>
<li>Immutable arguments are effectively passed “<strong>by value</strong>.” Objects such as integers and strings are passed by object reference instead of by copying, but because you can’t change immutable objects in place anyhow, the effect is much like making a copy.</li>
<li>Mutable arguments are effectively passed “<strong>by pointer</strong>.” Objects such as lists
and dictionaries are also passed by object reference, which is similar to the way C
passes arrays as pointers—mutable objects can be changed in place in the function,
much like C arrays.</li>
</ul>
------------------------------------------------------------------ <br><h3> Answer 25810863 Joop: </h3><p>There are a lot of insights in answers here, but I think an additional point is not clearly mentioned here explicitly.   Quoting from Python documentation <em><a href="https://docs.python.org/2/faq/programming.html#what-are-the-rules-for-local-and-global-variables-in-python" rel="nofollow noreferrer">What are the rules for local and global variables in Python?</a></em></p>
<blockquote>
<p>In Python, variables that are only referenced inside a function are implicitly global. If a variable is assigned a new value anywhere within the function’s body, it’s assumed to be a local. If a variable is ever assigned a new value inside the function, the variable is implicitly local, and you need to explicitly declare it as ‘global’.
Though a bit surprising at first, a moment’s consideration explains this. On one hand, requiring global for assigned variables provides a bar against unintended side-effects. On the other hand, if global was required for all global references, you’d be using global all the time. You’d have to declare as global every reference to a built-in function or to a component of an imported module. This clutter would defeat the usefulness of the global declaration for identifying side-effects.</p>
</blockquote>
<p>Even when passing a mutable object to a function this still applies. And to me it clearly explains the reason for the difference in behavior between assigning to the object and operating on the object in the function.</p>
<pre><code>def test(l):
    print &quot;Received&quot;, l, id(l)
    l = [0, 0, 0]
    print &quot;Changed to&quot;, l, id(l)  # New local object created, breaking link to global l

l = [1, 2, 3]
print &quot;Original&quot;, l, id(l)
test(l)
print &quot;After&quot;, l, id(l)
</code></pre>
<p>gives:</p>
<pre class="lang-none prettyprint-override"><code>Original [1, 2, 3] 4454645632
Received [1, 2, 3] 4454645632
Changed to [0, 0, 0] 4474591928
After [1, 2, 3] 4454645632
</code></pre>
<p>The assignment to an global variable that is not declared global therefore creates a new local object and breaks the link to the original object.</p>
------------------------------------------------------------------ <br><h3> Answer 21684541 Nuno Aniceto: </h3><p>As you can state you need to have a mutable object, but let me suggest you to check over the global variables as they can help you or even solve this kind of issue!</p>

<p><a href="http://docs.python.org/3/faq/programming.html#what-are-the-rules-for-local-and-global-variables-in-python" rel="noreferrer">http://docs.python.org/3/faq/programming.html#what-are-the-rules-for-local-and-global-variables-in-python</a></p>

<p>example:</p>

<pre><code>&gt;&gt;&gt; def x(y):
...     global z
...     z = y
...

&gt;&gt;&gt; x
&lt;function x at 0x00000000020E1730&gt;
&gt;&gt;&gt; y
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
NameError: name 'y' is not defined
&gt;&gt;&gt; z
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
NameError: name 'z' is not defined

&gt;&gt;&gt; x(2)
&gt;&gt;&gt; x
&lt;function x at 0x00000000020E1730&gt;
&gt;&gt;&gt; y
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
NameError: name 'y' is not defined
&gt;&gt;&gt; z
2
</code></pre>
<h4> Comment 37922353 Max P Magee: </h4>I was tempted to post a similar response- the original questioner may not have known that what he wanted was in fact to use a global variable, shared among functions. Here&#39;s the link I would have shared: <a href="http://stackoverflow.com/questions/423379/using-global-variables-in-a-function-other-than-the-one-that-created-them" title="using global variables in a function other than the one that created them">stackoverflow.com/questions/423379/&hellip;</a>  In answer to @Tim, Stack Overflow is not only a question and answer site, it&#39;s a vast repository of reference knowledge that only gets stronger and more nuanced- much like an active wiki- with more input.<br>------------------------------------------------------------------ <br><h3> Answer 12686527 matino: </h3><p>Here is the simple (I hope) explanation of the concept <code>pass by object</code> used in Python.<br>
Whenever you pass an object to the function, the object itself is passed (object in Python is actually what you'd call a value in other programming languages) not the reference to this object. In other words, when you call:</p>

<pre><code>def change_me(list):
   list = [1, 2, 3]

my_list = [0, 1]
change_me(my_list)
</code></pre>

<p>The actual object - [0, 1] (which would be called a value in other programming languages) is being passed. So in fact the function <code>change_me</code> will try to do something like:</p>

<pre><code>[0, 1] = [1, 2, 3]
</code></pre>

<p>which obviously will not change the object passed to the function. If the function looked like this:</p>

<pre><code>def change_me(list):
   list.append(2)
</code></pre>

<p>Then the call would result in:</p>

<pre><code>[0, 1].append(2)
</code></pre>

<p>which obviously will change the object. <a href="https://stackoverflow.com/a/534509/831531">This answer</a> explains it well.</p>
<h4> Comment 17172121 pepr: </h4>The problem is that the assignment does something else than you expect. The <code>list = [1, 2, 3]</code> causes reusing the <code>list</code> name for something else and forgeting the originally passed object. However, you can try <code>list[:] = [1, 2, 3]</code> (by the way <code>list</code> is wrong name for a variable. Thinking about <code>[0, 1] = [1, 2, 3]</code> is a complete nonsense. Anyway, what do you think means <i>the object itself is passed</i>? What is copied to the function in your opinion?<br><h4> Comment 36152119 Veky: </h4>@pepr objects aren&#39;t literals. They are objects. The only way to talk about them is giving them some names. That&#39;s why it&#39;s so simple once you grasp it, but enormously complicated to explain. :-)<br><h4> Comment 36239341 pepr: </h4>@Veky: I am aware of that. Anyway, the list literal is converted to the list object. Actually, any object in Python can exist without a name, and it can be used even when not given any name. And you can think about them as about anonymous objects. Think about objects being the elements of a lists. They need not a name. You can access them through indexing of or iterating through the list. Anyway, I insist on <code>[0, 1] = [1, 2, 3]</code> is simply a bad example. There is nothing like that in Python.<br><h4> Comment 36242700 Veky: </h4>@pepr: I don&#39;t necessarily mean Python-definition names, just ordinary names. Of course <code>alist[2]</code> counts as a name of a third element of alist. But I think I misunderstood what your problem was. :-)<br><h4> Comment 36361122 Veky: </h4>Argh. My English is obviously much worse than my Python. :-) I&#39;ll try just once more. I just said you have to give object some names just to talk about them. By that &quot;names&quot; I didn&#39;t mean &quot;names as defined by Python&quot;. I know Python mechanisms, don&#39;t worry.<br>------------------------------------------------------------------ <br><h3> Answer 35260424 Dolf Andringa: </h3><p>Aside from all the great explanations on how this stuff works in Python, I don't see a simple suggestion for the problem. As you seem to do create objects and instances, the Pythonic way of handling instance variables and changing them is the following:</p>
<pre><code>class PassByReference:
    def __init__(self):
        self.variable = 'Original'
        self.Change()
        print self.variable

    def Change(self):
        self.variable = 'Changed'
</code></pre>
<p>In instance methods, you normally refer to <code>self</code> to access instance attributes. It is normal to set instance attributes in <code>__init__</code> and read or change them in instance methods. That is also why you pass <code>self</code> as the first argument to <code>def Change</code>.</p>
<p>Another solution would be to create a static method like this:</p>
<pre><code>class PassByReference:
    def __init__(self):
        self.variable = 'Original'
        self.variable = PassByReference.Change(self.variable)
        print self.variable

    @staticmethod
    def Change(var):
        var = 'Changed'
        return var
</code></pre>
------------------------------------------------------------------ <br><h3> Answer 36775894 itmuckel: </h3><p>To simulate passing an object by reference, wrap it in a one-item list:</p>
<pre><code>class PassByReference:
    def __init__(self, name):
        self.name = name

def changeRef(ref):
    ref[0] = PassByReference('Michael')

obj = PassByReference('Peter')
print(obj.name)

p = [obj]
changeRef(p)

print(p[0].name)
</code></pre>
<p>Assigning to an element of the list mutates the list rather than reassigning a name. Since the list itself has reference semantics, the change is reflected in the caller.</p>
<h4> Comment 92715979 Minh Tran: </h4>You have <i>not</i> changed the private instance variable, <code>name</code>, of the original <code>PassByReference</code> object associated with the reference <code>obj</code>, though. In fact, <code>obj.name</code> will return <code>Peter</code>. The aforementioned comments assumes the definition <code>Mark Ransom</code> gave.<br><h4> Comment 92716018 Minh Tran: </h4>Point being, I don&#39;t agree that it&#39;s a <i>hack</i> (which I take to mean to refer to something that works but for reasons unknown, untested, or unintended by the implementer). You simply replaced one <code>PassByReference</code> object with another <code>PassByReference</code> object in your list and referred to the latter of the two objects.<br><h4> Comment 92715930 Minh Tran: </h4><code>p</code> is reference to a mutable list object which in turn stores the object <code>obj</code>. The reference &#39;p&#39;, gets passed into <code>changeRef</code>. Inside <code>changeRef</code>, a new reference is created (the new reference is called <code>ref</code>) that points to the same list object that <code>p</code> points to. But because lists are mutable, changes to the list are visible by <i>both</i> references. In this case, you used the <code>ref</code> reference to change the object at index 0 so that it subsequently stores the <code>PassByReference(&#39;Michael&#39;)</code> object. The change  to the list object was done using <code>ref</code> but this change is visible to <code>p</code>.<br><h4> Comment 92715951 Minh Tran: </h4>So now, the references <code>p</code> and <code>ref</code> point to a list object that stores the single object, <code>PassByReference(&#39;Michael&#39;)</code>. So it follows that <code>p[0].name</code> returns <code>Michael</code>. Of course, <code>ref</code> has now gone out of scope and may be garbage collected but all the same.<br>------------------------------------------------------------------ <br><h3> Answer 38834546 Brad Porter: </h3><p>I used the following method to quickly convert some Fortran code to Python.  True, it's not pass by reference as the original question was posed, but it is a simple workaround in some cases.</p>
<pre><code>a = 0
b = 0
c = 0

def myfunc(a, b, c):
    a = 1
    b = 2
    c = 3
    return a, b, c

a, b, c = myfunc(a, b, c)
print a, b, c
</code></pre>
<h4> Comment 108869270 kasimir: </h4>Yes, this solves the &#39;pass by reference&#39; in my use case as well. I have a function that basically cleans up values in a <code>dict</code> and then returns the <code>dict</code>. However, while cleaning up it may become apparent a rebuild of a part of the system is required. Therefore, the function must not only return the cleaned <code>dict</code> but also be able to signal the rebuild. I tried to pass a <code>bool</code> by reference, but ofc that doesn&#39;t work. Figuring out how to solve this, I found your solution (basically returning a tuple) to work best while also not being a hack/workaround at all (IMHO).<br>------------------------------------------------------------------ <br><h3> Answer 56069248 Daniel Jour: </h3><p>Since it seems to be nowhere mentioned an approach to simulate references as known from e.g. C++ is to use an "update" function and pass that instead of the actual variable (or rather, "name"):</p>

<pre><code>def need_to_modify(update):
    update(42) # set new value 42
    # other code

def call_it():
    value = 21
    def update_value(new_value):
        nonlocal value
        value = new_value
    need_to_modify(update_value)
    print(value) # prints 42
</code></pre>

<p>This is mostly useful for "out-only references" or in a situation with multiple threads / processes (by making the update function thread / multiprocessing safe).</p>

<p>Obviously the above does not allow <em>reading</em> the value, only updating it.</p>
<h4> Comment 135178374 Karl Knechtel: </h4>I think it would be better to have a separate, language-agnostic Q&amp;A for strategies for emulating pass-by-reference.<br>------------------------------------------------------------------ <br><h3> Answer 40345432 mARK bLOORE: </h3><p>Given the way Python handles values and references to them, the only way you can reference an arbitrary instance attribute is by name:</p>
<pre><code>class PassByReferenceIsh:
    def __init__(self):
        self.variable = 'Original'
        self.change('variable')
        print self.variable

    def change(self, var):
        self.__dict__[var] = 'Changed'
</code></pre>
<p>In real code you would, of course, add error checking on the dict lookup.</p>
------------------------------------------------------------------ <br><h3> Answer 55992875 Liakos: </h3><p>Since dictionaries are passed by reference, you can use a dict variable to store any referenced values inside it.</p>
<pre><code># returns the result of adding numbers `a` and `b`
def AddNumbers(a, b, ref): # using a dict for reference
    result = a + b
    ref['multi'] = a * b # reference the multi. ref['multi'] is number
    ref['msg'] = &quot;The result: &quot; + str(result) + &quot; was nice!&quot;
    return result

number1 = 5
number2 = 10
ref = {} # init a dict like that so it can save all the referenced values. this is because all dictionaries are passed by reference, while strings and numbers do not.

sum = AddNumbers(number1, number2, ref)
print(&quot;sum: &quot;, sum)             # the returned value
print(&quot;multi: &quot;, ref['multi'])  # a referenced value
print(&quot;msg: &quot;, ref['msg'])      # a referenced value
</code></pre>
------------------------------------------------------------------ <br><h3> Answer 39054982 textshell: </h3><p>While pass by reference is nothing that fits well into Python and should be rarely used, there are some workarounds that actually can work to get the object currently assigned to a local variable or even reassign a local variable from inside of a called function.</p>
<p>The basic idea is to have a function that can do that access and can be passed as object into other functions or stored in a class.</p>
<p>One way is to use <code>global</code> (for global variables) or <code>nonlocal</code> (for local variables in a function) in a wrapper function.</p>
<pre><code>def change(wrapper):
    wrapper(7)

x = 5

def setter(val):
    global x
    x = val

print(x)
</code></pre>
<p>The same idea works for reading and <code>del</code>eting a variable.</p>
<p>For just reading, there is even a shorter way of just using <code>lambda: x</code> which returns a callable that when called returns the current value of x. This is somewhat like &quot;call by name&quot; used in languages in the distant past.</p>
<p>Passing 3 wrappers to access a variable is a bit unwieldy so those can be wrapped into a class that has a proxy attribute:</p>
<pre><code>class ByRef:
    def __init__(self, r, w, d):
        self._read = r
        self._write = w
        self._delete = d
    def set(self, val):
        self._write(val)
    def get(self):
        return self._read()
    def remove(self):
        self._delete()
    wrapped = property(get, set, remove)

# Left as an exercise for the reader: define set, get, remove as local functions using global / nonlocal
r = ByRef(get, set, remove)
r.wrapped = 15
</code></pre>
<p>Pythons &quot;reflection&quot; support makes it possible to get a object that is capable of reassigning a name/variable in a given scope without defining functions explicitly in that scope:</p>
<pre><code>class ByRef:
    def __init__(self, locs, name):
        self._locs = locs
        self._name = name
    def set(self, val):
        self._locs[self._name] = val
    def get(self):
        return self._locs[self._name]
    def remove(self):
        del self._locs[self._name]
    wrapped = property(get, set, remove)

def change(x):
    x.wrapped = 7

def test_me():
    x = 6
    print(x)
    change(ByRef(locals(), &quot;x&quot;))
    print(x)
</code></pre>
<p>Here the <code>ByRef</code> class wraps a dictionary access. So attribute access to <code>wrapped</code> is translated to a item access in the passed dictionary. By passing the result of the builtin <code>locals</code> and the name of a local variable, this ends up accessing a local variable. The Python documentation as of 3.5 advises that changing the dictionary might not work, but it seems to work for me.</p>
<h4> Comment 133201958 Peter Mortensen: </h4>Re <i>&quot;The Python documentation as of 3.5&quot;</i>: Can you add the reference? (But **** <b><i>without</i></b> **** &quot;Edit:&quot;, &quot;Update:&quot;, or similar - the answer should appear as if it was written today.)<br>------------------------------------------------------------------ <br><h3> Answer 46136730 Jesse Hogan: </h3><p>Since your example happens to be object-oriented, you could make the following change to achieve a similar result:</p>

<pre><code>class PassByReference:
    def __init__(self):
        self.variable = 'Original'
        self.change('variable')
        print(self.variable)

    def change(self, var):
        setattr(self, var, 'Changed')

# o.variable will equal 'Changed'
o = PassByReference()
assert o.variable == 'Changed'
</code></pre>
<h4> Comment 85556278 Bishwas Mishra: </h4>Although this works. It is not pass by reference. It is &#39;pass by object reference&#39;.<br>------------------------------------------------------------------ <br><h3> Answer 50157212 sergzach: </h3><p>You can merely use <strong>an empty class</strong> as an instance to store reference objects because internally object attributes are stored in an instance dictionary. See the example.</p>

<pre><code>class RefsObj(object):
    "A class which helps to create references to variables."
    pass

...

# an example of usage
def change_ref_var(ref_obj):
    ref_obj.val = 24

ref_obj = RefsObj()
ref_obj.val = 1
print(ref_obj.val) # or print ref_obj.val for python2
change_ref_var(ref_obj)
print(ref_obj.val)
</code></pre>
------------------------------------------------------------------ <br><h3> Answer 54315603 Alok Garg: </h3><p><em>Pass-by-reference</em> in Python is quite different from the concept of pass by reference in C++/Java.</p>
<ul>
<li><p><strong>Java and C#:</strong> primitive types (including string) pass by value (copy). A reference type is passed by reference (address copy), so all changes made in the parameter in the called function are visible to the caller.</p>
</li>
<li><p><strong>C++:</strong> Both pass-by-reference or pass-by-value are allowed. If a parameter is passed by reference, you can either modify it or not depending upon whether the parameter was passed as const or not. However, const or not, the parameter maintains the reference to the object and reference cannot be assigned to point to a different object within the called function.</p>
</li>
<li><p><strong>Python:</strong>
Python is “pass-by-object-reference”, of which it is often said: “Object references are passed by value.” (<a href="https://robertheaton.com/2014/02/09/pythons-pass-by-object-reference-as-explained-by-philip-k-dick/" rel="nofollow noreferrer">read here</a>). Both the caller and the function refer to the same object, but the parameter in the function is a new variable which is just holding a copy of the object in the caller. Like C++, a parameter can be either modified or not in function. This depends upon the type of object passed. For example, an immutable object type cannot be modified in the called function whereas a mutable object can be either updated or re-initialized.</p>
<p>A crucial difference between updating or reassigning/re-initializing the mutable variable is that updated value gets reflected back in the called function whereas the reinitialized value does not. The scope of any assignment of new object to a mutable variable is local to the function in the python. Examples provided by @blair-conrad are great to understand this.</p>
</li>
</ul>
<h4> Comment 102208338 John: </h4>Old but I feel obliged to correct it. Strings are passed by reference in both Java and C#, NOT by value<br><h4> Comment 123598152 jjaskulowski: </h4>No. Everything is passed by value in c#. It is that the value of variable that is an object in c# is exactly and heap ID/address of the object. So when you set something in a function to a new object you set the variable in function to address. Passing by reference means passing an adres to value which is an address to the value for struct types but address to pointer in case of objects.<br>------------------------------------------------------------------ <br><h3> Answer 65935869 Julian wandhoven: </h3><p>Alternatively, you could use <a href="https://en.wikipedia.org/wiki/Ctypes" rel="nofollow noreferrer">ctypes</a> which would look something like this:</p>
<pre><code>import ctypes

def f(a):
    a.value = 2398 ## Resign the value in a function

a = ctypes.c_int(0)
print(&quot;pre f&quot;, a)
f(a)
print(&quot;post f&quot;, a)
</code></pre>
<p>As a is a c int and not a Python integer and apparently passed by reference. However, you have to be careful as strange things could happen, and it is therefore not advised.</p>
------------------------------------------------------------------ <br><h3> Answer 62970753 Magnus: </h3><p>I am new to Python, started yesterday (though I have been programming for 45 years).</p>
<p>I came here because I was writing a function where I wanted to have two so-called out-parameters. If it would have been only one out-parameter, I wouldn't get hung up right now on checking how reference/value works in Python. I would just have used the return value of the function instead. But since I needed <em>two</em> such out-parameters I felt I needed to sort it out.</p>
<p>In this post I am going to show how I solved my situation. Perhaps others coming here can find it valuable, even though it is not exactly an answer to the topic question. Experienced Python programmers of course already know about the solution I used, but it was new to me.</p>
<p>From the answers here I could quickly see that Python works a bit like JavaScript in this regard, and that you need to use workarounds if you want the reference functionality.</p>
<p>But then I found something neat in Python that I don't think I have seen in other languages before, namely that you can return more than one value from a function, in a simple comma-separated way, like this:</p>
<pre><code>def somefunction(p):
    a = p + 1
    b = p + 2
    c = -p
    return a, b, c
</code></pre>
<p>and that you can handle that on the calling side similarly, like this</p>
<pre><code>x, y, z = somefunction(w)
</code></pre>
<p>That was good enough for me and I was satisfied. There isn't any need to use some workaround.</p>
<p>In other languages you can of course also return many values, but then usually in the from of an object, and you need to adjust the calling side accordingly.</p>
<p>The Python way of doing it was nice and simple.</p>
<p>If you want to mimic <em>by reference</em> even more, you could do as follows:</p>
<pre><code>def somefunction(a, b, c):
    a = a * 2
    b = b + a
    c = a * b * c
    return a, b, c

x = 3
y = 5
z = 10
print(F&quot;Before : {x}, {y}, {z}&quot;)

x, y, z = somefunction(x, y, z)

print(F&quot;After  : {x}, {y}, {z}&quot;)
</code></pre>
<p>which gives this result</p>
<pre>
Before : 3, 5, 10
After  : 6, 11, 660
</pre>
<h4> Comment 112078719 juanpa.arrivillaga: </h4>&quot;But then I found something neat in Python that I don&#39;t think I have seen in other languages before, namely that you can return more than one value from a function&quot; No, you can&#39;t. What you are doing is returning a single value, a <code>tuple</code>, which is what the expression <code>a, b, c</code> creates. You then use <i>iterable unpacking</i> to unpack that tuple into separate variables. Of course, in effect, you can think of this as &quot;returning multiple values&quot;, but you aren&#39;t actually doing that, you are returning a container.<br><h4> Comment 112092512 Magnus: </h4>@juanpa.arrivillaga, yes, I was aware of that when I wrote my answer, I had just read about it. But I just described the whole thing in a practical way without going into the details of how it works and add unnecessary length to my answer. You can indeed return multiple values from a function, if it is done in an object or similar, like in a tuple (which in Python is taken care of in the neat way I showed). When I order things from a company, they can send me multiple things, even if it is all in one package.<br><h4> Comment 135178547 Karl Knechtel: </h4>This rambles a lot and is mostly off the topic of OP&#39;s question. It refers instead to this concept: <a href="https://stackoverflow.com/questions/354883">stackoverflow.com/questions/354883</a> - which is well addressed by other existing Q&amp;A.<br>------------------------------------------------------------------ <br><h3> Answer 68167731 Stepan Dyatkovskiy: </h3><p>Use <a href="https://docs.python.org/3/library/dataclasses.html" rel="nofollow noreferrer">dataclasses</a>. Also, it allows you to apply type restrictions (aka &quot;type hints&quot;).</p>
<pre class="lang-py prettyprint-override"><code>from dataclasses import dataclass

@dataclass
class Holder:
    obj: your_type # Need any type? Use &quot;obj: object&quot; then.

def foo(ref: Holder):
    ref.obj = do_something()
</code></pre>
<p>I agree with folks that in most cases you'd better consider not to use it.</p>
<p>And yet, when we're talking about <a href="https://en.wikipedia.org/wiki/State_pattern" rel="nofollow noreferrer"><em>contexts</em></a>, it's worth to know that way.</p>
<p>You can design an explicit context class though. When prototyping, I prefer dataclasses, just because it's easy to serialize them back and forth.</p>
<h4> Comment 131665947 Wolfgang Fahl: </h4>1.9 mill views and 13 years later a decent solution comes up. I have implemented it calling the Holder &quot;State&quot; and adding a boolean value that can now be modified in a different function ... excellent and clean!<br><h4> Comment 135178412 Karl Knechtel: </h4>@WolfgangFahl several prior answers do functionally the same thing, just with a list element, ordinary object attribute etc. instead of a dataclass instance attribute. They all fundamentally work in the same way: since passing an object with reference semantics by value allows for mutation but not reassignment, we convert the desired reassignment into mutation by creating a wrapper object.<br><h4> Comment 135219402 Stepan Dyatkovskiy: </h4>Agreed with @Karl Knechtel totally. Only reason I highlighted this case is that dataclasses support are quite friendly for serialization and provide minimum confusing API. So if somebody will extend your code there will be no temptation to perform list operations on what you supposed to use as a ref holder.<br>------------------------------------------------------------------ <br><h3> Answer 73945173 S.B: </h3><p>There are already many great answers (or let's say opinions) about this and I've read them, but I want to mention a missing one. The one from <a href="https://docs.python.org/3/faq/programming.html#how-do-i-write-a-function-with-output-parameters-call-by-reference" rel="nofollow noreferrer">Python's documentation</a> in the FAQ section. I don't know the date of publishing this page, but this should be our true reference:</p>
<blockquote>
<p>Remember that arguments are <strong>passed by assignment</strong> in Python. Since
assignment just creates references to objects, there’s no alias
between an argument name in the caller and callee, and so <strong>no
call-by-reference</strong> per se.</p>
</blockquote>
<p>If you have:</p>
<pre class="lang-py prettyprint-override"><code>a = SOMETHING

def fn(arg):
    pass
</code></pre>
<p>and you call it like <code>fn(a)</code>, you're doing exactly what you do in assignment. So this happens:</p>
<pre class="lang-py prettyprint-override"><code>arg = a
</code></pre>
<p>An additional reference to <code>SOMETHING</code> is created. Variables are just symbols/names/references. They don't &quot;hold&quot; anything.</p>
------------------------------------------------------------------ <br><h3> Answer 75776510 Bhanuday Sharma: </h3><p>I found other answers a little bit confusing and I had to struggle a while to grasp the concepts. So, I am trying to put the answer in my language. It may help you if other answers are confusing to you too. So, the answer is like this-</p>
<p>When you create a list-</p>
<pre><code>my_list = []
</code></pre>
<p>you are actually creating an object of the class list:</p>
<pre><code>my_list = list()
</code></pre>
<p>Here, my_list is just a name given to the memory address (e.g., 140707924412080) of the object created by the constructor of the 'list' class.</p>
<p>When you pass this list to a method defined as</p>
<pre><code>def my_method1(local_list):
    local_list.append(1)
</code></pre>
<p>another reference to the same memory address 140707924412080 is created. So, when you make any changes/mutate to the object by using append method, it is also reflected outside the my_method1. Because, both the outer list my_list and local_list are referencing the same memory address.</p>
<p>On the other hand, when you pass the same list to the following method,</p>
<pre><code>def my_method2(local_list2):
    local_list2 = [1,2,3,4]
</code></pre>
<p>the first half of the process remains the same. i.e., a new reference/name local_list2 is created which points to the same memory address 140707924412080. But when you create a new list [1,2,3,4], the constructor of the 'list' class is called again and a new object is created. This new object has a completely different memory address, e.g., 140707924412112. When you assign local_list2 to [1,2,3,4], now the local_list2 name refers to a new memory address which is 140707924412112. Since in this entire process you have not made any changes to the object placed at memory address 140707924412080, it remains unaffected.</p>
<p>In other words, it is in the spirit that 'other languages have variables, Python have names'. That means in other languages, variables are referenced to a fixed address in memory. That means, in C++, if you reassign a variable by</p>
<pre><code>a = 1
a = 2
</code></pre>
<p>the memory address where the value '1' was stored is now holding the value '2' And hence, the value '1' is completely lost. Whereas in Python, since everything is an object, earlier 'a' referred to the memory address that stores the object of class 'int' which in turn stores the value '1'. But, after reassignment, it refers to a completely different memory address that stores the newly created object of class 'int' holding the value '2'.</p>
<p>Hope it helps.</p>
------------------------------------------------------------------ <br><h3> Answer 71579032 Celes: </h3><pre><code>def i_my_wstring_length(wstring_input:str = &quot;&quot;, i_length:int = 0) -&gt; int:
    i_length[0] = len(wstring_input)
    return 0

wstring_test  = &quot;Test message with 32 characters.&quot;
i_length_test = [0]
i_my_wstring_length(wstring_test, i_length_test)
print(&quot;The string:\n\&quot;{}\&quot;\ncontains {} character(s).&quot;.format(wstring_test, *i_length_test))
input(&quot;\nPress ENTER key to continue . . . &quot;)
</code></pre>
------------------------------------------------------------------ <br><h3> Answer 66819159 Jop Knoppers: </h3><p>Most likely not the most reliable method but this works, keep in mind that you are overloading the built-in str function which is typically something you don't want to do:</p>
<pre><code>import builtins

class sstr(str):
    def __str__(self):
        if hasattr(self, 'changed'):
            return self.changed

        return self

    def change(self, value):
        self.changed = value

builtins.str = sstr

def change_the_value(val):
    val.change('After')

val = str('Before')
print (val)
change_the_value(val)
print (val)
</code></pre>
------------------------------------------------------------------ <br><h3> Answer 71049904 Youjun Hu: </h3><ol>
<li><p>Python assigns a unique identifier to each object and this identifier can be found by using Python's built-in <code>id()</code> function.
It is ready to verify that actual and formal arguments in a function call have the same id value, which indicates that the dummy argument and actual argument refer to the same object.</p>
</li>
<li><p>Note that the actual argument and the corresponding dummy argument are two names referring to the same object. If you re-bind a dummy argument to a new value/object in the function scope, this does not effect the fact that the actual argument still points to the original object because actual argument and dummy argument are two names.</p>
</li>
<li><p>The above two facts can be summarized as “arguments are passed by assignment”. i.e.,</p>
</li>
</ol>
<pre><code>dummy_argument = actual_argument
</code></pre>
<p>If you re-bind <code>dummy_argument</code> to a new object in the function body, the <code>actual_argument</code> still refers to the original object. If you use <code>dummy_argument[0] = some_thing</code>, then this will also modify <code>actual_argument[0]</code>. Therefore the effect of “pass by reference” can be achieved by modifying the components/attributes of the object reference passed in. Of course, this requires that the object passed is a mutable object.</p>
<ol start="4">
<li>To make comparison with other languages, you can say Python passes arguments by value in the same way as C does, where when you pass &quot;by reference&quot; you are actually passing by value the reference (i.e., the pointer)</li>
</ol>
------------------------------------------------------------------ <br><h3> Answer 75696407 Fernando Fabreti: </h3><p>My Tests:</p>
<pre class="lang-py prettyprint-override"><code>#objects:
def change_me(dict):
    dict.update(b=10, c=10)

d = {'a': 1, 'b': 1}
change_me(d)
d
{'a': 1, 'b': 10, 'c': 10}
# conclusion: objects are passed by reference
</code></pre>
<pre class="lang-py prettyprint-override"><code>#strings:
def change_me(str):
    str = 'another string'

d = 'a string'
change_me(d)
d
'a string'
# conclusion: strings are passed by value
# you may return a value and capture it again
# like:  d = change_me(d)
</code></pre>
------------------------------------------------------------------ <br><h3> Answer 76587103 kiriloff: </h3><p>A method's argument is &quot;passed by assignment&quot;: a reference to an object is passed by value.</p>
<p>With</p>
<pre><code>class PassByReference:
    def __init__(self):
        self.variable = 'Original'
        self.change( self.variable )
        print( self.variable )

    def change(self, var):
        var = 'Changed'

passbyref = PassByReference()
</code></pre>
<p>we can witness that rebinding a value to the reference copy passed as an argument will will not change the value bound to the object in the outer scope.</p>
<p>A way to circumvent is to pass your (mutable) argument as a one-element list, and alter its first (and unique) value in the body of the method.</p>
<pre><code>class PassByReference:
    def __init__(self):
        self.variable = ['Original']
        self.change( self.variable )
        print( self.variable[0] )

    def change(self, var):
        var[0] = 'Changed'

passbyref = PassByReference()
</code></pre>
------------------------------------------------------------------ <br><h3> Answer 67988352 TVK: </h3><p>I solved a similar requirement as follows:</p>
<p>To implement a member function that changes a variable, dont pass the variable itself, but pass a <code>functools.partial</code> that contains <code>setattr</code> referring to the variable.
Calling the <code>functools.partial</code> inside <code>change()</code> will execute <code>settatr</code> and change the actual referenced variable.</p>
<p>Note that <code>setattr</code> needs the name of the variable as string.</p>
<pre><code>class PassByReference(object):
    def __init__(self):
        self.variable = &quot;Original&quot;
        print(self.variable)        
        self.change(partial(setattr,self,&quot;variable&quot;))
        print(self.variable)

    def change(self, setter):
        setter(&quot;Changed&quot;)
</code></pre>
------------------------------------------------------------------ <br><h3> Answer 67891176 JustBeingHelpful: </h3><p>This might be an elegant object-oriented solution without this functionality in Python.  An even more elegant solution would be to have any class you make subclass from this.  Or you could name it &quot;MasterClass&quot;.  But instead of having a single variable and a single Boolean, make them a collection of some kind.  I fixed the naming of your instance variables to comply with <a href="https://pep8.org/" rel="nofollow noreferrer">PEP 8</a>.</p>
<pre><code>class PassByReference:
    def __init__(self, variable, pass_by_reference=True):
        self._variable_original = 'Original'
        self._variable = variable
        self._pass_by_reference = pass_by_reference # False =&gt; pass_by_value
        self.change(self.variable)
        print(self)

    def __str__(self):
        print(self.get_variable())

    def get_variable(self):
        if pass_by_reference == True:
            return self._variable
        else:
            return self._variable_original

    def set_variable(self, something):
        self._variable = something

    def change(self, var):
        self.set_variable(var)

def caller_method():

    pbr = PassByReference(variable='Changed') # This will print 'Changed'
    variable = pbr.get_variable() # This will assign value 'Changed'

    pbr2 = PassByReference(variable='Changed', pass_by_reference=False) # This will print 'Original'
    variable2 = pbr2.get_variable() # This will assign value 'Original'
</code></pre>
------------------------------------------------------------------ <br><h3> Answer 69642519 eyal0931: </h3><p>Most of the time, the variable to be passed by reference is a class member.
The solution I suggest is to use a decorator to add both a field that is mutable and corresponding property. The field is a class wrapper around the variable.</p>
<p>The <code>@refproperty</code> adds both <code>self._myvar</code> (mutable) and <code>self.myvar</code> property.</p>
<pre><code>@refproperty('myvar')
class T():
    pass

def f(x):
   x.value=6

y=T()
y.myvar=3
f(y._myvar)
print(y.myvar) 
</code></pre>
<p>It will print 6.</p>
<p>Compare this to:</p>
<pre><code>class X:
   pass

x=X()
x.myvar=4

def f(y):
    y=6

f(x.myvar)
print(x.myvar) 
</code></pre>
<p>In this case, it won't work. It will print 4.</p>
<p>The code is the following:</p>
<pre><code>def refproperty(var,value=None):
    def getp(self):
        return getattr(self,'_'+var).get(self)

    def setp(self,v):
        return getattr(self,'_'+var).set(self,v)

    def decorator(klass):
        orginit=klass.__init__
        setattr(klass,var,property(getp,setp))

        def newinit(self,*args,**kw):
            rv=RefVar(value)
            setattr(self,'_'+var,rv)
            orginit(self,*args,**kw)

        klass.__init__=newinit
        return klass
    return decorator

class RefVar(object):
    def __init__(self, value=None):
        self.value = value
    def get(self,*args):
        return self.value
    def set(self,main, value):
        self.value = value
</code></pre>
------------------------------------------------------------------ <br><h3> Answer 72357404 paulyang0125: </h3><p>I share another fun way for people to comprehend this topic over a handy tool - <em><a href="https://pythontutor.com/" rel="nofollow noreferrer">Python Tutor: Learn Python, JavaScript, C, C++, and Java programming by visualizing code</a></em> based on the example of passing a mutable list from @Mark Ransom.</p>
<p>Just play it around, and then you will figure it out.</p>
<ol>
<li><p>Passing a String</p>
<p><a href="https://i.stack.imgur.com/hBgao.png" rel="nofollow noreferrer"><img src="https://i.stack.imgur.com/hBgao.png" alt="Enter image description here" /></a></p>
</li>
<li><p>Passing a List</p>
<p><a href="https://i.stack.imgur.com/7ofdY.png" rel="nofollow noreferrer"><img src="https://i.stack.imgur.com/7ofdY.png" alt="Enter image description here" /></a></p>
</li>
</ol>
<h4> Comment 133202410 Peter Mortensen: </h4>It would be much clearer that this is not a tool recommendation if the images contained free-hand circles to <b><i>highlight</i></b> the essential part for this answer. The images also ought to be cropped and otherwise reduced in size to the absolute minimum.<br>------------------------------------------------------------------ <br><h3> Answer 70007855 mo FEAR: </h3><p>A simple answer:</p>
<p>In Python, like C++, when you create an object instance and pass it as a parameter, no copies of the instance itself get made, so you are referencing the same instance from outside and inside the function and are able to modify the component datums of the same object instance, hence changes are visible to the outside.</p>
<p>For basic types, Python and C++ also behave the same to each other, in that copies of the instances are now made, so the outside sees/modifies a different instance than the inside of the function. Hence changes from the inside are not visible on the outside.</p>
<p>Here comes the real difference between Python and C++:</p>
<p>C++ has the concept of address pointers, and C++ allows you to pass pointers instead, which bypasses the copying of basic types, so that the inside of the function can affect the same instances as those outside, so that the changes are also visible to the outside. This has no equivalent in Python, so is not possible without workarounds (such as creating wrapper types).</p>
<p>Such pointers can be useful in Python, but it's not as necessary as it is in C++, because in C++, you can only return a single entity, whereas in Python you can return multiple values separated by commas (i.e., a tuple). So in Python, if you have variables a,b, and c, and want a function to modify them persistently (relative to the outside), you would do this:</p>
<pre><code>a = 4
b = 3
c = 8

a, b, c = somefunc(a, b, c)
# a, b, and c now have different values here
</code></pre>
<p>Such syntax is not easily possible in C++, thus in C++ you would do this instead:</p>
<pre><code>int a = 4
int b = 3
int c = 8
somefunc(&amp;a, &amp;b, &amp;c)
// a, b, and c now have different values here
</code></pre>
<h4> Comment 124521913 juanpa.arrivillaga: </h4>I&#39;m speaking of Python. The interpreter <i>makes no distinction between &quot;basic types&quot; and &quot;other types&quot;</i> And in CPython at least, <b>all objects are allocated on a privately managed heap</b>. You seem to have no basic knowledge about the internals of Python, let alone the semantics of the langauge<br><h4> Comment 124425335 juanpa.arrivillaga: </h4>&quot;For basic types, python and c++ also behave the same to each other, in that copies of the instances are now made&quot;, no that is not correct. Copies of objects <i>are never made as part of the evaluation strategy</i><br><h4> Comment 124750869 juanpa.arrivillaga: </h4>you are simply mistaken. What you are calling &quot;basic types&quot; are not treated <i>in any way differently</i> when they are passed to functions or by the assignment operator. You are operating under totally false premises.<br><h4> Comment 124521920 juanpa.arrivillaga: </h4>The objects aren&#39;t modified <b>by assignment to the parameter</b>, but <b>that works that way for all objects</b>, because it isn&#39;t an issue of the <i>type</i> of object, but rather, the semantics of assignment and the evaluation strategy. In Python, <i>some types are merely immutable</i>. that is, they <i>expose no mutator methods</i>. However, we <i>can</i> (if we are willing to delve into implementation details) mutate them, and indeed, you&#39;ll see the evaluation strategy is exactly the same<br><h4> Comment 124744313 mo FEAR: </h4>This isn&#39;t about objects! It&#39;s about BASIC TYPES. Python treats them behind the scenes as objects, and they have to exist somewhere in memory. But when passed as parameters to a function, COPIES have to be made (by fundamental rules of information theory), otherwise when the function returns, the original variables that were passed to the function, would also get modified. BUT THEY DON&#39;T. TRY IT (Excuse the caps, I don&#39;t know how to achieve the bold effect). They only way this can be the case, is if there is a COPY somewhere else in memory, which is point of what is above.<br><h4> Comment 124744378 mo FEAR: </h4>In other words... one way or another, irrespective how you consider it from a philosophical standpoint, python DOES treat basic types DIFFERENTLY than it does for &quot;other types&quot;, just like C++. Saying &quot;by assignment to the parameter&quot; is pointless and philosophical, since if you change a basic type that is a member of &quot;another type&quot;, using THAT SAME ASSIGNMENT OPERATOR, then UNLIKE &quot;other types&quot;, the actual value DOES change, irrespective from where it is referenced after that.<br><h4> Comment 124744621 mo FEAR: </h4>To clarify (since the last statement above is not fully correct but I can&#39;t edit it anymore: If you assign to an &quot;other type&quot;, you are changing what instance it points to, without necessarily deleting the original instance (as long as it is pointed to by another reference). When you do this to a basic type though, even though it&#39;s technically an object in python, python still changes its actual value in memory, rather than what instance (or address) that reference points to. Python doesn&#39;t create a new instance (or memory location) just because you changed the value of an int, and then garbage<br><h4> Comment 124744631 mo FEAR: </h4>collect the old one, although it would do this for &quot;other types&quot;. And this difference holds despite using the same assignment operator in all cases.<br><h4> Comment 124750873 juanpa.arrivillaga: </h4>i.e. &quot;If you assign to an &quot;other type&quot;, you are changing what instance it points to, without necessarily deleting the original instance (as long as it is pointed to by another reference). When you do this to a basic type though, even though it&#39;s technically an object in python, python still changes its actual value in memory, rather than what instance (or address) that reference points to. &quot; is <i>totally incorrect</i>, assuming what you are saying is even coherent (it isn&#39;t, one doesn&#39;t <i>assign to types</i>, you assign to <i>variables</i>).<br><h4> Comment 124521269 mo FEAR: </h4>Your comment makes no sense. Are you speaking of python or c++? If python, then how the interpreter goes about differs whether they are basic types or not. Internally python uses an equivalent of a stack to manage local basic object types, and these are copies. If they weren&#39;t, then the originals outside the function call would be irreversibly modified, which they arent, which raises the question, have you ever even used python?!<br>