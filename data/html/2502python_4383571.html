 <h2> Title: Importing files from different folder </h2> <h4> Ivan, question_id: 4383571 </h4>Score: 2502, Tags: {python,importerror,python-import} <br><p>I have this folder structure:</p>
<pre><code>application
├── app
│   └── folder
│       └── file.py
└── app2
    └── some_folder
        └── some_file.py
</code></pre>
<p>How can I import a function from <code>file.py</code>, from within <code>some_file.py</code>? I tried:</p>
<pre class="lang-py prettyprint-override"><code>from application.app.folder.file import func_name
</code></pre>
<p>but it doesn't work.</p>
<h4> Kavin Raju S, Id: 109289974 Score: 5: </h4>Reading the official documentation helped me a lot! <a href="https://docs.python.org/3/reference/import.html#package-relative-imports" rel="nofollow noreferrer">docs.python.org/3/reference/&hellip;</a><br><h4> wim, Id: 74009194 Score: 2: </h4>Related:  <a href="http://stackoverflow.com/q/43476403/674039">stackoverflow.com/q/43476403/674039</a><br><h4> Gonzalo, Id: 118961726 Score: 0: </h4>If you have a dash in the name of the subfolder, it SHOULD BE UNDERSCORE. For example my-package and inside you have my_app folder and tests folder. If my_app is named my-app, you will have import problems<br><h4> smci, Id: 120151575 Score: 0: </h4>Neither <code>application</code> nor <code>app1</code>, <code>app2</code>, <code>folder</code>, <code>some_folder</code> are packages, and do not contain <code>__init__.py</code>, right? If you&#39;re going to be doing a lot of this, time to make them a package.<br><h4> Jeyekomon, Id: 124434057 Score: 0: </h4>It depends whether you understand <code>app</code> and <code>app2</code> as two logically separate projects/packages or not. If they are separate (for example the <code>app</code> is a common utility for several apps <code>app2</code>, <code>app3</code>, ...) then you can <a href="https://stackoverflow.com/questions/4830856/is-it-possible-to-use-pip-to-install-a-package-from-a-private-github-repository">install the <code>app</code> from its Github repository</a> into <code>app2</code>&#39;s (virtual) environment as a dependency using <code>pip</code> and then use it the same way you use any other third-party package.<br><h4> user3807691, Id: 125189755 Score: 0: </h4>How do I deploy the same on aws lambda using aws sam?<br><h4> Karl Knechtel, Id: 129822042 Score: 0: </h4>@JohnAllen it&#39;s not actually that hard. There are just a few conceptual issues that are poorly explained. A lot of the answers are duplicates, or re-organizations of various subsets of the same few simple ideas.<br><h4> pyjamas, Id: 134041749 Score: 0: </h4>A big source of confusion for me was that certain IDEs will make this problem disappear. In OP&#39;s example, running <code>some_file.py</code> should cause <code>ModuleNotFoundError: No module named &#39;application&#39;</code>, however if you run the file in PyCharm it will work! This is because PyCharm automatically appends the project root to <code>sys.path</code> so the <code>application</code> package is visible. My related question <a href="https://stackoverflow.com/q/75990606/3620725">here</a> gives a more complete example and some solutions.<br><h4> pyjamas, Id: 134041873 Score: 0: </h4>Another point of confusion is that when you have your project root in <code>sys.path</code> it <a href="https://imgur.com/9nPBT3k" rel="nofollow noreferrer">runs</a> with no errors even if you don&#39;t have any <code>__init__.py</code> files. This contradicts many highly upvoted comments and answers.<br>------------------------------------------------------------------ <br><h3> schmudu, Id: 47563957, Score: 13: </h3><p>In my case I had a class to import.  My file looked like this:</p>

<pre><code># /opt/path/to/code/log_helper.py
class LogHelper:
    # stuff here
</code></pre>

<p>In my main file I included the code via:</p>

<pre><code>import sys
sys.path.append("/opt/path/to/code/")
from log_helper import LogHelper
</code></pre>
<h4> Walter, Comment 102134756 Score: 2: </h4>@not2qubit sys wasn&#39;t imported in the answer.<br>------------------------------------------------------------------ <br><h3> danday74, Id: 48859135, Score: 53: </h3><p>Given a folder structure like</p>
<pre><code>├── main.py
└── myfolder
    └── myfile.py
</code></pre>
<p>Where <code>myfile.py</code> contains</p>
<pre><code>def myfunc():
    print('hello')
</code></pre>
<p>To call <code>myfunc</code> from <code>main.py</code>, use:</p>
<pre><code>from myfolder.myfile import myfunc
myfunc()
</code></pre>
<h4> Alexander Rossa, Comment 92813593 Score: 61: </h4>This is completely unrelated to the question which asks about importing files from a different branch of the file tree than the current working directory.<br><h4> Marc L., Comment 99549389 Score: 14: </h4>Lovely diagrams that expressly ignore OP&#39;s question.<br><h4> Vincent, Comment 85321241 Score: 13: </h4>adding an <b>init</b>.py (empty) configuration file in myfolder worked for me on linux (y)<br><h4> mrgloom, Comment 87141663 Score: 11: </h4>@Vincent did you mean <code>__init__.py</code>?<br><h4> MattSom, Comment 102784031 Score: 7: </h4>This is not what the OP was questioning about.<br><h4> Crearo Rotar, Comment 91640700 Score: 4: </h4>For some reason adding <code>__init__.py</code> doesn&#39;t work for me. I&#39;m using Py 3.6.5 on Ubuntu 18. It works on Pycharm but not from terminal<br><h4> OuuGiii, Comment 104518830 Score: 3: </h4>This is not answering the question at all.<br><h4> Vincent, Comment 87141698 Score: 2: </h4>@mrgloom indeed<br><h4> mrgloom, Comment 87141921 Score: 1: </h4>Also seems <code>__init__.py</code> is not needed anymore in modern python 3, <a href="https://stackoverflow.com/a/39991978/1179925">stackoverflow.com/a/39991978/1179925</a><br><h4> constiii, Comment 128609484 Score: 1: </h4>that does not address the problem unfortunately<br><h4> Guilherme Araujo Lima da Silva, Comment 109705354 Score: 1: </h4>The only answer that worked for me. I tried the others with no sucess at all. I place an empty <code>__init__.py</code> files in the subfolder but it ran correctly without it.<br><h4> kağan hazal ko&#231;demir, Comment 122609615 Score: 0: </h4>what about in myfile.py i want to call function from main.py ? could be with init ?<br><h4> alper, Comment 91762255 Score: 0: </h4>What if <code>myfunc</code> located on a parent directory? @danday74<br>------------------------------------------------------------------ <br><h3> Cameron, Id: 4383597, Score: 2260: </h3><p>Note: This answer was intended for a very specific question. For most programmers coming here from a search engine, this is not the answer you are looking for. Typically you would structure your files into packages (see other answers) instead of modifying the search path.</p>
<hr />
<p>By default, you can't. When importing a file, Python only searches the directory that the entry-point script is running from and <code>sys.path</code> which includes locations such as the package installation directory (it's actually <a href="https://docs.python.org/3/library/sys.html#sys.path" rel="noreferrer">a little more complex</a> than this, but this covers most cases).</p>
<p>However, you can add to the Python path at runtime:</p>
<pre><code># some_file.py
import sys
# caution: path[0] is reserved for script path (or '' in REPL)
sys.path.insert(1, '/path/to/application/app/folder')

import file
</code></pre>
<h4> pseudosudo, Comment 8761102 Score: 561: </h4><code>sys.path.append(&#39;&#47;path&#47;to&#47;application&#47;app&#47;folder&#39;)</code> is cleaner imo<br><h4> Cameron, Comment 8763777 Score: 531: </h4>@pseudosudo: Yep, it is, but inserting it at the beginning has the benefit of guaranteeing that the path is searched before others (even built-in ones) in the case of naming conflicts.<br><h4> Cameron, Comment 53217573 Score: 77: </h4>@Ofir: No, this isn&#39;t a nice clean pythonic solution. In general, you should be using packages (which are based on directory trees). This answer was specific to the question asked, and for some reason continues to accrue a large number upvotes.<br><h4> Ofir, Comment 53210287 Score: 59: </h4>Is it considered as a pythonic way to manage .py files in folders? I&#39;m wondering... why it&#39;s not supported by default? it doesn&#39;t make sense to maintain all .py files in a single directory..<br><h4> ArtOfWarfare, Comment 29361902 Score: 10: </h4>@kreativitea - <code>sys.path</code> returns a <code>list</code>, not a <code>deque</code>, and it&#39;d be silly to convert the <code>list</code> to a <code>deque</code> and back.<br><h4> rain_, Comment 76299022 Score: 3: </h4>@Cameron: Could you then provide the clean pythonic way to do this, or a link to the solution?<br><h4> rain_, Comment 76329076 Score: 2: </h4>@Cameron. It does not work for me. Im using a project folder. with some subfolders on it. One of those subfolders containts an <b>init</b>.py and files.py which has functions on them. From any file in a subfolder I use: from functions_folder.functions import *, and it just doesnt work.<br><h4> Steve Scott, Comment 110271454 Score: 2: </h4>Interesting. It only takes a path as a string. It does not accept a path object.<br><h4> AdjunctProfessorFalcon, Comment 65468402 Score: 2: </h4>@Cameron What exactly is &quot;the directory that the entry-point script is running from&quot; mean? Thanks!<br><h4> calder-ty, Comment 65484792 Score: 2: </h4>@Malvin9000 That means that if the file you are working on is not the main file for the program. For example say you are working on a module named <code>foo</code> and you want it imports a package named <code>bar</code>. Now if you write another script, <code>spam</code> that imports <code>foo</code> then <code>spam</code> is the entry-point script, and that when <code>foo</code> calls <code>import bar</code> python will search in <code>foo</code>&#39;s directory and then the directory containing <code>spam</code>.<br><h4> Haseeb, Comment 75944891 Score: 2: </h4>I already have the path in sys.path. When I do <code>print(sys.path)</code> it shows me the path is there but when I try and import it still gives me the <b>ImportError</b>. Why could this be happening?<br><h4> ArtOfWarfare, Comment 29287356 Score: 1: </h4>Now if only Python <code>lists</code> had a <code>prepend</code> method so that the best choice wouldn&#39;t be ugly looking. I understand the reason why <code>prepend</code> doesn&#39;t exist (because it would have worse run times than <code>append</code>), but it seems to be a moot reason. Shouldn&#39;t easy to read be valued over quick to run?<br><h4> Hi-Angel, Comment 111603769 Score: 1: </h4>Doesn&#39;t work for me. I have a file <code>foo</code> which I import, which in turn imports <code>conftest</code>, which located at a <code>..&#47;conftest.py</code> file. So I do <code>sys.path.append(tests_dir)</code>, where <code>tests_dir</code> I tried to be both <code>..&#47;</code> and an absolute path. However upon executing <code>import foo</code> I still get &quot;No module test named &#39;conftest&#39;`.<br><h4> Isi, Comment 113280478 Score: 1: </h4>@Shalomi11 On Windows, I recommend <code>sys.path.insert(1, os.path.abspath(&#39;&#47;path&#47;to&#47;application&#47;app&#47;folder&#39;))</code>, since with the notation above, the slashs are not how they should be in Windows. (You can check this if you put a breakpoint after this line and then in the debug mode, check &quot;sys.path&quot;)<br><h4> mcp, Comment 118119973 Score: 1: </h4>@Cameron Can you link to the pythonic solution you described, involving packages and directory trees?<br><h4> Cameron, Comment 76301755 Score: 1: </h4>@rain_: Use <a href="https://docs.python.org/2/tutorial/modules.html#packages" rel="nofollow noreferrer">Python packages</a> as suggested by joey&#39;s answer.<br><h4> kreativitea, Comment 29359561 Score: 0: </h4>@ArtOfWarfare deques solve the runtime issue, and they have an appendleft method.  If you need a list, use a list, if you need a deque, use a deque.<br><h4> Andreas Forsl&#246;w, Comment 102567942 Score: 0: </h4>@GabrielStaples yes, it does work on relative paths.<br><h4> Andreas Forsl&#246;w, Comment 102568062 Score: 0: </h4>Another thing worth pointing out about this approach, which makes it non-pythonic, is that you cannot have the same name for any of your <code>sys.path</code> modules as one of your local modules. I.e. you cannot import <code>sys&#47;path&#47;module.py</code> to your <code>current&#47;package&#47;main.py</code> if <code>current&#47;package&#47;main.py</code> imports <code>current&#47;package&#47;module.py</code>. In other words, all the imported modules has to have unique names.<br><h4> McLawrence, Comment 108591641 Score: 0: </h4>It&#39;s important to note that even if you use something like <code>os.path.abspath</code> aliases like <code>~</code> for your home directory are not replaced.<br><h4> HAL9000, Comment 121715114 Score: 0: </h4>would it be possible to add all those &quot;custom&quot; packages in a common python file or do you need to add this line in all the .py files that need to import those custom modules?<br><h4> theX, Comment 111857946 Score: 0: </h4>@Hi-Angel , does this solve your problem?: <a href="https://stackoverflow.com/questions/62886769/is-it-possible-to-import-a-python-file-from-outside-the-directory-the-main-file" title="is it possible to import a python file from outside the directory the main file">stackoverflow.com/questions/62886769/&hellip;</a><br><h4> Hi-Angel, Comment 111862053 Score: 0: </h4>@theX thanks, I should try it. For now I worked around this be placing the script in a different directory.<br><h4> Shalomi90, Comment 112784296 Score: 0: </h4>Hi guys, I have the same problem but the solution doesnt work. the path in the brackets is underlined and can&#39;t be find. What can I do? Its the correct path<br><h4> pyjamas, Comment 134042255 Score: 0: </h4>It&#39;s also worth mentioning that if you use PyCharm or Spyder then by default you <i>can</i> just use absolute imports without any errors because the IDE automatically adds your project directory to <code>sys.path</code>, which is the same thing this answer does. I think that&#39;s why there are wrong answers like joey&#39;s saying it should just work with so many upvotes. See also <a href="https://stackoverflow.com/q/75990606">Automatically add project to sys.path in VS Code</a><br><h4> Sermet Pekin, Comment 124123187 Score: 0: </h4>@Cameron thanks for your helpful answer. It has at least one more special case which I found useful. And that case is when I want to include my python file to the Spyder and Jupyter platforms from my own library. Same code should work in both platforms and when I copy and it does.<br>------------------------------------------------------------------ <br><h3> joey, Id: 21995949, Score: 1332: </h3><p>There is nothing wrong with:</p>
<pre><code>from application.app.folder.file import func_name
</code></pre>
<p>Just make sure <code>folder</code> also contains an <code>__init__.py</code>. This allows it to be included as a package. I am not sure why the other answers talk about <code>PYTHONPATH</code>.</p>
<h4> jay, Comment 48464320 Score: 91: </h4>@Xinyang It can be an empty file. Its very existence tells Python to treat the directory as a package.<br><h4> XYZ, Comment 48380399 Score: 87: </h4>What&#39;s inside the <code>init.py</code> or <code>__init__.py</code> file?<br><h4> dasWesen, Comment 76216537 Score: 85: </h4>Whatever I try, this won&#39;t work. I want to import from a &quot;sibling&quot; directory, so one up one down. All have __ init __.py&#39;s, including parent. Is this python 3 -specific?<br><h4> msvalkon, Comment 33747835 Score: 85: </h4>Because this doesn&#39;t cover the cases where modifying <code>PYTHONPATH</code> is necessary. Say you have two folders on the same level: <code>A</code> and <code>B</code>. <code>A</code> has an <code>__init.py__</code>. Try importing something from <code>B</code> within <code>A</code>.<br><h4> Scott Prive, Comment 59232806 Score: 33: </h4>This is not currently the highest voted answer, but it IS the most correct answer (for most cases). Simply create a package. It&#39;s not hard.   The other answers are needed because sometimes you might be restricted from certain system changes (creating or modifying a file, etc) like during testing.<br><h4> kakyo, Comment 99574150 Score: 23: </h4>running this script in command line with py3.7 on Windows gives me <code>No module named application.app.folder.file</code>. I have all the <b>init</b>.py in place including the one for the parent folder<br><h4> Yibo Yang, Comment 74431473 Score: 19: </h4>Of course this answer assumes that <code>application</code> and <code>app</code> are packages already (i.e. you already have <code>__init__.py</code> in both of them). As the result of adding <code>__init__.py</code> also to <code>folder</code>, <code>application.app.folder</code> becomes a (sub) <i>package</i>, from which you can access the <i>module</i> <code>application.app.folder.file</code>, whose symbol <code>func_name</code> can now be imported<br><h4> Lei_Bai, Comment 118598955 Score: 9: </h4>I am using python3, and it does not work for me<br><h4> sofly, Comment 42074035 Score: 8: </h4>this is a great answer - I was missing the <b>init</b>.py to initialize the package. Also encourages best practice so that there&#39;s less risk of namespace collision. Thanks!<br><h4> pyjamas, Comment 134041530 Score: 6: </h4>Even with <code>__init__.py</code> in every folder, absolute imports of adjacent packages doesn&#39;t work unless the root directory is in PYTHONPATH. I&#39;m not sure how there are 1200 upvotes on an answer that just <a href="https://i.imgur.com/4J5BKVL.png" rel="nofollow noreferrer">doesn&#39;t work</a>... I&#39;m assuming anyone not getting <code>ModuleNotFoundError</code> is running their code through an IDE like PyCharm that automatically adds the project directory to <code>sys.path</code>. You can read more <a href="https://stackoverflow.com/q/75990606/3620725">here</a> and <a href="https://stackoverflow.com/q/14132789/3620725">here</a><br><h4> martin36, Comment 121347547 Score: 5: </h4>In order to get this working for me, I had to add the lines <code>import sys</code> and <code>sys.path.insert(0, &#39;&#39;)</code> before importing the module<br><h4> mold, Comment 110988868 Score: 5: </h4>This sounds like a joke. Many guys writing a lot of things about what is right and don&#39;t and finally someone says that is not &quot;nothing wrong with&quot;...<br><h4> pouya, Comment 115147321 Score: 3: </h4>Wish Python 4 does something sensible about this so called Package system. No ,matter ow many <code>__init__.py</code> you put in place, python always fails to find modules.<br><h4> amdev, Comment 104930037 Score: 3: </h4>i have folder <code>a&#47;test.py</code> and the file <code>b.py</code> as the same level of a folder. even by adding a <code>__init__.py</code> file to the root folder (as side of <code>a</code> folder with <code>b.py</code>) i cant import a function from <code>b.py</code> file inside <code>test.py</code>...<br><h4> JohnAllen, Comment 128484756 Score: 3: </h4>This doesn&#39;t work. Simple as that. It SHOULD work, but it doesn&#39;t.<br><h4> benso8, Comment 132681277 Score: 2: </h4>I don&#39;t think this works with Python 3.8. I had issues using this approach.<br><h4> KansaiRobot, Comment 130966964 Score: 2: </h4>it doesn&#39;t work<br><h4> Pit Digger, Comment 131357682 Score: 2: </h4>This doesnt work, its so weird<br><h4> ashrasmun, Comment 121828959 Score: 2: </h4>ModuleNotFoundError: No module named &#39;application&#39; :(<br><h4> Mohd, Comment 116332233 Score: 2: </h4>Working and not working ... works when I try <code>from A.file import funcA</code> at level <code>Z</code>  (folder that has A and B as sub-folder)  at the IPython console.  However, running  <code>funcB</code> inside <code>B</code> folder that has  <code>from A.file import funcA</code> fails and throws the error (ModuleNotFoundError: No module named &#39;FashionColor&#39;). Note that running <code>funcB</code>  will change the working directory to <code>B</code>.  All folders have <b>init</b>.py.<br><h4> Minh Nghĩa, Comment 104210299 Score: 2: </h4>Is the <code>__init__.py</code> still required, given implicit package namespace?<br><h4> SnitchingAuggie, Comment 88619028 Score: 2: </h4>Is there a solution to this problem now? I can&#39;t find a way to circumvent the problem and I find it very confusing to have all files for one single program in one folder<br><h4> Sunding Wei, Comment 66214640 Score: 2: </h4>The empty <b>init</b>.py is vital in the container directory, thanks.<br><h4> dasWesen, Comment 80973920 Score: 2: </h4>@borgr I think I circumvented it back then... Sorry, I don&#39;t remember what code that problem was in, this was too long ago (and it&#39;s not relevant for me right now). But there seems to be a common issue, so if anyone else has the problem right now, yes, please go ahead and open a new question.<br><h4> Ax3l, Comment 55984838 Score: 2: </h4><code>__init__.py</code> syntax is described in more detail in   <a href="https://docs.python.org/3/tutorial/modules.html#packages" rel="nofollow noreferrer">docs.python.org/3/tutorial/modules.html#packages</a> and is useful if the package resides in a system or PYTHONPATH (sub-)dir or inside a dir of the calling application itself.<br><h4> Brōtsyorfuzthrāx, Comment 84854737 Score: 1: </h4>@msvalkon If changing the path to directory B won&#39;t break your program, you can use symbolic links along with this answer to solve that problem. Let&#39;s say you&#39;re in directory A and want to import something in directory B. Add <code>__init__.py</code> to directory B. Make a symbolic link of directory B; put it in directory A. In directory A, <code>import B.yourModule</code>.<br><h4> borgr, Comment 80766418 Score: 1: </h4>@dasWesen, don&#39;t think it should differ much, but if this doesn&#39;t help you, ask a new one<br><h4> Vishwas Sathish, Comment 136427243 Score: 1: </h4>This answer seems to be wrong as others pointed out. Does not work for Python 3.7 and 3.9. Wonder why it has so many upvotes.<br><h4> zlr, Comment 35278155 Score: 0: </h4>that&#39;s what i was looking for, ie works with standard local lib directory<br><h4> Bebotron, Comment 131482863 Score: 0: </h4>Does note work for files in sibling directories.<br><h4> Alirezaarabi, Comment 132103764 Score: 0: </h4>this is not worked for me. but <code>PYTHONPATH</code> worked<br><h4> Yeahprettymuch, Comment 110836317 Score: 0: </h4>How would <code>application.app.folder.file</code> be changed in case there was a space in the name of the folder? Doesn&#39;t seem to be any clear answer to that.<br><h4> Andrew K, Comment 123114915 Score: 0: </h4>If you are using a PEP8 formatter, you will run into problems here since module imports are automatically sorted to the top of the file for imports. You can use #noqa to ignore these lines... but wowza that&#39;s ugly<br><h4> Ashu, Comment 100997997 Score: 0: </h4>If my folder name is a_b_c and which contains app.py so how we can access it? @joey<br><h4> SMDC, Comment 88880856 Score: 0: </h4>This is the easiest solution<br>------------------------------------------------------------------ <br><h3> slizb, Id: 40612922, Score: 243: </h3><p>When modules are in parallel locations, as in the question:</p>

<pre><code>application/app2/some_folder/some_file.py
application/app2/another_folder/another_file.py
</code></pre>

<p>This shorthand makes one module visible to the other:</p>

<pre><code>import sys
sys.path.append('../')
</code></pre>
<h4> Carl Smith, Comment 74543117 Score: 44: </h4>As a caveat: This works so long as the importing script is run from its containing directory. Otherwise the parent directory of whatever other directory the script is run from will be appended to the path and the import will fail.<br><h4> Rahul, Comment 91674969 Score: 30: </h4>To avoid that, we can get the parent directory of file <code>sys.path.append(os.path.dirname(os.path.abspath(__file__)))</code><br><h4> addicted, Comment 104909466 Score: 6: </h4>If you run it from your root folder (ie. application folder), you are probably fine with <code>sys.path.append(&#39;.&#39;)</code> then importing the module by using <code>from app2.some_folder.some_file import your_function</code>.  Alternatively what works for me is running <code>python3 -m app2.another_folder.another_file</code> from root folder.<br><h4> towi_parallelism, Comment 104389899 Score: 3: </h4>@Rahul, your solution doesn&#39;t work for interactive shells<br><h4> RCross, Comment 100942317 Score: 2: </h4>That didn&#39;t work for me - I had to add an additional dirname in there to climb back up to the parent, so that running <code>cli&#47;foo.py</code> from the command line was able to <code>import cli.bar</code><br><h4> Amir, Comment 105061705 Score: 1: </h4>I find this to be the simplest way.  just append the relative file path to the file containing the module you need.  in my case:    import sys sys.append(&#39;../data_structure/&#39;) .  the module is in a file inside of the data_structure/ folder<br><h4> JohnAllen, Comment 128484793 Score: 0: </h4>So every directory I want to import from needs three total lines of code to import a single file from each directory? Or is <code>path.append</code> by default recursive?<br><h4> mirekphd, Comment 129536070 Score: 0: </h4>Rather than appending to system path, inserting custom package folder at 1st position in the path would be more robust (to name collisions, that are rather likely, e.g. when debugging a temporary copy of an official package copied from a write-protected location).<br>------------------------------------------------------------------ <br><h3> Alex Montoya, Id: 50474562, Score: 122: </h3><p><strong>First</strong> import sys in name-file.py</p>

<pre><code> import sys
</code></pre>

<p><strong>Second</strong> append the folder path in name-file.py</p>

<pre><code>sys.path.insert(0, '/the/folder/path/name-package/')
</code></pre>

<p><strong>Third</strong> Make a blank file called __ init __.py in your subdirectory (this tells Python it is a package)</p>

<ul>
<li>name-file.py</li>
<li>name-package

<ul>
<li>__ init __.py</li>
<li>name-module.py</li>
</ul></li>
</ul>

<p><strong>Fourth</strong> import the module inside the folder in name-file.py</p>

<pre><code>from name-package import name-module
</code></pre>
<h4> Bastian, Comment 95759808 Score: 11: </h4>With name-folder being right below name-file.py, this should work even without the <code>sys.path.insert</code>-command. As such, the answer leaves the question, if this solution works even when name-folder is located in an arbitrary location.<br><h4> mirekphd, Comment 129536087 Score: 0: </h4>Caution: insert at position 1, since position 0 is the script path (or &#39;&#39; in REPL).<br><h4> Deepak Tatyaji Ahire, Comment 135187247 Score: 0: </h4>Thanks for this answer @Alex Montoya! Upvoted!<br><h4> Giacomo, Comment 117762690 Score: 0: </h4>are you saying that I have to hardcode the path to the script? This means that the solution is not portable. Also the question is how to access from one subfolder to the other. Why not following the name convention and file structure of the original question?<br><h4> Jeyekomon, Comment 123699572 Score: 0: </h4>@Giacomo You don&#39;t have to hardcode anything. Just pass it as a parameter to the script.<br>------------------------------------------------------------------ <br><h3> Zectbumo, Id: 47853501, Score: 77: </h3><p>Try Python's relative imports:</p>

<pre><code>from ...app.folder.file import func_name
</code></pre>

<p>Every leading dot is another higher level in the hierarchy beginning with the current directory.</p>

<hr>

<p>Problems? If this isn't working for you then you probably are getting bit by the many gotcha's relative imports has.
Read answers and comments for more details: 
<a href="https://stackoverflow.com/questions/11536764/how-to-fix-attempted-relative-import-in-non-package-even-with-init-py">How to fix &quot;Attempted relative import in non-package&quot; even with __init__.py</a></p>

<p>Hint: have <code>__init__.py</code> at every directory level. You might need <code>python -m application.app2.some_folder.some_file</code> (leaving off .py) which you run from the top level directory or have that top level directory in your PYTHONPATH. <em>Phew!</em></p>
<h4> Karl Knechtel, Comment 129822049 Score: 2: </h4>@secluded sure, but <code>import 70_foo</code> isn&#39;t allowed either. Both package and module names have to be legal identifier names.<br><h4> secluded, Comment 113879770 Score: 2: </h4>This doesn&#39;t seem to work if your directory&#39;s name starts with a number (e.g. <code>import ..70_foo.test</code> is not allowed)<br><h4> Camilo Martinez M., Comment 120588970 Score: 2: </h4>Wow, this actually worked. I didn&#39;t know you could &quot;go up&quot; a directory by using multiple dots.<br>------------------------------------------------------------------ <br><h3> Ax3l, Id: 21878513, Score: 76: </h3><p>I think an ad hoc way would be to use <a href="https://docs.python.org/3/using/cmdline.html#envvar-PYTHONPATH" rel="nofollow noreferrer">the environment variable <code>PYTHONPATH</code></a> as described in the documentation: <a href="http://docs.python.org/2/tutorial/modules.html#the-module-search-path" rel="nofollow noreferrer" title="Python 2">Python2</a>, <a href="https://docs.python.org/3/tutorial/modules.html#the-module-search-path" rel="nofollow noreferrer" title="Python 3">Python3</a></p>
<pre><code># Linux and OS X
export PYTHONPATH=$HOME/dirWithScripts/:$PYTHONPATH

# Windows
set PYTHONPATH=C:\path\to\dirWithScripts\;%PYTHONPATH%
</code></pre>
<h4> Ax3l, Comment 38089724 Score: 7: </h4>no, with the path of the directory to your .py file<br><h4> information_interchange, Comment 108232159 Score: 4: </h4>Unfortunately, if you are using Anaconda, this won&#39;t work, since under the hood PYTHONPATH is not really used internally !<br><h4> Ax3l, Comment 108273976 Score: 1: </h4>For (recent) changes in anaconda, see this SO for workflows and comments for work-arounds: <a href="https://stackoverflow.com/questions/17386880/does-anaconda-create-a-separate-pythonpath-variable-for-each-new-environment" title="does anaconda create a separate pythonpath variable for each new environment">stackoverflow.com/questions/17386880/&hellip;</a> Generally speaking, build and install small packages instead of hacking the import dirs.<br><h4> Vladimir Putin, Comment 37892938 Score: 0: </h4>Wait, would I replace myScripts with the filename?<br>------------------------------------------------------------------ <br><h3> CianB, Id: 42170807, Score: 64: </h3><p>The issue is that Python is looking in the wrong directory for the file. To solve this, try using <em>relative import</em>. Change</p>
<pre><code>from application.app.folder.file import func_name
</code></pre>
<p>to:</p>
<pre><code>from .application.app.folder.file import func_name
</code></pre>
<p>Adding the dot instructs Python to look for the <code>application</code> folder within the current folder, instead of in the Python install folder.</p>
<h4> ashrasmun, Comment 121828969 Score: 24: </h4>ImportError: attempted relative import with no known parent package :(<br><h4> Prats, Comment 125057246 Score: 1: </h4>I&#39;m getting the same error, any solution to this?<br><h4> Karl Knechtel, Comment 129822062 Score: 1: </h4>@Prats please see <a href="https://stackoverflow.com/questions/11536764/how-to-fix-attempted-relative-import-in-non-package-even-with-init-py" title="how to fix attempted relative import in non package even with init py">stackoverflow.com/questions/11536764/&hellip;</a>.<br><h4> Pit Digger, Comment 131357697 Score: 0: </h4>Why this has so many votes ? Totally wrong answer.<br><h4> SMMH, Comment 135306680 Score: 0: </h4>@ashrasmun @Prats try making empty <code>__init__.py</code> files in your folder and its parent folder.<br>------------------------------------------------------------------ <br><h3> wecsam, Id: 51585877, Score: 49: </h3><p>In Python 3.4 and later, you can <a href="https://docs.python.org/3/library/importlib.html#importing-a-source-file-directly" rel="noreferrer">import from a source file directly (link to documentation)</a>. This is not the simplest solution, but I'm including this answer for completeness.</p>

<p>Here is an example. First, the file to be imported, named <code>foo.py</code>:</p>

<pre><code>def announce():
    print("Imported!")
</code></pre>

<p>The code that imports the file above, inspired heavily by the example in the documentation:</p>

<pre><code>import importlib.util

def module_from_file(module_name, file_path):
    spec = importlib.util.spec_from_file_location(module_name, file_path)
    module = importlib.util.module_from_spec(spec)
    spec.loader.exec_module(module)
    return module

foo = module_from_file("foo", "/path/to/foo.py")

if __name__ == "__main__":
    print(foo)
    print(dir(foo))
    foo.announce()
</code></pre>

<p>The output:</p>

<pre><code>&lt;module 'foo' from '/path/to/foo.py'&gt;
['__builtins__', '__cached__', '__doc__', '__file__', '__loader__', '__name__', '__package__', '__spec__', 'announce']
Imported!
</code></pre>

<p>Note that the variable name, the module name, and the filename need not match. This code still works:</p>

<pre><code>import importlib.util

def module_from_file(module_name, file_path):
    spec = importlib.util.spec_from_file_location(module_name, file_path)
    module = importlib.util.module_from_spec(spec)
    spec.loader.exec_module(module)
    return module

baz = module_from_file("bar", "/path/to/foo.py")

if __name__ == "__main__":
    print(baz)
    print(dir(baz))
    baz.announce()
</code></pre>

<p>The output:</p>

<pre><code>&lt;module 'bar' from '/path/to/foo.py'&gt;
['__builtins__', '__cached__', '__doc__', '__file__', '__loader__', '__name__', '__package__', '__spec__', 'announce']
Imported!
</code></pre>

<p>Programmatically importing modules was introduced in Python 3.1 and gives you more control over how modules are imported. Refer to the documentation for more information.</p>
<h4> Dan, Comment 94998821 Score: 33: </h4>I don&#39;t know if anyone even tried to understand this, but I think that it&#39;s too complicated.<br><h4> Sincere, Comment 121758593 Score: 4: </h4>This is the only solution that worked for me. I have the same file name in different directories.<br><h4> Paulo, Comment 129035361 Score: 1: </h4>That was the only solution that worked for me.<br><h4> DrCord, Comment 129610888 Score: 0: </h4>This should be the correct solution for import a local module that you don&#39;t want to publish to the package repository.<br><h4> john k, Comment 125010103 Score: 0: </h4>how to import everything in a file?<br>------------------------------------------------------------------ <br><h3> Nagev, Id: 46569406, Score: 42: </h3><p>Using <code>sys.path.append</code> with an absolute path is not ideal when moving the application to other environments. Using a relative path won't always work because the current working directory depends on how the script was invoked.</p>
<p>Since the application folder structure is fixed, we can use <code>os.path</code> to get the full path of the module we wish to import. For example, if this is the structure:</p>
<pre><code>/home/me/application/app2/some_folder/vanilla.py
/home/me/application/app2/another_folder/mango.py
</code></pre>
<p>And let's say that you want to import the <em>mango</em> module. You could do the following in <em>vanilla.py</em>:</p>
<pre><code>import sys, os.path
mango_dir = (os.path.abspath(os.path.join(os.path.dirname(__file__), '..'))
+ '/another_folder/')
sys.path.append(mango_dir)
import mango
</code></pre>
<p>Of course, you don't need the <em>mango_dir</em> variable.</p>
<p>To understand how this works look at this interactive session example:</p>
<pre><code>&gt;&gt;&gt; import os
&gt;&gt;&gt; mydir = '/home/me/application/app2/some_folder'
&gt;&gt;&gt; newdir = os.path.abspath(os.path.join(mydir, '..'))
&gt;&gt;&gt; newdir
    '/home/me/application/app2'
&gt;&gt;&gt; newdir = os.path.abspath(os.path.join(mydir, '..')) + '/another_folder'
&gt;&gt;&gt; 
&gt;&gt;&gt; newdir
'/home/me/application/app2/another_folder'
&gt;&gt;&gt; 
</code></pre>
<p>And check the <a href="https://docs.python.org/3/library/os.path.html" rel="noreferrer">os.path</a> documentation.</p>
<p>Also worth noting that dealing with multiple folders is made easier when using <a href="https://docs.python.org/3/tutorial/modules.html#packages" rel="noreferrer">packages</a>, as one can use dotted module names.</p>
------------------------------------------------------------------ <br><h3> Vaibhav Singh, Id: 27097894, Score: 40: </h3><p>From what I know,  add an <code>__init__.py</code> file directly in the folder of the functions you want  to  import  will do  the job.</p>
<h4> Ax3l, Comment 58741654 Score: 9: </h4>only if the script that wants to include that other directory is already in the sys.path<br><h4> herve-guerin, Comment 72853314 Score: 2: </h4>I used <code>sys.path.append(tools_dir)</code> on Windows and I don&#39;t need to add a <code>__init__.py&#39; file in my directory </code>tools_dir`<br><h4> Karl Knechtel, Comment 130275798 Score: 0: </h4><code>__init__.py</code> has <b>effectively nothing to do with it</b>.<br><h4> chanduthedev, Comment 135343555 Score: 0: </h4>Setting as ENV variable worked for me  <code>export PYTHONPATH=&quot;${PYTHONPATH}:&#47;path&#47;to&#47;python&#47;project&quot;</code><br>------------------------------------------------------------------ <br><h3> Erick Mwazonga, Id: 52586031, Score: 33: </h3><p>I was faced with the same challenge, especially when importing multiple files, this is how I managed to overcome it.</p>

<pre><code>import os, sys

from os.path import dirname, join, abspath
sys.path.insert(0, abspath(join(dirname(__file__), '..')))

from root_folder import file_name
</code></pre>
<h4> not2qubit, Comment 98302651 Score: 5: </h4>You answer would be more helpful if you could explain what it does differently from an ordinary import?<br><h4> jwal, Comment 98555570 Score: 1: </h4>I had /path/dir1/__init__.py and /path/dir1/mod.py. For /path/some.py from dir1.mod import func worked. When in /path/dir2/some.py it only worked after I copied and pasted the above answer at the top of the file. Didn&#39;t want to edit my path since not every python project I have is in /path/.<br><h4> Vishrant, Comment 123087507 Score: 0: </h4>My test files were moved to another directory when running it using <code>bazel</code> after adding this import, the test files were able to reference the dependencies.<br>------------------------------------------------------------------ <br><h3> dsg38, Id: 38978765, Score: 32: </h3><p>This worked for me in Python 3 on Linux:</p>
<pre><code>import sys
sys.path.append(pathToFolderContainingScripts)
from scriptName import functionName #scriptName without .py extension
</code></pre>
<h4> daGo, Comment 75165003 Score: 9: </h4><code>sys.path.append(&quot;&#47;home&#47;linux&#47;folder&#47;&quot;)</code> —  Make sure do not use a shortcut e.g. <code>&quot;~&#47;folder&#47;&quot;</code><br><h4> John Stud, Comment 110384017 Score: 3: </h4>This is the easiest answer; works for Windows as well.<br>------------------------------------------------------------------ <br><h3> ChandanK, Id: 33143646, Score: 29: </h3><p>Considering <code>application</code> as the root directory for your Python project, create an empty <code>__init__.py</code> file in the <code>application</code>, <code>app</code> and <code>folder</code> folders. Then in your <code>some_file.py</code>, make changes as follows to get the definition of <em>func_name</em>:</p>
<pre><code>import sys
sys.path.insert(0, r'/from/root/directory/application')

from application.app.folder.file import func_name ## You can also use '*' wildcard to import all the functions in file.py file.
func_name()
</code></pre>
<h4> Bolaka, Comment 58471088 Score: 0: </h4>should be: sys.path.insert(0, r&#39;/from/root/directory&#39;)<br>------------------------------------------------------------------ <br><h3> Mohsen Haddadi, Id: 62852757, Score: 22: </h3><p>One way is to create a package and use <em>absolute import</em> to access other modules from the package. Start the program from a script at the root of the package. This structure allows using and accessing sub-packages, parent package, and sibling packages and modules.</p>
<p>As an example, try creating the following folder structure:</p>
<pre><code>package/
├── __init__.py
├── main_module.py
├── module_0.py
├── subpackage_1/
|   ├── __init__.py
|   ├── module_1.py
|   └── sub_subpackage_3/
|       ├── __init__.py
|       └── module_3.py
└── subpackage_2/
    ├── __init__.py
    └── module_2.py
</code></pre>
<p>Contents of <code>main_module.py</code>:</p>
<pre><code>import subpackage_1.module_1
</code></pre>
<p>Contents of <code>module_0.py</code>:</p>
<pre><code>print('module_0 at parent directory, is imported')
</code></pre>
<p>Contents of <code>module_1.py</code>:</p>
<pre><code>print('importing other modules from module_1...')
import module_0
import subpackage_2.module_2
import subpackage_1.sub_subpackage_3.module_3
</code></pre>
<p>Contents of <code>module_2.py</code>:</p>
<pre><code>print('module_2 at same level directory, is imported')
</code></pre>
<p>Contents of <code>module_3.py</code>:</p>
<pre><code>print('module_3 at sub directory, is imported')
</code></pre>
<p>Leave all <code>__init__.py</code> files empty.</p>
<p>Now run <code>main_module.py</code>; the output will be</p>
<pre><code>importing other modules from module_1...
module_0 at parent directory, is imported
module_2 at same level directory, is imported
module_3 at sub directory, is imported
</code></pre>
------------------------------------------------------------------ <br><h3> Milovan Tomašević, Id: 67962159, Score: 22: </h3><pre class="lang-py prettyprint-override"><code>├───root
│   ├───dir_a
│   │   ├───file_a.py
│   │   └───file_xx.py
│   ├───dir_b
│   │   ├───file_b.py
│   │   └───file_yy.py
│   ├───dir_c
│   └───dir_n
</code></pre>
<p>You can add the parent directory to <code>PYTHONPATH</code>, in order to achieve that, you can use OS depending path in the &quot;module search path&quot; which is listed in <code>sys.path</code>. So you can easily add the parent directory like following:</p>
<pre class="lang-py prettyprint-override"><code># file_b.py

import sys
sys.path.insert(0, '..')

from dir_a.file_a import func_name
</code></pre>
<h4> mike, Comment 130615928 Score: 1: </h4>The magic here is to use &#39;.&#39; instead of &#39;/&#39; to indicate the path relative to current path.<br>------------------------------------------------------------------ <br><h3> Emeeus, Id: 36251540, Score: 15: </h3><p>This works for me on Windows:</p>
<pre><code># some_file.py on mainApp/app2
import sys
sys.path.insert(0, sys.path[0]+'\\app2')

import some_file
</code></pre>
------------------------------------------------------------------ <br><h3> WY Hsu, Id: 59598549, Score: 12: </h3><p>I bumped into the same question several times, so I would like to share my solution.</p>

<h2>Python Version: 3.X</h2>

<p>The following solution is for someone who develops your application in Python version 3.X because <a href="https://www.python.org/doc/sunset-python-2/" rel="noreferrer">Python 2 is not supported since Jan/1/2020</a>.</p>

<h2>Project Structure</h2>

<p>In python 3, you don't need <code>__init__.py</code> in your project subdirectory due to the <a href="https://www.python.org/dev/peps/pep-0420/" rel="noreferrer">Implicit Namespace Packages</a>. See <a href="https://stackoverflow.com/questions/37139786/is-init-py-not-required-for-packages-in-python-3-3">Is <strong>init</strong>.py not required for packages in Python 3.3+</a>  </p>

<pre><code>Project 
├── main.py
├── .gitignore
|
├── a
|   └── file_a.py
|
└── b
    └── file_b.py
</code></pre>

<h2>Problem Statement</h2>

<p>In <code>file_b.py</code>, I would like to import a class <code>A</code> in <code>file_a.py</code> under the folder a.</p>

<h2>Solutions</h2>

<h3>#1 A quick but dirty way</h3>

<p>Without installing the package like you are currently developing a new project</p>

<p>Using the <code>try catch</code> to check if the errors. Code example: </p>

<pre><code>import sys
try:
    # The insertion index should be 1 because index 0 is this file
    sys.path.insert(1, '/absolute/path/to/folder/a')  # the type of path is string
    # because the system path already have the absolute path to folder a
    # so it can recognize file_a.py while searching 
    from file_a import A
except (ModuleNotFoundError, ImportError) as e:
    print("{} fileure".format(type(e)))
else:
    print("Import succeeded")
</code></pre>

<h3>#2 Install your package</h3>

<p>Once you installed your application (in this post, the tutorial of installation is not included)</p>

<p>You can simply</p>

<pre><code>try:
    from __future__ import absolute_import
    # now it can reach class A of file_a.py in folder a 
    # by relative import
    from ..a.file_a import A  
except (ModuleNotFoundError, ImportError) as e:
    print("{} fileure".format(type(e)))
else:
    print("Import succeeded")
</code></pre>

<p>Happy coding!</p>
<h4> Giacomo, Comment 117762881 Score: 1: </h4>your first proposed solution worked for me using sys.path.insert(1, &#39;../a/&#39;) which I think is better than writing the full path.<br><h4> WY Hsu, Comment 105361416 Score: 0: </h4>for more info about <a href="https://stackoverflow.com/questions/42853617/python-fails-importing-package">absolute imports</a><br><h4> Medoalmasry, Comment 117796100 Score: 0: </h4>In case someone has a local package that you would like to import instead of the system package (THAT HAS THE SAME NAME) please use sys.path.insert(1,&#39;folder-to-grab-package-from&#39;) instead of sys.append(&#39;folder-to-grab-package-from&#39;)<br><h4> JohnAllen, Comment 128484933 Score: 0: </h4>You say &quot;You can simply&quot; but unfortunately seven lines of code to import a single file is not simple at all!<br>------------------------------------------------------------------ <br><h3> herve-guerin, Id: 42874499, Score: 11: </h3><p>I'm quite special: I use Python with Windows!</p>
<p>I just complete information: for both Windows and Linux, both relative and absolute paths work into <code>sys.path</code> (I need relative paths because I use my scripts on the several PCs and under different main directories).</p>
<p>And when using Windows, both <code>\</code> and <code>/</code> can be used as a separator for file names and of course you must double <code>\</code> into Python strings. Here are some valid examples:</p>
<pre><code>sys.path.append('c:\\tools\\mydir')
sys.path.append('..\\mytools')
sys.path.append('c:/tools/mydir')
sys.path.append('../mytools')
</code></pre>
<p>(Note: I think that <code>/</code> is more convenient than <code>\</code>, even if it is less 'Windows-native', because it is Linux-compatible and simpler to write and copy to <a href="https://en.wikipedia.org/wiki/File_Explorer" rel="nofollow noreferrer">Windows Explorer</a>)</p>
<h4> Corey Goldberg, Comment 95966924 Score: 4: </h4>os.path.join(&#39;tools&#39;, &#39;mydir&#39;)<br>------------------------------------------------------------------ <br><h3> user12058827, Id: 60202840, Score: 8: </h3><p>Instead of just doing an <code>import ...</code>, do this :</p>

<p><code>from &lt;MySubFolder&gt; import &lt;MyFile&gt;</code></p>

<p>MyFile is inside the MySubFolder.</p>
<h4> ScubaInstructor, Comment 135370166 Score: 0: </h4>Great and simple!<br>------------------------------------------------------------------ <br><h3> yerty, Id: 70919483, Score: 8: </h3><p>The following worked for me:</p>
<p><strong>OS</strong>: Windows 10</p>
<p><strong>Python</strong>: v3.10.0</p>
<p><strong>Note</strong>: Since I am Python v3.10.0, I am not using <code>__init__.py</code> files, which did not work for me anyway.</p>
<pre><code>application
├── app
│   └── folder
│       └── file.py
└── app2
    └── some_folder
        └── some_file.py
</code></pre>
<p><a href="https://stackoverflow.com/a/59598549/848353">WY Hsu's</a> first solution worked for me. I have reposted it with an <strong>absolute file reference</strong> for clarity:</p>
<pre><code>import sys
sys.path.insert(1, 'C:\\Users\\&lt;Your Username&gt;\\application')
import app2.some_folder.some_file

some_file.hello_world()
</code></pre>
<p><strong>Alternative Solution</strong>: However, this also worked for me:</p>
<pre><code>import sys
sys.path.append( '.' )
import app2.some_folder.some_file

some_file.hello_world()
</code></pre>
<p>Although, I do not understand why it works. I thought the dot is a reference to the current directory. However, when printing out the paths to the current folder, the current directory is already listed at the top:</p>
<pre><code>for path in sys.path:
    print(path)
</code></pre>
<h4> Tirbo06, Comment 126455055 Score: 1: </h4>For me I had to get up one more branch by doing <code>sys.path.append(&#39;..&#39;)</code> and it worked ! But still display the path of the CWD<br>------------------------------------------------------------------ <br><h3> Timothy C. Quinn, Id: 34439121, Score: 7: </h3><p>If the purpose of loading a module from a specific path is to assist you during the development of a custom module, you can create a symbolic link in the same folder of the test script that points to the root of the custom module. This module reference will take precedence over any other modules installed of the same name for any script run in that folder.</p>
<p>I tested this on Linux but it should work in any modern OS that supports symbolic links.</p>
<p>One advantage to this approach is that you can you can point to a module that's sitting in your own local software version control branch working copy which can greatly simplify the development cycle time and reduce failure modes of managing different versions of the module.</p>
<h4> Peter Mortensen, Comment 133821698 Score: 0: </h4>What is <i>&quot;SVC&quot;</i>? Do you mean <i>&quot;<a href="https://en.wikipedia.org/wiki/Distributed_version_control" rel="nofollow noreferrer">DVC</a>&quot;</i>? Or <i>&quot;<a href="https://en.wikipedia.org/wiki/Distributed_version_control" rel="nofollow noreferrer">DVCS</a>&quot;</i>? Or even <i>&quot;<a href="https://en.wikipedia.org/wiki/Concurrent_Versions_System" rel="nofollow noreferrer">CVS</a>&quot;</i>, <i>&quot;<a href="https://en.wikipedia.org/wiki/Microsoft_Visual_SourceSafe" rel="nofollow noreferrer">VSS</a>&quot;</i>, or <i>&quot;<a href="https://en.wikipedia.org/wiki/Apache_Subversion" rel="nofollow noreferrer">SVN</a>&quot;</i>? Or something else? <i>Source version control</i>?<br><h4> Timothy C. Quinn, Comment 133825700 Score: 0: </h4>SVC = Software Version Control. Just realized it&#39;s not a commonly used acronym but its is the umbrella over all of all version control systems. I&#39;ll edit my comment to be more clear.<br><h4> Timothy C. Quinn, Comment 133825732 Score: 0: </h4>Great read: <a href="https://docs.lib.purdue.edu/cgi/viewcontent.cgi?article=1393&amp;context=cstech" rel="nofollow noreferrer">docs.lib.purdue.edu/cgi/&hellip;</a><br>------------------------------------------------------------------ <br><h3> duhaime, Id: 56996357, Score: 6: </h3><p>I was working on project <code>a</code> that I wanted users to install via <code>pip install a</code> with the following file list:</p>

<pre><code>.
├── setup.py
├── MANIFEST.in
└── a
    ├── __init__.py
    ├── a.py
    └── b
        ├── __init__.py
        └── b.py
</code></pre>

<p>setup.py</p>

<pre><code>from setuptools import setup

setup (
  name='a',
  version='0.0.1',
  packages=['a'],
  package_data={
    'a': ['b/*'],
  },
)
</code></pre>

<p>MANIFEST.in</p>

<pre><code>recursive-include b *.*
</code></pre>

<p>a/<strong>init</strong>.py</p>

<pre><code>from __future__ import absolute_import

from a.a import cats
import a.b
</code></pre>

<p>a/a.py</p>

<pre><code>cats = 0
</code></pre>

<p>a/b/<strong>init</strong>.py</p>

<pre><code>from __future__ import absolute_import

from a.b.b import dogs
</code></pre>

<p>a/b/b.py</p>

<pre><code>dogs = 1
</code></pre>

<hr>

<p>I installed the module by running the following from the directory with <code>MANIFEST.in</code>:</p>

<pre><code>python setup.py install
</code></pre>

<p>Then, from a totally different location on my filesystem <code>/moustache/armwrestle</code> I was able to run:</p>

<pre><code>import a
dir(a)
</code></pre>

<p>Which confirmed that <code>a.cats</code> indeed equalled 0 and <code>a.b.dogs</code> indeed equalled 1, as intended.</p>
------------------------------------------------------------------ <br><h3> Md Shafiul Islam, Id: 64405877, Score: 6: </h3><p><strong>This worked for me.</strong></p>
<p>Python adds the folder containing the script you launch to the PYTHONPATH, so if you run</p>
<pre class="lang-bash prettyprint-override"><code>python application/app2/some_folder/some_file.py
</code></pre>
<p>Only the folder application/app2/some_folder is added to the path (not the base directory that you're executing the command in). Instead, run your file as a module and add a __init__.py in your some_folder directory.</p>
<pre class="lang-bash prettyprint-override"><code>python -m application.app2.some_folder.some_file
</code></pre>
<p>This will add the base directory to the path to executable <code>python</code>, and then classes will be accessible via a non-relative import.</p>
------------------------------------------------------------------ <br><h3> Sergiusz, Id: 72301427, Score: 6: </h3><p>My solution for people who have all the necessary <code>__init__.py</code> in the package, but import still doesn't work.</p>
<pre><code>import sys
import os
sys.path.insert(0, os.getcwd())

import application.app.folder.file as file
</code></pre>
<h4> Jota, Comment 133704616 Score: 0: </h4>worked for me... but this should not be like this, python sometimes is complicated to understand...<br>------------------------------------------------------------------ <br><h3> Neinstein, Id: 63826803, Score: 5: </h3><p>The code below imports the Python script given by its path, no matter where it is located, in a Python version-safe way:</p>
<pre><code>def import_module_by_path(path):
    name = os.path.splitext(os.path.basename(path))[0]
    if sys.version_info[0] == 2:
        # Python 2
        import imp
        return imp.load_source(name, path)
    elif sys.version_info[:2] &lt;= (3, 4):
        # Python 3, version &lt;= 3.4
        from importlib.machinery import SourceFileLoader
        return SourceFileLoader(name, path).load_module()
    else:
        # Python 3, after 3.4
        import importlib.util
        spec = importlib.util.spec_from_file_location(name, path)
        mod = importlib.util.module_from_spec(spec)
        spec.loader.exec_module(mod)
        return mod
</code></pre>
<p>I found this in the codebase of <a href="https://pypi.org/project/psutil/" rel="nofollow noreferrer">psutils</a>, at line 1042 in <a href="https://github.com/giampaolo/psutil/blob/ee60bad610822a7f630c52922b4918e684ba7695/psutil/tests/__init__.py" rel="nofollow noreferrer"><code>psutils.test.__init__.py</code></a> (<em>most recent commit as of 09.10.2020</em>).</p>
<p>Usage example:</p>
<pre><code>script = &quot;/home/username/Documents/some_script.py&quot;
some_module = import_module_by_path(script)
print(some_module.foo())
</code></pre>
<p><strong>Important caveat: The module will be treated as top-level; any relative imports from parent packages in it will fail.</strong></p>
<h4> Jon, Comment 119780172 Score: 0: </h4>Any idea why the two different Python3 methods? I tried both on Python 3.6, and they both worked, and returned identical results<br><h4> Jon, Comment 119780456 Score: 0: </h4>Also identical results on python 3.8.9. Starting with 3.8.10 and later, the <code>spec_from_file_location</code> starts saving the root path of the file (if a relative path given) in the <b>loader</b> object, but otherwise the data returned is identical. Also tested with python 3.10 -- exact same behavior as 3.8.10. Both methods work just fine.<br><h4> Neinstein, Comment 119785180 Score: 0: </h4>@Jon Unfortunately I can&#39;t comment on these, I&#39;m not familiar with the nuances of importlib. This is found property, and I didn&#39;t want to change anything - figured they had a reason for it. Maybe there&#39;s some nuance that is different, or that breaks for older/newer versions.<br>------------------------------------------------------------------ <br><h3> Adilet Usonov, Id: 72230506, Score: 5: </h3><h2>This problem may be due to <a href="https://en.wikipedia.org/wiki/JetBrains#IDEs" rel="nofollow noreferrer">PyCharm</a></h2>
<p>I had the same problem while using PyCharm. I had this project structure</p>
<pre><code>skylake\
   backend\
      apps\
          example.py
      configuration\
          settings.py
   frontend\
      ...some_stuff
</code></pre>
<p>and code <code>from configuration import settings</code> in <em>example.py</em> raised an import error.</p>
<p>The problem was that when I opened PyCharm, it considered that <em>skylake</em> is the root path and ran this code.</p>
<pre><code>sys.path.extend(['D:\\projects\\skylake', 'D:/projects/skylake'])
</code></pre>
<p>To fix this I just marked backend directory as the source root.</p>
<p><a href="https://i.stack.imgur.com/6yaVi.png" rel="nofollow noreferrer"><img src="https://i.stack.imgur.com/6yaVi.png" alt="Enter image description here" /></a></p>
<p>And it's fixed my problem.</p>
<h4> Peter Mortensen, Comment 133819753 Score: 0: </h4>&#39;skylake&#39; is not to be confused with <a href="https://en.wikipedia.org/wiki/Skylake_(microarchitecture)" rel="nofollow noreferrer">Skylake</a>.<br><h4> Adilet Usonov, Comment 134005745 Score: 0: </h4>@PeterMortensen bro, you fixed every answer I see  ಠ﹏ಠ<br>------------------------------------------------------------------ <br><h3> Dextron, Id: 57133053, Score: 4: </h3><p>You can use importlib to import modules where you want to import a module from a folder using a string like so:</p>

<pre><code>import importlib

scriptName = 'Snake'

script = importlib.import_module('Scripts\\.%s' % scriptName)
</code></pre>

<p>This example has a main.py which is the above code then a folder called Scripts and then you can call whatever you need from this folder by changing the <code>scriptName</code> variable. You can then use <code>script</code> to reference to this module. such as if I have a function called <code>Hello()</code> in the Snake module you can run this function by doing so:</p>

<pre><code>script.Hello()
</code></pre>

<p>I have tested this in Python 3.6</p>
------------------------------------------------------------------ <br><h3> picmate 涅, Id: 62685074, Score: 4: </h3><p>I usually create a symlink to the module I want to import. The symlink makes sure Python interpreter can locate the module inside the current directory (the script you are importing the other module into); later on when your work is over, you can remove the symlink. Also, you should ignore symlinks in .gitignore, so that, you wouldn't accidentally commit symlinked modules to your repo. This approach lets you even successfully work with modules that are located parallel to the script you are executing.</p>
<pre><code>ln -s ~/path/to/original/module/my_module ~/symlink/inside/the/destination/directory/my_module
</code></pre>
------------------------------------------------------------------ <br><h3> KSHMR, Id: 74829320, Score: 4: </h3><p>You can use <code>pip</code>'s <code>pip install -e .</code> command. You must create a file called <code>setup.py</code> in the root of the project's directory which contains the following:</p>
<pre><code>from setuptools import find_packages, setup

setup(
    name='src',
    packages=find_packages(),
    version='0.1.0',
    description='my_project',
    author='author',
    license='MIT',
)
</code></pre>
<p>Afterwards, enter <code>pip install -e .</code> while in your project's root directory. This will enable all directories to be called with their name as a module. For example, if your root directory contains the subdirectories <code>module1</code> and <code>module2</code>, each with scripts inside them, you will be able to access them from any subdirectories with the following command, for <code>module1</code>:</p>
<p><code>import module1.script1 as script1</code></p>
------------------------------------------------------------------ <br><h3> helloworld, Id: 76274034, Score: 4: </h3><p>There are many awesome answers, but I think it is import to note the <code>PATHONPATH</code>.
(Below is excerpted from various online resource. Credit to Internet!)</p>
<p>If you have a function in a Python file in another directory, you can still import it by modifying the Python import path or using a relative import.</p>
<p>Here's how you can do it:</p>
<p>Let's assume you have the following directory structure:</p>
<pre><code>my_project/
│
├── main.py
│
└── my_module/
    ├── __init__.py
    └── my_functions.py
</code></pre>
<p>Your <code>my_functions.py</code> defined a function named <code>my_function</code> and you want to use it in <code>main.py</code>.</p>
<p>Here is how you can do it:</p>
<pre><code>from my_module.my_functions import my_function

my_function()  # Outputs: Hello, World!
</code></pre>
<p>This assumes that <code>my_project</code> is in your Python path. If you're running <code>main.py</code> from the <code>my_project</code> directory, then Python will add <code>my_project</code> to the Python path automatically and it should be able to find <code>my_module</code>.</p>
<p>If <code>my_project</code> is not in your Python path, you must add it manually at the start of <code>main.py</code>:</p>
<pre><code>import sys
sys.path.insert(0, '/path/to/my_project')

from my_module.my_functions import my_function

my_function()  # Outputs: Hello, World!
</code></pre>
<p>Replace <code>'/path/to/my_project'</code> with the actual path to <code>my_project</code>.</p>
<p>The <code>__init__.py</code> file in <code>my_module</code> is necessary for Python to recognize <code>my_module</code> as a package that can be imported. If <code>my_module</code> doesn't contain <code>__init__.py</code>, simply create an empty file with that name.</p>
<p>Above answers this question post:</p>
<blockquote>
<p>Importing files from different folder</p>
</blockquote>
<p>For additional reference, if one needs to import functions defined in different files in the same module, here is the example on how to import functions from one file to another file ( under the same module).</p>
<p>Suppose you have the following directory structure:</p>
<pre><code>src/
    __init__.py
    file1.py
    file2.py
</code></pre>
<p>Let's say <code>file1.py</code> contains a function <code>function1()</code>, and you want to use this function in <code>file2.py</code>.</p>
<p>In <code>file2.py</code>, you can import the function from <code>file1.py</code> using the following line:</p>
<pre><code>from .file1 import function1
</code></pre>
<p>You can then call <code>function1()</code> in <code>file2.py</code> as if it was defined in the same file.</p>
<p>The <code>.</code> before <code>file1</code> in the <code>import</code> statement is a <strong>relative import</strong>, which means &quot;import from the same package&quot;. In this case, it's saying &quot;import from the same directory&quot;.</p>
<p>Note: This will only work if <strong>your script is run as a module</strong> (i.e., using the <code>-m</code> flag with Python, like <code>python -m src.file2</code>), not if you run the Python file directly (<code>python file2.py</code>). If you're running the file directly and the other file is in the same directory, you can just do <code>from file1 import function1</code>.</p>
<p>If you are running the file directly and the import is not working, make sure your <code>src</code> folder (the root folder of this module) is in the Python path. The Python path is a list of directories that Python checks when it's looking for the module you're trying to import. You can add the <code>src</code> folder to the Python path by adding it to the <code>PYTHONPATH</code> environment variable, or by adding an empty file named <code>__init__.py</code> in your <code>src</code> directory to make it a package.</p>
------------------------------------------------------------------ <br><h3> IOstream, Id: 45068315, Score: 2: </h3><p>You can refresh the Python shell by pressing <kbd>F5</kbd>, or go to <em>Run</em> → <em>Run Module</em>. This way you don't have to change the directory to read something from the file. Python will automatically change the directory. But if you want to work with different files from different directory in the Python shell, then you can change the directory in <em>sys</em>, <a href="https://stackoverflow.com/a/4383597/3982001">as Cameron said</a> earlier.</p>
------------------------------------------------------------------ <br><h3> mithunpaul, Id: 51549572, Score: 2: </h3><p>So I had just right clicked on my IDE, and added a new <code>folder</code> and was wondering why I wasn't able to import from it. Later I realized I have to right click and create a Python Package, and not a classic file system folder. Or a post-mortem method being adding an <code>__init__.py</code> (which makes python treat the file system folder as a package) as mentioned in other answers. Adding this answer here just in case someone went this route.</p>
------------------------------------------------------------------ <br><h3> B Furtado, Id: 61808596, Score: 2: </h3><p>I've had these problems a number of times. I've come to this same page a lot. 
In my last problem I had to run the <code>server</code> from a fixed directory, but whenever debugging I wanted to run from different sub-directories. </p>

<pre><code>import sys
sys.insert(1, /path) 
</code></pre>

<p>did <strong>NOT</strong> work for me because at different modules I had to read different <strong>*.csv</strong> files which were all in the same directory.</p>

<p>In the end, what worked for me was not pythonic, I guess, but:</p>

<p>I used a <code>if __main__</code> <strong>on top of the module I wanted to debug</strong>, that is run from a different than usual path.</p>

<p>So:</p>

<pre><code># On top of the module, instead of on the bottom
import os
if __name__ == '__main__':
    os.chdir('/path/for/the/regularly/run/directory')
</code></pre>
------------------------------------------------------------------ <br><h3> kepy97, Id: 63040187, Score: 2: </h3><p>If you have multiple folders and sub folders, you can always import any class or module from the <strong>main directory</strong>.</p>
<p>For example: Tree structure of the project</p>
<pre><code>Project 
├── main.py
├── .gitignore
|
├── src
     ├────model
     |    └── user_model.py
     |────controller
          └── user_controller.py
</code></pre>
<p>Now, if you want to import <strong>&quot;UserModel&quot;</strong> class from user_model.py in <strong>main.py</strong> file, you can do that using:</p>
<pre><code>from src.model.user_model.py import UserModel
</code></pre>
<p>Also, you can import same class in <strong>user_controller.py</strong> file using same line:</p>
<pre><code>from src.model.user_model.py import UserModel
</code></pre>
<p>Overall, you can give reference of main project directory to import classes and files in any python file inside <strong>Project</strong> directory.</p>
<h4> Giacomo, Comment 117762663 Score: 3: </h4>This is not an answer to the original question which was NOT about how to import from main.py, but rather (following your example) from user_model.py to user_controller.py.<br><h4> Richie F., Comment 115529442 Score: 0: </h4>do we need <code>__init__.py</code> under src to make this happen?<br>------------------------------------------------------------------ <br><h3> Daniel N., Id: 71803717, Score: 2: </h3><p>In case you only want to run the script instead of actually importing it, the <a href="https://docs.python.org/3.8/library/functions.html#exec" rel="nofollow noreferrer">exec</a> command will do the work</p>
<pre><code>exec(open('/full/or/relative/path').read())
</code></pre>
<h4> Peter Mortensen, Comment 133819704 Score: 0: </h4><a href="https://stackoverflow.com/questions/9383740/what-does-pythons-eval-do/9384005#9384005">eval&#39;s</a> evil twin?<br><h4> Le Quang Nam, Comment 130353953 Score: 0: </h4>This is the most effective and simple solution.<br>------------------------------------------------------------------ <br><h3> winsett, Id: 75185135, Score: 2: </h3><p>Just in case anyone still needs a solution and hasn't found one in the answers above. This worked for me:</p>
<p>I have this folder structure:</p>
<pre><code>a
└── b
    ├── c1
    |   └── d
    |       └── a_script.py
    └── c2
        └── a_lib.py
</code></pre>
<p>And I needed the <code>a_lib.py</code> to be included in the <code>a_script.py</code>. This is how I resolved the error that <code>c2</code> is not recognized:</p>
<pre><code>import sys
from pathlib import Path
path_scripts = Path(__file__).resolve().parents[2]
sys.path.append(str(path_scripts))
from c2 import a_lib
</code></pre>
------------------------------------------------------------------ <br><h3> Nermin, Id: 75673670, Score: 2: </h3><h3>2023 Python 3.10+ solution</h3>
<p>Out of all the answers here, only <a href="https://stackoverflow.com/questions/4383571/importing-files-from-different-folder?page=1&amp;tab=createdasc#comment121347547_21995949">martin36's solution</a> hidden in the comments worked for me to enable relative imports.</p>
<pre><code>import sys
sys.path.append('')
</code></pre>
<p>(But using <em>append</em> instead of <em>insert</em>)</p>
<pre><code>from application.app.folder.file import func_name
</code></pre>
<h4> Karl Knechtel, Comment 133760217 Score: 1: </h4>I can guarantee you that nothing fundamentally has changed in Python in a very long time that would be relevant to this answer. I can also guarantee you that using 3.10 is not relevant to your problem, in particular. I can almost guarantee you that many other answers would have solved your problem. I can almost guarantee you that changing <code>sys.path</code> is not necessary for your situation - many of the largest and most important Python libraries, running hundreds of thousands of lines of code, do not use it. Also, what you show here is <b>not a relative import</b>.<br><h4> Peter Mortensen, Comment 133820463 Score: 0: </h4>Can you explain your answer, please? E.g, why and how does appending an empty string work? Please respond by <a href="https://XXXX" rel="nofollow noreferrer">editing (changing) your answer</a>, not here in comments (**** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** <b><i>without</i></b> **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** &quot;Edit:&quot;, &quot;Update:&quot;, or similar - the answer should appear as if it was written today).<br><h4> Peter Mortensen, Comment 133820571 Score: 0: </h4>Does it <i>only</i> work in Python 3.10 (and later)? Or was it only tested with Python 3.10? <code>sys.path.append(&#39;&#39;)</code> itself executes without error in Python 3.6.9.<br><h4> Peter Mortensen, Comment 133820709 Score: 0: </h4>OK, <i><a href="https://stackoverflow.com/questions/49559003/why-is-the-first-element-in-pythons-sys-path-an-empty-string">Why is the first element in Python&#39;s sys.path an empty string?</a></i><br><h4> Peter Mortensen, Comment 133820730 Score: 0: </h4>If the first element is an empty string, what difference does it make to append an empty string at the end? For instance, is there a Python version dependence? Did they remove the empty string at the beginning in later versions of Python?<br><h4> Peter Mortensen, Comment 133820813 Score: 0: </h4>After the append operation on Python 3.6.9, example content of sys.path is: <code>[&#39;&#39;, &#39;&#47;usr&#47;lib&#47;python36.zip&#39;, &#39;&#47;usr&#47;lib&#47;python3.6&#39;, &#39;&#47;usr&#47;lib&#47;python3.6&#47;lib-dynload&#39;, &#39;&#47;home&#47;mortensen&#47;.local&#47;lib&#47;python3.6&#47;site-packages&#39;, &#39;&#47;usr&#47;local&#47;lib&#47;python3.6&#47;dist-packages&#39;, &#39;&#47;usr&#47;lib&#47;python3&#47;dist-packages&#39;, &#39;&#39;]</code><br><h4> Peter Mortensen, Comment 133821074 Score: 0: </h4>OK, only in the REPL (or if read from <a href="https://en.wikipedia.org/wiki/Standard_streams#Standard_input_(stdin)" rel="nofollow noreferrer">standard input</a>).<br><h4> Peter Mortensen, Comment 133821212 Score: 0: </h4><i><a href="https://docs.python.org/3/library/sys_path_init.html" rel="nofollow noreferrer">The initialization of the sys.path module search path</a></i><br><h4> Peter Mortensen, Comment 133822165 Score: 0: </h4><i>insert</i> is also used in <a href="https://stackoverflow.com/questions/72852/how-can-i-do-relative-imports-in-python">this answer</a> (though not with the same parameter).<br>------------------------------------------------------------------ <br><h3> Markus Hirsim&#228;ki, Id: 77407752, Score: 1: </h3><p>There is plenty of other solution already but here is my two cents. Let's say you don't want to do any of these:</p>
<ul>
<li>add <code>__init__.py</code> files</li>
<li>run with python -m mymodule</li>
<li>edit  <code>__package__</code></li>
<li>add <code>if</code> check in <code>__main__</code></li>
<li>edit <code>sys.path</code> by hand</li>
<li>edit <code>PYTHONPATH</code></li>
<li>restructure the project</li>
</ul>
<p>You can instead use a tool that will that will add a given absolute/relative path to sys.path while making sure the path is valid and in the correct format.</p>
<p><code>$ pip install importmonkey</code> [<a href="https://github.com/hirsimaki-markus/importmonkey" rel="nofollow noreferrer">github</a>] [<a href="https://pypi.org/project/importmonkey/" rel="nofollow noreferrer">pip</a>]</p>
<pre><code># Example structure
├─ src
│   └─ project
│       ├─ __init__.py
│       └─ module.py
└─ test
    └─ test.py
</code></pre>
<pre class="lang-py prettyprint-override"><code># Example solution using the tool, in test.py

from importmonkey import add_path
add_path(&quot;../src&quot;)  # relative to current __file__
import project

# You can add as many paths as needed, absolute or relative, in any file.
# Relative paths start from the current __file__ directory.
# Normal unix path conventions work so you can use '..' and '.' and so on.
# The paths you try to add are checked for validity etc. help(add_path) for details.

</code></pre>
<p>Disclosure of affiliation: I made importmonkey.</p>
------------------------------------------------------------------ <br><h3> Mustafa Kareem, Id: 63798655, Score: -3: </h3><p>Just use the change directory function from the <em>os</em> module:</p>
<pre><code>os.chdir(&quot;Here new director&quot;)
</code></pre>
<p>Then you can import normally.</p>
<p><a href="https://python101.pythonlibrary.org/chapter16_os.html#os-chdir-and-os-getcwd" rel="nofollow noreferrer">More information</a></p>
