 <h2> Title: Importing files from different folder </h2> <h3> Ivan, question_id: 4383571 </h3>Score: 2502, Tags: {python,importerror,python-import} <br><p>I have this folder structure:</p>
<pre><code>application
├── app
│   └── folder
│       └── file.py
└── app2
    └── some_folder
        └── some_file.py
</code></pre>
<p>How can I import a function from <code>file.py</code>, from within <code>some_file.py</code>? I tried:</p>
<pre class="lang-py prettyprint-override"><code>from application.app.folder.file import func_name
</code></pre>
<p>but it doesn't work.</p>
<h4> Comment 109289974 Kavin Raju S: </h4>Reading the official documentation helped me a lot! <a href="https://docs.python.org/3/reference/import.html#package-relative-imports" rel="nofollow noreferrer">docs.python.org/3/reference/&hellip;</a><br><h4> Comment 74009194 wim: </h4>Related:  <a href="http://stackoverflow.com/q/43476403/674039">stackoverflow.com/q/43476403/674039</a><br><h4> Comment 118961726 Gonzalo: </h4>If you have a dash in the name of the subfolder, it SHOULD BE UNDERSCORE. For example my-package and inside you have my_app folder and tests folder. If my_app is named my-app, you will have import problems<br><h4> Comment 120151575 smci: </h4>Neither <code>application</code> nor <code>app1</code>, <code>app2</code>, <code>folder</code>, <code>some_folder</code> are packages, and do not contain <code>__init__.py</code>, right? If you&#39;re going to be doing a lot of this, time to make them a package.<br><h4> Comment 124434057 Jeyekomon: </h4>It depends whether you understand <code>app</code> and <code>app2</code> as two logically separate projects/packages or not. If they are separate (for example the <code>app</code> is a common utility for several apps <code>app2</code>, <code>app3</code>, ...) then you can <a href="https://stackoverflow.com/questions/4830856/is-it-possible-to-use-pip-to-install-a-package-from-a-private-github-repository">install the <code>app</code> from its Github repository</a> into <code>app2</code>&#39;s (virtual) environment as a dependency using <code>pip</code> and then use it the same way you use any other third-party package.<br><h4> Comment 125189755 user3807691: </h4>How do I deploy the same on aws lambda using aws sam?<br><h4> Comment 129822042 Karl Knechtel: </h4>@JohnAllen it&#39;s not actually that hard. There are just a few conceptual issues that are poorly explained. A lot of the answers are duplicates, or re-organizations of various subsets of the same few simple ideas.<br><h4> Comment 134041749 pyjamas: </h4>A big source of confusion for me was that certain IDEs will make this problem disappear. In OP&#39;s example, running <code>some_file.py</code> should cause <code>ModuleNotFoundError: No module named &#39;application&#39;</code>, however if you run the file in PyCharm it will work! This is because PyCharm automatically appends the project root to <code>sys.path</code> so the <code>application</code> package is visible. My related question <a href="https://stackoverflow.com/q/75990606/3620725">here</a> gives a more complete example and some solutions.<br><h4> Comment 134041873 pyjamas: </h4>Another point of confusion is that when you have your project root in <code>sys.path</code> it <a href="https://imgur.com/9nPBT3k" rel="nofollow noreferrer">runs</a> with no errors even if you don&#39;t have any <code>__init__.py</code> files. This contradicts many highly upvoted comments and answers.<br>------------------------------------------------------------------ <br><h3> Answer 47563957 schmudu: </h3><p>In my case I had a class to import.  My file looked like this:</p>

<pre><code># /opt/path/to/code/log_helper.py
class LogHelper:
    # stuff here
</code></pre>

<p>In my main file I included the code via:</p>

<pre><code>import sys
sys.path.append("/opt/path/to/code/")
from log_helper import LogHelper
</code></pre>
<h4> Comment 102134756 Walter: </h4>@not2qubit sys wasn&#39;t imported in the answer.<br>------------------------------------------------------------------ <br><h3> Answer 48859135 danday74: </h3><p>Given a folder structure like</p>
<pre><code>├── main.py
└── myfolder
    └── myfile.py
</code></pre>
<p>Where <code>myfile.py</code> contains</p>
<pre><code>def myfunc():
    print('hello')
</code></pre>
<p>To call <code>myfunc</code> from <code>main.py</code>, use:</p>
<pre><code>from myfolder.myfile import myfunc
myfunc()
</code></pre>
<h4> Comment 92813593 Alexander Rossa: </h4>This is completely unrelated to the question which asks about importing files from a different branch of the file tree than the current working directory.<br><h4> Comment 99549389 Marc L.: </h4>Lovely diagrams that expressly ignore OP&#39;s question.<br><h4> Comment 85321241 Vincent: </h4>adding an <b>init</b>.py (empty) configuration file in myfolder worked for me on linux (y)<br><h4> Comment 87141663 mrgloom: </h4>@Vincent did you mean <code>__init__.py</code>?<br><h4> Comment 102784031 MattSom: </h4>This is not what the OP was questioning about.<br><h4> Comment 91640700 Crearo Rotar: </h4>For some reason adding <code>__init__.py</code> doesn&#39;t work for me. I&#39;m using Py 3.6.5 on Ubuntu 18. It works on Pycharm but not from terminal<br><h4> Comment 104518830 OuuGiii: </h4>This is not answering the question at all.<br><h4> Comment 87141698 Vincent: </h4>@mrgloom indeed<br><h4> Comment 87141921 mrgloom: </h4>Also seems <code>__init__.py</code> is not needed anymore in modern python 3, <a href="https://stackoverflow.com/a/39991978/1179925">stackoverflow.com/a/39991978/1179925</a><br><h4> Comment 128609484 constiii: </h4>that does not address the problem unfortunately<br><h4> Comment 109705354 Guilherme Araujo Lima da Silva: </h4>The only answer that worked for me. I tried the others with no sucess at all. I place an empty <code>__init__.py</code> files in the subfolder but it ran correctly without it.<br><h4> Comment 122609615 kağan hazal ko&#231;demir: </h4>what about in myfile.py i want to call function from main.py ? could be with init ?<br><h4> Comment 91762255 alper: </h4>What if <code>myfunc</code> located on a parent directory? @danday74<br>------------------------------------------------------------------ <br><h3> Answer 4383597 Cameron: </h3><p>Note: This answer was intended for a very specific question. For most programmers coming here from a search engine, this is not the answer you are looking for. Typically you would structure your files into packages (see other answers) instead of modifying the search path.</p>
<hr />
<p>By default, you can't. When importing a file, Python only searches the directory that the entry-point script is running from and <code>sys.path</code> which includes locations such as the package installation directory (it's actually <a href="https://docs.python.org/3/library/sys.html#sys.path" rel="noreferrer">a little more complex</a> than this, but this covers most cases).</p>
<p>However, you can add to the Python path at runtime:</p>
<pre><code># some_file.py
import sys
# caution: path[0] is reserved for script path (or '' in REPL)
sys.path.insert(1, '/path/to/application/app/folder')

import file
</code></pre>
<h4> Comment 8761102 pseudosudo: </h4><code>sys.path.append(&#39;&#47;path&#47;to&#47;application&#47;app&#47;folder&#39;)</code> is cleaner imo<br><h4> Comment 8763777 Cameron: </h4>@pseudosudo: Yep, it is, but inserting it at the beginning has the benefit of guaranteeing that the path is searched before others (even built-in ones) in the case of naming conflicts.<br><h4> Comment 53217573 Cameron: </h4>@Ofir: No, this isn&#39;t a nice clean pythonic solution. In general, you should be using packages (which are based on directory trees). This answer was specific to the question asked, and for some reason continues to accrue a large number upvotes.<br><h4> Comment 53210287 Ofir: </h4>Is it considered as a pythonic way to manage .py files in folders? I&#39;m wondering... why it&#39;s not supported by default? it doesn&#39;t make sense to maintain all .py files in a single directory..<br><h4> Comment 29361902 ArtOfWarfare: </h4>@kreativitea - <code>sys.path</code> returns a <code>list</code>, not a <code>deque</code>, and it&#39;d be silly to convert the <code>list</code> to a <code>deque</code> and back.<br><h4> Comment 76299022 rain_: </h4>@Cameron: Could you then provide the clean pythonic way to do this, or a link to the solution?<br><h4> Comment 76329076 rain_: </h4>@Cameron. It does not work for me. Im using a project folder. with some subfolders on it. One of those subfolders containts an <b>init</b>.py and files.py which has functions on them. From any file in a subfolder I use: from functions_folder.functions import *, and it just doesnt work.<br><h4> Comment 110271454 Steve Scott: </h4>Interesting. It only takes a path as a string. It does not accept a path object.<br><h4> Comment 65468402 AdjunctProfessorFalcon: </h4>@Cameron What exactly is &quot;the directory that the entry-point script is running from&quot; mean? Thanks!<br><h4> Comment 65484792 calder-ty: </h4>@Malvin9000 That means that if the file you are working on is not the main file for the program. For example say you are working on a module named <code>foo</code> and you want it imports a package named <code>bar</code>. Now if you write another script, <code>spam</code> that imports <code>foo</code> then <code>spam</code> is the entry-point script, and that when <code>foo</code> calls <code>import bar</code> python will search in <code>foo</code>&#39;s directory and then the directory containing <code>spam</code>.<br><h4> Comment 75944891 Haseeb: </h4>I already have the path in sys.path. When I do <code>print(sys.path)</code> it shows me the path is there but when I try and import it still gives me the <b>ImportError</b>. Why could this be happening?<br><h4> Comment 29287356 ArtOfWarfare: </h4>Now if only Python <code>lists</code> had a <code>prepend</code> method so that the best choice wouldn&#39;t be ugly looking. I understand the reason why <code>prepend</code> doesn&#39;t exist (because it would have worse run times than <code>append</code>), but it seems to be a moot reason. Shouldn&#39;t easy to read be valued over quick to run?<br><h4> Comment 111603769 Hi-Angel: </h4>Doesn&#39;t work for me. I have a file <code>foo</code> which I import, which in turn imports <code>conftest</code>, which located at a <code>..&#47;conftest.py</code> file. So I do <code>sys.path.append(tests_dir)</code>, where <code>tests_dir</code> I tried to be both <code>..&#47;</code> and an absolute path. However upon executing <code>import foo</code> I still get &quot;No module test named &#39;conftest&#39;`.<br><h4> Comment 113280478 Isi: </h4>@Shalomi11 On Windows, I recommend <code>sys.path.insert(1, os.path.abspath(&#39;&#47;path&#47;to&#47;application&#47;app&#47;folder&#39;))</code>, since with the notation above, the slashs are not how they should be in Windows. (You can check this if you put a breakpoint after this line and then in the debug mode, check &quot;sys.path&quot;)<br><h4> Comment 118119973 mcp: </h4>@Cameron Can you link to the pythonic solution you described, involving packages and directory trees?<br><h4> Comment 76301755 Cameron: </h4>@rain_: Use <a href="https://docs.python.org/2/tutorial/modules.html#packages" rel="nofollow noreferrer">Python packages</a> as suggested by joey&#39;s answer.<br><h4> Comment 29359561 kreativitea: </h4>@ArtOfWarfare deques solve the runtime issue, and they have an appendleft method.  If you need a list, use a list, if you need a deque, use a deque.<br><h4> Comment 102567942 Andreas Forsl&#246;w: </h4>@GabrielStaples yes, it does work on relative paths.<br><h4> Comment 102568062 Andreas Forsl&#246;w: </h4>Another thing worth pointing out about this approach, which makes it non-pythonic, is that you cannot have the same name for any of your <code>sys.path</code> modules as one of your local modules. I.e. you cannot import <code>sys&#47;path&#47;module.py</code> to your <code>current&#47;package&#47;main.py</code> if <code>current&#47;package&#47;main.py</code> imports <code>current&#47;package&#47;module.py</code>. In other words, all the imported modules has to have unique names.<br><h4> Comment 108591641 McLawrence: </h4>It&#39;s important to note that even if you use something like <code>os.path.abspath</code> aliases like <code>~</code> for your home directory are not replaced.<br><h4> Comment 121715114 HAL9000: </h4>would it be possible to add all those &quot;custom&quot; packages in a common python file or do you need to add this line in all the .py files that need to import those custom modules?<br><h4> Comment 111857946 theX: </h4>@Hi-Angel , does this solve your problem?: <a href="https://stackoverflow.com/questions/62886769/is-it-possible-to-import-a-python-file-from-outside-the-directory-the-main-file" title="is it possible to import a python file from outside the directory the main file">stackoverflow.com/questions/62886769/&hellip;</a><br><h4> Comment 111862053 Hi-Angel: </h4>@theX thanks, I should try it. For now I worked around this be placing the script in a different directory.<br><h4> Comment 112784296 Shalomi90: </h4>Hi guys, I have the same problem but the solution doesnt work. the path in the brackets is underlined and can&#39;t be find. What can I do? Its the correct path<br><h4> Comment 134042255 pyjamas: </h4>It&#39;s also worth mentioning that if you use PyCharm or Spyder then by default you <i>can</i> just use absolute imports without any errors because the IDE automatically adds your project directory to <code>sys.path</code>, which is the same thing this answer does. I think that&#39;s why there are wrong answers like joey&#39;s saying it should just work with so many upvotes. See also <a href="https://stackoverflow.com/q/75990606">Automatically add project to sys.path in VS Code</a><br><h4> Comment 124123187 Sermet Pekin: </h4>@Cameron thanks for your helpful answer. It has at least one more special case which I found useful. And that case is when I want to include my python file to the Spyder and Jupyter platforms from my own library. Same code should work in both platforms and when I copy and it does.<br>------------------------------------------------------------------ <br><h3> Answer 21995949 joey: </h3><p>There is nothing wrong with:</p>
<pre><code>from application.app.folder.file import func_name
</code></pre>
<p>Just make sure <code>folder</code> also contains an <code>__init__.py</code>. This allows it to be included as a package. I am not sure why the other answers talk about <code>PYTHONPATH</code>.</p>
<h4> Comment 48464320 jay: </h4>@Xinyang It can be an empty file. Its very existence tells Python to treat the directory as a package.<br><h4> Comment 48380399 XYZ: </h4>What&#39;s inside the <code>init.py</code> or <code>__init__.py</code> file?<br><h4> Comment 76216537 dasWesen: </h4>Whatever I try, this won&#39;t work. I want to import from a &quot;sibling&quot; directory, so one up one down. All have __ init __.py&#39;s, including parent. Is this python 3 -specific?<br><h4> Comment 33747835 msvalkon: </h4>Because this doesn&#39;t cover the cases where modifying <code>PYTHONPATH</code> is necessary. Say you have two folders on the same level: <code>A</code> and <code>B</code>. <code>A</code> has an <code>__init.py__</code>. Try importing something from <code>B</code> within <code>A</code>.<br><h4> Comment 59232806 Scott Prive: </h4>This is not currently the highest voted answer, but it IS the most correct answer (for most cases). Simply create a package. It&#39;s not hard.   The other answers are needed because sometimes you might be restricted from certain system changes (creating or modifying a file, etc) like during testing.<br><h4> Comment 99574150 kakyo: </h4>running this script in command line with py3.7 on Windows gives me <code>No module named application.app.folder.file</code>. I have all the <b>init</b>.py in place including the one for the parent folder<br><h4> Comment 74431473 Yibo Yang: </h4>Of course this answer assumes that <code>application</code> and <code>app</code> are packages already (i.e. you already have <code>__init__.py</code> in both of them). As the result of adding <code>__init__.py</code> also to <code>folder</code>, <code>application.app.folder</code> becomes a (sub) <i>package</i>, from which you can access the <i>module</i> <code>application.app.folder.file</code>, whose symbol <code>func_name</code> can now be imported<br><h4> Comment 118598955 Lei_Bai: </h4>I am using python3, and it does not work for me<br><h4> Comment 42074035 sofly: </h4>this is a great answer - I was missing the <b>init</b>.py to initialize the package. Also encourages best practice so that there&#39;s less risk of namespace collision. Thanks!<br><h4> Comment 134041530 pyjamas: </h4>Even with <code>__init__.py</code> in every folder, absolute imports of adjacent packages doesn&#39;t work unless the root directory is in PYTHONPATH. I&#39;m not sure how there are 1200 upvotes on an answer that just <a href="https://i.imgur.com/4J5BKVL.png" rel="nofollow noreferrer">doesn&#39;t work</a>... I&#39;m assuming anyone not getting <code>ModuleNotFoundError</code> is running their code through an IDE like PyCharm that automatically adds the project directory to <code>sys.path</code>. You can read more <a href="https://stackoverflow.com/q/75990606/3620725">here</a> and <a href="https://stackoverflow.com/q/14132789/3620725">here</a><br><h4> Comment 121347547 martin36: </h4>In order to get this working for me, I had to add the lines <code>import sys</code> and <code>sys.path.insert(0, &#39;&#39;)</code> before importing the module<br><h4> Comment 110988868 mold: </h4>This sounds like a joke. Many guys writing a lot of things about what is right and don&#39;t and finally someone says that is not &quot;nothing wrong with&quot;...<br><h4> Comment 115147321 pouya: </h4>Wish Python 4 does something sensible about this so called Package system. No ,matter ow many <code>__init__.py</code> you put in place, python always fails to find modules.<br><h4> Comment 104930037 amdev: </h4>i have folder <code>a&#47;test.py</code> and the file <code>b.py</code> as the same level of a folder. even by adding a <code>__init__.py</code> file to the root folder (as side of <code>a</code> folder with <code>b.py</code>) i cant import a function from <code>b.py</code> file inside <code>test.py</code>...<br><h4> Comment 128484756 JohnAllen: </h4>This doesn&#39;t work. Simple as that. It SHOULD work, but it doesn&#39;t.<br><h4> Comment 132681277 benso8: </h4>I don&#39;t think this works with Python 3.8. I had issues using this approach.<br><h4> Comment 130966964 KansaiRobot: </h4>it doesn&#39;t work<br><h4> Comment 131357682 Pit Digger: </h4>This doesnt work, its so weird<br><h4> Comment 121828959 ashrasmun: </h4>ModuleNotFoundError: No module named &#39;application&#39; :(<br><h4> Comment 116332233 Mohd: </h4>Working and not working ... works when I try <code>from A.file import funcA</code> at level <code>Z</code>  (folder that has A and B as sub-folder)  at the IPython console.  However, running  <code>funcB</code> inside <code>B</code> folder that has  <code>from A.file import funcA</code> fails and throws the error (ModuleNotFoundError: No module named &#39;FashionColor&#39;). Note that running <code>funcB</code>  will change the working directory to <code>B</code>.  All folders have <b>init</b>.py.<br><h4> Comment 104210299 Minh Nghĩa: </h4>Is the <code>__init__.py</code> still required, given implicit package namespace?<br><h4> Comment 88619028 SnitchingAuggie: </h4>Is there a solution to this problem now? I can&#39;t find a way to circumvent the problem and I find it very confusing to have all files for one single program in one folder<br><h4> Comment 66214640 Sunding Wei: </h4>The empty <b>init</b>.py is vital in the container directory, thanks.<br><h4> Comment 80973920 dasWesen: </h4>@borgr I think I circumvented it back then... Sorry, I don&#39;t remember what code that problem was in, this was too long ago (and it&#39;s not relevant for me right now). But there seems to be a common issue, so if anyone else has the problem right now, yes, please go ahead and open a new question.<br><h4> Comment 55984838 Ax3l: </h4><code>__init__.py</code> syntax is described in more detail in   <a href="https://docs.python.org/3/tutorial/modules.html#packages" rel="nofollow noreferrer">docs.python.org/3/tutorial/modules.html#packages</a> and is useful if the package resides in a system or PYTHONPATH (sub-)dir or inside a dir of the calling application itself.<br><h4> Comment 84854737 Brōtsyorfuzthrāx: </h4>@msvalkon If changing the path to directory B won&#39;t break your program, you can use symbolic links along with this answer to solve that problem. Let&#39;s say you&#39;re in directory A and want to import something in directory B. Add <code>__init__.py</code> to directory B. Make a symbolic link of directory B; put it in directory A. In directory A, <code>import B.yourModule</code>.<br><h4> Comment 80766418 borgr: </h4>@dasWesen, don&#39;t think it should differ much, but if this doesn&#39;t help you, ask a new one<br><h4> Comment 136427243 Vishwas Sathish: </h4>This answer seems to be wrong as others pointed out. Does not work for Python 3.7 and 3.9. Wonder why it has so many upvotes.<br><h4> Comment 35278155 zlr: </h4>that&#39;s what i was looking for, ie works with standard local lib directory<br><h4> Comment 131482863 Bebotron: </h4>Does note work for files in sibling directories.<br><h4> Comment 132103764 Alirezaarabi: </h4>this is not worked for me. but <code>PYTHONPATH</code> worked<br><h4> Comment 110836317 Yeahprettymuch: </h4>How would <code>application.app.folder.file</code> be changed in case there was a space in the name of the folder? Doesn&#39;t seem to be any clear answer to that.<br><h4> Comment 123114915 Andrew K: </h4>If you are using a PEP8 formatter, you will run into problems here since module imports are automatically sorted to the top of the file for imports. You can use #noqa to ignore these lines... but wowza that&#39;s ugly<br><h4> Comment 100997997 Ashu: </h4>If my folder name is a_b_c and which contains app.py so how we can access it? @joey<br><h4> Comment 88880856 SMDC: </h4>This is the easiest solution<br>------------------------------------------------------------------ <br><h3> Answer 40612922 slizb: </h3><p>When modules are in parallel locations, as in the question:</p>

<pre><code>application/app2/some_folder/some_file.py
application/app2/another_folder/another_file.py
</code></pre>

<p>This shorthand makes one module visible to the other:</p>

<pre><code>import sys
sys.path.append('../')
</code></pre>
<h4> Comment 74543117 Carl Smith: </h4>As a caveat: This works so long as the importing script is run from its containing directory. Otherwise the parent directory of whatever other directory the script is run from will be appended to the path and the import will fail.<br><h4> Comment 91674969 Rahul: </h4>To avoid that, we can get the parent directory of file <code>sys.path.append(os.path.dirname(os.path.abspath(__file__)))</code><br><h4> Comment 104909466 addicted: </h4>If you run it from your root folder (ie. application folder), you are probably fine with <code>sys.path.append(&#39;.&#39;)</code> then importing the module by using <code>from app2.some_folder.some_file import your_function</code>.  Alternatively what works for me is running <code>python3 -m app2.another_folder.another_file</code> from root folder.<br><h4> Comment 104389899 towi_parallelism: </h4>@Rahul, your solution doesn&#39;t work for interactive shells<br><h4> Comment 100942317 RCross: </h4>That didn&#39;t work for me - I had to add an additional dirname in there to climb back up to the parent, so that running <code>cli&#47;foo.py</code> from the command line was able to <code>import cli.bar</code><br><h4> Comment 105061705 Amir: </h4>I find this to be the simplest way.  just append the relative file path to the file containing the module you need.  in my case:    import sys sys.append(&#39;../data_structure/&#39;) .  the module is in a file inside of the data_structure/ folder<br><h4> Comment 128484793 JohnAllen: </h4>So every directory I want to import from needs three total lines of code to import a single file from each directory? Or is <code>path.append</code> by default recursive?<br><h4> Comment 129536070 mirekphd: </h4>Rather than appending to system path, inserting custom package folder at 1st position in the path would be more robust (to name collisions, that are rather likely, e.g. when debugging a temporary copy of an official package copied from a write-protected location).<br>------------------------------------------------------------------ <br><h3> Answer 50474562 Alex Montoya: </h3><p><strong>First</strong> import sys in name-file.py</p>

<pre><code> import sys
</code></pre>

<p><strong>Second</strong> append the folder path in name-file.py</p>

<pre><code>sys.path.insert(0, '/the/folder/path/name-package/')
</code></pre>

<p><strong>Third</strong> Make a blank file called __ init __.py in your subdirectory (this tells Python it is a package)</p>

<ul>
<li>name-file.py</li>
<li>name-package

<ul>
<li>__ init __.py</li>
<li>name-module.py</li>
</ul></li>
</ul>

<p><strong>Fourth</strong> import the module inside the folder in name-file.py</p>

<pre><code>from name-package import name-module
</code></pre>
<h4> Comment 95759808 Bastian: </h4>With name-folder being right below name-file.py, this should work even without the <code>sys.path.insert</code>-command. As such, the answer leaves the question, if this solution works even when name-folder is located in an arbitrary location.<br><h4> Comment 129536087 mirekphd: </h4>Caution: insert at position 1, since position 0 is the script path (or &#39;&#39; in REPL).<br><h4> Comment 135187247 Deepak Tatyaji Ahire: </h4>Thanks for this answer @Alex Montoya! Upvoted!<br><h4> Comment 117762690 Giacomo: </h4>are you saying that I have to hardcode the path to the script? This means that the solution is not portable. Also the question is how to access from one subfolder to the other. Why not following the name convention and file structure of the original question?<br><h4> Comment 123699572 Jeyekomon: </h4>@Giacomo You don&#39;t have to hardcode anything. Just pass it as a parameter to the script.<br>------------------------------------------------------------------ <br><h3> Answer 47853501 Zectbumo: </h3><p>Try Python's relative imports:</p>

<pre><code>from ...app.folder.file import func_name
</code></pre>

<p>Every leading dot is another higher level in the hierarchy beginning with the current directory.</p>

<hr>

<p>Problems? If this isn't working for you then you probably are getting bit by the many gotcha's relative imports has.
Read answers and comments for more details: 
<a href="https://stackoverflow.com/questions/11536764/how-to-fix-attempted-relative-import-in-non-package-even-with-init-py">How to fix &quot;Attempted relative import in non-package&quot; even with __init__.py</a></p>

<p>Hint: have <code>__init__.py</code> at every directory level. You might need <code>python -m application.app2.some_folder.some_file</code> (leaving off .py) which you run from the top level directory or have that top level directory in your PYTHONPATH. <em>Phew!</em></p>
<h4> Comment 129822049 Karl Knechtel: </h4>@secluded sure, but <code>import 70_foo</code> isn&#39;t allowed either. Both package and module names have to be legal identifier names.<br><h4> Comment 113879770 secluded: </h4>This doesn&#39;t seem to work if your directory&#39;s name starts with a number (e.g. <code>import ..70_foo.test</code> is not allowed)<br><h4> Comment 120588970 Camilo Martinez M.: </h4>Wow, this actually worked. I didn&#39;t know you could &quot;go up&quot; a directory by using multiple dots.<br>------------------------------------------------------------------ <br><h3> Answer 21878513 Ax3l: </h3><p>I think an ad hoc way would be to use <a href="https://docs.python.org/3/using/cmdline.html#envvar-PYTHONPATH" rel="nofollow noreferrer">the environment variable <code>PYTHONPATH</code></a> as described in the documentation: <a href="http://docs.python.org/2/tutorial/modules.html#the-module-search-path" rel="nofollow noreferrer" title="Python 2">Python2</a>, <a href="https://docs.python.org/3/tutorial/modules.html#the-module-search-path" rel="nofollow noreferrer" title="Python 3">Python3</a></p>
<pre><code># Linux and OS X
export PYTHONPATH=$HOME/dirWithScripts/:$PYTHONPATH

# Windows
set PYTHONPATH=C:\path\to\dirWithScripts\;%PYTHONPATH%
</code></pre>
<h4> Comment 38089724 Ax3l: </h4>no, with the path of the directory to your .py file<br><h4> Comment 108232159 information_interchange: </h4>Unfortunately, if you are using Anaconda, this won&#39;t work, since under the hood PYTHONPATH is not really used internally !<br><h4> Comment 108273976 Ax3l: </h4>For (recent) changes in anaconda, see this SO for workflows and comments for work-arounds: <a href="https://stackoverflow.com/questions/17386880/does-anaconda-create-a-separate-pythonpath-variable-for-each-new-environment" title="does anaconda create a separate pythonpath variable for each new environment">stackoverflow.com/questions/17386880/&hellip;</a> Generally speaking, build and install small packages instead of hacking the import dirs.<br><h4> Comment 37892938 Vladimir Putin: </h4>Wait, would I replace myScripts with the filename?<br>------------------------------------------------------------------ <br><h3> Answer 42170807 CianB: </h3><p>The issue is that Python is looking in the wrong directory for the file. To solve this, try using <em>relative import</em>. Change</p>
<pre><code>from application.app.folder.file import func_name
</code></pre>
<p>to:</p>
<pre><code>from .application.app.folder.file import func_name
</code></pre>
<p>Adding the dot instructs Python to look for the <code>application</code> folder within the current folder, instead of in the Python install folder.</p>
<h4> Comment 121828969 ashrasmun: </h4>ImportError: attempted relative import with no known parent package :(<br><h4> Comment 125057246 Prats: </h4>I&#39;m getting the same error, any solution to this?<br><h4> Comment 129822062 Karl Knechtel: </h4>@Prats please see <a href="https://stackoverflow.com/questions/11536764/how-to-fix-attempted-relative-import-in-non-package-even-with-init-py" title="how to fix attempted relative import in non package even with init py">stackoverflow.com/questions/11536764/&hellip;</a>.<br><h4> Comment 131357697 Pit Digger: </h4>Why this has so many votes ? Totally wrong answer.<br><h4> Comment 135306680 SMMH: </h4>@ashrasmun @Prats try making empty <code>__init__.py</code> files in your folder and its parent folder.<br>------------------------------------------------------------------ <br><h3> Answer 51585877 wecsam: </h3><p>In Python 3.4 and later, you can <a href="https://docs.python.org/3/library/importlib.html#importing-a-source-file-directly" rel="noreferrer">import from a source file directly (link to documentation)</a>. This is not the simplest solution, but I'm including this answer for completeness.</p>

<p>Here is an example. First, the file to be imported, named <code>foo.py</code>:</p>

<pre><code>def announce():
    print("Imported!")
</code></pre>

<p>The code that imports the file above, inspired heavily by the example in the documentation:</p>

<pre><code>import importlib.util

def module_from_file(module_name, file_path):
    spec = importlib.util.spec_from_file_location(module_name, file_path)
    module = importlib.util.module_from_spec(spec)
    spec.loader.exec_module(module)
    return module

foo = module_from_file("foo", "/path/to/foo.py")

if __name__ == "__main__":
    print(foo)
    print(dir(foo))
    foo.announce()
</code></pre>

<p>The output:</p>

<pre><code>&lt;module 'foo' from '/path/to/foo.py'&gt;
['__builtins__', '__cached__', '__doc__', '__file__', '__loader__', '__name__', '__package__', '__spec__', 'announce']
Imported!
</code></pre>

<p>Note that the variable name, the module name, and the filename need not match. This code still works:</p>

<pre><code>import importlib.util

def module_from_file(module_name, file_path):
    spec = importlib.util.spec_from_file_location(module_name, file_path)
    module = importlib.util.module_from_spec(spec)
    spec.loader.exec_module(module)
    return module

baz = module_from_file("bar", "/path/to/foo.py")

if __name__ == "__main__":
    print(baz)
    print(dir(baz))
    baz.announce()
</code></pre>

<p>The output:</p>

<pre><code>&lt;module 'bar' from '/path/to/foo.py'&gt;
['__builtins__', '__cached__', '__doc__', '__file__', '__loader__', '__name__', '__package__', '__spec__', 'announce']
Imported!
</code></pre>

<p>Programmatically importing modules was introduced in Python 3.1 and gives you more control over how modules are imported. Refer to the documentation for more information.</p>
<h4> Comment 94998821 Dan: </h4>I don&#39;t know if anyone even tried to understand this, but I think that it&#39;s too complicated.<br><h4> Comment 121758593 Sincere: </h4>This is the only solution that worked for me. I have the same file name in different directories.<br><h4> Comment 129035361 Paulo: </h4>That was the only solution that worked for me.<br><h4> Comment 129610888 DrCord: </h4>This should be the correct solution for import a local module that you don&#39;t want to publish to the package repository.<br><h4> Comment 125010103 john k: </h4>how to import everything in a file?<br>------------------------------------------------------------------ <br><h3> Answer 46569406 Nagev: </h3><p>Using <code>sys.path.append</code> with an absolute path is not ideal when moving the application to other environments. Using a relative path won't always work because the current working directory depends on how the script was invoked.</p>
<p>Since the application folder structure is fixed, we can use <code>os.path</code> to get the full path of the module we wish to import. For example, if this is the structure:</p>
<pre><code>/home/me/application/app2/some_folder/vanilla.py
/home/me/application/app2/another_folder/mango.py
</code></pre>
<p>And let's say that you want to import the <em>mango</em> module. You could do the following in <em>vanilla.py</em>:</p>
<pre><code>import sys, os.path
mango_dir = (os.path.abspath(os.path.join(os.path.dirname(__file__), '..'))
+ '/another_folder/')
sys.path.append(mango_dir)
import mango
</code></pre>
<p>Of course, you don't need the <em>mango_dir</em> variable.</p>
<p>To understand how this works look at this interactive session example:</p>
<pre><code>&gt;&gt;&gt; import os
&gt;&gt;&gt; mydir = '/home/me/application/app2/some_folder'
&gt;&gt;&gt; newdir = os.path.abspath(os.path.join(mydir, '..'))
&gt;&gt;&gt; newdir
    '/home/me/application/app2'
&gt;&gt;&gt; newdir = os.path.abspath(os.path.join(mydir, '..')) + '/another_folder'
&gt;&gt;&gt; 
&gt;&gt;&gt; newdir
'/home/me/application/app2/another_folder'
&gt;&gt;&gt; 
</code></pre>
<p>And check the <a href="https://docs.python.org/3/library/os.path.html" rel="noreferrer">os.path</a> documentation.</p>
<p>Also worth noting that dealing with multiple folders is made easier when using <a href="https://docs.python.org/3/tutorial/modules.html#packages" rel="noreferrer">packages</a>, as one can use dotted module names.</p>
------------------------------------------------------------------ <br><h3> Answer 27097894 Vaibhav Singh: </h3><p>From what I know,  add an <code>__init__.py</code> file directly in the folder of the functions you want  to  import  will do  the job.</p>
<h4> Comment 58741654 Ax3l: </h4>only if the script that wants to include that other directory is already in the sys.path<br><h4> Comment 72853314 herve-guerin: </h4>I used <code>sys.path.append(tools_dir)</code> on Windows and I don&#39;t need to add a <code>__init__.py&#39; file in my directory </code>tools_dir`<br><h4> Comment 130275798 Karl Knechtel: </h4><code>__init__.py</code> has <b>effectively nothing to do with it</b>.<br><h4> Comment 135343555 chanduthedev: </h4>Setting as ENV variable worked for me  <code>export PYTHONPATH=&quot;${PYTHONPATH}:&#47;path&#47;to&#47;python&#47;project&quot;</code><br>------------------------------------------------------------------ <br><h3> Answer 52586031 Erick Mwazonga: </h3><p>I was faced with the same challenge, especially when importing multiple files, this is how I managed to overcome it.</p>

<pre><code>import os, sys

from os.path import dirname, join, abspath
sys.path.insert(0, abspath(join(dirname(__file__), '..')))

from root_folder import file_name
</code></pre>
<h4> Comment 98302651 not2qubit: </h4>You answer would be more helpful if you could explain what it does differently from an ordinary import?<br><h4> Comment 98555570 jwal: </h4>I had /path/dir1/__init__.py and /path/dir1/mod.py. For /path/some.py from dir1.mod import func worked. When in /path/dir2/some.py it only worked after I copied and pasted the above answer at the top of the file. Didn&#39;t want to edit my path since not every python project I have is in /path/.<br><h4> Comment 123087507 Vishrant: </h4>My test files were moved to another directory when running it using <code>bazel</code> after adding this import, the test files were able to reference the dependencies.<br>------------------------------------------------------------------ <br><h3> Answer 38978765 dsg38: </h3><p>This worked for me in Python 3 on Linux:</p>
<pre><code>import sys
sys.path.append(pathToFolderContainingScripts)
from scriptName import functionName #scriptName without .py extension
</code></pre>
<h4> Comment 75165003 daGo: </h4><code>sys.path.append(&quot;&#47;home&#47;linux&#47;folder&#47;&quot;)</code> —  Make sure do not use a shortcut e.g. <code>&quot;~&#47;folder&#47;&quot;</code><br><h4> Comment 110384017 John Stud: </h4>This is the easiest answer; works for Windows as well.<br>------------------------------------------------------------------ <br><h3> Answer 33143646 ChandanK: </h3><p>Considering <code>application</code> as the root directory for your Python project, create an empty <code>__init__.py</code> file in the <code>application</code>, <code>app</code> and <code>folder</code> folders. Then in your <code>some_file.py</code>, make changes as follows to get the definition of <em>func_name</em>:</p>
<pre><code>import sys
sys.path.insert(0, r'/from/root/directory/application')

from application.app.folder.file import func_name ## You can also use '*' wildcard to import all the functions in file.py file.
func_name()
</code></pre>
<h4> Comment 58471088 Bolaka: </h4>should be: sys.path.insert(0, r&#39;/from/root/directory&#39;)<br>------------------------------------------------------------------ <br><h3> Answer 62852757 Mohsen Haddadi: </h3><p>One way is to create a package and use <em>absolute import</em> to access other modules from the package. Start the program from a script at the root of the package. This structure allows using and accessing sub-packages, parent package, and sibling packages and modules.</p>
<p>As an example, try creating the following folder structure:</p>
<pre><code>package/
├── __init__.py
├── main_module.py
├── module_0.py
├── subpackage_1/
|   ├── __init__.py
|   ├── module_1.py
|   └── sub_subpackage_3/
|       ├── __init__.py
|       └── module_3.py
└── subpackage_2/
    ├── __init__.py
    └── module_2.py
</code></pre>
<p>Contents of <code>main_module.py</code>:</p>
<pre><code>import subpackage_1.module_1
</code></pre>
<p>Contents of <code>module_0.py</code>:</p>
<pre><code>print('module_0 at parent directory, is imported')
</code></pre>
<p>Contents of <code>module_1.py</code>:</p>
<pre><code>print('importing other modules from module_1...')
import module_0
import subpackage_2.module_2
import subpackage_1.sub_subpackage_3.module_3
</code></pre>
<p>Contents of <code>module_2.py</code>:</p>
<pre><code>print('module_2 at same level directory, is imported')
</code></pre>
<p>Contents of <code>module_3.py</code>:</p>
<pre><code>print('module_3 at sub directory, is imported')
</code></pre>
<p>Leave all <code>__init__.py</code> files empty.</p>
<p>Now run <code>main_module.py</code>; the output will be</p>
<pre><code>importing other modules from module_1...
module_0 at parent directory, is imported
module_2 at same level directory, is imported
module_3 at sub directory, is imported
</code></pre>
------------------------------------------------------------------ <br><h3> Answer 67962159 Milovan Tomašević: </h3><pre class="lang-py prettyprint-override"><code>├───root
│   ├───dir_a
│   │   ├───file_a.py
│   │   └───file_xx.py
│   ├───dir_b
│   │   ├───file_b.py
│   │   └───file_yy.py
│   ├───dir_c
│   └───dir_n
</code></pre>
<p>You can add the parent directory to <code>PYTHONPATH</code>, in order to achieve that, you can use OS depending path in the &quot;module search path&quot; which is listed in <code>sys.path</code>. So you can easily add the parent directory like following:</p>
<pre class="lang-py prettyprint-override"><code># file_b.py

import sys
sys.path.insert(0, '..')

from dir_a.file_a import func_name
</code></pre>
<h4> Comment 130615928 mike: </h4>The magic here is to use &#39;.&#39; instead of &#39;/&#39; to indicate the path relative to current path.<br>------------------------------------------------------------------ <br><h3> Answer 36251540 Emeeus: </h3><p>This works for me on Windows:</p>
<pre><code># some_file.py on mainApp/app2
import sys
sys.path.insert(0, sys.path[0]+'\\app2')

import some_file
</code></pre>
------------------------------------------------------------------ <br><h3> Answer 59598549 WY Hsu: </h3><p>I bumped into the same question several times, so I would like to share my solution.</p>

<h2>Python Version: 3.X</h2>

<p>The following solution is for someone who develops your application in Python version 3.X because <a href="https://www.python.org/doc/sunset-python-2/" rel="noreferrer">Python 2 is not supported since Jan/1/2020</a>.</p>

<h2>Project Structure</h2>

<p>In python 3, you don't need <code>__init__.py</code> in your project subdirectory due to the <a href="https://www.python.org/dev/peps/pep-0420/" rel="noreferrer">Implicit Namespace Packages</a>. See <a href="https://stackoverflow.com/questions/37139786/is-init-py-not-required-for-packages-in-python-3-3">Is <strong>init</strong>.py not required for packages in Python 3.3+</a>  </p>

<pre><code>Project 
├── main.py
├── .gitignore
|
├── a
|   └── file_a.py
|
└── b
    └── file_b.py
</code></pre>

<h2>Problem Statement</h2>

<p>In <code>file_b.py</code>, I would like to import a class <code>A</code> in <code>file_a.py</code> under the folder a.</p>

<h2>Solutions</h2>

<h3>#1 A quick but dirty way</h3>

<p>Without installing the package like you are currently developing a new project</p>

<p>Using the <code>try catch</code> to check if the errors. Code example: </p>

<pre><code>import sys
try:
    # The insertion index should be 1 because index 0 is this file
    sys.path.insert(1, '/absolute/path/to/folder/a')  # the type of path is string
    # because the system path already have the absolute path to folder a
    # so it can recognize file_a.py while searching 
    from file_a import A
except (ModuleNotFoundError, ImportError) as e:
    print("{} fileure".format(type(e)))
else:
    print("Import succeeded")
</code></pre>

<h3>#2 Install your package</h3>

<p>Once you installed your application (in this post, the tutorial of installation is not included)</p>

<p>You can simply</p>

<pre><code>try:
    from __future__ import absolute_import
    # now it can reach class A of file_a.py in folder a 
    # by relative import
    from ..a.file_a import A  
except (ModuleNotFoundError, ImportError) as e:
    print("{} fileure".format(type(e)))
else:
    print("Import succeeded")
</code></pre>

<p>Happy coding!</p>
<h4> Comment 117762881 Giacomo: </h4>your first proposed solution worked for me using sys.path.insert(1, &#39;../a/&#39;) which I think is better than writing the full path.<br><h4> Comment 105361416 WY Hsu: </h4>for more info about <a href="https://stackoverflow.com/questions/42853617/python-fails-importing-package">absolute imports</a><br><h4> Comment 117796100 Medoalmasry: </h4>In case someone has a local package that you would like to import instead of the system package (THAT HAS THE SAME NAME) please use sys.path.insert(1,&#39;folder-to-grab-package-from&#39;) instead of sys.append(&#39;folder-to-grab-package-from&#39;)<br><h4> Comment 128484933 JohnAllen: </h4>You say &quot;You can simply&quot; but unfortunately seven lines of code to import a single file is not simple at all!<br>------------------------------------------------------------------ <br><h3> Answer 42874499 herve-guerin: </h3><p>I'm quite special: I use Python with Windows!</p>
<p>I just complete information: for both Windows and Linux, both relative and absolute paths work into <code>sys.path</code> (I need relative paths because I use my scripts on the several PCs and under different main directories).</p>
<p>And when using Windows, both <code>\</code> and <code>/</code> can be used as a separator for file names and of course you must double <code>\</code> into Python strings. Here are some valid examples:</p>
<pre><code>sys.path.append('c:\\tools\\mydir')
sys.path.append('..\\mytools')
sys.path.append('c:/tools/mydir')
sys.path.append('../mytools')
</code></pre>
<p>(Note: I think that <code>/</code> is more convenient than <code>\</code>, even if it is less 'Windows-native', because it is Linux-compatible and simpler to write and copy to <a href="https://en.wikipedia.org/wiki/File_Explorer" rel="nofollow noreferrer">Windows Explorer</a>)</p>
<h4> Comment 95966924 Corey Goldberg: </h4>os.path.join(&#39;tools&#39;, &#39;mydir&#39;)<br>------------------------------------------------------------------ <br><h3> Answer 60202840 user12058827: </h3><p>Instead of just doing an <code>import ...</code>, do this :</p>

<p><code>from &lt;MySubFolder&gt; import &lt;MyFile&gt;</code></p>

<p>MyFile is inside the MySubFolder.</p>
<h4> Comment 135370166 ScubaInstructor: </h4>Great and simple!<br>------------------------------------------------------------------ <br><h3> Answer 70919483 yerty: </h3><p>The following worked for me:</p>
<p><strong>OS</strong>: Windows 10</p>
<p><strong>Python</strong>: v3.10.0</p>
<p><strong>Note</strong>: Since I am Python v3.10.0, I am not using <code>__init__.py</code> files, which did not work for me anyway.</p>
<pre><code>application
├── app
│   └── folder
│       └── file.py
└── app2
    └── some_folder
        └── some_file.py
</code></pre>
<p><a href="https://stackoverflow.com/a/59598549/848353">WY Hsu's</a> first solution worked for me. I have reposted it with an <strong>absolute file reference</strong> for clarity:</p>
<pre><code>import sys
sys.path.insert(1, 'C:\\Users\\&lt;Your Username&gt;\\application')
import app2.some_folder.some_file

some_file.hello_world()
</code></pre>
<p><strong>Alternative Solution</strong>: However, this also worked for me:</p>
<pre><code>import sys
sys.path.append( '.' )
import app2.some_folder.some_file

some_file.hello_world()
</code></pre>
<p>Although, I do not understand why it works. I thought the dot is a reference to the current directory. However, when printing out the paths to the current folder, the current directory is already listed at the top:</p>
<pre><code>for path in sys.path:
    print(path)
</code></pre>
<h4> Comment 126455055 Tirbo06: </h4>For me I had to get up one more branch by doing <code>sys.path.append(&#39;..&#39;)</code> and it worked ! But still display the path of the CWD<br>------------------------------------------------------------------ <br><h3> Answer 34439121 Timothy C. Quinn: </h3><p>If the purpose of loading a module from a specific path is to assist you during the development of a custom module, you can create a symbolic link in the same folder of the test script that points to the root of the custom module. This module reference will take precedence over any other modules installed of the same name for any script run in that folder.</p>
<p>I tested this on Linux but it should work in any modern OS that supports symbolic links.</p>
<p>One advantage to this approach is that you can you can point to a module that's sitting in your own local software version control branch working copy which can greatly simplify the development cycle time and reduce failure modes of managing different versions of the module.</p>
<h4> Comment 133821698 Peter Mortensen: </h4>What is <i>&quot;SVC&quot;</i>? Do you mean <i>&quot;<a href="https://en.wikipedia.org/wiki/Distributed_version_control" rel="nofollow noreferrer">DVC</a>&quot;</i>? Or <i>&quot;<a href="https://en.wikipedia.org/wiki/Distributed_version_control" rel="nofollow noreferrer">DVCS</a>&quot;</i>? Or even <i>&quot;<a href="https://en.wikipedia.org/wiki/Concurrent_Versions_System" rel="nofollow noreferrer">CVS</a>&quot;</i>, <i>&quot;<a href="https://en.wikipedia.org/wiki/Microsoft_Visual_SourceSafe" rel="nofollow noreferrer">VSS</a>&quot;</i>, or <i>&quot;<a href="https://en.wikipedia.org/wiki/Apache_Subversion" rel="nofollow noreferrer">SVN</a>&quot;</i>? Or something else? <i>Source version control</i>?<br><h4> Comment 133825700 Timothy C. Quinn: </h4>SVC = Software Version Control. Just realized it&#39;s not a commonly used acronym but its is the umbrella over all of all version control systems. I&#39;ll edit my comment to be more clear.<br><h4> Comment 133825732 Timothy C. Quinn: </h4>Great read: <a href="https://docs.lib.purdue.edu/cgi/viewcontent.cgi?article=1393&amp;context=cstech" rel="nofollow noreferrer">docs.lib.purdue.edu/cgi/&hellip;</a><br>------------------------------------------------------------------ <br><h3> Answer 56996357 duhaime: </h3><p>I was working on project <code>a</code> that I wanted users to install via <code>pip install a</code> with the following file list:</p>

<pre><code>.
├── setup.py
├── MANIFEST.in
└── a
    ├── __init__.py
    ├── a.py
    └── b
        ├── __init__.py
        └── b.py
</code></pre>

<p>setup.py</p>

<pre><code>from setuptools import setup

setup (
  name='a',
  version='0.0.1',
  packages=['a'],
  package_data={
    'a': ['b/*'],
  },
)
</code></pre>

<p>MANIFEST.in</p>

<pre><code>recursive-include b *.*
</code></pre>

<p>a/<strong>init</strong>.py</p>

<pre><code>from __future__ import absolute_import

from a.a import cats
import a.b
</code></pre>

<p>a/a.py</p>

<pre><code>cats = 0
</code></pre>

<p>a/b/<strong>init</strong>.py</p>

<pre><code>from __future__ import absolute_import

from a.b.b import dogs
</code></pre>

<p>a/b/b.py</p>

<pre><code>dogs = 1
</code></pre>

<hr>

<p>I installed the module by running the following from the directory with <code>MANIFEST.in</code>:</p>

<pre><code>python setup.py install
</code></pre>

<p>Then, from a totally different location on my filesystem <code>/moustache/armwrestle</code> I was able to run:</p>

<pre><code>import a
dir(a)
</code></pre>

<p>Which confirmed that <code>a.cats</code> indeed equalled 0 and <code>a.b.dogs</code> indeed equalled 1, as intended.</p>
------------------------------------------------------------------ <br><h3> Answer 64405877 Md Shafiul Islam: </h3><p><strong>This worked for me.</strong></p>
<p>Python adds the folder containing the script you launch to the PYTHONPATH, so if you run</p>
<pre class="lang-bash prettyprint-override"><code>python application/app2/some_folder/some_file.py
</code></pre>
<p>Only the folder application/app2/some_folder is added to the path (not the base directory that you're executing the command in). Instead, run your file as a module and add a __init__.py in your some_folder directory.</p>
<pre class="lang-bash prettyprint-override"><code>python -m application.app2.some_folder.some_file
</code></pre>
<p>This will add the base directory to the path to executable <code>python</code>, and then classes will be accessible via a non-relative import.</p>
------------------------------------------------------------------ <br><h3> Answer 72301427 Sergiusz: </h3><p>My solution for people who have all the necessary <code>__init__.py</code> in the package, but import still doesn't work.</p>
<pre><code>import sys
import os
sys.path.insert(0, os.getcwd())

import application.app.folder.file as file
</code></pre>
<h4> Comment 133704616 Jota: </h4>worked for me... but this should not be like this, python sometimes is complicated to understand...<br>------------------------------------------------------------------ <br><h3> Answer 63826803 Neinstein: </h3><p>The code below imports the Python script given by its path, no matter where it is located, in a Python version-safe way:</p>
<pre><code>def import_module_by_path(path):
    name = os.path.splitext(os.path.basename(path))[0]
    if sys.version_info[0] == 2:
        # Python 2
        import imp
        return imp.load_source(name, path)
    elif sys.version_info[:2] &lt;= (3, 4):
        # Python 3, version &lt;= 3.4
        from importlib.machinery import SourceFileLoader
        return SourceFileLoader(name, path).load_module()
    else:
        # Python 3, after 3.4
        import importlib.util
        spec = importlib.util.spec_from_file_location(name, path)
        mod = importlib.util.module_from_spec(spec)
        spec.loader.exec_module(mod)
        return mod
</code></pre>
<p>I found this in the codebase of <a href="https://pypi.org/project/psutil/" rel="nofollow noreferrer">psutils</a>, at line 1042 in <a href="https://github.com/giampaolo/psutil/blob/ee60bad610822a7f630c52922b4918e684ba7695/psutil/tests/__init__.py" rel="nofollow noreferrer"><code>psutils.test.__init__.py</code></a> (<em>most recent commit as of 09.10.2020</em>).</p>
<p>Usage example:</p>
<pre><code>script = &quot;/home/username/Documents/some_script.py&quot;
some_module = import_module_by_path(script)
print(some_module.foo())
</code></pre>
<p><strong>Important caveat: The module will be treated as top-level; any relative imports from parent packages in it will fail.</strong></p>
<h4> Comment 119780172 Jon: </h4>Any idea why the two different Python3 methods? I tried both on Python 3.6, and they both worked, and returned identical results<br><h4> Comment 119780456 Jon: </h4>Also identical results on python 3.8.9. Starting with 3.8.10 and later, the <code>spec_from_file_location</code> starts saving the root path of the file (if a relative path given) in the <b>loader</b> object, but otherwise the data returned is identical. Also tested with python 3.10 -- exact same behavior as 3.8.10. Both methods work just fine.<br><h4> Comment 119785180 Neinstein: </h4>@Jon Unfortunately I can&#39;t comment on these, I&#39;m not familiar with the nuances of importlib. This is found property, and I didn&#39;t want to change anything - figured they had a reason for it. Maybe there&#39;s some nuance that is different, or that breaks for older/newer versions.<br>------------------------------------------------------------------ <br><h3> Answer 72230506 Adilet Usonov: </h3><h2>This problem may be due to <a href="https://en.wikipedia.org/wiki/JetBrains#IDEs" rel="nofollow noreferrer">PyCharm</a></h2>
<p>I had the same problem while using PyCharm. I had this project structure</p>
<pre><code>skylake\
   backend\
      apps\
          example.py
      configuration\
          settings.py
   frontend\
      ...some_stuff
</code></pre>
<p>and code <code>from configuration import settings</code> in <em>example.py</em> raised an import error.</p>
<p>The problem was that when I opened PyCharm, it considered that <em>skylake</em> is the root path and ran this code.</p>
<pre><code>sys.path.extend(['D:\\projects\\skylake', 'D:/projects/skylake'])
</code></pre>
<p>To fix this I just marked backend directory as the source root.</p>
<p><a href="https://i.stack.imgur.com/6yaVi.png" rel="nofollow noreferrer"><img src="https://i.stack.imgur.com/6yaVi.png" alt="Enter image description here" /></a></p>
<p>And it's fixed my problem.</p>
<h4> Comment 133819753 Peter Mortensen: </h4>&#39;skylake&#39; is not to be confused with <a href="https://en.wikipedia.org/wiki/Skylake_(microarchitecture)" rel="nofollow noreferrer">Skylake</a>.<br><h4> Comment 134005745 Adilet Usonov: </h4>@PeterMortensen bro, you fixed every answer I see  ಠ﹏ಠ<br>------------------------------------------------------------------ <br><h3> Answer 57133053 Dextron: </h3><p>You can use importlib to import modules where you want to import a module from a folder using a string like so:</p>

<pre><code>import importlib

scriptName = 'Snake'

script = importlib.import_module('Scripts\\.%s' % scriptName)
</code></pre>

<p>This example has a main.py which is the above code then a folder called Scripts and then you can call whatever you need from this folder by changing the <code>scriptName</code> variable. You can then use <code>script</code> to reference to this module. such as if I have a function called <code>Hello()</code> in the Snake module you can run this function by doing so:</p>

<pre><code>script.Hello()
</code></pre>

<p>I have tested this in Python 3.6</p>
------------------------------------------------------------------ <br><h3> Answer 62685074 picmate 涅: </h3><p>I usually create a symlink to the module I want to import. The symlink makes sure Python interpreter can locate the module inside the current directory (the script you are importing the other module into); later on when your work is over, you can remove the symlink. Also, you should ignore symlinks in .gitignore, so that, you wouldn't accidentally commit symlinked modules to your repo. This approach lets you even successfully work with modules that are located parallel to the script you are executing.</p>
<pre><code>ln -s ~/path/to/original/module/my_module ~/symlink/inside/the/destination/directory/my_module
</code></pre>
------------------------------------------------------------------ <br><h3> Answer 74829320 KSHMR: </h3><p>You can use <code>pip</code>'s <code>pip install -e .</code> command. You must create a file called <code>setup.py</code> in the root of the project's directory which contains the following:</p>
<pre><code>from setuptools import find_packages, setup

setup(
    name='src',
    packages=find_packages(),
    version='0.1.0',
    description='my_project',
    author='author',
    license='MIT',
)
</code></pre>
<p>Afterwards, enter <code>pip install -e .</code> while in your project's root directory. This will enable all directories to be called with their name as a module. For example, if your root directory contains the subdirectories <code>module1</code> and <code>module2</code>, each with scripts inside them, you will be able to access them from any subdirectories with the following command, for <code>module1</code>:</p>
<p><code>import module1.script1 as script1</code></p>
------------------------------------------------------------------ <br><h3> Answer 76274034 helloworld: </h3><p>There are many awesome answers, but I think it is import to note the <code>PATHONPATH</code>.
(Below is excerpted from various online resource. Credit to Internet!)</p>
<p>If you have a function in a Python file in another directory, you can still import it by modifying the Python import path or using a relative import.</p>
<p>Here's how you can do it:</p>
<p>Let's assume you have the following directory structure:</p>
<pre><code>my_project/
│
├── main.py
│
└── my_module/
    ├── __init__.py
    └── my_functions.py
</code></pre>
<p>Your <code>my_functions.py</code> defined a function named <code>my_function</code> and you want to use it in <code>main.py</code>.</p>
<p>Here is how you can do it:</p>
<pre><code>from my_module.my_functions import my_function

my_function()  # Outputs: Hello, World!
</code></pre>
<p>This assumes that <code>my_project</code> is in your Python path. If you're running <code>main.py</code> from the <code>my_project</code> directory, then Python will add <code>my_project</code> to the Python path automatically and it should be able to find <code>my_module</code>.</p>
<p>If <code>my_project</code> is not in your Python path, you must add it manually at the start of <code>main.py</code>:</p>
<pre><code>import sys
sys.path.insert(0, '/path/to/my_project')

from my_module.my_functions import my_function

my_function()  # Outputs: Hello, World!
</code></pre>
<p>Replace <code>'/path/to/my_project'</code> with the actual path to <code>my_project</code>.</p>
<p>The <code>__init__.py</code> file in <code>my_module</code> is necessary for Python to recognize <code>my_module</code> as a package that can be imported. If <code>my_module</code> doesn't contain <code>__init__.py</code>, simply create an empty file with that name.</p>
<p>Above answers this question post:</p>
<blockquote>
<p>Importing files from different folder</p>
</blockquote>
<p>For additional reference, if one needs to import functions defined in different files in the same module, here is the example on how to import functions from one file to another file ( under the same module).</p>
<p>Suppose you have the following directory structure:</p>
<pre><code>src/
    __init__.py
    file1.py
    file2.py
</code></pre>
<p>Let's say <code>file1.py</code> contains a function <code>function1()</code>, and you want to use this function in <code>file2.py</code>.</p>
<p>In <code>file2.py</code>, you can import the function from <code>file1.py</code> using the following line:</p>
<pre><code>from .file1 import function1
</code></pre>
<p>You can then call <code>function1()</code> in <code>file2.py</code> as if it was defined in the same file.</p>
<p>The <code>.</code> before <code>file1</code> in the <code>import</code> statement is a <strong>relative import</strong>, which means &quot;import from the same package&quot;. In this case, it's saying &quot;import from the same directory&quot;.</p>
<p>Note: This will only work if <strong>your script is run as a module</strong> (i.e., using the <code>-m</code> flag with Python, like <code>python -m src.file2</code>), not if you run the Python file directly (<code>python file2.py</code>). If you're running the file directly and the other file is in the same directory, you can just do <code>from file1 import function1</code>.</p>
<p>If you are running the file directly and the import is not working, make sure your <code>src</code> folder (the root folder of this module) is in the Python path. The Python path is a list of directories that Python checks when it's looking for the module you're trying to import. You can add the <code>src</code> folder to the Python path by adding it to the <code>PYTHONPATH</code> environment variable, or by adding an empty file named <code>__init__.py</code> in your <code>src</code> directory to make it a package.</p>
------------------------------------------------------------------ <br><h3> Answer 45068315 IOstream: </h3><p>You can refresh the Python shell by pressing <kbd>F5</kbd>, or go to <em>Run</em> → <em>Run Module</em>. This way you don't have to change the directory to read something from the file. Python will automatically change the directory. But if you want to work with different files from different directory in the Python shell, then you can change the directory in <em>sys</em>, <a href="https://stackoverflow.com/a/4383597/3982001">as Cameron said</a> earlier.</p>
------------------------------------------------------------------ <br><h3> Answer 51549572 mithunpaul: </h3><p>So I had just right clicked on my IDE, and added a new <code>folder</code> and was wondering why I wasn't able to import from it. Later I realized I have to right click and create a Python Package, and not a classic file system folder. Or a post-mortem method being adding an <code>__init__.py</code> (which makes python treat the file system folder as a package) as mentioned in other answers. Adding this answer here just in case someone went this route.</p>
------------------------------------------------------------------ <br><h3> Answer 61808596 B Furtado: </h3><p>I've had these problems a number of times. I've come to this same page a lot. 
In my last problem I had to run the <code>server</code> from a fixed directory, but whenever debugging I wanted to run from different sub-directories. </p>

<pre><code>import sys
sys.insert(1, /path) 
</code></pre>

<p>did <strong>NOT</strong> work for me because at different modules I had to read different <strong>*.csv</strong> files which were all in the same directory.</p>

<p>In the end, what worked for me was not pythonic, I guess, but:</p>

<p>I used a <code>if __main__</code> <strong>on top of the module I wanted to debug</strong>, that is run from a different than usual path.</p>

<p>So:</p>

<pre><code># On top of the module, instead of on the bottom
import os
if __name__ == '__main__':
    os.chdir('/path/for/the/regularly/run/directory')
</code></pre>
------------------------------------------------------------------ <br><h3> Answer 63040187 kepy97: </h3><p>If you have multiple folders and sub folders, you can always import any class or module from the <strong>main directory</strong>.</p>
<p>For example: Tree structure of the project</p>
<pre><code>Project 
├── main.py
├── .gitignore
|
├── src
     ├────model
     |    └── user_model.py
     |────controller
          └── user_controller.py
</code></pre>
<p>Now, if you want to import <strong>&quot;UserModel&quot;</strong> class from user_model.py in <strong>main.py</strong> file, you can do that using:</p>
<pre><code>from src.model.user_model.py import UserModel
</code></pre>
<p>Also, you can import same class in <strong>user_controller.py</strong> file using same line:</p>
<pre><code>from src.model.user_model.py import UserModel
</code></pre>
<p>Overall, you can give reference of main project directory to import classes and files in any python file inside <strong>Project</strong> directory.</p>
<h4> Comment 117762663 Giacomo: </h4>This is not an answer to the original question which was NOT about how to import from main.py, but rather (following your example) from user_model.py to user_controller.py.<br><h4> Comment 115529442 Richie F.: </h4>do we need <code>__init__.py</code> under src to make this happen?<br>------------------------------------------------------------------ <br><h3> Answer 71803717 Daniel N.: </h3><p>In case you only want to run the script instead of actually importing it, the <a href="https://docs.python.org/3.8/library/functions.html#exec" rel="nofollow noreferrer">exec</a> command will do the work</p>
<pre><code>exec(open('/full/or/relative/path').read())
</code></pre>
<h4> Comment 133819704 Peter Mortensen: </h4><a href="https://stackoverflow.com/questions/9383740/what-does-pythons-eval-do/9384005#9384005">eval&#39;s</a> evil twin?<br><h4> Comment 130353953 Le Quang Nam: </h4>This is the most effective and simple solution.<br>------------------------------------------------------------------ <br><h3> Answer 75185135 winsett: </h3><p>Just in case anyone still needs a solution and hasn't found one in the answers above. This worked for me:</p>
<p>I have this folder structure:</p>
<pre><code>a
└── b
    ├── c1
    |   └── d
    |       └── a_script.py
    └── c2
        └── a_lib.py
</code></pre>
<p>And I needed the <code>a_lib.py</code> to be included in the <code>a_script.py</code>. This is how I resolved the error that <code>c2</code> is not recognized:</p>
<pre><code>import sys
from pathlib import Path
path_scripts = Path(__file__).resolve().parents[2]
sys.path.append(str(path_scripts))
from c2 import a_lib
</code></pre>
------------------------------------------------------------------ <br><h3> Answer 75673670 Nermin: </h3><h3>2023 Python 3.10+ solution</h3>
<p>Out of all the answers here, only <a href="https://stackoverflow.com/questions/4383571/importing-files-from-different-folder?page=1&amp;tab=createdasc#comment121347547_21995949">martin36's solution</a> hidden in the comments worked for me to enable relative imports.</p>
<pre><code>import sys
sys.path.append('')
</code></pre>
<p>(But using <em>append</em> instead of <em>insert</em>)</p>
<pre><code>from application.app.folder.file import func_name
</code></pre>
<h4> Comment 133760217 Karl Knechtel: </h4>I can guarantee you that nothing fundamentally has changed in Python in a very long time that would be relevant to this answer. I can also guarantee you that using 3.10 is not relevant to your problem, in particular. I can almost guarantee you that many other answers would have solved your problem. I can almost guarantee you that changing <code>sys.path</code> is not necessary for your situation - many of the largest and most important Python libraries, running hundreds of thousands of lines of code, do not use it. Also, what you show here is <b>not a relative import</b>.<br><h4> Comment 133820463 Peter Mortensen: </h4>Can you explain your answer, please? E.g, why and how does appending an empty string work? Please respond by <a href="https://XXXX" rel="nofollow noreferrer">editing (changing) your answer</a>, not here in comments (**** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** <b><i>without</i></b> **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** &quot;Edit:&quot;, &quot;Update:&quot;, or similar - the answer should appear as if it was written today).<br><h4> Comment 133820571 Peter Mortensen: </h4>Does it <i>only</i> work in Python 3.10 (and later)? Or was it only tested with Python 3.10? <code>sys.path.append(&#39;&#39;)</code> itself executes without error in Python 3.6.9.<br><h4> Comment 133820709 Peter Mortensen: </h4>OK, <i><a href="https://stackoverflow.com/questions/49559003/why-is-the-first-element-in-pythons-sys-path-an-empty-string">Why is the first element in Python&#39;s sys.path an empty string?</a></i><br><h4> Comment 133820730 Peter Mortensen: </h4>If the first element is an empty string, what difference does it make to append an empty string at the end? For instance, is there a Python version dependence? Did they remove the empty string at the beginning in later versions of Python?<br><h4> Comment 133820813 Peter Mortensen: </h4>After the append operation on Python 3.6.9, example content of sys.path is: <code>[&#39;&#39;, &#39;&#47;usr&#47;lib&#47;python36.zip&#39;, &#39;&#47;usr&#47;lib&#47;python3.6&#39;, &#39;&#47;usr&#47;lib&#47;python3.6&#47;lib-dynload&#39;, &#39;&#47;home&#47;mortensen&#47;.local&#47;lib&#47;python3.6&#47;site-packages&#39;, &#39;&#47;usr&#47;local&#47;lib&#47;python3.6&#47;dist-packages&#39;, &#39;&#47;usr&#47;lib&#47;python3&#47;dist-packages&#39;, &#39;&#39;]</code><br><h4> Comment 133821074 Peter Mortensen: </h4>OK, only in the REPL (or if read from <a href="https://en.wikipedia.org/wiki/Standard_streams#Standard_input_(stdin)" rel="nofollow noreferrer">standard input</a>).<br><h4> Comment 133821212 Peter Mortensen: </h4><i><a href="https://docs.python.org/3/library/sys_path_init.html" rel="nofollow noreferrer">The initialization of the sys.path module search path</a></i><br><h4> Comment 133822165 Peter Mortensen: </h4><i>insert</i> is also used in <a href="https://stackoverflow.com/questions/72852/how-can-i-do-relative-imports-in-python">this answer</a> (though not with the same parameter).<br>------------------------------------------------------------------ <br><h3> Answer 77407752 Markus Hirsim&#228;ki: </h3><p>There is plenty of other solution already but here is my two cents. Let's say you don't want to do any of these:</p>
<ul>
<li>add <code>__init__.py</code> files</li>
<li>run with python -m mymodule</li>
<li>edit  <code>__package__</code></li>
<li>add <code>if</code> check in <code>__main__</code></li>
<li>edit <code>sys.path</code> by hand</li>
<li>edit <code>PYTHONPATH</code></li>
<li>restructure the project</li>
</ul>
<p>You can instead use a tool that will that will add a given absolute/relative path to sys.path while making sure the path is valid and in the correct format.</p>
<p><code>$ pip install importmonkey</code> [<a href="https://github.com/hirsimaki-markus/importmonkey" rel="nofollow noreferrer">github</a>] [<a href="https://pypi.org/project/importmonkey/" rel="nofollow noreferrer">pip</a>]</p>
<pre><code># Example structure
├─ src
│   └─ project
│       ├─ __init__.py
│       └─ module.py
└─ test
    └─ test.py
</code></pre>
<pre class="lang-py prettyprint-override"><code># Example solution using the tool, in test.py

from importmonkey import add_path
add_path(&quot;../src&quot;)  # relative to current __file__
import project

# You can add as many paths as needed, absolute or relative, in any file.
# Relative paths start from the current __file__ directory.
# Normal unix path conventions work so you can use '..' and '.' and so on.
# The paths you try to add are checked for validity etc. help(add_path) for details.

</code></pre>
<p>Disclosure of affiliation: I made importmonkey.</p>
------------------------------------------------------------------ <br><h3> Answer 63798655 Mustafa Kareem: </h3><p>Just use the change directory function from the <em>os</em> module:</p>
<pre><code>os.chdir(&quot;Here new director&quot;)
</code></pre>
<p>Then you can import normally.</p>
<p><a href="https://python101.pythonlibrary.org/chapter16_os.html#os-chdir-and-os-getcwd" rel="nofollow noreferrer">More information</a></p>
