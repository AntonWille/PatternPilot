 <h2> Title: How do I use boolean variables in Perl? </h2> <h4> Chad DeShon, question_id: 1036347, created_at: 2009-06-24 04:08:11+00:00 </h4>Score: 244, Tags: {perl,boolean} <br><p>I have tried:</p>

<pre><code>$var = false;
$var = FALSE;
$var = False;
</code></pre>

<p>None of these work. I get the error message</p>

<pre>Bareword "false" not allowed while "strict subs" is in use.</pre>
<h4> Comment by brian d foy, Score: 42, Id: 850448, created_at: 2009-06-24 17:30:05+00:00 </h4>You might want to start with my book <i>Learning Perl</i>. It&#39;s easier than guessing what to do until you get it right (monkeys, typewriters, and Hamlet, and all that). :)<h4> Comment by brian d foy, Score: 0, Id: 136471433, created_at: 2023-11-02 16:46:34+00:00 </h4>Over a decade later, Perl gets <code>true</code> and <code>false</code> &quot;distinguished booleans&quot; through the new <a href="https://perldoc.perl.org/builtin" rel="nofollow noreferrer"><code>builtin</code> package</a><hr><h3> ‚úîÔ∏è Answer by Alan Haggai Alavi, Id: 1036353, Score: 306, created_at: 2009-06-24 04:10:16+00:00 </h3><p><strong>Truth and Falsehood</strong> in <code>man perlsyn</code> explains:</p>
<blockquote>
<p>The number 0, the strings '0' and &quot;&quot;, the empty list &quot;()&quot;, and &quot;undef&quot; are all false in a boolean context.  All other values are true.</p>
</blockquote>
<p>In Perl, the following evaluate to false in conditionals:</p>
<pre><code>0
'0'
undef
''  # Empty scalar
()  # Empty list
('')
</code></pre>
<p>The rest are true. There are no barewords for <code>true</code> or <code>false</code>. (Note: Perl v5.38 introduced <code>true</code> and <code>false</code> through the new <a href="https://perldoc.perl.org/builtin" rel="nofollow noreferrer">builtin</a> pragma).</p>
<h4> Comment by ikegami, Score: 16, Id: 13297904, created_at: 2012-04-26 05:00:08+00:00 </h4>@eternicode, Perl does have two specific value it uses when it needs to return true and false, so not only does it have booleans, it has true (<code>!0</code> aka <code>PL_sv_yes</code>) and false (<code>!1</code> aka <code>PL_sv_no</code>). Or are you saying Perl should croak whenever something other than these two values are tested for truthness? That would be completely awful. e.g. It would prevent <code>$x ||= $default;</code><h4> Comment by ikegami, Score: 11, Id: 6450821, created_at: 2011-04-13 20:40:15+00:00 </h4>Problem 1: An empty list is not false, since it&#39;s impossible to check if an list is true or false. An empty list in scalar context returns <code>undef</code>.<h4> Comment by ikegami, Score: 6, Id: 6450859, created_at: 2011-04-13 20:43:00+00:00 </h4>Problem 3: Objects with an overloaded boolean operator can also be false.<h4> Comment by ikegami, Score: 5, Id: 6450847, created_at: 2011-04-13 20:42:04+00:00 </h4>Problem 2: <code>(&#39;&#39;)</code> and <code>&#39;&#39;</code> are the same value. I think you wanted to imply a list with an element that consists of an empty string (even though parens don&#39;t create lists), but as I&#39;ve already mentioned, it&#39;s impossible to check if a list is true of false.<h4> Comment by ikegami, Score: 2, Id: 91728998, created_at: 2018-09-18 17:43:38+00:00 </h4>@abhi divekar, It&#39;s not used an optimization; it&#39;s used because it&#39;s far simpler and clearer. Consider what happens when you have a multitude of initializations, or if you&#39;re in the middle of a larger statement (e.g. <code>f({ foo =&gt; $foo &#47;&#47; &quot;foo&quot;, ... })</code>). And it&#39;s positively invaluable when the LHS is complex or has side effects (e.g. <code>f( something_long_or_expensive() &#47;&#47; something_else() );</code>). The savings in complexity are <i>incredible</i>. It literally cuts the length of programs by a third. Even if you had to spend 20 minutes <i>once</i> to learn this, it&#39;s worth it.<h4> Comment by Matthew Lock, Score: 2, Id: 27096408, created_at: 2013-08-26 09:49:54+00:00 </h4>It&#39;s about time perl had the keywords true and false in it though. It only adds to the confusion when learning perl or switching between languages like I do a lot. I guess there&#39;s this <a href="http://search.cpan.org/dist/Keyword-Boolean-0.001/lib/Keyword/Boolean.pm" rel="nofollow noreferrer">search.cpan.org/dist/Keyword-Boolean-0.001/lib/Keyword/&hellip;</a> but I&#39;m too lazy to install it. While I&#39;m ranting how about &quot;elseif&quot;, &quot;if statement&quot; on a single line without having to have braces and so on!<h4> Comment by user118435, Score: 2, Id: 847455, created_at: 2009-06-24 06:47:20+00:00 </h4>@BlueWaldo: you can also use cmp and &lt;=&gt; when comparing and assigning the results of the comparison to a scalar.  $var = $var1 cmp $var2;  &#39;cmp&#39; and &#39;&lt;=&gt;&#39; (used for numeric comparisons) returns -1, 0, or 1 if left argument is less than, equal to, or greater than the right argument. Its not boolean but sometimes you may want to know if one argument ir equal or less than or greater than the other instead of just equal or not equal.<h4> Comment by Chad DeShon, Score: 1, Id: 847103, created_at: 2009-06-24 04:15:38+00:00 </h4>Are you allowed to do the following in Perl?  $var = ( $var1 eq $var2 );  This is done all the time in C. How does this work in Perl?<h4> Comment by C. K. Young, Score: 1, Id: 847105, created_at: 2009-06-24 04:16:21+00:00 </h4>@BlueWaldo: Yes, that works. $var will (IIRC) be either 0 or 1, in this case.<h4> Comment by C. K. Young, Score: 1, Id: 848796, created_at: 2009-06-24 12:48:41+00:00 </h4>@kevinadc: That &quot;sometimes&quot; is usually in the comparator of a sort invocation. :-)<h4> Comment by xenoterracide, Score: 1, Id: 2789068, created_at: 2010-05-03 11:17:24+00:00 </h4>there aren&#39;t any barewords but there is the boolean module on cpan which adds them and can make code more readable imo.<h4> Comment by fishinear, Score: 1, Id: 92986102, created_at: 2018-10-29 10:25:18+00:00 </h4>@abhidivekar An idiom like <code>$x ||= $default;</code> is extremely useful, and saves a lot of maintainer time once you are familiar with it. It is clear in one glance what is intended, and saves time that would otherwise be spend on understanding confusing nested if statements.<h4> Comment by Kaoru, Score: 0, Id: 37127290, created_at: 2014-06-06 06:29:53+00:00 </h4>You missed <code>0.0</code> (not <code>&quot;0.0&quot;</code> which is true.) Devel::Peek shows that <code>0</code> is <code>SVIV = 0</code> and <code>0.0</code> is <code>SVNV = 0</code> so they are slightly different values, both false.<h4> Comment by jrw32982, Score: 0, Id: 98510533, created_at: 2019-04-30 20:47:46+00:00 </h4>@ikegami @fishinear except that what is usually meant is <code>$x &#47;&#47;= $default</code> (give <code>$x</code> a default value if it is <code>undef</code>).  <code>$x ||= $default</code> means give <code>$x</code> a default value if its current value is &quot;false&quot;, which is something completely different.  Unfortunately the defined-or operator was introduced only in 5.10 and some servers still are running 5.8.<h4> Comment by SGeorgiades, Score: 0, Id: 86249461, created_at: 2018-04-03 02:19:30+00:00 </h4>You can install the &quot;boolean&quot; package from CPAN, and then put the following in your code: <code>use boolean qw(true false);</code>  You will now have the &quot;barewords&quot; true and false defined.<h4> Comment by Abhishek Divekar, Score: 0, Id: 91719430, created_at: 2018-09-18 13:15:27+00:00 </h4>@ikegami <code>$x ||= $default;</code> looks pretty evil to me. It&#39;s one of those &#39;micro-optimizations&#39; which saves 5 seconds of developer time and requires 20 minutes of maintainer time to comprehend.<h4> Comment by RealDeal_EE&#39;18, Score: 0, Id: 28283988, created_at: 2013-10-01 21:15:25+00:00 </h4>It doesn&#39;t need booleans for binary logic (&#39;i.e. one or the other&#39;). Signals are interpolated to be either a logical high or a logical low. @eternicode<h4> Comment by Robert Harvey, Score: 0, Id: 847093, created_at: 2009-06-24 04:13:02+00:00 </h4>Is the correct comparison, then, a comparison with zero, as in $var=0 ?<h4> Comment by C. K. Young, Score: 0, Id: 847098, created_at: 2009-06-24 04:14:31+00:00 </h4>No. 1. = is not comparison, it&#39;s assignment. 2. Do &quot;if ($var) {...}&quot;.<hr><h3>  Answer by ikegami, Id: 5655485, Score: 77, created_at: 2011-04-13 20:53:15+00:00 </h3><p>Since 5.36, you can use <code>true</code> and <code>false</code> from the <a href="https://perldoc.perl.org/builtin" rel="nofollow noreferrer">builtin</a> module/namespace. These are special true and false values that can be identified using <code>is_bool</code>. This is an experimental feature at this time.</p>
<p>But while these could be said to return <em>the</em> true and false, they are are but <em>a</em> true or false value respectively. In fact, every scalar is either true or false.</p>
<p>The most complete, concise definition of <em>a false value</em> I've come across is:</p>
<blockquote>
<p>Anything that stringifies to the empty string or the string <code>0</code> is false. Everything else is true.</p>
</blockquote>
<p>Therefore, the following values are false:</p>
<ul>
<li>The empty string.</li>
<li>The string <code>0</code>.</li>
<li>A signed integer with value zero.</li>
<li>An unsigned integer with value zero.</li>
<li>A floating point number with value positive zero.</li>
<li>A floating point number with value negative zero.</li>
<li>An undefined value.</li>
<li>An object with an overloaded boolean operator that evaluates one of the above.</li>
<li>A magical variable that evaluates to one of the above on fetch.</li>
</ul>
<p>Any other scalar is true.</p>
<hr />
<p><strong>A note on &quot;true zeroes&quot;</strong></p>
<p>While numbers that stringify to <code>0</code> are false, strings that numify to zero aren't necessarily. The only false strings are <code>0</code> and the empty string. Any other string, even if it numifies to zero, is true.</p>
<p>The following are strings that are true as a boolean and zero as a number:</p>
<ul>
<li>Without a warning:
<ul>
<li><code>&quot;0.0&quot;</code></li>
<li><code>&quot;0E0&quot;</code></li>
<li><code>&quot;00&quot;</code></li>
<li><code>&quot;+0&quot;</code></li>
<li><code>&quot;-0&quot;</code></li>
<li><code>&quot; 0&quot;</code></li>
<li><code>&quot;0\n&quot;</code></li>
<li><code>&quot;.0&quot;</code></li>
<li><code>&quot;0.&quot;</code></li>
<li><code>&quot;0 but true&quot;</code></li>
<li><code>&quot;\t00&quot;</code></li>
<li><code>&quot;\n0e1&quot;</code></li>
<li><code>&quot;+0.e-9&quot;</code></li>
</ul>
</li>
<li>With a warning:
<ul>
<li>Any string for which <code>Scalar::Util::looks_like_number</code> returns false. (e.g. <code>&quot;abc&quot;</code>)</li>
</ul>
</li>
</ul>
<h4> Comment by tobyink, Score: 2, Id: 33375693, created_at: 2014-02-25 15:17:44+00:00 </h4>Your &quot;concise&quot; definition is inconsistent with your longer explanation. Consider: <code>my $value = do { package XXX; use overload q[&quot;&quot;] =&gt; sub { &quot;XXX&quot; }, q[bool] =&gt; sub { 0 }; bless [] };</code>. Now <code>$value</code> will stringify to &quot;XXX&quot; but boolifies to false.<h4> Comment by ikegami, Score: 1, Id: 95927732, created_at: 2019-02-07 00:05:26+00:00 </h4>@Grinn, A list assignment in scalar context evaluates to the number of scalars to which its RHS evaluates. (See <a href="https://stackoverflow.com/q/54564428/589924">Scalar vs List Assignment Operator</a> for details.) If the sub returns nothing, the assignment will evaluate to 0, which is false. If the sub returns at least one scalar, the assignment will evaluate to a positive number, which is true.<h4> Comment by ikegami, Score: 1, Id: 33376354, created_at: 2014-02-25 15:30:55+00:00 </h4>@tobyink, The concise version isn&#39;t perfect, merely the best I&#39;ve found. It&#39;s meant to be practical, not all-encompassing. Do note that value returned by your <code>bool</code> does stringify to <code>0</code>. Also, you are discouraged from creating inconsistent overloads, and the values you return could be considered such. (e.g. a <code>&amp;&amp;</code> can be optimized into a <code>||</code>, so if these were inconsistent, you&#39;d have a problem.)<h4> Comment by Zaid, Score: 0, Id: 33390301, created_at: 2014-02-25 21:03:03+00:00 </h4>I&#39;m not sure if <code>0x00</code> is covered here.<h4> Comment by d.k, Score: 0, Id: 27208142, created_at: 2013-08-29 07:53:45+00:00 </h4>if I understood you right the word <b>true</b> in <i>While numbers that stringify to 0 are true</i> should be <b>false</b> or (to prevent confusion) <b>evaluate to false</b>.<h4> Comment by ikegami, Score: 0, Id: 54124941, created_at: 2015-10-15 20:34:45+00:00 </h4>@Zaid, Do you mean the value returned by the code <code>0x00</code> (the numerical value zero) or the string <code>0x00</code> (for which <code>looks_like_number</code> is false)? Either way, it&#39;s already covered.<h4> Comment by temporary_user_name, Score: 0, Id: 75200873, created_at: 2017-05-20 18:46:15+00:00 </h4>@ikegami so is it standard practice in perl to use <code>0</code>/<code>1</code> as boolean values, as in <code>$feature_enabled = 1;</code> ?<h4> Comment by ikegami, Score: 0, Id: 75200909, created_at: 2017-05-20 18:48:31+00:00 </h4>@Aerovistae, That&#39;s probably the most common choice, yes. <code>undef</code> is another common false value, but I&#39;d use <code>0</code> for a flag.<h4> Comment by Grinnz, Score: 0, Id: 95924930, created_at: 2019-02-06 21:44:51+00:00 </h4>Can you explain what part of your definition applies to <code>if (() = sub_returning_list)</code> evaluating as true if the sub returns list items, even if they are false?<hr><h3>  Answer by James Thompson, Id: 1036866, Score: 63, created_at: 2009-06-24 07:24:29+00:00 </h3><p>Perl doesn't have a native boolean type, but you can use comparison of integers or strings in order to get the same behavior. Alan's example is a nice way of doing that using comparison of integers. Here's an example</p>

<pre><code>my $boolean = 0;
if ( $boolean ) {
    print "$boolean evaluates to true\n";
} else {
    print "$boolean evaluates to false\n";
}
</code></pre>

<p>One thing that I've done in some of my programs is added the same behavior using a constant:</p>

<pre><code>#!/usr/bin/perl

use strict;
use warnings;

use constant false =&gt; 0;
use constant true  =&gt; 1;

my $val1 = true;
my $val2 = false;

print $val1, " &amp;&amp; ", $val2;
if ( $val1 &amp;&amp; $val2 ) {
    print " evaluates to true.\n";
} else {
    print " evaluates to false.\n";
}

print $val1, " || ", $val2;
if ( $val1 || $val2 ) {
    print " evaluates to true.\n";
} else {
    print " evaluates to false.\n";
}
</code></pre>

<p>The lines marked in "use constant" define a constant named true that always evaluates to 1, and a constant named false that always evaluates by 0. Because of the way that constants are defined in Perl, the following lines of code fails as well:</p>

<pre><code>true = 0;
true = false;
</code></pre>

<p>The error message should say something like "Can't modify constant in scalar assignment."</p>

<p>I saw that in one of the comments you asked about comparing strings. You should know that because Perl combines strings and numeric types in scalar variables, you have different syntax for comparing strings and numbers:</p>

<pre><code>my $var1 = "5.0";
my $var2 = "5";

print "using operator eq\n";
if ( $var1 eq $var2 ) {
    print "$var1 and $var2 are equal!\n";
} else {
    print "$var1 and $var2 are not equal!\n";
}

print "using operator ==\n";
if ( $var1 == $var2 ) {
    print "$var1 and $var2 are equal!\n";
} else {
    print "$var1 and $var2 are not equal!\n";
}
</code></pre>

<p>The difference between these operators is a very common source of confusion in Perl.</p>
<h4> Comment by Zano, Score: 11, Id: 1652196, created_at: 2009-11-20 01:59:16+00:00 </h4>Using constants as a poor mans macros that way is dangerous. These code examples aren&#39;t equivalent: <code>if ($exitstatus) { exit; }</code> vs <code>if ($exitstatus == true) { exit; }</code>, which might not be obvious to a casual observer. (And yes, the last example is poor programming style, but that is beside the point).<h4> Comment by Brad Gilbert, Score: 6, Id: 850429, created_at: 2009-06-24 17:25:19+00:00 </h4><code>use warnings;</code> instead of <code>#! perl -w</code><hr><h3>  Answer by xenoterracide, Id: 2757625, Score: 16, created_at: 2010-05-03 11:16:18+00:00 </h3><p>I recommend <code>use boolean;</code>. You have to install the <a href="http://search.cpan.org/dist/boolean/lib/boolean.pm" rel="noreferrer">boolean</a> module from cpan though.</p>
<h4> Comment by tjd, Score: 8, Id: 43063314, created_at: 2014-12-04 17:02:55+00:00 </h4>In Perl, as in life, there are many truths.  The inexperienced like to write silly things like <code>if ($my_true_value == true)</code>.  Pretending that there is One True Truth is, in my experience, a path to pain, and inefficient code.<h4> Comment by ILMostro_7, Score: 2, Id: 55791333, created_at: 2015-12-01 10:26:30+00:00 </h4>Perl is philosophical by nature<hr><h3>  Answer by syck, Id: 33013894, Score: 16, created_at: 2015-10-08 11:00:17+00:00 </h3><p>My favourites have always been</p>

<pre><code>use constant FALSE =&gt; 1==0;
use constant TRUE =&gt; not FALSE;
</code></pre>

<p>which is completely independent from the internal representation.</p>
<h4> Comment by Nostalg.io, Score: 6, Id: 79906648, created_at: 2017-09-28 18:15:26+00:00 </h4>Brilliant. You single-handedly fixed the Perl programming language!<hr><h3>  Answer by serenesat, Id: 29605910, Score: 9, created_at: 2015-04-13 12:56:37+00:00 </h3><p>I came across a <a href="http://perlmaven.com/boolean-values-in-perl">tutorial</a> which have a well explaination about <strong>What values are true and false in Perl</strong>. It state that:</p>

<p>Following scalar values are considered false:</p>

<ul>
<li><code>undef</code> - the undefined value</li>
<li><code>0</code> the number 0, even if you write it as 000 or 0.0</li>
<li><code>''</code> the empty string.</li>
<li><code>'0'</code> the string that contains a single 0 digit.</li>
</ul>

<p>All other scalar values, including the following are true:</p>

<ul>
<li><code>1</code> any non-0 number</li>
<li><code>' '</code> the string with a space in it</li>
<li><code>'00'</code> two or more 0 characters in a string</li>
<li><code>"0\n"</code> a 0 followed by a newline</li>
<li><code>'true'</code></li>
<li><code>'false'</code> yes, even the string 'false' evaluates to true.</li>
</ul>

<p>There is another good tutorial which explain about <a href="http://alvinalexander.com/blog/post/perl/what-values-true-false-perl-if-then-boolean">Perl true and false</a>.</p>
<hr><h3>  Answer by Bharat Pahalwani, Id: 20241312, Score: 7, created_at: 2013-11-27 11:32:16+00:00 </h3><p>Beautiful explanation given by <a href="http://www.perlmonks.org/?node_id=375665" rel="noreferrer">bobf</a> for Boolean values :  <a href="http://www.perlmonks.org/?node_id=495975" rel="noreferrer">True or False? A Quick Reference Guide</a></p>

<p>Truth tests for different values    </p>

<pre><code>                       Result of the expression when $var is:

Expression          | 1      | '0.0'  | a string | 0     | empty str | undef
--------------------+--------+--------+----------+-------+-----------+-------
if( $var )          | true   | true   | true     | false | false     | false
if( defined $var )  | true   | true   | true     | true  | true      | false
if( $var eq '' )    | false  | false  | false    | false | true      | true
if( $var == 0 )     | false  | true   | true     | true  | true      | true
</code></pre>
<h4> Comment by ILMostro_7, Score: 1, Id: 55791449, created_at: 2015-12-01 10:30:30+00:00 </h4>Poor answer, but a strong, reputable source in perlmonks.org.  It would be nice to have some real <b>content</b> instead of a comment and a link. :-/<hr><h3>  Answer by user257319, Id: 21135349, Score: 1, created_at: 2014-01-15 10:48:28+00:00 </h3><p>use the following file prefix, this will add to your perl script eTRUE and eFALSE, it will actually be REAL(!) true and false (just like java)</p>

<pre><code>#!/usr/bin/perl
use strict;
use warnings;

use constant { #real true false, compatible with encode_json decode_json for later (we don't want field:false... will be field:0...)
                eTRUE  =&gt;  bless( do{\(my $o = 1)}, 'JSON::PP::Boolean' ),
                eFALSE =&gt;  bless( do{\(my $o = 0)}, 'JSON::PP::Boolean' )
             };
</code></pre>

<p>There are, actually, few reasons why you should use that.</p>

<p>My reason is that working with JSON, I've got 0 and 1 as values to keys, but this hack will make sure correct values are kept along your script.</p>
<hr><h3>  Answer by brian d foy, Id: 77411449, Score: 1, created_at: 2023-11-02 16:45:26+00:00 </h3><p>Perl v5.38 introduced experimental &quot;distinguished booleans&quot; through the new <a href="https://perldoc.perl.org/builtin" rel="nofollow noreferrer">builtin</a> pragma. This means that you now have the <code>true</code> or <code>false</code> that you wanted.</p>
<pre><code>use v5.38;
use experimental qw(builtin);
use builtin qw(true false);

my $var = false;
</code></pre>
<hr><h3>  Answer by jubilatious1, Id: 69148259, Score: -3, created_at: 2021-09-12 03:37:27+00:00 </h3><p><strong>Booleans in Raku (the programming language formerly known as Perl_6):</strong></p>
<pre><code>~$ raku
Welcome to ùêëùêöùê§ùêÆùêùùê®‚Ñ¢ v2021.06.
Implementing the ùêëùêöùê§ùêÆ‚Ñ¢ programming language v6.d.
Built on MoarVM version 2021.06.

To exit type 'exit' or '^D'

&gt; my $var = False;
False
&gt; say $var;
False

&gt; say $var.^name
Bool
&gt; say $var.WHAT
(Bool)

&gt; say ++$var
True
&gt; say --$var
False

&gt; say $var.Int
0
&gt; say $var.Int + 1
1
&gt; say ($var.Int + 1).Bool
True
&gt; say $var.Int - 1
-1
&gt; say ($var.Int - 1).Bool
True

&gt; say $var.succ
True
&gt; say $var.Int.succ
1
&gt; say $var.pred
False
&gt; say $var.Int.pred
-1

&gt; say ++($var.Int); #ERROR
Cannot resolve caller prefix:&lt;++&gt;(Int:D); the following candidates
match the type but require mutable arguments:
    (Mu:D $a is rw)
    (Int:D $a is rw --&gt; Int:D)
    #&lt;SNIP&gt;    
&gt; say --($var.Int); #ERROR
Cannot resolve caller prefix:&lt;--&gt;(Int:D); the following candidates
match the type but require mutable arguments:
    (Mu:D $a is rw)
    (Int:D $a is rw --&gt; Int:D)
    #&lt;SNIP&gt;

&gt; exit
</code></pre>
<p><a href="https://docs.raku.org/type/Bool" rel="nofollow noreferrer">https://docs.raku.org/type/Bool</a><br />
<a href="https://docs.raku.org/language/syntax#index-entry-Boolean_(literals)" rel="nofollow noreferrer">https://docs.raku.org/language/syntax#index-entry-Boolean_(literals)</a></p>
