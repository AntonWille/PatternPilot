 <h2> Title: Iterating over dictionaries using &#39;for&#39; loops </h2> <h4> TopChef, question_id: 3294889 </h4>Score: 4266, Tags: {python,dictionary} <br><pre class="lang-py prettyprint-override"><code>d = {'x': 1, 'y': 2, 'z': 3}

for key in d:
    print(key, 'corresponds to', d[key])
</code></pre>
<p>How does Python recognize that it needs only to read the <code>key</code> from the dictionary? Is <code>key</code> a special keyword, or is it simply a variable?</p>
<h4> Charlie Parker, Id: 117844974 Score: 12: </h4>did you try: <code>for key, value in d.items():</code>?<br><h4> Siva Sankar, Id: 129288802 Score: 0: </h4>Keys are immutable data types. Keys are unique.<br><h4> Karl Knechtel, Id: 129481289 Score: 0: </h4>&quot;Is key a special keyword, or is it simply a variable?&quot; There are no such &quot;special keywords&quot; for <code>for</code> loop syntax. See <a href="/q19257862">Understanding for loops in Python</a>.<br><h4> Raksha Saini, Id: 116072226 Score: 0: </h4>As we know that in Python Dictionary as a set of key: value pairs, with the requirement that the keys are unique (within one dictionary). A pair of braces creates an empty dictionary: {}. Placing a comma-separated list of key:value pairs within the braces adds initial key:value pairs to the dictionary. No, key is not a special word in Python. Here key is Just a variable name.<br>------------------------------------------------------------------ <br><h3> Alexander Gessler, Id: 3294897, Score: 123: </h3><p>When you iterate through dictionaries using the <code>for .. in ..</code>-syntax, it always iterates over the keys (the values are accessible using <code>dictionary[key]</code>).</p>
<p>To iterate over key-value pairs, use the following:</p>
<ul>
<li><code>for k,v in dict.iteritems()</code> in Python 2</li>
<li><code>for k,v in dict.items()</code> in Python 3</li>
</ul>
<h4> Andreas Fester, Comment 46753073 Score: 54: </h4>Note that for Python 3, it is <code>items()</code> instead of <code>iteritems()</code><br>------------------------------------------------------------------ <br><h3> chryss, Id: 3294969, Score: 39: </h3><p>This is a very common looping idiom. <code>in</code> is an operator. For when to use <code>for key in dict</code> and when it must be <code>for key in dict.keys()</code> see <a href="https://web.archive.org/web/20180411011411/http://python.net/~goodger/projects/pycon/2007/idiomatic/handout.html" rel="noreferrer">David Goodger's Idiomatic Python article (archived copy)</a>.</p>
<h4> Wolf, Comment 62165165 Score: 1: </h4>As I read these sections about <code>in</code>, the operator part is <a href="http://python.net/~goodger/projects/pycon/2007/idiomatic/handout.html#use-in-where-possible-2" rel="nofollow noreferrer">where you check for existence</a>. Maybe the better delete this <i><code>in is an operator</code></i> information.<br>------------------------------------------------------------------ <br><h3> sberry, Id: 3294899, Score: 6814: </h3><p><code>key</code> is just a variable name.  </p>

<pre><code>for key in d:
</code></pre>

<p>will simply loop over the keys in the dictionary, rather than the keys and values.  To loop over both key and value you can use the following:</p>

<p>For Python 3.x:</p>

<pre><code>for key, value in d.items():
</code></pre>

<p>For Python 2.x:</p>

<pre><code>for key, value in d.iteritems():
</code></pre>

<p>To test for yourself, change the word <code>key</code> to <code>poop</code>.</p>

<p>In Python 3.x, <code>iteritems()</code> was replaced with simply <code>items()</code>, which returns a set-like view backed by the dict, like <code>iteritems()</code> but even better. 
This is also available in 2.7 as <code>viewitems()</code>. </p>

<p>The operation <code>items()</code> will work for both 2 and 3, but in 2 it will return a list of the dictionary's <code>(key, value)</code> pairs, which will not reflect changes to the dict that happen after the <code>items()</code> call. If you want the 2.x behavior in 3.x, you can call <code>list(d.items())</code>.</p>
<h4> quiet_penguin, Comment 77700753 Score: 256: </h4>Adding an overlooked reason not to access value like this: d[key] inside the for loop causes the key to be hashed again (to get the value). When the dictionary is large this extra hash will add to the overall time. This is discussed in Raymond Hettinger&#39;s tech talk <a href="https://www.youtube.com/watch?v=anrOzOapJ2E" rel="nofollow noreferrer">youtube.com/watch?v=anrOzOapJ2E</a><br><h4> Aimery, Comment 102139254 Score: 26: </h4>@yugr From Python 3.7, dictionaries are insertion-ordered and this is a language feature. See <a href="https://stackoverflow.com/a/39980744/9428564">stackoverflow.com/a/39980744/9428564</a><br><h4> Geza Turi, Comment 100571684 Score: 12: </h4>@yugr Why do you say that ? The docs says <code>Keys and values are iterated over in insertion order. </code> [<a href="https://docs.python.org/3/library/stdtypes.html#dictionary-view-objects]" rel="nofollow noreferrer">docs.python.org/3/library/&hellip;</a><br><h4> JoeyC, Comment 93291724 Score: 9: </h4>@HarisankarKrishnaSwamy what is the alternative?<br><h4> yugr, Comment 100575661 Score: 3: </h4>@GezaTuri Only starting from Python 3.6 (and there have been rumors this &quot;feature&quot; may be removed again in future versions).<br><h4> yugr, Comment 102140719 Score: 1: </h4>@Aimery That&#39;s great, maybe it&#39;ll be usable in portable code 10 years from now. Do IronPython and Pypy support this as well?<br><h4> ShadowRanger, Comment 125009686 Score: 1: </h4>@yugr: PyPy is the interpreter that actually introduced the <code>dict</code> design that was implicitly insertion-ordered (so it&#39;s been in PyPy as an implementation detail for longer than it&#39;s been in the CPython reference interpreter). IronPython barely supports Python 3 at all (it&#39;s first alpha release was in early 2021 and only supports the 3.4 language standard), and to my knowledge C#/.NET lacks an insertion ordered hashmap as a built-in, so it probably doesn&#39;t support it, and won&#39;t, until they release a 3.7 or higher compatible release (at which point the language standard requires it).<br><h4> Nate T, Comment 124344487 Score: 1: </h4>I dunno... the &#39;test for yourself&#39; logic seems like a <i>crappy</i> way of going about it.<br><h4> mrT, Comment 106124652 Score: 0: </h4>How do you get the key for a given value with the use of a condition, for example if I had some pets and I wanted to check what pet corresponds to the number 4 <code>dict = {&#39;cats&#39; : 5, &#39;dogs&#39; : 4, &#39;fish&#39; : 7}</code> how would you use a condition to get key &#39;dogs&#39; from a given value e.g. 4?<br><h4> Ikbel, Comment 98649829 Score: 0: </h4>by using the <code>items()</code>  method the values in the dictionary will be switched, thus using  <code>d[key]</code> would be more accurate.<br><h4> Russell Lego, Comment 99686375 Score: 0: </h4>this actually  does not work <code>In [10]: d Out[10]: {&#39;id&#39;: [1, 2, 3], &#39;name&#39;: [&#39;russell&#39;, &#39;priya&#39;, &#39;ravi&#39;]}  In [11]: for key, value in d.iteritems():     ...:     print key     ...:     print value     ...:      name [&#39;russell&#39;, &#39;priya&#39;, &#39;ravi&#39;] id [1, 2, 3]</code><br><h4> 842Mono, Comment 120322252 Score: 0: </h4>There&#39;s also <code>for value in d.values() :</code> in Python 3.x<br>------------------------------------------------------------------ <br><h3> ars, Id: 3295295, Score: 554: </h3><p>It's not that key is a special word, but that dictionaries implement the iterator protocol.  You could do this in your class, e.g. see <a href="https://stackoverflow.com/questions/19151/build-a-basic-python-iterator/24377#24377">this question</a> for how to build class iterators.</p>

<p>In the case of dictionaries, it's implemented at the C level.  The details are available in <a href="http://www.python.org/dev/peps/pep-0234/" rel="noreferrer">PEP 234</a>.  In particular, the section titled "Dictionary Iterators":</p>

<blockquote>
  <ul>
  <li><p>Dictionaries implement a tp_iter slot that returns an efficient
  iterator that iterates over the keys of the dictionary. [...] This 
  means that we can write</p>

<pre><code>for k in dict: ...
</code></pre>
  
  <p>which is equivalent to, but much faster than</p>

<pre><code>for k in dict.keys(): ...
</code></pre>
  
  <p>as long as the restriction on modifications to the dictionary
  (either by the loop or by another thread) are not violated.</p></li>
  <li><p>Add methods to dictionaries that return different kinds of
  iterators explicitly:</p>

<pre><code>for key in dict.iterkeys(): ...

for value in dict.itervalues(): ...

for key, value in dict.iteritems(): ...
</code></pre>
  
  <p>This means that <code>for x in dict</code> is shorthand for <code>for x in
   dict.iterkeys()</code>.</p></li>
  </ul>
</blockquote>

<p>In Python 3, <code>dict.iterkeys()</code>, <code>dict.itervalues()</code> and <code>dict.iteritems()</code> are no longer supported. Use <code>dict.keys()</code>, <code>dict.values()</code> and <code>dict.items()</code> instead.</p>
------------------------------------------------------------------ <br><h3> John La Rooy, Id: 3295662, Score: 274: </h3><p>Iterating over a <code>dict</code> iterates through its keys in no particular order, as you can see here:</p>
<p>(This is practically <a href="https://stackoverflow.com/questions/39980323/dictionaries-are-ordered-in-python-3-6">no longer the case since Python 3.6</a>, but note that it's only guaranteed behaviour since Python 3.7.)</p>
<pre><code>&gt;&gt;&gt; d = {'x': 1, 'y': 2, 'z': 3}
&gt;&gt;&gt; list(d)
['y', 'x', 'z']
&gt;&gt;&gt; d.keys()
['y', 'x', 'z']
</code></pre>
<p>For your example, it is a better idea to use <code>dict.items()</code>:</p>
<pre><code>&gt;&gt;&gt; d.items()
[('y', 2), ('x', 1), ('z', 3)]
</code></pre>
<p>This gives you a list of tuples. When you loop over them like this, each tuple is unpacked into <code>k</code> and <code>v</code> automatically:</p>
<pre><code>for k,v in d.items():
    print(k, 'corresponds to', v)
</code></pre>
<p>Using <code>k</code> and <code>v</code> as variable names when looping over a <code>dict</code> is quite common if the body of the loop is only a few lines. For more complicated loops it may be a good idea to use more descriptive names:</p>
<pre><code>for letter, number in d.items():
    print(letter, 'corresponds to', number)
</code></pre>
<p>It's a good idea to get into the habit of using format strings:</p>
<pre><code>for letter, number in d.items():
    print('{0} corresponds to {1}'.format(letter, number))
</code></pre>
<h4> Gregory Arenius, Comment 89784964 Score: 24: </h4>From the Python 3.7 release notes: &quot;The insertion-order preservation nature of dict objects is now an official part of the Python language spec.&quot;<br>------------------------------------------------------------------ <br><h3> ssoler, Id: 3295279, Score: 153: </h3><p><code>key</code> is simply a variable.</p>
<p>For <strong>Python 3.x</strong>:</p>
<pre><code>&gt;&gt;&gt; d = {'x': 1, 'y': 2, 'z': 3}
&gt;&gt;&gt; for the_key, the_value in d.items():
...     print(the_key, 'corresponds to', the_value)
...
x corresponds to 1
y corresponds to 2
z corresponds to 3
</code></pre>
<p>For <strong>Python 2.x</strong>:</p>
<pre><code>&gt;&gt;&gt; d = {'x': 1, 'y': 2, 'z': 3} 
&gt;&gt;&gt; for my_var in d:
&gt;&gt;&gt;     print my_var, 'corresponds to', d[my_var]

x corresponds to 1
y corresponds to 2
z corresponds to 3
</code></pre>
<p>... or better,</p>
<pre><code>d = {'x': 1, 'y': 2, 'z': 3} 

for the_key, the_value in d.iteritems():
    print the_key, 'corresponds to', the_value
</code></pre>
------------------------------------------------------------------ <br><h3> jdhao, Id: 44182134, Score: 38: </h3><p>I have a use case where I have to iterate through the dict to get the key, value pair, also the index indicating where I am. This is how I do it:</p>
<pre><code>d = {'x': 1, 'y': 2, 'z': 3} 
for i, (key, value) in enumerate(d.items()):
   print(i, key, value)
</code></pre>
<p>Note that the parentheses around the key, value are important, without them, you'd get an <code>ValueError</code> &quot;not enough values to unpack&quot;.</p>
<h4> gosuto, Comment 108239947 Score: 2: </h4>How is this relevant to the question?<br>------------------------------------------------------------------ <br><h3> Gowdham V, Id: 70724260, Score: 35: </h3><p>For Iterating through dictionaries, The below code can be used.</p>
<pre><code>dictionary= {1: &quot;a&quot;, 2: &quot;b&quot;, 3: &quot;c&quot;}

#To iterate over the keys
for key in dictionary.keys():
    print(key)

#To Iterate over the values
for value in dictionary.values():
    print(value)

#To Iterate both the keys and values
for key, value in dictionary.items():
    print(key, '\t', value)
</code></pre>
------------------------------------------------------------------ <br><h3> Russia Must Remove Putin, Id: 44666083, Score: 32: </h3><blockquote>
  <h2>Iterating over dictionaries using 'for' loops</h2>

<pre><code>d = {'x': 1, 'y': 2, 'z': 3} 
for key in d:
    ...
</code></pre>
  
  <p>How does Python recognize that it needs only to read the key from the
  dictionary? Is key a special word in Python? Or is it simply a
  variable?</p>
</blockquote>

<p>It's not just <code>for</code> loops. The important word here is "iterating".</p>

<p>A dictionary is a mapping of keys to values:</p>

<pre><code>d = {'x': 1, 'y': 2, 'z': 3} 
</code></pre>

<p>Any time we iterate over it, we iterate over the keys. The variable name <code>key</code> is only intended to be descriptive - and it is quite apt for the purpose.</p>

<p>This happens in a list comprehension:</p>

<pre><code>&gt;&gt;&gt; [k for k in d]
['x', 'y', 'z']
</code></pre>

<p>It happens when we pass the dictionary to list (or any other collection type object):</p>

<pre><code>&gt;&gt;&gt; list(d)
['x', 'y', 'z']
</code></pre>

<p>The way Python iterates is, in a context where it needs to, it calls the <code>__iter__</code> method of the object (in this case the dictionary) which returns an iterator (in this case, a keyiterator object):</p>

<pre><code>&gt;&gt;&gt; d.__iter__()
&lt;dict_keyiterator object at 0x7fb1747bee08&gt;
</code></pre>

<p>We shouldn't use these special methods ourselves, instead, use the respective builtin function to call it, <code>iter</code>:</p>

<pre><code>&gt;&gt;&gt; key_iterator = iter(d)
&gt;&gt;&gt; key_iterator
&lt;dict_keyiterator object at 0x7fb172fa9188&gt;
</code></pre>

<p>Iterators have a <code>__next__</code> method - but we call it with the builtin function, <code>next</code>:</p>

<pre><code>&gt;&gt;&gt; next(key_iterator)
'x'
&gt;&gt;&gt; next(key_iterator)
'y'
&gt;&gt;&gt; next(key_iterator)
'z'
&gt;&gt;&gt; next(key_iterator)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
StopIteration
</code></pre>

<p>When an iterator is exhausted, it raises <code>StopIteration</code>. This is how Python knows to exit a <code>for</code> loop, or a list comprehension, or a generator expression, or any other iterative context. Once an iterator raises <code>StopIteration</code> it will always raise it - if you want to iterate again, you need a new one.</p>

<pre><code>&gt;&gt;&gt; list(key_iterator)
[]
&gt;&gt;&gt; new_key_iterator = iter(d)
&gt;&gt;&gt; list(new_key_iterator)
['x', 'y', 'z']
</code></pre>

<h2>Returning to dicts</h2>

<p>We've seen dicts iterating in many contexts. What we've seen is that any time we iterate over a dict, we get the keys. Back to the original example:</p>

<blockquote>
<pre><code>d = {'x': 1, 'y': 2, 'z': 3} 
for key in d:
</code></pre>
</blockquote>

<p>If we change the variable name, we still get the keys. Let's try it:</p>

<pre><code>&gt;&gt;&gt; for each_key in d:
...     print(each_key, '=&gt;', d[each_key])
... 
x =&gt; 1
y =&gt; 2
z =&gt; 3
</code></pre>

<p>If we want to iterate over the values, we need to use the <code>.values</code> method of dicts, or for both together, <code>.items</code>:</p>

<pre><code>&gt;&gt;&gt; list(d.values())
[1, 2, 3]
&gt;&gt;&gt; list(d.items())
[('x', 1), ('y', 2), ('z', 3)]
</code></pre>

<p>In the example given, it would be more efficient to iterate over the items like this:</p>

<pre><code>for a_key, corresponding_value in d.items():
    print(a_key, corresponding_value)
</code></pre>

<p>But for academic purposes, the question's example is just fine.</p>
------------------------------------------------------------------ <br><h3> Ankur Agarwal, Id: 47088919, Score: 13: </h3><p>You can check the implementation of CPython's <code>dicttype</code> on GitHub. This is the signature of method that implements the dict iterator:</p>

<pre><code>_PyDict_Next(PyObject *op, Py_ssize_t *ppos, PyObject **pkey,
             PyObject **pvalue, Py_hash_t *phash)
</code></pre>

<p><a href="https://github.com/python/cpython/blob/b2e5794870eb4728ddfaafc0f79a40299576434f/Objects/dictobject.c" rel="noreferrer">CPython dictobject.c</a></p>
------------------------------------------------------------------ <br><h3> Neil Chowdhury  o_O, Id: 34550429, Score: 8: </h3><p>To iterate over keys, it is slower but better to use <code>my_dict.keys()</code>. If you tried to do something like this:</p>
<pre><code>for key in my_dict:
    my_dict[key+&quot;-1&quot;] = my_dict[key]-1
</code></pre>
<p>it would create a runtime error because you are changing the keys while the program is running. If you are absolutely set on reducing time, use the <code>for key in my_dict</code> way, but you have been warned.</p>
<h4> Martijn Pieters, Comment 113767417 Score: 1: </h4>Why is it &#39;better&#39; to use <code>my_dict.keys()</code> over iterating directly over the dictionary? Iteration over a dictionary is clearly documented as yielding keys. It appears you had Python 2 in mind when you answered this, because in Python 3 <code>for key in my_dict.keys()</code> will <i>still have the same problem with changing the dictionary size during iteration</i>.<br>------------------------------------------------------------------ <br><h3> Mister Verleg, Id: 63814044, Score: 7: </h3><p>If you are looking for a clear and visual example:</p>
<pre><code>cat  = {'name': 'Snowy', 'color': 'White' ,'age': 14}
for key , value in cat.items():
   print(key, ': ', value)
</code></pre>
<p>Result:</p>
<pre class="lang-none prettyprint-override"><code>name:  Snowy
color:  White
age:  14
</code></pre>
------------------------------------------------------------------ <br><h3> theAccountant.py, Id: 70747846, Score: -1: </h3><p>A dictionary in Python is a collection of key-value pairs. Each key is connected to a value, and you can use a key to access the value associated with that key. A key's value can be a number, a string, a list, or even another dictionary. In this case, threat each &quot;key-value pair&quot; as a separate row in the table: d is your table with two columns. the key is the first column, key[value] is your second column. Your for loop is a standard way to iterate over a table.</p>
------------------------------------------------------------------ <br><h3> Amar Kumar, Id: 61296126, Score: 6: </h3><p>This will print the output in <em>sorted</em> order by <em>values</em> in ascending order.</p>
<pre><code>d = {'x': 3, 'y': 1, 'z': 2}

def by_value(item):
    return item[1]

for key, value in sorted(d.items(), key=by_value):
    print(key, '-&gt;', value)
</code></pre>
<p>Output:</p>
<blockquote>
<pre><code>y -&gt; 1
z -&gt; 2
x -&gt; 3
</code></pre>
</blockquote>
<h4> Joe Ferndz, Comment 115801955 Score: 1: </h4>I dont think this was the question asked. The question was about key and why python picks up the keys from the dictionary without the .items() or .keys() option.<br>------------------------------------------------------------------ <br><h3> cottontail, Id: 76494930, Score: 1: </h3><p>If you want to loop over a dictionary and modify it in iteration (perhaps add/delete a key), in Python 2, it was possible by looping over <code>my_dict.keys()</code>. In Python 3, the iteration has to be over an explicit copy of the keys (otherwise it throws a <code>RuntimeError</code>) because <code>my_dict.keys()</code> returns a view of the dictionary keys, so any change to <code>my_dict</code> changes the view as well.</p>
<pre class="lang-py prettyprint-override"><code>my_dict = {'a': 1, 'b': 2, 'c': 3}
for k in my_dict:
    my_dict.pop(k)        # &lt;---- error


# remove keys from my_dict
for k in list(my_dict):
    my_dict.pop(k)        # &lt;---- OK
</code></pre>
------------------------------------------------------------------ <br><h3> Rohit_VE, Id: 67599090, Score: -1: </h3><p>Let's get straight to the point. If the word key is just a variable, as you have mentioned then the main thing to note is that when you run a <strong>'FOR LOOP'</strong> over a dictionary it runs through only the <em>'keys'</em> and ignores the <em>'values'</em>.</p>
<pre><code>d = {'x': 1, 'y': 2, 'z': 3} 
for key in d:
    print (key, 'corresponds to', d[key])
</code></pre>
<p>rather try this:</p>
<pre><code>d = {'x': 1, 'y': 2, 'z': 3} 
for i in d:
    print (i, 'corresponds to', d[i])
</code></pre>
<p>but if you use a function like:</p>
<pre><code>d = {'x': 1, 'y': 2, 'z': 3}
print(d.keys())
</code></pre>
<p>in the above case <strong>'keys'</strong> is just not a variable, its a function.</p>
------------------------------------------------------------------ <br><h3> m.r, Id: 75836459, Score: -1: </h3><p>When you loop over a dict, this is what actually happening:</p>
<pre><code>&gt;&gt;&gt; d = {'x': 1, 'y': 2, 'z': 3}
&gt;&gt;&gt; iter(d)
Out[408]: &lt;dict_keyiterator at 0x2b240fc6d40&gt;
&gt;&gt;&gt; list(iter(d))
Out[409]: ['x', 'y', 'z']
&gt;&gt;&gt; for key in iter(d):
        print(key)    
x
y
z
</code></pre>
