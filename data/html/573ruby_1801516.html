 <h2> Title: How do you add an array to another array in Ruby and not end up with a multi-dimensional result? </h2> <h3> ncvncvn, question_id: 1801516 </h3>Score: 573, Tags: {ruby,arrays,multidimensional-array} <br><p>I tried:</p>
<pre><code>somearray = [&quot;some&quot;, &quot;thing&quot;]
anotherarray = [&quot;another&quot;, &quot;thing&quot;]
somearray.push(anotherarray.flatten!)
</code></pre>
<p>I expected</p>
<pre><code>[&quot;some&quot;, &quot;thing&quot;, &quot;another&quot;, &quot;thing&quot;]
</code></pre>
<p>but got</p>
<pre><code>[&quot;some&quot;, &quot;thing&quot;, nil]
</code></pre>
<h4> Comment 83301357 Ziggy: </h4>Questions get upvotes if they are useful to users. The simplest questions get the most upvotes because they are useful to the most people.<br><h4> Comment 1691285 Telemachus: </h4>It&#39;s worth saying (not to give you grief, but because it will bite you again and again) that your expectation is the problem here. Ruby arrays (unlike say arrays in Perl) do <i>not</i> automatically flatten in contexts like this. This isn&#39;t a bug: it&#39;s a feature.<br><h4> Comment 57951821 yeyo: </h4><code>ri Array@flatten!</code> Why this question is getting so many votes? The doc is explicit <code>Array#flatten!</code> <i>Flattens self in place. Returns nil if no modifications were made (i.e., the array contains no subarrays.)</i><br><h4> Comment 84383877 Konstantin: </h4>@yeyo, don&#39;t you just think that flatten operation is free?<br><h4> Comment 84412852 yeyo: </h4>@Konstantin op isn&#39;t looking for alternatives or talking about performance issues, op was expecting a result he or she didn&#39;t get because <code>flatten!</code> doesn&#39;t work like that. Finally, the question reflects a logic problem rather than an optimization problem. See pilcrow&#39;s answer below for more.<br><h4> Comment 84512185 Konstantin: </h4>@yeyo, well the actual question title doesn&#39;t completely correlate to the question title. I assume that OP actually wanted to add an array to another one, so I believe it&#39;s worthy to clarify dos and donts both to him and all the newcomers. You know, SO question title has a big weight in SEs ;)<br>------------------------------------------------------------------ <br><h3> Answer 1801652 pilcrow: </h3><p>You've got a workable idea, but the <code>#flatten!</code> is in the wrong place -- it flattens its receiver, so you could use it to turn <code>[1, 2, ['foo', 'bar']]</code> into <code>[1,2,'foo','bar']</code>.</p>

<p>I'm doubtless forgetting some approaches, but you can <strong>concatenate</strong>:</p>

<pre><code>a1.concat a2
a1 + a2              # creates a new array, as does a1 += a2
</code></pre>

<p>or <strong>prepend/append</strong>:</p>

<pre><code>a1.push(*a2)         # note the asterisk
a2.unshift(*a1)      # note the asterisk, and that a2 is the receiver
</code></pre>

<p>or <strong>splice</strong>:</p>

<pre><code>a1[a1.length, 0] = a2
a1[a1.length..0] = a2
a1.insert(a1.length, *a2)
</code></pre>

<p>or <strong>append and flatten</strong>:</p>

<pre><code>(a1 &lt;&lt; a2).flatten!  # a call to #flatten instead would return a new array
</code></pre>
<h4> Comment 14458274 phatmann: </h4>Using push instead of concat avoids the creation of a third array, so this is preferred for large arrays.<br><h4> Comment 38609164 cbliard: </h4>@phatmann Concatenation with <a href="http://www.ruby-doc.org/core/Array.html#method-i-concat" rel="nofollow noreferrer"><code>Array#concat</code></a> does not allocate a new array, Concatenation with <a href="http://www.ruby-doc.org/core/Array.html#method-i-2B" rel="nofollow noreferrer"><code>Array#+</code></a> does<br><h4> Comment 52725927 Terra Ashley: </h4>The only thing this answer is missing is benchmark comparisons of each approach.  +1!<br><h4> Comment 90051738 vaibhavatul47: </h4><i>Note</i>: concat will modify original array. <code>a = [1, 3]</code> <code>a.concat([4, 5])</code>, a becomes <code>[1, 3, 4, 5]</code><br><h4> Comment 38671881 phatmann: </h4>@cbliard Now that I look at the docs I see you are right about <code>concat</code>! So really the answer should be edited yet again to just have <code>concat</code> as the solution. The other solutions are cool but superfluous.<br><h4> Comment 14458913 pilcrow: </h4>+1 @phatmann.  I&#39;ve edited to reflect that push/unshift are really distinct from concatenation which (you&#39;re right) does suggest to me the creation of a new array.<br><h4> Comment 25774217 sk4l: </h4>You are AWESOME, you know that, pilcrow? It never occurred to me that I was getting a multi-dimensional array when pushing one array to another and didn&#39;t think this is the source of my error. Thank you!<br><h4> Comment 39876898 erik258: </h4>At least in 1.9.3, <code>+=</code> behaves as you&#39;d expect:  <code>1.9.3-p484 :001 &gt; a1 = [1,2,3]  =&gt; [1, 2, 3] 1.9.3-p484 :002 &gt; a2=[4,5,6]  =&gt; [4, 5, 6] 1.9.3-p484 :003 &gt; a1 += a2  =&gt; [1, 2, 3, 4, 5, 6] 1.9.3-p484 :004 &gt; a1  =&gt; [1, 2, 3, 4, 5, 6]</code><br><h4> Comment 39897957 pilcrow: </h4>@DanFarrell, right, we know that works as commented in the <code>a1 + a2</code> example.<br><h4> Comment 73110224 ScottJ: </h4><code>[a1, a2].reduce(:+)</code> works well, especially if you may have more than 2 elements in the list<br><h4> Comment 73543108 Justus Eapen: </h4>Can we explain the asterisk operator in this situation?<br><h4> Comment 130728420 ajay_speed: </h4>@pilcrow what is this a1.push(*a2) = &gt; asterisk used for? what it means and were all we can use this symbol? I am new to ruby.<br><h4> Comment 130733638 pilcrow: </h4>@ajay_speed, the asterisk or &quot;splat&quot; is a Ruby operator.  Check the docs, look around here, and ask a question here if it doesn&#39;t make sense.<br><h4> Comment 83791421 Developer Marius Žilėnas: </h4><b>Note</b>: <code>([1] &lt;&lt; 3).flatten</code> will produce <code>[1,3]</code>, while <code>([1] &lt;&lt; 3).flatten!</code> will produce <b><code>nil</code></b>.<br>------------------------------------------------------------------ <br><h3> Answer 1801534 micmoo: </h3><p>You can just use the <code>+</code> operator!</p>

<pre><code>irb(main):001:0&gt; a = [1,2]
=&gt; [1, 2]
irb(main):002:0&gt; b = [3,4]
=&gt; [3, 4]
irb(main):003:0&gt; a + b
=&gt; [1, 2, 3, 4]
</code></pre>

<p>You can read all about the array class here:
<a href="http://ruby-doc.org/core/classes/Array.html" rel="noreferrer">http://ruby-doc.org/core/classes/Array.html</a></p>
<h4> Comment 14458291 phatmann: </h4>The poster wanted to know how to concat to an existing array, not create a new array that was the union of two arrays.<br><h4> Comment 54908497 Filip Bartuzi: </h4>remember that <code>+=</code> creates new object. in such example <code>[1, 2].each_with_object([]) { |number, object| object+=number }</code> empty array <code>[]</code> will be returned<br><h4> Comment 50470313 Joshua Pinter: </h4>@kbrock Correct. If dealing with <i>large</i> arrays, you&#39;ll want to look at the <code>push</code> method as described by @pilcrow.<br><h4> Comment 72657340 alexandre-rousseau: </h4>Item added must be an array<br><h4> Comment 47189067 kbrock: </h4>Note: <code>a+= b</code> creates a new array: <code>c = a = [1,2] ; b = [3,4] ; a += b ; puts c #=&gt; [1,2]</code><br><h4> Comment 49416477 Herb Meehan: </h4>Very straight forward and no methods to memorize. Thanks! This worked for me.<br><h4> Comment 83701414 Marvin: </h4>@kbrock Your comment saved me from much heartache.  I&#39;m liking Ruby less and less,  Behavior like somearray += ...  making a new object is completely unexpected.<br>------------------------------------------------------------------ <br><h3> Answer 18101775 WebDev: </h3><p>The cleanest approach is to use the <strong>Array#concat</strong> method; it will not create a new array (unlike Array#+ which will do the same thing but create a new array).</p>
<p>Straight from the docs (<a href="http://www.ruby-doc.org/core-1.9.3/Array.html#method-i-concat" rel="noreferrer">http://www.ruby-doc.org/core-1.9.3/Array.html#method-i-concat</a>):</p>
<blockquote>
<h3>concat(other_ary)</h3>
<blockquote>
<p>Appends the elements of other_ary to self.</p>
</blockquote>
</blockquote>
<p>So</p>
<pre><code>[1,2].concat([3,4])  #=&gt; [1,2,3,4]  
</code></pre>
<p><strong>Array#concat</strong> will not flatten a multidimensional array if it is passed in as an argument. You'll need to handle that separately:</p>
<pre><code>arr= [3,[4,5]]
arr= arr.flatten   #=&gt; [3,4,5]
[1,2].concat(arr)  #=&gt; [1,2,3,4,5]
</code></pre>
<p>Lastly, you can use our corelib gem (<a href="https://github.com/corlewsolutions/corelib" rel="noreferrer">https://github.com/corlewsolutions/corelib</a>) which adds useful helpers to the Ruby core classes.  In particular we have an <strong>Array#add_all</strong> method which will automatically flatten multidimensional arrays before executing the concat.</p>
<h4> Comment 53922002 WebDev: </h4>&quot;You usually want immutability&quot; is not accurate.  In 20+ years of full time software development I&#39;ve worked with all kinds of arrays and collections on a daily basis.  Sometimes you modify an existing array in place.  Sometimes you need to work with a new instance.<br><h4> Comment 52296644 vasilakisfil: </h4>You usually want immutability, so creating a new array is a better idea.<br>------------------------------------------------------------------ <br><h3> Answer 54138581 snibbets: </h3><pre><code>a = ["some", "thing"]
b = ["another", "thing"]
</code></pre>

<p>To append <code>b</code> to <code>a</code> and store the result in <code>a</code>:</p>

<pre><code>a.push(*b)
</code></pre>

<p>or</p>

<pre><code>a += b
</code></pre>

<p>In either case, <code>a</code> becomes:</p>

<pre><code>["some", "thing", "another", "thing"]
</code></pre>

<p>but in the former case, the elements of <code>b</code> are appended to the existing <code>a</code> array, and in the latter case the two arrays are concatenated together and the result is stored in <code>a</code>.</p>
<h4> Comment 95599960 Dave Hartnoll: </h4>Note that <code>a.push(*b)</code> is not exactly the same as <code>a += b</code>. The former adds the new elements to the existing array; the latter creates a new array with all elements and assigns it to <code>a</code>. You can see the difference if you do something like <code>aa = a</code> to save the ref to <code>a</code> before either append method and then examine <code>aa</code> afterwards. In the former case, it changes with the new value of <code>a</code>, and in the latter it remains unchanged.<br><h4> Comment 119092930 ragurney: </h4>NOTE: what @DaveHartnoll points out is <i>extremely important</i> for <code>each_with_object</code> usage and the like. Doing <code>each_with_object([]) { |thing, result| result += [thing] }</code> will not work, while using the <code>push</code> method does.<br>------------------------------------------------------------------ <br><h3> Answer 34619050 Ludovic Kuty: </h3><p>Easy method that works with Ruby version >= 2.0 but not with older versions :</p>

<pre><code>irb(main):001:0&gt; a=[1,2]
=&gt; [1, 2]
irb(main):003:0&gt; b=[3,4]
=&gt; [3, 4]
irb(main):002:0&gt; c=[5,6]
=&gt; [5, 6]
irb(main):004:0&gt; [*a,*b,*c]
=&gt; [1, 2, 3, 4, 5, 6]
</code></pre>
<h4> Comment 73139945 Ludovic Kuty: </h4>I don&#39;t think that justifies the -1 this answer gets. No ruby version mentioned by OP, ruby version explicitly mentioned in the answer, so... you want to be backward compatible with version pre alpha 0.0.0.0.1 ? This is one of the good solutions, depending on the ruby version<br><h4> Comment 94393632 sandre89: </h4>Just to point that this answer is very &#39;similar&#39; to the very idiomatic JavaScript ES6 in which you could do <code>[...array1, ...array2]</code>, just remembering that the <code>splat</code> operator in ruby would be <code>*</code> instead of <code>...</code>. It makes it easier to remember<br><h4> Comment 65217208 Abhinay: </h4>@Ikuty This is by far the most elegant solution I found, can you please explain whats happening with <code>*</code> here?<br><h4> Comment 73084839 Otheus: </h4><code>[*a, *b]</code> fails for older versions of ruby, ie, 1.8.7. And as much as Ruby wants to tell you its out of life, RHEL6 is still maintained, making Ruby 1.8 very much a significant target version.<br><h4> Comment 67760984 Omar Ali: </h4>@Abhinay the plat operator explodes the array into elements thus creating a single-dimension array in the last line.<br>------------------------------------------------------------------ <br><h3> Answer 1801547 Joshua Cheek: </h3><p>Here are two ways, notice in this case that the first way assigns a new array ( translates to somearray = somearray + anotherarray )</p>

<pre><code>somearray = ["some", "thing"]

anotherarray = ["another", "thing"]

somearray += anotherarray # =&gt; ["some", "thing", "another", "thing"]

somearray = ["some", "thing"]
somearray.concat anotherarray # =&gt; ["some", "thing", "another", "thing"]
</code></pre>
------------------------------------------------------------------ <br><h3> Answer 1801545 g00se0ne: </h3><p>Try this, it will combine your arrays removing duplicates</p>

<pre><code>array1 = ["foo", "bar"]
array2 = ["foo1", "bar1"]

array3 = array1|array2
</code></pre>

<p><a href="http://www.ruby-doc.org/core/classes/Array.html" rel="noreferrer">http://www.ruby-doc.org/core/classes/Array.html</a></p>

<p>Further documentation look at "Set Union"</p>
<h4> Comment 1689652 Joshua Cheek: </h4>This is an or, it returns an array with no duplicate elements, here is an example of how it probably doesn&#39;t do what he is asking, the two &quot;baz&quot; in the first array get turned into one, and the &quot;bar&quot; in the second array doesn&#39;t get added.  array1 = [&quot;foo&quot;, &quot;bar&quot; , &quot;baz&quot; , &quot;baz&quot; ] array2 = [&quot;foo1&quot;, &quot;bar1&quot; , &quot;bar&quot; ]  array3 = array1|array2 array3 # =&gt; [&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;, &quot;foo1&quot;, &quot;bar1&quot;]<br><h4> Comment 86671092 Joshua Pinter: </h4>Or even better: <code>array1 |= [ &quot;foo1&quot;, &quot;bar1&quot; ] #=&gt; [ &quot;foo&quot;, &quot;bar&quot;, &quot;foo1&quot;, &quot;bar1&quot; ]</code><br>------------------------------------------------------------------ <br><h3> Answer 31601925 slindsey3000: </h3><pre><code>(array1 + array2).uniq
</code></pre>
<p>This way you get array1 elements first. You will get no duplicates.</p>
------------------------------------------------------------------ <br><h3> Answer 1801536 samg: </h3><pre><code>[&quot;some&quot;, &quot;thing&quot;] + [&quot;another&quot;, &quot;thing&quot;]
</code></pre>
<h4> Comment 104593434 Alexis Wilke: </h4>I don&#39;t think that <code>&quot;another&quot; + &quot;thing&quot;</code> is going to work as expected.<br><h4> Comment 73084887 Otheus: </h4>I don&#39;t know about efficiency, but this works for Ruby 1.8. In general, <code>[*a] + [*b]</code> works<br>------------------------------------------------------------------ <br><h3> Answer 44487296 juliangonzalez: </h3><p>Elaborating on @Pilcrow's answer the only suitable answer for huge arrays is <code>concat</code> (<code>+</code>) since is fast and does not allocate a new object to be garbage-collected when operating inside a loop.</p>

<p>Here's the benchmark:</p>

<pre><code>require 'benchmark'

huge_ary_1 = Array.new(1_000_000) { rand(5_000_000..30_000_00) }

huge_ary_2 = Array.new(1_000_000) { rand(35_000_000..55_000_00) }

Benchmark.bm do |bm|
  p '-------------------CONCAT ----------------'
  bm.report { huge_ary_1.concat(huge_ary_2) }

  p '------------------- PUSH ----------------'
  bm.report { huge_ary_1.push(*huge_ary_2)  }
end
</code></pre>

<p>Results:</p>

<pre><code>       user     system      total        real
"-------------------CONCAT ----------------"
  0.000000   0.000000   0.000000 (  0.009388)
"------------------- PUSH ----------------"
  example/array_concat_vs_push.rb:13:in `block (2 levels) in &lt;main&gt;': stack level too deep (SystemStackError)
</code></pre>

<p>As you can see using <code>push</code> throws an <strong>ERROR</strong>: <code>stack level too deep (SystemStackError)</code> when the arrays are big enough.</p>
------------------------------------------------------------------ <br><h3> Answer 58087348 Lyle Dickie: </h3><p>somearray = ["some", "thing"]</p>

<p>anotherarray = ["another", "thing"]</p>

<p>somearray + anotherarray</p>
------------------------------------------------------------------ <br><h3> Answer 48024814 Datt: </h3><p>Just another way of doing it.</p>

<pre><code>[somearray, anotherarray].flatten
=&gt; ["some", "thing", "another", "thing"]
</code></pre>
<h4> Comment 108869335 hagello: </h4><code>flatten</code> flattens everything as far as possible, recursively. Even nested arrays. Consequently, if <code>somearray</code> or <code>anotherarray</code> contains nested arrays, they get flattened, too. This is a side-effect that is usually not intended.<br>------------------------------------------------------------------ <br><h3> Answer 33905682 Ziggy: </h3><p>The question, essentially, is "how to concatenate arrays in Ruby". Naturally the answer is to use <code>concat</code> or <code>+</code> as mentioned in nearly every answer.</p>

<p>A natural extension to the question would be "how to perform row-wise concatenation of 2D arrays in Ruby". When I googled "ruby concatenate matrices", this SO question was the top result so I thought I would leave my answer to that (unasked but related) question here for posterity.</p>

<hr>

<p>In some applications you might want to "concatenate" two 2D arrays row-wise. Something like,</p>

<pre><code>[[a, b], | [[x],    [[a, b, x],
 [c, d]] |  [y]] =&gt;  [c, d, y]]
</code></pre>

<p>This is something like "augmenting" a matrix. For example, I used this technique to create a single adjacency matrix to represent a graph out of a bunch of smaller matrices. Without this technique I would have had to iterate over the components in a way that could have been error prone or frustrating to think about. I might have had to do an <code>each_with_index</code>, for example. Instead I combined <a href="http://ruby-doc.org/core-2.2.0/Array.html#method-i-zip" rel="noreferrer">zip</a> and <a href="http://ruby-doc.org/core-2.2.0/Array.html#method-i-flatten" rel="noreferrer">flatten</a> as follows,</p>

<pre><code># given two multi-dimensional arrays that you want to concatenate row-wise
m1 = [[:a, :b], [:c, :d]]
m2 = [[:x], [:y]]

m1m2 = m1.zip(m2).map(&amp;:flatten)
# =&gt; [[:a, :b, :x], [:c, :d, :y]]
</code></pre>
------------------------------------------------------------------ <br><h3> Answer 70804262 Md. Mahmudur Rahman: </h3><pre><code>somearray = [&quot;some&quot;, &quot;thing&quot;]
anotherarray = [&quot;another&quot;, &quot;thing&quot;]
somearray + anotherarray # =&gt; [&quot;some&quot;, &quot;thing&quot;, &quot;another&quot;, &quot;thing&quot;]
somearray.concat anotherarray # =&gt; [&quot;some&quot;, &quot;thing&quot;, &quot;another&quot;, &quot;thing&quot;]
somearray.push(anotherarray).flatten # =&gt; [&quot;some&quot;, &quot;thing&quot;, &quot;another&quot;, &quot;thing&quot;]
somearray.push *anotherarray # =&gt; [&quot;another&quot;, &quot;thing&quot;, &quot;another&quot;, &quot;thing&quot;]
 
</code></pre>
------------------------------------------------------------------ <br><h3> Answer 30095197 Sandip Bhattacharya: </h3><p>If the new data could be an array or a scalar, and you want to prevent the new data to be nested if it was an array, the splat operator is awesome! It returns a scalar for a scalar, and an unpacked list of arguments for an array.</p>

<pre class="lang-ruby prettyprint-override"><code>1.9.3-p551 :020 &gt; a = [1, 2]
 =&gt; [1, 2] 
1.9.3-p551 :021 &gt; b = [3, 4]
 =&gt; [3, 4] 
1.9.3-p551 :022 &gt; c = 5
 =&gt; 5 
1.9.3-p551 :023 &gt; a.object_id
 =&gt; 6617020 
1.9.3-p551 :024 &gt; a.push *b
 =&gt; [1, 2, 3, 4] 
1.9.3-p551 :025 &gt; a.object_id
 =&gt; 6617020 
1.9.3-p551 :026 &gt; a.push *c
 =&gt; [1, 2, 3, 4, 5] 
1.9.3-p551 :027 &gt; a.object_id
 =&gt; 6617020 
</code></pre>
------------------------------------------------------------------ <br><h3> Answer 43010281 ScottJ: </h3><p>I'm surprised nobody has mentioned <code>reduce</code>, which works well when you have an array of arrays:</p>

<pre><code>lists = [["a", "b"], ["c", "d"]]
flatlist = lists.reduce(:+)  # ["a", "b", "c", "d"]
</code></pre>
------------------------------------------------------------------ <br><h3> Answer 53603166 AustintheCleric: </h3><pre><code>a = ['a', 'b']
b = ['c', 'd']
arr = [a, b].flatten
</code></pre>

<p>This won't remove dups, but </p>

<pre><code>a|b
</code></pre>

<p>removes dups.</p>
<h4> Comment 94673813 Mirodinho: </h4>Note: This recursively flattens all inner arrays as well.<br>------------------------------------------------------------------ <br><h3> Answer 1803308 nas: </h3><p>I find it easier to push or append arrays and then flatten them in place, like so:</p>

<pre><code>somearray = ["some", "thing"]
anotherarray = ["another", "thing"]
somearray.push anotherarray # =&gt; ["some", "thing", ["another", "thing"]]
#or
somearray &lt;&lt; anotherarray # =&gt; ["some", "thing", ["another", "thing"]]
somearray.flatten!  # =&gt; ["some", "thing", "another", "thing"]
somearray # =&gt; ["some", "thing", "another", "thing"]
</code></pre>
