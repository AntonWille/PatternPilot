 <h2> Title: How do you add an array to another array in Ruby and not end up with a multi-dimensional result? </h2> <h4> ncvncvn, question_id: 1801516 </h4>Score: 573, Tags: {ruby,arrays,multidimensional-array} <br><p>I tried:</p>
<pre><code>somearray = [&quot;some&quot;, &quot;thing&quot;]
anotherarray = [&quot;another&quot;, &quot;thing&quot;]
somearray.push(anotherarray.flatten!)
</code></pre>
<p>I expected</p>
<pre><code>[&quot;some&quot;, &quot;thing&quot;, &quot;another&quot;, &quot;thing&quot;]
</code></pre>
<p>but got</p>
<pre><code>[&quot;some&quot;, &quot;thing&quot;, nil]
</code></pre>
<h4> Ziggy, Id: 83301357 Score: 14: </h4>Questions get upvotes if they are useful to users. The simplest questions get the most upvotes because they are useful to the most people.<br><h4> Telemachus, Id: 1691285 Score: 6: </h4>It&#39;s worth saying (not to give you grief, but because it will bite you again and again) that your expectation is the problem here. Ruby arrays (unlike say arrays in Perl) do <i>not</i> automatically flatten in contexts like this. This isn&#39;t a bug: it&#39;s a feature.<br><h4> yeyo, Id: 57951821 Score: 4: </h4><code>ri Array@flatten!</code> Why this question is getting so many votes? The doc is explicit <code>Array#flatten!</code> <i>Flattens self in place. Returns nil if no modifications were made (i.e., the array contains no subarrays.)</i><br><h4> Konstantin, Id: 84383877 Score: 0: </h4>@yeyo, don&#39;t you just think that flatten operation is free?<br><h4> yeyo, Id: 84412852 Score: 0: </h4>@Konstantin op isn&#39;t looking for alternatives or talking about performance issues, op was expecting a result he or she didn&#39;t get because <code>flatten!</code> doesn&#39;t work like that. Finally, the question reflects a logic problem rather than an optimization problem. See pilcrow&#39;s answer below for more.<br><h4> Konstantin, Id: 84512185 Score: 0: </h4>@yeyo, well the actual question title doesn&#39;t completely correlate to the question title. I assume that OP actually wanted to add an array to another one, so I believe it&#39;s worthy to clarify dos and donts both to him and all the newcomers. You know, SO question title has a big weight in SEs ;)<br>------------------------------------------------------------------ <br><h3> pilcrow, Id: 1801652, Score: 826: </h3><p>You've got a workable idea, but the <code>#flatten!</code> is in the wrong place -- it flattens its receiver, so you could use it to turn <code>[1, 2, ['foo', 'bar']]</code> into <code>[1,2,'foo','bar']</code>.</p>

<p>I'm doubtless forgetting some approaches, but you can <strong>concatenate</strong>:</p>

<pre><code>a1.concat a2
a1 + a2              # creates a new array, as does a1 += a2
</code></pre>

<p>or <strong>prepend/append</strong>:</p>

<pre><code>a1.push(*a2)         # note the asterisk
a2.unshift(*a1)      # note the asterisk, and that a2 is the receiver
</code></pre>

<p>or <strong>splice</strong>:</p>

<pre><code>a1[a1.length, 0] = a2
a1[a1.length..0] = a2
a1.insert(a1.length, *a2)
</code></pre>

<p>or <strong>append and flatten</strong>:</p>

<pre><code>(a1 &lt;&lt; a2).flatten!  # a call to #flatten instead would return a new array
</code></pre>
<h4> phatmann, Comment 14458274 Score: 60: </h4>Using push instead of concat avoids the creation of a third array, so this is preferred for large arrays.<br><h4> cbliard, Comment 38609164 Score: 19: </h4>@phatmann Concatenation with <a href="http://www.ruby-doc.org/core/Array.html#method-i-concat" rel="nofollow noreferrer"><code>Array#concat</code></a> does not allocate a new array, Concatenation with <a href="http://www.ruby-doc.org/core/Array.html#method-i-2B" rel="nofollow noreferrer"><code>Array#+</code></a> does<br><h4> Terra Ashley, Comment 52725927 Score: 7: </h4>The only thing this answer is missing is benchmark comparisons of each approach.  +1!<br><h4> vaibhavatul47, Comment 90051738 Score: 1: </h4><i>Note</i>: concat will modify original array. <code>a = [1, 3]</code> <code>a.concat([4, 5])</code>, a becomes <code>[1, 3, 4, 5]</code><br><h4> phatmann, Comment 38671881 Score: 1: </h4>@cbliard Now that I look at the docs I see you are right about <code>concat</code>! So really the answer should be edited yet again to just have <code>concat</code> as the solution. The other solutions are cool but superfluous.<br><h4> pilcrow, Comment 14458913 Score: 1: </h4>+1 @phatmann.  I&#39;ve edited to reflect that push/unshift are really distinct from concatenation which (you&#39;re right) does suggest to me the creation of a new array.<br><h4> sk4l, Comment 25774217 Score: 0: </h4>You are AWESOME, you know that, pilcrow? It never occurred to me that I was getting a multi-dimensional array when pushing one array to another and didn&#39;t think this is the source of my error. Thank you!<br><h4> erik258, Comment 39876898 Score: 0: </h4>At least in 1.9.3, <code>+=</code> behaves as you&#39;d expect:  <code>1.9.3-p484 :001 &gt; a1 = [1,2,3]  =&gt; [1, 2, 3] 1.9.3-p484 :002 &gt; a2=[4,5,6]  =&gt; [4, 5, 6] 1.9.3-p484 :003 &gt; a1 += a2  =&gt; [1, 2, 3, 4, 5, 6] 1.9.3-p484 :004 &gt; a1  =&gt; [1, 2, 3, 4, 5, 6]</code><br><h4> pilcrow, Comment 39897957 Score: 0: </h4>@DanFarrell, right, we know that works as commented in the <code>a1 + a2</code> example.<br><h4> ScottJ, Comment 73110224 Score: 0: </h4><code>[a1, a2].reduce(:+)</code> works well, especially if you may have more than 2 elements in the list<br><h4> Justus Eapen, Comment 73543108 Score: 0: </h4>Can we explain the asterisk operator in this situation?<br><h4> ajay_speed, Comment 130728420 Score: 0: </h4>@pilcrow what is this a1.push(*a2) = &gt; asterisk used for? what it means and were all we can use this symbol? I am new to ruby.<br><h4> pilcrow, Comment 130733638 Score: 0: </h4>@ajay_speed, the asterisk or &quot;splat&quot; is a Ruby operator.  Check the docs, look around here, and ask a question here if it doesn&#39;t make sense.<br><h4> Developer Marius Žilėnas, Comment 83791421 Score: 0: </h4><b>Note</b>: <code>([1] &lt;&lt; 3).flatten</code> will produce <code>[1,3]</code>, while <code>([1] &lt;&lt; 3).flatten!</code> will produce <b><code>nil</code></b>.<br>------------------------------------------------------------------ <br><h3> micmoo, Id: 1801534, Score: 231: </h3><p>You can just use the <code>+</code> operator!</p>

<pre><code>irb(main):001:0&gt; a = [1,2]
=&gt; [1, 2]
irb(main):002:0&gt; b = [3,4]
=&gt; [3, 4]
irb(main):003:0&gt; a + b
=&gt; [1, 2, 3, 4]
</code></pre>

<p>You can read all about the array class here:
<a href="http://ruby-doc.org/core/classes/Array.html" rel="noreferrer">http://ruby-doc.org/core/classes/Array.html</a></p>
<h4> phatmann, Comment 14458291 Score: 22: </h4>The poster wanted to know how to concat to an existing array, not create a new array that was the union of two arrays.<br><h4> Filip Bartuzi, Comment 54908497 Score: 2: </h4>remember that <code>+=</code> creates new object. in such example <code>[1, 2].each_with_object([]) { |number, object| object+=number }</code> empty array <code>[]</code> will be returned<br><h4> Joshua Pinter, Comment 50470313 Score: 1: </h4>@kbrock Correct. If dealing with <i>large</i> arrays, you&#39;ll want to look at the <code>push</code> method as described by @pilcrow.<br><h4> alexandre-rousseau, Comment 72657340 Score: 1: </h4>Item added must be an array<br><h4> kbrock, Comment 47189067 Score: 1: </h4>Note: <code>a+= b</code> creates a new array: <code>c = a = [1,2] ; b = [3,4] ; a += b ; puts c #=&gt; [1,2]</code><br><h4> Herb Meehan, Comment 49416477 Score: 0: </h4>Very straight forward and no methods to memorize. Thanks! This worked for me.<br><h4> Marvin, Comment 83701414 Score: 0: </h4>@kbrock Your comment saved me from much heartache.  I&#39;m liking Ruby less and less,  Behavior like somearray += ...  making a new object is completely unexpected.<br>------------------------------------------------------------------ <br><h3> WebDev, Id: 18101775, Score: 87: </h3><p>The cleanest approach is to use the <strong>Array#concat</strong> method; it will not create a new array (unlike Array#+ which will do the same thing but create a new array).</p>
<p>Straight from the docs (<a href="http://www.ruby-doc.org/core-1.9.3/Array.html#method-i-concat" rel="noreferrer">http://www.ruby-doc.org/core-1.9.3/Array.html#method-i-concat</a>):</p>
<blockquote>
<h3>concat(other_ary)</h3>
<blockquote>
<p>Appends the elements of other_ary to self.</p>
</blockquote>
</blockquote>
<p>So</p>
<pre><code>[1,2].concat([3,4])  #=&gt; [1,2,3,4]  
</code></pre>
<p><strong>Array#concat</strong> will not flatten a multidimensional array if it is passed in as an argument. You'll need to handle that separately:</p>
<pre><code>arr= [3,[4,5]]
arr= arr.flatten   #=&gt; [3,4,5]
[1,2].concat(arr)  #=&gt; [1,2,3,4,5]
</code></pre>
<p>Lastly, you can use our corelib gem (<a href="https://github.com/corlewsolutions/corelib" rel="noreferrer">https://github.com/corlewsolutions/corelib</a>) which adds useful helpers to the Ruby core classes.  In particular we have an <strong>Array#add_all</strong> method which will automatically flatten multidimensional arrays before executing the concat.</p>
<h4> WebDev, Comment 53922002 Score: 10: </h4>&quot;You usually want immutability&quot; is not accurate.  In 20+ years of full time software development I&#39;ve worked with all kinds of arrays and collections on a daily basis.  Sometimes you modify an existing array in place.  Sometimes you need to work with a new instance.<br><h4> vasilakisfil, Comment 52296644 Score: 1: </h4>You usually want immutability, so creating a new array is a better idea.<br>------------------------------------------------------------------ <br><h3> snibbets, Id: 54138581, Score: 46: </h3><pre><code>a = ["some", "thing"]
b = ["another", "thing"]
</code></pre>

<p>To append <code>b</code> to <code>a</code> and store the result in <code>a</code>:</p>

<pre><code>a.push(*b)
</code></pre>

<p>or</p>

<pre><code>a += b
</code></pre>

<p>In either case, <code>a</code> becomes:</p>

<pre><code>["some", "thing", "another", "thing"]
</code></pre>

<p>but in the former case, the elements of <code>b</code> are appended to the existing <code>a</code> array, and in the latter case the two arrays are concatenated together and the result is stored in <code>a</code>.</p>
<h4> Dave Hartnoll, Comment 95599960 Score: 4: </h4>Note that <code>a.push(*b)</code> is not exactly the same as <code>a += b</code>. The former adds the new elements to the existing array; the latter creates a new array with all elements and assigns it to <code>a</code>. You can see the difference if you do something like <code>aa = a</code> to save the ref to <code>a</code> before either append method and then examine <code>aa</code> afterwards. In the former case, it changes with the new value of <code>a</code>, and in the latter it remains unchanged.<br><h4> ragurney, Comment 119092930 Score: 2: </h4>NOTE: what @DaveHartnoll points out is <i>extremely important</i> for <code>each_with_object</code> usage and the like. Doing <code>each_with_object([]) { |thing, result| result += [thing] }</code> will not work, while using the <code>push</code> method does.<br>------------------------------------------------------------------ <br><h3> Ludovic Kuty, Id: 34619050, Score: 44: </h3><p>Easy method that works with Ruby version >= 2.0 but not with older versions :</p>

<pre><code>irb(main):001:0&gt; a=[1,2]
=&gt; [1, 2]
irb(main):003:0&gt; b=[3,4]
=&gt; [3, 4]
irb(main):002:0&gt; c=[5,6]
=&gt; [5, 6]
irb(main):004:0&gt; [*a,*b,*c]
=&gt; [1, 2, 3, 4, 5, 6]
</code></pre>
<h4> Ludovic Kuty, Comment 73139945 Score: 4: </h4>I don&#39;t think that justifies the -1 this answer gets. No ruby version mentioned by OP, ruby version explicitly mentioned in the answer, so... you want to be backward compatible with version pre alpha 0.0.0.0.1 ? This is one of the good solutions, depending on the ruby version<br><h4> sandre89, Comment 94393632 Score: 4: </h4>Just to point that this answer is very &#39;similar&#39; to the very idiomatic JavaScript ES6 in which you could do <code>[...array1, ...array2]</code>, just remembering that the <code>splat</code> operator in ruby would be <code>*</code> instead of <code>...</code>. It makes it easier to remember<br><h4> Abhinay, Comment 65217208 Score: 3: </h4>@Ikuty This is by far the most elegant solution I found, can you please explain whats happening with <code>*</code> here?<br><h4> Otheus, Comment 73084839 Score: 0: </h4><code>[*a, *b]</code> fails for older versions of ruby, ie, 1.8.7. And as much as Ruby wants to tell you its out of life, RHEL6 is still maintained, making Ruby 1.8 very much a significant target version.<br><h4> Omar Ali, Comment 67760984 Score: 0: </h4>@Abhinay the plat operator explodes the array into elements thus creating a single-dimension array in the last line.<br>------------------------------------------------------------------ <br><h3> Joshua Cheek, Id: 1801547, Score: 41: </h3><p>Here are two ways, notice in this case that the first way assigns a new array ( translates to somearray = somearray + anotherarray )</p>

<pre><code>somearray = ["some", "thing"]

anotherarray = ["another", "thing"]

somearray += anotherarray # =&gt; ["some", "thing", "another", "thing"]

somearray = ["some", "thing"]
somearray.concat anotherarray # =&gt; ["some", "thing", "another", "thing"]
</code></pre>
------------------------------------------------------------------ <br><h3> g00se0ne, Id: 1801545, Score: 38: </h3><p>Try this, it will combine your arrays removing duplicates</p>

<pre><code>array1 = ["foo", "bar"]
array2 = ["foo1", "bar1"]

array3 = array1|array2
</code></pre>

<p><a href="http://www.ruby-doc.org/core/classes/Array.html" rel="noreferrer">http://www.ruby-doc.org/core/classes/Array.html</a></p>

<p>Further documentation look at "Set Union"</p>
<h4> Joshua Cheek, Comment 1689652 Score: 1: </h4>This is an or, it returns an array with no duplicate elements, here is an example of how it probably doesn&#39;t do what he is asking, the two &quot;baz&quot; in the first array get turned into one, and the &quot;bar&quot; in the second array doesn&#39;t get added.  array1 = [&quot;foo&quot;, &quot;bar&quot; , &quot;baz&quot; , &quot;baz&quot; ] array2 = [&quot;foo1&quot;, &quot;bar1&quot; , &quot;bar&quot; ]  array3 = array1|array2 array3 # =&gt; [&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;, &quot;foo1&quot;, &quot;bar1&quot;]<br><h4> Joshua Pinter, Comment 86671092 Score: 1: </h4>Or even better: <code>array1 |= [ &quot;foo1&quot;, &quot;bar1&quot; ] #=&gt; [ &quot;foo&quot;, &quot;bar&quot;, &quot;foo1&quot;, &quot;bar1&quot; ]</code><br>------------------------------------------------------------------ <br><h3> slindsey3000, Id: 31601925, Score: 22: </h3><pre><code>(array1 + array2).uniq
</code></pre>
<p>This way you get array1 elements first. You will get no duplicates.</p>
------------------------------------------------------------------ <br><h3> samg, Id: 1801536, Score: 13: </h3><pre><code>[&quot;some&quot;, &quot;thing&quot;] + [&quot;another&quot;, &quot;thing&quot;]
</code></pre>
<h4> Alexis Wilke, Comment 104593434 Score: 3: </h4>I don&#39;t think that <code>&quot;another&quot; + &quot;thing&quot;</code> is going to work as expected.<br><h4> Otheus, Comment 73084887 Score: 0: </h4>I don&#39;t know about efficiency, but this works for Ruby 1.8. In general, <code>[*a] + [*b]</code> works<br>------------------------------------------------------------------ <br><h3> juliangonzalez, Id: 44487296, Score: 13: </h3><p>Elaborating on @Pilcrow's answer the only suitable answer for huge arrays is <code>concat</code> (<code>+</code>) since is fast and does not allocate a new object to be garbage-collected when operating inside a loop.</p>

<p>Here's the benchmark:</p>

<pre><code>require 'benchmark'

huge_ary_1 = Array.new(1_000_000) { rand(5_000_000..30_000_00) }

huge_ary_2 = Array.new(1_000_000) { rand(35_000_000..55_000_00) }

Benchmark.bm do |bm|
  p '-------------------CONCAT ----------------'
  bm.report { huge_ary_1.concat(huge_ary_2) }

  p '------------------- PUSH ----------------'
  bm.report { huge_ary_1.push(*huge_ary_2)  }
end
</code></pre>

<p>Results:</p>

<pre><code>       user     system      total        real
"-------------------CONCAT ----------------"
  0.000000   0.000000   0.000000 (  0.009388)
"------------------- PUSH ----------------"
  example/array_concat_vs_push.rb:13:in `block (2 levels) in &lt;main&gt;': stack level too deep (SystemStackError)
</code></pre>

<p>As you can see using <code>push</code> throws an <strong>ERROR</strong>: <code>stack level too deep (SystemStackError)</code> when the arrays are big enough.</p>
------------------------------------------------------------------ <br><h3> Lyle Dickie, Id: 58087348, Score: 4: </h3><p>somearray = ["some", "thing"]</p>

<p>anotherarray = ["another", "thing"]</p>

<p>somearray + anotherarray</p>
------------------------------------------------------------------ <br><h3> Datt, Id: 48024814, Score: 10: </h3><p>Just another way of doing it.</p>

<pre><code>[somearray, anotherarray].flatten
=&gt; ["some", "thing", "another", "thing"]
</code></pre>
<h4> hagello, Comment 108869335 Score: 0: </h4><code>flatten</code> flattens everything as far as possible, recursively. Even nested arrays. Consequently, if <code>somearray</code> or <code>anotherarray</code> contains nested arrays, they get flattened, too. This is a side-effect that is usually not intended.<br>------------------------------------------------------------------ <br><h3> Ziggy, Id: 33905682, Score: 8: </h3><p>The question, essentially, is "how to concatenate arrays in Ruby". Naturally the answer is to use <code>concat</code> or <code>+</code> as mentioned in nearly every answer.</p>

<p>A natural extension to the question would be "how to perform row-wise concatenation of 2D arrays in Ruby". When I googled "ruby concatenate matrices", this SO question was the top result so I thought I would leave my answer to that (unasked but related) question here for posterity.</p>

<hr>

<p>In some applications you might want to "concatenate" two 2D arrays row-wise. Something like,</p>

<pre><code>[[a, b], | [[x],    [[a, b, x],
 [c, d]] |  [y]] =&gt;  [c, d, y]]
</code></pre>

<p>This is something like "augmenting" a matrix. For example, I used this technique to create a single adjacency matrix to represent a graph out of a bunch of smaller matrices. Without this technique I would have had to iterate over the components in a way that could have been error prone or frustrating to think about. I might have had to do an <code>each_with_index</code>, for example. Instead I combined <a href="http://ruby-doc.org/core-2.2.0/Array.html#method-i-zip" rel="noreferrer">zip</a> and <a href="http://ruby-doc.org/core-2.2.0/Array.html#method-i-flatten" rel="noreferrer">flatten</a> as follows,</p>

<pre><code># given two multi-dimensional arrays that you want to concatenate row-wise
m1 = [[:a, :b], [:c, :d]]
m2 = [[:x], [:y]]

m1m2 = m1.zip(m2).map(&amp;:flatten)
# =&gt; [[:a, :b, :x], [:c, :d, :y]]
</code></pre>
------------------------------------------------------------------ <br><h3> Md. Mahmudur Rahman, Id: 70804262, Score: 7: </h3><pre><code>somearray = [&quot;some&quot;, &quot;thing&quot;]
anotherarray = [&quot;another&quot;, &quot;thing&quot;]
somearray + anotherarray # =&gt; [&quot;some&quot;, &quot;thing&quot;, &quot;another&quot;, &quot;thing&quot;]
somearray.concat anotherarray # =&gt; [&quot;some&quot;, &quot;thing&quot;, &quot;another&quot;, &quot;thing&quot;]
somearray.push(anotherarray).flatten # =&gt; [&quot;some&quot;, &quot;thing&quot;, &quot;another&quot;, &quot;thing&quot;]
somearray.push *anotherarray # =&gt; [&quot;another&quot;, &quot;thing&quot;, &quot;another&quot;, &quot;thing&quot;]
 
</code></pre>
------------------------------------------------------------------ <br><h3> Sandip Bhattacharya, Id: 30095197, Score: 5: </h3><p>If the new data could be an array or a scalar, and you want to prevent the new data to be nested if it was an array, the splat operator is awesome! It returns a scalar for a scalar, and an unpacked list of arguments for an array.</p>

<pre class="lang-ruby prettyprint-override"><code>1.9.3-p551 :020 &gt; a = [1, 2]
 =&gt; [1, 2] 
1.9.3-p551 :021 &gt; b = [3, 4]
 =&gt; [3, 4] 
1.9.3-p551 :022 &gt; c = 5
 =&gt; 5 
1.9.3-p551 :023 &gt; a.object_id
 =&gt; 6617020 
1.9.3-p551 :024 &gt; a.push *b
 =&gt; [1, 2, 3, 4] 
1.9.3-p551 :025 &gt; a.object_id
 =&gt; 6617020 
1.9.3-p551 :026 &gt; a.push *c
 =&gt; [1, 2, 3, 4, 5] 
1.9.3-p551 :027 &gt; a.object_id
 =&gt; 6617020 
</code></pre>
------------------------------------------------------------------ <br><h3> ScottJ, Id: 43010281, Score: 5: </h3><p>I'm surprised nobody has mentioned <code>reduce</code>, which works well when you have an array of arrays:</p>

<pre><code>lists = [["a", "b"], ["c", "d"]]
flatlist = lists.reduce(:+)  # ["a", "b", "c", "d"]
</code></pre>
------------------------------------------------------------------ <br><h3> AustintheCleric, Id: 53603166, Score: 5: </h3><pre><code>a = ['a', 'b']
b = ['c', 'd']
arr = [a, b].flatten
</code></pre>

<p>This won't remove dups, but </p>

<pre><code>a|b
</code></pre>

<p>removes dups.</p>
<h4> Mirodinho, Comment 94673813 Score: 0: </h4>Note: This recursively flattens all inner arrays as well.<br>------------------------------------------------------------------ <br><h3> nas, Id: 1803308, Score: 3: </h3><p>I find it easier to push or append arrays and then flatten them in place, like so:</p>

<pre><code>somearray = ["some", "thing"]
anotherarray = ["another", "thing"]
somearray.push anotherarray # =&gt; ["some", "thing", ["another", "thing"]]
#or
somearray &lt;&lt; anotherarray # =&gt; ["some", "thing", ["another", "thing"]]
somearray.flatten!  # =&gt; ["some", "thing", "another", "thing"]
somearray # =&gt; ["some", "thing", "another", "thing"]
</code></pre>
