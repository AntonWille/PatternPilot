[
    {
        "owner": {
            "account_id": 6018,
            "reputation": 583451,
            "user_id": 9951,
            "user_type": "registered",
            "accept_rate": 78,
            "profile_image": "https:\/\/i.stack.imgur.com\/CIFG8.png?s=256&g=1",
            "display_name": "Bite code",
            "link": "https:\/\/stackoverflow.com\/users\/9951\/bite-code"
        },
        "is_accepted": true,
        "score": 17888,
        "last_activity_date": 1691641618,
        "last_edit_date": 1691641618,
        "creation_date": 1224802124,
        "answer_id": 231855,
        "question_id": 231767,
        "content_license": "CC BY-SA 4.0",
        "body_markdown": "To understand what `yield` does, you must understand what *generators* are. And before you can understand generators, you must understand *iterables*.\r\n\r\nIterables\r\n---------\r\n\r\nWhen you create a list, you can read its items one by one. Reading its items one by one is called iteration:\r\n\r\n    &gt;&gt;&gt; mylist = [1, 2, 3]\r\n    &gt;&gt;&gt; for i in mylist:\r\n    ...    print(i)\r\n    1\r\n    2\r\n    3\r\n\r\n`mylist` is an *iterable*. When you use a list comprehension, you create a list, and so an iterable:\r\n\r\n    &gt;&gt;&gt; mylist = [x*x for x in range(3)]\r\n    &gt;&gt;&gt; for i in mylist:\r\n    ...    print(i)\r\n    0\r\n    1\r\n    4\r\n\r\nEverything you can use &quot;`for... in...`&quot; on is an iterable; `lists`, `strings`, files...\r\n\r\nThese iterables are handy because you can read them as much as you wish, but you store all the values in memory and this is not always what you want when you have a lot of values.\r\n\r\nGenerators\r\n----------\r\n\r\nGenerators are iterators, a kind of iterable **you can only iterate over once**. Generators do not store all the values in memory, **they generate the values on the fly**:\r\n\r\n    &gt;&gt;&gt; mygenerator = (x*x for x in range(3))\r\n    &gt;&gt;&gt; for i in mygenerator:\r\n    ...    print(i)\r\n    0\r\n    1\r\n    4\r\n\r\nIt is just the same except you used `()` instead of `[]`. BUT, you **cannot** perform `for i in mygenerator` a second time since generators can only be used once: they calculate 0, then forget about it and calculate 1, and end after calculating 4, one by one.\r\n\r\nYield\r\n-----\r\n\r\n`yield` is a keyword that is used like `return`, except the function will return a generator.\r\n\r\n    &gt;&gt;&gt; def create_generator():\r\n    ...    mylist = range(3)\r\n    ...    for i in mylist:\r\n    ...        yield i*i\r\n    ...\r\n    &gt;&gt;&gt; mygenerator = create_generator() # create a generator\r\n    &gt;&gt;&gt; print(mygenerator) # mygenerator is an object!\r\n    &lt;generator object create_generator at 0xb7555c34&gt;\r\n    &gt;&gt;&gt; for i in mygenerator:\r\n    ...     print(i)\r\n    0\r\n    1\r\n    4\r\n\r\nHere it&#39;s a useless example, but it&#39;s handy when you know your function will return a huge set of values that you will only need to read once.\r\n\r\nTo master `yield`, you must understand that **when you call the function, the code you have written in the function body does not run.** The function only returns the generator object, this is a bit tricky.\r\n\r\nThen, your code will continue from where it left off each time `for` uses the generator.\r\n\r\nNow the hard part:\r\n\r\nThe first time the `for` calls the generator object created from your function, it will run the code in your function from the beginning until it hits `yield`, then it&#39;ll return the first value of the loop. Then, each subsequent call will run another iteration of the loop you have written in the function and return the next value. This will continue until the generator is considered empty, which happens when the function runs without hitting `yield`. That can be because the loop has come to an end, or because you no longer satisfy an `&quot;if\/else&quot;`.\r\n\r\n---\r\n\r\nYour code explained\r\n-------------------\r\n\r\n*Generator:*\r\n\r\n    # Here you create the method of the node object that will return the generator\r\n    def _get_child_candidates(self, distance, min_dist, max_dist):\r\n\r\n        # Here is the code that will be called each time you use the generator object:\r\n\r\n        # If there is still a child of the node object on its left\r\n        # AND if the distance is ok, return the next child\r\n        if self._leftchild and distance - max_dist &lt; self._median:\r\n            yield self._leftchild\r\n\r\n        # If there is still a child of the node object on its right\r\n        # AND if the distance is ok, return the next child\r\n        if self._rightchild and distance + max_dist &gt;= self._median:\r\n            yield self._rightchild\r\n\r\n        # If the function arrives here, the generator will be considered empty\r\n        # There are no more than two values: the left and the right children\r\n\r\n*Caller:*\r\n\r\n    # Create an empty list and a list with the current object reference\r\n    result, candidates = list(), [self]\r\n\r\n    # Loop on candidates (they contain only one element at the beginning)\r\n    while candidates:\r\n\r\n        # Get the last candidate and remove it from the list\r\n        node = candidates.pop()\r\n\r\n        # Get the distance between obj and the candidate\r\n        distance = node._get_dist(obj)\r\n\r\n        # If the distance is ok, then you can fill in the result\r\n        if distance &lt;= max_dist and distance &gt;= min_dist:\r\n            result.extend(node._values)\r\n\r\n        # Add the children of the candidate to the candidate&#39;s list\r\n        # so the loop will keep running until it has looked\r\n        # at all the children of the children of the children, etc. of the candidate\r\n        candidates.extend(node._get_child_candidates(distance, min_dist, max_dist))\r\n\r\n    return result\r\n\r\nThis code contains several smart parts:\r\n\r\n- The loop iterates on a list, but the list expands while the loop is being iterated. It&#39;s a concise way to go through all these nested data even if it&#39;s a bit dangerous since you can end up with an infinite loop. In this case, `candidates.extend(node._get_child_candidates(distance, min_dist, max_dist))` exhausts all the values of the generator, but `while` keeps creating new generator objects which will produce different values from the previous ones since it&#39;s not applied on the same node.\r\n\r\n- The `extend()` method is a list object method that expects an iterable and adds its values to the list.\r\n\r\nUsually, we pass a list to it:\r\n\r\n    &gt;&gt;&gt; a = [1, 2]\r\n    &gt;&gt;&gt; b = [3, 4]\r\n    &gt;&gt;&gt; a.extend(b)\r\n    &gt;&gt;&gt; print(a)\r\n    [1, 2, 3, 4]\r\n\r\nBut in your code, it gets a generator, which is good because:\r\n\r\n1. You don&#39;t need to read the values twice.\r\n2. You may have a lot of children and you don&#39;t want them all stored in memory.\r\n\r\nAnd it works because Python does not care if the argument of a method is a list or not. Python expects iterables so it will work with strings, lists, tuples, and generators! This is called duck typing and is one of the reasons why Python is so cool. But this is another story, for another question...\r\n\r\nYou can stop here, or read a little bit to see an advanced use of a generator:\r\n\r\nControlling a generator exhaustion\r\n------\r\n\r\n    &gt;&gt;&gt; class Bank(): # Let&#39;s create a bank, building ATMs\r\n    ...    crisis = False\r\n    ...    def create_atm(self):\r\n    ...        while not self.crisis:\r\n    ...            yield &quot;$100&quot;\r\n    &gt;&gt;&gt; hsbc = Bank() # When everything&#39;s ok the ATM gives you as much as you want\r\n    &gt;&gt;&gt; corner_street_atm = hsbc.create_atm()\r\n    &gt;&gt;&gt; print(corner_street_atm.next())\r\n    $100\r\n    &gt;&gt;&gt; print(corner_street_atm.next())\r\n    $100\r\n    &gt;&gt;&gt; print([corner_street_atm.next() for cash in range(5)])\r\n    [&#39;$100&#39;, &#39;$100&#39;, &#39;$100&#39;, &#39;$100&#39;, &#39;$100&#39;]\r\n    &gt;&gt;&gt; hsbc.crisis = True # Crisis is coming, no more money!\r\n    &gt;&gt;&gt; print(corner_street_atm.next())\r\n    &lt;type &#39;exceptions.StopIteration&#39;&gt;\r\n    &gt;&gt;&gt; wall_street_atm = hsbc.create_atm() # It&#39;s even true for new ATMs\r\n    &gt;&gt;&gt; print(wall_street_atm.next())\r\n    &lt;type &#39;exceptions.StopIteration&#39;&gt;\r\n    &gt;&gt;&gt; hsbc.crisis = False # The trouble is, even post-crisis the ATM remains empty\r\n    &gt;&gt;&gt; print(corner_street_atm.next())\r\n    &lt;type &#39;exceptions.StopIteration&#39;&gt;\r\n    &gt;&gt;&gt; brand_new_atm = hsbc.create_atm() # Build a new one to get back in business\r\n    &gt;&gt;&gt; for cash in brand_new_atm:\r\n    ...    print cash\r\n    $100\r\n    $100\r\n    $100\r\n    $100\r\n    $100\r\n    $100\r\n    $100\r\n    $100\r\n    $100\r\n    ...\r\n\r\n**Note:** For Python 3, use`print(corner_street_atm.__next__())` or `print(next(corner_street_atm))`\r\n\r\nIt can be useful for various things like controlling access to a resource.\r\n\r\nItertools, your best friend\r\n-----\r\n\r\nThe `itertools` module contains special functions to manipulate iterables. Ever wish to duplicate a generator?\r\nChain two generators? Group values in a nested list with a one-liner? `Map \/ Zip` without creating another list?\r\n\r\nThen just `import itertools`.\r\n\r\nAn example? Let&#39;s see the possible orders of arrival for a four-horse race:\r\n\r\n    &gt;&gt;&gt; horses = [1, 2, 3, 4]\r\n    &gt;&gt;&gt; races = itertools.permutations(horses)\r\n    &gt;&gt;&gt; print(races)\r\n    &lt;itertools.permutations object at 0xb754f1dc&gt;\r\n    &gt;&gt;&gt; print(list(itertools.permutations(horses)))\r\n    [(1, 2, 3, 4),\r\n     (1, 2, 4, 3),\r\n     (1, 3, 2, 4),\r\n     (1, 3, 4, 2),\r\n     (1, 4, 2, 3),\r\n     (1, 4, 3, 2),\r\n     (2, 1, 3, 4),\r\n     (2, 1, 4, 3),\r\n     (2, 3, 1, 4),\r\n     (2, 3, 4, 1),\r\n     (2, 4, 1, 3),\r\n     (2, 4, 3, 1),\r\n     (3, 1, 2, 4),\r\n     (3, 1, 4, 2),\r\n     (3, 2, 1, 4),\r\n     (3, 2, 4, 1),\r\n     (3, 4, 1, 2),\r\n     (3, 4, 2, 1),\r\n     (4, 1, 2, 3),\r\n     (4, 1, 3, 2),\r\n     (4, 2, 1, 3),\r\n     (4, 2, 3, 1),\r\n     (4, 3, 1, 2),\r\n     (4, 3, 2, 1)]\r\n\r\n\r\nUnderstanding the inner mechanisms of iteration\r\n------\r\n\r\nIteration is a process implying iterables (implementing the `__iter__()` method) and iterators (implementing the `__next__()` method).\r\nIterables are any objects you can get an iterator from. Iterators are objects that let you iterate on iterables.\r\n\r\nThere is more about it in this article about [how `for` loops work][1].\r\n\r\n  [1]: https:\/\/web.archive.org\/web\/20201109034340\/http:\/\/effbot.org\/zone\/python-for-statement.htm\r\n",
        "body": "<p>To understand what <code>yield<\/code> does, you must understand what <em>generators<\/em> are. And before you can understand generators, you must understand <em>iterables<\/em>.<\/p>\n<h2>Iterables<\/h2>\n<p>When you create a list, you can read its items one by one. Reading its items one by one is called iteration:<\/p>\n<pre><code>&gt;&gt;&gt; mylist = [1, 2, 3]\n&gt;&gt;&gt; for i in mylist:\n...    print(i)\n1\n2\n3\n<\/code><\/pre>\n<p><code>mylist<\/code> is an <em>iterable<\/em>. When you use a list comprehension, you create a list, and so an iterable:<\/p>\n<pre><code>&gt;&gt;&gt; mylist = [x*x for x in range(3)]\n&gt;&gt;&gt; for i in mylist:\n...    print(i)\n0\n1\n4\n<\/code><\/pre>\n<p>Everything you can use &quot;<code>for... in...<\/code>&quot; on is an iterable; <code>lists<\/code>, <code>strings<\/code>, files...<\/p>\n<p>These iterables are handy because you can read them as much as you wish, but you store all the values in memory and this is not always what you want when you have a lot of values.<\/p>\n<h2>Generators<\/h2>\n<p>Generators are iterators, a kind of iterable <strong>you can only iterate over once<\/strong>. Generators do not store all the values in memory, <strong>they generate the values on the fly<\/strong>:<\/p>\n<pre><code>&gt;&gt;&gt; mygenerator = (x*x for x in range(3))\n&gt;&gt;&gt; for i in mygenerator:\n...    print(i)\n0\n1\n4\n<\/code><\/pre>\n<p>It is just the same except you used <code>()<\/code> instead of <code>[]<\/code>. BUT, you <strong>cannot<\/strong> perform <code>for i in mygenerator<\/code> a second time since generators can only be used once: they calculate 0, then forget about it and calculate 1, and end after calculating 4, one by one.<\/p>\n<h2>Yield<\/h2>\n<p><code>yield<\/code> is a keyword that is used like <code>return<\/code>, except the function will return a generator.<\/p>\n<pre><code>&gt;&gt;&gt; def create_generator():\n...    mylist = range(3)\n...    for i in mylist:\n...        yield i*i\n...\n&gt;&gt;&gt; mygenerator = create_generator() # create a generator\n&gt;&gt;&gt; print(mygenerator) # mygenerator is an object!\n&lt;generator object create_generator at 0xb7555c34&gt;\n&gt;&gt;&gt; for i in mygenerator:\n...     print(i)\n0\n1\n4\n<\/code><\/pre>\n<p>Here it's a useless example, but it's handy when you know your function will return a huge set of values that you will only need to read once.<\/p>\n<p>To master <code>yield<\/code>, you must understand that <strong>when you call the function, the code you have written in the function body does not run.<\/strong> The function only returns the generator object, this is a bit tricky.<\/p>\n<p>Then, your code will continue from where it left off each time <code>for<\/code> uses the generator.<\/p>\n<p>Now the hard part:<\/p>\n<p>The first time the <code>for<\/code> calls the generator object created from your function, it will run the code in your function from the beginning until it hits <code>yield<\/code>, then it'll return the first value of the loop. Then, each subsequent call will run another iteration of the loop you have written in the function and return the next value. This will continue until the generator is considered empty, which happens when the function runs without hitting <code>yield<\/code>. That can be because the loop has come to an end, or because you no longer satisfy an <code>&quot;if\/else&quot;<\/code>.<\/p>\n<hr \/>\n<h2>Your code explained<\/h2>\n<p><em>Generator:<\/em><\/p>\n<pre><code># Here you create the method of the node object that will return the generator\ndef _get_child_candidates(self, distance, min_dist, max_dist):\n\n    # Here is the code that will be called each time you use the generator object:\n\n    # If there is still a child of the node object on its left\n    # AND if the distance is ok, return the next child\n    if self._leftchild and distance - max_dist &lt; self._median:\n        yield self._leftchild\n\n    # If there is still a child of the node object on its right\n    # AND if the distance is ok, return the next child\n    if self._rightchild and distance + max_dist &gt;= self._median:\n        yield self._rightchild\n\n    # If the function arrives here, the generator will be considered empty\n    # There are no more than two values: the left and the right children\n<\/code><\/pre>\n<p><em>Caller:<\/em><\/p>\n<pre><code># Create an empty list and a list with the current object reference\nresult, candidates = list(), [self]\n\n# Loop on candidates (they contain only one element at the beginning)\nwhile candidates:\n\n    # Get the last candidate and remove it from the list\n    node = candidates.pop()\n\n    # Get the distance between obj and the candidate\n    distance = node._get_dist(obj)\n\n    # If the distance is ok, then you can fill in the result\n    if distance &lt;= max_dist and distance &gt;= min_dist:\n        result.extend(node._values)\n\n    # Add the children of the candidate to the candidate's list\n    # so the loop will keep running until it has looked\n    # at all the children of the children of the children, etc. of the candidate\n    candidates.extend(node._get_child_candidates(distance, min_dist, max_dist))\n\nreturn result\n<\/code><\/pre>\n<p>This code contains several smart parts:<\/p>\n<ul>\n<li><p>The loop iterates on a list, but the list expands while the loop is being iterated. It's a concise way to go through all these nested data even if it's a bit dangerous since you can end up with an infinite loop. In this case, <code>candidates.extend(node._get_child_candidates(distance, min_dist, max_dist))<\/code> exhausts all the values of the generator, but <code>while<\/code> keeps creating new generator objects which will produce different values from the previous ones since it's not applied on the same node.<\/p>\n<\/li>\n<li><p>The <code>extend()<\/code> method is a list object method that expects an iterable and adds its values to the list.<\/p>\n<\/li>\n<\/ul>\n<p>Usually, we pass a list to it:<\/p>\n<pre><code>&gt;&gt;&gt; a = [1, 2]\n&gt;&gt;&gt; b = [3, 4]\n&gt;&gt;&gt; a.extend(b)\n&gt;&gt;&gt; print(a)\n[1, 2, 3, 4]\n<\/code><\/pre>\n<p>But in your code, it gets a generator, which is good because:<\/p>\n<ol>\n<li>You don't need to read the values twice.<\/li>\n<li>You may have a lot of children and you don't want them all stored in memory.<\/li>\n<\/ol>\n<p>And it works because Python does not care if the argument of a method is a list or not. Python expects iterables so it will work with strings, lists, tuples, and generators! This is called duck typing and is one of the reasons why Python is so cool. But this is another story, for another question...<\/p>\n<p>You can stop here, or read a little bit to see an advanced use of a generator:<\/p>\n<h2>Controlling a generator exhaustion<\/h2>\n<pre><code>&gt;&gt;&gt; class Bank(): # Let's create a bank, building ATMs\n...    crisis = False\n...    def create_atm(self):\n...        while not self.crisis:\n...            yield &quot;$100&quot;\n&gt;&gt;&gt; hsbc = Bank() # When everything's ok the ATM gives you as much as you want\n&gt;&gt;&gt; corner_street_atm = hsbc.create_atm()\n&gt;&gt;&gt; print(corner_street_atm.next())\n$100\n&gt;&gt;&gt; print(corner_street_atm.next())\n$100\n&gt;&gt;&gt; print([corner_street_atm.next() for cash in range(5)])\n['$100', '$100', '$100', '$100', '$100']\n&gt;&gt;&gt; hsbc.crisis = True # Crisis is coming, no more money!\n&gt;&gt;&gt; print(corner_street_atm.next())\n&lt;type 'exceptions.StopIteration'&gt;\n&gt;&gt;&gt; wall_street_atm = hsbc.create_atm() # It's even true for new ATMs\n&gt;&gt;&gt; print(wall_street_atm.next())\n&lt;type 'exceptions.StopIteration'&gt;\n&gt;&gt;&gt; hsbc.crisis = False # The trouble is, even post-crisis the ATM remains empty\n&gt;&gt;&gt; print(corner_street_atm.next())\n&lt;type 'exceptions.StopIteration'&gt;\n&gt;&gt;&gt; brand_new_atm = hsbc.create_atm() # Build a new one to get back in business\n&gt;&gt;&gt; for cash in brand_new_atm:\n...    print cash\n$100\n$100\n$100\n$100\n$100\n$100\n$100\n$100\n$100\n...\n<\/code><\/pre>\n<p><strong>Note:<\/strong> For Python 3, use<code>print(corner_street_atm.__next__())<\/code> or <code>print(next(corner_street_atm))<\/code><\/p>\n<p>It can be useful for various things like controlling access to a resource.<\/p>\n<h2>Itertools, your best friend<\/h2>\n<p>The <code>itertools<\/code> module contains special functions to manipulate iterables. Ever wish to duplicate a generator?\nChain two generators? Group values in a nested list with a one-liner? <code>Map \/ Zip<\/code> without creating another list?<\/p>\n<p>Then just <code>import itertools<\/code>.<\/p>\n<p>An example? Let's see the possible orders of arrival for a four-horse race:<\/p>\n<pre><code>&gt;&gt;&gt; horses = [1, 2, 3, 4]\n&gt;&gt;&gt; races = itertools.permutations(horses)\n&gt;&gt;&gt; print(races)\n&lt;itertools.permutations object at 0xb754f1dc&gt;\n&gt;&gt;&gt; print(list(itertools.permutations(horses)))\n[(1, 2, 3, 4),\n (1, 2, 4, 3),\n (1, 3, 2, 4),\n (1, 3, 4, 2),\n (1, 4, 2, 3),\n (1, 4, 3, 2),\n (2, 1, 3, 4),\n (2, 1, 4, 3),\n (2, 3, 1, 4),\n (2, 3, 4, 1),\n (2, 4, 1, 3),\n (2, 4, 3, 1),\n (3, 1, 2, 4),\n (3, 1, 4, 2),\n (3, 2, 1, 4),\n (3, 2, 4, 1),\n (3, 4, 1, 2),\n (3, 4, 2, 1),\n (4, 1, 2, 3),\n (4, 1, 3, 2),\n (4, 2, 1, 3),\n (4, 2, 3, 1),\n (4, 3, 1, 2),\n (4, 3, 2, 1)]\n<\/code><\/pre>\n<h2>Understanding the inner mechanisms of iteration<\/h2>\n<p>Iteration is a process implying iterables (implementing the <code>__iter__()<\/code> method) and iterators (implementing the <code>__next__()<\/code> method).\nIterables are any objects you can get an iterator from. Iterators are objects that let you iterate on iterables.<\/p>\n<p>There is more about it in this article about <a href=\"https:\/\/web.archive.org\/web\/20201109034340\/http:\/\/effbot.org\/zone\/python-for-statement.htm\" rel=\"noreferrer\">how <code>for<\/code> loops work<\/a>.<\/p>\n",
        "community_owned_date": null
    },
    {
        "owner": {
            "account_id": 3591,
            "reputation": 333165,
            "user_id": 5190,
            "user_type": "moderator",
            "accept_rate": 76,
            "profile_image": "https:\/\/i.stack.imgur.com\/WWHqF.jpg?s=256&g=1",
            "display_name": "Vinko Vrsalovic",
            "link": "https:\/\/stackoverflow.com\/users\/5190\/vinko-vrsalovic"
        },
        "is_accepted": true,
        "score": 9054,
        "last_activity_date": 1661577028,
        "last_edit_date": 1661577028,
        "creation_date": 1230367459,
        "answer_id": 394814,
        "question_id": 394809,
        "content_license": "CC BY-SA 4.0",
        "body_markdown": "Yes, it was [added][1] in version 2.5. The expression syntax is:\r\n```python\r\na if condition else b\r\n```\r\nFirst `condition` is evaluated, then exactly one of either `a` or `b` is evaluated and returned based on the [Boolean][2] value of `condition`. If `condition` evaluates to `True`, then `a` is evaluated and returned but `b` is ignored, or else when `b` is evaluated and returned but `a` is ignored.\r\n\r\nThis allows short-circuiting because when `condition` is true only `a` is evaluated and `b` is not evaluated at all, but when `condition` is false only `b` is evaluated and `a` is not evaluated at all.\r\n\r\nFor example:\r\n```python\r\n&gt;&gt;&gt; &#39;true&#39; if True else &#39;false&#39;\r\n&#39;true&#39;\r\n&gt;&gt;&gt; &#39;true&#39; if False else &#39;false&#39;\r\n&#39;false&#39;\r\n```\r\nNote that conditionals are an _expression_, not a _statement_. This means you can&#39;t use **statements** such as `pass`, or assignments with `=` (or &quot;augmented&quot; assignments like `+=`), within a conditional **expression**:\r\n```python\r\n&gt;&gt;&gt; pass if False else pass\r\n  File &quot;&lt;stdin&gt;&quot;, line 1\r\n    pass if False else pass\r\n         ^\r\nSyntaxError: invalid syntax\r\n\r\n&gt;&gt;&gt; # Python parses this as `x = (1 if False else y) = 2`\r\n&gt;&gt;&gt; # The `(1 if False else x)` part is actually valid, but\r\n&gt;&gt;&gt; # it can&#39;t be on the left-hand side of `=`.\r\n&gt;&gt;&gt; x = 1 if False else y = 2\r\n  File &quot;&lt;stdin&gt;&quot;, line 1\r\nSyntaxError: cannot assign to conditional expression\r\n\r\n&gt;&gt;&gt; # If we parenthesize it instead...\r\n&gt;&gt;&gt; (x = 1) if False else (y = 2)\r\n  File &quot;&lt;stdin&gt;&quot;, line 1\r\n    (x = 1) if False else (y = 2)\r\n       ^\r\nSyntaxError: invalid syntax\r\n```\r\n(In 3.8 and above, the `:=` &quot;walrus&quot; operator allows simple assignment of values *as an expression*, which is then compatible with this syntax. But please don&#39;t write code like that; it will quickly become very difficult to understand.)\r\n\r\nSimilarly, because it is an expression, the `else` part is *mandatory*:\r\n```\r\n# Invalid syntax: we didn&#39;t specify what the value should be if the \r\n# condition isn&#39;t met. It doesn&#39;t matter if we can verify that\r\n# ahead of time.\r\na if True\r\n```\r\nYou can, however, use conditional expressions to assign a variable like so:\r\n```python\r\nx = a if True else b\r\n```\r\nOr for example to return a value:\r\n```\r\n# Of course we should just use the standard library `max`;\r\n# this is just for demonstration purposes.\r\ndef my_max(a, b):\r\n    return a if a &gt; b else b\r\n```\r\nThink of the conditional expression as switching between two values. We can use it when we are in a &#39;one value or another&#39; situation, where we will *do the same thing* with the result, regardless of whether the condition is met. We use the expression to compute the value, and then do something with it. If you need to *do something different* depending on the condition, then use a normal `if` **statement** instead.\r\n\r\n----------\r\n\r\nKeep in mind that it&#39;s frowned upon by some Pythonistas for several reasons:\r\n\r\n- The order of the arguments is different from those of the classic `condition ? a : b` ternary operator from many other languages (such as [C][3], [C++][4], [Go][5], [Perl][6], [Ruby][7], [Java][8], [JavaScript][9], etc.), which may lead to bugs when people unfamiliar with Python&#39;s &quot;surprising&quot; behaviour use it (they may reverse the argument order).\r\n- Some find it &quot;unwieldy&quot;, since it goes contrary to the normal flow of thought (thinking of the condition first and then the effects).\r\n- Stylistic reasons. (Although the &#39;inline `if`&#39; can be *really* useful, and make your script more concise, it really does complicate your code)\r\n\r\nIf you&#39;re having trouble remembering the order, then remember that when read aloud, you (almost) say what you mean. For example, `x = 4 if b &gt; 8 else 9` is read aloud as `x will be 4 if b is greater than 8 otherwise 9`.\r\n\r\nOfficial documentation:\r\n\r\n- [Conditional expressions][10]\r\n- [Is there an equivalent of C\u2019s \u201d?:\u201d ternary operator?][11]\r\n\r\n  [1]: https:\/\/mail.python.org\/pipermail\/python-dev\/2005-September\/056846.html &quot;[Python-Dev] Conditional Expression Resolution&quot;\r\n  [2]: https:\/\/en.wikipedia.org\/wiki\/Boolean_data_type &quot;Boolean data type&quot;\r\n  [3]: https:\/\/en.wikipedia.org\/wiki\/C_%28programming_language%29\r\n  [4]: https:\/\/en.wikipedia.org\/wiki\/C%2B%2B\r\n  [5]: https:\/\/en.wikipedia.org\/wiki\/Go_%28programming_language%29\r\n  [6]: https:\/\/en.wikipedia.org\/wiki\/Perl\r\n  [7]: https:\/\/en.wikipedia.org\/wiki\/Ruby_%28programming_language%29\r\n  [8]: https:\/\/en.wikipedia.org\/wiki\/Java_%28programming_language%29\r\n  [9]: https:\/\/en.wikipedia.org\/wiki\/JavaScript\r\n  [10]: https:\/\/docs.python.org\/3\/reference\/expressions.html#conditional-expressions &quot;Conditional expressions&quot;\r\n  [11]: https:\/\/docs.python.org\/3\/faq\/programming.html#is-there-an-equivalent-of-c-s-ternary-operator &quot;Is there an equivalent of C\u2019s \u201d?:\u201d ternary operator?&quot;",
        "body": "<p>Yes, it was <a href=\"https:\/\/mail.python.org\/pipermail\/python-dev\/2005-September\/056846.html\" rel=\"noreferrer\" title=\"[Python-Dev] Conditional Expression Resolution\">added<\/a> in version 2.5. The expression syntax is:<\/p>\n<pre class=\"lang-py prettyprint-override\"><code>a if condition else b\n<\/code><\/pre>\n<p>First <code>condition<\/code> is evaluated, then exactly one of either <code>a<\/code> or <code>b<\/code> is evaluated and returned based on the <a href=\"https:\/\/en.wikipedia.org\/wiki\/Boolean_data_type\" rel=\"noreferrer\" title=\"Boolean data type\">Boolean<\/a> value of <code>condition<\/code>. If <code>condition<\/code> evaluates to <code>True<\/code>, then <code>a<\/code> is evaluated and returned but <code>b<\/code> is ignored, or else when <code>b<\/code> is evaluated and returned but <code>a<\/code> is ignored.<\/p>\n<p>This allows short-circuiting because when <code>condition<\/code> is true only <code>a<\/code> is evaluated and <code>b<\/code> is not evaluated at all, but when <code>condition<\/code> is false only <code>b<\/code> is evaluated and <code>a<\/code> is not evaluated at all.<\/p>\n<p>For example:<\/p>\n<pre class=\"lang-py prettyprint-override\"><code>&gt;&gt;&gt; 'true' if True else 'false'\n'true'\n&gt;&gt;&gt; 'true' if False else 'false'\n'false'\n<\/code><\/pre>\n<p>Note that conditionals are an <em>expression<\/em>, not a <em>statement<\/em>. This means you can't use <strong>statements<\/strong> such as <code>pass<\/code>, or assignments with <code>=<\/code> (or &quot;augmented&quot; assignments like <code>+=<\/code>), within a conditional <strong>expression<\/strong>:<\/p>\n<pre class=\"lang-py prettyprint-override\"><code>&gt;&gt;&gt; pass if False else pass\n  File &quot;&lt;stdin&gt;&quot;, line 1\n    pass if False else pass\n         ^\nSyntaxError: invalid syntax\n\n&gt;&gt;&gt; # Python parses this as `x = (1 if False else y) = 2`\n&gt;&gt;&gt; # The `(1 if False else x)` part is actually valid, but\n&gt;&gt;&gt; # it can't be on the left-hand side of `=`.\n&gt;&gt;&gt; x = 1 if False else y = 2\n  File &quot;&lt;stdin&gt;&quot;, line 1\nSyntaxError: cannot assign to conditional expression\n\n&gt;&gt;&gt; # If we parenthesize it instead...\n&gt;&gt;&gt; (x = 1) if False else (y = 2)\n  File &quot;&lt;stdin&gt;&quot;, line 1\n    (x = 1) if False else (y = 2)\n       ^\nSyntaxError: invalid syntax\n<\/code><\/pre>\n<p>(In 3.8 and above, the <code>:=<\/code> &quot;walrus&quot; operator allows simple assignment of values <em>as an expression<\/em>, which is then compatible with this syntax. But please don't write code like that; it will quickly become very difficult to understand.)<\/p>\n<p>Similarly, because it is an expression, the <code>else<\/code> part is <em>mandatory<\/em>:<\/p>\n<pre><code># Invalid syntax: we didn't specify what the value should be if the \n# condition isn't met. It doesn't matter if we can verify that\n# ahead of time.\na if True\n<\/code><\/pre>\n<p>You can, however, use conditional expressions to assign a variable like so:<\/p>\n<pre class=\"lang-py prettyprint-override\"><code>x = a if True else b\n<\/code><\/pre>\n<p>Or for example to return a value:<\/p>\n<pre><code># Of course we should just use the standard library `max`;\n# this is just for demonstration purposes.\ndef my_max(a, b):\n    return a if a &gt; b else b\n<\/code><\/pre>\n<p>Think of the conditional expression as switching between two values. We can use it when we are in a 'one value or another' situation, where we will <em>do the same thing<\/em> with the result, regardless of whether the condition is met. We use the expression to compute the value, and then do something with it. If you need to <em>do something different<\/em> depending on the condition, then use a normal <code>if<\/code> <strong>statement<\/strong> instead.<\/p>\n<hr \/>\n<p>Keep in mind that it's frowned upon by some Pythonistas for several reasons:<\/p>\n<ul>\n<li>The order of the arguments is different from those of the classic <code>condition ? a : b<\/code> ternary operator from many other languages (such as <a href=\"https:\/\/en.wikipedia.org\/wiki\/C_%28programming_language%29\" rel=\"noreferrer\">C<\/a>, <a href=\"https:\/\/en.wikipedia.org\/wiki\/C%2B%2B\" rel=\"noreferrer\">C++<\/a>, <a href=\"https:\/\/en.wikipedia.org\/wiki\/Go_%28programming_language%29\" rel=\"noreferrer\">Go<\/a>, <a href=\"https:\/\/en.wikipedia.org\/wiki\/Perl\" rel=\"noreferrer\">Perl<\/a>, <a href=\"https:\/\/en.wikipedia.org\/wiki\/Ruby_%28programming_language%29\" rel=\"noreferrer\">Ruby<\/a>, <a href=\"https:\/\/en.wikipedia.org\/wiki\/Java_%28programming_language%29\" rel=\"noreferrer\">Java<\/a>, <a href=\"https:\/\/en.wikipedia.org\/wiki\/JavaScript\" rel=\"noreferrer\">JavaScript<\/a>, etc.), which may lead to bugs when people unfamiliar with Python's &quot;surprising&quot; behaviour use it (they may reverse the argument order).<\/li>\n<li>Some find it &quot;unwieldy&quot;, since it goes contrary to the normal flow of thought (thinking of the condition first and then the effects).<\/li>\n<li>Stylistic reasons. (Although the 'inline <code>if<\/code>' can be <em>really<\/em> useful, and make your script more concise, it really does complicate your code)<\/li>\n<\/ul>\n<p>If you're having trouble remembering the order, then remember that when read aloud, you (almost) say what you mean. For example, <code>x = 4 if b &gt; 8 else 9<\/code> is read aloud as <code>x will be 4 if b is greater than 8 otherwise 9<\/code>.<\/p>\n<p>Official documentation:<\/p>\n<ul>\n<li><a href=\"https:\/\/docs.python.org\/3\/reference\/expressions.html#conditional-expressions\" rel=\"noreferrer\" title=\"Conditional expressions\">Conditional expressions<\/a><\/li>\n<li><a href=\"https:\/\/docs.python.org\/3\/faq\/programming.html#is-there-an-equivalent-of-c-s-ternary-operator\" rel=\"noreferrer\" title=\"Is there an equivalent of C\u2019s \u201d?:\u201d ternary operator?\">Is there an equivalent of C\u2019s \u201d?:\u201d ternary operator?<\/a><\/li>\n<\/ul>\n",
        "community_owned_date": null
    },
    {
        "owner": {
            "account_id": 258754,
            "reputation": 379785,
            "user_id": 541136,
            "user_type": "moderator",
            "accept_rate": 96,
            "profile_image": "https:\/\/i.stack.imgur.com\/wftMn.jpg?s=256&g=1",
            "display_name": "Russia Must Remove Putin",
            "link": "https:\/\/stackoverflow.com\/users\/541136\/russia-must-remove-putin"
        },
        "is_accepted": true,
        "score": 8995,
        "last_activity_date": 1648550948,
        "last_edit_date": 1648550948,
        "creation_date": 1415657508,
        "answer_id": 26853961,
        "question_id": 38987,
        "content_license": "CC BY-SA 4.0",
        "body_markdown": "## How can I merge two Python dictionaries in a single expression?\r\n\r\nFor dictionaries `x` and `y`, their shallowly-merged dictionary `z` takes values from `y`, replacing those from `x`.\r\n\r\n- In Python 3.9.0 or greater (released 17 October 2020, [`PEP-584`][1], [discussed here][2]):\r\n  ```python\r\n  z = x | y\r\n  ```\r\n\r\n- In Python 3.5 or greater:\r\n  ```python\r\n  z = {**x, **y}\r\n  ```\r\n- In Python 2, (or 3.4 or lower) write a function:\r\n  ```python\r\n  def merge_two_dicts(x, y):\r\n      z = x.copy()   # start with keys and values of x\r\n      z.update(y)    # modifies z with keys and values of y\r\n      return z\r\n  ```\r\n  and now:\r\n  ```python\r\n  z = merge_two_dicts(x, y)\r\n  ```\r\n\r\n### Explanation\r\n\r\nSay you have two dictionaries and you want to merge them into a new dictionary without altering the original dictionaries:\r\n\r\n```python\r\nx = {&#39;a&#39;: 1, &#39;b&#39;: 2}\r\ny = {&#39;b&#39;: 3, &#39;c&#39;: 4}\r\n```\r\nThe desired result is to get a new dictionary (`z`) with the values merged, and the second dictionary&#39;s values overwriting those from the first.\r\n\r\n```python\r\n&gt;&gt;&gt; z\r\n{&#39;a&#39;: 1, &#39;b&#39;: 3, &#39;c&#39;: 4}\r\n```\r\nA new syntax for this, proposed in [PEP 448][3] and [available as of Python 3.5][4], is \r\n```python\r\nz = {**x, **y}\r\n```\r\nAnd it is indeed a single expression. \r\n\r\nNote that we can merge in with literal notation as well:\r\n```python\r\nz = {**x, &#39;foo&#39;: 1, &#39;bar&#39;: 2, **y}\r\n```\r\nand now: \r\n```python\r\n&gt;&gt;&gt; z\r\n{&#39;a&#39;: 1, &#39;b&#39;: 3, &#39;foo&#39;: 1, &#39;bar&#39;: 2, &#39;c&#39;: 4}\r\n```\r\n\r\nIt is now showing as implemented in the [release schedule for 3.5, PEP 478][5], and it has now made its way into the [What&#39;s New in Python 3.5][6] document.\r\n\r\nHowever, since many organizations are still on Python 2, you may wish to do this in a backward-compatible way. The classically Pythonic way, available in Python 2 and Python 3.0-3.4, is to do this as a two-step process:\r\n```python\r\nz = x.copy()\r\nz.update(y) # which returns None since it mutates z\r\n```\r\nIn both approaches, `y` will come second and its values will replace `x`&#39;s values, thus `b` will point to `3` in our final result.\r\n\r\n## Not yet on Python 3.5, but want a *single expression*\r\n\r\nIf you are not yet on Python 3.5 or need to write backward-compatible code, and you want this in a *single expression*, the most performant while the correct approach is to put it in a function:\r\n```python\r\ndef merge_two_dicts(x, y):\r\n    &quot;&quot;&quot;Given two dictionaries, merge them into a new dict as a shallow copy.&quot;&quot;&quot;\r\n    z = x.copy()\r\n    z.update(y)\r\n    return z\r\n```\r\nand then you have a single expression:\r\n```python\r\nz = merge_two_dicts(x, y)\r\n```\r\nYou can also make a function to merge an arbitrary number of dictionaries, from zero to a very large number:\r\n```python\r\ndef merge_dicts(*dict_args):\r\n    &quot;&quot;&quot;\r\n    Given any number of dictionaries, shallow copy and merge into a new dict,\r\n    precedence goes to key-value pairs in latter dictionaries.\r\n    &quot;&quot;&quot;\r\n    result = {}\r\n    for dictionary in dict_args:\r\n        result.update(dictionary)\r\n    return result\r\n```\r\nThis function will work in Python 2 and 3 for all dictionaries. e.g. given dictionaries `a` to `g`:\r\n```python\r\nz = merge_dicts(a, b, c, d, e, f, g) \r\n```\r\nand key-value pairs in `g` will take precedence over dictionaries `a` to `f`, and so on.\r\n\r\n## Critiques of Other Answers\r\n\r\nDon&#39;t use what you see in the formerly accepted answer:\r\n```python\r\nz = dict(x.items() + y.items())\r\n```\r\nIn Python 2, you create two lists in memory for each dict, create a third list in memory with length equal to the length of the first two put together, and then discard all three lists to create the dict. **In Python 3, this will fail** because you&#39;re adding two `dict_items` objects together, not two lists - \r\n```python\r\n&gt;&gt;&gt; c = dict(a.items() + b.items())\r\nTraceback (most recent call last):\r\n  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;\r\nTypeError: unsupported operand type(s) for +: &#39;dict_items&#39; and &#39;dict_items&#39;\r\n```\r\nand you would have to explicitly create them as lists, e.g. `z = dict(list(x.items()) + list(y.items()))`. This is a waste of resources and computation power. \r\n\r\nSimilarly, taking the union of `items()` in Python 3 (`viewitems()` in Python 2.7) will also fail when values are unhashable objects (like lists, for example). Even if your values are hashable, **since sets are semantically unordered, the behavior is undefined in regards to precedence. So don&#39;t do this:**\r\n```python\r\n&gt;&gt;&gt; c = dict(a.items() | b.items())\r\n```\r\nThis example demonstrates what happens when values are unhashable:\r\n```python\r\n&gt;&gt;&gt; x = {&#39;a&#39;: []}\r\n&gt;&gt;&gt; y = {&#39;b&#39;: []}\r\n&gt;&gt;&gt; dict(x.items() | y.items())\r\nTraceback (most recent call last):\r\n  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;\r\nTypeError: unhashable type: &#39;list&#39;\r\n```\r\nHere&#39;s an example where `y` should have precedence, but instead the value from `x` is retained due to the arbitrary order of sets:\r\n```python\r\n&gt;&gt;&gt; x = {&#39;a&#39;: 2}\r\n&gt;&gt;&gt; y = {&#39;a&#39;: 1}\r\n&gt;&gt;&gt; dict(x.items() | y.items())\r\n{&#39;a&#39;: 2}\r\n```\r\nAnother hack you should not use:\r\n```python\r\nz = dict(x, **y)\r\n```\r\nThis uses the `dict` constructor and is very fast and memory-efficient (even slightly more so than our two-step process) but unless you know precisely what is happening here (that is, the second dict is being passed as keyword arguments to the dict constructor), it&#39;s difficult to read, it&#39;s not the intended usage, and so it is not Pythonic. \r\n\r\nHere&#39;s an example of the usage being [remediated in django][7].\r\n\r\nDictionaries are intended to take hashable keys (e.g. `frozenset`s or tuples), but **this method fails in Python 3 when keys are not strings.**\r\n```python\r\n&gt;&gt;&gt; c = dict(a, **b)\r\nTraceback (most recent call last):\r\n  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;\r\nTypeError: keyword arguments must be strings\r\n```\r\nFrom the [mailing list][8], Guido van Rossum, the creator of the language, wrote:\r\n&gt; I am fine with\r\n&gt; declaring dict({}, **{1:3}) illegal, since after all it is abuse of\r\n&gt; the ** mechanism.\r\n\r\nand \r\n\r\n&gt; Apparently dict(x, **y) is going around as &quot;cool hack&quot; for &quot;call\r\n&gt; x.update(y) and return x&quot;. Personally, I find it more despicable than\r\n&gt; cool.\r\n\r\nIt is my understanding (as well as the understanding of the [creator of the language][9]) that the intended usage for `dict(**y)` is for creating dictionaries for readability purposes, e.g.:\r\n```python\r\ndict(a=1, b=10, c=11)\r\n```\r\ninstead of \r\n```python\r\n{&#39;a&#39;: 1, &#39;b&#39;: 10, &#39;c&#39;: 11}\r\n```\r\n## Response to comments\r\n\r\n&gt; Despite what Guido says, `dict(x, **y)` is in line with the dict specification, which btw. works for both Python 2 and 3. The fact that this only works for string keys is a direct consequence of how keyword parameters work and not a short-coming of dict. Nor is using the ** operator in this place an abuse of the mechanism, in fact, ** was designed precisely to pass dictionaries as keywords. \r\n\r\nAgain, it doesn&#39;t work for 3 when keys are not strings. The implicit calling contract is that namespaces take ordinary dictionaries, while users must only pass keyword arguments that are strings. All other callables enforced it. `dict` broke this consistency in Python 2:\r\n\r\n    &gt;&gt;&gt; foo(**{(&#39;a&#39;, &#39;b&#39;): None})\r\n    Traceback (most recent call last):\r\n      File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;\r\n    TypeError: foo() keywords must be strings\r\n    &gt;&gt;&gt; dict(**{(&#39;a&#39;, &#39;b&#39;): None})\r\n    {(&#39;a&#39;, &#39;b&#39;): None}\r\n\r\nThis inconsistency was bad given other implementations of Python (PyPy, Jython, IronPython). Thus it was fixed in Python 3, as this usage could be a breaking change.\r\n\r\nI submit to you that it is malicious incompetence to intentionally write code that only works in one version of a language or that only works given certain arbitrary constraints.\r\n\r\nMore comments:\r\n\r\n&gt; `dict(x.items() + y.items())` is still the most readable solution for Python 2. Readability counts. \r\n\r\nMy response: `merge_two_dicts(x, y)` actually seems much clearer to me, if we&#39;re actually concerned about readability. And it is not forward compatible, as Python 2 is increasingly deprecated.\r\n\r\n&gt; `{**x, **y}` does not seem to handle nested dictionaries. the contents of nested keys are simply overwritten, not merged [...] I ended up being burnt by these answers that do not merge recursively and I was surprised no one mentioned it. In my interpretation of the word &quot;merging&quot; these answers describe &quot;updating one dict with another&quot;, and not merging.\r\n\r\nYes. I must refer you back to the question, which is asking for a *shallow* merge of ***two*** dictionaries, with the first&#39;s values being overwritten by the second&#39;s - in a single expression.\r\n\r\nAssuming two dictionaries of dictionaries, one might recursively merge them in a single function, but you should be careful not to modify the dictionaries from either source, and the surest way to avoid that is to make a copy when assigning values. As keys must be hashable and are usually therefore immutable, it is pointless to copy them:\r\n\r\n```python\r\nfrom copy import deepcopy\r\n\r\ndef dict_of_dicts_merge(x, y):\r\n    z = {}\r\n    overlapping_keys = x.keys() &amp; y.keys()\r\n    for key in overlapping_keys:\r\n        z[key] = dict_of_dicts_merge(x[key], y[key])\r\n    for key in x.keys() - overlapping_keys:\r\n        z[key] = deepcopy(x[key])\r\n    for key in y.keys() - overlapping_keys:\r\n        z[key] = deepcopy(y[key])\r\n    return z\r\n```\r\nUsage:\r\n```python\r\n&gt;&gt;&gt; x = {&#39;a&#39;:{1:{}}, &#39;b&#39;: {2:{}}}\r\n&gt;&gt;&gt; y = {&#39;b&#39;:{10:{}}, &#39;c&#39;: {11:{}}}\r\n&gt;&gt;&gt; dict_of_dicts_merge(x, y)\r\n{&#39;b&#39;: {2: {}, 10: {}}, &#39;a&#39;: {1: {}}, &#39;c&#39;: {11: {}}}\r\n```\r\nComing up with contingencies for other value types is far beyond the scope of this question, so I will point you at [my answer to the canonical question on a &quot;Dictionaries of dictionaries merge&quot;][10].\r\n\r\n## Less Performant But Correct Ad-hocs\r\n\r\nThese approaches are less performant, but they will provide correct behavior.\r\nThey will be *much less* performant than `copy` and `update` or the new unpacking because they iterate through each key-value pair at a higher level of abstraction, but they *do* respect the order of precedence (latter dictionaries have precedence)\r\n\r\nYou can also chain the dictionaries manually inside a [dict comprehension][11]:\r\n```python\r\n{k: v for d in dicts for k, v in d.items()} # iteritems in Python 2.7\r\n```\r\nor in Python 2.6 (and perhaps as early as 2.4 when generator expressions were introduced):\r\n```python\r\ndict((k, v) for d in dicts for k, v in d.items()) # iteritems in Python 2\r\n```\r\n`itertools.chain` will chain the iterators over the key-value pairs in the correct order:\r\n```python\r\nfrom itertools import chain\r\nz = dict(chain(x.items(), y.items())) # iteritems in Python 2\r\n```\r\n## Performance Analysis\r\n\r\nI&#39;m only going to do the performance analysis of the usages known to behave correctly. (Self-contained so you can copy and paste yourself.)\r\n```python\r\nfrom timeit import repeat\r\nfrom itertools import chain\r\n\r\nx = dict.fromkeys(&#39;abcdefg&#39;)\r\ny = dict.fromkeys(&#39;efghijk&#39;)\r\n\r\ndef merge_two_dicts(x, y):\r\n    z = x.copy()\r\n    z.update(y)\r\n    return z\r\n\r\nmin(repeat(lambda: {**x, **y}))\r\nmin(repeat(lambda: merge_two_dicts(x, y)))\r\nmin(repeat(lambda: {k: v for d in (x, y) for k, v in d.items()}))\r\nmin(repeat(lambda: dict(chain(x.items(), y.items()))))\r\nmin(repeat(lambda: dict(item for d in (x, y) for item in d.items())))\r\n```\r\n\r\nIn Python 3.8.1, NixOS:\r\n\r\n```python\r\n&gt;&gt;&gt; min(repeat(lambda: {**x, **y}))\r\n1.0804965235292912\r\n&gt;&gt;&gt; min(repeat(lambda: merge_two_dicts(x, y)))\r\n1.636518670246005\r\n&gt;&gt;&gt; min(repeat(lambda: {k: v for d in (x, y) for k, v in d.items()}))\r\n3.1779992282390594\r\n&gt;&gt;&gt; min(repeat(lambda: dict(chain(x.items(), y.items()))))\r\n2.740647904574871\r\n&gt;&gt;&gt; min(repeat(lambda: dict(item for d in (x, y) for item in d.items())))\r\n4.266070580109954\r\n```\r\n\r\n```shell\r\n$ uname -a\r\nLinux nixos 4.19.113 #1-NixOS SMP Wed Mar 25 07:06:15 UTC 2020 x86_64 GNU\/Linux\r\n```\r\n\r\n## Resources on Dictionaries\r\n\r\n- [My explanation of Python&#39;s **dictionary implementation**, updated for 3.6.][12]\r\n- [Answer on how to add new keys to a dictionary][13]\r\n- [Mapping two lists into a dictionary][14]\r\n- [The official Python docs on dictionaries][15] \r\n- [The Dictionary Even Mightier][16] - talk by Brandon Rhodes at Pycon 2017\r\n- [Modern Python Dictionaries, A Confluence of Great Ideas][17] - talk by Raymond Hettinger at Pycon 2017\r\n\r\n\r\n  [1]: https:\/\/www.python.org\/dev\/peps\/pep-0584\/\r\n  [2]: https:\/\/bugs.python.org\/issue36144\r\n  [3]: https:\/\/www.python.org\/dev\/peps\/pep-0448\r\n  [4]: https:\/\/mail.python.org\/pipermail\/python-dev\/2015-February\/138564.html\r\n  [5]: https:\/\/www.python.org\/dev\/peps\/pep-0478\/#features-for-3-5\r\n  [6]: https:\/\/docs.python.org\/dev\/whatsnew\/3.5.html#pep-448-additional-unpacking-generalizations\r\n  [7]: https:\/\/code.djangoproject.com\/attachment\/ticket\/13357\/django-pypy.2.diff\r\n  [8]: https:\/\/mail.python.org\/pipermail\/python-dev\/2010-April\/099459.html\r\n  [9]: https:\/\/mail.python.org\/pipermail\/python-dev\/2010-April\/099485.html\r\n  [10]: https:\/\/stackoverflow.com\/a\/24088493\/541136\r\n  [11]: https:\/\/www.python.org\/dev\/peps\/pep-0274\/\r\n  [12]: https:\/\/stackoverflow.com\/questions\/327311\/how-are-pythons-built-in-dictionaries-implemented\/44509302#44509302\r\n  [13]: https:\/\/stackoverflow.com\/questions\/1024847\/add-new-keys-to-a-dictionary\/27208535#27208535\r\n  [14]: https:\/\/stackoverflow.com\/questions\/209840\/map-two-lists-into-a-dictionary-in-python\/33737067#33737067\r\n  [15]: https:\/\/docs.python.org\/3\/tutorial\/datastructures.html#dictionaries\r\n  [16]: https:\/\/www.youtube.com\/watch?v=66P5FMkWoVU\r\n  [17]: https:\/\/www.youtube.com\/watch?v=npw4s1QTmPg",
        "body": "<h2>How can I merge two Python dictionaries in a single expression?<\/h2>\n<p>For dictionaries <code>x<\/code> and <code>y<\/code>, their shallowly-merged dictionary <code>z<\/code> takes values from <code>y<\/code>, replacing those from <code>x<\/code>.<\/p>\n<ul>\n<li><p>In Python 3.9.0 or greater (released 17 October 2020, <a href=\"https:\/\/www.python.org\/dev\/peps\/pep-0584\/\" rel=\"noreferrer\"><code>PEP-584<\/code><\/a>, <a href=\"https:\/\/bugs.python.org\/issue36144\" rel=\"noreferrer\">discussed here<\/a>):<\/p>\n<pre class=\"lang-py prettyprint-override\"><code>z = x | y\n<\/code><\/pre>\n<\/li>\n<li><p>In Python 3.5 or greater:<\/p>\n<pre class=\"lang-py prettyprint-override\"><code>z = {**x, **y}\n<\/code><\/pre>\n<\/li>\n<li><p>In Python 2, (or 3.4 or lower) write a function:<\/p>\n<pre class=\"lang-py prettyprint-override\"><code>def merge_two_dicts(x, y):\n    z = x.copy()   # start with keys and values of x\n    z.update(y)    # modifies z with keys and values of y\n    return z\n<\/code><\/pre>\n<p>and now:<\/p>\n<pre class=\"lang-py prettyprint-override\"><code>z = merge_two_dicts(x, y)\n<\/code><\/pre>\n<\/li>\n<\/ul>\n<h3>Explanation<\/h3>\n<p>Say you have two dictionaries and you want to merge them into a new dictionary without altering the original dictionaries:<\/p>\n<pre class=\"lang-py prettyprint-override\"><code>x = {'a': 1, 'b': 2}\ny = {'b': 3, 'c': 4}\n<\/code><\/pre>\n<p>The desired result is to get a new dictionary (<code>z<\/code>) with the values merged, and the second dictionary's values overwriting those from the first.<\/p>\n<pre class=\"lang-py prettyprint-override\"><code>&gt;&gt;&gt; z\n{'a': 1, 'b': 3, 'c': 4}\n<\/code><\/pre>\n<p>A new syntax for this, proposed in <a href=\"https:\/\/www.python.org\/dev\/peps\/pep-0448\" rel=\"noreferrer\">PEP 448<\/a> and <a href=\"https:\/\/mail.python.org\/pipermail\/python-dev\/2015-February\/138564.html\" rel=\"noreferrer\">available as of Python 3.5<\/a>, is<\/p>\n<pre class=\"lang-py prettyprint-override\"><code>z = {**x, **y}\n<\/code><\/pre>\n<p>And it is indeed a single expression.<\/p>\n<p>Note that we can merge in with literal notation as well:<\/p>\n<pre class=\"lang-py prettyprint-override\"><code>z = {**x, 'foo': 1, 'bar': 2, **y}\n<\/code><\/pre>\n<p>and now:<\/p>\n<pre class=\"lang-py prettyprint-override\"><code>&gt;&gt;&gt; z\n{'a': 1, 'b': 3, 'foo': 1, 'bar': 2, 'c': 4}\n<\/code><\/pre>\n<p>It is now showing as implemented in the <a href=\"https:\/\/www.python.org\/dev\/peps\/pep-0478\/#features-for-3-5\" rel=\"noreferrer\">release schedule for 3.5, PEP 478<\/a>, and it has now made its way into the <a href=\"https:\/\/docs.python.org\/dev\/whatsnew\/3.5.html#pep-448-additional-unpacking-generalizations\" rel=\"noreferrer\">What's New in Python 3.5<\/a> document.<\/p>\n<p>However, since many organizations are still on Python 2, you may wish to do this in a backward-compatible way. The classically Pythonic way, available in Python 2 and Python 3.0-3.4, is to do this as a two-step process:<\/p>\n<pre class=\"lang-py prettyprint-override\"><code>z = x.copy()\nz.update(y) # which returns None since it mutates z\n<\/code><\/pre>\n<p>In both approaches, <code>y<\/code> will come second and its values will replace <code>x<\/code>'s values, thus <code>b<\/code> will point to <code>3<\/code> in our final result.<\/p>\n<h2>Not yet on Python 3.5, but want a <em>single expression<\/em><\/h2>\n<p>If you are not yet on Python 3.5 or need to write backward-compatible code, and you want this in a <em>single expression<\/em>, the most performant while the correct approach is to put it in a function:<\/p>\n<pre class=\"lang-py prettyprint-override\"><code>def merge_two_dicts(x, y):\n    &quot;&quot;&quot;Given two dictionaries, merge them into a new dict as a shallow copy.&quot;&quot;&quot;\n    z = x.copy()\n    z.update(y)\n    return z\n<\/code><\/pre>\n<p>and then you have a single expression:<\/p>\n<pre class=\"lang-py prettyprint-override\"><code>z = merge_two_dicts(x, y)\n<\/code><\/pre>\n<p>You can also make a function to merge an arbitrary number of dictionaries, from zero to a very large number:<\/p>\n<pre class=\"lang-py prettyprint-override\"><code>def merge_dicts(*dict_args):\n    &quot;&quot;&quot;\n    Given any number of dictionaries, shallow copy and merge into a new dict,\n    precedence goes to key-value pairs in latter dictionaries.\n    &quot;&quot;&quot;\n    result = {}\n    for dictionary in dict_args:\n        result.update(dictionary)\n    return result\n<\/code><\/pre>\n<p>This function will work in Python 2 and 3 for all dictionaries. e.g. given dictionaries <code>a<\/code> to <code>g<\/code>:<\/p>\n<pre class=\"lang-py prettyprint-override\"><code>z = merge_dicts(a, b, c, d, e, f, g) \n<\/code><\/pre>\n<p>and key-value pairs in <code>g<\/code> will take precedence over dictionaries <code>a<\/code> to <code>f<\/code>, and so on.<\/p>\n<h2>Critiques of Other Answers<\/h2>\n<p>Don't use what you see in the formerly accepted answer:<\/p>\n<pre class=\"lang-py prettyprint-override\"><code>z = dict(x.items() + y.items())\n<\/code><\/pre>\n<p>In Python 2, you create two lists in memory for each dict, create a third list in memory with length equal to the length of the first two put together, and then discard all three lists to create the dict. <strong>In Python 3, this will fail<\/strong> because you're adding two <code>dict_items<\/code> objects together, not two lists -<\/p>\n<pre class=\"lang-py prettyprint-override\"><code>&gt;&gt;&gt; c = dict(a.items() + b.items())\nTraceback (most recent call last):\n  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;\nTypeError: unsupported operand type(s) for +: 'dict_items' and 'dict_items'\n<\/code><\/pre>\n<p>and you would have to explicitly create them as lists, e.g. <code>z = dict(list(x.items()) + list(y.items()))<\/code>. This is a waste of resources and computation power.<\/p>\n<p>Similarly, taking the union of <code>items()<\/code> in Python 3 (<code>viewitems()<\/code> in Python 2.7) will also fail when values are unhashable objects (like lists, for example). Even if your values are hashable, <strong>since sets are semantically unordered, the behavior is undefined in regards to precedence. So don't do this:<\/strong><\/p>\n<pre class=\"lang-py prettyprint-override\"><code>&gt;&gt;&gt; c = dict(a.items() | b.items())\n<\/code><\/pre>\n<p>This example demonstrates what happens when values are unhashable:<\/p>\n<pre class=\"lang-py prettyprint-override\"><code>&gt;&gt;&gt; x = {'a': []}\n&gt;&gt;&gt; y = {'b': []}\n&gt;&gt;&gt; dict(x.items() | y.items())\nTraceback (most recent call last):\n  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;\nTypeError: unhashable type: 'list'\n<\/code><\/pre>\n<p>Here's an example where <code>y<\/code> should have precedence, but instead the value from <code>x<\/code> is retained due to the arbitrary order of sets:<\/p>\n<pre class=\"lang-py prettyprint-override\"><code>&gt;&gt;&gt; x = {'a': 2}\n&gt;&gt;&gt; y = {'a': 1}\n&gt;&gt;&gt; dict(x.items() | y.items())\n{'a': 2}\n<\/code><\/pre>\n<p>Another hack you should not use:<\/p>\n<pre class=\"lang-py prettyprint-override\"><code>z = dict(x, **y)\n<\/code><\/pre>\n<p>This uses the <code>dict<\/code> constructor and is very fast and memory-efficient (even slightly more so than our two-step process) but unless you know precisely what is happening here (that is, the second dict is being passed as keyword arguments to the dict constructor), it's difficult to read, it's not the intended usage, and so it is not Pythonic.<\/p>\n<p>Here's an example of the usage being <a href=\"https:\/\/code.djangoproject.com\/attachment\/ticket\/13357\/django-pypy.2.diff\" rel=\"noreferrer\">remediated in django<\/a>.<\/p>\n<p>Dictionaries are intended to take hashable keys (e.g. <code>frozenset<\/code>s or tuples), but <strong>this method fails in Python 3 when keys are not strings.<\/strong><\/p>\n<pre class=\"lang-py prettyprint-override\"><code>&gt;&gt;&gt; c = dict(a, **b)\nTraceback (most recent call last):\n  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;\nTypeError: keyword arguments must be strings\n<\/code><\/pre>\n<p>From the <a href=\"https:\/\/mail.python.org\/pipermail\/python-dev\/2010-April\/099459.html\" rel=\"noreferrer\">mailing list<\/a>, Guido van Rossum, the creator of the language, wrote:<\/p>\n<blockquote>\n<p>I am fine with\ndeclaring dict({}, **{1:3}) illegal, since after all it is abuse of\nthe ** mechanism.<\/p>\n<\/blockquote>\n<p>and<\/p>\n<blockquote>\n<p>Apparently dict(x, **y) is going around as &quot;cool hack&quot; for &quot;call\nx.update(y) and return x&quot;. Personally, I find it more despicable than\ncool.<\/p>\n<\/blockquote>\n<p>It is my understanding (as well as the understanding of the <a href=\"https:\/\/mail.python.org\/pipermail\/python-dev\/2010-April\/099485.html\" rel=\"noreferrer\">creator of the language<\/a>) that the intended usage for <code>dict(**y)<\/code> is for creating dictionaries for readability purposes, e.g.:<\/p>\n<pre class=\"lang-py prettyprint-override\"><code>dict(a=1, b=10, c=11)\n<\/code><\/pre>\n<p>instead of<\/p>\n<pre class=\"lang-py prettyprint-override\"><code>{'a': 1, 'b': 10, 'c': 11}\n<\/code><\/pre>\n<h2>Response to comments<\/h2>\n<blockquote>\n<p>Despite what Guido says, <code>dict(x, **y)<\/code> is in line with the dict specification, which btw. works for both Python 2 and 3. The fact that this only works for string keys is a direct consequence of how keyword parameters work and not a short-coming of dict. Nor is using the ** operator in this place an abuse of the mechanism, in fact, ** was designed precisely to pass dictionaries as keywords.<\/p>\n<\/blockquote>\n<p>Again, it doesn't work for 3 when keys are not strings. The implicit calling contract is that namespaces take ordinary dictionaries, while users must only pass keyword arguments that are strings. All other callables enforced it. <code>dict<\/code> broke this consistency in Python 2:<\/p>\n<pre><code>&gt;&gt;&gt; foo(**{('a', 'b'): None})\nTraceback (most recent call last):\n  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;\nTypeError: foo() keywords must be strings\n&gt;&gt;&gt; dict(**{('a', 'b'): None})\n{('a', 'b'): None}\n<\/code><\/pre>\n<p>This inconsistency was bad given other implementations of Python (PyPy, Jython, IronPython). Thus it was fixed in Python 3, as this usage could be a breaking change.<\/p>\n<p>I submit to you that it is malicious incompetence to intentionally write code that only works in one version of a language or that only works given certain arbitrary constraints.<\/p>\n<p>More comments:<\/p>\n<blockquote>\n<p><code>dict(x.items() + y.items())<\/code> is still the most readable solution for Python 2. Readability counts.<\/p>\n<\/blockquote>\n<p>My response: <code>merge_two_dicts(x, y)<\/code> actually seems much clearer to me, if we're actually concerned about readability. And it is not forward compatible, as Python 2 is increasingly deprecated.<\/p>\n<blockquote>\n<p><code>{**x, **y}<\/code> does not seem to handle nested dictionaries. the contents of nested keys are simply overwritten, not merged [...] I ended up being burnt by these answers that do not merge recursively and I was surprised no one mentioned it. In my interpretation of the word &quot;merging&quot; these answers describe &quot;updating one dict with another&quot;, and not merging.<\/p>\n<\/blockquote>\n<p>Yes. I must refer you back to the question, which is asking for a <em>shallow<\/em> merge of <em><strong>two<\/strong><\/em> dictionaries, with the first's values being overwritten by the second's - in a single expression.<\/p>\n<p>Assuming two dictionaries of dictionaries, one might recursively merge them in a single function, but you should be careful not to modify the dictionaries from either source, and the surest way to avoid that is to make a copy when assigning values. As keys must be hashable and are usually therefore immutable, it is pointless to copy them:<\/p>\n<pre class=\"lang-py prettyprint-override\"><code>from copy import deepcopy\n\ndef dict_of_dicts_merge(x, y):\n    z = {}\n    overlapping_keys = x.keys() &amp; y.keys()\n    for key in overlapping_keys:\n        z[key] = dict_of_dicts_merge(x[key], y[key])\n    for key in x.keys() - overlapping_keys:\n        z[key] = deepcopy(x[key])\n    for key in y.keys() - overlapping_keys:\n        z[key] = deepcopy(y[key])\n    return z\n<\/code><\/pre>\n<p>Usage:<\/p>\n<pre class=\"lang-py prettyprint-override\"><code>&gt;&gt;&gt; x = {'a':{1:{}}, 'b': {2:{}}}\n&gt;&gt;&gt; y = {'b':{10:{}}, 'c': {11:{}}}\n&gt;&gt;&gt; dict_of_dicts_merge(x, y)\n{'b': {2: {}, 10: {}}, 'a': {1: {}}, 'c': {11: {}}}\n<\/code><\/pre>\n<p>Coming up with contingencies for other value types is far beyond the scope of this question, so I will point you at <a href=\"https:\/\/stackoverflow.com\/a\/24088493\/541136\">my answer to the canonical question on a &quot;Dictionaries of dictionaries merge&quot;<\/a>.<\/p>\n<h2>Less Performant But Correct Ad-hocs<\/h2>\n<p>These approaches are less performant, but they will provide correct behavior.\nThey will be <em>much less<\/em> performant than <code>copy<\/code> and <code>update<\/code> or the new unpacking because they iterate through each key-value pair at a higher level of abstraction, but they <em>do<\/em> respect the order of precedence (latter dictionaries have precedence)<\/p>\n<p>You can also chain the dictionaries manually inside a <a href=\"https:\/\/www.python.org\/dev\/peps\/pep-0274\/\" rel=\"noreferrer\">dict comprehension<\/a>:<\/p>\n<pre class=\"lang-py prettyprint-override\"><code>{k: v for d in dicts for k, v in d.items()} # iteritems in Python 2.7\n<\/code><\/pre>\n<p>or in Python 2.6 (and perhaps as early as 2.4 when generator expressions were introduced):<\/p>\n<pre class=\"lang-py prettyprint-override\"><code>dict((k, v) for d in dicts for k, v in d.items()) # iteritems in Python 2\n<\/code><\/pre>\n<p><code>itertools.chain<\/code> will chain the iterators over the key-value pairs in the correct order:<\/p>\n<pre class=\"lang-py prettyprint-override\"><code>from itertools import chain\nz = dict(chain(x.items(), y.items())) # iteritems in Python 2\n<\/code><\/pre>\n<h2>Performance Analysis<\/h2>\n<p>I'm only going to do the performance analysis of the usages known to behave correctly. (Self-contained so you can copy and paste yourself.)<\/p>\n<pre class=\"lang-py prettyprint-override\"><code>from timeit import repeat\nfrom itertools import chain\n\nx = dict.fromkeys('abcdefg')\ny = dict.fromkeys('efghijk')\n\ndef merge_two_dicts(x, y):\n    z = x.copy()\n    z.update(y)\n    return z\n\nmin(repeat(lambda: {**x, **y}))\nmin(repeat(lambda: merge_two_dicts(x, y)))\nmin(repeat(lambda: {k: v for d in (x, y) for k, v in d.items()}))\nmin(repeat(lambda: dict(chain(x.items(), y.items()))))\nmin(repeat(lambda: dict(item for d in (x, y) for item in d.items())))\n<\/code><\/pre>\n<p>In Python 3.8.1, NixOS:<\/p>\n<pre class=\"lang-py prettyprint-override\"><code>&gt;&gt;&gt; min(repeat(lambda: {**x, **y}))\n1.0804965235292912\n&gt;&gt;&gt; min(repeat(lambda: merge_two_dicts(x, y)))\n1.636518670246005\n&gt;&gt;&gt; min(repeat(lambda: {k: v for d in (x, y) for k, v in d.items()}))\n3.1779992282390594\n&gt;&gt;&gt; min(repeat(lambda: dict(chain(x.items(), y.items()))))\n2.740647904574871\n&gt;&gt;&gt; min(repeat(lambda: dict(item for d in (x, y) for item in d.items())))\n4.266070580109954\n<\/code><\/pre>\n<pre class=\"lang-sh prettyprint-override\"><code>$ uname -a\nLinux nixos 4.19.113 #1-NixOS SMP Wed Mar 25 07:06:15 UTC 2020 x86_64 GNU\/Linux\n<\/code><\/pre>\n<h2>Resources on Dictionaries<\/h2>\n<ul>\n<li><a href=\"https:\/\/stackoverflow.com\/questions\/327311\/how-are-pythons-built-in-dictionaries-implemented\/44509302#44509302\">My explanation of Python's <strong>dictionary implementation<\/strong>, updated for 3.6.<\/a><\/li>\n<li><a href=\"https:\/\/stackoverflow.com\/questions\/1024847\/add-new-keys-to-a-dictionary\/27208535#27208535\">Answer on how to add new keys to a dictionary<\/a><\/li>\n<li><a href=\"https:\/\/stackoverflow.com\/questions\/209840\/map-two-lists-into-a-dictionary-in-python\/33737067#33737067\">Mapping two lists into a dictionary<\/a><\/li>\n<li><a href=\"https:\/\/docs.python.org\/3\/tutorial\/datastructures.html#dictionaries\" rel=\"noreferrer\">The official Python docs on dictionaries<\/a><\/li>\n<li><a href=\"https:\/\/www.youtube.com\/watch?v=66P5FMkWoVU\" rel=\"noreferrer\">The Dictionary Even Mightier<\/a> - talk by Brandon Rhodes at Pycon 2017<\/li>\n<li><a href=\"https:\/\/www.youtube.com\/watch?v=npw4s1QTmPg\" rel=\"noreferrer\">Modern Python Dictionaries, A Confluence of Great Ideas<\/a> - talk by Raymond Hettinger at Pycon 2017<\/li>\n<\/ul>\n",
        "community_owned_date": null
    },
    {
        "owner": {
            "account_id": 6018,
            "reputation": 583451,
            "user_id": 9951,
            "user_type": "registered",
            "accept_rate": 78,
            "profile_image": "https:\/\/i.stack.imgur.com\/CIFG8.png?s=256&g=1",
            "display_name": "Bite code",
            "link": "https:\/\/stackoverflow.com\/users\/9951\/bite-code"
        },
        "is_accepted": false,
        "score": 8950,
        "last_activity_date": 1701887004,
        "last_edit_date": 1701887004,
        "creation_date": 1309865390,
        "answer_id": 6581949,
        "question_id": 100003,
        "content_license": "CC BY-SA 4.0",
        "body_markdown": "Classes as objects\r\n==================\r\n\r\nPrior to delving into metaclasses, a solid grasp of Python classes is beneficial. Python holds a particularly distinctive concept of classes, a notion it adopts from the Smalltalk language.\r\n\r\nIn most languages, classes are just pieces of code that describe how to produce an object. That is somewhat true in Python too:\r\n\r\n    &gt;&gt;&gt; class ObjectCreator(object):\r\n    ...     pass\r\n\r\n    &gt;&gt;&gt; my_object = ObjectCreator()\r\n    &gt;&gt;&gt; print(my_object)\r\n        &lt;__main__.ObjectCreator object at 0x8974f2c&gt;\r\n\r\nBut classes are more than that in Python. **Classes are objects too.**\r\n\r\nYes, objects.\r\n\r\nWhen a Python script runs, every line of code is executed from top to bottom. When the Python interpreter encounters the `class` keyword, Python creates an **object** out of the &quot;description&quot; of the class that follows. Thus, the following instruction\r\n\r\n    &gt;&gt;&gt; class ObjectCreator(object):\r\n    ...     pass\r\n\r\n...creates an *object* with the name `ObjectCreator`!\r\n\r\nThis object (the class) is itself capable of creating objects (called *instances*).\r\n\r\nBut still, it&#39;s an object. Therefore, like all objects:\r\n\r\n- you can assign it to a variable&lt;sup&gt;1&lt;\/sup&gt;\r\n    ```\r\n    JustAnotherVariable = ObjectCreator\r\n    ```\r\n- you can attach attributes to it\r\n    ```\r\n    ObjectCreator.class_attribute = &#39;foo&#39;\r\n    ```\r\n- you can pass it as a function parameter\r\n    ```\r\n    print(ObjectCreator)\r\n    ```\r\n\r\n&lt;sup&gt;&lt;sup&gt;1&lt;\/sup&gt; Note that merely assigning it to another variable doesn&#39;t change the class&#39;s `__name__`, i.e.,\r\n\r\n```\r\n&gt;&gt;&gt; print(JustAnotherVariable)\r\n    &lt;class &#39;__main__.ObjectCreator&#39;&gt;\r\n\r\n&gt;&gt;&gt; print(JustAnotherVariable())\r\n    &lt;__main__.ObjectCreator object at 0x8997b4c&gt;\r\n```\r\n&lt;\/sup&gt;\r\n\r\n\r\n\r\nCreating classes dynamically\r\n============================\r\n\r\nSince classes are objects, you can create them on the fly, like any object.\r\n\r\nFirst, you can create a class in a function using `class`:\r\n\r\n    &gt;&gt;&gt; def choose_class(name):\r\n    ...     if name == &#39;foo&#39;:\r\n    ...         class Foo(object):\r\n    ...             pass\r\n    ...         return Foo # return the class, not an instance\r\n    ...     else:\r\n    ...         class Bar(object):\r\n    ...             pass\r\n    ...         return Bar\r\n\r\n    &gt;&gt;&gt; MyClass = choose_class(&#39;foo&#39;)\r\n\r\n    &gt;&gt;&gt; print(MyClass) # the function returns a class, not an instance\r\n        &lt;class &#39;__main__.Foo&#39;&gt;\r\n\r\n    &gt;&gt;&gt; print(MyClass()) # you can create an object from this class\r\n        &lt;__main__.Foo object at 0x89c6d4c&gt;\r\n\r\n\r\nBut it&#39;s not so dynamic, since you still have to write the whole class yourself.\r\n\r\nSince classes are objects, they must be generated by something.\r\n\r\nWhen you use the `class` keyword, Python creates this object automatically. But as\r\nwith most things in Python, it gives you a way to do it manually.\r\n\r\nRemember the function `type`? The good old function that lets you know what\r\ntype an object is:\r\n\r\n    &gt;&gt;&gt; print(type(1))\r\n        &lt;type &#39;int&#39;&gt;\r\n\r\n    &gt;&gt;&gt; print(type(&quot;1&quot;))\r\n        &lt;type &#39;str&#39;&gt;\r\n\r\n    &gt;&gt;&gt; print(type(ObjectCreator))\r\n        &lt;type &#39;type&#39;&gt;\r\n\r\n    &gt;&gt;&gt; print(type(ObjectCreator()))\r\n        &lt;class &#39;__main__.ObjectCreator&#39;&gt;\r\n\r\nWell, [`type`][1] has also a completely different ability: it can create classes on the fly. `type` can take the description of a class as parameters,\r\nand return a class.\r\n\r\n(I  know, it&#39;s silly that the same function can have two completely different uses according to the parameters you pass to it. It&#39;s an issue due to backward\r\ncompatibility in Python)\r\n\r\n`type` works this way:\r\n\r\n    type(name, bases, attrs)\r\n\r\nWhere:\r\n\r\n- **`name`**: name of the class\r\n- **`bases`**: tuple of the parent class (for inheritance, can be empty)\r\n- **`attrs`**: dictionary containing attributes names and values\r\n\r\n\r\ne.g.:\r\n\r\n    &gt;&gt;&gt; class MyShinyClass(object):\r\n    ...     pass\r\n\r\ncan be created manually this way:\r\n\r\n    &gt;&gt;&gt; MyShinyClass = type(&#39;MyShinyClass&#39;, (), {}) # returns a class object\r\n    &gt;&gt;&gt; print(MyShinyClass)\r\n        &lt;class &#39;__main__.MyShinyClass&#39;&gt;\r\n\r\n    &gt;&gt;&gt; print(MyShinyClass()) # create an instance with the class\r\n        &lt;__main__.MyShinyClass object at 0x8997cec&gt;\r\n\r\nYou&#39;ll notice that we use `MyShinyClass` as the name of the class\r\nand as the variable to hold the class reference. They can be different,\r\nbut there is no reason to complicate things.\r\n\r\n`type` accepts a dictionary to define the attributes of the class. So:\r\n\r\n    &gt;&gt;&gt; class Foo(object):\r\n    ...     bar = True\r\n\r\nCan be translated to:\r\n\r\n    &gt;&gt;&gt; Foo = type(&#39;Foo&#39;, (), {&#39;bar&#39;:True})\r\n\r\nAnd used as a normal class:\r\n\r\n    &gt;&gt;&gt; print(Foo)\r\n        &lt;class &#39;__main__.Foo&#39;&gt;\r\n\r\n    &gt;&gt;&gt; print(Foo.bar)\r\n        True\r\n\r\n    &gt;&gt;&gt; f = Foo()\r\n    &gt;&gt;&gt; print(f)\r\n        &lt;__main__.Foo object at 0x8a9b84c&gt;\r\n\r\n    &gt;&gt;&gt; print(f.bar)\r\n        True\r\n\r\nAnd of course, you can inherit from it, so:\r\n\r\n    &gt;&gt;&gt; class FooChild(Foo):\r\n    ...     pass\r\n\r\nwould be:\r\n\r\n    &gt;&gt;&gt; FooChild = type(&#39;FooChild&#39;, (Foo,), {})\r\n    &gt;&gt;&gt; print(FooChild)\r\n        &lt;class &#39;__main__.FooChild&#39;&gt;\r\n\r\n    &gt;&gt;&gt; print(FooChild.bar) # bar is inherited from Foo\r\n        True\r\n\r\nEventually, you&#39;ll want to add methods to your class. Just define a function\r\nwith the proper signature and assign it as an attribute.\r\n\r\n    &gt;&gt;&gt; def echo_bar(self):\r\n    ...     print(self.bar)\r\n\r\n    &gt;&gt;&gt; FooChild = type(&#39;FooChild&#39;, (Foo,), {&#39;echo_bar&#39;: echo_bar})\r\n\r\n    &gt;&gt;&gt; hasattr(Foo, &#39;echo_bar&#39;)\r\n        False\r\n\r\n    &gt;&gt;&gt; hasattr(FooChild, &#39;echo_bar&#39;)\r\n        True\r\n\r\n    &gt;&gt;&gt; my_foo = FooChild()\r\n    &gt;&gt;&gt; my_foo.echo_bar()\r\n        True\r\n\r\nAnd you can add even more methods after you dynamically create the class, just like adding methods to a normally created class object.\r\n\r\n    &gt;&gt;&gt; def echo_bar_more(self):\r\n    ...     print(&#39;yet another method&#39;)\r\n\r\n    &gt;&gt;&gt; FooChild.echo_bar_more = echo_bar_more\r\n    &gt;&gt;&gt; hasattr(FooChild, &#39;echo_bar_more&#39;)\r\n        True\r\n\r\nYou see where we are going: in Python, classes are objects, and you can create a class on the fly, dynamically.\r\n\r\nThis is what Python does when you use the keyword `class`, and it does so by using a metaclass.\r\n\r\nWhat are metaclasses (finally)\r\n==============================\r\n\r\nMetaclasses are the &#39;stuff&#39; that creates classes.\r\n\r\nYou define classes in order to create objects, right?\r\n\r\nBut we learned that Python classes are objects.\r\n\r\nWell, metaclasses are what create these objects. They are the classes&#39; classes,\r\nyou can picture them this way:\r\n\r\n    MyClass = MetaClass()\r\n    my_object = MyClass()\r\n\r\nYou&#39;ve seen that `type` lets you do something like this:\r\n\r\n    MyClass = type(&#39;MyClass&#39;, (), {})\r\n\r\nIt&#39;s because the function `type` is in fact a metaclass. `type` is the\r\nmetaclass Python uses to create all classes behind the scenes.\r\n\r\nNow you wonder &quot;why the heck is it written in lowercase, and not `Type`?&quot;\r\n\r\nWell, I guess it&#39;s a matter of consistency with `str`, the class that creates\r\nstrings objects, and `int` the class that creates integer objects. `type` is\r\njust the class that creates class objects.\r\n\r\nYou see that by checking the `__class__` attribute.\r\n\r\nEverything, and I mean everything, is an object in Python. That includes integers,\r\nstrings, functions and classes. All of them are objects. And all of them have\r\nbeen created from a class:\r\n\r\n    &gt;&gt;&gt; age = 35\r\n    &gt;&gt;&gt; age.__class__\r\n        &lt;type &#39;int&#39;&gt;\r\n\r\n    &gt;&gt;&gt; name = &#39;bob&#39;\r\n    &gt;&gt;&gt; name.__class__\r\n        &lt;type &#39;str&#39;&gt;\r\n\r\n    &gt;&gt;&gt; def foo(): pass\r\n    &gt;&gt;&gt; foo.__class__\r\n        &lt;type &#39;function&#39;&gt;\r\n\r\n    &gt;&gt;&gt; class Bar(object): pass\r\n    &gt;&gt;&gt; b = Bar()\r\n    &gt;&gt;&gt; b.__class__\r\n        &lt;class &#39;__main__.Bar&#39;&gt;\r\n\r\nNow, what is the `__class__` of any `__class__` ?\r\n\r\n    &gt;&gt;&gt; age.__class__.__class__\r\n        &lt;type &#39;type&#39;&gt;\r\n\r\n    &gt;&gt;&gt; name.__class__.__class__\r\n        &lt;type &#39;type&#39;&gt;\r\n\r\n    &gt;&gt;&gt; foo.__class__.__class__\r\n        &lt;type &#39;type&#39;&gt;\r\n\r\n    &gt;&gt;&gt; b.__class__.__class__\r\n        &lt;type &#39;type&#39;&gt;\r\n\r\nSo, a metaclass is just the stuff that creates class objects.\r\n\r\nYou can call it a &#39;class factory&#39; if you wish.\r\n\r\n`type` is the built-in metaclass Python uses, but of course, you can create your\r\nown metaclass.\r\n\r\nThe [`__metaclass__`][2] attribute\r\n==================================\r\n\r\nIn Python 2, you can add a `__metaclass__` attribute when you write a class (see next section for the Python 3 syntax):\r\n\r\n    class Foo(object):\r\n        __metaclass__ = something...\r\n        [...]\r\n\r\nIf you do so, Python will use the metaclass to create the class `Foo`.\r\n\r\nCareful, it&#39;s tricky.\r\n\r\nYou write `class Foo(object)` first, but the class object `Foo` is not created\r\nin memory yet.\r\n\r\nPython will look for `__metaclass__` in the class definition. If it finds it,\r\nit will use it to create the object class `Foo`. If it doesn&#39;t, it will use\r\n`type` to create the class.\r\n\r\nRead that several times.\r\n\r\nWhen you do:\r\n\r\n    class Foo(Bar):\r\n        pass\r\n\r\nPython does the following:\r\n\r\nIs there a `__metaclass__` attribute in `Foo`?\r\n\r\nIf yes, create in-memory a class object (I said a class object, stay with me here), with the name `Foo` by using what is in `__metaclass__`.\r\n\r\nIf Python can&#39;t find `__metaclass__`, it will look for a `__metaclass__` at the MODULE level, and try to do the same (but only for classes that don&#39;t inherit anything, basically old-style classes).\r\n\r\nThen if it can&#39;t find any `__metaclass__` at all, it will use the `Bar`&#39;s (the first parent) own metaclass (which might be the default `type`) to create the class object.\r\n\r\nBe careful here that the `__metaclass__` attribute will not be inherited, the metaclass of the parent (`Bar.__class__`) will be. If `Bar` used a `__metaclass__` attribute that created `Bar` with `type()` (and not `type.__new__()`), the subclasses will not inherit that behavior.\r\n\r\nNow the big question is, what can you put in `__metaclass__`?\r\n\r\nThe answer is something that can create a class.\r\n\r\nAnd what can create a class? `type`, or anything that subclasses or uses it.\r\n\r\nMetaclasses in Python 3\r\n=======================\r\n\r\nThe syntax to set the metaclass has been changed in Python 3:\r\n\r\n    class Foo(object, metaclass=something):\r\n        ...\r\n\r\ni.e. the `__metaclass__` attribute is no longer used, in favor of a keyword argument in the list of base classes.\r\n\r\nThe behavior of metaclasses however stays [largely the same](https:\/\/www.python.org\/dev\/peps\/pep-3115\/).\r\n\r\nOne thing added to metaclasses in Python 3 is that you can also pass attributes as keyword-arguments into a metaclass, like so:\r\n\r\n    class Foo(object, metaclass=something, kwarg1=value1, kwarg2=value2):\r\n        ...\r\n\r\nRead the section below for how Python handles this.\r\n\r\nCustom metaclasses\r\n==================\r\n\r\nThe main purpose of a metaclass is to change the class automatically,\r\nwhen it&#39;s created.\r\n\r\nYou usually do this for APIs, where you want to create classes matching the\r\ncurrent context.\r\n\r\nImagine a stupid example, where you decide that all classes in your module\r\nshould have their attributes written in uppercase. There are several ways to\r\ndo this, but one way is to set `__metaclass__` at the module level.\r\n\r\nThis way, all classes of this module will be created using this metaclass,\r\nand we just have to tell the metaclass to turn all attributes to uppercase.\r\n\r\nLuckily, `__metaclass__` can actually be any callable, it doesn&#39;t need to be a\r\nformal class (I know, something with &#39;class&#39; in its name doesn&#39;t need to be\r\na class, go figure... but it&#39;s helpful).\r\n\r\nSo we will start with a simple example, by using a function.\r\n\r\n    # the metaclass will automatically get passed the same argument\r\n    # that you usually pass to `type`\r\n    def upper_attr(future_class_name, future_class_parents, future_class_attrs):\r\n        &quot;&quot;&quot;\r\n          Return a class object, with the list of its attribute turned\r\n          into uppercase.\r\n        &quot;&quot;&quot;\r\n        # pick up any attribute that doesn&#39;t start with &#39;__&#39; and uppercase it\r\n        uppercase_attrs = {\r\n            attr if attr.startswith(&quot;__&quot;) else attr.upper(): v\r\n            for attr, v in future_class_attrs.items()\r\n        }\r\n\r\n        # let `type` do the class creation\r\n        return type(future_class_name, future_class_parents, uppercase_attrs)\r\n\r\n    __metaclass__ = upper_attr # this will affect all classes in the module\r\n\r\n    class Foo(): # global __metaclass__ won&#39;t work with &quot;object&quot; though\r\n        # but we can define __metaclass__ here instead to affect only this class\r\n        # and this will work with &quot;object&quot; children\r\n        bar = &#39;bip&#39;\r\n\r\nLet&#39;s check:\r\n\r\n    &gt;&gt;&gt; hasattr(Foo, &#39;bar&#39;)\r\n        False\r\n\r\n    &gt;&gt;&gt; hasattr(Foo, &#39;BAR&#39;)\r\n        True\r\n\r\n    &gt;&gt;&gt; Foo.BAR\r\n        &#39;bip&#39;\r\n\r\nNow, let&#39;s do exactly the same, but using a real class for a metaclass:\r\n\r\n    # remember that `type` is actually a class like `str` and `int`\r\n    # so you can inherit from it\r\n    class UpperAttrMetaclass(type):\r\n        # __new__ is the method called before __init__\r\n        # it&#39;s the method that creates the object and returns it\r\n        # while __init__ just initializes the object passed as parameter\r\n        # you rarely use __new__, except when you want to control how the object\r\n        # is created.\r\n        # here the created object is the class, and we want to customize it\r\n        # so we override __new__\r\n        # you can do some stuff in __init__ too if you wish\r\n        # some advanced use involves overriding __call__ as well, but we won&#39;t\r\n        # see this\r\n        def __new__(\r\n            upperattr_metaclass,\r\n            future_class_name,\r\n            future_class_parents,\r\n            future_class_attrs\r\n        ):\r\n            uppercase_attrs = {\r\n                attr if attr.startswith(&quot;__&quot;) else attr.upper(): v\r\n                for attr, v in future_class_attrs.items()\r\n            }\r\n            return type(future_class_name, future_class_parents, uppercase_attrs)\r\n\r\nLet&#39;s rewrite the above, but with shorter and more realistic variable names now that we know what they mean:\r\n\r\n    class UpperAttrMetaclass(type):\r\n        def __new__(cls, clsname, bases, attrs):\r\n            uppercase_attrs = {\r\n                attr if attr.startswith(&quot;__&quot;) else attr.upper(): v\r\n                for attr, v in attrs.items()\r\n            }\r\n            return type(clsname, bases, uppercase_attrs)\r\n\r\nYou may have noticed the extra argument `cls`. There is\r\nnothing special about it: `__new__` always receives the class it&#39;s defined in, as the first parameter. Just like you have `self` for ordinary methods which receive the instance as the first parameter, or the defining class for class methods.\r\n\r\nBut this is not proper OOP. We are calling `type` directly and we aren&#39;t overriding or calling the parent&#39;s `__new__`. Let&#39;s do that instead:\r\n\r\n    class UpperAttrMetaclass(type):\r\n        def __new__(cls, clsname, bases, attrs):\r\n            uppercase_attrs = {\r\n                attr if attr.startswith(&quot;__&quot;) else attr.upper(): v\r\n                for attr, v in attrs.items()\r\n            }\r\n            return type.__new__(cls, clsname, bases, uppercase_attrs)\r\n\r\nWe can make it even cleaner by using `super`, which will ease inheritance (because yes, you can have metaclasses, inheriting from metaclasses, inheriting from type):\r\n\r\n    class UpperAttrMetaclass(type):\r\n        def __new__(cls, clsname, bases, attrs):\r\n            uppercase_attrs = {\r\n                attr if attr.startswith(&quot;__&quot;) else attr.upper(): v\r\n                for attr, v in attrs.items()\r\n            }\r\n\r\n            # Python 2 requires passing arguments to super:\r\n            return super(UpperAttrMetaclass, cls).__new__(\r\n                cls, clsname, bases, uppercase_attrs)\r\n\r\n            # Python 3 can use no-arg super() which infers them:\r\n            return super().__new__(cls, clsname, bases, uppercase_attrs)\r\n\r\nOh, and in Python 3 if you do this call with keyword arguments, like this:\r\n\r\n    class Foo(object, metaclass=MyMetaclass, kwarg1=value1):\r\n        ...\r\n\r\nIt translates to this in the metaclass to use it:\r\n\r\n    class MyMetaclass(type):\r\n        def __new__(cls, clsname, bases, dct, kwargs1=default):\r\n            ...\r\n\r\nThat&#39;s it. There is really nothing more about metaclasses.\r\n\r\nThe reason behind the complexity of the code using metaclasses is not because\r\nof metaclasses, it&#39;s because you usually use metaclasses to do twisted stuff\r\nrelying on introspection, manipulating inheritance, vars such as `__dict__`, etc.\r\n\r\nIndeed, metaclasses are especially useful to do black magic, and therefore\r\ncomplicated stuff. But by themselves, they are simple:\r\n\r\n- intercept a class creation\r\n- modify the class\r\n- return the modified class\r\n\r\n\r\nWhy would you use metaclasses classes instead of functions?\r\n=============================================================\r\n\r\nSince `__metaclass__` can accept any callable, why would you use a class\r\nsince it&#39;s obviously more complicated?\r\n\r\nThere are several reasons to do so:\r\n\r\n- The intention is clear. When you read `UpperAttrMetaclass(type)`, you know\r\n  what&#39;s going to follow\r\n- You can use OOP. Metaclass can inherit from metaclass, override parent methods. Metaclasses can even use metaclasses.\r\n- Subclasses of a class will be instances of its metaclass if you specified a metaclass-class, but not with a metaclass-function.\r\n- You can structure your code better. You never use metaclasses for something as trivial as the above example. It&#39;s usually for something complicated. Having the ability to make several methods and group them in one class is very useful to make the code easier to read.\r\n- You can hook on `__new__`, `__init__` and `__call__`. Which will allow you to do different stuff, Even if usually you can do it all in `__new__`,\r\n  some people are just more comfortable using `__init__`.\r\n- These are called metaclasses, damn it! It must mean something!\r\n\r\n\r\nWhy would you use metaclasses?\r\n========================================\r\n\r\nNow the big question. Why would you use some obscure error-prone feature?\r\n\r\nWell, usually you don&#39;t:\r\n\r\n&gt; Metaclasses are deeper magic that\r\n&gt; 99% of users should never worry about it.\r\n&gt; If you wonder whether you need them,\r\n&gt; you don&#39;t (the people who actually\r\n&gt; need them know with certainty that\r\n&gt; they need them, and don&#39;t need an\r\n&gt; explanation about why).\r\n\r\n  *Python Guru Tim Peters*\r\n\r\nThe main use case for a metaclass is creating an API. A typical example of this is the Django ORM. It allows you to define something like this:\r\n\r\n    class Person(models.Model):\r\n        name = models.CharField(max_length=30)\r\n        age = models.IntegerField()\r\n\r\nBut if you do this:\r\n\r\n    person = Person(name=&#39;bob&#39;, age=&#39;35&#39;)\r\n    print(person.age)\r\n\r\nIt won&#39;t return an `IntegerField` object. It will return an `int`, and can even take it directly from the database.\r\n\r\nThis is possible because `models.Model` defines `__metaclass__` and\r\nit uses some magic that will turn the `Person` you just defined with simple statements\r\ninto a complex hook to a database field.\r\n\r\nDjango makes something complex look simple by exposing a simple API\r\nand using metaclasses, recreating code from this API to do the real job\r\nbehind the scenes.\r\n\r\nThe last word\r\n====================\r\n\r\nFirst, you know that classes are objects that can create instances.\r\n\r\nWell, in fact, classes are themselves instances. Of metaclasses.\r\n\r\n    &gt;&gt;&gt; class Foo(object): pass\r\n    &gt;&gt;&gt; id(Foo)\r\n        142630324\r\n\r\nEverything is an object in Python, and they are all either instance of classes\r\nor instances of metaclasses.\r\n\r\nExcept for `type`.\r\n\r\n`type` is actually its own metaclass. This is not something you could\r\nreproduce in pure Python, and is done by cheating a little bit at the implementation\r\nlevel.\r\n\r\nSecondly, metaclasses are complicated. You may not want to use them for\r\nvery simple class alterations. You can change classes by using two different techniques:\r\n\r\n- [monkey patching](http:\/\/en.wikipedia.org\/wiki\/Monkey_patch)\r\n- class decorators\r\n\r\n99% of the time you need class alteration, you are better off using these.\r\n\r\nBut 98% of the time, you don&#39;t need class alteration at all.\r\n\r\n\r\n  [1]: http:\/\/docs.python.org\/2\/library\/functions.html#type\r\n  [2]: http:\/\/docs.python.org\/2\/reference\/datamodel.html?highlight=__metaclass__#__metaclass__",
        "body": "<h1>Classes as objects<\/h1>\n<p>Prior to delving into metaclasses, a solid grasp of Python classes is beneficial. Python holds a particularly distinctive concept of classes, a notion it adopts from the Smalltalk language.<\/p>\n<p>In most languages, classes are just pieces of code that describe how to produce an object. That is somewhat true in Python too:<\/p>\n<pre><code>&gt;&gt;&gt; class ObjectCreator(object):\n...     pass\n\n&gt;&gt;&gt; my_object = ObjectCreator()\n&gt;&gt;&gt; print(my_object)\n    &lt;__main__.ObjectCreator object at 0x8974f2c&gt;\n<\/code><\/pre>\n<p>But classes are more than that in Python. <strong>Classes are objects too.<\/strong><\/p>\n<p>Yes, objects.<\/p>\n<p>When a Python script runs, every line of code is executed from top to bottom. When the Python interpreter encounters the <code>class<\/code> keyword, Python creates an <strong>object<\/strong> out of the &quot;description&quot; of the class that follows. Thus, the following instruction<\/p>\n<pre><code>&gt;&gt;&gt; class ObjectCreator(object):\n...     pass\n<\/code><\/pre>\n<p>...creates an <em>object<\/em> with the name <code>ObjectCreator<\/code>!<\/p>\n<p>This object (the class) is itself capable of creating objects (called <em>instances<\/em>).<\/p>\n<p>But still, it's an object. Therefore, like all objects:<\/p>\n<ul>\n<li>you can assign it to a variable<sup>1<\/sup>\n<pre><code>JustAnotherVariable = ObjectCreator\n<\/code><\/pre>\n<\/li>\n<li>you can attach attributes to it\n<pre><code>ObjectCreator.class_attribute = 'foo'\n<\/code><\/pre>\n<\/li>\n<li>you can pass it as a function parameter\n<pre><code>print(ObjectCreator)\n<\/code><\/pre>\n<\/li>\n<\/ul>\n<p><sup><sup>1<\/sup> Note that merely assigning it to another variable doesn't change the class's <code>__name__<\/code>, i.e.,<\/p>\n<pre><code>&gt;&gt;&gt; print(JustAnotherVariable)\n    &lt;class '__main__.ObjectCreator'&gt;\n\n&gt;&gt;&gt; print(JustAnotherVariable())\n    &lt;__main__.ObjectCreator object at 0x8997b4c&gt;\n<\/code><\/pre>\n<\/sup>\n<h1>Creating classes dynamically<\/h1>\n<p>Since classes are objects, you can create them on the fly, like any object.<\/p>\n<p>First, you can create a class in a function using <code>class<\/code>:<\/p>\n<pre><code>&gt;&gt;&gt; def choose_class(name):\n...     if name == 'foo':\n...         class Foo(object):\n...             pass\n...         return Foo # return the class, not an instance\n...     else:\n...         class Bar(object):\n...             pass\n...         return Bar\n\n&gt;&gt;&gt; MyClass = choose_class('foo')\n\n&gt;&gt;&gt; print(MyClass) # the function returns a class, not an instance\n    &lt;class '__main__.Foo'&gt;\n\n&gt;&gt;&gt; print(MyClass()) # you can create an object from this class\n    &lt;__main__.Foo object at 0x89c6d4c&gt;\n<\/code><\/pre>\n<p>But it's not so dynamic, since you still have to write the whole class yourself.<\/p>\n<p>Since classes are objects, they must be generated by something.<\/p>\n<p>When you use the <code>class<\/code> keyword, Python creates this object automatically. But as\nwith most things in Python, it gives you a way to do it manually.<\/p>\n<p>Remember the function <code>type<\/code>? The good old function that lets you know what\ntype an object is:<\/p>\n<pre><code>&gt;&gt;&gt; print(type(1))\n    &lt;type 'int'&gt;\n\n&gt;&gt;&gt; print(type(&quot;1&quot;))\n    &lt;type 'str'&gt;\n\n&gt;&gt;&gt; print(type(ObjectCreator))\n    &lt;type 'type'&gt;\n\n&gt;&gt;&gt; print(type(ObjectCreator()))\n    &lt;class '__main__.ObjectCreator'&gt;\n<\/code><\/pre>\n<p>Well, <a href=\"http:\/\/docs.python.org\/2\/library\/functions.html#type\" rel=\"noreferrer\"><code>type<\/code><\/a> has also a completely different ability: it can create classes on the fly. <code>type<\/code> can take the description of a class as parameters,\nand return a class.<\/p>\n<p>(I  know, it's silly that the same function can have two completely different uses according to the parameters you pass to it. It's an issue due to backward\ncompatibility in Python)<\/p>\n<p><code>type<\/code> works this way:<\/p>\n<pre><code>type(name, bases, attrs)\n<\/code><\/pre>\n<p>Where:<\/p>\n<ul>\n<li><strong><code>name<\/code><\/strong>: name of the class<\/li>\n<li><strong><code>bases<\/code><\/strong>: tuple of the parent class (for inheritance, can be empty)<\/li>\n<li><strong><code>attrs<\/code><\/strong>: dictionary containing attributes names and values<\/li>\n<\/ul>\n<p>e.g.:<\/p>\n<pre><code>&gt;&gt;&gt; class MyShinyClass(object):\n...     pass\n<\/code><\/pre>\n<p>can be created manually this way:<\/p>\n<pre><code>&gt;&gt;&gt; MyShinyClass = type('MyShinyClass', (), {}) # returns a class object\n&gt;&gt;&gt; print(MyShinyClass)\n    &lt;class '__main__.MyShinyClass'&gt;\n\n&gt;&gt;&gt; print(MyShinyClass()) # create an instance with the class\n    &lt;__main__.MyShinyClass object at 0x8997cec&gt;\n<\/code><\/pre>\n<p>You'll notice that we use <code>MyShinyClass<\/code> as the name of the class\nand as the variable to hold the class reference. They can be different,\nbut there is no reason to complicate things.<\/p>\n<p><code>type<\/code> accepts a dictionary to define the attributes of the class. So:<\/p>\n<pre><code>&gt;&gt;&gt; class Foo(object):\n...     bar = True\n<\/code><\/pre>\n<p>Can be translated to:<\/p>\n<pre><code>&gt;&gt;&gt; Foo = type('Foo', (), {'bar':True})\n<\/code><\/pre>\n<p>And used as a normal class:<\/p>\n<pre><code>&gt;&gt;&gt; print(Foo)\n    &lt;class '__main__.Foo'&gt;\n\n&gt;&gt;&gt; print(Foo.bar)\n    True\n\n&gt;&gt;&gt; f = Foo()\n&gt;&gt;&gt; print(f)\n    &lt;__main__.Foo object at 0x8a9b84c&gt;\n\n&gt;&gt;&gt; print(f.bar)\n    True\n<\/code><\/pre>\n<p>And of course, you can inherit from it, so:<\/p>\n<pre><code>&gt;&gt;&gt; class FooChild(Foo):\n...     pass\n<\/code><\/pre>\n<p>would be:<\/p>\n<pre><code>&gt;&gt;&gt; FooChild = type('FooChild', (Foo,), {})\n&gt;&gt;&gt; print(FooChild)\n    &lt;class '__main__.FooChild'&gt;\n\n&gt;&gt;&gt; print(FooChild.bar) # bar is inherited from Foo\n    True\n<\/code><\/pre>\n<p>Eventually, you'll want to add methods to your class. Just define a function\nwith the proper signature and assign it as an attribute.<\/p>\n<pre><code>&gt;&gt;&gt; def echo_bar(self):\n...     print(self.bar)\n\n&gt;&gt;&gt; FooChild = type('FooChild', (Foo,), {'echo_bar': echo_bar})\n\n&gt;&gt;&gt; hasattr(Foo, 'echo_bar')\n    False\n\n&gt;&gt;&gt; hasattr(FooChild, 'echo_bar')\n    True\n\n&gt;&gt;&gt; my_foo = FooChild()\n&gt;&gt;&gt; my_foo.echo_bar()\n    True\n<\/code><\/pre>\n<p>And you can add even more methods after you dynamically create the class, just like adding methods to a normally created class object.<\/p>\n<pre><code>&gt;&gt;&gt; def echo_bar_more(self):\n...     print('yet another method')\n\n&gt;&gt;&gt; FooChild.echo_bar_more = echo_bar_more\n&gt;&gt;&gt; hasattr(FooChild, 'echo_bar_more')\n    True\n<\/code><\/pre>\n<p>You see where we are going: in Python, classes are objects, and you can create a class on the fly, dynamically.<\/p>\n<p>This is what Python does when you use the keyword <code>class<\/code>, and it does so by using a metaclass.<\/p>\n<h1>What are metaclasses (finally)<\/h1>\n<p>Metaclasses are the 'stuff' that creates classes.<\/p>\n<p>You define classes in order to create objects, right?<\/p>\n<p>But we learned that Python classes are objects.<\/p>\n<p>Well, metaclasses are what create these objects. They are the classes' classes,\nyou can picture them this way:<\/p>\n<pre><code>MyClass = MetaClass()\nmy_object = MyClass()\n<\/code><\/pre>\n<p>You've seen that <code>type<\/code> lets you do something like this:<\/p>\n<pre><code>MyClass = type('MyClass', (), {})\n<\/code><\/pre>\n<p>It's because the function <code>type<\/code> is in fact a metaclass. <code>type<\/code> is the\nmetaclass Python uses to create all classes behind the scenes.<\/p>\n<p>Now you wonder &quot;why the heck is it written in lowercase, and not <code>Type<\/code>?&quot;<\/p>\n<p>Well, I guess it's a matter of consistency with <code>str<\/code>, the class that creates\nstrings objects, and <code>int<\/code> the class that creates integer objects. <code>type<\/code> is\njust the class that creates class objects.<\/p>\n<p>You see that by checking the <code>__class__<\/code> attribute.<\/p>\n<p>Everything, and I mean everything, is an object in Python. That includes integers,\nstrings, functions and classes. All of them are objects. And all of them have\nbeen created from a class:<\/p>\n<pre><code>&gt;&gt;&gt; age = 35\n&gt;&gt;&gt; age.__class__\n    &lt;type 'int'&gt;\n\n&gt;&gt;&gt; name = 'bob'\n&gt;&gt;&gt; name.__class__\n    &lt;type 'str'&gt;\n\n&gt;&gt;&gt; def foo(): pass\n&gt;&gt;&gt; foo.__class__\n    &lt;type 'function'&gt;\n\n&gt;&gt;&gt; class Bar(object): pass\n&gt;&gt;&gt; b = Bar()\n&gt;&gt;&gt; b.__class__\n    &lt;class '__main__.Bar'&gt;\n<\/code><\/pre>\n<p>Now, what is the <code>__class__<\/code> of any <code>__class__<\/code> ?<\/p>\n<pre><code>&gt;&gt;&gt; age.__class__.__class__\n    &lt;type 'type'&gt;\n\n&gt;&gt;&gt; name.__class__.__class__\n    &lt;type 'type'&gt;\n\n&gt;&gt;&gt; foo.__class__.__class__\n    &lt;type 'type'&gt;\n\n&gt;&gt;&gt; b.__class__.__class__\n    &lt;type 'type'&gt;\n<\/code><\/pre>\n<p>So, a metaclass is just the stuff that creates class objects.<\/p>\n<p>You can call it a 'class factory' if you wish.<\/p>\n<p><code>type<\/code> is the built-in metaclass Python uses, but of course, you can create your\nown metaclass.<\/p>\n<h1>The <a href=\"http:\/\/docs.python.org\/2\/reference\/datamodel.html?highlight=__metaclass__#__metaclass__\" rel=\"noreferrer\"><code>__metaclass__<\/code><\/a> attribute<\/h1>\n<p>In Python 2, you can add a <code>__metaclass__<\/code> attribute when you write a class (see next section for the Python 3 syntax):<\/p>\n<pre><code>class Foo(object):\n    __metaclass__ = something...\n    [...]\n<\/code><\/pre>\n<p>If you do so, Python will use the metaclass to create the class <code>Foo<\/code>.<\/p>\n<p>Careful, it's tricky.<\/p>\n<p>You write <code>class Foo(object)<\/code> first, but the class object <code>Foo<\/code> is not created\nin memory yet.<\/p>\n<p>Python will look for <code>__metaclass__<\/code> in the class definition. If it finds it,\nit will use it to create the object class <code>Foo<\/code>. If it doesn't, it will use\n<code>type<\/code> to create the class.<\/p>\n<p>Read that several times.<\/p>\n<p>When you do:<\/p>\n<pre><code>class Foo(Bar):\n    pass\n<\/code><\/pre>\n<p>Python does the following:<\/p>\n<p>Is there a <code>__metaclass__<\/code> attribute in <code>Foo<\/code>?<\/p>\n<p>If yes, create in-memory a class object (I said a class object, stay with me here), with the name <code>Foo<\/code> by using what is in <code>__metaclass__<\/code>.<\/p>\n<p>If Python can't find <code>__metaclass__<\/code>, it will look for a <code>__metaclass__<\/code> at the MODULE level, and try to do the same (but only for classes that don't inherit anything, basically old-style classes).<\/p>\n<p>Then if it can't find any <code>__metaclass__<\/code> at all, it will use the <code>Bar<\/code>'s (the first parent) own metaclass (which might be the default <code>type<\/code>) to create the class object.<\/p>\n<p>Be careful here that the <code>__metaclass__<\/code> attribute will not be inherited, the metaclass of the parent (<code>Bar.__class__<\/code>) will be. If <code>Bar<\/code> used a <code>__metaclass__<\/code> attribute that created <code>Bar<\/code> with <code>type()<\/code> (and not <code>type.__new__()<\/code>), the subclasses will not inherit that behavior.<\/p>\n<p>Now the big question is, what can you put in <code>__metaclass__<\/code>?<\/p>\n<p>The answer is something that can create a class.<\/p>\n<p>And what can create a class? <code>type<\/code>, or anything that subclasses or uses it.<\/p>\n<h1>Metaclasses in Python 3<\/h1>\n<p>The syntax to set the metaclass has been changed in Python 3:<\/p>\n<pre><code>class Foo(object, metaclass=something):\n    ...\n<\/code><\/pre>\n<p>i.e. the <code>__metaclass__<\/code> attribute is no longer used, in favor of a keyword argument in the list of base classes.<\/p>\n<p>The behavior of metaclasses however stays <a href=\"https:\/\/www.python.org\/dev\/peps\/pep-3115\/\" rel=\"noreferrer\">largely the same<\/a>.<\/p>\n<p>One thing added to metaclasses in Python 3 is that you can also pass attributes as keyword-arguments into a metaclass, like so:<\/p>\n<pre><code>class Foo(object, metaclass=something, kwarg1=value1, kwarg2=value2):\n    ...\n<\/code><\/pre>\n<p>Read the section below for how Python handles this.<\/p>\n<h1>Custom metaclasses<\/h1>\n<p>The main purpose of a metaclass is to change the class automatically,\nwhen it's created.<\/p>\n<p>You usually do this for APIs, where you want to create classes matching the\ncurrent context.<\/p>\n<p>Imagine a stupid example, where you decide that all classes in your module\nshould have their attributes written in uppercase. There are several ways to\ndo this, but one way is to set <code>__metaclass__<\/code> at the module level.<\/p>\n<p>This way, all classes of this module will be created using this metaclass,\nand we just have to tell the metaclass to turn all attributes to uppercase.<\/p>\n<p>Luckily, <code>__metaclass__<\/code> can actually be any callable, it doesn't need to be a\nformal class (I know, something with 'class' in its name doesn't need to be\na class, go figure... but it's helpful).<\/p>\n<p>So we will start with a simple example, by using a function.<\/p>\n<pre><code># the metaclass will automatically get passed the same argument\n# that you usually pass to `type`\ndef upper_attr(future_class_name, future_class_parents, future_class_attrs):\n    &quot;&quot;&quot;\n      Return a class object, with the list of its attribute turned\n      into uppercase.\n    &quot;&quot;&quot;\n    # pick up any attribute that doesn't start with '__' and uppercase it\n    uppercase_attrs = {\n        attr if attr.startswith(&quot;__&quot;) else attr.upper(): v\n        for attr, v in future_class_attrs.items()\n    }\n\n    # let `type` do the class creation\n    return type(future_class_name, future_class_parents, uppercase_attrs)\n\n__metaclass__ = upper_attr # this will affect all classes in the module\n\nclass Foo(): # global __metaclass__ won't work with &quot;object&quot; though\n    # but we can define __metaclass__ here instead to affect only this class\n    # and this will work with &quot;object&quot; children\n    bar = 'bip'\n<\/code><\/pre>\n<p>Let's check:<\/p>\n<pre><code>&gt;&gt;&gt; hasattr(Foo, 'bar')\n    False\n\n&gt;&gt;&gt; hasattr(Foo, 'BAR')\n    True\n\n&gt;&gt;&gt; Foo.BAR\n    'bip'\n<\/code><\/pre>\n<p>Now, let's do exactly the same, but using a real class for a metaclass:<\/p>\n<pre><code># remember that `type` is actually a class like `str` and `int`\n# so you can inherit from it\nclass UpperAttrMetaclass(type):\n    # __new__ is the method called before __init__\n    # it's the method that creates the object and returns it\n    # while __init__ just initializes the object passed as parameter\n    # you rarely use __new__, except when you want to control how the object\n    # is created.\n    # here the created object is the class, and we want to customize it\n    # so we override __new__\n    # you can do some stuff in __init__ too if you wish\n    # some advanced use involves overriding __call__ as well, but we won't\n    # see this\n    def __new__(\n        upperattr_metaclass,\n        future_class_name,\n        future_class_parents,\n        future_class_attrs\n    ):\n        uppercase_attrs = {\n            attr if attr.startswith(&quot;__&quot;) else attr.upper(): v\n            for attr, v in future_class_attrs.items()\n        }\n        return type(future_class_name, future_class_parents, uppercase_attrs)\n<\/code><\/pre>\n<p>Let's rewrite the above, but with shorter and more realistic variable names now that we know what they mean:<\/p>\n<pre><code>class UpperAttrMetaclass(type):\n    def __new__(cls, clsname, bases, attrs):\n        uppercase_attrs = {\n            attr if attr.startswith(&quot;__&quot;) else attr.upper(): v\n            for attr, v in attrs.items()\n        }\n        return type(clsname, bases, uppercase_attrs)\n<\/code><\/pre>\n<p>You may have noticed the extra argument <code>cls<\/code>. There is\nnothing special about it: <code>__new__<\/code> always receives the class it's defined in, as the first parameter. Just like you have <code>self<\/code> for ordinary methods which receive the instance as the first parameter, or the defining class for class methods.<\/p>\n<p>But this is not proper OOP. We are calling <code>type<\/code> directly and we aren't overriding or calling the parent's <code>__new__<\/code>. Let's do that instead:<\/p>\n<pre><code>class UpperAttrMetaclass(type):\n    def __new__(cls, clsname, bases, attrs):\n        uppercase_attrs = {\n            attr if attr.startswith(&quot;__&quot;) else attr.upper(): v\n            for attr, v in attrs.items()\n        }\n        return type.__new__(cls, clsname, bases, uppercase_attrs)\n<\/code><\/pre>\n<p>We can make it even cleaner by using <code>super<\/code>, which will ease inheritance (because yes, you can have metaclasses, inheriting from metaclasses, inheriting from type):<\/p>\n<pre><code>class UpperAttrMetaclass(type):\n    def __new__(cls, clsname, bases, attrs):\n        uppercase_attrs = {\n            attr if attr.startswith(&quot;__&quot;) else attr.upper(): v\n            for attr, v in attrs.items()\n        }\n\n        # Python 2 requires passing arguments to super:\n        return super(UpperAttrMetaclass, cls).__new__(\n            cls, clsname, bases, uppercase_attrs)\n\n        # Python 3 can use no-arg super() which infers them:\n        return super().__new__(cls, clsname, bases, uppercase_attrs)\n<\/code><\/pre>\n<p>Oh, and in Python 3 if you do this call with keyword arguments, like this:<\/p>\n<pre><code>class Foo(object, metaclass=MyMetaclass, kwarg1=value1):\n    ...\n<\/code><\/pre>\n<p>It translates to this in the metaclass to use it:<\/p>\n<pre><code>class MyMetaclass(type):\n    def __new__(cls, clsname, bases, dct, kwargs1=default):\n        ...\n<\/code><\/pre>\n<p>That's it. There is really nothing more about metaclasses.<\/p>\n<p>The reason behind the complexity of the code using metaclasses is not because\nof metaclasses, it's because you usually use metaclasses to do twisted stuff\nrelying on introspection, manipulating inheritance, vars such as <code>__dict__<\/code>, etc.<\/p>\n<p>Indeed, metaclasses are especially useful to do black magic, and therefore\ncomplicated stuff. But by themselves, they are simple:<\/p>\n<ul>\n<li>intercept a class creation<\/li>\n<li>modify the class<\/li>\n<li>return the modified class<\/li>\n<\/ul>\n<h1>Why would you use metaclasses classes instead of functions?<\/h1>\n<p>Since <code>__metaclass__<\/code> can accept any callable, why would you use a class\nsince it's obviously more complicated?<\/p>\n<p>There are several reasons to do so:<\/p>\n<ul>\n<li>The intention is clear. When you read <code>UpperAttrMetaclass(type)<\/code>, you know\nwhat's going to follow<\/li>\n<li>You can use OOP. Metaclass can inherit from metaclass, override parent methods. Metaclasses can even use metaclasses.<\/li>\n<li>Subclasses of a class will be instances of its metaclass if you specified a metaclass-class, but not with a metaclass-function.<\/li>\n<li>You can structure your code better. You never use metaclasses for something as trivial as the above example. It's usually for something complicated. Having the ability to make several methods and group them in one class is very useful to make the code easier to read.<\/li>\n<li>You can hook on <code>__new__<\/code>, <code>__init__<\/code> and <code>__call__<\/code>. Which will allow you to do different stuff, Even if usually you can do it all in <code>__new__<\/code>,\nsome people are just more comfortable using <code>__init__<\/code>.<\/li>\n<li>These are called metaclasses, damn it! It must mean something!<\/li>\n<\/ul>\n<h1>Why would you use metaclasses?<\/h1>\n<p>Now the big question. Why would you use some obscure error-prone feature?<\/p>\n<p>Well, usually you don't:<\/p>\n<blockquote>\n<p>Metaclasses are deeper magic that\n99% of users should never worry about it.\nIf you wonder whether you need them,\nyou don't (the people who actually\nneed them know with certainty that\nthey need them, and don't need an\nexplanation about why).<\/p>\n<\/blockquote>\n<p><em>Python Guru Tim Peters<\/em><\/p>\n<p>The main use case for a metaclass is creating an API. A typical example of this is the Django ORM. It allows you to define something like this:<\/p>\n<pre><code>class Person(models.Model):\n    name = models.CharField(max_length=30)\n    age = models.IntegerField()\n<\/code><\/pre>\n<p>But if you do this:<\/p>\n<pre><code>person = Person(name='bob', age='35')\nprint(person.age)\n<\/code><\/pre>\n<p>It won't return an <code>IntegerField<\/code> object. It will return an <code>int<\/code>, and can even take it directly from the database.<\/p>\n<p>This is possible because <code>models.Model<\/code> defines <code>__metaclass__<\/code> and\nit uses some magic that will turn the <code>Person<\/code> you just defined with simple statements\ninto a complex hook to a database field.<\/p>\n<p>Django makes something complex look simple by exposing a simple API\nand using metaclasses, recreating code from this API to do the real job\nbehind the scenes.<\/p>\n<h1>The last word<\/h1>\n<p>First, you know that classes are objects that can create instances.<\/p>\n<p>Well, in fact, classes are themselves instances. Of metaclasses.<\/p>\n<pre><code>&gt;&gt;&gt; class Foo(object): pass\n&gt;&gt;&gt; id(Foo)\n    142630324\n<\/code><\/pre>\n<p>Everything is an object in Python, and they are all either instance of classes\nor instances of metaclasses.<\/p>\n<p>Except for <code>type<\/code>.<\/p>\n<p><code>type<\/code> is actually its own metaclass. This is not something you could\nreproduce in pure Python, and is done by cheating a little bit at the implementation\nlevel.<\/p>\n<p>Secondly, metaclasses are complicated. You may not want to use them for\nvery simple class alterations. You can change classes by using two different techniques:<\/p>\n<ul>\n<li><a href=\"http:\/\/en.wikipedia.org\/wiki\/Monkey_patch\" rel=\"noreferrer\">monkey patching<\/a><\/li>\n<li>class decorators<\/li>\n<\/ul>\n<p>99% of the time you need class alteration, you are better off using these.<\/p>\n<p>But 98% of the time, you don't need class alteration at all.<\/p>\n",
        "community_owned_date": 1312882877.0
    },
    {
        "owner": {
            "account_id": 10167,
            "reputation": 93363,
            "user_id": 19082,
            "user_type": "registered",
            "accept_rate": 50,
            "profile_image": "https:\/\/www.gravatar.com\/avatar\/27c58ba8661585b00b571efab36af60f?s=256&d=identicon&r=PG",
            "display_name": "Mike Hordecki",
            "link": "https:\/\/stackoverflow.com\/users\/19082\/mike-hordecki"
        },
        "is_accepted": true,
        "score": 8781,
        "last_activity_date": 1649594691,
        "last_edit_date": 1649594691,
        "creation_date": 1233960756,
        "answer_id": 522578,
        "question_id": 522563,
        "content_license": "CC BY-SA 4.0",
        "body_markdown": "Use the built-in function [`enumerate()`][1]:\r\n\r\n    for idx, x in enumerate(xs):\r\n        print(idx, x)\r\n\r\nIt is *[non-pythonic][3]* to manually index via `for i in range(len(xs)): x = xs[i]` or manually manage an additional state variable.\r\n\r\nCheck out [PEP 279][2] for more.\r\n\r\n  [1]: https:\/\/docs.python.org\/3\/library\/functions.html#enumerate &quot;enumerate&quot;\r\n  [2]: https:\/\/www.python.org\/dev\/peps\/pep-0279\/ &quot;PEP 279&quot;\r\n  [3]: https:\/\/stackoverflow.com\/questions\/25011078\/what-does-pythonic-mean\r\n",
        "body": "<p>Use the built-in function <a href=\"https:\/\/docs.python.org\/3\/library\/functions.html#enumerate\" rel=\"noreferrer\" title=\"enumerate\"><code>enumerate()<\/code><\/a>:<\/p>\n<pre><code>for idx, x in enumerate(xs):\n    print(idx, x)\n<\/code><\/pre>\n<p>It is <em><a href=\"https:\/\/stackoverflow.com\/questions\/25011078\/what-does-pythonic-mean\">non-pythonic<\/a><\/em> to manually index via <code>for i in range(len(xs)): x = xs[i]<\/code> or manually manage an additional state variable.<\/p>\n<p>Check out <a href=\"https:\/\/www.python.org\/dev\/peps\/pep-0279\/\" rel=\"noreferrer\" title=\"PEP 279\">PEP 279<\/a> for more.<\/p>\n",
        "community_owned_date": null
    },
    {
        "owner": {
            "account_id": 12659,
            "reputation": 109897,
            "user_id": 25050,
            "user_type": "registered",
            "accept_rate": 78,
            "profile_image": "https:\/\/www.gravatar.com\/avatar\/6ec78954391f88681b2a5b97ef958d08?s=256&d=identicon&r=PG",
            "display_name": "Mr Fooz",
            "link": "https:\/\/stackoverflow.com\/users\/25050\/mr-fooz"
        },
        "is_accepted": true,
        "score": 8778,
        "last_activity_date": 1688632322,
        "last_edit_date": 1688632322,
        "creation_date": 1231302403,
        "answer_id": 419185,
        "question_id": 419163,
        "content_license": "CC BY-SA 4.0",
        "body_markdown": "Short Answer\r\n============\r\n\r\nIt&#39;s boilerplate code that protects users from accidentally invoking the script when they didn&#39;t intend to. Here are some common problems when the guard is omitted from a script:\r\n \r\n * If you import the guardless script in another script (e.g. `import my_script_without_a_name_eq_main_guard`), then the latter script will trigger the former to run *at import time* and *using the second script&#39;s command line arguments*. This is almost always a mistake.\r\n \r\n * If you have a custom class in the guardless script and save it to a pickle file, then unpickling it in another script will trigger an import of the guardless script, with the same problems outlined in the previous bullet.\r\n\r\nLong Answer\r\n===========\r\n\r\nTo better understand why and how this matters, we need to take a step back to understand how Python initializes scripts and how this interacts with its module import mechanism.\r\n\r\nWhenever the Python interpreter reads a source file, it does two things:\r\n\r\n * it sets a few special variables like `__name__`, and then\r\n\r\n * it executes all of the code found in the file.\r\n \r\nLet&#39;s see how this works and how it relates to your question about the `__name__` checks we always see in Python scripts.\r\n\r\nCode Sample\r\n-----------\r\n\r\nLet&#39;s use a slightly different code sample to explore how imports and scripts work.  Suppose the following is in a file called `foo.py`.\r\n\r\n    # Suppose this is foo.py.\r\n\r\n    print(&quot;before import&quot;)\r\n    import math\r\n    \r\n    print(&quot;before function_a&quot;)\r\n    def function_a():\r\n        print(&quot;Function A&quot;)\r\n    \r\n    print(&quot;before function_b&quot;)\r\n    def function_b():\r\n        print(&quot;Function B {}&quot;.format(math.sqrt(100)))\r\n    \r\n    print(&quot;before __name__ guard&quot;)\r\n    if __name__ == &#39;__main__&#39;:\r\n        function_a()\r\n        function_b()\r\n    print(&quot;after __name__ guard&quot;)\r\n\r\nSpecial Variables\r\n-----------------\r\n\r\nWhen the Python interpreter reads a source file, it first defines a few special variables. In this case, we care about the `__name__` variable.\r\n\r\n**When Your Module Is the Main Program**\r\n\r\nIf you are running your module (the source file) as the main program, e.g.\r\n\r\n    python foo.py\r\n\r\nthe interpreter will assign the hard-coded string `&quot;__main__&quot;` to the `__name__` variable, i.e.\r\n\r\n    # It&#39;s as if the interpreter inserts this at the top\r\n    # of your module when run as the main program.\r\n    __name__ = &quot;__main__&quot; \r\n    \r\n**When Your Module Is Imported By Another**\r\n\r\nOn the other hand, suppose some other module is the main program and it imports your module. This means there&#39;s a statement like this in the main program, or in some other module the main program imports:\r\n\r\n    # Suppose this is in some other main program.\r\n    import foo\r\n\r\nThe interpreter will search for your `foo.py` file (along with searching for a few other variants), and prior to executing that module, it will assign the name `&quot;foo&quot;` from the import statement to the `__name__` variable, i.e.\r\n\r\n    # It&#39;s as if the interpreter inserts this at the top\r\n    # of your module when it&#39;s imported from another module.\r\n    __name__ = &quot;foo&quot;\r\n    \r\n\r\nExecuting the Module&#39;s Code\r\n---------------------------\r\n\r\nAfter the special variables are set up, the interpreter executes all the code in the module, one statement at a time. You may want to open another window on the side with the code sample so you can follow along with this explanation.\r\n\r\n**Always**\r\n\r\n1. It prints the string `&quot;before import&quot;` (without quotes).\r\n\r\n2. It loads the `math` module and assigns it to a variable called `math`. This is equivalent to replacing `import math` with the following (note that `__import__` is a low-level function in Python that takes a string and triggers the actual import):\r\n```\r\n# Find and load a module given its string name, &quot;math&quot;,\r\n# then assign it to a local variable called math.\r\nmath = __import__(&quot;math&quot;)\r\n```\r\n3. It prints the string `&quot;before function_a&quot;`.\r\n\r\n4. It executes the `def` block, creating a function object, then assigning that function object to a variable called `function_a`.\r\n\r\n5. It prints the string `&quot;before function_b&quot;`.\r\n\r\n6. It executes the second `def` block, creating another function object, then assigning it to a variable called `function_b`.\r\n\r\n7. It prints the string `&quot;before __name__ guard&quot;`.\r\n\r\n**Only When Your Module Is the Main Program**\r\n\r\n8. If your module is the main program, then it will see that `__name__` was indeed set to `&quot;__main__&quot;` and it calls the two functions, printing the strings `&quot;Function A&quot;` and `&quot;Function B 10.0&quot;`.\r\n\r\n**Only When Your Module Is Imported by Another**\r\n\r\n8. (**instead**) If your module is not the main program but was imported by another one, then `__name__` will be `&quot;foo&quot;`, not `&quot;__main__&quot;`, and it&#39;ll skip the body of the `if` statement.\r\n\r\n**Always**\r\n\r\n9. It will print the string `&quot;after __name__ guard&quot;` in both situations.\r\n\r\n***Summary***\r\n\r\nIn summary, here&#39;s what&#39;d be printed in the two cases:\r\n\r\n&lt;!-- language: lang-none --&gt;\r\n\r\n    # What gets printed if foo is the main program\r\n    before import\r\n    before function_a\r\n    before function_b\r\n    before __name__ guard\r\n    Function A\r\n    Function B 10.0\r\n    after __name__ guard\r\n\r\n&lt;!-- language: lang-none --&gt;\r\n\r\n    # What gets printed if foo is imported as a regular module\r\n    before import\r\n    before function_a\r\n    before function_b\r\n    before __name__ guard\r\n    after __name__ guard\r\n\r\nWhy Does It Work This Way?\r\n--------------------------\r\n\r\nYou might naturally wonder why anybody would want this.  Well, sometimes you want to write a `.py` file that can be both used by other programs and\/or modules as a module, and can also be run as the main program itself.  Examples:\r\n\r\n * Your module is a library, but you want to have a script mode where it runs some unit tests or a demo.\r\n \r\n * Your module is only used as a main program, but it has some unit tests, and the testing framework works by importing `.py` files like your script and running special test functions. You don&#39;t want it to try running the script just because it&#39;s importing the module.\r\n \r\n * Your module is mostly used as a main program, but it also provides a programmer-friendly API for advanced users.\r\n\r\nBeyond those examples, it&#39;s elegant that running a script in Python is just setting up a few magic variables and importing the script. &quot;Running&quot; the script is a side effect of importing the script&#39;s module.\r\n\r\nFood for Thought\r\n----------------\r\n\r\n * Question: Can I have multiple `__name__` checking blocks?  Answer: it&#39;s strange to do so, but the language won&#39;t stop you.\r\n \r\n * Suppose the following is in `foo2.py`.  What happens if you say `python foo2.py` on the command-line? Why?\r\n \r\n&lt;!-- language: python --&gt;\r\n\r\n    # Suppose this is foo2.py.\r\n    import os, sys; sys.path.insert(0, os.path.dirname(__file__)) # needed for some interpreters\r\n\r\n    def function_a():\r\n        print(&quot;a1&quot;)\r\n        from foo2 import function_b\r\n        print(&quot;a2&quot;)\r\n        function_b()\r\n        print(&quot;a3&quot;)\r\n\r\n    def function_b():\r\n        print(&quot;b&quot;)\r\n\r\n    print(&quot;t1&quot;)\r\n    if __name__ == &quot;__main__&quot;:\r\n        print(&quot;m1&quot;)\r\n        function_a()\r\n        print(&quot;m2&quot;)\r\n    print(&quot;t2&quot;)\r\n          \r\n * Now, figure out what will happen in `foo3.py` (having removed the `__name__` check):\r\n \r\n&lt;!-- language: python --&gt;\r\n\r\n    # Suppose this is foo3.py.\r\n    import os, sys; sys.path.insert(0, os.path.dirname(__file__)) # needed for some interpreters\r\n    \r\n    def function_a():\r\n        print(&quot;a1&quot;)\r\n        from foo3 import function_b\r\n        print(&quot;a2&quot;)\r\n        function_b()\r\n        print(&quot;a3&quot;)\r\n\r\n    def function_b():\r\n        print(&quot;b&quot;)\r\n\r\n    print(&quot;t1&quot;)\r\n    print(&quot;m1&quot;)\r\n    function_a()\r\n    print(&quot;m2&quot;)\r\n    print(&quot;t2&quot;)\r\n\r\n * What will this do when used as a script?  When imported as a module?\r\n\r\n&lt;!-- language: python --&gt;\r\n\r\n    # Suppose this is in foo4.py\r\n    __name__ = &quot;__main__&quot;\r\n    \r\n    def bar():\r\n        print(&quot;bar&quot;)\r\n        \r\n    print(&quot;before __name__ guard&quot;)\r\n    if __name__ == &quot;__main__&quot;:\r\n        bar()\r\n    print(&quot;after __name__ guard&quot;)\r\n",
        "body": "<h1>Short Answer<\/h1>\n<p>It's boilerplate code that protects users from accidentally invoking the script when they didn't intend to. Here are some common problems when the guard is omitted from a script:<\/p>\n<ul>\n<li><p>If you import the guardless script in another script (e.g. <code>import my_script_without_a_name_eq_main_guard<\/code>), then the latter script will trigger the former to run <em>at import time<\/em> and <em>using the second script's command line arguments<\/em>. This is almost always a mistake.<\/p>\n<\/li>\n<li><p>If you have a custom class in the guardless script and save it to a pickle file, then unpickling it in another script will trigger an import of the guardless script, with the same problems outlined in the previous bullet.<\/p>\n<\/li>\n<\/ul>\n<h1>Long Answer<\/h1>\n<p>To better understand why and how this matters, we need to take a step back to understand how Python initializes scripts and how this interacts with its module import mechanism.<\/p>\n<p>Whenever the Python interpreter reads a source file, it does two things:<\/p>\n<ul>\n<li><p>it sets a few special variables like <code>__name__<\/code>, and then<\/p>\n<\/li>\n<li><p>it executes all of the code found in the file.<\/p>\n<\/li>\n<\/ul>\n<p>Let's see how this works and how it relates to your question about the <code>__name__<\/code> checks we always see in Python scripts.<\/p>\n<h2>Code Sample<\/h2>\n<p>Let's use a slightly different code sample to explore how imports and scripts work.  Suppose the following is in a file called <code>foo.py<\/code>.<\/p>\n<pre><code># Suppose this is foo.py.\n\nprint(&quot;before import&quot;)\nimport math\n\nprint(&quot;before function_a&quot;)\ndef function_a():\n    print(&quot;Function A&quot;)\n\nprint(&quot;before function_b&quot;)\ndef function_b():\n    print(&quot;Function B {}&quot;.format(math.sqrt(100)))\n\nprint(&quot;before __name__ guard&quot;)\nif __name__ == '__main__':\n    function_a()\n    function_b()\nprint(&quot;after __name__ guard&quot;)\n<\/code><\/pre>\n<h2>Special Variables<\/h2>\n<p>When the Python interpreter reads a source file, it first defines a few special variables. In this case, we care about the <code>__name__<\/code> variable.<\/p>\n<p><strong>When Your Module Is the Main Program<\/strong><\/p>\n<p>If you are running your module (the source file) as the main program, e.g.<\/p>\n<pre><code>python foo.py\n<\/code><\/pre>\n<p>the interpreter will assign the hard-coded string <code>&quot;__main__&quot;<\/code> to the <code>__name__<\/code> variable, i.e.<\/p>\n<pre><code># It's as if the interpreter inserts this at the top\n# of your module when run as the main program.\n__name__ = &quot;__main__&quot; \n<\/code><\/pre>\n<p><strong>When Your Module Is Imported By Another<\/strong><\/p>\n<p>On the other hand, suppose some other module is the main program and it imports your module. This means there's a statement like this in the main program, or in some other module the main program imports:<\/p>\n<pre><code># Suppose this is in some other main program.\nimport foo\n<\/code><\/pre>\n<p>The interpreter will search for your <code>foo.py<\/code> file (along with searching for a few other variants), and prior to executing that module, it will assign the name <code>&quot;foo&quot;<\/code> from the import statement to the <code>__name__<\/code> variable, i.e.<\/p>\n<pre><code># It's as if the interpreter inserts this at the top\n# of your module when it's imported from another module.\n__name__ = &quot;foo&quot;\n<\/code><\/pre>\n<h2>Executing the Module's Code<\/h2>\n<p>After the special variables are set up, the interpreter executes all the code in the module, one statement at a time. You may want to open another window on the side with the code sample so you can follow along with this explanation.<\/p>\n<p><strong>Always<\/strong><\/p>\n<ol>\n<li><p>It prints the string <code>&quot;before import&quot;<\/code> (without quotes).<\/p>\n<\/li>\n<li><p>It loads the <code>math<\/code> module and assigns it to a variable called <code>math<\/code>. This is equivalent to replacing <code>import math<\/code> with the following (note that <code>__import__<\/code> is a low-level function in Python that takes a string and triggers the actual import):<\/p>\n<\/li>\n<\/ol>\n<pre><code># Find and load a module given its string name, &quot;math&quot;,\n# then assign it to a local variable called math.\nmath = __import__(&quot;math&quot;)\n<\/code><\/pre>\n<ol start=\"3\">\n<li><p>It prints the string <code>&quot;before function_a&quot;<\/code>.<\/p>\n<\/li>\n<li><p>It executes the <code>def<\/code> block, creating a function object, then assigning that function object to a variable called <code>function_a<\/code>.<\/p>\n<\/li>\n<li><p>It prints the string <code>&quot;before function_b&quot;<\/code>.<\/p>\n<\/li>\n<li><p>It executes the second <code>def<\/code> block, creating another function object, then assigning it to a variable called <code>function_b<\/code>.<\/p>\n<\/li>\n<li><p>It prints the string <code>&quot;before __name__ guard&quot;<\/code>.<\/p>\n<\/li>\n<\/ol>\n<p><strong>Only When Your Module Is the Main Program<\/strong><\/p>\n<ol start=\"8\">\n<li>If your module is the main program, then it will see that <code>__name__<\/code> was indeed set to <code>&quot;__main__&quot;<\/code> and it calls the two functions, printing the strings <code>&quot;Function A&quot;<\/code> and <code>&quot;Function B 10.0&quot;<\/code>.<\/li>\n<\/ol>\n<p><strong>Only When Your Module Is Imported by Another<\/strong><\/p>\n<ol start=\"8\">\n<li>(<strong>instead<\/strong>) If your module is not the main program but was imported by another one, then <code>__name__<\/code> will be <code>&quot;foo&quot;<\/code>, not <code>&quot;__main__&quot;<\/code>, and it'll skip the body of the <code>if<\/code> statement.<\/li>\n<\/ol>\n<p><strong>Always<\/strong><\/p>\n<ol start=\"9\">\n<li>It will print the string <code>&quot;after __name__ guard&quot;<\/code> in both situations.<\/li>\n<\/ol>\n<p><em><strong>Summary<\/strong><\/em><\/p>\n<p>In summary, here's what'd be printed in the two cases:<\/p>\n<pre class=\"lang-none prettyprint-override\"><code># What gets printed if foo is the main program\nbefore import\nbefore function_a\nbefore function_b\nbefore __name__ guard\nFunction A\nFunction B 10.0\nafter __name__ guard\n<\/code><\/pre>\n<pre class=\"lang-none prettyprint-override\"><code># What gets printed if foo is imported as a regular module\nbefore import\nbefore function_a\nbefore function_b\nbefore __name__ guard\nafter __name__ guard\n<\/code><\/pre>\n<h2>Why Does It Work This Way?<\/h2>\n<p>You might naturally wonder why anybody would want this.  Well, sometimes you want to write a <code>.py<\/code> file that can be both used by other programs and\/or modules as a module, and can also be run as the main program itself.  Examples:<\/p>\n<ul>\n<li><p>Your module is a library, but you want to have a script mode where it runs some unit tests or a demo.<\/p>\n<\/li>\n<li><p>Your module is only used as a main program, but it has some unit tests, and the testing framework works by importing <code>.py<\/code> files like your script and running special test functions. You don't want it to try running the script just because it's importing the module.<\/p>\n<\/li>\n<li><p>Your module is mostly used as a main program, but it also provides a programmer-friendly API for advanced users.<\/p>\n<\/li>\n<\/ul>\n<p>Beyond those examples, it's elegant that running a script in Python is just setting up a few magic variables and importing the script. &quot;Running&quot; the script is a side effect of importing the script's module.<\/p>\n<h2>Food for Thought<\/h2>\n<ul>\n<li><p>Question: Can I have multiple <code>__name__<\/code> checking blocks?  Answer: it's strange to do so, but the language won't stop you.<\/p>\n<\/li>\n<li><p>Suppose the following is in <code>foo2.py<\/code>.  What happens if you say <code>python foo2.py<\/code> on the command-line? Why?<\/p>\n<\/li>\n<\/ul>\n<pre class=\"lang-py prettyprint-override\"><code># Suppose this is foo2.py.\nimport os, sys; sys.path.insert(0, os.path.dirname(__file__)) # needed for some interpreters\n\ndef function_a():\n    print(&quot;a1&quot;)\n    from foo2 import function_b\n    print(&quot;a2&quot;)\n    function_b()\n    print(&quot;a3&quot;)\n\ndef function_b():\n    print(&quot;b&quot;)\n\nprint(&quot;t1&quot;)\nif __name__ == &quot;__main__&quot;:\n    print(&quot;m1&quot;)\n    function_a()\n    print(&quot;m2&quot;)\nprint(&quot;t2&quot;)\n      \n<\/code><\/pre>\n<ul>\n<li>Now, figure out what will happen in <code>foo3.py<\/code> (having removed the <code>__name__<\/code> check):<\/li>\n<\/ul>\n<pre class=\"lang-py prettyprint-override\"><code># Suppose this is foo3.py.\nimport os, sys; sys.path.insert(0, os.path.dirname(__file__)) # needed for some interpreters\n\ndef function_a():\n    print(&quot;a1&quot;)\n    from foo3 import function_b\n    print(&quot;a2&quot;)\n    function_b()\n    print(&quot;a3&quot;)\n\ndef function_b():\n    print(&quot;b&quot;)\n\nprint(&quot;t1&quot;)\nprint(&quot;m1&quot;)\nfunction_a()\nprint(&quot;m2&quot;)\nprint(&quot;t2&quot;)\n<\/code><\/pre>\n<ul>\n<li>What will this do when used as a script?  When imported as a module?<\/li>\n<\/ul>\n<pre class=\"lang-py prettyprint-override\"><code># Suppose this is in foo4.py\n__name__ = &quot;__main__&quot;\n\ndef bar():\n    print(&quot;bar&quot;)\n    \nprint(&quot;before __name__ guard&quot;)\nif __name__ == &quot;__main__&quot;:\n    bar()\nprint(&quot;after __name__ guard&quot;)\n<\/code><\/pre>\n",
        "community_owned_date": null
    },
    {
        "owner": {
            "account_id": 118337,
            "reputation": 170973,
            "user_id": 309308,
            "user_type": "registered",
            "accept_rate": 74,
            "profile_image": "https:\/\/www.gravatar.com\/avatar\/dd7e03fbbfcabd4675844173ec5390d2?s=256&d=identicon&r=PG",
            "display_name": "Michael Mrozek",
            "link": "https:\/\/stackoverflow.com\/users\/309308\/michael-mrozek"
        },
        "is_accepted": true,
        "score": 8307,
        "last_activity_date": 1698842624,
        "last_edit_date": 1698842624,
        "creation_date": 1281322581,
        "answer_id": 3437070,
        "question_id": 3437059,
        "content_license": "CC BY-SA 4.0",
        "body_markdown": "Use the [`in` operator][1]:\r\n\r\n    if &quot;blah&quot; not in somestring: \r\n        continue\r\nNote: This is case-sensitive.\r\n\r\n  [1]: https:\/\/docs.python.org\/reference\/expressions.html#membership-test-details",
        "body": "<p>Use the <a href=\"https:\/\/docs.python.org\/reference\/expressions.html#membership-test-details\" rel=\"noreferrer\"><code>in<\/code> operator<\/a>:<\/p>\n<pre><code>if &quot;blah&quot; not in somestring: \n    continue\n<\/code><\/pre>\n<p>Note: This is case-sensitive.<\/p>\n",
        "community_owned_date": null
    },
    {
        "owner": {
            "account_id": 34048,
            "reputation": 861721,
            "user_id": 95810,
            "user_type": "registered",
            "accept_rate": 80,
            "profile_image": "https:\/\/www.gravatar.com\/avatar\/e8d5fe90f1fe2148bf130cccd4dc311c?s=256&d=identicon&r=PG",
            "display_name": "Alex Martelli",
            "link": "https:\/\/stackoverflow.com\/users\/95810\/alex-martelli"
        },
        "is_accepted": true,
        "score": 7255,
        "last_activity_date": 1702349118,
        "last_edit_date": 1702349118,
        "creation_date": 1244147821,
        "answer_id": 952952,
        "question_id": 952914,
        "content_license": "CC BY-SA 4.0",
        "body_markdown": "A list of lists named `xss` can be flattened using a [list comprehension]:\r\n\r\n```\r\nflat_list = [\r\n    x\r\n    for xs in xss\r\n    for x in xs\r\n]\r\n```\r\n\r\nThe above is equivalent to:\r\n\r\n```\r\nflat_list = []\r\n\r\nfor xs in xss:\r\n    for x in xs:\r\n        flat_list.append(x)\r\n```\r\n\r\nHere is the corresponding function:\r\n\r\n```\r\ndef flatten(xss):\r\n    return [x for xs in xss for x in xs]\r\n```\r\n\r\nThis is the fastest method.\r\nAs evidence, using the [`timeit`] module in the standard library, we see:\r\n\r\n```bash\r\n$ python -mtimeit -s&#39;xss=[[1,2,3],[4,5,6],[7],[8,9]]*99&#39; &#39;[x for xs in xss for x in xs]&#39;\r\n10000 loops, best of 3: 143 usec per loop\r\n\r\n$ python -mtimeit -s&#39;xss=[[1,2,3],[4,5,6],[7],[8,9]]*99&#39; &#39;sum(xss, [])&#39;\r\n1000 loops, best of 3: 969 usec per loop\r\n\r\n$ python -mtimeit -s&#39;xss=[[1,2,3],[4,5,6],[7],[8,9]]*99&#39; &#39;reduce(lambda xs, ys: xs + ys, xss)&#39;\r\n1000 loops, best of 3: 1.1 msec per loop\r\n```\r\n\r\nExplanation: the methods based on `+` (including the implied use in `sum`) are, of necessity, `O(L**2)` when there are L sublists -- as the intermediate result list keeps getting longer, at each step a new intermediate result list object gets allocated, and all the items in the previous intermediate result must be copied over (as well as a few new ones added at the end). So, for simplicity and without actual loss of generality, say you have L sublists of M items each: the first M items are copied back and forth `L-1` times, the second M items `L-2` times, and so on; total number of copies is M times the sum of x for x from 1 to L excluded, i.e., `M * (L**2)\/2`.\r\n\r\nThe list comprehension just generates one list, once, and copies each item over (from its original place of residence to the result list) also exactly once.\r\n\r\n\r\n  [list comprehension]: https:\/\/docs.python.org\/3\/tutorial\/datastructures.html#list-comprehensions\r\n  [`timeit`]: https:\/\/docs.python.org\/3\/library\/timeit.html\r\n",
        "body": "<p>A list of lists named <code>xss<\/code> can be flattened using a <a href=\"https:\/\/docs.python.org\/3\/tutorial\/datastructures.html#list-comprehensions\" rel=\"noreferrer\">list comprehension<\/a>:<\/p>\n<pre><code>flat_list = [\n    x\n    for xs in xss\n    for x in xs\n]\n<\/code><\/pre>\n<p>The above is equivalent to:<\/p>\n<pre><code>flat_list = []\n\nfor xs in xss:\n    for x in xs:\n        flat_list.append(x)\n<\/code><\/pre>\n<p>Here is the corresponding function:<\/p>\n<pre><code>def flatten(xss):\n    return [x for xs in xss for x in xs]\n<\/code><\/pre>\n<p>This is the fastest method.\nAs evidence, using the <a href=\"https:\/\/docs.python.org\/3\/library\/timeit.html\" rel=\"noreferrer\"><code>timeit<\/code><\/a> module in the standard library, we see:<\/p>\n<pre class=\"lang-bash prettyprint-override\"><code>$ python -mtimeit -s'xss=[[1,2,3],[4,5,6],[7],[8,9]]*99' '[x for xs in xss for x in xs]'\n10000 loops, best of 3: 143 usec per loop\n\n$ python -mtimeit -s'xss=[[1,2,3],[4,5,6],[7],[8,9]]*99' 'sum(xss, [])'\n1000 loops, best of 3: 969 usec per loop\n\n$ python -mtimeit -s'xss=[[1,2,3],[4,5,6],[7],[8,9]]*99' 'reduce(lambda xs, ys: xs + ys, xss)'\n1000 loops, best of 3: 1.1 msec per loop\n<\/code><\/pre>\n<p>Explanation: the methods based on <code>+<\/code> (including the implied use in <code>sum<\/code>) are, of necessity, <code>O(L**2)<\/code> when there are L sublists -- as the intermediate result list keeps getting longer, at each step a new intermediate result list object gets allocated, and all the items in the previous intermediate result must be copied over (as well as a few new ones added at the end). So, for simplicity and without actual loss of generality, say you have L sublists of M items each: the first M items are copied back and forth <code>L-1<\/code> times, the second M items <code>L-2<\/code> times, and so on; total number of copies is M times the sum of x for x from 1 to L excluded, i.e., <code>M * (L**2)\/2<\/code>.<\/p>\n<p>The list comprehension just generates one list, once, and copies each item over (from its original place of residence to the result list) also exactly once.<\/p>\n",
        "community_owned_date": null
    },
    {
        "owner": {
            "account_id": 343,
            "reputation": 90874,
            "user_id": 429,
            "user_type": "registered",
            "accept_rate": 80,
            "profile_image": "https:\/\/www.gravatar.com\/avatar\/05ce4158a6d636a028bd108bf52cd492?s=256&d=identicon&r=PG",
            "display_name": "Patrick",
            "link": "https:\/\/stackoverflow.com\/users\/429\/patrick"
        },
        "is_accepted": true,
        "score": 7110,
        "last_activity_date": 1663507396,
        "last_edit_date": 1663507396,
        "creation_date": 1221028085,
        "answer_id": 53522,
        "question_id": 53513,
        "content_license": "CC BY-SA 4.0",
        "body_markdown": "    if not a:\r\n        print(&quot;List is empty&quot;)\r\n\r\nUsing the [implicit booleanness][1] of the empty ```list``` is quite Pythonic.\r\n\r\n  [1]: https:\/\/docs.python.org\/library\/stdtypes.html#truth-value-testing\r\n\r\n\r\n",
        "body": "<pre><code>if not a:\n    print(&quot;List is empty&quot;)\n<\/code><\/pre>\n<p>Using the <a href=\"https:\/\/docs.python.org\/library\/stdtypes.html#truth-value-testing\" rel=\"noreferrer\">implicit booleanness<\/a> of the empty <code>list<\/code> is quite Pythonic.<\/p>\n",
        "community_owned_date": null
    },
    {
        "owner": {
            "account_id": 914,
            "reputation": 235159,
            "user_id": 1199,
            "user_type": "registered",
            "profile_image": "https:\/\/www.gravatar.com\/avatar\/78cb7314ef6c9ff2954f8e0d6506fc06?s=256&d=identicon&r=PG",
            "display_name": "Blair Conrad",
            "link": "https:\/\/stackoverflow.com\/users\/1199\/blair-conrad"
        },
        "is_accepted": true,
        "score": 7016,
        "last_activity_date": 1577697804,
        "last_edit_date": 1577697804,
        "creation_date": 1226084767,
        "answer_id": 273227,
        "question_id": 273192,
        "content_license": "CC BY-SA 4.0",
        "body_markdown": "On Python \u2265 3.5, use [`pathlib.Path.mkdir`][1]:\r\n\r\n    from pathlib import Path\r\n    Path(&quot;\/my\/directory&quot;).mkdir(parents=True, exist_ok=True)\r\n\r\nFor older versions of Python, I see two answers with good qualities, each with a small flaw, so I will give my take on it:\r\n\r\nTry [`os.path.exists`][2], and consider [`os.makedirs`][3] for the creation.\r\n\r\n    import os\r\n    if not os.path.exists(directory):\r\n        os.makedirs(directory)\r\n\r\nAs noted in comments and elsewhere, there&#39;s a race condition &amp;ndash; if the directory is created between the `os.path.exists` and the `os.makedirs` calls, the `os.makedirs` will fail with an `OSError`. Unfortunately, blanket-catching `OSError` and continuing is not foolproof, as it will ignore a failure to create the directory due to other factors, such as insufficient permissions, full disk, etc.\r\n\r\nOne option would be to trap the `OSError` and examine the embedded error code (see [Is there a cross-platform way of getting information from Python\u2019s OSError][4]):\r\n\r\n    import os, errno\r\n    \r\n    try:\r\n        os.makedirs(directory)\r\n    except OSError as e:\r\n        if e.errno != errno.EEXIST:\r\n            raise\r\n\r\nAlternatively, there could be a second `os.path.exists`, but suppose another created the directory after the first check, then removed it before the second one &amp;ndash; we could still be fooled. \r\n\r\nDepending on the application, the danger of concurrent operations may be more or less than the danger posed by other factors such as file permissions. The developer would have to know more about the particular application being developed and its expected environment before choosing an implementation.\r\n\r\nModern versions of Python improve this code quite a bit, both by exposing [`FileExistsError`][5] (in 3.3+)...\r\n\r\n    try:\r\n        os.makedirs(&quot;path\/to\/directory&quot;)\r\n    except FileExistsError:\r\n        # directory already exists\r\n        pass\r\n\r\n...and by allowing [a keyword argument to `os.makedirs` called `exist_ok`][6] (in 3.2+).\r\n\r\n    os.makedirs(&quot;path\/to\/directory&quot;, exist_ok=True)  # succeeds even if directory exists.\r\n\r\n\r\n  [1]: https:\/\/docs.python.org\/library\/pathlib.html#pathlib.Path.mkdir\r\n  [2]: https:\/\/docs.python.org\/library\/os.path.html#os.path.exists\r\n  [3]: https:\/\/docs.python.org\/library\/os.html#os.makedirs\r\n  [4]: https:\/\/stackoverflow.com\/questions\/273698\/is-there-a-cross-platform-way-of-getting-information-from-pythons-oserror\r\n  [5]: https:\/\/docs.python.org\/3.3\/library\/exceptions.html?#FileExistsError\r\n  [6]: https:\/\/docs.python.org\/3.2\/library\/os.html#os.makedirs",
        "body": "<p>On Python \u2265 3.5, use <a href=\"https:\/\/docs.python.org\/library\/pathlib.html#pathlib.Path.mkdir\" rel=\"noreferrer\"><code>pathlib.Path.mkdir<\/code><\/a>:<\/p>\n\n<pre><code>from pathlib import Path\nPath(\"\/my\/directory\").mkdir(parents=True, exist_ok=True)\n<\/code><\/pre>\n\n<p>For older versions of Python, I see two answers with good qualities, each with a small flaw, so I will give my take on it:<\/p>\n\n<p>Try <a href=\"https:\/\/docs.python.org\/library\/os.path.html#os.path.exists\" rel=\"noreferrer\"><code>os.path.exists<\/code><\/a>, and consider <a href=\"https:\/\/docs.python.org\/library\/os.html#os.makedirs\" rel=\"noreferrer\"><code>os.makedirs<\/code><\/a> for the creation.<\/p>\n\n<pre><code>import os\nif not os.path.exists(directory):\n    os.makedirs(directory)\n<\/code><\/pre>\n\n<p>As noted in comments and elsewhere, there's a race condition &ndash; if the directory is created between the <code>os.path.exists<\/code> and the <code>os.makedirs<\/code> calls, the <code>os.makedirs<\/code> will fail with an <code>OSError<\/code>. Unfortunately, blanket-catching <code>OSError<\/code> and continuing is not foolproof, as it will ignore a failure to create the directory due to other factors, such as insufficient permissions, full disk, etc.<\/p>\n\n<p>One option would be to trap the <code>OSError<\/code> and examine the embedded error code (see <a href=\"https:\/\/stackoverflow.com\/questions\/273698\/is-there-a-cross-platform-way-of-getting-information-from-pythons-oserror\">Is there a cross-platform way of getting information from Python\u2019s OSError<\/a>):<\/p>\n\n<pre><code>import os, errno\n\ntry:\n    os.makedirs(directory)\nexcept OSError as e:\n    if e.errno != errno.EEXIST:\n        raise\n<\/code><\/pre>\n\n<p>Alternatively, there could be a second <code>os.path.exists<\/code>, but suppose another created the directory after the first check, then removed it before the second one &ndash; we could still be fooled. <\/p>\n\n<p>Depending on the application, the danger of concurrent operations may be more or less than the danger posed by other factors such as file permissions. The developer would have to know more about the particular application being developed and its expected environment before choosing an implementation.<\/p>\n\n<p>Modern versions of Python improve this code quite a bit, both by exposing <a href=\"https:\/\/docs.python.org\/3.3\/library\/exceptions.html?#FileExistsError\" rel=\"noreferrer\"><code>FileExistsError<\/code><\/a> (in 3.3+)...<\/p>\n\n<pre><code>try:\n    os.makedirs(\"path\/to\/directory\")\nexcept FileExistsError:\n    # directory already exists\n    pass\n<\/code><\/pre>\n\n<p>...and by allowing <a href=\"https:\/\/docs.python.org\/3.2\/library\/os.html#os.makedirs\" rel=\"noreferrer\">a keyword argument to <code>os.makedirs<\/code> called <code>exist_ok<\/code><\/a> (in 3.2+).<\/p>\n\n<pre><code>os.makedirs(\"path\/to\/directory\", exist_ok=True)  # succeeds even if directory exists.\n<\/code><\/pre>\n",
        "community_owned_date": null
    },
    {
        "owner": {
            "account_id": 9922,
            "reputation": 93601,
            "user_id": 18515,
            "user_type": "registered",
            "accept_rate": 54,
            "profile_image": "https:\/\/www.gravatar.com\/avatar\/f9375b447dd668a10c19891379b9db2a?s=256&d=identicon&r=PG",
            "display_name": "Devin Jeanpierre",
            "link": "https:\/\/stackoverflow.com\/users\/18515\/devin-jeanpierre"
        },
        "is_accepted": true,
        "score": 6877,
        "last_activity_date": 1606073342,
        "last_edit_date": 1606073342,
        "creation_date": 1236214774,
        "answer_id": 613218,
        "question_id": 613183,
        "content_license": "CC BY-SA 4.0",
        "body_markdown": "### Python 3.7+ or CPython 3.6\r\n\r\nDicts preserve insertion order in Python 3.7+. Same in CPython 3.6, but [it&#39;s an implementation detail][1].\r\n\r\n    &gt;&gt;&gt; x = {1: 2, 3: 4, 4: 3, 2: 1, 0: 0}\r\n    &gt;&gt;&gt; {k: v for k, v in sorted(x.items(), key=lambda item: item[1])}\r\n    {0: 0, 2: 1, 1: 2, 4: 3, 3: 4}\r\n\r\nor\r\n\r\n    &gt;&gt;&gt; dict(sorted(x.items(), key=lambda item: item[1]))\r\n    {0: 0, 2: 1, 1: 2, 4: 3, 3: 4}\r\n\r\n### Older Python\r\n\r\nIt is not possible to sort a dictionary, only to get a representation of a dictionary that is sorted. Dictionaries are inherently orderless, but other types, such as lists and tuples, are not. So you need an ordered data type to represent sorted values, which will be a list\u2014probably a list of tuples.\r\n\r\nFor instance,\r\n\r\n    import operator\r\n    x = {1: 2, 3: 4, 4: 3, 2: 1, 0: 0}\r\n    sorted_x = sorted(x.items(), key=operator.itemgetter(1))\r\n\r\n`sorted_x` will be a list of tuples sorted by the second element in each tuple. `dict(sorted_x) == x`.\r\n\r\nAnd for those wishing to sort on keys instead of values:\r\n\r\n    import operator\r\n    x = {1: 2, 3: 4, 4: 3, 2: 1, 0: 0}\r\n    sorted_x = sorted(x.items(), key=operator.itemgetter(0))\r\n\r\n\r\nIn Python3 since [unpacking is not allowed][2] we can use \r\n\r\n    x = {1: 2, 3: 4, 4: 3, 2: 1, 0: 0}\r\n    sorted_x = sorted(x.items(), key=lambda kv: kv[1])\r\n\r\nIf you want the output as a dict, you can use [`collections.OrderedDict`][3]:\r\n\r\n    import collections\r\n\r\n    sorted_dict = collections.OrderedDict(sorted_x)\r\n\r\n\r\n  [1]: https:\/\/stackoverflow.com\/q\/39980323\/4518341\r\n  [2]: https:\/\/stackoverflow.com\/a\/15712231\/4293057\r\n  [3]: https:\/\/docs.python.org\/3\/library\/collections.html#collections.OrderedDict",
        "body": "<h3>Python 3.7+ or CPython 3.6<\/h3>\n<p>Dicts preserve insertion order in Python 3.7+. Same in CPython 3.6, but <a href=\"https:\/\/stackoverflow.com\/q\/39980323\/4518341\">it's an implementation detail<\/a>.<\/p>\n<pre><code>&gt;&gt;&gt; x = {1: 2, 3: 4, 4: 3, 2: 1, 0: 0}\n&gt;&gt;&gt; {k: v for k, v in sorted(x.items(), key=lambda item: item[1])}\n{0: 0, 2: 1, 1: 2, 4: 3, 3: 4}\n<\/code><\/pre>\n<p>or<\/p>\n<pre><code>&gt;&gt;&gt; dict(sorted(x.items(), key=lambda item: item[1]))\n{0: 0, 2: 1, 1: 2, 4: 3, 3: 4}\n<\/code><\/pre>\n<h3>Older Python<\/h3>\n<p>It is not possible to sort a dictionary, only to get a representation of a dictionary that is sorted. Dictionaries are inherently orderless, but other types, such as lists and tuples, are not. So you need an ordered data type to represent sorted values, which will be a list\u2014probably a list of tuples.<\/p>\n<p>For instance,<\/p>\n<pre><code>import operator\nx = {1: 2, 3: 4, 4: 3, 2: 1, 0: 0}\nsorted_x = sorted(x.items(), key=operator.itemgetter(1))\n<\/code><\/pre>\n<p><code>sorted_x<\/code> will be a list of tuples sorted by the second element in each tuple. <code>dict(sorted_x) == x<\/code>.<\/p>\n<p>And for those wishing to sort on keys instead of values:<\/p>\n<pre><code>import operator\nx = {1: 2, 3: 4, 4: 3, 2: 1, 0: 0}\nsorted_x = sorted(x.items(), key=operator.itemgetter(0))\n<\/code><\/pre>\n<p>In Python3 since <a href=\"https:\/\/stackoverflow.com\/a\/15712231\/4293057\">unpacking is not allowed<\/a> we can use<\/p>\n<pre><code>x = {1: 2, 3: 4, 4: 3, 2: 1, 0: 0}\nsorted_x = sorted(x.items(), key=lambda kv: kv[1])\n<\/code><\/pre>\n<p>If you want the output as a dict, you can use <a href=\"https:\/\/docs.python.org\/3\/library\/collections.html#collections.OrderedDict\" rel=\"noreferrer\"><code>collections.OrderedDict<\/code><\/a>:<\/p>\n<pre><code>import collections\n\nsorted_dict = collections.OrderedDict(sorted_x)\n<\/code><\/pre>\n",
        "community_owned_date": null
    },
    {
        "owner": {
            "account_id": 47755,
            "reputation": 129245,
            "user_id": 141555,
            "user_type": "registered",
            "accept_rate": 91,
            "profile_image": "https:\/\/i.stack.imgur.com\/oOW8R.jpg?s=256&g=1",
            "display_name": "sberry",
            "link": "https:\/\/stackoverflow.com\/users\/141555\/sberry"
        },
        "is_accepted": true,
        "score": 6812,
        "last_activity_date": 1578030379,
        "last_edit_date": 1578030379,
        "creation_date": 1279664973,
        "answer_id": 3294899,
        "question_id": 3294889,
        "content_license": "CC BY-SA 4.0",
        "body_markdown": "`key` is just a variable name.  \r\n\r\n    for key in d:\r\n\r\nwill simply loop over the keys in the dictionary, rather than the keys and values.  To loop over both key and value you can use the following:\r\n\r\n\r\nFor Python 3.x:\r\n\r\n    for key, value in d.items():\r\n\r\nFor Python 2.x:\r\n\r\n    for key, value in d.iteritems():\r\n\r\nTo test for yourself, change the word `key` to `poop`.\r\n\r\nIn Python 3.x, `iteritems()` was replaced with simply `items()`, which returns a set-like view backed by the dict, like `iteritems()` but even better. \r\nThis is also available in 2.7 as `viewitems()`. \r\n\r\nThe operation `items()` will work for both 2 and 3, but in 2 it will return a list of the dictionary&#39;s `(key, value)` pairs, which will not reflect changes to the dict that happen after the `items()` call. If you want the 2.x behavior in 3.x, you can call `list(d.items())`.",
        "body": "<p><code>key<\/code> is just a variable name.  <\/p>\n\n<pre><code>for key in d:\n<\/code><\/pre>\n\n<p>will simply loop over the keys in the dictionary, rather than the keys and values.  To loop over both key and value you can use the following:<\/p>\n\n<p>For Python 3.x:<\/p>\n\n<pre><code>for key, value in d.items():\n<\/code><\/pre>\n\n<p>For Python 2.x:<\/p>\n\n<pre><code>for key, value in d.iteritems():\n<\/code><\/pre>\n\n<p>To test for yourself, change the word <code>key<\/code> to <code>poop<\/code>.<\/p>\n\n<p>In Python 3.x, <code>iteritems()<\/code> was replaced with simply <code>items()<\/code>, which returns a set-like view backed by the dict, like <code>iteritems()<\/code> but even better. \nThis is also available in 2.7 as <code>viewitems()<\/code>. <\/p>\n\n<p>The operation <code>items()<\/code> will work for both 2 and 3, but in 2 it will return a list of the dictionary's <code>(key, value)<\/code> pairs, which will not reflect changes to the dict that happen after the <code>items()<\/code> call. If you want the 2.x behavior in 3.x, you can call <code>list(d.items())<\/code>.<\/p>\n",
        "community_owned_date": null
    },
    {
        "owner": {
            "account_id": 8651,
            "reputation": 82335,
            "user_id": 15682,
            "user_type": "registered",
            "accept_rate": 73,
            "profile_image": "https:\/\/www.gravatar.com\/avatar\/10e90e4046a5a032b3824c3812cac317?s=256&d=identicon&r=PG",
            "display_name": "rslite",
            "link": "https:\/\/stackoverflow.com\/users\/15682\/rslite"
        },
        "is_accepted": false,
        "score": 6483,
        "last_activity_date": 1703170254,
        "last_edit_date": 1703170254,
        "creation_date": 1221656271,
        "answer_id": 82852,
        "question_id": 82831,
        "content_license": "CC BY-SA 4.0",
        "body_markdown": "If the reason you&#39;re checking is so you can do something like `if file_exists: open_it()`, it&#39;s safer to use a `try` around the attempt to open it. Checking and then opening risks the file being deleted or moved or something between when you check and when you try to open it.\r\n\r\nIf you&#39;re not planning to open the file immediately, you can use [`os.path.isfile`][1]\r\n\r\n&gt; Return `True` if path is an existing regular file. This follows symbolic links, so both [islink()][2] and [isfile()][1] can be true for the same path.\r\n\r\n    import os.path\r\n    os.path.isfile(fname)\r\n\r\nif you need to be sure it&#39;s a file.\r\n\r\nStarting with Python 3.4, the [`pathlib` module][3] offers an object-oriented approach (backported to `pathlib2` in Python 2.7):\r\n\r\n    from pathlib import Path\r\n    \r\n    my_file = Path(&quot;\/path\/to\/file&quot;)\r\n    if my_file.is_file():\r\n        # file exists\r\n\r\nTo check a directory, do:\r\n\r\n    if my_file.is_dir():\r\n        # directory exists\r\n\r\nTo check whether a `Path` object exists independently of whether is it a file or directory, use `exists()`:\r\n\r\n    if my_file.exists():\r\n        # path exists\r\n\r\nYou can also use `resolve(strict=True)` in a `try` block:\r\n\r\n    try:\r\n        my_abs_path = my_file.resolve(strict=True)\r\n    except FileNotFoundError:\r\n        # doesn&#39;t exist\r\n    else:\r\n        # exists\r\n\r\n\r\n\r\n[1]:https:\/\/docs.python.org\/library\/os.path.html#os.path.isfile\r\n[2]:https:\/\/docs.python.org\/library\/os.path.html#os.path.islink\r\n[3]:https:\/\/docs.python.org\/3\/library\/pathlib.html#pathlib.Path.is_file",
        "body": "<p>If the reason you're checking is so you can do something like <code>if file_exists: open_it()<\/code>, it's safer to use a <code>try<\/code> around the attempt to open it. Checking and then opening risks the file being deleted or moved or something between when you check and when you try to open it.<\/p>\n<p>If you're not planning to open the file immediately, you can use <a href=\"https:\/\/docs.python.org\/library\/os.path.html#os.path.isfile\" rel=\"nofollow noreferrer\"><code>os.path.isfile<\/code><\/a><\/p>\n<blockquote>\n<p>Return <code>True<\/code> if path is an existing regular file. This follows symbolic links, so both <a href=\"https:\/\/docs.python.org\/library\/os.path.html#os.path.islink\" rel=\"nofollow noreferrer\">islink()<\/a> and <a href=\"https:\/\/docs.python.org\/library\/os.path.html#os.path.isfile\" rel=\"nofollow noreferrer\">isfile()<\/a> can be true for the same path.<\/p>\n<\/blockquote>\n<pre><code>import os.path\nos.path.isfile(fname)\n<\/code><\/pre>\n<p>if you need to be sure it's a file.<\/p>\n<p>Starting with Python 3.4, the <a href=\"https:\/\/docs.python.org\/3\/library\/pathlib.html#pathlib.Path.is_file\" rel=\"nofollow noreferrer\"><code>pathlib<\/code> module<\/a> offers an object-oriented approach (backported to <code>pathlib2<\/code> in Python 2.7):<\/p>\n<pre><code>from pathlib import Path\n\nmy_file = Path(&quot;\/path\/to\/file&quot;)\nif my_file.is_file():\n    # file exists\n<\/code><\/pre>\n<p>To check a directory, do:<\/p>\n<pre><code>if my_file.is_dir():\n    # directory exists\n<\/code><\/pre>\n<p>To check whether a <code>Path<\/code> object exists independently of whether is it a file or directory, use <code>exists()<\/code>:<\/p>\n<pre><code>if my_file.exists():\n    # path exists\n<\/code><\/pre>\n<p>You can also use <code>resolve(strict=True)<\/code> in a <code>try<\/code> block:<\/p>\n<pre><code>try:\n    my_abs_path = my_file.resolve(strict=True)\nexcept FileNotFoundError:\n    # doesn't exist\nelse:\n    # exists\n<\/code><\/pre>\n",
        "community_owned_date": null
    },
    {
        "owner": {
            "account_id": 680,
            "reputation": 961801,
            "user_id": 893,
            "user_type": "registered",
            "accept_rate": 84,
            "profile_image": "https:\/\/www.gravatar.com\/avatar\/747ffa5da3538e66840ebc0548b8fd58?s=256&d=identicon&r=PG",
            "display_name": "Greg Hewgill",
            "link": "https:\/\/stackoverflow.com\/users\/893\/greg-hewgill"
        },
        "is_accepted": true,
        "score": 6454,
        "last_activity_date": 1700087757,
        "last_edit_date": 1700087757,
        "creation_date": 1233701304,
        "answer_id": 509295,
        "question_id": 509211,
        "content_license": "CC BY-SA 4.0",
        "body_markdown": "The syntax is:\r\n\r\n    a[start:stop]  # items start through stop-1\r\n    a[start:]      # items start through the rest of the array\r\n    a[:stop]       # items from the beginning through stop-1\r\n    a[:]           # a copy of the whole array\r\n\r\nThere is also the `step` value, which can be used with any of the above:\r\n\r\n    a[start:stop:step] # start through not past stop, by step\r\n\r\nThe key point to remember is that the `:stop` value represents the first value that is *not* in the selected slice. So, the difference between `stop` and `start` is the number of elements selected (if `step` is 1, the default).\r\n\r\nThe other feature is that `start` or `stop` may be a *negative* number, which means it counts from the end of the array instead of the beginning. So:\r\n\r\n    a[-1]    # last item in the array\r\n    a[-2:]   # last two items in the array\r\n    a[:-2]   # everything except the last two items\r\n\r\nSimilarly, `step` may be a negative number:\r\n\r\n    a[::-1]    # all items in the array, reversed\r\n    a[1::-1]   # the first two items, reversed\r\n    a[:-3:-1]  # the last two items, reversed\r\n    a[-3::-1]  # everything except the last two items, reversed\r\n\r\nPython is kind to the programmer if there are fewer items than you ask for. For example, if you ask for `a[:-2]` and `a` only contains one element, you get an empty list instead of an error. Sometimes you would prefer the error, so you have to be aware that this may happen.\r\n\r\n### Relationship with the `slice` object\r\n\r\nA [`slice` object][slice] can represent a slicing operation, i.e.:\r\n\r\n    a[start:stop:step]\r\n\r\nis equivalent to:\r\n\r\n    a[slice(start, stop, step)]\r\n\r\nSlice objects also behave slightly differently depending on the number of arguments, similar to `range()`, i.e. both `slice(stop)` and `slice(start, stop[, step])` are supported.\r\nTo skip specifying a given argument, one might use `None`, so that e.g. `a[start:]` is equivalent to `a[slice(start, None)]` or `a[::-1]` is equivalent to `a[slice(None, None, -1)]`.\r\n\r\nWhile the `:`-based notation is very helpful for simple slicing, the explicit use of `slice()` objects simplifies the programmatic generation of slicing.\r\n\r\n\r\n [operator]: https:\/\/docs.python.org\/3\/library\/operator.html\r\n [slice]: https:\/\/www.w3schools.com\/python\/ref_func_slice.asp\r\n",
        "body": "<p>The syntax is:<\/p>\n<pre><code>a[start:stop]  # items start through stop-1\na[start:]      # items start through the rest of the array\na[:stop]       # items from the beginning through stop-1\na[:]           # a copy of the whole array\n<\/code><\/pre>\n<p>There is also the <code>step<\/code> value, which can be used with any of the above:<\/p>\n<pre><code>a[start:stop:step] # start through not past stop, by step\n<\/code><\/pre>\n<p>The key point to remember is that the <code>:stop<\/code> value represents the first value that is <em>not<\/em> in the selected slice. So, the difference between <code>stop<\/code> and <code>start<\/code> is the number of elements selected (if <code>step<\/code> is 1, the default).<\/p>\n<p>The other feature is that <code>start<\/code> or <code>stop<\/code> may be a <em>negative<\/em> number, which means it counts from the end of the array instead of the beginning. So:<\/p>\n<pre><code>a[-1]    # last item in the array\na[-2:]   # last two items in the array\na[:-2]   # everything except the last two items\n<\/code><\/pre>\n<p>Similarly, <code>step<\/code> may be a negative number:<\/p>\n<pre><code>a[::-1]    # all items in the array, reversed\na[1::-1]   # the first two items, reversed\na[:-3:-1]  # the last two items, reversed\na[-3::-1]  # everything except the last two items, reversed\n<\/code><\/pre>\n<p>Python is kind to the programmer if there are fewer items than you ask for. For example, if you ask for <code>a[:-2]<\/code> and <code>a<\/code> only contains one element, you get an empty list instead of an error. Sometimes you would prefer the error, so you have to be aware that this may happen.<\/p>\n<h3>Relationship with the <code>slice<\/code> object<\/h3>\n<p>A <a href=\"https:\/\/www.w3schools.com\/python\/ref_func_slice.asp\" rel=\"noreferrer\"><code>slice<\/code> object<\/a> can represent a slicing operation, i.e.:<\/p>\n<pre><code>a[start:stop:step]\n<\/code><\/pre>\n<p>is equivalent to:<\/p>\n<pre><code>a[slice(start, stop, step)]\n<\/code><\/pre>\n<p>Slice objects also behave slightly differently depending on the number of arguments, similar to <code>range()<\/code>, i.e. both <code>slice(stop)<\/code> and <code>slice(start, stop[, step])<\/code> are supported.\nTo skip specifying a given argument, one might use <code>None<\/code>, so that e.g. <code>a[start:]<\/code> is equivalent to <code>a[slice(start, None)]<\/code> or <code>a[::-1]<\/code> is equivalent to <code>a[slice(None, None, -1)]<\/code>.<\/p>\n<p>While the <code>:<\/code>-based notation is very helpful for simple slicing, the explicit use of <code>slice()<\/code> objects simplifies the programmatic generation of slicing.<\/p>\n",
        "community_owned_date": null
    },
    {
        "owner": {
            "account_id": 64585,
            "reputation": 852655,
            "user_id": 190597,
            "user_type": "registered",
            "accept_rate": 88,
            "profile_image": "https:\/\/www.gravatar.com\/avatar\/8f7683207b9fcc8e77120265517f7ce9?s=256&d=identicon&r=PG&f=y&so-version=2",
            "display_name": "unutbu",
            "link": "https:\/\/stackoverflow.com\/users\/190597\/unutbu"
        },
        "is_accepted": true,
        "score": 6374,
        "last_activity_date": 1695705271,
        "last_edit_date": 1695705271,
        "creation_date": 1371059060,
        "answer_id": 17071908,
        "question_id": 17071871,
        "content_license": "CC BY-SA 4.0",
        "body_markdown": "To select rows whose column value equals a scalar, `some_value`, use `==`:\r\n\r\n    df.loc[df[&#39;column_name&#39;] == some_value]\r\n\r\nTo select rows whose column value is in an iterable, `some_values`, use `isin`:\r\n\r\n    df.loc[df[&#39;column_name&#39;].isin(some_values)]\r\n\r\nCombine multiple conditions with `&amp;`: \r\n\r\n    df.loc[(df[&#39;column_name&#39;] &gt;= A) &amp; (df[&#39;column_name&#39;] &lt;= B)]\r\n\r\nNote the parentheses. Due to Python&#39;s [operator precedence rules](https:\/\/docs.python.org\/3\/reference\/expressions.html#operator-precedence), `&amp;` binds more tightly than `&lt;=` and `&gt;=`. Thus, the parentheses in the last example are necessary. Without the parentheses \r\n\r\n    df[&#39;column_name&#39;] &gt;= A &amp; df[&#39;column_name&#39;] &lt;= B\r\n\r\nis parsed as \r\n\r\n    df[&#39;column_name&#39;] &gt;= (A &amp; df[&#39;column_name&#39;]) &lt;= B\r\n\r\nwhich results in a [Truth value of a Series is ambiguous error][1].\r\n\r\n----------\r\n\r\nTo select rows whose column value *does not equal* `some_value`, use `!=`:\r\n\r\n    df.loc[df[&#39;column_name&#39;] != some_value]\r\n\r\n\r\nThe `isin` returns a boolean Series, so to select rows whose value is *not* in `some_values`, negate the boolean Series using `~`:\r\n\r\n    df = df.loc[~df[&#39;column_name&#39;].isin(some_values)] # .loc is not in-place replacement\r\n\r\n----------\r\n\r\nFor example,\r\n\r\n    import pandas as pd\r\n    import numpy as np\r\n    df = pd.DataFrame({&#39;A&#39;: &#39;foo bar foo bar foo bar foo foo&#39;.split(),\r\n                       &#39;B&#39;: &#39;one one two three two two one three&#39;.split(),\r\n                       &#39;C&#39;: np.arange(8), &#39;D&#39;: np.arange(8) * 2})\r\n    print(df)\r\n    #      A      B  C   D\r\n    # 0  foo    one  0   0\r\n    # 1  bar    one  1   2\r\n    # 2  foo    two  2   4\r\n    # 3  bar  three  3   6\r\n    # 4  foo    two  4   8\r\n    # 5  bar    two  5  10\r\n    # 6  foo    one  6  12\r\n    # 7  foo  three  7  14\r\n\r\n    print(df.loc[df[&#39;A&#39;] == &#39;foo&#39;])\r\n\r\nyields\r\n\r\n         A      B  C   D\r\n    0  foo    one  0   0\r\n    2  foo    two  2   4\r\n    4  foo    two  4   8\r\n    6  foo    one  6  12\r\n    7  foo  three  7  14\r\n\r\n----------\r\n\r\nIf you have multiple values you want to include, put them in a\r\nlist (or more generally, any iterable) and use `isin`:\r\n\r\n    print(df.loc[df[&#39;B&#39;].isin([&#39;one&#39;,&#39;three&#39;])])\r\n\r\nyields\r\n\r\n         A      B  C   D\r\n    0  foo    one  0   0\r\n    1  bar    one  1   2\r\n    3  bar  three  3   6\r\n    6  foo    one  6  12\r\n    7  foo  three  7  14\r\n\r\n\r\n----------\r\n\r\nNote, however, that if you wish to do this many times, it is more efficient to\r\nmake an index first, and then use `df.loc`:\r\n\r\n    df = df.set_index([&#39;B&#39;])\r\n    print(df.loc[&#39;one&#39;])\r\n\r\nyields\r\n\r\n           A  C   D\r\n    B              \r\n    one  foo  0   0\r\n    one  bar  1   2\r\n    one  foo  6  12\r\n\r\nor, to include multiple values from the index use `df.index.isin`:\r\n\r\n    df.loc[df.index.isin([&#39;one&#39;,&#39;two&#39;])]\r\n\r\nyields\r\n\r\n           A  C   D\r\n    B              \r\n    one  foo  0   0\r\n    one  bar  1   2\r\n    two  foo  2   4\r\n    two  foo  4   8\r\n    two  bar  5  10\r\n    one  foo  6  12\r\n\r\n\r\n  [1]: https:\/\/stackoverflow.com\/questions\/36921951\/truth-value-of-a-series-is-ambiguous-use-a-empty-a-bool-a-item-a-any-o",
        "body": "<p>To select rows whose column value equals a scalar, <code>some_value<\/code>, use <code>==<\/code>:<\/p>\n<pre><code>df.loc[df['column_name'] == some_value]\n<\/code><\/pre>\n<p>To select rows whose column value is in an iterable, <code>some_values<\/code>, use <code>isin<\/code>:<\/p>\n<pre><code>df.loc[df['column_name'].isin(some_values)]\n<\/code><\/pre>\n<p>Combine multiple conditions with <code>&amp;<\/code>:<\/p>\n<pre><code>df.loc[(df['column_name'] &gt;= A) &amp; (df['column_name'] &lt;= B)]\n<\/code><\/pre>\n<p>Note the parentheses. Due to Python's <a href=\"https:\/\/docs.python.org\/3\/reference\/expressions.html#operator-precedence\" rel=\"noreferrer\">operator precedence rules<\/a>, <code>&amp;<\/code> binds more tightly than <code>&lt;=<\/code> and <code>&gt;=<\/code>. Thus, the parentheses in the last example are necessary. Without the parentheses<\/p>\n<pre><code>df['column_name'] &gt;= A &amp; df['column_name'] &lt;= B\n<\/code><\/pre>\n<p>is parsed as<\/p>\n<pre><code>df['column_name'] &gt;= (A &amp; df['column_name']) &lt;= B\n<\/code><\/pre>\n<p>which results in a <a href=\"https:\/\/stackoverflow.com\/questions\/36921951\/truth-value-of-a-series-is-ambiguous-use-a-empty-a-bool-a-item-a-any-o\">Truth value of a Series is ambiguous error<\/a>.<\/p>\n<hr \/>\n<p>To select rows whose column value <em>does not equal<\/em> <code>some_value<\/code>, use <code>!=<\/code>:<\/p>\n<pre><code>df.loc[df['column_name'] != some_value]\n<\/code><\/pre>\n<p>The <code>isin<\/code> returns a boolean Series, so to select rows whose value is <em>not<\/em> in <code>some_values<\/code>, negate the boolean Series using <code>~<\/code>:<\/p>\n<pre><code>df = df.loc[~df['column_name'].isin(some_values)] # .loc is not in-place replacement\n<\/code><\/pre>\n<hr \/>\n<p>For example,<\/p>\n<pre><code>import pandas as pd\nimport numpy as np\ndf = pd.DataFrame({'A': 'foo bar foo bar foo bar foo foo'.split(),\n                   'B': 'one one two three two two one three'.split(),\n                   'C': np.arange(8), 'D': np.arange(8) * 2})\nprint(df)\n#      A      B  C   D\n# 0  foo    one  0   0\n# 1  bar    one  1   2\n# 2  foo    two  2   4\n# 3  bar  three  3   6\n# 4  foo    two  4   8\n# 5  bar    two  5  10\n# 6  foo    one  6  12\n# 7  foo  three  7  14\n\nprint(df.loc[df['A'] == 'foo'])\n<\/code><\/pre>\n<p>yields<\/p>\n<pre><code>     A      B  C   D\n0  foo    one  0   0\n2  foo    two  2   4\n4  foo    two  4   8\n6  foo    one  6  12\n7  foo  three  7  14\n<\/code><\/pre>\n<hr \/>\n<p>If you have multiple values you want to include, put them in a\nlist (or more generally, any iterable) and use <code>isin<\/code>:<\/p>\n<pre><code>print(df.loc[df['B'].isin(['one','three'])])\n<\/code><\/pre>\n<p>yields<\/p>\n<pre><code>     A      B  C   D\n0  foo    one  0   0\n1  bar    one  1   2\n3  bar  three  3   6\n6  foo    one  6  12\n7  foo  three  7  14\n<\/code><\/pre>\n<hr \/>\n<p>Note, however, that if you wish to do this many times, it is more efficient to\nmake an index first, and then use <code>df.loc<\/code>:<\/p>\n<pre><code>df = df.set_index(['B'])\nprint(df.loc['one'])\n<\/code><\/pre>\n<p>yields<\/p>\n<pre><code>       A  C   D\nB              \none  foo  0   0\none  bar  1   2\none  foo  6  12\n<\/code><\/pre>\n<p>or, to include multiple values from the index use <code>df.index.isin<\/code>:<\/p>\n<pre><code>df.loc[df.index.isin(['one','two'])]\n<\/code><\/pre>\n<p>yields<\/p>\n<pre><code>       A  C   D\nB              \none  foo  0   0\none  bar  1   2\ntwo  foo  2   4\ntwo  foo  4   8\ntwo  bar  5  10\none  foo  6  12\n<\/code><\/pre>\n",
        "community_owned_date": null
    },
    {
        "owner": {
            "account_id": 140334,
            "reputation": 66687,
            "user_id": 346573,
            "user_type": "registered",
            "profile_image": "https:\/\/www.gravatar.com\/avatar\/4a839932df915d7850d6a2b58dd2d32d?s=256&d=identicon&r=PG",
            "display_name": "pycruft",
            "link": "https:\/\/stackoverflow.com\/users\/346573\/pycruft"
        },
        "is_accepted": false,
        "score": 6329,
        "last_activity_date": 1701100772,
        "last_edit_date": 1701100772,
        "creation_date": 1278622871,
        "answer_id": 3207973,
        "question_id": 3207219,
        "content_license": "CC BY-SA 4.0",
        "body_markdown": "**[`os.listdir()`][1]** returns everything inside a directory -- including both **files** and **directories**.\r\n\r\n[**`os.path`**][3]&#39;s `isfile()` can be used to only list files:\r\n\r\n```\r\nfrom os import listdir\r\nfrom os.path import isfile, join\r\nonlyfiles = [f for f in listdir(mypath) if isfile(join(mypath, f))]\r\n```\r\n\r\nAlternatively, **[`os.walk()`][2]** **yields two lists** for each directory it visits -- one for **files** and one for **dirs**. If you only want the top directory you can break the first time it yields:\r\n\r\n```\r\nfrom os import walk\r\n\r\nf = []\r\nfor (dirpath, dirnames, filenames) in walk(mypath):\r\n    f.extend(filenames)\r\n    break\r\n```\r\n\r\nor, shorter:\r\n\r\n```python\r\nfrom os import walk\r\n\r\nfilenames = next(walk(mypath), (None, None, []))[2]  # [] if no file\r\n```\r\n\r\n   [1]: https:\/\/docs.python.org\/3\/library\/os.html#os.listdir &quot;os.listdir&quot;\r\n   [2]: https:\/\/docs.python.org\/3\/library\/os.html#os.walk &quot;os.walk&quot;\r\n   [3]: https:\/\/docs.python.org\/3\/library\/os.path.html#module-os.path &quot;os.path&quot;",
        "body": "<p><strong><a href=\"https:\/\/docs.python.org\/3\/library\/os.html#os.listdir\" rel=\"noreferrer\" title=\"os.listdir\"><code>os.listdir()<\/code><\/a><\/strong> returns everything inside a directory -- including both <strong>files<\/strong> and <strong>directories<\/strong>.<\/p>\n<p><a href=\"https:\/\/docs.python.org\/3\/library\/os.path.html#module-os.path\" rel=\"noreferrer\" title=\"os.path\"><strong><code>os.path<\/code><\/strong><\/a>'s <code>isfile()<\/code> can be used to only list files:<\/p>\n<pre><code>from os import listdir\nfrom os.path import isfile, join\nonlyfiles = [f for f in listdir(mypath) if isfile(join(mypath, f))]\n<\/code><\/pre>\n<p>Alternatively, <strong><a href=\"https:\/\/docs.python.org\/3\/library\/os.html#os.walk\" rel=\"noreferrer\" title=\"os.walk\"><code>os.walk()<\/code><\/a><\/strong> <strong>yields two lists<\/strong> for each directory it visits -- one for <strong>files<\/strong> and one for <strong>dirs<\/strong>. If you only want the top directory you can break the first time it yields:<\/p>\n<pre><code>from os import walk\n\nf = []\nfor (dirpath, dirnames, filenames) in walk(mypath):\n    f.extend(filenames)\n    break\n<\/code><\/pre>\n<p>or, shorter:<\/p>\n<pre class=\"lang-py prettyprint-override\"><code>from os import walk\n\nfilenames = next(walk(mypath), (None, None, []))[2]  # [] if no file\n<\/code><\/pre>\n",
        "community_owned_date": null
    },
    {
        "owner": {
            "account_id": 11786,
            "reputation": 69191,
            "user_id": 1941213,
            "user_type": "registered",
            "accept_rate": 57,
            "profile_image": "https:\/\/www.gravatar.com\/avatar\/24dea531b0cb0ec8ccd9825f0bd0886a?s=256&d=identicon&r=PG",
            "display_name": "Alex Coventry",
            "link": "https:\/\/stackoverflow.com\/users\/1941213\/alex-coventry"
        },
        "is_accepted": true,
        "score": 5935,
        "last_activity_date": 1672678163,
        "last_edit_date": 1672678163,
        "creation_date": 1223343649,
        "answer_id": 176921,
        "question_id": 176918,
        "content_license": "CC BY-SA 4.0",
        "body_markdown": "```py\r\n&gt;&gt;&gt; [&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;].index(&quot;bar&quot;)\r\n1\r\n```\r\n\r\nSee [the documentation](https:\/\/docs.python.org\/tutorial\/datastructures.html#more-on-lists) for the built-in `.index()` method of the list:\r\n\r\n&gt;     list.index(x[, start[, end]])\r\n&gt; Return zero-based index in the list of the first item whose value is equal to *x*. Raises a [`ValueError`](https:\/\/docs.python.org\/library\/exceptions.html#ValueError) if there is no such item.\r\n&gt;\r\n&gt; The optional arguments *start* and *end* are interpreted as in the [slice notation](https:\/\/docs.python.org\/tutorial\/introduction.html#lists) and are used to limit the search to a particular subsequence of the list. The returned index is computed relative to the beginning of the full sequence rather than the start argument.\r\n\r\n## Caveats\r\n\r\n### Linear time-complexity in list length\r\nAn `index` call checks every element of the list in order, until it finds a match. If the list is long, and if there is no guarantee that the value will be near the beginning, this can slow down the code. \r\n\r\nThis problem can only be completely avoided by using a different data structure. However, if the element is known to be within a certain part of the list, the `start` and `end` parameters can be used to narrow the search.\r\n\r\nFor example:\r\n\r\n    &gt;&gt;&gt; import timeit\r\n    &gt;&gt;&gt; timeit.timeit(&#39;l.index(999_999)&#39;, setup=&#39;l = list(range(0, 1_000_000))&#39;, number=1000)\r\n    9.356267921015387\r\n    &gt;&gt;&gt; timeit.timeit(&#39;l.index(999_999, 999_990, 1_000_000)&#39;, setup=&#39;l = list(range(0, 1_000_000))&#39;, number=1000)\r\n    0.0004404920036904514\r\n\r\nThe second call is orders of magnitude faster, because it only has to search through 10 elements, rather than all 1 million.\r\n\r\n### Only the index of the *first match* is returned\r\n\r\nA call to `index` searches through the list in order until it finds a match, and *stops there.* If there could be more than one occurrence of the value, and all indices are needed, `index` cannot solve the problem:\r\n```\r\n&gt;&gt;&gt; [1, 1].index(1) # the `1` index is not found.\r\n0\r\n```\r\nInstead, use a [list comprehension or generator expression to do the search](\/questions\/34835951\/), with [`enumerate` to get indices](\/questions\/522563\/):\r\n```\r\n&gt;&gt;&gt; # A list comprehension gives a list of indices directly:\r\n&gt;&gt;&gt; [i for i, e in enumerate([1, 2, 1]) if e == 1]\r\n[0, 2]\r\n&gt;&gt;&gt; # A generator comprehension gives us an iterable object...\r\n&gt;&gt;&gt; g = (i for i, e in enumerate([1, 2, 1]) if e == 1)\r\n&gt;&gt;&gt; # which can be used in a `for` loop, or manually iterated with `next`:\r\n&gt;&gt;&gt; next(g)\r\n0\r\n&gt;&gt;&gt; next(g)\r\n2\r\n```\r\nThe list comprehension and generator expression techniques still work if there is only one match, and are more generalizable.\r\n\r\n### Raises an exception if there is no match\r\n\r\nAs noted in the documentation above, using `.index` will raise an exception if the searched-for value is not in the list:\r\n```\r\n&gt;&gt;&gt; [1, 1].index(2)\r\nTraceback (most recent call last):\r\n  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;\r\nValueError: 2 is not in list\r\n```\r\nIf this is a concern, either [explicitly check first](https:\/\/stackoverflow.com\/questions\/12934190) using `item in my_list`, or handle the exception with `try`\/`except` as appropriate.\r\n\r\nThe explicit check is simple and readable, but it must iterate the list a second time. See https:\/\/stackoverflow.com\/questions\/11360858 for more guidance on this choice.",
        "body": "<pre class=\"lang-py prettyprint-override\"><code>&gt;&gt;&gt; [&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;].index(&quot;bar&quot;)\n1\n<\/code><\/pre>\n<p>See <a href=\"https:\/\/docs.python.org\/tutorial\/datastructures.html#more-on-lists\" rel=\"noreferrer\">the documentation<\/a> for the built-in <code>.index()<\/code> method of the list:<\/p>\n<blockquote>\n<pre><code>list.index(x[, start[, end]])\n<\/code><\/pre>\n<p>Return zero-based index in the list of the first item whose value is equal to <em>x<\/em>. Raises a <a href=\"https:\/\/docs.python.org\/library\/exceptions.html#ValueError\" rel=\"noreferrer\"><code>ValueError<\/code><\/a> if there is no such item.<\/p>\n<p>The optional arguments <em>start<\/em> and <em>end<\/em> are interpreted as in the <a href=\"https:\/\/docs.python.org\/tutorial\/introduction.html#lists\" rel=\"noreferrer\">slice notation<\/a> and are used to limit the search to a particular subsequence of the list. The returned index is computed relative to the beginning of the full sequence rather than the start argument.<\/p>\n<\/blockquote>\n<h2>Caveats<\/h2>\n<h3>Linear time-complexity in list length<\/h3>\n<p>An <code>index<\/code> call checks every element of the list in order, until it finds a match. If the list is long, and if there is no guarantee that the value will be near the beginning, this can slow down the code.<\/p>\n<p>This problem can only be completely avoided by using a different data structure. However, if the element is known to be within a certain part of the list, the <code>start<\/code> and <code>end<\/code> parameters can be used to narrow the search.<\/p>\n<p>For example:<\/p>\n<pre><code>&gt;&gt;&gt; import timeit\n&gt;&gt;&gt; timeit.timeit('l.index(999_999)', setup='l = list(range(0, 1_000_000))', number=1000)\n9.356267921015387\n&gt;&gt;&gt; timeit.timeit('l.index(999_999, 999_990, 1_000_000)', setup='l = list(range(0, 1_000_000))', number=1000)\n0.0004404920036904514\n<\/code><\/pre>\n<p>The second call is orders of magnitude faster, because it only has to search through 10 elements, rather than all 1 million.<\/p>\n<h3>Only the index of the <em>first match<\/em> is returned<\/h3>\n<p>A call to <code>index<\/code> searches through the list in order until it finds a match, and <em>stops there.<\/em> If there could be more than one occurrence of the value, and all indices are needed, <code>index<\/code> cannot solve the problem:<\/p>\n<pre><code>&gt;&gt;&gt; [1, 1].index(1) # the `1` index is not found.\n0\n<\/code><\/pre>\n<p>Instead, use a <a href=\"\/questions\/34835951\/\">list comprehension or generator expression to do the search<\/a>, with <a href=\"\/questions\/522563\/\"><code>enumerate<\/code> to get indices<\/a>:<\/p>\n<pre><code>&gt;&gt;&gt; # A list comprehension gives a list of indices directly:\n&gt;&gt;&gt; [i for i, e in enumerate([1, 2, 1]) if e == 1]\n[0, 2]\n&gt;&gt;&gt; # A generator comprehension gives us an iterable object...\n&gt;&gt;&gt; g = (i for i, e in enumerate([1, 2, 1]) if e == 1)\n&gt;&gt;&gt; # which can be used in a `for` loop, or manually iterated with `next`:\n&gt;&gt;&gt; next(g)\n0\n&gt;&gt;&gt; next(g)\n2\n<\/code><\/pre>\n<p>The list comprehension and generator expression techniques still work if there is only one match, and are more generalizable.<\/p>\n<h3>Raises an exception if there is no match<\/h3>\n<p>As noted in the documentation above, using <code>.index<\/code> will raise an exception if the searched-for value is not in the list:<\/p>\n<pre><code>&gt;&gt;&gt; [1, 1].index(2)\nTraceback (most recent call last):\n  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;\nValueError: 2 is not in list\n<\/code><\/pre>\n<p>If this is a concern, either <a href=\"https:\/\/stackoverflow.com\/questions\/12934190\">explicitly check first<\/a> using <code>item in my_list<\/code>, or handle the exception with <code>try<\/code>\/<code>except<\/code> as appropriate.<\/p>\n<p>The explicit check is simple and readable, but it must iterate the list a second time. See <a href=\"https:\/\/stackoverflow.com\/questions\/11360858\">What is the EAFP principle in Python?<\/a> for more guidance on this choice.<\/p>\n",
        "community_owned_date": null
    },
    {
        "owner": {
            "account_id": 2940,
            "reputation": 86043,
            "user_id": 4172,
            "user_type": "registered",
            "accept_rate": 60,
            "profile_image": "https:\/\/www.gravatar.com\/avatar\/32cdc777a19a6f2b2129decd30061cd1?s=256&d=identicon&r=PG",
            "display_name": "kender",
            "link": "https:\/\/stackoverflow.com\/users\/4172\/kender"
        },
        "is_accepted": true,
        "score": 5855,
        "last_activity_date": 1682060218,
        "last_edit_date": 1682060218,
        "creation_date": 1225432945,
        "answer_id": 252711,
        "question_id": 252703,
        "content_license": "CC BY-SA 4.0",
        "body_markdown": "[`.append()`][1] appends a specified object at the end of the list:\r\n\r\n```\r\n&gt;&gt;&gt; x = [1, 2, 3]\r\n&gt;&gt;&gt; x.append([4, 5])\r\n&gt;&gt;&gt; print(x)\r\n[1, 2, 3, [4, 5]]\r\n```\r\n\r\n[`.extend()`][1] extends the list by appending elements from the specified iterable:\r\n\r\n```\r\n&gt;&gt;&gt; x = [1, 2, 3]\r\n&gt;&gt;&gt; x.extend([4, 5])\r\n&gt;&gt;&gt; print(x)\r\n[1, 2, 3, 4, 5]\r\n```\r\n\r\n[1]: https:\/\/docs.python.org\/3\/library\/stdtypes.html#mutable-sequence-types",
        "body": "<p><a href=\"https:\/\/docs.python.org\/3\/library\/stdtypes.html#mutable-sequence-types\" rel=\"noreferrer\"><code>.append()<\/code><\/a> appends a specified object at the end of the list:<\/p>\n<pre><code>&gt;&gt;&gt; x = [1, 2, 3]\n&gt;&gt;&gt; x.append([4, 5])\n&gt;&gt;&gt; print(x)\n[1, 2, 3, [4, 5]]\n<\/code><\/pre>\n<p><a href=\"https:\/\/docs.python.org\/3\/library\/stdtypes.html#mutable-sequence-types\" rel=\"noreferrer\"><code>.extend()<\/code><\/a> extends the list by appending elements from the specified iterable:<\/p>\n<pre><code>&gt;&gt;&gt; x = [1, 2, 3]\n&gt;&gt;&gt; x.extend([4, 5])\n&gt;&gt;&gt; print(x)\n[1, 2, 3, 4, 5]\n<\/code><\/pre>\n",
        "community_owned_date": null
    },
    {
        "owner": {
            "account_id": 6744,
            "reputation": 78876,
            "user_id": 11465,
            "user_type": "registered",
            "accept_rate": 65,
            "profile_image": "https:\/\/www.gravatar.com\/avatar\/9820b5956634e5bbad7f4ed91a232822?s=256&d=identicon&r=PG",
            "display_name": "David Cournapeau",
            "link": "https:\/\/stackoverflow.com\/users\/11465\/david-cournapeau"
        },
        "is_accepted": true,
        "score": 5765,
        "last_activity_date": 1684540374,
        "last_edit_date": 1684540374,
        "creation_date": 1221701975,
        "answer_id": 89243,
        "question_id": 89228,
        "content_license": "CC BY-SA 4.0",
        "body_markdown": "Use [`subprocess.run`][2]:\r\n\r\n```py\r\nimport subprocess\r\n\r\nsubprocess.run([&quot;ls&quot;, &quot;-l&quot;]) \r\n```\r\n\r\nAnother common way is [`os.system`][3] but you shouldn&#39;t use it because it is unsafe if any parts of the command come from outside your program or can contain spaces or other special characters, also `subprocess.run` is generally more flexible (you can get the [`stdout`][4], [`stderr`][5], the [&quot;real&quot; status code][6], better [error handling][7], etc.). Even the [documentation for `os.system`][3] recommends using `subprocess` instead.\r\n\r\nOn Python 3.4 and earlier, use `subprocess.call` instead of `.run`:\r\n\r\n```py\r\nsubprocess.call([&quot;ls&quot;, &quot;-l&quot;])\r\n```\r\n\r\n\r\n  [2]: https:\/\/docs.python.org\/library\/subprocess.html#subprocess.run\r\n  [3]: https:\/\/docs.python.org\/library\/os.html#os.system\r\n  [4]: https:\/\/docs.python.org\/library\/subprocess.html#subprocess.CompletedProcess.stdout\r\n  [5]: https:\/\/docs.python.org\/library\/subprocess.html#subprocess.CompletedProcess.stderr\r\n  [6]: https:\/\/docs.python.org\/library\/subprocess.html#subprocess.CompletedProcess.returncode\r\n  [7]: https:\/\/docs.python.org\/library\/subprocess.html#subprocess.CalledProcessError\r\n  [9]: https:\/\/docs.python.org\/library\/subprocess.html#subprocess-replacements\r\n",
        "body": "<p>Use <a href=\"https:\/\/docs.python.org\/library\/subprocess.html#subprocess.run\" rel=\"noreferrer\"><code>subprocess.run<\/code><\/a>:<\/p>\n<pre class=\"lang-py prettyprint-override\"><code>import subprocess\n\nsubprocess.run([&quot;ls&quot;, &quot;-l&quot;]) \n<\/code><\/pre>\n<p>Another common way is <a href=\"https:\/\/docs.python.org\/library\/os.html#os.system\" rel=\"noreferrer\"><code>os.system<\/code><\/a> but you shouldn't use it because it is unsafe if any parts of the command come from outside your program or can contain spaces or other special characters, also <code>subprocess.run<\/code> is generally more flexible (you can get the <a href=\"https:\/\/docs.python.org\/library\/subprocess.html#subprocess.CompletedProcess.stdout\" rel=\"noreferrer\"><code>stdout<\/code><\/a>, <a href=\"https:\/\/docs.python.org\/library\/subprocess.html#subprocess.CompletedProcess.stderr\" rel=\"noreferrer\"><code>stderr<\/code><\/a>, the <a href=\"https:\/\/docs.python.org\/library\/subprocess.html#subprocess.CompletedProcess.returncode\" rel=\"noreferrer\">&quot;real&quot; status code<\/a>, better <a href=\"https:\/\/docs.python.org\/library\/subprocess.html#subprocess.CalledProcessError\" rel=\"noreferrer\">error handling<\/a>, etc.). Even the <a href=\"https:\/\/docs.python.org\/library\/os.html#os.system\" rel=\"noreferrer\">documentation for <code>os.system<\/code><\/a> recommends using <code>subprocess<\/code> instead.<\/p>\n<p>On Python 3.4 and earlier, use <code>subprocess.call<\/code> instead of <code>.run<\/code>:<\/p>\n<pre class=\"lang-py prettyprint-override\"><code>subprocess.call([&quot;ls&quot;, &quot;-l&quot;])\n<\/code><\/pre>\n",
        "community_owned_date": null
    },
    {
        "owner": {
            "account_id": 1889,
            "reputation": 120500,
            "user_id": 2603,
            "user_type": "registered",
            "accept_rate": 75,
            "profile_image": "https:\/\/i.stack.imgur.com\/NIuNK.jpg?s=256&g=1",
            "display_name": "Aaron Maenpaa",
            "link": "https:\/\/stackoverflow.com\/users\/2603\/aaron-maenpaa"
        },
        "is_accepted": true,
        "score": 5644,
        "last_activity_date": 1654485719,
        "last_edit_date": 1654485719,
        "creation_date": 1236083178,
        "answer_id": 606199,
        "question_id": 606191,
        "content_license": "CC BY-SA 4.0",
        "body_markdown": "[Decode the `bytes` object][bytes.decode] to produce a string:\r\n\r\n    &gt;&gt;&gt; b&quot;abcde&quot;.decode(&quot;utf-8&quot;) \r\n    &#39;abcde&#39;\r\n\r\nThe above example *assumes* that the `bytes` object is in UTF-8, because it is a common encoding. However, you should use the encoding your data is actually in!\r\n\r\n[bytes.decode]: https:\/\/docs.python.org\/3\/library\/stdtypes.html#bytes.decode\r\n",
        "body": "<p><a href=\"https:\/\/docs.python.org\/3\/library\/stdtypes.html#bytes.decode\" rel=\"noreferrer\">Decode the <code>bytes<\/code> object<\/a> to produce a string:<\/p>\n<pre><code>&gt;&gt;&gt; b&quot;abcde&quot;.decode(&quot;utf-8&quot;) \n'abcde'\n<\/code><\/pre>\n<p>The above example <em>assumes<\/em> that the <code>bytes<\/code> object is in UTF-8, because it is a common encoding. However, you should use the encoding your data is actually in!<\/p>\n",
        "community_owned_date": null
    },
    {
        "owner": {
            "account_id": 71746,
            "reputation": 67702,
            "user_id": 207432,
            "user_type": "registered",
            "profile_image": "https:\/\/www.gravatar.com\/avatar\/6813ca950db3b749647569d79b96fbf9?s=256&d=identicon&r=PG",
            "display_name": "Daniel G",
            "link": "https:\/\/stackoverflow.com\/users\/207432\/daniel-g"
        },
        "is_accepted": true,
        "score": 5417,
        "last_activity_date": 1654480948,
        "last_edit_date": 1654480948,
        "creation_date": 1258009626,
        "answer_id": 1720432,
        "question_id": 1720421,
        "content_license": "CC BY-SA 4.0",
        "body_markdown": "Use the `+` operator to combine the lists:\r\n\r\n    listone = [1, 2, 3]\r\n    listtwo = [4, 5, 6]\r\n\r\n    joinedlist = listone + listtwo\r\n\r\nOutput:\r\n\r\n    &gt;&gt;&gt; joinedlist\r\n    [1, 2, 3, 4, 5, 6]\r\n",
        "body": "<p>Use the <code>+<\/code> operator to combine the lists:<\/p>\n<pre><code>listone = [1, 2, 3]\nlisttwo = [4, 5, 6]\n\njoinedlist = listone + listtwo\n<\/code><\/pre>\n<p>Output:<\/p>\n<pre><code>&gt;&gt;&gt; joinedlist\n[1, 2, 3, 4, 5, 6]\n<\/code><\/pre>\n",
        "community_owned_date": null
    },
    {
        "owner": {
            "account_id": 5624,
            "reputation": 86709,
            "user_id": 9161,
            "user_type": "registered",
            "accept_rate": 53,
            "profile_image": "https:\/\/www.gravatar.com\/avatar\/f7a299bf5d76571cdaa91d2d1ff3805e?s=256&d=identicon&r=PG",
            "display_name": "Chris B.",
            "link": "https:\/\/stackoverflow.com\/users\/9161\/chris-b"
        },
        "is_accepted": true,
        "score": 5362,
        "last_activity_date": 1678198341,
        "last_edit_date": 1678198341,
        "creation_date": 1256152221,
        "answer_id": 1602964,
        "question_id": 1602934,
        "content_license": "CC BY-SA 4.0",
        "body_markdown": "[`in`][1] tests for the existence of a key in a [`dict`][2]:\r\n\r\n    d = {&quot;key1&quot;: 10, &quot;key2&quot;: 23}\r\n\r\n    if &quot;key1&quot; in d:\r\n        print(&quot;this will execute&quot;)\r\n    \r\n    if &quot;nonexistent key&quot; in d:\r\n        print(&quot;this will not&quot;)\r\n\r\n---\r\n\r\nUse [`dict.get()`][3] to provide a default value when the key does not exist:\r\n\r\n    d = {}\r\n\r\n    for i in range(100):\r\n        key = i % 10\r\n        d[key] = d.get(key, 0) + 1\r\n\r\n---\r\n\r\nTo provide a default value for *every* key, either use [`dict.setdefault()`][4] on each assignment:\r\n\r\n    d = {}\r\n    \r\n    for i in range(100):\r\n        d[i % 10] = d.setdefault(i % 10, 0) + 1    \r\n\r\n...or better, use [`defaultdict`][5] from the [`collections`][6] module:\r\n\r\n    from collections import defaultdict\r\n\r\n    d = defaultdict(int)\r\n    \r\n    for i in range(100):\r\n        d[i % 10] += 1\r\n\r\n\r\n  [1]: https:\/\/docs.python.org\/reference\/expressions.html#membership-test-operations\r\n  [2]: https:\/\/docs.python.org\/library\/stdtypes.html#dict\r\n  [3]: https:\/\/docs.python.org\/library\/stdtypes.html#dict.get\r\n  [4]: https:\/\/docs.python.org\/library\/stdtypes.html#dict.setdefault\r\n  [5]: https:\/\/docs.python.org\/library\/collections.html#collections.defaultdict\r\n  [6]: https:\/\/docs.python.org\/library\/collections.html",
        "body": "<p><a href=\"https:\/\/docs.python.org\/reference\/expressions.html#membership-test-operations\" rel=\"noreferrer\"><code>in<\/code><\/a> tests for the existence of a key in a <a href=\"https:\/\/docs.python.org\/library\/stdtypes.html#dict\" rel=\"noreferrer\"><code>dict<\/code><\/a>:<\/p>\n<pre><code>d = {&quot;key1&quot;: 10, &quot;key2&quot;: 23}\n\nif &quot;key1&quot; in d:\n    print(&quot;this will execute&quot;)\n\nif &quot;nonexistent key&quot; in d:\n    print(&quot;this will not&quot;)\n<\/code><\/pre>\n<hr \/>\n<p>Use <a href=\"https:\/\/docs.python.org\/library\/stdtypes.html#dict.get\" rel=\"noreferrer\"><code>dict.get()<\/code><\/a> to provide a default value when the key does not exist:<\/p>\n<pre><code>d = {}\n\nfor i in range(100):\n    key = i % 10\n    d[key] = d.get(key, 0) + 1\n<\/code><\/pre>\n<hr \/>\n<p>To provide a default value for <em>every<\/em> key, either use <a href=\"https:\/\/docs.python.org\/library\/stdtypes.html#dict.setdefault\" rel=\"noreferrer\"><code>dict.setdefault()<\/code><\/a> on each assignment:<\/p>\n<pre><code>d = {}\n\nfor i in range(100):\n    d[i % 10] = d.setdefault(i % 10, 0) + 1    \n<\/code><\/pre>\n<p>...or better, use <a href=\"https:\/\/docs.python.org\/library\/collections.html#collections.defaultdict\" rel=\"noreferrer\"><code>defaultdict<\/code><\/a> from the <a href=\"https:\/\/docs.python.org\/library\/collections.html\" rel=\"noreferrer\"><code>collections<\/code><\/a> module:<\/p>\n<pre><code>from collections import defaultdict\n\nd = defaultdict(int)\n\nfor i in range(100):\n    d[i % 10] += 1\n<\/code><\/pre>\n",
        "community_owned_date": null
    },
    {
        "owner": {
            "account_id": 1528135,
            "reputation": 90720,
            "user_id": 1426056,
            "user_type": "registered",
            "accept_rate": 87,
            "profile_image": "https:\/\/www.gravatar.com\/avatar\/3ac815b6fca201737db888a28efd7248?s=256&d=identicon&r=PG",
            "display_name": "waitingkuo",
            "link": "https:\/\/stackoverflow.com\/users\/1426056\/waitingkuo"
        },
        "is_accepted": true,
        "score": 5232,
        "last_activity_date": 1681675636,
        "last_edit_date": 1681675636,
        "creation_date": 1368169678,
        "answer_id": 16476974,
        "question_id": 16476924,
        "content_license": "CC BY-SA 4.0",
        "body_markdown": "\r\n[`DataFrame.iterrows`](https:\/\/pandas.pydata.org\/pandas-docs\/stable\/reference\/api\/pandas.DataFrame.iterrows.html#pandas-dataframe-iterrows) is a generator which yields both the index and row (as a Series):\r\n\r\n\r\n    import pandas as pd\r\n    \r\n    df = pd.DataFrame({&#39;c1&#39;: [10, 11, 12], &#39;c2&#39;: [100, 110, 120]})\r\n    df = df.reset_index()  # make sure indexes pair with number of rows\r\n\r\n    for index, row in df.iterrows():\r\n        print(row[&#39;c1&#39;], row[&#39;c2&#39;])\r\n\r\n&lt;!-- --&gt;\r\n\r\n    10 100\r\n    11 110\r\n    12 120\r\n\r\n----\r\n\r\nObligatory disclaimer from the [documentation](https:\/\/pandas.pydata.org\/docs\/user_guide\/basics.html#iteration)\r\n\r\n&gt; **Iterating through pandas objects is generally slow. In many cases, iterating manually over the rows is not needed** and can be avoided with one of the following approaches:\r\n&gt; * Look for a vectorized solution: many operations can be performed using built-in methods or NumPy functions, (boolean) indexing, \u2026\r\n&gt; * When you have a function that cannot work on the full DataFrame\/Series at once, it is better to use apply() instead of iterating over the values. See the docs on function application.\r\n&gt; * If you need to do iterative manipulations on the values but performance is important, consider writing the inner loop with cython or numba. See the enhancing performance section for some examples of this approach.\r\n\r\nOther answers in this thread delve into greater depth on alternatives to iter* functions if you are interested to learn more.\r\n",
        "body": "<p><a href=\"https:\/\/pandas.pydata.org\/pandas-docs\/stable\/reference\/api\/pandas.DataFrame.iterrows.html#pandas-dataframe-iterrows\" rel=\"noreferrer\"><code>DataFrame.iterrows<\/code><\/a> is a generator which yields both the index and row (as a Series):<\/p>\n<pre><code>import pandas as pd\n\ndf = pd.DataFrame({'c1': [10, 11, 12], 'c2': [100, 110, 120]})\ndf = df.reset_index()  # make sure indexes pair with number of rows\n\nfor index, row in df.iterrows():\n    print(row['c1'], row['c2'])\n<\/code><\/pre>\n\n<pre><code>10 100\n11 110\n12 120\n<\/code><\/pre>\n<hr \/>\n<p>Obligatory disclaimer from the <a href=\"https:\/\/pandas.pydata.org\/docs\/user_guide\/basics.html#iteration\" rel=\"noreferrer\">documentation<\/a><\/p>\n<blockquote>\n<p><strong>Iterating through pandas objects is generally slow. In many cases, iterating manually over the rows is not needed<\/strong> and can be avoided with one of the following approaches:<\/p>\n<ul>\n<li>Look for a vectorized solution: many operations can be performed using built-in methods or NumPy functions, (boolean) indexing, \u2026<\/li>\n<li>When you have a function that cannot work on the full DataFrame\/Series at once, it is better to use apply() instead of iterating over the values. See the docs on function application.<\/li>\n<li>If you need to do iterative manipulations on the values but performance is important, consider writing the inner loop with cython or numba. See the enhancing performance section for some examples of this approach.<\/li>\n<\/ul>\n<\/blockquote>\n<p>Other answers in this thread delve into greater depth on alternatives to iter* functions if you are interested to learn more.<\/p>\n",
        "community_owned_date": null
    },
    {
        "owner": {
            "account_id": 3791,
            "reputation": 67992,
            "user_id": 5536,
            "user_type": "registered",
            "accept_rate": 75,
            "profile_image": "https:\/\/i.stack.imgur.com\/2RAZb.jpg?s=256&g=1",
            "display_name": "Paul Stephenson",
            "link": "https:\/\/stackoverflow.com\/users\/5536\/paul-stephenson"
        },
        "is_accepted": true,
        "score": 5155,
        "last_activity_date": 1677982664,
        "last_edit_date": 1677982664,
        "creation_date": 1231403984,
        "answer_id": 423596,
        "question_id": 423379,
        "content_license": "CC BY-SA 4.0",
        "body_markdown": "You can use a global variable within other functions by declaring it as `global` **within each function that assigns a value to it**:\r\n\r\n    globvar = 0\r\n\r\n    def set_globvar_to_one():\r\n        global globvar    # Needed to modify global copy of globvar\r\n        globvar = 1\r\n\r\n    def print_globvar():\r\n        print(globvar)     # No need for global declaration to read value of globvar\r\n\r\n    set_globvar_to_one()\r\n    print_globvar()       # Prints 1\r\n\r\nSince it&#39;s unclear whether `globvar = 1` is creating a local variable or changing a global variable, Python defaults to creating a local variable, and makes you explicitly choose the other behavior with the `global` keyword.\r\n\r\nSee other answers if you want to share a global variable across modules.",
        "body": "<p>You can use a global variable within other functions by declaring it as <code>global<\/code> <strong>within each function that assigns a value to it<\/strong>:<\/p>\n<pre><code>globvar = 0\n\ndef set_globvar_to_one():\n    global globvar    # Needed to modify global copy of globvar\n    globvar = 1\n\ndef print_globvar():\n    print(globvar)     # No need for global declaration to read value of globvar\n\nset_globvar_to_one()\nprint_globvar()       # Prints 1\n<\/code><\/pre>\n<p>Since it's unclear whether <code>globvar = 1<\/code> is creating a local variable or changing a global variable, Python defaults to creating a local variable, and makes you explicitly choose the other behavior with the <code>global<\/code> keyword.<\/p>\n<p>See other answers if you want to share a global variable across modules.<\/p>\n",
        "community_owned_date": null
    },
    {
        "owner": {
            "account_id": 18469,
            "reputation": 165401,
            "user_id": 42346,
            "user_type": "registered",
            "profile_image": "https:\/\/i.stack.imgur.com\/ZikEw.jpg?s=256&g=1",
            "display_name": "mechanical_meat",
            "link": "https:\/\/stackoverflow.com\/users\/42346\/mechanical-meat"
        },
        "is_accepted": true,
        "score": 5056,
        "last_activity_date": 1521727008,
        "last_edit_date": 1521727008,
        "creation_date": 1308930994,
        "answer_id": 6470452,
        "question_id": 6470428,
        "content_license": "CC BY-SA 3.0",
        "body_markdown": "From [Python Documentation](https:\/\/docs.python.org\/3\/tutorial\/errors.html#handling-exceptions):\r\n&gt; An except clause may name multiple exceptions as a parenthesized tuple, for example\r\n\r\n    except (IDontLikeYouException, YouAreBeingMeanException) as e:\r\n        pass\r\n\r\nOr, for Python 2 only:\r\n\r\n    except (IDontLikeYouException, YouAreBeingMeanException), e:\r\n        pass\r\n \r\nSeparating the exception from the variable with a comma will still work in Python 2.6 and 2.7, but is now deprecated and does not work in Python 3; now you should be using `as`.",
        "body": "<p>From <a href=\"https:\/\/docs.python.org\/3\/tutorial\/errors.html#handling-exceptions\" rel=\"noreferrer\">Python Documentation<\/a>:<\/p>\n\n<blockquote>\n  <p>An except clause may name multiple exceptions as a parenthesized tuple, for example<\/p>\n<\/blockquote>\n\n<pre><code>except (IDontLikeYouException, YouAreBeingMeanException) as e:\n    pass\n<\/code><\/pre>\n\n<p>Or, for Python 2 only:<\/p>\n\n<pre><code>except (IDontLikeYouException, YouAreBeingMeanException), e:\n    pass\n<\/code><\/pre>\n\n<p>Separating the exception from the variable with a comma will still work in Python 2.6 and 2.7, but is now deprecated and does not work in Python 3; now you should be using <code>as<\/code>.<\/p>\n",
        "community_owned_date": null
    },
    {
        "owner": {
            "account_id": 11369,
            "reputation": 274588,
            "user_id": 21886,
            "user_type": "registered",
            "accept_rate": 88,
            "profile_image": "https:\/\/www.gravatar.com\/avatar\/38750c50c11e6054c2123073b17b18fc?s=256&d=identicon&r=PG",
            "display_name": "RichieHindle",
            "link": "https:\/\/stackoverflow.com\/users\/21886\/richiehindle"
        },
        "is_accepted": true,
        "score": 4792,
        "last_activity_date": 1696921496,
        "last_edit_date": 1696921496,
        "creation_date": 1312895259,
        "answer_id": 6996628,
        "question_id": 6996603,
        "content_license": "CC BY-SA 4.0",
        "body_markdown": "Use one of these methods:\r\n\r\n* [`pathlib.Path.unlink()`][5] removes a file or symbolic link.\r\n\r\n* [`pathlib.Path.rmdir()`][6] removes an empty directory.\r\n\r\n* [`shutil.rmtree()`][3] deletes a directory and all its contents.\r\n\r\n---\r\n\r\nOn Python 3.3 and below, you can use these methods instead of the [`pathlib`](https:\/\/docs.python.org\/3\/library\/pathlib.html) ones:\r\n\r\n- [`os.remove()`][1] removes a file.\r\n- [`os.unlink()`](https:\/\/docs.python.org\/3\/library\/os.html#os.unlink) removes a symbolic link.\r\n\r\n- [`os.rmdir()`][2] removes an empty directory.\r\n\r\n\r\n\r\n\r\n  [1]: http:\/\/docs.python.org\/library\/os.html#os.remove\r\n  [2]: http:\/\/docs.python.org\/library\/os.html#os.rmdir\r\n  [3]: http:\/\/docs.python.org\/library\/shutil.html#shutil.rmtree\r\n  [4]: https:\/\/docs.python.org\/3\/library\/pathlib.html#pathlib.Path\r\n  [5]: https:\/\/docs.python.org\/3\/library\/pathlib.html#pathlib.Path.unlink\r\n  [6]: https:\/\/docs.python.org\/3\/library\/pathlib.html#pathlib.Path.rmdir",
        "body": "<p>Use one of these methods:<\/p>\n<ul>\n<li><p><a href=\"https:\/\/docs.python.org\/3\/library\/pathlib.html#pathlib.Path.unlink\" rel=\"noreferrer\"><code>pathlib.Path.unlink()<\/code><\/a> removes a file or symbolic link.<\/p>\n<\/li>\n<li><p><a href=\"https:\/\/docs.python.org\/3\/library\/pathlib.html#pathlib.Path.rmdir\" rel=\"noreferrer\"><code>pathlib.Path.rmdir()<\/code><\/a> removes an empty directory.<\/p>\n<\/li>\n<li><p><a href=\"http:\/\/docs.python.org\/library\/shutil.html#shutil.rmtree\" rel=\"noreferrer\"><code>shutil.rmtree()<\/code><\/a> deletes a directory and all its contents.<\/p>\n<\/li>\n<\/ul>\n<hr \/>\n<p>On Python 3.3 and below, you can use these methods instead of the <a href=\"https:\/\/docs.python.org\/3\/library\/pathlib.html\" rel=\"noreferrer\"><code>pathlib<\/code><\/a> ones:<\/p>\n<ul>\n<li><p><a href=\"http:\/\/docs.python.org\/library\/os.html#os.remove\" rel=\"noreferrer\"><code>os.remove()<\/code><\/a> removes a file.<\/p>\n<\/li>\n<li><p><a href=\"https:\/\/docs.python.org\/3\/library\/os.html#os.unlink\" rel=\"noreferrer\"><code>os.unlink()<\/code><\/a> removes a symbolic link.<\/p>\n<\/li>\n<li><p><a href=\"http:\/\/docs.python.org\/library\/os.html#os.rmdir\" rel=\"noreferrer\"><code>os.rmdir()<\/code><\/a> removes an empty directory.<\/p>\n<\/li>\n<\/ul>\n",
        "community_owned_date": null
    },
    {
        "owner": {
            "account_id": 6018,
            "reputation": 583451,
            "user_id": 9951,
            "user_type": "registered",
            "accept_rate": 78,
            "profile_image": "https:\/\/i.stack.imgur.com\/CIFG8.png?s=256&g=1",
            "display_name": "Bite code",
            "link": "https:\/\/stackoverflow.com\/users\/9951\/bite-code"
        },
        "is_accepted": false,
        "score": 4769,
        "last_activity_date": 1619473774,
        "last_edit_date": 1619473774,
        "creation_date": 1256043946,
        "answer_id": 1594484,
        "question_id": 739654,
        "content_license": "CC BY-SA 4.0",
        "body_markdown": "If you are not into long explanations, see [Paolo Bergantino\u2019s answer][2].\r\n\r\n\r\n# Decorator Basics\r\n\r\n## Python\u2019s functions are objects\r\n\r\nTo understand decorators, you must first understand that functions are objects in Python. This has important consequences. Let\u2019s see why with a simple example :\r\n\r\n    def shout(word=&quot;yes&quot;):\r\n        return word.capitalize()+&quot;!&quot;\r\n\r\n    print(shout())\r\n    # outputs : &#39;Yes!&#39;\r\n\r\n    # As an object, you can assign the function to a variable like any other object \r\n    scream = shout\r\n\r\n    # Notice we don&#39;t use parentheses: we are not calling the function,\r\n    # we are putting the function &quot;shout&quot; into the variable &quot;scream&quot;.\r\n    # It means you can then call &quot;shout&quot; from &quot;scream&quot;:\r\n\r\n    print(scream())\r\n    # outputs : &#39;Yes!&#39;\r\n\r\n    # More than that, it means you can remove the old name &#39;shout&#39;,\r\n    #&#160;and the function will still be accessible from &#39;scream&#39;\r\n\r\n    del shout\r\n    try:\r\n        print(shout())\r\n    except NameError as e:\r\n        print(e)\r\n        #outputs: &quot;name &#39;shout&#39; is not defined&quot;\r\n\r\n    print(scream())\r\n    # outputs: &#39;Yes!&#39;\r\n\r\nKeep this in mind. We\u2019ll circle back to it shortly. \r\n\r\nAnother interesting property of Python functions is they can be defined inside another function!\r\n\r\n    def talk():\r\n\r\n        # You can define a function on the fly in &quot;talk&quot; ...\r\n        def whisper(word=&quot;yes&quot;):\r\n            return word.lower()+&quot;...&quot;\r\n\r\n        # ... and use it right away!\r\n        print(whisper())\r\n\r\n    # You call &quot;talk&quot;, that defines &quot;whisper&quot; EVERY TIME you call it, then\r\n    # &quot;whisper&quot; is called in &quot;talk&quot;. \r\n    talk()\r\n    # outputs: \r\n    # &quot;yes...&quot;\r\n\r\n    # But &quot;whisper&quot; DOES NOT EXIST outside &quot;talk&quot;:\r\n\r\n    try:\r\n        print(whisper())\r\n    except NameError as e:\r\n        print(e)\r\n        #outputs : &quot;name &#39;whisper&#39; is not defined&quot;*\r\n        #Python&#39;s functions are objects\r\n\r\n\r\n## Functions references\r\n\r\nOkay, still here? Now the fun part...\r\n\r\nYou\u2019ve seen that functions are objects. Therefore, functions:\r\n\r\n- can be assigned to a variable\r\n- can be defined in another function\r\n\r\nThat means that **a function can `return` another function**.\r\n\r\n    def getTalk(kind=&quot;shout&quot;):\r\n\r\n        # We define functions on the fly\r\n        def shout(word=&quot;yes&quot;):\r\n            return word.capitalize()+&quot;!&quot;\r\n\r\n        def whisper(word=&quot;yes&quot;) :\r\n            return word.lower()+&quot;...&quot;\r\n\r\n        # Then we return one of them\r\n        if kind == &quot;shout&quot;:\r\n            # We don&#39;t use &quot;()&quot;, we are not calling the function,\r\n            # we are returning the function object\r\n            return shout  \r\n        else:\r\n            return whisper\r\n\r\n    # How do you use this strange beast?\r\n\r\n    # Get the function and assign it to a variable\r\n    talk = getTalk()      \r\n\r\n    # You can see that &quot;talk&quot; is here a function object:\r\n    print(talk)\r\n    #outputs : &lt;function shout at 0xb7ea817c&gt;\r\n\r\n    # The object is the one returned by the function:\r\n    print(talk())\r\n    #outputs : Yes!\r\n\r\n    # And you can even use it directly if you feel wild:\r\n    print(getTalk(&quot;whisper&quot;)())\r\n    #outputs : yes...\r\n\r\nThere\u2019s more! \r\n\r\nIf you can `return` a function, you can pass one as a parameter:\r\n\r\n    def doSomethingBefore(func): \r\n        print(&quot;I do something before then I call the function you gave me&quot;)\r\n        print(func())\r\n\r\n    doSomethingBefore(scream)\r\n    #outputs: \r\n    #I do something before then I call the function you gave me\r\n    #Yes!\r\n\r\nWell, you just have everything needed to understand decorators. You see, decorators are \u201cwrappers\u201d, which means that **they let you execute code before and after the function they decorate** without modifying the function itself.\r\n\r\n\r\n## Handcrafted decorators\r\n\r\nHow you\u2019d do it manually:\r\n\r\n    # A decorator is a function that expects ANOTHER function as parameter\r\n    def my_shiny_new_decorator(a_function_to_decorate):\r\n\r\n        # Inside, the decorator defines a function on the fly: the wrapper.\r\n        # This function is going to be wrapped around the original function\r\n        # so it can execute code before and after it.\r\n        def the_wrapper_around_the_original_function():\r\n\r\n            # Put here the code you want to be executed BEFORE the original function is called\r\n            print(&quot;Before the function runs&quot;)\r\n\r\n            # Call the function here (using parentheses)\r\n            a_function_to_decorate()\r\n\r\n            # Put here the code you want to be executed AFTER the original function is called\r\n            print(&quot;After the function runs&quot;)\r\n\r\n        # At this point, &quot;a_function_to_decorate&quot; HAS NEVER BEEN EXECUTED.\r\n        # We return the wrapper function we have just created.\r\n        # The wrapper contains the function and the code to execute before and after. It\u2019s ready to use!\r\n        return the_wrapper_around_the_original_function\r\n\r\n    # Now imagine you create a function you don&#39;t want to ever touch again.\r\n    def a_stand_alone_function():\r\n        print(&quot;I am a stand alone function, don&#39;t you dare modify me&quot;)\r\n\r\n    a_stand_alone_function() \r\n    #outputs: I am a stand alone function, don&#39;t you dare modify me\r\n\r\n    # Well, you can decorate it to extend its behavior.\r\n    # Just pass it to the decorator, it will wrap it dynamically in \r\n    # any code you want and return you a new function ready to be used:\r\n\r\n    a_stand_alone_function_decorated = my_shiny_new_decorator(a_stand_alone_function)\r\n    a_stand_alone_function_decorated()\r\n    #outputs:\r\n    #Before the function runs\r\n    #I am a stand alone function, don&#39;t you dare modify me\r\n    #After the function runs\r\n\r\nNow, you probably want that every time you call `a_stand_alone_function`, `a_stand_alone_function_decorated` is called instead. That\u2019s easy, just overwrite `a_stand_alone_function` with the function returned by `my_shiny_new_decorator`:\r\n\r\n    a_stand_alone_function = my_shiny_new_decorator(a_stand_alone_function)\r\n    a_stand_alone_function()\r\n    #outputs:\r\n    #Before the function runs\r\n    #I am a stand alone function, don&#39;t you dare modify me\r\n    #After the function runs\r\n\r\n    # That\u2019s EXACTLY what decorators do!\r\n\r\n\r\n## Decorators demystified\r\n\r\nThe previous example, using the decorator syntax:\r\n\r\n    @my_shiny_new_decorator\r\n    def another_stand_alone_function():\r\n        print(&quot;Leave me alone&quot;)\r\n\r\n    another_stand_alone_function()  \r\n    #outputs:  \r\n    #Before the function runs\r\n    #Leave me alone\r\n    #After the function runs\r\n\r\nYes, that\u2019s all, it\u2019s that simple. `@decorator` is just a shortcut to:\r\n\r\n    another_stand_alone_function = my_shiny_new_decorator(another_stand_alone_function)\r\n\r\nDecorators are just a pythonic variant of the [decorator design pattern][3]. There are several classic design patterns embedded in Python to ease development (like iterators).\r\n\r\nOf course, you can accumulate decorators:\r\n\r\n    def bread(func):\r\n        def wrapper():\r\n            print(&quot;&lt;\/&#39;&#39;&#39;&#39;&#39;&#39;\\&gt;&quot;)\r\n            func()\r\n            print(&quot;&lt;\\______\/&gt;&quot;)\r\n        return wrapper\r\n\r\n    def ingredients(func):\r\n        def wrapper():\r\n            print(&quot;#tomatoes#&quot;)\r\n            func()\r\n            print(&quot;~salad~&quot;)\r\n        return wrapper\r\n\r\n    def sandwich(food=&quot;--ham--&quot;):\r\n        print(food)\r\n\r\n    sandwich()\r\n    #outputs: --ham--\r\n    sandwich = bread(ingredients(sandwich))\r\n    sandwich()\r\n    #outputs:\r\n    #&lt;\/&#39;&#39;&#39;&#39;&#39;&#39;\\&gt;\r\n    # #tomatoes#\r\n    # --ham--\r\n    # ~salad~\r\n    #&lt;\\______\/&gt;\r\n\r\nUsing the Python decorator syntax:\r\n\r\n    @bread\r\n    @ingredients\r\n    def sandwich(food=&quot;--ham--&quot;):\r\n        print(food)\r\n\r\n    sandwich()\r\n    #outputs:\r\n    #&lt;\/&#39;&#39;&#39;&#39;&#39;&#39;\\&gt;\r\n    # #tomatoes#\r\n    # --ham--\r\n    # ~salad~\r\n    #&lt;\\______\/&gt;\r\n\r\nThe order you set the decorators MATTERS:\r\n\r\n    @ingredients\r\n    @bread\r\n    def strange_sandwich(food=&quot;--ham--&quot;):\r\n        print(food)\r\n\r\n    strange_sandwich()\r\n    #outputs:\r\n    ##tomatoes#\r\n    #&lt;\/&#39;&#39;&#39;&#39;&#39;&#39;\\&gt;\r\n    # --ham--\r\n    #&lt;\\______\/&gt;\r\n    # ~salad~\r\n\r\n\r\n----\r\n\r\n# Now: to answer the question...\r\n\r\nAs a conclusion, you can easily see how to answer the question:\r\n\r\n    # The decorator to make it bold\r\n    def makebold(fn):\r\n        # The new function the decorator returns\r\n        def wrapper():\r\n            # Insertion of some code before and after\r\n            return &quot;&lt;b&gt;&quot; + fn() + &quot;&lt;\/b&gt;&quot;\r\n        return wrapper\r\n\r\n    # The decorator to make it italic\r\n    def makeitalic(fn):\r\n        # The new function the decorator returns\r\n        def wrapper():\r\n            # Insertion of some code before and after\r\n            return &quot;&lt;i&gt;&quot; + fn() + &quot;&lt;\/i&gt;&quot;\r\n        return wrapper\r\n\r\n    @makebold\r\n    @makeitalic\r\n    def say():\r\n        return &quot;hello&quot;\r\n\r\n    print(say())\r\n    #outputs: &lt;b&gt;&lt;i&gt;hello&lt;\/i&gt;&lt;\/b&gt;\r\n\r\n    # This is the exact equivalent to \r\n    def say():\r\n        return &quot;hello&quot;\r\n    say = makebold(makeitalic(say))\r\n\r\n    print(say())\r\n    #outputs: &lt;b&gt;&lt;i&gt;hello&lt;\/i&gt;&lt;\/b&gt;\r\n\r\n\r\nYou can now just leave happy, or burn your brain a little bit more and see advanced uses of decorators.\r\n\r\n----\r\n\r\n# Taking decorators to the next level\r\n\r\n## Passing arguments to the decorated function\r\n\r\n    # It\u2019s not black magic, you just have to let the wrapper \r\n    # pass the argument:\r\n\r\n    def a_decorator_passing_arguments(function_to_decorate):\r\n        def a_wrapper_accepting_arguments(arg1, arg2):\r\n            print(&quot;I got args! Look: {0}, {1}&quot;.format(arg1, arg2))\r\n            function_to_decorate(arg1, arg2)\r\n        return a_wrapper_accepting_arguments\r\n\r\n    # Since when you are calling the function returned by the decorator, you are\r\n    # calling the wrapper, passing arguments to the wrapper will let it pass them to \r\n    # the decorated function\r\n\r\n    @a_decorator_passing_arguments\r\n    def print_full_name(first_name, last_name):\r\n        print(&quot;My name is {0} {1}&quot;.format(first_name, last_name))\r\n        \r\n    print_full_name(&quot;Peter&quot;, &quot;Venkman&quot;)\r\n    # outputs:\r\n    #I got args! Look: Peter Venkman\r\n    #My name is Peter Venkman\r\n\r\n\r\n## Decorating methods\r\n\r\nOne nifty thing about Python is that methods and functions are really the same.  The only difference is that methods expect that their first argument is a reference to the current object (`self`). \r\n\r\nThat means you can build a decorator for methods the same way! Just remember to take `self` into consideration:\r\n        \r\n    def method_friendly_decorator(method_to_decorate):\r\n        def wrapper(self, lie):\r\n            lie = lie - 3 # very friendly, decrease age even more :-)\r\n            return method_to_decorate(self, lie)\r\n        return wrapper\r\n        \r\n        \r\n    class Lucy(object):\r\n        \r\n        def __init__(self):\r\n            self.age = 32\r\n        \r\n        @method_friendly_decorator\r\n        def sayYourAge(self, lie):\r\n            print(&quot;I am {0}, what did you think?&quot;.format(self.age + lie))\r\n            \r\n    l = Lucy()\r\n    l.sayYourAge(-3)\r\n    #outputs: I am 26, what did you think?\r\n\r\nIf you\u2019re making general-purpose decorator--one you\u2019ll apply to any function or method, no matter its arguments--then just use `*args, **kwargs`:\r\n\r\n    def a_decorator_passing_arbitrary_arguments(function_to_decorate):\r\n        # The wrapper accepts any arguments\r\n        def a_wrapper_accepting_arbitrary_arguments(*args, **kwargs):\r\n            print(&quot;Do I have args?:&quot;)\r\n            print(args)\r\n            print(kwargs)\r\n            # Then you unpack the arguments, here *args, **kwargs\r\n            # If you are not familiar with unpacking, check:\r\n            # http:\/\/www.saltycrane.com\/blog\/2008\/01\/how-to-use-args-and-kwargs-in-python\/\r\n            function_to_decorate(*args, **kwargs)\r\n        return a_wrapper_accepting_arbitrary_arguments\r\n\r\n    @a_decorator_passing_arbitrary_arguments\r\n    def function_with_no_argument():\r\n        print(&quot;Python is cool, no argument here.&quot;)\r\n\r\n    function_with_no_argument()\r\n    #outputs\r\n    #Do I have args?:\r\n    #()\r\n    #{}\r\n    #Python is cool, no argument here.\r\n\r\n    @a_decorator_passing_arbitrary_arguments\r\n    def function_with_arguments(a, b, c):\r\n        print(a, b, c)\r\n        \r\n    function_with_arguments(1,2,3)\r\n    #outputs\r\n    #Do I have args?:\r\n    #(1, 2, 3)\r\n    #{}\r\n    #1 2 3 \r\n     \r\n    @a_decorator_passing_arbitrary_arguments\r\n    def function_with_named_arguments(a, b, c, platypus=&quot;Why not ?&quot;):\r\n        print(&quot;Do {0}, {1} and {2} like platypus? {3}&quot;.format(a, b, c, platypus))\r\n\r\n    function_with_named_arguments(&quot;Bill&quot;, &quot;Linus&quot;, &quot;Steve&quot;, platypus=&quot;Indeed!&quot;)\r\n    #outputs\r\n    #Do I have args ? :\r\n    #(&#39;Bill&#39;, &#39;Linus&#39;, &#39;Steve&#39;)\r\n    #{&#39;platypus&#39;: &#39;Indeed!&#39;}\r\n    #Do Bill, Linus and Steve like platypus? Indeed!\r\n\r\n    class Mary(object):\r\n        \r\n        def __init__(self):\r\n            self.age = 31\r\n        \r\n        @a_decorator_passing_arbitrary_arguments\r\n        def sayYourAge(self, lie=-3): # You can now add a default value\r\n            print(&quot;I am {0}, what did you think?&quot;.format(self.age + lie))\r\n\r\n    m = Mary()\r\n    m.sayYourAge()\r\n    #outputs\r\n    # Do I have args?:\r\n    #(&lt;__main__.Mary object at 0xb7d303ac&gt;,)\r\n    #{}\r\n    #I am 28, what did you think?\r\n\r\n\r\n## Passing arguments to the decorator\r\n\r\nGreat, now what would you say about passing arguments to the decorator itself? \r\n\r\nThis can get somewhat twisted, since a decorator must accept a function as an argument. Therefore, you cannot pass the decorated function\u2019s arguments directly to the decorator.\r\n\r\nBefore rushing to the solution, let\u2019s write a little reminder: \r\n\r\n    # Decorators are ORDINARY functions\r\n    def my_decorator(func):\r\n        print(&quot;I am an ordinary function&quot;)\r\n        def wrapper():\r\n            print(&quot;I am function returned by the decorator&quot;)\r\n            func()\r\n        return wrapper\r\n\r\n    # Therefore, you can call it without any &quot;@&quot;\r\n\r\n    def lazy_function():\r\n        print(&quot;zzzzzzzz&quot;)\r\n\r\n    decorated_function = my_decorator(lazy_function)\r\n    #outputs: I am an ordinary function\r\n                \r\n    # It outputs &quot;I am an ordinary function&quot;, because that\u2019s just what you do:\r\n    # calling a function. Nothing magic.\r\n\r\n    @my_decorator\r\n    def lazy_function():\r\n        print(&quot;zzzzzzzz&quot;)\r\n        \r\n    #outputs: I am an ordinary function\r\n\r\nIt\u2019s exactly the same. &quot;`my_decorator`&quot; is called. So when you `@my_decorator`, you are telling Python to call the function &#39;labelled by the variable &quot;`my_decorator`&quot;&#39;. \r\n\r\nThis is important! The label you give can point directly to the decorator\u2014**or not**. \r\n\r\nLet\u2019s get evil. \u263a\r\n\r\n    def decorator_maker():\r\n        \r\n        print(&quot;I make decorators! I am executed only once: &quot;\r\n              &quot;when you make me create a decorator.&quot;)\r\n                \r\n        def my_decorator(func):\r\n            \r\n            print(&quot;I am a decorator! I am executed only when you decorate a function.&quot;)\r\n                   \r\n            def wrapped():\r\n                print(&quot;I am the wrapper around the decorated function. &quot;\r\n                      &quot;I am called when you call the decorated function. &quot;\r\n                      &quot;As the wrapper, I return the RESULT of the decorated function.&quot;)\r\n                return func()\r\n            \r\n            print(&quot;As the decorator, I return the wrapped function.&quot;)\r\n            \r\n            return wrapped\r\n        \r\n        print(&quot;As a decorator maker, I return a decorator&quot;)\r\n        return my_decorator\r\n                \r\n    # Let\u2019s create a decorator. It\u2019s just a new function after all.\r\n    new_decorator = decorator_maker()       \r\n    #outputs:\r\n    #I make decorators! I am executed only once: when you make me create a decorator.\r\n    #As a decorator maker, I return a decorator\r\n\r\n    # Then we decorate the function\r\n                \r\n    def decorated_function():\r\n        print(&quot;I am the decorated function.&quot;)\r\n       \r\n    decorated_function = new_decorator(decorated_function)\r\n    #outputs:\r\n    #I am a decorator! I am executed only when you decorate a function.\r\n    #As the decorator, I return the wrapped function\r\n         \r\n    # Let\u2019s call the function:\r\n    decorated_function()\r\n    #outputs:\r\n    #I am the wrapper around the decorated function. I am called when you call the decorated function.\r\n    #As the wrapper, I return the RESULT of the decorated function.\r\n    #I am the decorated function.\r\n\r\nNo surprise here. \r\n\r\nLet\u2019s do EXACTLY the same thing, but skip all the pesky intermediate variables:\r\n\r\n    def decorated_function():\r\n        print(&quot;I am the decorated function.&quot;)\r\n    decorated_function = decorator_maker()(decorated_function)\r\n    #outputs:\r\n    #I make decorators! I am executed only once: when you make me create a decorator.\r\n    #As a decorator maker, I return a decorator\r\n    #I am a decorator! I am executed only when you decorate a function.\r\n    #As the decorator, I return the wrapped function.\r\n\r\n    # Finally:\r\n    decorated_function()    \r\n    #outputs:\r\n    #I am the wrapper around the decorated function. I am called when you call the decorated function.\r\n    #As the wrapper, I return the RESULT of the decorated function.\r\n    #I am the decorated function.\r\n\r\nLet\u2019s make it *even shorter*:\r\n\r\n    @decorator_maker()\r\n    def decorated_function():\r\n        print(&quot;I am the decorated function.&quot;)\r\n    #outputs:\r\n    #I make decorators! I am executed only once: when you make me create a decorator.\r\n    #As a decorator maker, I return a decorator\r\n    #I am a decorator! I am executed only when you decorate a function.\r\n    #As the decorator, I return the wrapped function.\r\n\r\n    #Eventually: \r\n    decorated_function()    \r\n    #outputs:\r\n    #I am the wrapper around the decorated function. I am called when you call the decorated function.\r\n    #As the wrapper, I return the RESULT of the decorated function.\r\n    #I am the decorated function.\r\n\r\nHey, did you see that? We used a function call with the &quot;`@`&quot; syntax! :-)\r\n\r\nSo, back to decorators with arguments. If we can use functions to generate the decorator on the fly, we can pass arguments to that function, right?\r\n\r\n    def decorator_maker_with_arguments(decorator_arg1, decorator_arg2):\r\n        \r\n        print(&quot;I make decorators! And I accept arguments: {0}, {1}&quot;.format(decorator_arg1, decorator_arg2))\r\n                \r\n        def my_decorator(func):\r\n            # The ability to pass arguments here is a gift from closures.\r\n            # If you are not comfortable with closures, you can assume it\u2019s ok,\r\n            # or read: https:\/\/stackoverflow.com\/questions\/13857\/can-you-explain-closures-as-they-relate-to-python\r\n            print(&quot;I am the decorator. Somehow you passed me arguments: {0}, {1}&quot;.format(decorator_arg1, decorator_arg2))\r\n                   \r\n            # Don&#39;t confuse decorator arguments and function arguments!\r\n            def wrapped(function_arg1, function_arg2) :\r\n                print(&quot;I am the wrapper around the decorated function.\\n&quot;\r\n                      &quot;I can access all the variables\\n&quot;\r\n                      &quot;\\t- from the decorator: {0} {1}\\n&quot;\r\n                      &quot;\\t- from the function call: {2} {3}\\n&quot;\r\n                      &quot;Then I can pass them to the decorated function&quot;\r\n                      .format(decorator_arg1, decorator_arg2,\r\n                              function_arg1, function_arg2))\r\n                return func(function_arg1, function_arg2)\r\n            \r\n            return wrapped\r\n        \r\n        return my_decorator\r\n\r\n    @decorator_maker_with_arguments(&quot;Leonard&quot;, &quot;Sheldon&quot;)\r\n    def decorated_function_with_arguments(function_arg1, function_arg2):\r\n        print(&quot;I am the decorated function and only knows about my arguments: {0}&quot;\r\n               &quot; {1}&quot;.format(function_arg1, function_arg2))\r\n              \r\n    decorated_function_with_arguments(&quot;Rajesh&quot;, &quot;Howard&quot;)\r\n    #outputs:\r\n    #I make decorators! And I accept arguments: Leonard Sheldon\r\n    #I am the decorator. Somehow you passed me arguments: Leonard Sheldon\r\n    #I am the wrapper around the decorated function. \r\n    #I can access all the variables \r\n    #\t- from the decorator: Leonard Sheldon \r\n    #\t- from the function call: Rajesh Howard \r\n    #Then I can pass them to the decorated function\r\n    #I am the decorated function and only knows about my arguments: Rajesh Howard\r\n\r\nHere it is: a decorator with arguments. Arguments can be set as variable:\r\n\r\n    c1 = &quot;Penny&quot;\r\n    c2 = &quot;Leslie&quot;\r\n\r\n    @decorator_maker_with_arguments(&quot;Leonard&quot;, c1)\r\n    def decorated_function_with_arguments(function_arg1, function_arg2):\r\n        print(&quot;I am the decorated function and only knows about my arguments:&quot;\r\n               &quot; {0} {1}&quot;.format(function_arg1, function_arg2))\r\n\r\n    decorated_function_with_arguments(c2, &quot;Howard&quot;)\r\n    #outputs:\r\n    #I make decorators! And I accept arguments: Leonard Penny\r\n    #I am the decorator. Somehow you passed me arguments: Leonard Penny\r\n    #I am the wrapper around the decorated function. \r\n    #I can access all the variables \r\n    #\t- from the decorator: Leonard Penny \r\n    #\t- from the function call: Leslie Howard \r\n    #Then I can pass them to the decorated function\r\n    #I am the decorated function and only know about my arguments: Leslie Howard\r\n\r\nAs you can see, you can pass arguments to the decorator like any function using this trick. You can even use `*args, **kwargs` if you wish. But remember decorators are called **only once**. Just when Python imports the script. You can&#39;t dynamically set the arguments afterwards. When you do &quot;import x&quot;, **the function is already decorated**, so you can&#39;t\r\nchange anything.\r\n\r\n----\r\n\r\n# Let\u2019s practice: decorating a decorator\r\n\r\nOkay, as a bonus, I&#39;ll give you a snippet to make any decorator accept generically any argument. After all, in order to accept arguments, we created our decorator using another function. \r\n\r\nWe wrapped the decorator.\r\n\r\nAnything else we saw recently that wrapped function?\r\n\r\nOh yes, decorators!\r\n\r\nLet\u2019s have some fun and write a decorator for the decorators:\r\n\r\n    def decorator_with_args(decorator_to_enhance):\r\n        &quot;&quot;&quot; \r\n        This function is supposed to be used as a decorator.\r\n        It must decorate an other function, that is intended to be used as a decorator.\r\n        Take a cup of coffee.\r\n        It will allow any decorator to accept an arbitrary number of arguments,\r\n        saving you the headache to remember how to do that every time.\r\n        &quot;&quot;&quot;\r\n        \r\n        # We use the same trick we did to pass arguments\r\n        def decorator_maker(*args, **kwargs):\r\n           \r\n            # We create on the fly a decorator that accepts only a function\r\n            # but keeps the passed arguments from the maker.\r\n            def decorator_wrapper(func):\r\n           \r\n                # We return the result of the original decorator, which, after all, \r\n                # IS JUST AN ORDINARY FUNCTION (which returns a function).\r\n                # Only pitfall: the decorator must have this specific signature or it won&#39;t work:\r\n                return decorator_to_enhance(func, *args, **kwargs)\r\n            \r\n            return decorator_wrapper\r\n        \r\n        return decorator_maker\r\n           \r\nIt can be used as follows:\r\n        \r\n    # You create the function you will use as a decorator. And stick a decorator on it :-)\r\n    # Don&#39;t forget, the signature is &quot;decorator(func, *args, **kwargs)&quot;\r\n    @decorator_with_args \r\n    def decorated_decorator(func, *args, **kwargs): \r\n        def wrapper(function_arg1, function_arg2):\r\n            print(&quot;Decorated with {0} {1}&quot;.format(args, kwargs))\r\n            return func(function_arg1, function_arg2)\r\n        return wrapper\r\n        \r\n    # Then you decorate the functions you wish with your brand new decorated decorator.\r\n\r\n    @decorated_decorator(42, 404, 1024)\r\n    def decorated_function(function_arg1, function_arg2):\r\n        print(&quot;Hello {0} {1}&quot;.format(function_arg1, function_arg2))\r\n\r\n    decorated_function(&quot;Universe and&quot;, &quot;everything&quot;)\r\n    #outputs:\r\n    #Decorated with (42, 404, 1024) {}\r\n    #Hello Universe and everything\r\n\r\n    # Whoooot!\r\n    \r\nI know, the last time you had this feeling, it was after listening a guy saying: &quot;before understanding recursion, you must first understand recursion&quot;. But now, don&#39;t you feel good about mastering this?\r\n\r\n----\r\n\r\n# Best practices: decorators\r\n\r\n- Decorators were introduced in Python 2.4, so be sure your code will be run on &gt;= 2.4. \r\n- Decorators slow down the function call. Keep that in mind.\r\n- **You cannot un-decorate a function.** (There *are* hacks to create decorators that can be removed, but nobody uses them.) So once a function is decorated, it\u2019s decorated *for all the code*.\r\n- Decorators wrap functions, which can make them hard to debug.  (This gets better from Python &gt;= 2.5; see below.)\r\n\r\nThe `functools` module was introduced in Python 2.5. It includes the function `functools.wraps()`, which copies the name, module, and docstring of the decorated function to its wrapper. \r\n\r\n(Fun fact: `functools.wraps()` is a decorator! \u263a)\r\n\r\n    # For debugging, the stacktrace prints you the function __name__\r\n    def foo():\r\n        print(&quot;foo&quot;)\r\n        \r\n    print(foo.__name__)\r\n    #outputs: foo\r\n        \r\n    # With a decorator, it gets messy    \r\n    def bar(func):\r\n        def wrapper():\r\n            print(&quot;bar&quot;)\r\n            return func()\r\n        return wrapper\r\n\r\n    @bar\r\n    def foo():\r\n        print(&quot;foo&quot;)\r\n\r\n    print(foo.__name__)\r\n    #outputs: wrapper\r\n\r\n    # &quot;functools&quot; can help for that\r\n\r\n    import functools\r\n\r\n    def bar(func):\r\n        # We say that &quot;wrapper&quot;, is wrapping &quot;func&quot;\r\n        # and the magic begins\r\n        @functools.wraps(func)\r\n        def wrapper():\r\n            print(&quot;bar&quot;)\r\n            return func()\r\n        return wrapper\r\n\r\n    @bar\r\n    def foo():\r\n        print(&quot;foo&quot;)\r\n\r\n    print(foo.__name__)\r\n    #outputs: foo\r\n\r\n----\r\n\r\n# How can the decorators be useful?\r\n\r\n**Now the big question:** What can I use decorators for? \r\n\r\nSeem cool and powerful, but a practical example would be great. Well, there are 1000 possibilities. Classic uses are extending a function behavior from an external lib (you can&#39;t modify it), or for debugging (you don&#39;t want to modify it because it\u2019s temporary). \r\n\r\nYou can use them to extend several functions in a DRY\u2019s way, like so:\r\n\r\n        \r\n    def benchmark(func):\r\n        &quot;&quot;&quot;\r\n        A decorator that prints the time a function takes\r\n        to execute.\r\n        &quot;&quot;&quot;\r\n        import time\r\n        def wrapper(*args, **kwargs):\r\n            t = time.clock()\r\n            res = func(*args, **kwargs)\r\n            print(&quot;{0} {1}&quot;.format(func.__name__, time.clock()-t))\r\n            return res\r\n        return wrapper\r\n\r\n\r\n    def logging(func):\r\n        &quot;&quot;&quot;\r\n        A decorator that logs the activity of the script.\r\n        (it actually just prints it, but it could be logging!)\r\n        &quot;&quot;&quot;\r\n        def wrapper(*args, **kwargs):\r\n            res = func(*args, **kwargs)\r\n            print(&quot;{0} {1} {2}&quot;.format(func.__name__, args, kwargs))\r\n            return res\r\n        return wrapper\r\n\r\n\r\n    def counter(func):\r\n        &quot;&quot;&quot;\r\n        A decorator that counts and prints the number of times a function has been executed\r\n        &quot;&quot;&quot;\r\n        def wrapper(*args, **kwargs):\r\n            wrapper.count = wrapper.count + 1\r\n            res = func(*args, **kwargs)\r\n            print(&quot;{0} has been used: {1}x&quot;.format(func.__name__, wrapper.count))\r\n            return res\r\n        wrapper.count = 0\r\n        return wrapper\r\n\r\n    @counter\r\n    @benchmark\r\n    @logging\r\n    def reverse_string(string):\r\n        return str(reversed(string))\r\n\r\n    print(reverse_string(&quot;Able was I ere I saw Elba&quot;))\r\n    print(reverse_string(&quot;A man, a plan, a canoe, pasta, heros, rajahs, a coloratura, maps, snipe, percale, macaroni, a gag, a banana bag, a tan, a tag, a banana bag again (or a camel), a crepe, pins, Spam, a rut, a Rolo, cash, a jar, sore hats, a peon, a canal: Panama!&quot;))\r\n    \r\n    #outputs:\r\n    #reverse_string (&#39;Able was I ere I saw Elba&#39;,) {}\r\n    #wrapper 0.0\r\n    #wrapper has been used: 1x \r\n    #ablE was I ere I saw elbA\r\n    #reverse_string (&#39;A man, a plan, a canoe, pasta, heros, rajahs, a coloratura, maps, snipe, percale, macaroni, a gag, a banana bag, a tan, a tag, a banana bag again (or a camel), a crepe, pins, Spam, a rut, a Rolo, cash, a jar, sore hats, a peon, a canal: Panama!&#39;,) {}\r\n    #wrapper 0.0\r\n    #wrapper has been used: 2x\r\n    #!amanaP :lanac a ,noep a ,stah eros ,raj a ,hsac ,oloR a ,tur a ,mapS ,snip ,eperc a ,)lemac a ro( niaga gab ananab a ,gat a ,nat a ,gab ananab a ,gag a ,inoracam ,elacrep ,epins ,spam ,arutaroloc a ,shajar ,soreh ,atsap ,eonac a ,nalp a ,nam A\r\n\r\nOf course the good thing with decorators is that you can use them right away on almost anything without rewriting. DRY, I said:\r\n\r\n    @counter\r\n    @benchmark\r\n    @logging\r\n    def get_random_futurama_quote():\r\n        from urllib import urlopen\r\n        result = urlopen(&quot;http:\/\/subfusion.net\/cgi-bin\/quote.pl?quote=futurama&quot;).read()\r\n        try:\r\n            value = result.split(&quot;&lt;br&gt;&lt;b&gt;&lt;hr&gt;&lt;br&gt;&quot;)[1].split(&quot;&lt;br&gt;&lt;br&gt;&lt;hr&gt;&quot;)[0]\r\n            return value.strip()\r\n        except:\r\n            return &quot;No, I&#39;m ... doesn&#39;t!&quot;\r\n\r\n        \r\n    print(get_random_futurama_quote())\r\n    print(get_random_futurama_quote())\r\n    \r\n    #outputs:\r\n    #get_random_futurama_quote () {}\r\n    #wrapper 0.02\r\n    #wrapper has been used: 1x\r\n    #The laws of science be a harsh mistress.\r\n    #get_random_futurama_quote () {}\r\n    #wrapper 0.01\r\n    #wrapper has been used: 2x\r\n    #Curse you, merciful Poseidon!\r\n\r\nPython itself provides several decorators: `property`, `staticmethod`, etc. \r\n\r\n- Django uses decorators to manage caching and view permissions. \r\n- Twisted to fake inlining asynchronous functions calls.\r\n\r\nThis really is a large playground.\r\n\r\n\r\n  [1]: https:\/\/stackoverflow.com\/questions\/231767\/can-somebody-explain-me-the-python-yield-statement\/231855#231855\r\n  [2]: https:\/\/stackoverflow.com\/questions\/739654\/understanding-python-decorators#answer-739665\r\n  [3]: http:\/\/en.wikipedia.org\/wiki\/Decorator_pattern\r\n ",
        "body": "<p>If you are not into long explanations, see <a href=\"https:\/\/stackoverflow.com\/questions\/739654\/understanding-python-decorators#answer-739665\">Paolo Bergantino\u2019s answer<\/a>.<\/p>\n<h1>Decorator Basics<\/h1>\n<h2>Python\u2019s functions are objects<\/h2>\n<p>To understand decorators, you must first understand that functions are objects in Python. This has important consequences. Let\u2019s see why with a simple example :<\/p>\n<pre><code>def shout(word=&quot;yes&quot;):\n    return word.capitalize()+&quot;!&quot;\n\nprint(shout())\n# outputs : 'Yes!'\n\n# As an object, you can assign the function to a variable like any other object \nscream = shout\n\n# Notice we don't use parentheses: we are not calling the function,\n# we are putting the function &quot;shout&quot; into the variable &quot;scream&quot;.\n# It means you can then call &quot;shout&quot; from &quot;scream&quot;:\n\nprint(scream())\n# outputs : 'Yes!'\n\n# More than that, it means you can remove the old name 'shout',\n#\u00a0and the function will still be accessible from 'scream'\n\ndel shout\ntry:\n    print(shout())\nexcept NameError as e:\n    print(e)\n    #outputs: &quot;name 'shout' is not defined&quot;\n\nprint(scream())\n# outputs: 'Yes!'\n<\/code><\/pre>\n<p>Keep this in mind. We\u2019ll circle back to it shortly.<\/p>\n<p>Another interesting property of Python functions is they can be defined inside another function!<\/p>\n<pre><code>def talk():\n\n    # You can define a function on the fly in &quot;talk&quot; ...\n    def whisper(word=&quot;yes&quot;):\n        return word.lower()+&quot;...&quot;\n\n    # ... and use it right away!\n    print(whisper())\n\n# You call &quot;talk&quot;, that defines &quot;whisper&quot; EVERY TIME you call it, then\n# &quot;whisper&quot; is called in &quot;talk&quot;. \ntalk()\n# outputs: \n# &quot;yes...&quot;\n\n# But &quot;whisper&quot; DOES NOT EXIST outside &quot;talk&quot;:\n\ntry:\n    print(whisper())\nexcept NameError as e:\n    print(e)\n    #outputs : &quot;name 'whisper' is not defined&quot;*\n    #Python's functions are objects\n<\/code><\/pre>\n<h2>Functions references<\/h2>\n<p>Okay, still here? Now the fun part...<\/p>\n<p>You\u2019ve seen that functions are objects. Therefore, functions:<\/p>\n<ul>\n<li>can be assigned to a variable<\/li>\n<li>can be defined in another function<\/li>\n<\/ul>\n<p>That means that <strong>a function can <code>return<\/code> another function<\/strong>.<\/p>\n<pre><code>def getTalk(kind=&quot;shout&quot;):\n\n    # We define functions on the fly\n    def shout(word=&quot;yes&quot;):\n        return word.capitalize()+&quot;!&quot;\n\n    def whisper(word=&quot;yes&quot;) :\n        return word.lower()+&quot;...&quot;\n\n    # Then we return one of them\n    if kind == &quot;shout&quot;:\n        # We don't use &quot;()&quot;, we are not calling the function,\n        # we are returning the function object\n        return shout  \n    else:\n        return whisper\n\n# How do you use this strange beast?\n\n# Get the function and assign it to a variable\ntalk = getTalk()      \n\n# You can see that &quot;talk&quot; is here a function object:\nprint(talk)\n#outputs : &lt;function shout at 0xb7ea817c&gt;\n\n# The object is the one returned by the function:\nprint(talk())\n#outputs : Yes!\n\n# And you can even use it directly if you feel wild:\nprint(getTalk(&quot;whisper&quot;)())\n#outputs : yes...\n<\/code><\/pre>\n<p>There\u2019s more!<\/p>\n<p>If you can <code>return<\/code> a function, you can pass one as a parameter:<\/p>\n<pre><code>def doSomethingBefore(func): \n    print(&quot;I do something before then I call the function you gave me&quot;)\n    print(func())\n\ndoSomethingBefore(scream)\n#outputs: \n#I do something before then I call the function you gave me\n#Yes!\n<\/code><\/pre>\n<p>Well, you just have everything needed to understand decorators. You see, decorators are \u201cwrappers\u201d, which means that <strong>they let you execute code before and after the function they decorate<\/strong> without modifying the function itself.<\/p>\n<h2>Handcrafted decorators<\/h2>\n<p>How you\u2019d do it manually:<\/p>\n<pre><code># A decorator is a function that expects ANOTHER function as parameter\ndef my_shiny_new_decorator(a_function_to_decorate):\n\n    # Inside, the decorator defines a function on the fly: the wrapper.\n    # This function is going to be wrapped around the original function\n    # so it can execute code before and after it.\n    def the_wrapper_around_the_original_function():\n\n        # Put here the code you want to be executed BEFORE the original function is called\n        print(&quot;Before the function runs&quot;)\n\n        # Call the function here (using parentheses)\n        a_function_to_decorate()\n\n        # Put here the code you want to be executed AFTER the original function is called\n        print(&quot;After the function runs&quot;)\n\n    # At this point, &quot;a_function_to_decorate&quot; HAS NEVER BEEN EXECUTED.\n    # We return the wrapper function we have just created.\n    # The wrapper contains the function and the code to execute before and after. It\u2019s ready to use!\n    return the_wrapper_around_the_original_function\n\n# Now imagine you create a function you don't want to ever touch again.\ndef a_stand_alone_function():\n    print(&quot;I am a stand alone function, don't you dare modify me&quot;)\n\na_stand_alone_function() \n#outputs: I am a stand alone function, don't you dare modify me\n\n# Well, you can decorate it to extend its behavior.\n# Just pass it to the decorator, it will wrap it dynamically in \n# any code you want and return you a new function ready to be used:\n\na_stand_alone_function_decorated = my_shiny_new_decorator(a_stand_alone_function)\na_stand_alone_function_decorated()\n#outputs:\n#Before the function runs\n#I am a stand alone function, don't you dare modify me\n#After the function runs\n<\/code><\/pre>\n<p>Now, you probably want that every time you call <code>a_stand_alone_function<\/code>, <code>a_stand_alone_function_decorated<\/code> is called instead. That\u2019s easy, just overwrite <code>a_stand_alone_function<\/code> with the function returned by <code>my_shiny_new_decorator<\/code>:<\/p>\n<pre><code>a_stand_alone_function = my_shiny_new_decorator(a_stand_alone_function)\na_stand_alone_function()\n#outputs:\n#Before the function runs\n#I am a stand alone function, don't you dare modify me\n#After the function runs\n\n# That\u2019s EXACTLY what decorators do!\n<\/code><\/pre>\n<h2>Decorators demystified<\/h2>\n<p>The previous example, using the decorator syntax:<\/p>\n<pre><code>@my_shiny_new_decorator\ndef another_stand_alone_function():\n    print(&quot;Leave me alone&quot;)\n\nanother_stand_alone_function()  \n#outputs:  \n#Before the function runs\n#Leave me alone\n#After the function runs\n<\/code><\/pre>\n<p>Yes, that\u2019s all, it\u2019s that simple. <code>@decorator<\/code> is just a shortcut to:<\/p>\n<pre><code>another_stand_alone_function = my_shiny_new_decorator(another_stand_alone_function)\n<\/code><\/pre>\n<p>Decorators are just a pythonic variant of the <a href=\"http:\/\/en.wikipedia.org\/wiki\/Decorator_pattern\" rel=\"noreferrer\">decorator design pattern<\/a>. There are several classic design patterns embedded in Python to ease development (like iterators).<\/p>\n<p>Of course, you can accumulate decorators:<\/p>\n<pre><code>def bread(func):\n    def wrapper():\n        print(&quot;&lt;\/''''''\\&gt;&quot;)\n        func()\n        print(&quot;&lt;\\______\/&gt;&quot;)\n    return wrapper\n\ndef ingredients(func):\n    def wrapper():\n        print(&quot;#tomatoes#&quot;)\n        func()\n        print(&quot;~salad~&quot;)\n    return wrapper\n\ndef sandwich(food=&quot;--ham--&quot;):\n    print(food)\n\nsandwich()\n#outputs: --ham--\nsandwich = bread(ingredients(sandwich))\nsandwich()\n#outputs:\n#&lt;\/''''''\\&gt;\n# #tomatoes#\n# --ham--\n# ~salad~\n#&lt;\\______\/&gt;\n<\/code><\/pre>\n<p>Using the Python decorator syntax:<\/p>\n<pre><code>@bread\n@ingredients\ndef sandwich(food=&quot;--ham--&quot;):\n    print(food)\n\nsandwich()\n#outputs:\n#&lt;\/''''''\\&gt;\n# #tomatoes#\n# --ham--\n# ~salad~\n#&lt;\\______\/&gt;\n<\/code><\/pre>\n<p>The order you set the decorators MATTERS:<\/p>\n<pre><code>@ingredients\n@bread\ndef strange_sandwich(food=&quot;--ham--&quot;):\n    print(food)\n\nstrange_sandwich()\n#outputs:\n##tomatoes#\n#&lt;\/''''''\\&gt;\n# --ham--\n#&lt;\\______\/&gt;\n# ~salad~\n<\/code><\/pre>\n<hr \/>\n<h1>Now: to answer the question...<\/h1>\n<p>As a conclusion, you can easily see how to answer the question:<\/p>\n<pre><code># The decorator to make it bold\ndef makebold(fn):\n    # The new function the decorator returns\n    def wrapper():\n        # Insertion of some code before and after\n        return &quot;&lt;b&gt;&quot; + fn() + &quot;&lt;\/b&gt;&quot;\n    return wrapper\n\n# The decorator to make it italic\ndef makeitalic(fn):\n    # The new function the decorator returns\n    def wrapper():\n        # Insertion of some code before and after\n        return &quot;&lt;i&gt;&quot; + fn() + &quot;&lt;\/i&gt;&quot;\n    return wrapper\n\n@makebold\n@makeitalic\ndef say():\n    return &quot;hello&quot;\n\nprint(say())\n#outputs: &lt;b&gt;&lt;i&gt;hello&lt;\/i&gt;&lt;\/b&gt;\n\n# This is the exact equivalent to \ndef say():\n    return &quot;hello&quot;\nsay = makebold(makeitalic(say))\n\nprint(say())\n#outputs: &lt;b&gt;&lt;i&gt;hello&lt;\/i&gt;&lt;\/b&gt;\n<\/code><\/pre>\n<p>You can now just leave happy, or burn your brain a little bit more and see advanced uses of decorators.<\/p>\n<hr \/>\n<h1>Taking decorators to the next level<\/h1>\n<h2>Passing arguments to the decorated function<\/h2>\n<pre><code># It\u2019s not black magic, you just have to let the wrapper \n# pass the argument:\n\ndef a_decorator_passing_arguments(function_to_decorate):\n    def a_wrapper_accepting_arguments(arg1, arg2):\n        print(&quot;I got args! Look: {0}, {1}&quot;.format(arg1, arg2))\n        function_to_decorate(arg1, arg2)\n    return a_wrapper_accepting_arguments\n\n# Since when you are calling the function returned by the decorator, you are\n# calling the wrapper, passing arguments to the wrapper will let it pass them to \n# the decorated function\n\n@a_decorator_passing_arguments\ndef print_full_name(first_name, last_name):\n    print(&quot;My name is {0} {1}&quot;.format(first_name, last_name))\n    \nprint_full_name(&quot;Peter&quot;, &quot;Venkman&quot;)\n# outputs:\n#I got args! Look: Peter Venkman\n#My name is Peter Venkman\n<\/code><\/pre>\n<h2>Decorating methods<\/h2>\n<p>One nifty thing about Python is that methods and functions are really the same.  The only difference is that methods expect that their first argument is a reference to the current object (<code>self<\/code>).<\/p>\n<p>That means you can build a decorator for methods the same way! Just remember to take <code>self<\/code> into consideration:<\/p>\n<pre><code>def method_friendly_decorator(method_to_decorate):\n    def wrapper(self, lie):\n        lie = lie - 3 # very friendly, decrease age even more :-)\n        return method_to_decorate(self, lie)\n    return wrapper\n    \n    \nclass Lucy(object):\n    \n    def __init__(self):\n        self.age = 32\n    \n    @method_friendly_decorator\n    def sayYourAge(self, lie):\n        print(&quot;I am {0}, what did you think?&quot;.format(self.age + lie))\n        \nl = Lucy()\nl.sayYourAge(-3)\n#outputs: I am 26, what did you think?\n<\/code><\/pre>\n<p>If you\u2019re making general-purpose decorator--one you\u2019ll apply to any function or method, no matter its arguments--then just use <code>*args, **kwargs<\/code>:<\/p>\n<pre><code>def a_decorator_passing_arbitrary_arguments(function_to_decorate):\n    # The wrapper accepts any arguments\n    def a_wrapper_accepting_arbitrary_arguments(*args, **kwargs):\n        print(&quot;Do I have args?:&quot;)\n        print(args)\n        print(kwargs)\n        # Then you unpack the arguments, here *args, **kwargs\n        # If you are not familiar with unpacking, check:\n        # http:\/\/www.saltycrane.com\/blog\/2008\/01\/how-to-use-args-and-kwargs-in-python\/\n        function_to_decorate(*args, **kwargs)\n    return a_wrapper_accepting_arbitrary_arguments\n\n@a_decorator_passing_arbitrary_arguments\ndef function_with_no_argument():\n    print(&quot;Python is cool, no argument here.&quot;)\n\nfunction_with_no_argument()\n#outputs\n#Do I have args?:\n#()\n#{}\n#Python is cool, no argument here.\n\n@a_decorator_passing_arbitrary_arguments\ndef function_with_arguments(a, b, c):\n    print(a, b, c)\n    \nfunction_with_arguments(1,2,3)\n#outputs\n#Do I have args?:\n#(1, 2, 3)\n#{}\n#1 2 3 \n \n@a_decorator_passing_arbitrary_arguments\ndef function_with_named_arguments(a, b, c, platypus=&quot;Why not ?&quot;):\n    print(&quot;Do {0}, {1} and {2} like platypus? {3}&quot;.format(a, b, c, platypus))\n\nfunction_with_named_arguments(&quot;Bill&quot;, &quot;Linus&quot;, &quot;Steve&quot;, platypus=&quot;Indeed!&quot;)\n#outputs\n#Do I have args ? :\n#('Bill', 'Linus', 'Steve')\n#{'platypus': 'Indeed!'}\n#Do Bill, Linus and Steve like platypus? Indeed!\n\nclass Mary(object):\n    \n    def __init__(self):\n        self.age = 31\n    \n    @a_decorator_passing_arbitrary_arguments\n    def sayYourAge(self, lie=-3): # You can now add a default value\n        print(&quot;I am {0}, what did you think?&quot;.format(self.age + lie))\n\nm = Mary()\nm.sayYourAge()\n#outputs\n# Do I have args?:\n#(&lt;__main__.Mary object at 0xb7d303ac&gt;,)\n#{}\n#I am 28, what did you think?\n<\/code><\/pre>\n<h2>Passing arguments to the decorator<\/h2>\n<p>Great, now what would you say about passing arguments to the decorator itself?<\/p>\n<p>This can get somewhat twisted, since a decorator must accept a function as an argument. Therefore, you cannot pass the decorated function\u2019s arguments directly to the decorator.<\/p>\n<p>Before rushing to the solution, let\u2019s write a little reminder:<\/p>\n<pre><code># Decorators are ORDINARY functions\ndef my_decorator(func):\n    print(&quot;I am an ordinary function&quot;)\n    def wrapper():\n        print(&quot;I am function returned by the decorator&quot;)\n        func()\n    return wrapper\n\n# Therefore, you can call it without any &quot;@&quot;\n\ndef lazy_function():\n    print(&quot;zzzzzzzz&quot;)\n\ndecorated_function = my_decorator(lazy_function)\n#outputs: I am an ordinary function\n            \n# It outputs &quot;I am an ordinary function&quot;, because that\u2019s just what you do:\n# calling a function. Nothing magic.\n\n@my_decorator\ndef lazy_function():\n    print(&quot;zzzzzzzz&quot;)\n    \n#outputs: I am an ordinary function\n<\/code><\/pre>\n<p>It\u2019s exactly the same. &quot;<code>my_decorator<\/code>&quot; is called. So when you <code>@my_decorator<\/code>, you are telling Python to call the function 'labelled by the variable &quot;<code>my_decorator<\/code>&quot;'.<\/p>\n<p>This is important! The label you give can point directly to the decorator\u2014<strong>or not<\/strong>.<\/p>\n<p>Let\u2019s get evil. \u263a<\/p>\n<pre><code>def decorator_maker():\n    \n    print(&quot;I make decorators! I am executed only once: &quot;\n          &quot;when you make me create a decorator.&quot;)\n            \n    def my_decorator(func):\n        \n        print(&quot;I am a decorator! I am executed only when you decorate a function.&quot;)\n               \n        def wrapped():\n            print(&quot;I am the wrapper around the decorated function. &quot;\n                  &quot;I am called when you call the decorated function. &quot;\n                  &quot;As the wrapper, I return the RESULT of the decorated function.&quot;)\n            return func()\n        \n        print(&quot;As the decorator, I return the wrapped function.&quot;)\n        \n        return wrapped\n    \n    print(&quot;As a decorator maker, I return a decorator&quot;)\n    return my_decorator\n            \n# Let\u2019s create a decorator. It\u2019s just a new function after all.\nnew_decorator = decorator_maker()       \n#outputs:\n#I make decorators! I am executed only once: when you make me create a decorator.\n#As a decorator maker, I return a decorator\n\n# Then we decorate the function\n            \ndef decorated_function():\n    print(&quot;I am the decorated function.&quot;)\n   \ndecorated_function = new_decorator(decorated_function)\n#outputs:\n#I am a decorator! I am executed only when you decorate a function.\n#As the decorator, I return the wrapped function\n     \n# Let\u2019s call the function:\ndecorated_function()\n#outputs:\n#I am the wrapper around the decorated function. I am called when you call the decorated function.\n#As the wrapper, I return the RESULT of the decorated function.\n#I am the decorated function.\n<\/code><\/pre>\n<p>No surprise here.<\/p>\n<p>Let\u2019s do EXACTLY the same thing, but skip all the pesky intermediate variables:<\/p>\n<pre><code>def decorated_function():\n    print(&quot;I am the decorated function.&quot;)\ndecorated_function = decorator_maker()(decorated_function)\n#outputs:\n#I make decorators! I am executed only once: when you make me create a decorator.\n#As a decorator maker, I return a decorator\n#I am a decorator! I am executed only when you decorate a function.\n#As the decorator, I return the wrapped function.\n\n# Finally:\ndecorated_function()    \n#outputs:\n#I am the wrapper around the decorated function. I am called when you call the decorated function.\n#As the wrapper, I return the RESULT of the decorated function.\n#I am the decorated function.\n<\/code><\/pre>\n<p>Let\u2019s make it <em>even shorter<\/em>:<\/p>\n<pre><code>@decorator_maker()\ndef decorated_function():\n    print(&quot;I am the decorated function.&quot;)\n#outputs:\n#I make decorators! I am executed only once: when you make me create a decorator.\n#As a decorator maker, I return a decorator\n#I am a decorator! I am executed only when you decorate a function.\n#As the decorator, I return the wrapped function.\n\n#Eventually: \ndecorated_function()    \n#outputs:\n#I am the wrapper around the decorated function. I am called when you call the decorated function.\n#As the wrapper, I return the RESULT of the decorated function.\n#I am the decorated function.\n<\/code><\/pre>\n<p>Hey, did you see that? We used a function call with the &quot;<code>@<\/code>&quot; syntax! :-)<\/p>\n<p>So, back to decorators with arguments. If we can use functions to generate the decorator on the fly, we can pass arguments to that function, right?<\/p>\n<pre><code>def decorator_maker_with_arguments(decorator_arg1, decorator_arg2):\n    \n    print(&quot;I make decorators! And I accept arguments: {0}, {1}&quot;.format(decorator_arg1, decorator_arg2))\n            \n    def my_decorator(func):\n        # The ability to pass arguments here is a gift from closures.\n        # If you are not comfortable with closures, you can assume it\u2019s ok,\n        # or read: https:\/\/stackoverflow.com\/questions\/13857\/can-you-explain-closures-as-they-relate-to-python\n        print(&quot;I am the decorator. Somehow you passed me arguments: {0}, {1}&quot;.format(decorator_arg1, decorator_arg2))\n               \n        # Don't confuse decorator arguments and function arguments!\n        def wrapped(function_arg1, function_arg2) :\n            print(&quot;I am the wrapper around the decorated function.\\n&quot;\n                  &quot;I can access all the variables\\n&quot;\n                  &quot;\\t- from the decorator: {0} {1}\\n&quot;\n                  &quot;\\t- from the function call: {2} {3}\\n&quot;\n                  &quot;Then I can pass them to the decorated function&quot;\n                  .format(decorator_arg1, decorator_arg2,\n                          function_arg1, function_arg2))\n            return func(function_arg1, function_arg2)\n        \n        return wrapped\n    \n    return my_decorator\n\n@decorator_maker_with_arguments(&quot;Leonard&quot;, &quot;Sheldon&quot;)\ndef decorated_function_with_arguments(function_arg1, function_arg2):\n    print(&quot;I am the decorated function and only knows about my arguments: {0}&quot;\n           &quot; {1}&quot;.format(function_arg1, function_arg2))\n          \ndecorated_function_with_arguments(&quot;Rajesh&quot;, &quot;Howard&quot;)\n#outputs:\n#I make decorators! And I accept arguments: Leonard Sheldon\n#I am the decorator. Somehow you passed me arguments: Leonard Sheldon\n#I am the wrapper around the decorated function. \n#I can access all the variables \n#   - from the decorator: Leonard Sheldon \n#   - from the function call: Rajesh Howard \n#Then I can pass them to the decorated function\n#I am the decorated function and only knows about my arguments: Rajesh Howard\n<\/code><\/pre>\n<p>Here it is: a decorator with arguments. Arguments can be set as variable:<\/p>\n<pre><code>c1 = &quot;Penny&quot;\nc2 = &quot;Leslie&quot;\n\n@decorator_maker_with_arguments(&quot;Leonard&quot;, c1)\ndef decorated_function_with_arguments(function_arg1, function_arg2):\n    print(&quot;I am the decorated function and only knows about my arguments:&quot;\n           &quot; {0} {1}&quot;.format(function_arg1, function_arg2))\n\ndecorated_function_with_arguments(c2, &quot;Howard&quot;)\n#outputs:\n#I make decorators! And I accept arguments: Leonard Penny\n#I am the decorator. Somehow you passed me arguments: Leonard Penny\n#I am the wrapper around the decorated function. \n#I can access all the variables \n#   - from the decorator: Leonard Penny \n#   - from the function call: Leslie Howard \n#Then I can pass them to the decorated function\n#I am the decorated function and only know about my arguments: Leslie Howard\n<\/code><\/pre>\n<p>As you can see, you can pass arguments to the decorator like any function using this trick. You can even use <code>*args, **kwargs<\/code> if you wish. But remember decorators are called <strong>only once<\/strong>. Just when Python imports the script. You can't dynamically set the arguments afterwards. When you do &quot;import x&quot;, <strong>the function is already decorated<\/strong>, so you can't\nchange anything.<\/p>\n<hr \/>\n<h1>Let\u2019s practice: decorating a decorator<\/h1>\n<p>Okay, as a bonus, I'll give you a snippet to make any decorator accept generically any argument. After all, in order to accept arguments, we created our decorator using another function.<\/p>\n<p>We wrapped the decorator.<\/p>\n<p>Anything else we saw recently that wrapped function?<\/p>\n<p>Oh yes, decorators!<\/p>\n<p>Let\u2019s have some fun and write a decorator for the decorators:<\/p>\n<pre><code>def decorator_with_args(decorator_to_enhance):\n    &quot;&quot;&quot; \n    This function is supposed to be used as a decorator.\n    It must decorate an other function, that is intended to be used as a decorator.\n    Take a cup of coffee.\n    It will allow any decorator to accept an arbitrary number of arguments,\n    saving you the headache to remember how to do that every time.\n    &quot;&quot;&quot;\n    \n    # We use the same trick we did to pass arguments\n    def decorator_maker(*args, **kwargs):\n       \n        # We create on the fly a decorator that accepts only a function\n        # but keeps the passed arguments from the maker.\n        def decorator_wrapper(func):\n       \n            # We return the result of the original decorator, which, after all, \n            # IS JUST AN ORDINARY FUNCTION (which returns a function).\n            # Only pitfall: the decorator must have this specific signature or it won't work:\n            return decorator_to_enhance(func, *args, **kwargs)\n        \n        return decorator_wrapper\n    \n    return decorator_maker\n       \n<\/code><\/pre>\n<p>It can be used as follows:<\/p>\n<pre><code># You create the function you will use as a decorator. And stick a decorator on it :-)\n# Don't forget, the signature is &quot;decorator(func, *args, **kwargs)&quot;\n@decorator_with_args \ndef decorated_decorator(func, *args, **kwargs): \n    def wrapper(function_arg1, function_arg2):\n        print(&quot;Decorated with {0} {1}&quot;.format(args, kwargs))\n        return func(function_arg1, function_arg2)\n    return wrapper\n    \n# Then you decorate the functions you wish with your brand new decorated decorator.\n\n@decorated_decorator(42, 404, 1024)\ndef decorated_function(function_arg1, function_arg2):\n    print(&quot;Hello {0} {1}&quot;.format(function_arg1, function_arg2))\n\ndecorated_function(&quot;Universe and&quot;, &quot;everything&quot;)\n#outputs:\n#Decorated with (42, 404, 1024) {}\n#Hello Universe and everything\n\n# Whoooot!\n<\/code><\/pre>\n<p>I know, the last time you had this feeling, it was after listening a guy saying: &quot;before understanding recursion, you must first understand recursion&quot;. But now, don't you feel good about mastering this?<\/p>\n<hr \/>\n<h1>Best practices: decorators<\/h1>\n<ul>\n<li>Decorators were introduced in Python 2.4, so be sure your code will be run on &gt;= 2.4.<\/li>\n<li>Decorators slow down the function call. Keep that in mind.<\/li>\n<li><strong>You cannot un-decorate a function.<\/strong> (There <em>are<\/em> hacks to create decorators that can be removed, but nobody uses them.) So once a function is decorated, it\u2019s decorated <em>for all the code<\/em>.<\/li>\n<li>Decorators wrap functions, which can make them hard to debug.  (This gets better from Python &gt;= 2.5; see below.)<\/li>\n<\/ul>\n<p>The <code>functools<\/code> module was introduced in Python 2.5. It includes the function <code>functools.wraps()<\/code>, which copies the name, module, and docstring of the decorated function to its wrapper.<\/p>\n<p>(Fun fact: <code>functools.wraps()<\/code> is a decorator! \u263a)<\/p>\n<pre><code># For debugging, the stacktrace prints you the function __name__\ndef foo():\n    print(&quot;foo&quot;)\n    \nprint(foo.__name__)\n#outputs: foo\n    \n# With a decorator, it gets messy    \ndef bar(func):\n    def wrapper():\n        print(&quot;bar&quot;)\n        return func()\n    return wrapper\n\n@bar\ndef foo():\n    print(&quot;foo&quot;)\n\nprint(foo.__name__)\n#outputs: wrapper\n\n# &quot;functools&quot; can help for that\n\nimport functools\n\ndef bar(func):\n    # We say that &quot;wrapper&quot;, is wrapping &quot;func&quot;\n    # and the magic begins\n    @functools.wraps(func)\n    def wrapper():\n        print(&quot;bar&quot;)\n        return func()\n    return wrapper\n\n@bar\ndef foo():\n    print(&quot;foo&quot;)\n\nprint(foo.__name__)\n#outputs: foo\n<\/code><\/pre>\n<hr \/>\n<h1>How can the decorators be useful?<\/h1>\n<p><strong>Now the big question:<\/strong> What can I use decorators for?<\/p>\n<p>Seem cool and powerful, but a practical example would be great. Well, there are 1000 possibilities. Classic uses are extending a function behavior from an external lib (you can't modify it), or for debugging (you don't want to modify it because it\u2019s temporary).<\/p>\n<p>You can use them to extend several functions in a DRY\u2019s way, like so:<\/p>\n<pre><code>def benchmark(func):\n    &quot;&quot;&quot;\n    A decorator that prints the time a function takes\n    to execute.\n    &quot;&quot;&quot;\n    import time\n    def wrapper(*args, **kwargs):\n        t = time.clock()\n        res = func(*args, **kwargs)\n        print(&quot;{0} {1}&quot;.format(func.__name__, time.clock()-t))\n        return res\n    return wrapper\n\n\ndef logging(func):\n    &quot;&quot;&quot;\n    A decorator that logs the activity of the script.\n    (it actually just prints it, but it could be logging!)\n    &quot;&quot;&quot;\n    def wrapper(*args, **kwargs):\n        res = func(*args, **kwargs)\n        print(&quot;{0} {1} {2}&quot;.format(func.__name__, args, kwargs))\n        return res\n    return wrapper\n\n\ndef counter(func):\n    &quot;&quot;&quot;\n    A decorator that counts and prints the number of times a function has been executed\n    &quot;&quot;&quot;\n    def wrapper(*args, **kwargs):\n        wrapper.count = wrapper.count + 1\n        res = func(*args, **kwargs)\n        print(&quot;{0} has been used: {1}x&quot;.format(func.__name__, wrapper.count))\n        return res\n    wrapper.count = 0\n    return wrapper\n\n@counter\n@benchmark\n@logging\ndef reverse_string(string):\n    return str(reversed(string))\n\nprint(reverse_string(&quot;Able was I ere I saw Elba&quot;))\nprint(reverse_string(&quot;A man, a plan, a canoe, pasta, heros, rajahs, a coloratura, maps, snipe, percale, macaroni, a gag, a banana bag, a tan, a tag, a banana bag again (or a camel), a crepe, pins, Spam, a rut, a Rolo, cash, a jar, sore hats, a peon, a canal: Panama!&quot;))\n\n#outputs:\n#reverse_string ('Able was I ere I saw Elba',) {}\n#wrapper 0.0\n#wrapper has been used: 1x \n#ablE was I ere I saw elbA\n#reverse_string ('A man, a plan, a canoe, pasta, heros, rajahs, a coloratura, maps, snipe, percale, macaroni, a gag, a banana bag, a tan, a tag, a banana bag again (or a camel), a crepe, pins, Spam, a rut, a Rolo, cash, a jar, sore hats, a peon, a canal: Panama!',) {}\n#wrapper 0.0\n#wrapper has been used: 2x\n#!amanaP :lanac a ,noep a ,stah eros ,raj a ,hsac ,oloR a ,tur a ,mapS ,snip ,eperc a ,)lemac a ro( niaga gab ananab a ,gat a ,nat a ,gab ananab a ,gag a ,inoracam ,elacrep ,epins ,spam ,arutaroloc a ,shajar ,soreh ,atsap ,eonac a ,nalp a ,nam A\n<\/code><\/pre>\n<p>Of course the good thing with decorators is that you can use them right away on almost anything without rewriting. DRY, I said:<\/p>\n<pre><code>@counter\n@benchmark\n@logging\ndef get_random_futurama_quote():\n    from urllib import urlopen\n    result = urlopen(&quot;http:\/\/subfusion.net\/cgi-bin\/quote.pl?quote=futurama&quot;).read()\n    try:\n        value = result.split(&quot;&lt;br&gt;&lt;b&gt;&lt;hr&gt;&lt;br&gt;&quot;)[1].split(&quot;&lt;br&gt;&lt;br&gt;&lt;hr&gt;&quot;)[0]\n        return value.strip()\n    except:\n        return &quot;No, I'm ... doesn't!&quot;\n\n    \nprint(get_random_futurama_quote())\nprint(get_random_futurama_quote())\n\n#outputs:\n#get_random_futurama_quote () {}\n#wrapper 0.02\n#wrapper has been used: 1x\n#The laws of science be a harsh mistress.\n#get_random_futurama_quote () {}\n#wrapper 0.01\n#wrapper has been used: 2x\n#Curse you, merciful Poseidon!\n<\/code><\/pre>\n<p>Python itself provides several decorators: <code>property<\/code>, <code>staticmethod<\/code>, etc.<\/p>\n<ul>\n<li>Django uses decorators to manage caching and view permissions.<\/li>\n<li>Twisted to fake inlining asynchronous functions calls.<\/li>\n<\/ul>\n<p>This really is a large playground.<\/p>\n",
        "community_owned_date": 1339365389.0
    },
    {
        "owner": {
            "account_id": 125976,
            "reputation": 71466,
            "user_id": 322129,
            "user_type": "registered",
            "accept_rate": 100,
            "profile_image": "https:\/\/www.gravatar.com\/avatar\/6f1b006173728a91d96289dd324f6271?s=256&d=identicon&r=PG&f=y&so-version=2",
            "display_name": "Russell Dias",
            "link": "https:\/\/stackoverflow.com\/users\/322129\/russell-dias"
        },
        "is_accepted": true,
        "score": 4630,
        "last_activity_date": 1469968442,
        "last_edit_date": 1469968442,
        "creation_date": 1298858058,
        "answer_id": 5137509,
        "question_id": 5137497,
        "content_license": "CC BY-SA 3.0",
        "body_markdown": "To get the full path to the directory a Python file is contained in, write this in that file:\r\n \r\n    import os \r\n    dir_path = os.path.dirname(os.path.realpath(__file__))\r\n\r\n(Note that the incantation above won&#39;t work if you&#39;ve already used `os.chdir()` to change your current working directory, since the value of the `__file__` constant is relative to the current working directory and is not changed by an `os.chdir()` call.)\r\n\r\n----------\r\n\r\nTo get the current working directory use \r\n\r\n    import os\r\n    cwd = os.getcwd()\r\n\r\n----\r\n\r\nDocumentation references for the modules, constants and functions used above:\r\n\r\n- The [`os`](https:\/\/docs.python.org\/library\/os.html) and [`os.path`](https:\/\/docs.python.org\/library\/os.path.html#module-os.path) modules.\r\n- The [`__file__`](https:\/\/docs.python.org\/reference\/datamodel.html) constant\r\n- [`os.path.realpath(path)`](https:\/\/docs.python.org\/library\/os.path.html#os.path.realpath) (returns *&quot;the canonical path of the specified filename, eliminating any symbolic links encountered in the path&quot;*)\r\n- [`os.path.dirname(path)`](https:\/\/docs.python.org\/library\/os.path.html#os.path.dirname) (returns *&quot;the directory name of pathname `path`&quot;*)\r\n- [`os.getcwd()`](https:\/\/docs.python.org\/library\/os.html#os.getcwd) (returns *&quot;a string representing the current working directory&quot;*)\r\n- [`os.chdir(path)`](https:\/\/docs.python.org\/library\/os.html#os.chdir) (*&quot;change the current working directory to `path`&quot;*)",
        "body": "<p>To get the full path to the directory a Python file is contained in, write this in that file:<\/p>\n\n<pre><code>import os \ndir_path = os.path.dirname(os.path.realpath(__file__))\n<\/code><\/pre>\n\n<p>(Note that the incantation above won't work if you've already used <code>os.chdir()<\/code> to change your current working directory, since the value of the <code>__file__<\/code> constant is relative to the current working directory and is not changed by an <code>os.chdir()<\/code> call.)<\/p>\n\n<hr>\n\n<p>To get the current working directory use <\/p>\n\n<pre><code>import os\ncwd = os.getcwd()\n<\/code><\/pre>\n\n<hr>\n\n<p>Documentation references for the modules, constants and functions used above:<\/p>\n\n<ul>\n<li>The <a href=\"https:\/\/docs.python.org\/library\/os.html\"><code>os<\/code><\/a> and <a href=\"https:\/\/docs.python.org\/library\/os.path.html#module-os.path\"><code>os.path<\/code><\/a> modules.<\/li>\n<li>The <a href=\"https:\/\/docs.python.org\/reference\/datamodel.html\"><code>__file__<\/code><\/a> constant<\/li>\n<li><a href=\"https:\/\/docs.python.org\/library\/os.path.html#os.path.realpath\"><code>os.path.realpath(path)<\/code><\/a> (returns <em>\"the canonical path of the specified filename, eliminating any symbolic links encountered in the path\"<\/em>)<\/li>\n<li><a href=\"https:\/\/docs.python.org\/library\/os.path.html#os.path.dirname\"><code>os.path.dirname(path)<\/code><\/a> (returns <em>\"the directory name of pathname <code>path<\/code>\"<\/em>)<\/li>\n<li><a href=\"https:\/\/docs.python.org\/library\/os.html#os.getcwd\"><code>os.getcwd()<\/code><\/a> (returns <em>\"a string representing the current working directory\"<\/em>)<\/li>\n<li><a href=\"https:\/\/docs.python.org\/library\/os.html#os.chdir\"><code>os.chdir(path)<\/code><\/a> (<em>\"change the current working directory to <code>path<\/code>\"<\/em>)<\/li>\n<\/ul>\n",
        "community_owned_date": null
    },
    {
        "owner": {
            "account_id": 7323,
            "reputation": 50887,
            "user_id": 12682,
            "user_type": "registered",
            "accept_rate": 100,
            "profile_image": "https:\/\/www.gravatar.com\/avatar\/9c6aeb29b5fb2bfebbb57dd47fc59dd6?s=256&d=identicon&r=PG",
            "display_name": "Swati",
            "link": "https:\/\/stackoverflow.com\/users\/12682\/swati"
        },
        "is_accepted": true,
        "score": 4618,
        "last_activity_date": 1643106738,
        "last_edit_date": 1643106738,
        "creation_date": 1222197935,
        "answer_id": 123212,
        "question_id": 123198,
        "content_license": "CC BY-SA 4.0",
        "body_markdown": "[`shutil`][1] has many methods you can use. One of which is:\r\n\r\n```\r\nimport shutil\r\n\r\nshutil.copyfile(src, dst)\r\n\r\n# 2nd option\r\nshutil.copy(src, dst)  # dst can be a folder; use shutil.copy2() to preserve timestamp\r\n```\r\n\r\n - Copy the contents of the file named `src` to a file named `dst`. Both `src` and `dst` need to be the entire filename of the files, including path.\r\n - The destination location must be writable; otherwise, an `IOError` exception will be raised.\r\n - If `dst` already exists, it will be replaced.\r\n - Special files such as character or block devices and pipes cannot be copied with this function. \r\n - With `copy`, `src` and `dst` are path names given as `str`s. \r\n\r\n\r\nAnother `shutil` method to look at is [`shutil.copy2()`](https:\/\/docs.python.org\/3\/library\/shutil.html#shutil.copy2). It&#39;s similar but preserves more metadata (e.g. time stamps).\r\n\r\nIf you use `os.path` operations, use `copy` rather than `copyfile`. `copyfile` will only accept strings.\r\n\r\n  [1]: http:\/\/docs.python.org\/3\/library\/shutil.html",
        "body": "<p><a href=\"http:\/\/docs.python.org\/3\/library\/shutil.html\" rel=\"noreferrer\"><code>shutil<\/code><\/a> has many methods you can use. One of which is:<\/p>\n<pre><code>import shutil\n\nshutil.copyfile(src, dst)\n\n# 2nd option\nshutil.copy(src, dst)  # dst can be a folder; use shutil.copy2() to preserve timestamp\n<\/code><\/pre>\n<ul>\n<li>Copy the contents of the file named <code>src<\/code> to a file named <code>dst<\/code>. Both <code>src<\/code> and <code>dst<\/code> need to be the entire filename of the files, including path.<\/li>\n<li>The destination location must be writable; otherwise, an <code>IOError<\/code> exception will be raised.<\/li>\n<li>If <code>dst<\/code> already exists, it will be replaced.<\/li>\n<li>Special files such as character or block devices and pipes cannot be copied with this function.<\/li>\n<li>With <code>copy<\/code>, <code>src<\/code> and <code>dst<\/code> are path names given as <code>str<\/code>s.<\/li>\n<\/ul>\n<p>Another <code>shutil<\/code> method to look at is <a href=\"https:\/\/docs.python.org\/3\/library\/shutil.html#shutil.copy2\" rel=\"noreferrer\"><code>shutil.copy2()<\/code><\/a>. It's similar but preserves more metadata (e.g. time stamps).<\/p>\n<p>If you use <code>os.path<\/code> operations, use <code>copy<\/code> rather than <code>copyfile<\/code>. <code>copyfile<\/code> will only accept strings.<\/p>\n",
        "community_owned_date": null
    },
    {
        "owner": {
            "account_id": 104636,
            "reputation": 581024,
            "user_id": 279627,
            "user_type": "registered",
            "accept_rate": 82,
            "profile_image": "https:\/\/www.gravatar.com\/avatar\/2dceea858ad8f1577bec6ddaa0485d15?s=256&d=identicon&r=PG",
            "display_name": "Sven Marnach",
            "link": "https:\/\/stackoverflow.com\/users\/279627\/sven-marnach"
        },
        "is_accepted": true,
        "score": 4555,
        "last_activity_date": 1674467459,
        "last_edit_date": 1674467459,
        "creation_date": 1341088158,
        "answer_id": 11277439,
        "question_id": 11277432,
        "content_license": "CC BY-SA 4.0",
        "body_markdown": "To delete a key regardless of whether it is in the dictionary, use the two-argument form of [`dict.pop()`](http:\/\/docs.python.org\/library\/stdtypes.html#dict.pop):\r\n\r\n```python\r\nmy_dict.pop(&#39;key&#39;, None)\r\n```\r\nThis will return `my_dict[key]` if `key` exists in the dictionary, and `None` otherwise. If the second parameter is not specified (i.e. `my_dict.pop(&#39;key&#39;)`) and `key` does not exist, a `KeyError` is raised.\r\n\r\n\r\nTo delete a key that is guaranteed to exist, you can also use\r\n\r\n    del my_dict[&#39;key&#39;]\r\n\r\nThis will raise a `KeyError` if the key is not in the dictionary.",
        "body": "<p>To delete a key regardless of whether it is in the dictionary, use the two-argument form of <a href=\"http:\/\/docs.python.org\/library\/stdtypes.html#dict.pop\" rel=\"noreferrer\"><code>dict.pop()<\/code><\/a>:<\/p>\n<pre class=\"lang-py prettyprint-override\"><code>my_dict.pop('key', None)\n<\/code><\/pre>\n<p>This will return <code>my_dict[key]<\/code> if <code>key<\/code> exists in the dictionary, and <code>None<\/code> otherwise. If the second parameter is not specified (i.e. <code>my_dict.pop('key')<\/code>) and <code>key<\/code> does not exist, a <code>KeyError<\/code> is raised.<\/p>\n<p>To delete a key that is guaranteed to exist, you can also use<\/p>\n<pre><code>del my_dict['key']\n<\/code><\/pre>\n<p>This will raise a <code>KeyError<\/code> if the key is not in the dictionary.<\/p>\n",
        "community_owned_date": null
    },
    {
        "owner": {
            "account_id": 25201,
            "reputation": 53358,
            "user_id": 64633,
            "user_type": "registered",
            "accept_rate": 100,
            "profile_image": "https:\/\/www.gravatar.com\/avatar\/27081fdeb4fdc784fa1f14ec0fb2e1db?s=256&d=identicon&r=PG",
            "display_name": "Rod",
            "link": "https:\/\/stackoverflow.com\/users\/64633\/rod"
        },
        "is_accepted": true,
        "score": 4525,
        "last_activity_date": 1671047240,
        "last_edit_date": 1671047240,
        "creation_date": 1296911880,
        "answer_id": 4907053,
        "question_id": 4906977,
        "content_license": "CC BY-SA 4.0",
        "body_markdown": "Environment variables are accessed through [`os.environ`][2]:\r\n\r\n    import os\r\n    print(os.environ[&#39;HOME&#39;])\r\n\r\nTo see a list of all environment variables:\r\n\r\n    print(os.environ)\r\n\r\n---\r\n\r\nIf a key is not present, attempting to access it will raise a `KeyError`. To avoid this: \r\n\r\n    # Returns `None` if the key doesn&#39;t exist\r\n    print(os.environ.get(&#39;KEY_THAT_MIGHT_EXIST&#39;))\r\n\r\n    # Returns `default_value` if the key doesn&#39;t exist\r\n    print(os.environ.get(&#39;KEY_THAT_MIGHT_EXIST&#39;, default_value))\r\n\r\n    # Returns `default_value` if the key doesn&#39;t exist\r\n    print(os.getenv(&#39;KEY_THAT_MIGHT_EXIST&#39;, default_value))\r\n\r\n\r\n  [2]: https:\/\/docs.python.org\/library\/os.html#os.environ\r\n\r\n\r\n",
        "body": "<p>Environment variables are accessed through <a href=\"https:\/\/docs.python.org\/library\/os.html#os.environ\" rel=\"noreferrer\"><code>os.environ<\/code><\/a>:<\/p>\n<pre><code>import os\nprint(os.environ['HOME'])\n<\/code><\/pre>\n<p>To see a list of all environment variables:<\/p>\n<pre><code>print(os.environ)\n<\/code><\/pre>\n<hr \/>\n<p>If a key is not present, attempting to access it will raise a <code>KeyError<\/code>. To avoid this:<\/p>\n<pre><code># Returns `None` if the key doesn't exist\nprint(os.environ.get('KEY_THAT_MIGHT_EXIST'))\n\n# Returns `default_value` if the key doesn't exist\nprint(os.environ.get('KEY_THAT_MIGHT_EXIST', default_value))\n\n# Returns `default_value` if the key doesn't exist\nprint(os.getenv('KEY_THAT_MIGHT_EXIST', default_value))\n<\/code><\/pre>\n",
        "community_owned_date": null
    },
    {
        "owner": {
            "account_id": 1631004,
            "reputation": 46942,
            "user_id": 1505540,
            "user_type": "registered",
            "profile_image": "https:\/\/www.gravatar.com\/avatar\/4550dc81109cd4a3f46e15eef96b1811?s=256&d=identicon&r=PG",
            "display_name": "lexual",
            "link": "https:\/\/stackoverflow.com\/users\/1505540\/lexual"
        },
        "is_accepted": false,
        "score": 4499,
        "last_activity_date": 1686588741,
        "last_edit_date": 1686588741,
        "creation_date": 1341539295,
        "answer_id": 11354850,
        "question_id": 11346283,
        "content_license": "CC BY-SA 4.0",
        "body_markdown": "## Rename Specific Columns\r\n\r\nUse the [`df.rename()`][1] function and refer the columns to be renamed. Not all the columns have to be renamed:\r\n\r\n    df = df.rename(columns={&#39;oldName1&#39;: &#39;newName1&#39;, &#39;oldName2&#39;: &#39;newName2&#39;})\r\n\r\n    # Or rename the existing DataFrame (rather than creating a copy) \r\n    df.rename(columns={&#39;oldName1&#39;: &#39;newName1&#39;, &#39;oldName2&#39;: &#39;newName2&#39;}, inplace=True)\r\n\r\n**Minimal Code Example**\r\n\r\n    df = pd.DataFrame(&#39;x&#39;, index=range(3), columns=list(&#39;abcde&#39;))\r\n    df\r\n    \r\n       a  b  c  d  e\r\n    0  x  x  x  x  x\r\n    1  x  x  x  x  x\r\n    2  x  x  x  x  x\r\n\r\nThe following methods all work and produce the same output:\r\n\r\n    df2 = df.rename({&#39;a&#39;: &#39;X&#39;, &#39;b&#39;: &#39;Y&#39;}, axis=1)\r\n    df2 = df.rename({&#39;a&#39;: &#39;X&#39;, &#39;b&#39;: &#39;Y&#39;}, axis=&#39;columns&#39;)\r\n    df2 = df.rename(columns={&#39;a&#39;: &#39;X&#39;, &#39;b&#39;: &#39;Y&#39;}) \r\n \r\n    df2\r\n\r\n       X  Y  c  d  e\r\n    0  x  x  x  x  x\r\n    1  x  x  x  x  x\r\n    2  x  x  x  x  x\r\n\r\nRemember to assign the result back, as the modification is not-inplace. Alternatively, specify `inplace=True`:\r\n\r\n    df.rename({&#39;a&#39;: &#39;X&#39;, &#39;b&#39;: &#39;Y&#39;}, axis=1, inplace=True)\r\n    df\r\n    \r\n       X  Y  c  d  e\r\n    0  x  x  x  x  x\r\n    1  x  x  x  x  x\r\n    2  x  x  x  x  x\r\n     \r\nYou can specify `errors=&#39;raise&#39;` to raise errors if an invalid column-to-rename is specified.\r\n\r\n----\r\n\r\n## Reassign Column Headers\r\n\r\nUse [`df.set_axis()`][3] with `axis=1`.\r\n\r\n    df2 = df.set_axis([&#39;V&#39;, &#39;W&#39;, &#39;X&#39;, &#39;Y&#39;, &#39;Z&#39;], axis=1)\r\n    df2\r\n\r\n       V  W  X  Y  Z\r\n    0  x  x  x  x  x\r\n    1  x  x  x  x  x\r\n    2  x  x  x  x  x\r\n\r\n\r\nHeaders can be assigned directly:\r\n\r\n    df.columns = [&#39;V&#39;, &#39;W&#39;, &#39;X&#39;, &#39;Y&#39;, &#39;Z&#39;]\r\n    df\r\n\r\n       V  W  X  Y  Z\r\n    0  x  x  x  x  x\r\n    1  x  x  x  x  x\r\n    2  x  x  x  x  x\r\n\r\n\r\n  [1]: https:\/\/pandas.pydata.org\/pandas-docs\/stable\/reference\/api\/pandas.DataFrame.rename.html\r\n  [3]: https:\/\/pandas.pydata.org\/pandas-docs\/stable\/reference\/api\/pandas.DataFrame.set_axis.html",
        "body": "<h2>Rename Specific Columns<\/h2>\n<p>Use the <a href=\"https:\/\/pandas.pydata.org\/pandas-docs\/stable\/reference\/api\/pandas.DataFrame.rename.html\" rel=\"noreferrer\"><code>df.rename()<\/code><\/a> function and refer the columns to be renamed. Not all the columns have to be renamed:<\/p>\n<pre><code>df = df.rename(columns={'oldName1': 'newName1', 'oldName2': 'newName2'})\n\n# Or rename the existing DataFrame (rather than creating a copy) \ndf.rename(columns={'oldName1': 'newName1', 'oldName2': 'newName2'}, inplace=True)\n<\/code><\/pre>\n<p><strong>Minimal Code Example<\/strong><\/p>\n<pre><code>df = pd.DataFrame('x', index=range(3), columns=list('abcde'))\ndf\n\n   a  b  c  d  e\n0  x  x  x  x  x\n1  x  x  x  x  x\n2  x  x  x  x  x\n<\/code><\/pre>\n<p>The following methods all work and produce the same output:<\/p>\n<pre><code>df2 = df.rename({'a': 'X', 'b': 'Y'}, axis=1)\ndf2 = df.rename({'a': 'X', 'b': 'Y'}, axis='columns')\ndf2 = df.rename(columns={'a': 'X', 'b': 'Y'}) \n\ndf2\n\n   X  Y  c  d  e\n0  x  x  x  x  x\n1  x  x  x  x  x\n2  x  x  x  x  x\n<\/code><\/pre>\n<p>Remember to assign the result back, as the modification is not-inplace. Alternatively, specify <code>inplace=True<\/code>:<\/p>\n<pre><code>df.rename({'a': 'X', 'b': 'Y'}, axis=1, inplace=True)\ndf\n\n   X  Y  c  d  e\n0  x  x  x  x  x\n1  x  x  x  x  x\n2  x  x  x  x  x\n \n<\/code><\/pre>\n<p>You can specify <code>errors='raise'<\/code> to raise errors if an invalid column-to-rename is specified.<\/p>\n<hr \/>\n<h2>Reassign Column Headers<\/h2>\n<p>Use <a href=\"https:\/\/pandas.pydata.org\/pandas-docs\/stable\/reference\/api\/pandas.DataFrame.set_axis.html\" rel=\"noreferrer\"><code>df.set_axis()<\/code><\/a> with <code>axis=1<\/code>.<\/p>\n<pre><code>df2 = df.set_axis(['V', 'W', 'X', 'Y', 'Z'], axis=1)\ndf2\n\n   V  W  X  Y  Z\n0  x  x  x  x  x\n1  x  x  x  x  x\n2  x  x  x  x  x\n<\/code><\/pre>\n<p>Headers can be assigned directly:<\/p>\n<pre><code>df.columns = ['V', 'W', 'X', 'Y', 'Z']\ndf\n\n   V  W  X  Y  Z\n0  x  x  x  x  x\n1  x  x  x  x  x\n2  x  x  x  x  x\n<\/code><\/pre>\n",
        "community_owned_date": null
    },
    {
        "owner": {
            "account_id": 18102,
            "reputation": 47514,
            "user_id": 41165,
            "user_type": "registered",
            "profile_image": "https:\/\/www.gravatar.com\/avatar\/c3fa7cc39c502467700f7aa870963983?s=256&d=identicon&r=PG",
            "display_name": "Patrick Harrington",
            "link": "https:\/\/stackoverflow.com\/users\/41165\/patrick-harrington"
        },
        "is_accepted": true,
        "score": 4420,
        "last_activity_date": 1659915057,
        "last_edit_date": 1659915057,
        "creation_date": 1232561332,
        "answer_id": 466376,
        "question_id": 466345,
        "content_license": "CC BY-SA 4.0",
        "body_markdown": "[`datetime.strptime`][2] parses an input string in the user-specified format into a *timezone-naive* [`datetime`][datetime] object:\r\n\r\n    &gt;&gt;&gt; from datetime import datetime\r\n    &gt;&gt;&gt; datetime.strptime(&#39;Jun 1 2005  1:33PM&#39;, &#39;%b %d %Y %I:%M%p&#39;)\r\n    datetime.datetime(2005, 6, 1, 13, 33)\r\n\r\nTo obtain a [`date`][date] object using an existing `datetime` object, convert it using `.date()`: \r\n\r\n    &gt;&gt;&gt; datetime.strptime(&#39;Jun 1 2005&#39;, &#39;%b %d %Y&#39;).date()\r\n    date(2005, 6, 1)\r\n\r\n---\r\n\r\n**Links:**\r\n\r\n- `strptime` docs: [Python 2][1], [Python 3][2]\r\n\r\n- `strptime`\/`strftime` format string docs: [Python 2][3], [Python 3][4]\r\n\r\n- [strftime.org][5] format string cheatsheet\r\n\r\n**Notes:**\r\n\r\n- `strptime` = &quot;string parse time&quot;\r\n- `strftime` = &quot;string format time&quot;\r\n\r\n\r\n\r\n  [1]: https:\/\/docs.python.org\/2\/library\/datetime.html#datetime.datetime.strptime &quot;datetime.datetime.strptime&quot;\r\n  [2]: https:\/\/docs.python.org\/3\/library\/datetime.html#datetime.datetime.strptime\r\n  [3]: https:\/\/docs.python.org\/2\/library\/datetime.html#strftime-and-strptime-behavior &quot;strftime-and-strptime-behavior&quot;\r\n  [4]: https:\/\/docs.python.org\/3\/library\/datetime.html#strftime-and-strptime-behavior\r\n  [5]: http:\/\/strftime.org\/\r\n  [datetime]: https:\/\/docs.python.org\/3\/library\/datetime.html#datetime-objects\r\n  [date]: https:\/\/docs.python.org\/3\/library\/datetime.html#date-objects",
        "body": "<p><a href=\"https:\/\/docs.python.org\/3\/library\/datetime.html#datetime.datetime.strptime\" rel=\"noreferrer\"><code>datetime.strptime<\/code><\/a> parses an input string in the user-specified format into a <em>timezone-naive<\/em> <a href=\"https:\/\/docs.python.org\/3\/library\/datetime.html#datetime-objects\" rel=\"noreferrer\"><code>datetime<\/code><\/a> object:<\/p>\n<pre><code>&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; datetime.strptime('Jun 1 2005  1:33PM', '%b %d %Y %I:%M%p')\ndatetime.datetime(2005, 6, 1, 13, 33)\n<\/code><\/pre>\n<p>To obtain a <a href=\"https:\/\/docs.python.org\/3\/library\/datetime.html#date-objects\" rel=\"noreferrer\"><code>date<\/code><\/a> object using an existing <code>datetime<\/code> object, convert it using <code>.date()<\/code>:<\/p>\n<pre><code>&gt;&gt;&gt; datetime.strptime('Jun 1 2005', '%b %d %Y').date()\ndate(2005, 6, 1)\n<\/code><\/pre>\n<hr \/>\n<p><strong>Links:<\/strong><\/p>\n<ul>\n<li><p><code>strptime<\/code> docs: <a href=\"https:\/\/docs.python.org\/2\/library\/datetime.html#datetime.datetime.strptime\" rel=\"noreferrer\" title=\"datetime.datetime.strptime\">Python 2<\/a>, <a href=\"https:\/\/docs.python.org\/3\/library\/datetime.html#datetime.datetime.strptime\" rel=\"noreferrer\">Python 3<\/a><\/p>\n<\/li>\n<li><p><code>strptime<\/code>\/<code>strftime<\/code> format string docs: <a href=\"https:\/\/docs.python.org\/2\/library\/datetime.html#strftime-and-strptime-behavior\" rel=\"noreferrer\" title=\"strftime-and-strptime-behavior\">Python 2<\/a>, <a href=\"https:\/\/docs.python.org\/3\/library\/datetime.html#strftime-and-strptime-behavior\" rel=\"noreferrer\">Python 3<\/a><\/p>\n<\/li>\n<li><p><a href=\"http:\/\/strftime.org\/\" rel=\"noreferrer\">strftime.org<\/a> format string cheatsheet<\/p>\n<\/li>\n<\/ul>\n<p><strong>Notes:<\/strong><\/p>\n<ul>\n<li><code>strptime<\/code> = &quot;string parse time&quot;<\/li>\n<li><code>strftime<\/code> = &quot;string format time&quot;<\/li>\n<\/ul>\n",
        "community_owned_date": null
    },
    {
        "owner": {
            "account_id": 8083,
            "reputation": 367240,
            "user_id": 14343,
            "user_type": "registered",
            "accept_rate": 78,
            "profile_image": "https:\/\/www.gravatar.com\/avatar\/75e9a11371cbe1566607180863efdf4c?s=256&d=identicon&r=PG",
            "display_name": "Ned Batchelder",
            "link": "https:\/\/stackoverflow.com\/users\/14343\/ned-batchelder"
        },
        "is_accepted": true,
        "score": 4391,
        "last_activity_date": 1654377776,
        "last_edit_date": 1654377776,
        "creation_date": 1227443633,
        "answer_id": 312464,
        "question_id": 312443,
        "content_license": "CC BY-SA 4.0",
        "body_markdown": "Here&#39;s a generator that yields evenly-sized chunks:\r\n\r\n```\r\ndef chunks(lst, n):\r\n\t&quot;&quot;&quot;Yield successive n-sized chunks from lst.&quot;&quot;&quot;\r\n\tfor i in range(0, len(lst), n):\r\n\t\tyield lst[i:i + n]\r\n```\r\n\r\n```\r\nimport pprint\r\npprint.pprint(list(chunks(range(10, 75), 10)))\r\n[[10, 11, 12, 13, 14, 15, 16, 17, 18, 19],\r\n [20, 21, 22, 23, 24, 25, 26, 27, 28, 29],\r\n [30, 31, 32, 33, 34, 35, 36, 37, 38, 39],\r\n [40, 41, 42, 43, 44, 45, 46, 47, 48, 49],\r\n [50, 51, 52, 53, 54, 55, 56, 57, 58, 59],\r\n [60, 61, 62, 63, 64, 65, 66, 67, 68, 69],\r\n [70, 71, 72, 73, 74]]\r\n```\r\n\r\nFor Python 2, using `xrange` instead of `range`:\r\n\r\n\tdef chunks(lst, n):\r\n\t\t&quot;&quot;&quot;Yield successive n-sized chunks from lst.&quot;&quot;&quot;\r\n\t\tfor i in xrange(0, len(lst), n):\r\n\t\t\tyield lst[i:i + n]\r\n\r\n_____________\r\n\r\nBelow is a list comprehension one-liner. The method above is preferable, though, since using named functions makes code easier to understand. For Python 3:\r\n\r\n\t[lst[i:i + n] for i in range(0, len(lst), n)]\r\n\t\r\nFor Python 2:\r\n\r\n\t[lst[i:i + n] for i in xrange(0, len(lst), n)]",
        "body": "<p>Here's a generator that yields evenly-sized chunks:<\/p>\n<pre><code>def chunks(lst, n):\n    &quot;&quot;&quot;Yield successive n-sized chunks from lst.&quot;&quot;&quot;\n    for i in range(0, len(lst), n):\n        yield lst[i:i + n]\n<\/code><\/pre>\n<pre><code>import pprint\npprint.pprint(list(chunks(range(10, 75), 10)))\n[[10, 11, 12, 13, 14, 15, 16, 17, 18, 19],\n [20, 21, 22, 23, 24, 25, 26, 27, 28, 29],\n [30, 31, 32, 33, 34, 35, 36, 37, 38, 39],\n [40, 41, 42, 43, 44, 45, 46, 47, 48, 49],\n [50, 51, 52, 53, 54, 55, 56, 57, 58, 59],\n [60, 61, 62, 63, 64, 65, 66, 67, 68, 69],\n [70, 71, 72, 73, 74]]\n<\/code><\/pre>\n<p>For Python 2, using <code>xrange<\/code> instead of <code>range<\/code>:<\/p>\n<pre><code>def chunks(lst, n):\n    &quot;&quot;&quot;Yield successive n-sized chunks from lst.&quot;&quot;&quot;\n    for i in xrange(0, len(lst), n):\n        yield lst[i:i + n]\n<\/code><\/pre>\n<hr \/>\n<p>Below is a list comprehension one-liner. The method above is preferable, though, since using named functions makes code easier to understand. For Python 3:<\/p>\n<pre><code>[lst[i:i + n] for i in range(0, len(lst), n)]\n<\/code><\/pre>\n<p>For Python 2:<\/p>\n<pre><code>[lst[i:i + n] for i in xrange(0, len(lst), n)]\n<\/code><\/pre>\n",
        "community_owned_date": null
    },
    {
        "owner": {
            "account_id": 8983,
            "reputation": 482873,
            "user_id": 16417,
            "user_type": "registered",
            "accept_rate": 93,
            "profile_image": "https:\/\/i.stack.imgur.com\/wHrac.jpg?s=256&g=1",
            "display_name": "Paolo Bergantino",
            "link": "https:\/\/stackoverflow.com\/users\/16417\/paolo-bergantino"
        },
        "is_accepted": true,
        "score": 4361,
        "last_activity_date": 1613120883,
        "last_edit_date": 1613120883,
        "creation_date": 1245622146,
        "answer_id": 1024851,
        "question_id": 1024847,
        "content_license": "CC BY-SA 4.0",
        "body_markdown": "You create a new key\/value pair on a dictionary by assigning a value to that key\r\n\r\n    d = {&#39;key&#39;: &#39;value&#39;}\r\n    print(d)  # {&#39;key&#39;: &#39;value&#39;}\r\n\r\n    d[&#39;mynewkey&#39;] = &#39;mynewvalue&#39;\r\n\r\n    print(d)  # {&#39;key&#39;: &#39;value&#39;, &#39;mynewkey&#39;: &#39;mynewvalue&#39;}\r\n\r\nIf the key doesn&#39;t exist, it&#39;s added and points to that value. If it exists, the current value it points to is overwritten.\r\n",
        "body": "<p>You create a new key\/value pair on a dictionary by assigning a value to that key<\/p>\n<pre><code>d = {'key': 'value'}\nprint(d)  # {'key': 'value'}\n\nd['mynewkey'] = 'mynewvalue'\n\nprint(d)  # {'key': 'value', 'mynewkey': 'mynewvalue'}\n<\/code><\/pre>\n<p>If the key doesn't exist, it's added and points to that value. If it exists, the current value it points to is overwritten.<\/p>\n",
        "community_owned_date": null
    },
    {
        "owner": {
            "account_id": 258754,
            "reputation": 379785,
            "user_id": 541136,
            "user_type": "moderator",
            "accept_rate": 96,
            "profile_image": "https:\/\/i.stack.imgur.com\/wftMn.jpg?s=256&g=1",
            "display_name": "Russia Must Remove Putin",
            "link": "https:\/\/stackoverflow.com\/users\/541136\/russia-must-remove-putin"
        },
        "is_accepted": true,
        "score": 4182,
        "last_activity_date": 1613378361,
        "last_edit_date": 1613378361,
        "creation_date": 1401985858,
        "answer_id": 24065533,
        "question_id": 2052390,
        "content_license": "CC BY-SA 4.0",
        "body_markdown": "&gt; ## How do I manually throw\/raise an exception in Python?\r\n\r\n[Use the most specific Exception constructor that semantically fits your issue][1].  \r\n\r\nBe specific in your message, e.g.:\r\n\r\n    raise ValueError(&#39;A very specific bad thing happened.&#39;)\r\n\r\n## Don&#39;t raise generic exceptions\r\n\r\n\r\nAvoid raising a generic `Exception`. To catch it, you&#39;ll have to catch all other more specific exceptions that subclass it.\r\n\r\n### Problem 1: Hiding bugs\r\n\r\n    raise Exception(&#39;I know Python!&#39;) # Don&#39;t! If you catch, likely to hide bugs.\r\n\r\nFor example:\r\n\r\n    def demo_bad_catch():\r\n        try:\r\n            raise ValueError(&#39;Represents a hidden bug, do not catch this&#39;)\r\n            raise Exception(&#39;This is the exception you expect to handle&#39;)\r\n        except Exception as error:\r\n            print(&#39;Caught this error: &#39; + repr(error))\r\n\r\n    &gt;&gt;&gt; demo_bad_catch()\r\n    Caught this error: ValueError(&#39;Represents a hidden bug, do not catch this&#39;,)\r\n\r\n### Problem 2: Won&#39;t catch \r\n\r\nAnd more specific catches won&#39;t catch the general exception:\r\n\r\n    def demo_no_catch():\r\n        try:\r\n            raise Exception(&#39;general exceptions not caught by specific handling&#39;)\r\n        except ValueError as e:\r\n            print(&#39;we will not catch exception: Exception&#39;)\r\n     \r\n    \r\n    &gt;&gt;&gt; demo_no_catch()\r\n    Traceback (most recent call last):\r\n      File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;\r\n      File &quot;&lt;stdin&gt;&quot;, line 3, in demo_no_catch\r\n    Exception: general exceptions not caught by specific handling\r\n\r\n## Best Practices: `raise` statement\r\n\r\n[Instead, use the most specific Exception constructor that semantically fits your issue][2].\r\n\r\n    raise ValueError(&#39;A very specific bad thing happened&#39;)\r\n\r\nwhich also handily allows an arbitrary number of arguments to be passed to the constructor:\r\n\r\n    raise ValueError(&#39;A very specific bad thing happened&#39;, &#39;foo&#39;, &#39;bar&#39;, &#39;baz&#39;) \r\n\r\nThese arguments are accessed by the `args` attribute on the `Exception` object. For example:\r\n\r\n    try:\r\n        some_code_that_may_raise_our_value_error()\r\n    except ValueError as err:\r\n        print(err.args)\r\nprints \r\n\r\n    (&#39;message&#39;, &#39;foo&#39;, &#39;bar&#39;, &#39;baz&#39;)    \r\n\r\nIn Python 2.5, an actual `message` attribute was added to `BaseException` in favor of encouraging users to subclass Exceptions and stop using `args`, but [the introduction of `message` and the original deprecation of args has been retracted][3].\r\n\r\n## Best Practices: `except` clause\r\n\r\nWhen inside an except clause, you might want to, for example, log that a specific type of error happened, and then re-raise. The best way to do this while preserving the stack trace is to use a bare raise statement. For example:\r\n\r\n    logger = logging.getLogger(__name__)\r\n\r\n    try:\r\n        do_something_in_app_that_breaks_easily()\r\n    except AppError as error:\r\n        logger.error(error)\r\n        raise                 # just this!\r\n        # raise AppError      # Don&#39;t do this, you&#39;ll lose the stack trace!\r\n\r\n### Don&#39;t modify your errors... but if you insist.\r\n\r\nYou can preserve the stacktrace (and error value) with `sys.exc_info()`, but **this is way more error prone** and **has compatibility problems between Python 2 and 3**, prefer to use a bare `raise` to re-raise. \r\n\r\n\r\nTo explain - the `sys.exc_info()` returns the type, value, and traceback. \r\n\r\n    type, value, traceback = sys.exc_info()\r\n\r\n\r\nThis is the syntax in Python 2 - note this is not compatible with Python 3:\r\n\r\n    raise AppError, error, sys.exc_info()[2] # avoid this.\r\n    # Equivalently, as error *is* the second object:\r\n    raise sys.exc_info()[0], sys.exc_info()[1], sys.exc_info()[2]\r\n\r\nIf you want to, you can modify what happens with your new raise - e.g. setting new `args` for the instance:\r\n\r\n    def error():\r\n        raise ValueError(&#39;oops!&#39;)\r\n    \r\n    def catch_error_modify_message():\r\n        try:\r\n            error()\r\n        except ValueError:\r\n            error_type, error_instance, traceback = sys.exc_info()\r\n            error_instance.args = (error_instance.args[0] + &#39; &lt;modification&gt;&#39;,)\r\n            raise error_type, error_instance, traceback\r\n\r\nAnd we have preserved the whole traceback while modifying the args. Note that this is **not a best practice** and it is **invalid syntax** in Python 3 (making keeping compatibility much harder to work around).\r\n    \r\n    &gt;&gt;&gt; catch_error_modify_message()\r\n    Traceback (most recent call last):\r\n      File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;\r\n      File &quot;&lt;stdin&gt;&quot;, line 3, in catch_error_modify_message\r\n      File &quot;&lt;stdin&gt;&quot;, line 2, in error\r\n    ValueError: oops! &lt;modification&gt;\r\n\r\nIn [Python 3][4]:\r\n\r\n    raise error.with_traceback(sys.exc_info()[2])\r\n\r\nAgain: avoid manually manipulating tracebacks. It&#39;s [less efficient][5] and more error prone. And if you&#39;re using threading and `sys.exc_info` you may even get the wrong traceback (especially if you&#39;re using exception handling for control flow - which I&#39;d personally tend to avoid.)\r\n\r\n### Python 3, Exception chaining\r\n\r\nIn Python 3, you can chain Exceptions, which preserve tracebacks:\r\n\r\n    raise RuntimeError(&#39;specific message&#39;) from error\r\n\r\nBe aware:\r\n\r\n- this *does* allow changing the error type raised, and\r\n- this is *not* compatible with Python 2.\r\n\r\n### Deprecated Methods:\r\n\r\nThese can easily hide and even get into production code. You want to raise an exception, and doing them will raise an exception, **but not the one intended!**\r\n\r\n[Valid in Python 2, but not in Python 3][6] is the following:\r\n\r\n    raise ValueError, &#39;message&#39; # Don&#39;t do this, it&#39;s deprecated!\r\n\r\nOnly [valid in much older versions of Python][7] (2.4 and lower), you may still see people raising strings:\r\n\r\n    raise &#39;message&#39; # really really wrong. don&#39;t do this.\r\n\r\nIn all modern versions, this will actually raise a `TypeError`, because you&#39;re not raising a `BaseException` type. If you&#39;re not checking for the right exception and don&#39;t have a reviewer that&#39;s aware of the issue, it could get into production.\r\n\r\n## Example Usage\r\n\r\nI raise Exceptions to warn consumers of my API if they&#39;re using it incorrectly:\r\n\r\n    def api_func(foo):\r\n        &#39;&#39;&#39;foo should be either &#39;baz&#39; or &#39;bar&#39;. returns something very useful.&#39;&#39;&#39;\r\n        if foo not in _ALLOWED_ARGS:\r\n            raise ValueError(&#39;{foo} wrong, use &quot;baz&quot; or &quot;bar&quot;&#39;.format(foo=repr(foo)))\r\n\r\n## Create your own error types when apropos\r\n\r\n&gt; **&quot;I want to make an error on purpose, so that it would go into the except&quot;**\r\n\r\nYou can create your own error types, if you want to indicate something specific is wrong with your application, just subclass the appropriate point in the exception hierarchy:\r\n\r\n    class MyAppLookupError(LookupError):\r\n        &#39;&#39;&#39;raise this when there&#39;s a lookup error for my app&#39;&#39;&#39;\r\n\r\nand usage:\r\n\r\n    if important_key not in resource_dict and not ok_to_be_missing:\r\n        raise MyAppLookupError(&#39;resource is missing, and that is not ok.&#39;)\r\n\r\n\r\n  [1]: https:\/\/docs.python.org\/3\/library\/exceptions.html#exception-hierarchy\r\n  [2]: https:\/\/docs.python.org\/3\/library\/exceptions.html#exception-hierarchy\r\n  [3]: http:\/\/www.python.org\/dev\/peps\/pep-0352\/#retracted-ideas\r\n  [4]: https:\/\/docs.python.org\/3\/reference\/simple_stmts.html#the-raise-statement\r\n  [5]: https:\/\/docs.python.org\/2\/reference\/simple_stmts.html#the-raise-statement\r\n  [6]: http:\/\/www.python.org\/dev\/peps\/pep-3109\/\r\n  [7]: https:\/\/docs.python.org\/2\/whatsnew\/2.5.html#pep-352-exceptions-as-new-style-classes\r\n\r\n\r\n\r\n",
        "body": "<blockquote>\n<h2>How do I manually throw\/raise an exception in Python?<\/h2>\n<\/blockquote>\n<p><a href=\"https:\/\/docs.python.org\/3\/library\/exceptions.html#exception-hierarchy\" rel=\"noreferrer\">Use the most specific Exception constructor that semantically fits your issue<\/a>.<\/p>\n<p>Be specific in your message, e.g.:<\/p>\n<pre><code>raise ValueError('A very specific bad thing happened.')\n<\/code><\/pre>\n<h2>Don't raise generic exceptions<\/h2>\n<p>Avoid raising a generic <code>Exception<\/code>. To catch it, you'll have to catch all other more specific exceptions that subclass it.<\/p>\n<h3>Problem 1: Hiding bugs<\/h3>\n<pre><code>raise Exception('I know Python!') # Don't! If you catch, likely to hide bugs.\n<\/code><\/pre>\n<p>For example:<\/p>\n<pre><code>def demo_bad_catch():\n    try:\n        raise ValueError('Represents a hidden bug, do not catch this')\n        raise Exception('This is the exception you expect to handle')\n    except Exception as error:\n        print('Caught this error: ' + repr(error))\n\n&gt;&gt;&gt; demo_bad_catch()\nCaught this error: ValueError('Represents a hidden bug, do not catch this',)\n<\/code><\/pre>\n<h3>Problem 2: Won't catch<\/h3>\n<p>And more specific catches won't catch the general exception:<\/p>\n<pre><code>def demo_no_catch():\n    try:\n        raise Exception('general exceptions not caught by specific handling')\n    except ValueError as e:\n        print('we will not catch exception: Exception')\n \n\n&gt;&gt;&gt; demo_no_catch()\nTraceback (most recent call last):\n  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;\n  File &quot;&lt;stdin&gt;&quot;, line 3, in demo_no_catch\nException: general exceptions not caught by specific handling\n<\/code><\/pre>\n<h2>Best Practices: <code>raise<\/code> statement<\/h2>\n<p><a href=\"https:\/\/docs.python.org\/3\/library\/exceptions.html#exception-hierarchy\" rel=\"noreferrer\">Instead, use the most specific Exception constructor that semantically fits your issue<\/a>.<\/p>\n<pre><code>raise ValueError('A very specific bad thing happened')\n<\/code><\/pre>\n<p>which also handily allows an arbitrary number of arguments to be passed to the constructor:<\/p>\n<pre><code>raise ValueError('A very specific bad thing happened', 'foo', 'bar', 'baz') \n<\/code><\/pre>\n<p>These arguments are accessed by the <code>args<\/code> attribute on the <code>Exception<\/code> object. For example:<\/p>\n<pre><code>try:\n    some_code_that_may_raise_our_value_error()\nexcept ValueError as err:\n    print(err.args)\n<\/code><\/pre>\n<p>prints<\/p>\n<pre><code>('message', 'foo', 'bar', 'baz')    \n<\/code><\/pre>\n<p>In Python 2.5, an actual <code>message<\/code> attribute was added to <code>BaseException<\/code> in favor of encouraging users to subclass Exceptions and stop using <code>args<\/code>, but <a href=\"http:\/\/www.python.org\/dev\/peps\/pep-0352\/#retracted-ideas\" rel=\"noreferrer\">the introduction of <code>message<\/code> and the original deprecation of args has been retracted<\/a>.<\/p>\n<h2>Best Practices: <code>except<\/code> clause<\/h2>\n<p>When inside an except clause, you might want to, for example, log that a specific type of error happened, and then re-raise. The best way to do this while preserving the stack trace is to use a bare raise statement. For example:<\/p>\n<pre><code>logger = logging.getLogger(__name__)\n\ntry:\n    do_something_in_app_that_breaks_easily()\nexcept AppError as error:\n    logger.error(error)\n    raise                 # just this!\n    # raise AppError      # Don't do this, you'll lose the stack trace!\n<\/code><\/pre>\n<h3>Don't modify your errors... but if you insist.<\/h3>\n<p>You can preserve the stacktrace (and error value) with <code>sys.exc_info()<\/code>, but <strong>this is way more error prone<\/strong> and <strong>has compatibility problems between Python 2 and 3<\/strong>, prefer to use a bare <code>raise<\/code> to re-raise.<\/p>\n<p>To explain - the <code>sys.exc_info()<\/code> returns the type, value, and traceback.<\/p>\n<pre><code>type, value, traceback = sys.exc_info()\n<\/code><\/pre>\n<p>This is the syntax in Python 2 - note this is not compatible with Python 3:<\/p>\n<pre><code>raise AppError, error, sys.exc_info()[2] # avoid this.\n# Equivalently, as error *is* the second object:\nraise sys.exc_info()[0], sys.exc_info()[1], sys.exc_info()[2]\n<\/code><\/pre>\n<p>If you want to, you can modify what happens with your new raise - e.g. setting new <code>args<\/code> for the instance:<\/p>\n<pre><code>def error():\n    raise ValueError('oops!')\n\ndef catch_error_modify_message():\n    try:\n        error()\n    except ValueError:\n        error_type, error_instance, traceback = sys.exc_info()\n        error_instance.args = (error_instance.args[0] + ' &lt;modification&gt;',)\n        raise error_type, error_instance, traceback\n<\/code><\/pre>\n<p>And we have preserved the whole traceback while modifying the args. Note that this is <strong>not a best practice<\/strong> and it is <strong>invalid syntax<\/strong> in Python 3 (making keeping compatibility much harder to work around).<\/p>\n<pre><code>&gt;&gt;&gt; catch_error_modify_message()\nTraceback (most recent call last):\n  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;\n  File &quot;&lt;stdin&gt;&quot;, line 3, in catch_error_modify_message\n  File &quot;&lt;stdin&gt;&quot;, line 2, in error\nValueError: oops! &lt;modification&gt;\n<\/code><\/pre>\n<p>In <a href=\"https:\/\/docs.python.org\/3\/reference\/simple_stmts.html#the-raise-statement\" rel=\"noreferrer\">Python 3<\/a>:<\/p>\n<pre><code>raise error.with_traceback(sys.exc_info()[2])\n<\/code><\/pre>\n<p>Again: avoid manually manipulating tracebacks. It's <a href=\"https:\/\/docs.python.org\/2\/reference\/simple_stmts.html#the-raise-statement\" rel=\"noreferrer\">less efficient<\/a> and more error prone. And if you're using threading and <code>sys.exc_info<\/code> you may even get the wrong traceback (especially if you're using exception handling for control flow - which I'd personally tend to avoid.)<\/p>\n<h3>Python 3, Exception chaining<\/h3>\n<p>In Python 3, you can chain Exceptions, which preserve tracebacks:<\/p>\n<pre><code>raise RuntimeError('specific message') from error\n<\/code><\/pre>\n<p>Be aware:<\/p>\n<ul>\n<li>this <em>does<\/em> allow changing the error type raised, and<\/li>\n<li>this is <em>not<\/em> compatible with Python 2.<\/li>\n<\/ul>\n<h3>Deprecated Methods:<\/h3>\n<p>These can easily hide and even get into production code. You want to raise an exception, and doing them will raise an exception, <strong>but not the one intended!<\/strong><\/p>\n<p><a href=\"http:\/\/www.python.org\/dev\/peps\/pep-3109\/\" rel=\"noreferrer\">Valid in Python 2, but not in Python 3<\/a> is the following:<\/p>\n<pre><code>raise ValueError, 'message' # Don't do this, it's deprecated!\n<\/code><\/pre>\n<p>Only <a href=\"https:\/\/docs.python.org\/2\/whatsnew\/2.5.html#pep-352-exceptions-as-new-style-classes\" rel=\"noreferrer\">valid in much older versions of Python<\/a> (2.4 and lower), you may still see people raising strings:<\/p>\n<pre><code>raise 'message' # really really wrong. don't do this.\n<\/code><\/pre>\n<p>In all modern versions, this will actually raise a <code>TypeError<\/code>, because you're not raising a <code>BaseException<\/code> type. If you're not checking for the right exception and don't have a reviewer that's aware of the issue, it could get into production.<\/p>\n<h2>Example Usage<\/h2>\n<p>I raise Exceptions to warn consumers of my API if they're using it incorrectly:<\/p>\n<pre><code>def api_func(foo):\n    '''foo should be either 'baz' or 'bar'. returns something very useful.'''\n    if foo not in _ALLOWED_ARGS:\n        raise ValueError('{foo} wrong, use &quot;baz&quot; or &quot;bar&quot;'.format(foo=repr(foo)))\n<\/code><\/pre>\n<h2>Create your own error types when apropos<\/h2>\n<blockquote>\n<p><strong>&quot;I want to make an error on purpose, so that it would go into the except&quot;<\/strong><\/p>\n<\/blockquote>\n<p>You can create your own error types, if you want to indicate something specific is wrong with your application, just subclass the appropriate point in the exception hierarchy:<\/p>\n<pre><code>class MyAppLookupError(LookupError):\n    '''raise this when there's a lookup error for my app'''\n<\/code><\/pre>\n<p>and usage:<\/p>\n<pre><code>if important_key not in resource_dict and not ok_to_be_missing:\n    raise MyAppLookupError('resource is missing, and that is not ok.')\n<\/code><\/pre>\n",
        "community_owned_date": null
    },
    {
        "owner": {
            "account_id": 76141,
            "reputation": 801829,
            "user_id": 218196,
            "user_type": "registered",
            "accept_rate": 100,
            "profile_image": "https:\/\/i.stack.imgur.com\/4P5DY.jpg?s=256&g=1",
            "display_name": "Felix Kling",
            "link": "https:\/\/stackoverflow.com\/users\/218196\/felix-kling"
        },
        "is_accepted": true,
        "score": 4041,
        "last_activity_date": 1676583215,
        "last_edit_date": 1676583215,
        "creation_date": 1270889721,
        "answer_id": 2612815,
        "question_id": 2612802,
        "content_license": "CC BY-SA 4.0",
        "body_markdown": "`new_list = my_list` doesn&#39;t actually create a second list. The assignment just copies the reference to the list, not the actual list, so both `new_list` and `my_list` refer to the same list after the assignment.\r\n\r\nTo actually copy the list, you have several options:\r\n\r\n- You can use the built-in [`list.copy()`][1] method (available since Python 3.3):\r\n    ```\r\n    new_list = old_list.copy()\r\n    ```\r\n- You can slice it: \r\n    ```\r\n    new_list = old_list[:]\r\n    ```\r\n    [Alex Martelli][2]&#39;s opinion (at least [back in 2007][3]) about this is, that *it is a weird syntax and it does not make sense to use it ever*. ;) (In his opinion, the next one is more readable).\r\n\r\n- You can use the built-in [`list()`][4] constructor:\r\n    ```\r\n    new_list = list(old_list)\r\n    ```\r\n- You can use generic [`copy.copy()`][5]:\r\n    ```\r\n    import copy\r\n    new_list = copy.copy(old_list)\r\n    ```\r\n    This is a little slower than `list()` because it has to find out the datatype of `old_list` first.\r\n\r\n- If you need to copy the elements of the list as well, use generic [`copy.deepcopy()`][6]:\r\n    ```\r\n    import copy\r\n    new_list = copy.deepcopy(old_list)\r\n    ```\r\n    Obviously the slowest and most memory-needing method, but sometimes unavoidable. This operates recursively; it will handle any number of levels of nested lists (or other containers).\r\n\r\n**Example:**\r\n```\r\nimport copy\r\n\r\nclass Foo(object):\r\n    def __init__(self, val):\r\n         self.val = val\r\n\r\n    def __repr__(self):\r\n        return f&#39;Foo({self.val!r})&#39;\r\n\r\nfoo = Foo(1)\r\n\r\na = [&#39;foo&#39;, foo]\r\nb = a.copy()\r\nc = a[:]\r\nd = list(a)\r\ne = copy.copy(a)\r\nf = copy.deepcopy(a)\r\n\r\n# edit orignal list and instance \r\na.append(&#39;baz&#39;)\r\nfoo.val = 5\r\n\r\nprint(f&#39;original: {a}\\nlist.copy(): {b}\\nslice: {c}\\nlist(): {d}\\ncopy: {e}\\ndeepcopy: {f}&#39;)\r\n```\r\nResult:\r\n```\r\noriginal: [&#39;foo&#39;, Foo(5), &#39;baz&#39;]\r\nlist.copy(): [&#39;foo&#39;, Foo(5)]\r\nslice: [&#39;foo&#39;, Foo(5)]\r\nlist(): [&#39;foo&#39;, Foo(5)]\r\ncopy: [&#39;foo&#39;, Foo(5)]\r\ndeepcopy: [&#39;foo&#39;, Foo(1)]\r\n```\r\n\r\n\r\n  [1]: https:\/\/docs.python.org\/library\/stdtypes.html#mutable-sequence-types\r\n  [2]: https:\/\/en.wikipedia.org\/wiki\/Alex_Martelli\r\n  [3]: https:\/\/www.youtube.com\/watch?v=g7V89K8QfgQ\r\n  [4]: https:\/\/docs.python.org\/library\/stdtypes.html#list\r\n  [5]: https:\/\/docs.python.org\/library\/copy.html#copy.copy\r\n  [6]: https:\/\/docs.python.org\/library\/copy.html#copy.deepcopy",
        "body": "<p><code>new_list = my_list<\/code> doesn't actually create a second list. The assignment just copies the reference to the list, not the actual list, so both <code>new_list<\/code> and <code>my_list<\/code> refer to the same list after the assignment.<\/p>\n<p>To actually copy the list, you have several options:<\/p>\n<ul>\n<li><p>You can use the built-in <a href=\"https:\/\/docs.python.org\/library\/stdtypes.html#mutable-sequence-types\" rel=\"noreferrer\"><code>list.copy()<\/code><\/a> method (available since Python 3.3):<\/p>\n<pre><code>new_list = old_list.copy()\n<\/code><\/pre>\n<\/li>\n<li><p>You can slice it:<\/p>\n<pre><code>new_list = old_list[:]\n<\/code><\/pre>\n<p><a href=\"https:\/\/en.wikipedia.org\/wiki\/Alex_Martelli\" rel=\"noreferrer\">Alex Martelli<\/a>'s opinion (at least <a href=\"https:\/\/www.youtube.com\/watch?v=g7V89K8QfgQ\" rel=\"noreferrer\">back in 2007<\/a>) about this is, that <em>it is a weird syntax and it does not make sense to use it ever<\/em>. ;) (In his opinion, the next one is more readable).<\/p>\n<\/li>\n<li><p>You can use the built-in <a href=\"https:\/\/docs.python.org\/library\/stdtypes.html#list\" rel=\"noreferrer\"><code>list()<\/code><\/a> constructor:<\/p>\n<pre><code>new_list = list(old_list)\n<\/code><\/pre>\n<\/li>\n<li><p>You can use generic <a href=\"https:\/\/docs.python.org\/library\/copy.html#copy.copy\" rel=\"noreferrer\"><code>copy.copy()<\/code><\/a>:<\/p>\n<pre><code>import copy\nnew_list = copy.copy(old_list)\n<\/code><\/pre>\n<p>This is a little slower than <code>list()<\/code> because it has to find out the datatype of <code>old_list<\/code> first.<\/p>\n<\/li>\n<li><p>If you need to copy the elements of the list as well, use generic <a href=\"https:\/\/docs.python.org\/library\/copy.html#copy.deepcopy\" rel=\"noreferrer\"><code>copy.deepcopy()<\/code><\/a>:<\/p>\n<pre><code>import copy\nnew_list = copy.deepcopy(old_list)\n<\/code><\/pre>\n<p>Obviously the slowest and most memory-needing method, but sometimes unavoidable. This operates recursively; it will handle any number of levels of nested lists (or other containers).<\/p>\n<\/li>\n<\/ul>\n<p><strong>Example:<\/strong><\/p>\n<pre><code>import copy\n\nclass Foo(object):\n    def __init__(self, val):\n         self.val = val\n\n    def __repr__(self):\n        return f'Foo({self.val!r})'\n\nfoo = Foo(1)\n\na = ['foo', foo]\nb = a.copy()\nc = a[:]\nd = list(a)\ne = copy.copy(a)\nf = copy.deepcopy(a)\n\n# edit orignal list and instance \na.append('baz')\nfoo.val = 5\n\nprint(f'original: {a}\\nlist.copy(): {b}\\nslice: {c}\\nlist(): {d}\\ncopy: {e}\\ndeepcopy: {f}')\n<\/code><\/pre>\n<p>Result:<\/p>\n<pre><code>original: ['foo', Foo(5), 'baz']\nlist.copy(): ['foo', Foo(5)]\nslice: ['foo', Foo(5)]\nlist(): ['foo', Foo(5)]\ncopy: ['foo', Foo(5)]\ndeepcopy: ['foo', Foo(1)]\n<\/code><\/pre>\n",
        "community_owned_date": null
    },
    {
        "owner": {
            "account_id": 31162,
            "reputation": 84759,
            "user_id": 85360,
            "user_type": "registered",
            "accept_rate": 45,
            "profile_image": "https:\/\/www.gravatar.com\/avatar\/424a8f03889e3ffbf9ed57adb1fc41cc?s=256&d=identicon&r=PG",
            "display_name": "Brandon Rhodes",
            "link": "https:\/\/stackoverflow.com\/users\/85360\/brandon-rhodes"
        },
        "is_accepted": true,
        "score": 4036,
        "last_activity_date": 1574785167,
        "last_edit_date": 1574785167,
        "creation_date": 1244903460,
        "answer_id": 990779,
        "question_id": 990754,
        "content_license": "CC BY-SA 4.0",
        "body_markdown": "Usually, activating a virtualenv gives you a shell function named:\r\n\r\n    $ deactivate\r\n\r\nwhich puts things back to normal.\r\n\r\nI have just looked specifically again at the code for `virtualenvwrapper`, and, yes, it too supports `deactivate` as the way to escape from all virtualenvs.\r\n\r\nIf you are trying to leave an [_Anaconda_][1] environment, the command depends upon your version of `conda`. Recent versions (like 4.6) install a `conda` function directly in your shell, in which case you run:\r\n\r\n    conda deactivate\r\n\r\nOlder conda versions instead implement deactivation using a stand-alone script:\r\n\r\n    source deactivate\r\n\r\n  [1]: https:\/\/en.wikipedia.org\/wiki\/Anaconda_(Python_distribution)\r\n",
        "body": "<p>Usually, activating a virtualenv gives you a shell function named:<\/p>\n\n<pre><code>$ deactivate\n<\/code><\/pre>\n\n<p>which puts things back to normal.<\/p>\n\n<p>I have just looked specifically again at the code for <code>virtualenvwrapper<\/code>, and, yes, it too supports <code>deactivate<\/code> as the way to escape from all virtualenvs.<\/p>\n\n<p>If you are trying to leave an <a href=\"https:\/\/en.wikipedia.org\/wiki\/Anaconda_(Python_distribution)\" rel=\"noreferrer\"><em>Anaconda<\/em><\/a> environment, the command depends upon your version of <code>conda<\/code>. Recent versions (like 4.6) install a <code>conda<\/code> function directly in your shell, in which case you run:<\/p>\n\n<pre><code>conda deactivate\n<\/code><\/pre>\n\n<p>Older conda versions instead implement deactivation using a stand-alone script:<\/p>\n\n<pre><code>source deactivate\n<\/code><\/pre>\n",
        "community_owned_date": null
    },
    {
        "owner": {
            "account_id": 36515,
            "reputation": 128408,
            "user_id": 104184,
            "user_type": "registered",
            "accept_rate": 100,
            "profile_image": "https:\/\/i.stack.imgur.com\/iN82N.jpg?s=256&g=1",
            "display_name": "Sasha Chedygov",
            "link": "https:\/\/stackoverflow.com\/users\/104184\/sasha-chedygov"
        },
        "is_accepted": true,
        "score": 3916,
        "last_activity_date": 1635696431,
        "last_edit_date": 1635696431,
        "creation_date": 1243711795,
        "answer_id": 930398,
        "question_id": 930397,
        "content_license": "CC BY-SA 4.0",
        "body_markdown": "`some_list[-1]` is the shortest and most Pythonic.\r\n\r\nIn fact, you can do much more with this syntax. The `some_list[-n]` syntax gets the nth-to-last element. So `some_list[-1]` gets the last element, `some_list[-2]` gets the second to last, etc, all the way down to `some_list[-len(some_list)]`, which gives you the first element.\r\n\r\nYou can also set list elements in this way. For instance:\r\n\r\n    &gt;&gt;&gt; some_list = [1, 2, 3]\r\n    &gt;&gt;&gt; some_list[-1] = 5 # Set the last element\r\n    &gt;&gt;&gt; some_list[-2] = 3 # Set the second to last element\r\n    &gt;&gt;&gt; some_list\r\n    [1, 3, 5]\r\n\r\nNote that getting a list item by index will raise an [`IndexError`][1] if the expected item doesn&#39;t exist. This means that `some_list[-1]` will raise an exception if `some_list` is empty, because an empty list can&#39;t have a last element.\r\n\r\n  [1]: https:\/\/docs.python.org\/3\/library\/exceptions.html#IndexError",
        "body": "<p><code>some_list[-1]<\/code> is the shortest and most Pythonic.<\/p>\n<p>In fact, you can do much more with this syntax. The <code>some_list[-n]<\/code> syntax gets the nth-to-last element. So <code>some_list[-1]<\/code> gets the last element, <code>some_list[-2]<\/code> gets the second to last, etc, all the way down to <code>some_list[-len(some_list)]<\/code>, which gives you the first element.<\/p>\n<p>You can also set list elements in this way. For instance:<\/p>\n<pre><code>&gt;&gt;&gt; some_list = [1, 2, 3]\n&gt;&gt;&gt; some_list[-1] = 5 # Set the last element\n&gt;&gt;&gt; some_list[-2] = 3 # Set the second to last element\n&gt;&gt;&gt; some_list\n[1, 3, 5]\n<\/code><\/pre>\n<p>Note that getting a list item by index will raise an <a href=\"https:\/\/docs.python.org\/3\/library\/exceptions.html#IndexError\" rel=\"noreferrer\"><code>IndexError<\/code><\/a> if the expected item doesn't exist. This means that <code>some_list[-1]<\/code> will raise an exception if <code>some_list<\/code> is empty, because an empty list can't have a last element.<\/p>\n",
        "community_owned_date": null
    },
    {
        "owner": {
            "account_id": 64585,
            "reputation": 852655,
            "user_id": 190597,
            "user_type": "registered",
            "accept_rate": 88,
            "profile_image": "https:\/\/www.gravatar.com\/avatar\/8f7683207b9fcc8e77120265517f7ce9?s=256&d=identicon&r=PG&f=y&so-version=2",
            "display_name": "unutbu",
            "link": "https:\/\/stackoverflow.com\/users\/190597\/unutbu"
        },
        "is_accepted": true,
        "score": 3882,
        "last_activity_date": 1618216991,
        "last_edit_date": 1618216991,
        "creation_date": 1257275628,
        "answer_id": 1669524,
        "question_id": 136097,
        "content_license": "CC BY-SA 4.0",
        "body_markdown": "Maybe a bit of example code will help: Notice the difference in the call signatures of `foo`, `class_foo` and `static_foo`:\r\n\r\n    class A(object):\r\n        def foo(self, x):\r\n            print(f&quot;executing foo({self}, {x})&quot;)\r\n    \r\n        @classmethod\r\n        def class_foo(cls, x):\r\n            print(f&quot;executing class_foo({cls}, {x})&quot;)\r\n    \r\n        @staticmethod\r\n        def static_foo(x):\r\n            print(f&quot;executing static_foo({x})&quot;)\r\n    \r\n    a = A()\r\n    \r\nBelow is the usual way an object instance calls a method. The object instance, `a`, is implicitly passed as the first argument.\r\n    \r\n    a.foo(1)\r\n    # executing foo(&lt;__main__.A object at 0xb7dbef0c&gt;, 1)\r\n\r\n\r\n----------\r\n\r\n   \r\n**With classmethods**, the class of the object instance is implicitly passed as the first argument instead of `self`.\r\n    \r\n    a.class_foo(1)\r\n    # executing class_foo(&lt;class &#39;__main__.A&#39;&gt;, 1)\r\n    \r\nYou can also call `class_foo` using the class. In fact, if you define something to be\r\na classmethod, it is probably because you intend to call it from the class rather than from a class instance. `A.foo(1)` would have raised a TypeError, but `A.class_foo(1)` works just fine:\r\n        \r\n    A.class_foo(1)\r\n    # executing class_foo(&lt;class &#39;__main__.A&#39;&gt;, 1)\r\n \r\nOne use people have found for class methods is to create [inheritable alternative constructors](https:\/\/stackoverflow.com\/a\/1950927\/190597).\r\n\r\n\r\n----------\r\n\r\n\r\n**With staticmethods**, neither `self` (the object instance) nor  `cls` (the class) is implicitly passed as the first argument. They behave like plain functions except that you can call them from an instance or the class:\r\n    \r\n    a.static_foo(1)\r\n    # executing static_foo(1)\r\n\r\n    A.static_foo(&#39;hi&#39;)\r\n    # executing static_foo(hi)\r\n\r\nStaticmethods are used to group functions which have some logical connection with a class to the class.\r\n\r\n----------\r\n\r\n\r\n`foo` is just a function, but when you call `a.foo` you don&#39;t just get the function,\r\nyou get a &quot;partially applied&quot; version of the function with the object instance `a` bound as the first argument to the function. `foo` expects 2 arguments, while `a.foo` only expects 1 argument.\r\n\r\n`a` is bound to `foo`. That is what is meant by the term &quot;bound&quot; below:\r\n\r\n    print(a.foo)\r\n    # &lt;bound method A.foo of &lt;__main__.A object at 0xb7d52f0c&gt;&gt;\r\n\r\nWith `a.class_foo`, `a` is not bound to `class_foo`, rather the class `A` is bound to `class_foo`.\r\n\r\n    print(a.class_foo)\r\n    # &lt;bound method type.class_foo of &lt;class &#39;__main__.A&#39;&gt;&gt;\r\n\r\nHere, with a staticmethod, even though it is a method, `a.static_foo` just returns\r\na good &#39;ole function with no arguments bound. `static_foo` expects 1 argument, and\r\n`a.static_foo` expects 1 argument too.\r\n\r\n    print(a.static_foo)\r\n    # &lt;function static_foo at 0xb7d479cc&gt;\r\n\r\nAnd of course the same thing happens when you call `static_foo` with the class `A` instead.\r\n\r\n    print(A.static_foo)\r\n    # &lt;function static_foo at 0xb7d479cc&gt;\r\n",
        "body": "<p>Maybe a bit of example code will help: Notice the difference in the call signatures of <code>foo<\/code>, <code>class_foo<\/code> and <code>static_foo<\/code>:<\/p>\n<pre><code>class A(object):\n    def foo(self, x):\n        print(f&quot;executing foo({self}, {x})&quot;)\n\n    @classmethod\n    def class_foo(cls, x):\n        print(f&quot;executing class_foo({cls}, {x})&quot;)\n\n    @staticmethod\n    def static_foo(x):\n        print(f&quot;executing static_foo({x})&quot;)\n\na = A()\n<\/code><\/pre>\n<p>Below is the usual way an object instance calls a method. The object instance, <code>a<\/code>, is implicitly passed as the first argument.<\/p>\n<pre><code>a.foo(1)\n# executing foo(&lt;__main__.A object at 0xb7dbef0c&gt;, 1)\n<\/code><\/pre>\n<hr \/>\n<p><strong>With classmethods<\/strong>, the class of the object instance is implicitly passed as the first argument instead of <code>self<\/code>.<\/p>\n<pre><code>a.class_foo(1)\n# executing class_foo(&lt;class '__main__.A'&gt;, 1)\n<\/code><\/pre>\n<p>You can also call <code>class_foo<\/code> using the class. In fact, if you define something to be\na classmethod, it is probably because you intend to call it from the class rather than from a class instance. <code>A.foo(1)<\/code> would have raised a TypeError, but <code>A.class_foo(1)<\/code> works just fine:<\/p>\n<pre><code>A.class_foo(1)\n# executing class_foo(&lt;class '__main__.A'&gt;, 1)\n<\/code><\/pre>\n<p>One use people have found for class methods is to create <a href=\"https:\/\/stackoverflow.com\/a\/1950927\/190597\">inheritable alternative constructors<\/a>.<\/p>\n<hr \/>\n<p><strong>With staticmethods<\/strong>, neither <code>self<\/code> (the object instance) nor  <code>cls<\/code> (the class) is implicitly passed as the first argument. They behave like plain functions except that you can call them from an instance or the class:<\/p>\n<pre><code>a.static_foo(1)\n# executing static_foo(1)\n\nA.static_foo('hi')\n# executing static_foo(hi)\n<\/code><\/pre>\n<p>Staticmethods are used to group functions which have some logical connection with a class to the class.<\/p>\n<hr \/>\n<p><code>foo<\/code> is just a function, but when you call <code>a.foo<\/code> you don't just get the function,\nyou get a &quot;partially applied&quot; version of the function with the object instance <code>a<\/code> bound as the first argument to the function. <code>foo<\/code> expects 2 arguments, while <code>a.foo<\/code> only expects 1 argument.<\/p>\n<p><code>a<\/code> is bound to <code>foo<\/code>. That is what is meant by the term &quot;bound&quot; below:<\/p>\n<pre><code>print(a.foo)\n# &lt;bound method A.foo of &lt;__main__.A object at 0xb7d52f0c&gt;&gt;\n<\/code><\/pre>\n<p>With <code>a.class_foo<\/code>, <code>a<\/code> is not bound to <code>class_foo<\/code>, rather the class <code>A<\/code> is bound to <code>class_foo<\/code>.<\/p>\n<pre><code>print(a.class_foo)\n# &lt;bound method type.class_foo of &lt;class '__main__.A'&gt;&gt;\n<\/code><\/pre>\n<p>Here, with a staticmethod, even though it is a method, <code>a.static_foo<\/code> just returns\na good 'ole function with no arguments bound. <code>static_foo<\/code> expects 1 argument, and\n<code>a.static_foo<\/code> expects 1 argument too.<\/p>\n<pre><code>print(a.static_foo)\n# &lt;function static_foo at 0xb7d479cc&gt;\n<\/code><\/pre>\n<p>And of course the same thing happens when you call <code>static_foo<\/code> with the class <code>A<\/code> instead.<\/p>\n<pre><code>print(A.static_foo)\n# &lt;function static_foo at 0xb7d479cc&gt;\n<\/code><\/pre>\n",
        "community_owned_date": null
    },
    {
        "owner": {
            "account_id": 809,
            "reputation": 177514,
            "user_id": 1057,
            "user_type": "registered",
            "accept_rate": 80,
            "profile_image": "https:\/\/www.gravatar.com\/avatar\/e5778b659d144e38ed982c3f4e566089?s=256&d=identicon&r=PG",
            "display_name": "Harley Holcombe",
            "link": "https:\/\/stackoverflow.com\/users\/1057\/harley-holcombe"
        },
        "is_accepted": true,
        "score": 3871,
        "last_activity_date": 1653984535,
        "last_edit_date": 1653984535,
        "creation_date": 1231217825,
        "answer_id": 415519,
        "question_id": 415511,
        "content_license": "CC BY-SA 4.0",
        "body_markdown": "Use [`datetime`][1]:\r\n\r\n    &gt;&gt;&gt; import datetime\r\n    &gt;&gt;&gt; now = datetime.datetime.now()\r\n    &gt;&gt;&gt; now\r\n    datetime.datetime(2009, 1, 6, 15, 8, 24, 78915)\r\n    &gt;&gt;&gt; print(now)\r\n    2009-01-06 15:08:24.789150\r\n\r\nFor just the clock time without the date:\r\n\r\n    &gt;&gt;&gt; now.time()\r\n    datetime.time(15, 8, 24, 78915)\r\n    &gt;&gt;&gt; print(now.time())\r\n    15:08:24.789150\r\n\r\n---\r\n\r\nTo save typing, you can import the `datetime` object from the [`datetime`][1] module:\r\n\r\n    &gt;&gt;&gt; from datetime import datetime\r\n\r\nThen remove the prefix `datetime.` from all of the above.\r\n\r\n [1]: https:\/\/docs.python.org\/3\/library\/datetime.html\r\n",
        "body": "<p>Use <a href=\"https:\/\/docs.python.org\/3\/library\/datetime.html\" rel=\"noreferrer\"><code>datetime<\/code><\/a>:<\/p>\n<pre><code>&gt;&gt;&gt; import datetime\n&gt;&gt;&gt; now = datetime.datetime.now()\n&gt;&gt;&gt; now\ndatetime.datetime(2009, 1, 6, 15, 8, 24, 78915)\n&gt;&gt;&gt; print(now)\n2009-01-06 15:08:24.789150\n<\/code><\/pre>\n<p>For just the clock time without the date:<\/p>\n<pre><code>&gt;&gt;&gt; now.time()\ndatetime.time(15, 8, 24, 78915)\n&gt;&gt;&gt; print(now.time())\n15:08:24.789150\n<\/code><\/pre>\n<hr \/>\n<p>To save typing, you can import the <code>datetime<\/code> object from the <a href=\"https:\/\/docs.python.org\/3\/library\/datetime.html\" rel=\"noreferrer\"><code>datetime<\/code><\/a> module:<\/p>\n<pre><code>&gt;&gt;&gt; from datetime import datetime\n<\/code><\/pre>\n<p>Then remove the prefix <code>datetime.<\/code> from all of the above.<\/p>\n",
        "community_owned_date": null
    },
    {
        "owner": {
            "account_id": 8983,
            "reputation": 482873,
            "user_id": 16417,
            "user_type": "registered",
            "accept_rate": 93,
            "profile_image": "https:\/\/i.stack.imgur.com\/wHrac.jpg?s=256&g=1",
            "display_name": "Paolo Bergantino",
            "link": "https:\/\/stackoverflow.com\/users\/16417\/paolo-bergantino"
        },
        "is_accepted": true,
        "score": 3725,
        "last_activity_date": 1368200697,
        "last_edit_date": 1495542891,
        "creation_date": 1237483844,
        "answer_id": 663175,
        "question_id": 663171,
        "content_license": "CC BY-SA 3.0",
        "body_markdown": "    &gt;&gt;&gt; x = &quot;Hello World!&quot;\r\n    &gt;&gt;&gt; x[2:]\r\n    &#39;llo World!&#39;\r\n    &gt;&gt;&gt; x[:2]\r\n    &#39;He&#39;\r\n    &gt;&gt;&gt; x[:-2]\r\n    &#39;Hello Worl&#39;\r\n    &gt;&gt;&gt; x[-2:]\r\n    &#39;d!&#39;\r\n    &gt;&gt;&gt; x[2:-2]\r\n    &#39;llo Worl&#39;\r\n\r\nPython calls this concept &quot;slicing&quot; and it works on more than just strings. Take a look [here][1] for a comprehensive introduction.\r\n\r\n\r\n  [1]: https:\/\/stackoverflow.com\/questions\/509211\/good-primer-for-python-slice-notation",
        "body": "<pre><code>&gt;&gt;&gt; x = \"Hello World!\"\n&gt;&gt;&gt; x[2:]\n'llo World!'\n&gt;&gt;&gt; x[:2]\n'He'\n&gt;&gt;&gt; x[:-2]\n'Hello Worl'\n&gt;&gt;&gt; x[-2:]\n'd!'\n&gt;&gt;&gt; x[2:-2]\n'llo Worl'\n<\/code><\/pre>\n\n<p>Python calls this concept \"slicing\" and it works on more than just strings. Take a look <a href=\"https:\/\/stackoverflow.com\/questions\/509211\/good-primer-for-python-slice-notation\">here<\/a> for a comprehensive introduction.<\/p>\n",
        "community_owned_date": null
    },
    {
        "owner": {
            "account_id": 2696,
            "reputation": 45909,
            "user_id": 3785,
            "user_type": "registered",
            "accept_rate": 80,
            "profile_image": "https:\/\/www.gravatar.com\/avatar\/91e799ee062d66b9a2da8428d28038a0?s=256&d=identicon&r=PG",
            "display_name": "Mario F",
            "link": "https:\/\/stackoverflow.com\/users\/3785\/mario-f"
        },
        "is_accepted": true,
        "score": 3610,
        "last_activity_date": 1633660109,
        "last_edit_date": 1633660109,
        "creation_date": 1221575984,
        "answer_id": 73050,
        "question_id": 72899,
        "content_license": "CC BY-SA 4.0",
        "body_markdown": "The [`sorted()`][1] function takes a `key=` parameter\r\n\r\n    newlist = sorted(list_to_be_sorted, key=lambda d: d[&#39;name&#39;]) \r\n\r\nAlternatively, you can use [`operator.itemgetter`][2] instead of defining the function yourself\r\n\r\n    from operator import itemgetter\r\n    newlist = sorted(list_to_be_sorted, key=itemgetter(&#39;name&#39;)) \r\n\r\nFor completeness, add `reverse=True` to sort in descending order\r\n\r\n    newlist = sorted(list_to_be_sorted, key=itemgetter(&#39;name&#39;), reverse=True)\r\n\r\n\r\n  [1]: https:\/\/docs.python.org\/library\/functions.html#sorted\r\n  [2]: https:\/\/docs.python.org\/library\/operator.html#operator.itemgetter",
        "body": "<p>The <a href=\"https:\/\/docs.python.org\/library\/functions.html#sorted\" rel=\"noreferrer\"><code>sorted()<\/code><\/a> function takes a <code>key=<\/code> parameter<\/p>\n<pre><code>newlist = sorted(list_to_be_sorted, key=lambda d: d['name']) \n<\/code><\/pre>\n<p>Alternatively, you can use <a href=\"https:\/\/docs.python.org\/library\/operator.html#operator.itemgetter\" rel=\"noreferrer\"><code>operator.itemgetter<\/code><\/a> instead of defining the function yourself<\/p>\n<pre><code>from operator import itemgetter\nnewlist = sorted(list_to_be_sorted, key=itemgetter('name')) \n<\/code><\/pre>\n<p>For completeness, add <code>reverse=True<\/code> to sort in descending order<\/p>\n<pre><code>newlist = sorted(list_to_be_sorted, key=itemgetter('name'), reverse=True)\n<\/code><\/pre>\n",
        "community_owned_date": null
    },
    {
        "owner": {
            "account_id": 416547,
            "reputation": 92004,
            "user_id": 791998,
            "user_type": "registered",
            "accept_rate": 80,
            "profile_image": "https:\/\/www.gravatar.com\/avatar\/a6704cf6e18d734f94d5988cf02fae45?s=256&d=identicon&r=PG",
            "display_name": "Petar Ivanov",
            "link": "https:\/\/stackoverflow.com\/users\/791998\/petar-ivanov"
        },
        "is_accepted": true,
        "score": 3604,
        "last_activity_date": 1648548100,
        "last_edit_date": 1648548100,
        "creation_date": 1311390598,
        "answer_id": 6797990,
        "question_id": 6797984,
        "content_license": "CC BY-SA 4.0",
        "body_markdown": "Use [`str.lower()`][python3]:\r\n\r\n    &quot;Kilometer&quot;.lower()\r\n\r\n  [python3]: https:\/\/docs.python.org\/library\/stdtypes.html#str.lower",
        "body": "<p>Use <a href=\"https:\/\/docs.python.org\/library\/stdtypes.html#str.lower\" rel=\"noreferrer\"><code>str.lower()<\/code><\/a>:<\/p>\n<pre><code>&quot;Kilometer&quot;.lower()\n<\/code><\/pre>\n",
        "community_owned_date": null
    },
    {
        "owner": {
            "account_id": 2366166,
            "reputation": 74731,
            "user_id": 2071807,
            "user_type": "registered",
            "accept_rate": 68,
            "profile_image": "https:\/\/i.stack.imgur.com\/QgeOJ.jpg?s=256&g=1",
            "display_name": "LondonRob",
            "link": "https:\/\/stackoverflow.com\/users\/2071807\/londonrob"
        },
        "is_accepted": false,
        "score": 3550,
        "last_activity_date": 1675745891,
        "last_edit_date": 1675745891,
        "creation_date": 1376046729,
        "answer_id": 18145399,
        "question_id": 13411544,
        "content_license": "CC BY-SA 4.0",
        "body_markdown": "The best way to do this in Pandas is to use [`drop`][1]:\r\n\r\n    df = df.drop(&#39;column_name&#39;, axis=1)\r\n\r\nwhere `1` is the *axis* number (`0` for rows and `1` for columns.)\r\n\r\nOr, the `drop()` method accepts `index`\/`columns` keywords as an alternative to specifying the axis. So we can now just do:\r\n\r\n```\r\ndf = df.drop(columns=[&#39;column_nameA&#39;, &#39;column_nameB&#39;])\r\n```\r\n\r\n- *This was [introduced in v0.21.0][2] (October 27, 2017)*\r\n\r\nTo delete the column without having to reassign `df` you can do:\r\n\r\n    df.drop(&#39;column_name&#39;, axis=1, inplace=True)\r\n\r\nFinally, to drop by column *number* instead of by column *label*, try this to delete, e.g. the 1st, 2nd and 4th columns:\r\n\r\n    df = df.drop(df.columns[[0, 1, 3]], axis=1)  # df.columns is zero-based pd.Index\r\n\r\nAlso working with &quot;text&quot; syntax for the columns:\r\n\r\n```\r\ndf.drop([&#39;column_nameA&#39;, &#39;column_nameB&#39;], axis=1, inplace=True)\r\n```\r\n\r\n\r\n  [1]: https:\/\/pandas.pydata.org\/pandas-docs\/stable\/reference\/api\/pandas.DataFrame.drop.html\r\n  [2]: https:\/\/pandas.pydata.org\/pandas-docs\/stable\/whatsnew\/v0.21.0.html#method-drop-now-also-accepts-index-columns-keywords",
        "body": "<p>The best way to do this in Pandas is to use <a href=\"https:\/\/pandas.pydata.org\/pandas-docs\/stable\/reference\/api\/pandas.DataFrame.drop.html\" rel=\"noreferrer\"><code>drop<\/code><\/a>:<\/p>\n<pre><code>df = df.drop('column_name', axis=1)\n<\/code><\/pre>\n<p>where <code>1<\/code> is the <em>axis<\/em> number (<code>0<\/code> for rows and <code>1<\/code> for columns.)<\/p>\n<p>Or, the <code>drop()<\/code> method accepts <code>index<\/code>\/<code>columns<\/code> keywords as an alternative to specifying the axis. So we can now just do:<\/p>\n<pre><code>df = df.drop(columns=['column_nameA', 'column_nameB'])\n<\/code><\/pre>\n<ul>\n<li><em>This was <a href=\"https:\/\/pandas.pydata.org\/pandas-docs\/stable\/whatsnew\/v0.21.0.html#method-drop-now-also-accepts-index-columns-keywords\" rel=\"noreferrer\">introduced in v0.21.0<\/a> (October 27, 2017)<\/em><\/li>\n<\/ul>\n<p>To delete the column without having to reassign <code>df<\/code> you can do:<\/p>\n<pre><code>df.drop('column_name', axis=1, inplace=True)\n<\/code><\/pre>\n<p>Finally, to drop by column <em>number<\/em> instead of by column <em>label<\/em>, try this to delete, e.g. the 1st, 2nd and 4th columns:<\/p>\n<pre><code>df = df.drop(df.columns[[0, 1, 3]], axis=1)  # df.columns is zero-based pd.Index\n<\/code><\/pre>\n<p>Also working with &quot;text&quot; syntax for the columns:<\/p>\n<pre><code>df.drop(['column_nameA', 'column_nameB'], axis=1, inplace=True)\n<\/code><\/pre>\n",
        "community_owned_date": null
    },
    {
        "owner": {
            "account_id": 1273,
            "reputation": 187878,
            "user_id": 1694,
            "user_type": "registered",
            "accept_rate": 95,
            "profile_image": "https:\/\/www.gravatar.com\/avatar\/bd42b746d79be5dd325a8e94bc00ac58?s=256&d=identicon&r=PG",
            "display_name": "Eli Courtwright",
            "link": "https:\/\/stackoverflow.com\/users\/1694\/eli-courtwright"
        },
        "is_accepted": false,
        "score": 3539,
        "last_activity_date": 1671066408,
        "last_edit_date": 1671066408,
        "creation_date": 1221743506,
        "answer_id": 92395,
        "question_id": 89228,
        "content_license": "CC BY-SA 4.0",
        "body_markdown": "Here is a summary of ways to call external programs, including their advantages and disadvantages:\r\n\r\n1. [`os.system`](https:\/\/docs.python.org\/3\/library\/os.html#os.system) passes the command and arguments to your system&#39;s shell. This is nice because you can actually run multiple commands at once in this manner and set up pipes and input\/output redirection. For example:  \r\n\r\n    ```python\r\n    os.system(&quot;some_command &lt; input_file | another_command &gt; output_file&quot;)  \r\n    ```\r\n\r\n    However, while this is convenient, you have to manually handle the escaping of shell characters such as spaces, et cetera. On the other hand, this also lets you run commands which are simply shell commands and not actually external programs.\r\n\r\n2. [`os.popen`](https:\/\/docs.python.org\/3\/library\/os.html#os.popen) will do the same thing as `os.system` except that it gives you a file-like object that you can use to access standard input\/output for that process. There are 3 other variants of popen that all handle the i\/o slightly differently. If you pass everything as a string, then your command is passed to the shell; if you pass them as a list then you don&#39;t need to worry about escaping anything. Example:\r\n\r\n    ```python\r\n    print(os.popen(&quot;ls -l&quot;).read())\r\n    ```\r\n\r\n3. [`subprocess.Popen`](https:\/\/docs.python.org\/3\/library\/subprocess.html#subprocess.Popen). This is intended as a replacement for `os.popen`, but has the downside of being slightly more complicated by virtue of being so comprehensive. For example, you&#39;d say:\r\n\r\n    ```python\r\n    print subprocess.Popen(&quot;echo Hello World&quot;, shell=True, stdout=subprocess.PIPE).stdout.read()\r\n    ```\r\n\r\n    instead of\r\n\r\n    ```python\r\n    print os.popen(&quot;echo Hello World&quot;).read()\r\n    ```\r\n\r\n    but it is nice to have all of the options there in one unified class instead of 4 different popen functions. See [the documentation](https:\/\/docs.python.org\/3\/library\/subprocess.html#popen-constructor).\r\n\r\n4. [`subprocess.call`](https:\/\/docs.python.org\/3\/library\/subprocess.html#subprocess.call). This is basically just like the `Popen` class and takes all of the same arguments, but it simply waits until the command completes and gives you the return code. For example:\r\n\r\n    ```python\r\n    return_code = subprocess.call(&quot;echo Hello World&quot;, shell=True)\r\n    ```\r\n\r\n5. [`subprocess.run`](https:\/\/docs.python.org\/3\/library\/subprocess.html#subprocess.run). Python 3.5+ only. Similar to the above but even more flexible and returns a [`CompletedProcess`](https:\/\/docs.python.org\/3\/library\/subprocess.html#subprocess.CompletedProcess) object when the command finishes executing.\r\n\r\n6. `os.fork`, `os.exec`, `os.spawn` are similar to their C language counterparts, but I don&#39;t recommend using them directly.\r\n\r\nThe `subprocess` module should probably be what you use.\r\n\r\nFinally, please be aware that for all methods where you pass the final command to be executed by the shell as a string and you are responsible for escaping it. **There are serious security implications** if any part of the string that you pass can not be fully trusted. For example, if a user is entering some\/any part of the string. If you are unsure, only use these methods with constants. To give you a hint of the implications consider this code:\r\n\r\n```python\r\nprint subprocess.Popen(&quot;echo %s &quot; % user_input, stdout=PIPE).stdout.read()\r\n```\r\n\r\nand imagine that the user enters something &quot;`my mama didnt love me &amp;&amp; rm -rf \/`&quot; which could erase the whole filesystem.\r\n",
        "body": "<p>Here is a summary of ways to call external programs, including their advantages and disadvantages:<\/p>\n<ol>\n<li><p><a href=\"https:\/\/docs.python.org\/3\/library\/os.html#os.system\" rel=\"noreferrer\"><code>os.system<\/code><\/a> passes the command and arguments to your system's shell. This is nice because you can actually run multiple commands at once in this manner and set up pipes and input\/output redirection. For example:<\/p>\n<pre class=\"lang-py prettyprint-override\"><code>os.system(&quot;some_command &lt; input_file | another_command &gt; output_file&quot;)  \n<\/code><\/pre>\n<p>However, while this is convenient, you have to manually handle the escaping of shell characters such as spaces, et cetera. On the other hand, this also lets you run commands which are simply shell commands and not actually external programs.<\/p>\n<\/li>\n<li><p><a href=\"https:\/\/docs.python.org\/3\/library\/os.html#os.popen\" rel=\"noreferrer\"><code>os.popen<\/code><\/a> will do the same thing as <code>os.system<\/code> except that it gives you a file-like object that you can use to access standard input\/output for that process. There are 3 other variants of popen that all handle the i\/o slightly differently. If you pass everything as a string, then your command is passed to the shell; if you pass them as a list then you don't need to worry about escaping anything. Example:<\/p>\n<pre class=\"lang-py prettyprint-override\"><code>print(os.popen(&quot;ls -l&quot;).read())\n<\/code><\/pre>\n<\/li>\n<li><p><a href=\"https:\/\/docs.python.org\/3\/library\/subprocess.html#subprocess.Popen\" rel=\"noreferrer\"><code>subprocess.Popen<\/code><\/a>. This is intended as a replacement for <code>os.popen<\/code>, but has the downside of being slightly more complicated by virtue of being so comprehensive. For example, you'd say:<\/p>\n<pre class=\"lang-py prettyprint-override\"><code>print subprocess.Popen(&quot;echo Hello World&quot;, shell=True, stdout=subprocess.PIPE).stdout.read()\n<\/code><\/pre>\n<p>instead of<\/p>\n<pre class=\"lang-py prettyprint-override\"><code>print os.popen(&quot;echo Hello World&quot;).read()\n<\/code><\/pre>\n<p>but it is nice to have all of the options there in one unified class instead of 4 different popen functions. See <a href=\"https:\/\/docs.python.org\/3\/library\/subprocess.html#popen-constructor\" rel=\"noreferrer\">the documentation<\/a>.<\/p>\n<\/li>\n<li><p><a href=\"https:\/\/docs.python.org\/3\/library\/subprocess.html#subprocess.call\" rel=\"noreferrer\"><code>subprocess.call<\/code><\/a>. This is basically just like the <code>Popen<\/code> class and takes all of the same arguments, but it simply waits until the command completes and gives you the return code. For example:<\/p>\n<pre class=\"lang-py prettyprint-override\"><code>return_code = subprocess.call(&quot;echo Hello World&quot;, shell=True)\n<\/code><\/pre>\n<\/li>\n<li><p><a href=\"https:\/\/docs.python.org\/3\/library\/subprocess.html#subprocess.run\" rel=\"noreferrer\"><code>subprocess.run<\/code><\/a>. Python 3.5+ only. Similar to the above but even more flexible and returns a <a href=\"https:\/\/docs.python.org\/3\/library\/subprocess.html#subprocess.CompletedProcess\" rel=\"noreferrer\"><code>CompletedProcess<\/code><\/a> object when the command finishes executing.<\/p>\n<\/li>\n<li><p><code>os.fork<\/code>, <code>os.exec<\/code>, <code>os.spawn<\/code> are similar to their C language counterparts, but I don't recommend using them directly.<\/p>\n<\/li>\n<\/ol>\n<p>The <code>subprocess<\/code> module should probably be what you use.<\/p>\n<p>Finally, please be aware that for all methods where you pass the final command to be executed by the shell as a string and you are responsible for escaping it. <strong>There are serious security implications<\/strong> if any part of the string that you pass can not be fully trusted. For example, if a user is entering some\/any part of the string. If you are unsure, only use these methods with constants. To give you a hint of the implications consider this code:<\/p>\n<pre class=\"lang-py prettyprint-override\"><code>print subprocess.Popen(&quot;echo %s &quot; % user_input, stdout=PIPE).stdout.read()\n<\/code><\/pre>\n<p>and imagine that the user enters something &quot;<code>my mama didnt love me &amp;&amp; rm -rf \/<\/code>&quot; which could erase the whole filesystem.<\/p>\n",
        "community_owned_date": null
    },
    {
        "owner": {
            "account_id": 914,
            "reputation": 235159,
            "user_id": 1199,
            "user_type": "registered",
            "profile_image": "https:\/\/www.gravatar.com\/avatar\/78cb7314ef6c9ff2954f8e0d6506fc06?s=256&d=identicon&r=PG",
            "display_name": "Blair Conrad",
            "link": "https:\/\/stackoverflow.com\/users\/1199\/blair-conrad"
        },
        "is_accepted": true,
        "score": 3515,
        "last_activity_date": 1491185618,
        "last_edit_date": 1491185618,
        "creation_date": 1244805507,
        "answer_id": 986145,
        "question_id": 986006,
        "content_license": "CC BY-SA 3.0",
        "body_markdown": "Arguments are [passed by assignment][1]. The rationale behind this is twofold:\r\n\r\n1. the parameter passed in is actually a _reference_ to an object (but the reference is passed by value)\r\n2. some data types are mutable, but others aren&#39;t\r\n\r\nSo:\r\n\r\n* If you pass a *mutable* object into a method, the method gets a reference to that same object and you can mutate it to your heart&#39;s delight, but if you rebind the reference in the method, the outer scope will know nothing about it, and after you&#39;re done, the outer reference will still point at the original object. \r\n\r\n* If you pass an *immutable* object to a method, you still can&#39;t rebind the outer reference, and you can&#39;t even mutate the object.\r\n\r\nTo make it even more clear, let&#39;s have some examples. \r\n\r\nList - a mutable type\r\n-----\r\n\r\n**Let&#39;s try to modify the list that was passed to a method:**\r\n\r\n    def try_to_change_list_contents(the_list):\r\n        print(&#39;got&#39;, the_list)\r\n        the_list.append(&#39;four&#39;)\r\n        print(&#39;changed to&#39;, the_list)\r\n\r\n    outer_list = [&#39;one&#39;, &#39;two&#39;, &#39;three&#39;]\r\n    \r\n    print(&#39;before, outer_list =&#39;, outer_list)\r\n    try_to_change_list_contents(outer_list)\r\n    print(&#39;after, outer_list =&#39;, outer_list)\r\n\r\nOutput:\r\n\r\n&lt;!-- language: none --&gt;\r\n\r\n    before, outer_list = [&#39;one&#39;, &#39;two&#39;, &#39;three&#39;]\r\n    got [&#39;one&#39;, &#39;two&#39;, &#39;three&#39;]\r\n    changed to [&#39;one&#39;, &#39;two&#39;, &#39;three&#39;, &#39;four&#39;]\r\n    after, outer_list = [&#39;one&#39;, &#39;two&#39;, &#39;three&#39;, &#39;four&#39;]\r\n\r\nSince the parameter passed in is a reference to `outer_list`, not a copy of it, we can use the mutating list methods to change it and have the changes reflected in the outer scope.\r\n\r\n\r\n**Now let&#39;s see what happens when we try to change the reference that was passed in as a parameter:**\r\n\r\n    def try_to_change_list_reference(the_list):\r\n        print(&#39;got&#39;, the_list)\r\n        the_list = [&#39;and&#39;, &#39;we&#39;, &#39;can&#39;, &#39;not&#39;, &#39;lie&#39;]\r\n        print(&#39;set to&#39;, the_list)\r\n    \r\n    outer_list = [&#39;we&#39;, &#39;like&#39;, &#39;proper&#39;, &#39;English&#39;]\r\n    \r\n    print(&#39;before, outer_list =&#39;, outer_list)\r\n    try_to_change_list_reference(outer_list)\r\n    print(&#39;after, outer_list =&#39;, outer_list)\r\n\r\nOutput:\r\n\r\n&lt;!-- language: none --&gt;\r\n\r\n    before, outer_list = [&#39;we&#39;, &#39;like&#39;, &#39;proper&#39;, &#39;English&#39;]\r\n    got [&#39;we&#39;, &#39;like&#39;, &#39;proper&#39;, &#39;English&#39;]\r\n    set to [&#39;and&#39;, &#39;we&#39;, &#39;can&#39;, &#39;not&#39;, &#39;lie&#39;]\r\n    after, outer_list = [&#39;we&#39;, &#39;like&#39;, &#39;proper&#39;, &#39;English&#39;]\r\n\r\nSince the `the_list` parameter was passed by value, assigning a new list to it had no effect that the code outside the method could see. The `the_list` was a copy of the `outer_list` reference, and we had `the_list` point to a new list, but there was no way to change where `outer_list` pointed.\r\n\r\nString - an immutable type\r\n------\r\n\r\n**It&#39;s immutable, so there&#39;s nothing we can do to change the contents of the string**\r\n\r\n**Now, let&#39;s try to change the reference**\r\n\r\n    def try_to_change_string_reference(the_string):\r\n        print(&#39;got&#39;, the_string)\r\n        the_string = &#39;In a kingdom by the sea&#39;\r\n        print(&#39;set to&#39;, the_string)\r\n    \r\n    outer_string = &#39;It was many and many a year ago&#39;\r\n    \r\n    print(&#39;before, outer_string =&#39;, outer_string)\r\n    try_to_change_string_reference(outer_string)\r\n    print(&#39;after, outer_string =&#39;, outer_string)\r\n\r\nOutput:\r\n\r\n&lt;!-- language: none --&gt;\r\n\r\n    before, outer_string = It was many and many a year ago\r\n    got It was many and many a year ago\r\n    set to In a kingdom by the sea\r\n    after, outer_string = It was many and many a year ago\r\n\r\nAgain, since the `the_string` parameter was passed by value, assigning a new string to it had no effect that the code outside the method could see. The `the_string` was a copy of the `outer_string` reference, and we had `the_string` point to a new string, but there was no way to change where `outer_string` pointed.\r\n\r\nI hope this clears things up a little.\r\n\r\n**EDIT:** It&#39;s been noted that this doesn&#39;t answer the question that @David originally asked, &quot;Is there something I can do to pass the variable by actual reference?&quot;. Let&#39;s work on that.\r\n\r\nHow do we get around this?\r\n------\r\n\r\nAs @[Andrea](#986031)&#39;s answer shows, you could return the new value. This doesn&#39;t change the way things are passed in, but does let you get the information you want back out:\r\n\r\n    def return_a_whole_new_string(the_string):\r\n        new_string = something_to_do_with_the_old_string(the_string)\r\n        return new_string\r\n\r\n    # then you could call it like\r\n    my_string = return_a_whole_new_string(my_string)\r\n\r\nIf you really wanted to avoid using a return value, you could create a class to hold your value and pass it into the function or use an existing class, like a list:\r\n\r\n    def use_a_wrapper_to_simulate_pass_by_reference(stuff_to_change):\r\n        new_string = something_to_do_with_the_old_string(stuff_to_change[0])\r\n        stuff_to_change[0] = new_string\r\n\r\n    # then you could call it like\r\n    wrapper = [my_string]\r\n    use_a_wrapper_to_simulate_pass_by_reference(wrapper)\r\n\r\n    do_something_with(wrapper[0])\r\n\r\nAlthough this seems a little cumbersome.\r\n\r\n\r\n  [1]: http:\/\/docs.python.org\/3\/faq\/programming.html#how-do-i-write-a-function-with-output-parameters-call-by-reference",
        "body": "<p>Arguments are <a href=\"http:\/\/docs.python.org\/3\/faq\/programming.html#how-do-i-write-a-function-with-output-parameters-call-by-reference\" rel=\"noreferrer\">passed by assignment<\/a>. The rationale behind this is twofold:<\/p>\n\n<ol>\n<li>the parameter passed in is actually a <em>reference<\/em> to an object (but the reference is passed by value)<\/li>\n<li>some data types are mutable, but others aren't<\/li>\n<\/ol>\n\n<p>So:<\/p>\n\n<ul>\n<li><p>If you pass a <em>mutable<\/em> object into a method, the method gets a reference to that same object and you can mutate it to your heart's delight, but if you rebind the reference in the method, the outer scope will know nothing about it, and after you're done, the outer reference will still point at the original object. <\/p><\/li>\n<li><p>If you pass an <em>immutable<\/em> object to a method, you still can't rebind the outer reference, and you can't even mutate the object.<\/p><\/li>\n<\/ul>\n\n<p>To make it even more clear, let's have some examples. <\/p>\n\n<h2>List - a mutable type<\/h2>\n\n<p><strong>Let's try to modify the list that was passed to a method:<\/strong><\/p>\n\n<pre><code>def try_to_change_list_contents(the_list):\n    print('got', the_list)\n    the_list.append('four')\n    print('changed to', the_list)\n\nouter_list = ['one', 'two', 'three']\n\nprint('before, outer_list =', outer_list)\ntry_to_change_list_contents(outer_list)\nprint('after, outer_list =', outer_list)\n<\/code><\/pre>\n\n<p>Output:<\/p>\n\n<pre class=\"lang-none prettyprint-override\"><code>before, outer_list = ['one', 'two', 'three']\ngot ['one', 'two', 'three']\nchanged to ['one', 'two', 'three', 'four']\nafter, outer_list = ['one', 'two', 'three', 'four']\n<\/code><\/pre>\n\n<p>Since the parameter passed in is a reference to <code>outer_list<\/code>, not a copy of it, we can use the mutating list methods to change it and have the changes reflected in the outer scope.<\/p>\n\n<p><strong>Now let's see what happens when we try to change the reference that was passed in as a parameter:<\/strong><\/p>\n\n<pre><code>def try_to_change_list_reference(the_list):\n    print('got', the_list)\n    the_list = ['and', 'we', 'can', 'not', 'lie']\n    print('set to', the_list)\n\nouter_list = ['we', 'like', 'proper', 'English']\n\nprint('before, outer_list =', outer_list)\ntry_to_change_list_reference(outer_list)\nprint('after, outer_list =', outer_list)\n<\/code><\/pre>\n\n<p>Output:<\/p>\n\n<pre class=\"lang-none prettyprint-override\"><code>before, outer_list = ['we', 'like', 'proper', 'English']\ngot ['we', 'like', 'proper', 'English']\nset to ['and', 'we', 'can', 'not', 'lie']\nafter, outer_list = ['we', 'like', 'proper', 'English']\n<\/code><\/pre>\n\n<p>Since the <code>the_list<\/code> parameter was passed by value, assigning a new list to it had no effect that the code outside the method could see. The <code>the_list<\/code> was a copy of the <code>outer_list<\/code> reference, and we had <code>the_list<\/code> point to a new list, but there was no way to change where <code>outer_list<\/code> pointed.<\/p>\n\n<h2>String - an immutable type<\/h2>\n\n<p><strong>It's immutable, so there's nothing we can do to change the contents of the string<\/strong><\/p>\n\n<p><strong>Now, let's try to change the reference<\/strong><\/p>\n\n<pre><code>def try_to_change_string_reference(the_string):\n    print('got', the_string)\n    the_string = 'In a kingdom by the sea'\n    print('set to', the_string)\n\nouter_string = 'It was many and many a year ago'\n\nprint('before, outer_string =', outer_string)\ntry_to_change_string_reference(outer_string)\nprint('after, outer_string =', outer_string)\n<\/code><\/pre>\n\n<p>Output:<\/p>\n\n<pre class=\"lang-none prettyprint-override\"><code>before, outer_string = It was many and many a year ago\ngot It was many and many a year ago\nset to In a kingdom by the sea\nafter, outer_string = It was many and many a year ago\n<\/code><\/pre>\n\n<p>Again, since the <code>the_string<\/code> parameter was passed by value, assigning a new string to it had no effect that the code outside the method could see. The <code>the_string<\/code> was a copy of the <code>outer_string<\/code> reference, and we had <code>the_string<\/code> point to a new string, but there was no way to change where <code>outer_string<\/code> pointed.<\/p>\n\n<p>I hope this clears things up a little.<\/p>\n\n<p><strong>EDIT:<\/strong> It's been noted that this doesn't answer the question that @David originally asked, \"Is there something I can do to pass the variable by actual reference?\". Let's work on that.<\/p>\n\n<h2>How do we get around this?<\/h2>\n\n<p>As @Andrea's answer shows, you could return the new value. This doesn't change the way things are passed in, but does let you get the information you want back out:<\/p>\n\n<pre><code>def return_a_whole_new_string(the_string):\n    new_string = something_to_do_with_the_old_string(the_string)\n    return new_string\n\n# then you could call it like\nmy_string = return_a_whole_new_string(my_string)\n<\/code><\/pre>\n\n<p>If you really wanted to avoid using a return value, you could create a class to hold your value and pass it into the function or use an existing class, like a list:<\/p>\n\n<pre><code>def use_a_wrapper_to_simulate_pass_by_reference(stuff_to_change):\n    new_string = something_to_do_with_the_old_string(stuff_to_change[0])\n    stuff_to_change[0] = new_string\n\n# then you could call it like\nwrapper = [my_string]\nuse_a_wrapper_to_simulate_pass_by_reference(wrapper)\n\ndo_something_with(wrapper[0])\n<\/code><\/pre>\n\n<p>Although this seems a little cumbersome.<\/p>\n",
        "community_owned_date": null
    },
    {
        "owner": {
            "account_id": 42135,
            "reputation": 36441,
            "user_id": 122683,
            "user_type": "registered",
            "profile_image": "https:\/\/www.gravatar.com\/avatar\/9a414150a10bd70bfb5be0ba6b045e82?s=256&d=identicon&r=PG",
            "display_name": "moshez",
            "link": "https:\/\/stackoverflow.com\/users\/122683\/moshez"
        },
        "is_accepted": true,
        "score": 3465,
        "last_activity_date": 1684612163,
        "last_edit_date": 1684612163,
        "creation_date": 1271120212,
        "answer_id": 2626364,
        "question_id": 1436703,
        "content_license": "CC BY-SA 4.0",
        "body_markdown": "&lt;!-- language-all: lang-python --&gt;\r\n[Alex Martelli summarized well][2] but, surprisingly, was too succinct.\r\n\r\nFirst, let me reiterate the main points in [Alex][1]\u2019s post:\r\n\r\n   - The default implementation is useless (it\u2019s hard to think of one which wouldn\u2019t be, but yeah)\r\n   - `__repr__` goal is to be unambiguous\r\n   - `__str__` goal is to be readable\r\n   - Container\u2019s `__str__` uses contained objects\u2019 `__repr__`\r\n\r\n**Default implementation is useless**\r\n\r\nThis is mostly a surprise because Python\u2019s defaults tend to be fairly useful. However, in this case, having a default for `__repr__` which would act like:\r\n\r\n    return &quot;%s(%r)&quot; % (self.__class__, self.__dict__)\r\n\r\nwould have been too dangerous (for example, too easy to get into infinite recursion if objects reference each other). So Python cops out. Note that there is one default which is true: if `__repr__` is defined, and `__str__` is not, the object will behave as though `__str__=__repr__`.\r\n\r\nThis means, in simple terms: almost every object you implement should have a functional `__repr__` that\u2019s usable for understanding the object. Implementing `__str__` is optional: do that if you need a \u201cpretty print\u201d functionality (for example, used by a report generator).\r\n\r\n**The goal of `__repr__` is to be unambiguous**\r\n\r\nLet me come right out and say it \u2014 I do not believe in debuggers. I don\u2019t really know how to use any debugger, and have never used one seriously. Furthermore, I believe that the big fault in debuggers is their basic nature \u2014 most failures I debug happened a long long time ago, in a galaxy far far away. This means that I do believe, with religious fervor, in logging. Logging is the lifeblood of any decent fire-and-forget server system. Python makes it easy to log: with maybe some project specific wrappers, all you need is a\r\n\r\n    log(INFO, &quot;I am in the weird function and a is&quot;, a, &quot;and b is&quot;, b, &quot;but I got a null C \u2014 using default&quot;, default_c)\r\n\r\nBut you have to do the last step \u2014 make sure every object you implement has a useful repr, so code like that can just work. This is why the \u201ceval\u201d thing comes up: if you have enough information so `eval(repr(c))==c`, that means you know everything there is to know about `c`. If that\u2019s easy enough, at least in a fuzzy way, do it. If not, make sure you have enough information about `c` anyway. I usually use an eval-like format: `&quot;MyClass(this=%r,that=%r)&quot; % (self.this,self.that)`. It does not mean that you can actually construct MyClass, or that those are the right constructor arguments \u2014 but it is a useful form to express \u201cthis is everything you need to know about this instance\u201d.\r\n\r\nNote: I used `%r` above, not `%s`. You always want to use `repr()` [or `%r` formatting character, equivalently] inside `__repr__` implementation, or you\u2019re defeating the goal of repr. You want to be able to differentiate `MyClass(3)` and `MyClass(&quot;3&quot;)`.\r\n\r\n**The goal of `__str__` is to be readable**\r\n\r\nSpecifically, it is not intended to be unambiguous \u2014 notice that `str(3)==str(&quot;3&quot;)`. Likewise, if you implement an IP abstraction, having the str of it look like 192.168.1.1 is just fine. When implementing a date\/time abstraction, the str can be &quot;2010\/4\/12 15:35:22&quot;, etc. The goal is to represent it in a way that a user, not a programmer, would want to read it. Chop off useless digits, pretend to be some other class \u2014 as long is it supports readability, it is an improvement.\r\n\r\n**Container\u2019s `__str__` uses contained objects\u2019 `__repr__`**\r\n\r\nThis seems surprising, doesn\u2019t it? It is a little, but how readable would it be if it used their `__str__`?\r\n\r\n    [moshe is, 3, hello\r\n    world, this is a list, oh I don&#39;t know, containing just 4 elements]\r\n\r\nNot very. Specifically, the strings in a container would find it way too easy to disturb its string representation. In the face of ambiguity, remember, Python resists the temptation to guess. If you want the above behavior when you\u2019re printing a list, just\r\n\r\n    print(&quot;[&quot; + &quot;, &quot;.join(lst) + &quot;]&quot;)\r\n\r\n(you can probably also figure out what to do about dictionaries).\r\n\r\n**Summary**\r\n\r\nImplement `__repr__` for any class you implement. This should be second nature. Implement `__str__` if you think it would be useful to have a string version which errs on the side of readability.\r\n\r\n\r\n  [1]: https:\/\/stackoverflow.com\/users\/95810\/alex-martelli\r\n  [2]: https:\/\/stackoverflow.com\/a\/1436756\/3798217",
        "body": "\n<p><a href=\"https:\/\/stackoverflow.com\/a\/1436756\/3798217\">Alex Martelli summarized well<\/a> but, surprisingly, was too succinct.<\/p>\n<p>First, let me reiterate the main points in <a href=\"https:\/\/stackoverflow.com\/users\/95810\/alex-martelli\">Alex<\/a>\u2019s post:<\/p>\n<ul>\n<li>The default implementation is useless (it\u2019s hard to think of one which wouldn\u2019t be, but yeah)<\/li>\n<li><code>__repr__<\/code> goal is to be unambiguous<\/li>\n<li><code>__str__<\/code> goal is to be readable<\/li>\n<li>Container\u2019s <code>__str__<\/code> uses contained objects\u2019 <code>__repr__<\/code><\/li>\n<\/ul>\n<p><strong>Default implementation is useless<\/strong><\/p>\n<p>This is mostly a surprise because Python\u2019s defaults tend to be fairly useful. However, in this case, having a default for <code>__repr__<\/code> which would act like:<\/p>\n<pre class=\"lang-python prettyprint-override\"><code>return &quot;%s(%r)&quot; % (self.__class__, self.__dict__)\n<\/code><\/pre>\n<p>would have been too dangerous (for example, too easy to get into infinite recursion if objects reference each other). So Python cops out. Note that there is one default which is true: if <code>__repr__<\/code> is defined, and <code>__str__<\/code> is not, the object will behave as though <code>__str__=__repr__<\/code>.<\/p>\n<p>This means, in simple terms: almost every object you implement should have a functional <code>__repr__<\/code> that\u2019s usable for understanding the object. Implementing <code>__str__<\/code> is optional: do that if you need a \u201cpretty print\u201d functionality (for example, used by a report generator).<\/p>\n<p><strong>The goal of <code>__repr__<\/code> is to be unambiguous<\/strong><\/p>\n<p>Let me come right out and say it \u2014 I do not believe in debuggers. I don\u2019t really know how to use any debugger, and have never used one seriously. Furthermore, I believe that the big fault in debuggers is their basic nature \u2014 most failures I debug happened a long long time ago, in a galaxy far far away. This means that I do believe, with religious fervor, in logging. Logging is the lifeblood of any decent fire-and-forget server system. Python makes it easy to log: with maybe some project specific wrappers, all you need is a<\/p>\n<pre class=\"lang-python prettyprint-override\"><code>log(INFO, &quot;I am in the weird function and a is&quot;, a, &quot;and b is&quot;, b, &quot;but I got a null C \u2014 using default&quot;, default_c)\n<\/code><\/pre>\n<p>But you have to do the last step \u2014 make sure every object you implement has a useful repr, so code like that can just work. This is why the \u201ceval\u201d thing comes up: if you have enough information so <code>eval(repr(c))==c<\/code>, that means you know everything there is to know about <code>c<\/code>. If that\u2019s easy enough, at least in a fuzzy way, do it. If not, make sure you have enough information about <code>c<\/code> anyway. I usually use an eval-like format: <code>&quot;MyClass(this=%r,that=%r)&quot; % (self.this,self.that)<\/code>. It does not mean that you can actually construct MyClass, or that those are the right constructor arguments \u2014 but it is a useful form to express \u201cthis is everything you need to know about this instance\u201d.<\/p>\n<p>Note: I used <code>%r<\/code> above, not <code>%s<\/code>. You always want to use <code>repr()<\/code> [or <code>%r<\/code> formatting character, equivalently] inside <code>__repr__<\/code> implementation, or you\u2019re defeating the goal of repr. You want to be able to differentiate <code>MyClass(3)<\/code> and <code>MyClass(&quot;3&quot;)<\/code>.<\/p>\n<p><strong>The goal of <code>__str__<\/code> is to be readable<\/strong><\/p>\n<p>Specifically, it is not intended to be unambiguous \u2014 notice that <code>str(3)==str(&quot;3&quot;)<\/code>. Likewise, if you implement an IP abstraction, having the str of it look like 192.168.1.1 is just fine. When implementing a date\/time abstraction, the str can be &quot;2010\/4\/12 15:35:22&quot;, etc. The goal is to represent it in a way that a user, not a programmer, would want to read it. Chop off useless digits, pretend to be some other class \u2014 as long is it supports readability, it is an improvement.<\/p>\n<p><strong>Container\u2019s <code>__str__<\/code> uses contained objects\u2019 <code>__repr__<\/code><\/strong><\/p>\n<p>This seems surprising, doesn\u2019t it? It is a little, but how readable would it be if it used their <code>__str__<\/code>?<\/p>\n<pre class=\"lang-python prettyprint-override\"><code>[moshe is, 3, hello\nworld, this is a list, oh I don't know, containing just 4 elements]\n<\/code><\/pre>\n<p>Not very. Specifically, the strings in a container would find it way too easy to disturb its string representation. In the face of ambiguity, remember, Python resists the temptation to guess. If you want the above behavior when you\u2019re printing a list, just<\/p>\n<pre class=\"lang-python prettyprint-override\"><code>print(&quot;[&quot; + &quot;, &quot;.join(lst) + &quot;]&quot;)\n<\/code><\/pre>\n<p>(you can probably also figure out what to do about dictionaries).<\/p>\n<p><strong>Summary<\/strong><\/p>\n<p>Implement <code>__repr__<\/code> for any class you implement. This should be second nature. Implement <code>__str__<\/code> if you think it would be useful to have a string version which errs on the side of readability.<\/p>\n",
        "community_owned_date": null
    },
    {
        "owner": {
            "account_id": 20689,
            "reputation": 99535,
            "user_id": 49701,
            "user_type": "registered",
            "accept_rate": 94,
            "profile_image": "https:\/\/www.gravatar.com\/avatar\/88c44d4902ae5685dae7d672da983e08?s=256&d=identicon&r=PG",
            "display_name": "Evan Fosmark",
            "link": "https:\/\/stackoverflow.com\/users\/49701\/evan-fosmark"
        },
        "is_accepted": false,
        "score": 3449,
        "last_activity_date": 1695306095,
        "last_edit_date": 1695306095,
        "creation_date": 1233731159,
        "answer_id": 510351,
        "question_id": 510348,
        "content_license": "CC BY-SA 4.0",
        "body_markdown": "This delays for 2.5 seconds:\r\n\r\n    import time\r\n\r\n    time.sleep(2.5)\r\n\r\n---\r\n\r\nHere is another example where something is run approximately once a minute:\r\n\r\n    import time\r\n\r\n    while True:\r\n        print(&quot;This prints once a minute.&quot;)\r\n        time.sleep(60) # Delay for 1 minute (60 seconds).\r\n",
        "body": "<p>This delays for 2.5 seconds:<\/p>\n<pre><code>import time\n\ntime.sleep(2.5)\n<\/code><\/pre>\n<hr \/>\n<p>Here is another example where something is run approximately once a minute:<\/p>\n<pre><code>import time\n\nwhile True:\n    print(&quot;This prints once a minute.&quot;)\n    time.sleep(60) # Delay for 1 minute (60 seconds).\n<\/code><\/pre>\n",
        "community_owned_date": null
    },
    {
        "owner": {
            "account_id": 9516,
            "reputation": 131036,
            "user_id": 17624,
            "user_type": "registered",
            "profile_image": "https:\/\/www.gravatar.com\/avatar\/90285a816eda046ff55a0dcacc0c5ee8?s=256&d=identicon&r=PG",
            "display_name": "Thomas Wouters",
            "link": "https:\/\/stackoverflow.com\/users\/17624\/thomas-wouters"
        },
        "is_accepted": true,
        "score": 3426,
        "last_activity_date": 1551735259,
        "last_edit_date": 1551735259,
        "creation_date": 1221807718,
        "answer_id": 100146,
        "question_id": 100003,
        "content_license": "CC BY-SA 4.0",
        "body_markdown": "A metaclass is the class of a class. A class defines how an instance of the class (i.e. an object) behaves while a metaclass defines how a class behaves. A class is an instance of a metaclass.\r\n\r\nWhile in Python you can use arbitrary callables for metaclasses (like [Jerub][1] shows), the better approach is to make it an actual class itself. `type` is the usual metaclass in Python. `type` is itself a class, and it is its own type. You won&#39;t be able to recreate something like `type` purely in Python, but Python cheats a little. To create your own metaclass in Python you really just want to subclass `type`.\r\n\r\nA metaclass is most commonly used as a class-factory. When you create an object by calling the class, Python creates a new class (when it executes the &#39;class&#39; statement) by calling the metaclass. Combined with the normal `__init__` and `__new__` methods, metaclasses therefore allow you to do &#39;extra things&#39; when creating a class, like registering the new class with some registry or replace the class with something else entirely.\r\n\r\nWhen the `class` statement is executed, Python first executes the body of the `class` statement as a normal block of code. The resulting namespace (a dict) holds the attributes of the class-to-be. The metaclass is determined by looking at the baseclasses of the class-to-be (metaclasses are inherited), at the `__metaclass__` attribute of the class-to-be (if any) or the `__metaclass__` global variable. The metaclass is then called with the name, bases and attributes of the class to instantiate it.\r\n\r\nHowever, metaclasses actually define the *type* of a class, not just a factory for it, so you can do much more with them. You can, for instance, define normal methods on the metaclass. These metaclass-methods are like classmethods in that they can be called on the class without an instance, but they are also not like classmethods in that they cannot be called on an instance of the class. `type.__subclasses__()` is an example of a method on the `type` metaclass. You can also define the normal &#39;magic&#39; methods, like `__add__`, `__iter__` and `__getattr__`, to implement or change how the class behaves.\r\n\r\nHere&#39;s an aggregated example of the bits and pieces:\r\n\r\n    def make_hook(f):\r\n        &quot;&quot;&quot;Decorator to turn &#39;foo&#39; method into &#39;__foo__&#39;&quot;&quot;&quot;\r\n        f.is_hook = 1\r\n        return f\r\n    \r\n    class MyType(type):\r\n        def __new__(mcls, name, bases, attrs):\r\n    \r\n            if name.startswith(&#39;None&#39;):\r\n                return None\r\n    \r\n            # Go over attributes and see if they should be renamed.\r\n            newattrs = {}\r\n            for attrname, attrvalue in attrs.iteritems():\r\n                if getattr(attrvalue, &#39;is_hook&#39;, 0):\r\n                    newattrs[&#39;__%s__&#39; % attrname] = attrvalue\r\n                else:\r\n                    newattrs[attrname] = attrvalue\r\n    \r\n            return super(MyType, mcls).__new__(mcls, name, bases, newattrs)\r\n    \r\n        def __init__(self, name, bases, attrs):\r\n            super(MyType, self).__init__(name, bases, attrs)\r\n    \r\n            # classregistry.register(self, self.interfaces)\r\n            print &quot;Would register class %s now.&quot; % self\r\n    \r\n        def __add__(self, other):\r\n            class AutoClass(self, other):\r\n                pass\r\n            return AutoClass\r\n            # Alternatively, to autogenerate the classname as well as the class:\r\n            # return type(self.__name__ + other.__name__, (self, other), {})\r\n    \r\n        def unregister(self):\r\n            # classregistry.unregister(self)\r\n            print &quot;Would unregister class %s now.&quot; % self\r\n    \r\n    class MyObject:\r\n        __metaclass__ = MyType\r\n    \r\n    \r\n    class NoneSample(MyObject):\r\n        pass\r\n    \r\n    # Will print &quot;NoneType None&quot;\r\n    print type(NoneSample), repr(NoneSample)\r\n    \r\n    class Example(MyObject):\r\n        def __init__(self, value):\r\n            self.value = value\r\n        @make_hook\r\n        def add(self, other):\r\n            return self.__class__(self.value + other.value)\r\n    \r\n    # Will unregister the class\r\n    Example.unregister()\r\n    \r\n    inst = Example(10)\r\n    # Will fail with an AttributeError\r\n    #inst.unregister()\r\n    \r\n    print inst + inst\r\n    class Sibling(MyObject):\r\n        pass\r\n    \r\n    ExampleSibling = Example + Sibling\r\n    # ExampleSibling is now a subclass of both Example and Sibling (with no\r\n    # content of its own) although it will believe it&#39;s called &#39;AutoClass&#39;\r\n    print ExampleSibling\r\n    print ExampleSibling.__mro__\r\n\r\n  [1]: https:\/\/stackoverflow.com\/questions\/100003\/what-is-a-metaclass-in-python\/100037#100037",
        "body": "<p>A metaclass is the class of a class. A class defines how an instance of the class (i.e. an object) behaves while a metaclass defines how a class behaves. A class is an instance of a metaclass.<\/p>\n\n<p>While in Python you can use arbitrary callables for metaclasses (like <a href=\"https:\/\/stackoverflow.com\/questions\/100003\/what-is-a-metaclass-in-python\/100037#100037\">Jerub<\/a> shows), the better approach is to make it an actual class itself. <code>type<\/code> is the usual metaclass in Python. <code>type<\/code> is itself a class, and it is its own type. You won't be able to recreate something like <code>type<\/code> purely in Python, but Python cheats a little. To create your own metaclass in Python you really just want to subclass <code>type<\/code>.<\/p>\n\n<p>A metaclass is most commonly used as a class-factory. When you create an object by calling the class, Python creates a new class (when it executes the 'class' statement) by calling the metaclass. Combined with the normal <code>__init__<\/code> and <code>__new__<\/code> methods, metaclasses therefore allow you to do 'extra things' when creating a class, like registering the new class with some registry or replace the class with something else entirely.<\/p>\n\n<p>When the <code>class<\/code> statement is executed, Python first executes the body of the <code>class<\/code> statement as a normal block of code. The resulting namespace (a dict) holds the attributes of the class-to-be. The metaclass is determined by looking at the baseclasses of the class-to-be (metaclasses are inherited), at the <code>__metaclass__<\/code> attribute of the class-to-be (if any) or the <code>__metaclass__<\/code> global variable. The metaclass is then called with the name, bases and attributes of the class to instantiate it.<\/p>\n\n<p>However, metaclasses actually define the <em>type<\/em> of a class, not just a factory for it, so you can do much more with them. You can, for instance, define normal methods on the metaclass. These metaclass-methods are like classmethods in that they can be called on the class without an instance, but they are also not like classmethods in that they cannot be called on an instance of the class. <code>type.__subclasses__()<\/code> is an example of a method on the <code>type<\/code> metaclass. You can also define the normal 'magic' methods, like <code>__add__<\/code>, <code>__iter__<\/code> and <code>__getattr__<\/code>, to implement or change how the class behaves.<\/p>\n\n<p>Here's an aggregated example of the bits and pieces:<\/p>\n\n<pre><code>def make_hook(f):\n    \"\"\"Decorator to turn 'foo' method into '__foo__'\"\"\"\n    f.is_hook = 1\n    return f\n\nclass MyType(type):\n    def __new__(mcls, name, bases, attrs):\n\n        if name.startswith('None'):\n            return None\n\n        # Go over attributes and see if they should be renamed.\n        newattrs = {}\n        for attrname, attrvalue in attrs.iteritems():\n            if getattr(attrvalue, 'is_hook', 0):\n                newattrs['__%s__' % attrname] = attrvalue\n            else:\n                newattrs[attrname] = attrvalue\n\n        return super(MyType, mcls).__new__(mcls, name, bases, newattrs)\n\n    def __init__(self, name, bases, attrs):\n        super(MyType, self).__init__(name, bases, attrs)\n\n        # classregistry.register(self, self.interfaces)\n        print \"Would register class %s now.\" % self\n\n    def __add__(self, other):\n        class AutoClass(self, other):\n            pass\n        return AutoClass\n        # Alternatively, to autogenerate the classname as well as the class:\n        # return type(self.__name__ + other.__name__, (self, other), {})\n\n    def unregister(self):\n        # classregistry.unregister(self)\n        print \"Would unregister class %s now.\" % self\n\nclass MyObject:\n    __metaclass__ = MyType\n\n\nclass NoneSample(MyObject):\n    pass\n\n# Will print \"NoneType None\"\nprint type(NoneSample), repr(NoneSample)\n\nclass Example(MyObject):\n    def __init__(self, value):\n        self.value = value\n    @make_hook\n    def add(self, other):\n        return self.__class__(self.value + other.value)\n\n# Will unregister the class\nExample.unregister()\n\ninst = Example(10)\n# Will fail with an AttributeError\n#inst.unregister()\n\nprint inst + inst\nclass Sibling(MyObject):\n    pass\n\nExampleSibling = Example + Sibling\n# ExampleSibling is now a subclass of both Example and Sibling (with no\n# content of its own) although it will believe it's called 'AutoClass'\nprint ExampleSibling\nprint ExampleSibling.__mro__\n<\/code><\/pre>\n",
        "community_owned_date": null
    },
    {
        "owner": {
            "account_id": 342731,
            "reputation": 344122,
            "user_id": 674039,
            "user_type": "registered",
            "accept_rate": 94,
            "profile_image": "https:\/\/i.stack.imgur.com\/leoFi.gif?s=256&g=1",
            "display_name": "wim",
            "link": "https:\/\/stackoverflow.com\/users\/674039\/wim"
        },
        "is_accepted": false,
        "score": 3424,
        "last_activity_date": 1678538726,
        "last_edit_date": 1678538726,
        "creation_date": 1391440201,
        "answer_id": 21530768,
        "question_id": 21530577,
        "content_license": "CC BY-SA 4.0",
        "body_markdown": "&lt;!-- language-all: lang-bash --&gt;\r\n\r\nLooks like you haven&#39;t properly installed the header files and static libraries for python dev.  Use your package manager to install them system-wide.  \r\n\r\nFor `apt` (**Ubuntu, Debian...**):\r\n\r\n    sudo apt-get install python-dev   # for python2.x installs\r\n    sudo apt-get install python3-dev  # for python3.x installs\r\n\r\nFor `yum` (**CentOS, RHEL...**):\r\n\r\n    sudo yum install python-devel    # for python2.x installs\r\n    sudo yum install python3-devel   # for python3.x installs\r\n\r\nFor `dnf` (**Fedora...**):\r\n\r\n    sudo dnf install python2-devel  # for python2.x installs\r\n    sudo dnf install python3-devel  # for python3.x installs\r\n\r\nFor `zypper` (**openSUSE...**):\r\n\r\n    sudo zypper in python-devel   # for python2.x installs\r\n    sudo zypper in python3-devel  # for python3.x installs\r\n\r\nFor `apk` (**Alpine...**):\r\n\r\n    # This is a departure from the normal Alpine naming\r\n    # scheme, which uses py2- and py3- prefixes\r\n    sudo apk add python2-dev  # for python2.x installs\r\n    sudo apk add python3-dev  # for python3.x installs\r\n\r\nFor `apt-cyg` (**Cygwin...**):\r\n\r\n    apt-cyg install python-devel   # for python2.x installs\r\n    apt-cyg install python3-devel  # for python3.x installs\r\n\r\n*Note:* python3-dev does not automatically cover all minor versions of python3, if you are using e.g. python 3.8 you may need to install python3.8-dev.\r\n",
        "body": "\n<p>Looks like you haven't properly installed the header files and static libraries for python dev.  Use your package manager to install them system-wide.<\/p>\n<p>For <code>apt<\/code> (<strong>Ubuntu, Debian...<\/strong>):<\/p>\n<pre class=\"lang-bash prettyprint-override\"><code>sudo apt-get install python-dev   # for python2.x installs\nsudo apt-get install python3-dev  # for python3.x installs\n<\/code><\/pre>\n<p>For <code>yum<\/code> (<strong>CentOS, RHEL...<\/strong>):<\/p>\n<pre class=\"lang-bash prettyprint-override\"><code>sudo yum install python-devel    # for python2.x installs\nsudo yum install python3-devel   # for python3.x installs\n<\/code><\/pre>\n<p>For <code>dnf<\/code> (<strong>Fedora...<\/strong>):<\/p>\n<pre class=\"lang-bash prettyprint-override\"><code>sudo dnf install python2-devel  # for python2.x installs\nsudo dnf install python3-devel  # for python3.x installs\n<\/code><\/pre>\n<p>For <code>zypper<\/code> (<strong>openSUSE...<\/strong>):<\/p>\n<pre class=\"lang-bash prettyprint-override\"><code>sudo zypper in python-devel   # for python2.x installs\nsudo zypper in python3-devel  # for python3.x installs\n<\/code><\/pre>\n<p>For <code>apk<\/code> (<strong>Alpine...<\/strong>):<\/p>\n<pre class=\"lang-bash prettyprint-override\"><code># This is a departure from the normal Alpine naming\n# scheme, which uses py2- and py3- prefixes\nsudo apk add python2-dev  # for python2.x installs\nsudo apk add python3-dev  # for python3.x installs\n<\/code><\/pre>\n<p>For <code>apt-cyg<\/code> (<strong>Cygwin...<\/strong>):<\/p>\n<pre class=\"lang-bash prettyprint-override\"><code>apt-cyg install python-devel   # for python2.x installs\napt-cyg install python3-devel  # for python3.x installs\n<\/code><\/pre>\n<p><em>Note:<\/em> python3-dev does not automatically cover all minor versions of python3, if you are using e.g. python 3.8 you may need to install python3.8-dev.<\/p>\n",
        "community_owned_date": null
    },
    {
        "owner": {
            "account_id": 3964,
            "reputation": 43787,
            "user_id": 5821,
            "user_type": "registered",
            "accept_rate": 50,
            "profile_image": "https:\/\/i.stack.imgur.com\/287n9.jpg?s=256&g=1",
            "display_name": "P\u0113teris Caune",
            "link": "https:\/\/stackoverflow.com\/users\/5821\/p%c4%93teris-caune"
        },
        "is_accepted": true,
        "score": 3395,
        "last_activity_date": 1627757914,
        "last_edit_date": 1627757914,
        "creation_date": 1227206799,
        "answer_id": 306417,
        "question_id": 306400,
        "content_license": "CC BY-SA 4.0",
        "body_markdown": "Use [`random.choice()`][1]:\r\n\r\n    import random\r\n\r\n    foo = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;]\r\n    print(random.choice(foo))\r\n\r\nFor [cryptographically secure][2] random choices (e.g., for generating a passphrase from a wordlist), use [`secrets.choice()`][4]:\r\n\r\n    import secrets\r\n\r\n    foo = [&#39;battery&#39;, &#39;correct&#39;, &#39;horse&#39;, &#39;staple&#39;]\r\n    print(secrets.choice(foo))\r\n\r\n`secrets` is new in Python 3.6. On older versions of Python you can use the [`random.SystemRandom`][3] class:\r\n\r\n    import random\r\n\r\n    secure_random = random.SystemRandom()\r\n    print(secure_random.choice(foo))\r\n\r\n  [1]: https:\/\/docs.python.org\/library\/random.html#random.choice\r\n  [2]: https:\/\/en.wikipedia.org\/wiki\/Cryptographically_secure_pseudorandom_number_generator\r\n  [3]: https:\/\/docs.python.org\/library\/random.html#random.SystemRandom\r\n  [4]: https:\/\/docs.python.org\/library\/secrets.html#secrets.choice\r\n\r\n\r\n\r\n",
        "body": "<p>Use <a href=\"https:\/\/docs.python.org\/library\/random.html#random.choice\" rel=\"noreferrer\"><code>random.choice()<\/code><\/a>:<\/p>\n<pre><code>import random\n\nfoo = ['a', 'b', 'c', 'd', 'e']\nprint(random.choice(foo))\n<\/code><\/pre>\n<p>For <a href=\"https:\/\/en.wikipedia.org\/wiki\/Cryptographically_secure_pseudorandom_number_generator\" rel=\"noreferrer\">cryptographically secure<\/a> random choices (e.g., for generating a passphrase from a wordlist), use <a href=\"https:\/\/docs.python.org\/library\/secrets.html#secrets.choice\" rel=\"noreferrer\"><code>secrets.choice()<\/code><\/a>:<\/p>\n<pre><code>import secrets\n\nfoo = ['battery', 'correct', 'horse', 'staple']\nprint(secrets.choice(foo))\n<\/code><\/pre>\n<p><code>secrets<\/code> is new in Python 3.6. On older versions of Python you can use the <a href=\"https:\/\/docs.python.org\/library\/random.html#random.SystemRandom\" rel=\"noreferrer\"><code>random.SystemRandom<\/code><\/a> class:<\/p>\n<pre><code>import random\n\nsecure_random = random.SystemRandom()\nprint(secure_random.choice(foo))\n<\/code><\/pre>\n",
        "community_owned_date": null
    },
    {
        "owner": {
            "account_id": 27387,
            "reputation": 95832,
            "user_id": 72247,
            "user_type": "registered",
            "profile_image": "https:\/\/www.gravatar.com\/avatar\/9a457b3df9be22c93d3c1ba990236d56?s=256&d=identicon&r=PG",
            "display_name": "Jarret Hardie",
            "link": "https:\/\/stackoverflow.com\/users\/72247\/jarret-hardie"
        },
        "is_accepted": true,
        "score": 3380,
        "last_activity_date": 1631006884,
        "last_edit_date": 1631006884,
        "creation_date": 1236178123,
        "answer_id": 610893,
        "question_id": 610883,
        "content_license": "CC BY-SA 4.0",
        "body_markdown": "Try [`hasattr()`][1]:\r\n\r\n    if hasattr(a, &#39;property&#39;):\r\n        a.property\r\n\r\nSee [zweiterlinde&#39;s answer][2] below, who offers good advice about asking forgiveness! A very pythonic approach! \r\n\r\nThe general practice in python is that, if the property is likely to be there most of the time, simply call it and either let the exception propagate, or trap it with a try\/except block. This will likely be faster than `hasattr`. If the property is likely to not be there most of the time, or you&#39;re not sure, using `hasattr` will probably be faster than repeatedly falling into an exception block.\r\n\r\n\r\n  [1]: https:\/\/docs.python.org\/3\/library\/functions.html#hasattr\r\n  [2]: https:\/\/stackoverflow.com\/a\/610923\/117030",
        "body": "<p>Try <a href=\"https:\/\/docs.python.org\/3\/library\/functions.html#hasattr\" rel=\"noreferrer\"><code>hasattr()<\/code><\/a>:<\/p>\n<pre><code>if hasattr(a, 'property'):\n    a.property\n<\/code><\/pre>\n<p>See <a href=\"https:\/\/stackoverflow.com\/a\/610923\/117030\">zweiterlinde's answer<\/a> below, who offers good advice about asking forgiveness! A very pythonic approach!<\/p>\n<p>The general practice in python is that, if the property is likely to be there most of the time, simply call it and either let the exception propagate, or trap it with a try\/except block. This will likely be faster than <code>hasattr<\/code>. If the property is likely to not be there most of the time, or you're not sure, using <code>hasattr<\/code> will probably be faster than repeatedly falling into an exception block.<\/p>\n",
        "community_owned_date": null
    },
    {
        "owner": {
            "account_id": 809,
            "reputation": 177514,
            "user_id": 1057,
            "user_type": "registered",
            "accept_rate": 80,
            "profile_image": "https:\/\/www.gravatar.com\/avatar\/e5778b659d144e38ed982c3f4e566089?s=256&d=identicon&r=PG",
            "display_name": "Harley Holcombe",
            "link": "https:\/\/stackoverflow.com\/users\/1057\/harley-holcombe"
        },
        "is_accepted": true,
        "score": 3352,
        "last_activity_date": 1655081262,
        "last_edit_date": 1655081262,
        "creation_date": 1228344124,
        "answer_id": 339013,
        "question_id": 339007,
        "content_license": "CC BY-SA 4.0",
        "body_markdown": "To pad strings:\r\n\r\n    &gt;&gt;&gt; n = &#39;4&#39;\r\n    &gt;&gt;&gt; print(n.zfill(3))\r\n    004\r\n\r\nTo pad numbers:\r\n\r\n    &gt;&gt;&gt; n = 4\r\n    &gt;&gt;&gt; print(f&#39;{n:03}&#39;) # Preferred method, python &gt;= 3.6\r\n    004\r\n    &gt;&gt;&gt; print(&#39;%03d&#39; % n)\r\n    004\r\n    &gt;&gt;&gt; print(format(n, &#39;03&#39;)) # python &gt;= 2.6\r\n    004\r\n    &gt;&gt;&gt; print(&#39;{0:03d}&#39;.format(n))  # python &gt;= 2.6 + python 3\r\n    004\r\n    &gt;&gt;&gt; print(&#39;{foo:03d}&#39;.format(foo=n))  # python &gt;= 2.6 + python 3\r\n    004\r\n    &gt;&gt;&gt; print(&#39;{:03d}&#39;.format(n))  # python &gt;= 2.7 + python3\r\n    004\r\n\r\n[String formatting documentation][1].\r\n\r\n\r\n[1]:https:\/\/docs.python.org\/3\/library\/string.html#format-string-syntax",
        "body": "<p>To pad strings:<\/p>\n<pre><code>&gt;&gt;&gt; n = '4'\n&gt;&gt;&gt; print(n.zfill(3))\n004\n<\/code><\/pre>\n<p>To pad numbers:<\/p>\n<pre><code>&gt;&gt;&gt; n = 4\n&gt;&gt;&gt; print(f'{n:03}') # Preferred method, python &gt;= 3.6\n004\n&gt;&gt;&gt; print('%03d' % n)\n004\n&gt;&gt;&gt; print(format(n, '03')) # python &gt;= 2.6\n004\n&gt;&gt;&gt; print('{0:03d}'.format(n))  # python &gt;= 2.6 + python 3\n004\n&gt;&gt;&gt; print('{foo:03d}'.format(foo=n))  # python &gt;= 2.6 + python 3\n004\n&gt;&gt;&gt; print('{:03d}'.format(n))  # python &gt;= 2.7 + python3\n004\n<\/code><\/pre>\n<p><a href=\"https:\/\/docs.python.org\/3\/library\/string.html#format-string-syntax\" rel=\"noreferrer\">String formatting documentation<\/a>.<\/p>\n",
        "community_owned_date": null
    },
    {
        "owner": {
            "account_id": 680,
            "reputation": 961801,
            "user_id": 893,
            "user_type": "registered",
            "accept_rate": 84,
            "profile_image": "https:\/\/www.gravatar.com\/avatar\/747ffa5da3538e66840ebc0548b8fd58?s=256&d=identicon&r=PG",
            "display_name": "Greg Hewgill",
            "link": "https:\/\/stackoverflow.com\/users\/893\/greg-hewgill"
        },
        "is_accepted": true,
        "score": 3312,
        "last_activity_date": 1579220055,
        "last_edit_date": 1579220055,
        "creation_date": 1301357335,
        "answer_id": 5466478,
        "question_id": 5466451,
        "content_license": "CC BY-SA 4.0",
        "body_markdown": "You need to double the `{{` and `}}`:\r\n\r\n    &gt;&gt;&gt; x = &quot; {{ Hello }} {0} &quot;\r\n    &gt;&gt;&gt; print(x.format(42))\r\n    &#39; { Hello } 42 &#39;\r\n\r\nHere&#39;s the relevant part of the [Python documentation for format string syntax](https:\/\/docs.python.org\/library\/string.html#formatstrings):\r\n\r\n&gt; Format strings contain \u201creplacement fields\u201d surrounded by curly braces `{}`. Anything that is not contained in braces is considered literal text, which is copied unchanged to the output. If you need to include a brace character in the literal text, it can be escaped by doubling: `{{` and `}}`.",
        "body": "<p>You need to double the <code>{{<\/code> and <code>}}<\/code>:<\/p>\n\n<pre><code>&gt;&gt;&gt; x = \" {{ Hello }} {0} \"\n&gt;&gt;&gt; print(x.format(42))\n' { Hello } 42 '\n<\/code><\/pre>\n\n<p>Here's the relevant part of the <a href=\"https:\/\/docs.python.org\/library\/string.html#formatstrings\" rel=\"noreferrer\">Python documentation for format string syntax<\/a>:<\/p>\n\n<blockquote>\n  <p>Format strings contain \u201creplacement fields\u201d surrounded by curly braces <code>{}<\/code>. Anything that is not contained in braces is considered literal text, which is copied unchanged to the output. If you need to include a brace character in the literal text, it can be escaped by doubling: <code>{{<\/code> and <code>}}<\/code>.<\/p>\n<\/blockquote>\n",
        "community_owned_date": null
    },
    {
        "owner": {
            "account_id": 18791,
            "reputation": 72112,
            "user_id": 43427,
            "user_type": "registered",
            "profile_image": "https:\/\/www.gravatar.com\/avatar\/403cdea06d09870a185e495f2194bbcd?s=256&d=identicon&r=PG",
            "display_name": "codelogic",
            "link": "https:\/\/stackoverflow.com\/users\/43427\/codelogic"
        },
        "is_accepted": true,
        "score": 3269,
        "last_activity_date": 1577914970,
        "last_edit_date": 1577914970,
        "creation_date": 1233262903,
        "answer_id": 493399,
        "question_id": 493386,
        "content_license": "CC BY-SA 4.0",
        "body_markdown": "In Python 3, you can use the `sep=` and `end=` parameters of the [`print`][1] function:\r\n\r\nTo not add a newline to the end of the string:\r\n\r\n    print(&#39;.&#39;, end=&#39;&#39;)\r\n\r\nTo not add a space between all the function arguments you want to print:\r\n\r\n    print(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, sep=&#39;&#39;)\r\n\r\nYou can pass any string to either parameter, and you can use both parameters at the same time.\r\n\r\nIf you are having trouble with buffering, you can flush the output by adding `flush=True` keyword argument:\r\n\r\n    print(&#39;.&#39;, end=&#39;&#39;, flush=True)\r\n\r\nPython 2.6 and 2.7\r\n---------\r\nFrom Python 2.6 you can either import the `print` function from Python 3 using the [`__future__` module][2]:\r\n\r\n    from __future__ import print_function\r\n\r\nwhich allows you to use the Python 3 solution above.\r\n\r\nHowever, note that the `flush` keyword is not available in the version of the `print` function imported from `__future__` in Python 2; it only works in Python 3, more specifically 3.3 and later. In earlier versions you&#39;ll still need to flush manually with a call to `sys.stdout.flush()`. You&#39;ll also have to rewrite all other print statements in the file where you do this import.\r\n\r\nOr you can use [`sys.stdout.write()`][3]\r\n\r\n    import sys\r\n    sys.stdout.write(&#39;.&#39;)\r\n\r\nYou may also need to call\r\n\r\n    sys.stdout.flush()\r\n\r\nto ensure `stdout` is flushed immediately.\r\n\r\n\r\n  [1]: https:\/\/docs.python.org\/library\/functions.html#print\r\n  [2]: https:\/\/docs.python.org\/2\/library\/__future__.html\r\n  [3]: https:\/\/docs.python.org\/library\/sys.html#sys.stdout",
        "body": "<p>In Python 3, you can use the <code>sep=<\/code> and <code>end=<\/code> parameters of the <a href=\"https:\/\/docs.python.org\/library\/functions.html#print\" rel=\"noreferrer\"><code>print<\/code><\/a> function:<\/p>\n\n<p>To not add a newline to the end of the string:<\/p>\n\n<pre><code>print('.', end='')\n<\/code><\/pre>\n\n<p>To not add a space between all the function arguments you want to print:<\/p>\n\n<pre><code>print('a', 'b', 'c', sep='')\n<\/code><\/pre>\n\n<p>You can pass any string to either parameter, and you can use both parameters at the same time.<\/p>\n\n<p>If you are having trouble with buffering, you can flush the output by adding <code>flush=True<\/code> keyword argument:<\/p>\n\n<pre><code>print('.', end='', flush=True)\n<\/code><\/pre>\n\n<h2>Python 2.6 and 2.7<\/h2>\n\n<p>From Python 2.6 you can either import the <code>print<\/code> function from Python 3 using the <a href=\"https:\/\/docs.python.org\/2\/library\/__future__.html\" rel=\"noreferrer\"><code>__future__<\/code> module<\/a>:<\/p>\n\n<pre><code>from __future__ import print_function\n<\/code><\/pre>\n\n<p>which allows you to use the Python 3 solution above.<\/p>\n\n<p>However, note that the <code>flush<\/code> keyword is not available in the version of the <code>print<\/code> function imported from <code>__future__<\/code> in Python 2; it only works in Python 3, more specifically 3.3 and later. In earlier versions you'll still need to flush manually with a call to <code>sys.stdout.flush()<\/code>. You'll also have to rewrite all other print statements in the file where you do this import.<\/p>\n\n<p>Or you can use <a href=\"https:\/\/docs.python.org\/library\/sys.html#sys.stdout\" rel=\"noreferrer\"><code>sys.stdout.write()<\/code><\/a><\/p>\n\n<pre><code>import sys\nsys.stdout.write('.')\n<\/code><\/pre>\n\n<p>You may also need to call<\/p>\n\n<pre><code>sys.stdout.flush()\n<\/code><\/pre>\n\n<p>to ensure <code>stdout<\/code> is flushed immediately.<\/p>\n",
        "community_owned_date": null
    },
    {
        "owner": {
            "account_id": 555,
            "reputation": 56956,
            "user_id": 720,
            "user_type": "registered",
            "accept_rate": 67,
            "profile_image": "https:\/\/www.gravatar.com\/avatar\/3c57f2a468f2fc945f1e5c47d1afee66?s=256&d=identicon&r=PG",
            "display_name": "Peter Hoffmann",
            "link": "https:\/\/stackoverflow.com\/users\/720\/peter-hoffmann"
        },
        "is_accepted": true,
        "score": 3192,
        "last_activity_date": 1690825657,
        "last_edit_date": 1690825657,
        "creation_date": 1220195851,
        "answer_id": 36908,
        "question_id": 36901,
        "content_license": "CC BY-SA 4.0",
        "body_markdown": "The `*args` and `**kwargs` are common idioms to allow an arbitrary number of arguments to functions, as described in the section [more on defining functions][1] in the Python tutorial.\r\n\r\nThe `*args` will give you all positional arguments [as a tuple][2]:\r\n\r\n    def foo(*args):\r\n        for a in args:\r\n            print(a)        \r\n    \r\n    foo(1)\r\n    # 1\r\n    \r\n    foo(1, 2, 3)\r\n    # 1\r\n    # 2\r\n    # 3\r\n\r\nThe `**kwargs` will give you all \r\nkeyword arguments as a dictionary:\r\n\r\n    def bar(**kwargs):\r\n        for a in kwargs:\r\n            print(a, kwargs[a])  \r\n    \r\n    bar(name=&#39;one&#39;, age=27)\r\n    # name one\r\n    # age 27\r\n\r\nBoth idioms can be mixed with normal arguments to allow a set of fixed and some variable arguments:\r\n\r\n    def foo(kind, *args, bar=None, **kwargs):\r\n        print(kind, args, bar, kwargs)\r\n\r\n    foo(123, &#39;a&#39;, &#39;b&#39;, apple=&#39;red&#39;)\r\n    # 123 (&#39;a&#39;, &#39;b&#39;) None {&#39;apple&#39;: &#39;red&#39;}\r\n\r\nIt is also possible to use this the other way around:\r\n\r\n    def foo(a, b, c):\r\n        print(a, b, c)\r\n\r\n    obj = {&#39;b&#39;:10, &#39;c&#39;:&#39;lee&#39;}\r\n    \r\n    foo(100, **obj)\r\n    # 100 10 lee\r\n\r\nAnother usage of the `*l` idiom is to **unpack argument lists** when calling a function.\r\n\r\n    def foo(bar, lee):\r\n        print(bar, lee)\r\n\r\n    baz = [1, 2]\r\n    \r\n    foo(*baz)\r\n    # 1 2\r\n\r\nIn Python 3 it is possible to use `*l` on the left side of an assignment ([Extended Iterable Unpacking][3]), though it gives a list instead of a tuple in this context:\r\n\r\n    first, *rest = [1, 2, 3, 4]\r\n    # first = 1\r\n    # rest = [2, 3, 4]\r\n\r\nAlso Python 3 adds a new semantic (refer [PEP 3102](https:\/\/www.python.org\/dev\/peps\/pep-3102\/)):\r\n\r\n    def func(arg1, arg2, arg3, *, kwarg1, kwarg2):\r\n        pass\r\n\r\nSuch function accepts only 3 positional arguments, and everything after `*` can only be passed as keyword arguments.\r\n\r\n### Note:\r\n\r\nA Python `dict`, semantically used for keyword argument passing, is arbitrarily ordered. However, in Python 3.6+, keyword arguments are guaranteed to remember insertion order.\r\n&quot;The order of elements in `**kwargs` now corresponds to the order in which keyword arguments were passed to the function.&quot; - [What\u2019s New In Python 3.6][4].\r\nIn fact, all dicts in CPython 3.6 will remember insertion order as an implementation detail, and this becomes standard in Python 3.7. \r\n\r\n\r\n  [1]: http:\/\/docs.python.org\/3\/tutorial\/controlflow.html#more-on-defining-functions\r\n  [2]: https:\/\/docs.python.org\/3\/tutorial\/controlflow.html#arbitrary-argument-lists\r\n  [3]: http:\/\/www.python.org\/dev\/peps\/pep-3132\/\r\n  [4]: https:\/\/docs.python.org\/3\/whatsnew\/3.6.html",
        "body": "<p>The <code>*args<\/code> and <code>**kwargs<\/code> are common idioms to allow an arbitrary number of arguments to functions, as described in the section <a href=\"http:\/\/docs.python.org\/3\/tutorial\/controlflow.html#more-on-defining-functions\" rel=\"noreferrer\">more on defining functions<\/a> in the Python tutorial.<\/p>\n<p>The <code>*args<\/code> will give you all positional arguments <a href=\"https:\/\/docs.python.org\/3\/tutorial\/controlflow.html#arbitrary-argument-lists\" rel=\"noreferrer\">as a tuple<\/a>:<\/p>\n<pre><code>def foo(*args):\n    for a in args:\n        print(a)        \n\nfoo(1)\n# 1\n\nfoo(1, 2, 3)\n# 1\n# 2\n# 3\n<\/code><\/pre>\n<p>The <code>**kwargs<\/code> will give you all\nkeyword arguments as a dictionary:<\/p>\n<pre><code>def bar(**kwargs):\n    for a in kwargs:\n        print(a, kwargs[a])  \n\nbar(name='one', age=27)\n# name one\n# age 27\n<\/code><\/pre>\n<p>Both idioms can be mixed with normal arguments to allow a set of fixed and some variable arguments:<\/p>\n<pre><code>def foo(kind, *args, bar=None, **kwargs):\n    print(kind, args, bar, kwargs)\n\nfoo(123, 'a', 'b', apple='red')\n# 123 ('a', 'b') None {'apple': 'red'}\n<\/code><\/pre>\n<p>It is also possible to use this the other way around:<\/p>\n<pre><code>def foo(a, b, c):\n    print(a, b, c)\n\nobj = {'b':10, 'c':'lee'}\n\nfoo(100, **obj)\n# 100 10 lee\n<\/code><\/pre>\n<p>Another usage of the <code>*l<\/code> idiom is to <strong>unpack argument lists<\/strong> when calling a function.<\/p>\n<pre><code>def foo(bar, lee):\n    print(bar, lee)\n\nbaz = [1, 2]\n\nfoo(*baz)\n# 1 2\n<\/code><\/pre>\n<p>In Python 3 it is possible to use <code>*l<\/code> on the left side of an assignment (<a href=\"http:\/\/www.python.org\/dev\/peps\/pep-3132\/\" rel=\"noreferrer\">Extended Iterable Unpacking<\/a>), though it gives a list instead of a tuple in this context:<\/p>\n<pre><code>first, *rest = [1, 2, 3, 4]\n# first = 1\n# rest = [2, 3, 4]\n<\/code><\/pre>\n<p>Also Python 3 adds a new semantic (refer <a href=\"https:\/\/www.python.org\/dev\/peps\/pep-3102\/\" rel=\"noreferrer\">PEP 3102<\/a>):<\/p>\n<pre><code>def func(arg1, arg2, arg3, *, kwarg1, kwarg2):\n    pass\n<\/code><\/pre>\n<p>Such function accepts only 3 positional arguments, and everything after <code>*<\/code> can only be passed as keyword arguments.<\/p>\n<h3>Note:<\/h3>\n<p>A Python <code>dict<\/code>, semantically used for keyword argument passing, is arbitrarily ordered. However, in Python 3.6+, keyword arguments are guaranteed to remember insertion order.\n&quot;The order of elements in <code>**kwargs<\/code> now corresponds to the order in which keyword arguments were passed to the function.&quot; - <a href=\"https:\/\/docs.python.org\/3\/whatsnew\/3.6.html\" rel=\"noreferrer\">What\u2019s New In Python 3.6<\/a>.\nIn fact, all dicts in CPython 3.6 will remember insertion order as an implementation detail, and this becomes standard in Python 3.7.<\/p>\n",
        "community_owned_date": null
    },
    {
        "owner": {
            "account_id": 354053,
            "reputation": 139393,
            "user_id": 1209279,
            "user_type": "registered",
            "accept_rate": 91,
            "profile_image": "https:\/\/www.gravatar.com\/avatar\/516b0a47cdf1739c51ff9dee89f0d459?s=256&d=identicon&r=PG",
            "display_name": "Levon",
            "link": "https:\/\/stackoverflow.com\/users\/1209279\/levon"
        },
        "is_accepted": true,
        "score": 3151,
        "last_activity_date": 1485867284,
        "last_edit_date": 1485867284,
        "creation_date": 1337379774,
        "answer_id": 10660443,
        "question_id": 10660435,
        "content_license": "CC BY-SA 3.0",
        "body_markdown": "Are you talking about multi-line strings? Easy, use triple quotes to start and end them.\r\n\r\n    s = &quot;&quot;&quot; this is a very\r\n            long string if I had the\r\n            energy to type more and more ...&quot;&quot;&quot;\r\n\r\nYou can use single quotes too (3 of them of course at start and end) and treat the resulting string `s` just like any other string.\r\n\r\n**NOTE**: Just as with any string, anything between the starting and ending quotes becomes part of the string, so this example has a leading blank (as pointed out by @root45). This string will also contain both blanks and newlines.\r\n\r\nI.e.,:\r\n\r\n    &#39; this is a very\\n        long string if I had the\\n        energy to type more and more ...&#39;\r\n\r\nFinally, one can also construct long lines in Python like this:\r\n\r\n     s = (&quot;this is a very&quot;\r\n          &quot;long string too&quot;\r\n          &quot;for sure ...&quot;\r\n         )\r\n\r\nwhich will **not** include any extra blanks or newlines (this is a deliberate example showing what the effect of skipping blanks will result in):\r\n\r\n    &#39;this is a verylong string toofor sure ...&#39;\r\n\r\nNo commas required, simply place the strings to be joined together into a pair of parenthesis and be sure to account for any needed blanks and newlines.",
        "body": "<p>Are you talking about multi-line strings? Easy, use triple quotes to start and end them.<\/p>\n\n<pre><code>s = \"\"\" this is a very\n        long string if I had the\n        energy to type more and more ...\"\"\"\n<\/code><\/pre>\n\n<p>You can use single quotes too (3 of them of course at start and end) and treat the resulting string <code>s<\/code> just like any other string.<\/p>\n\n<p><strong>NOTE<\/strong>: Just as with any string, anything between the starting and ending quotes becomes part of the string, so this example has a leading blank (as pointed out by @root45). This string will also contain both blanks and newlines.<\/p>\n\n<p>I.e.,:<\/p>\n\n<pre><code>' this is a very\\n        long string if I had the\\n        energy to type more and more ...'\n<\/code><\/pre>\n\n<p>Finally, one can also construct long lines in Python like this:<\/p>\n\n<pre><code> s = (\"this is a very\"\n      \"long string too\"\n      \"for sure ...\"\n     )\n<\/code><\/pre>\n\n<p>which will <strong>not<\/strong> include any extra blanks or newlines (this is a deliberate example showing what the effect of skipping blanks will result in):<\/p>\n\n<pre><code>'this is a verylong string toofor sure ...'\n<\/code><\/pre>\n\n<p>No commas required, simply place the strings to be joined together into a pair of parenthesis and be sure to account for any needed blanks and newlines.<\/p>\n",
        "community_owned_date": null
    },
    {
        "owner": {
            "account_id": 8983,
            "reputation": 482873,
            "user_id": 16417,
            "user_type": "registered",
            "accept_rate": 93,
            "profile_image": "https:\/\/i.stack.imgur.com\/wHrac.jpg?s=256&g=1",
            "display_name": "Paolo Bergantino",
            "link": "https:\/\/stackoverflow.com\/users\/16417\/paolo-bergantino"
        },
        "is_accepted": true,
        "score": 3088,
        "last_activity_date": 1614176498,
        "last_edit_date": 1614176498,
        "creation_date": 1239434178,
        "answer_id": 739665,
        "question_id": 739654,
        "content_license": "CC BY-SA 4.0",
        "body_markdown": "Check out [the documentation](http:\/\/docs.python.org\/reference\/compound_stmts.html#function) to see how decorators work. Here is what you asked for:\r\n\r\n    from functools import wraps\r\n\r\n    def makebold(fn):\r\n        @wraps(fn)\r\n        def wrapper(*args, **kwargs):\r\n            return &quot;&lt;b&gt;&quot; + fn(*args, **kwargs) + &quot;&lt;\/b&gt;&quot;\r\n        return wrapper\r\n\r\n    def makeitalic(fn):\r\n        @wraps(fn)\r\n        def wrapper(*args, **kwargs):\r\n            return &quot;&lt;i&gt;&quot; + fn(*args, **kwargs) + &quot;&lt;\/i&gt;&quot;\r\n        return wrapper\r\n\r\n    @makebold\r\n    @makeitalic\r\n    def hello():\r\n        return &quot;hello world&quot;\r\n\r\n    @makebold\r\n    @makeitalic\r\n    def log(s):\r\n        return s\r\n\r\n    print hello()        # returns &quot;&lt;b&gt;&lt;i&gt;hello world&lt;\/i&gt;&lt;\/b&gt;&quot;\r\n    print hello.__name__ # with functools.wraps() this returns &quot;hello&quot;\r\n    print log(&#39;hello&#39;)   # returns &quot;&lt;b&gt;&lt;i&gt;hello&lt;\/i&gt;&lt;\/b&gt;&quot;",
        "body": "<p>Check out <a href=\"http:\/\/docs.python.org\/reference\/compound_stmts.html#function\" rel=\"noreferrer\">the documentation<\/a> to see how decorators work. Here is what you asked for:<\/p>\n<pre><code>from functools import wraps\n\ndef makebold(fn):\n    @wraps(fn)\n    def wrapper(*args, **kwargs):\n        return &quot;&lt;b&gt;&quot; + fn(*args, **kwargs) + &quot;&lt;\/b&gt;&quot;\n    return wrapper\n\ndef makeitalic(fn):\n    @wraps(fn)\n    def wrapper(*args, **kwargs):\n        return &quot;&lt;i&gt;&quot; + fn(*args, **kwargs) + &quot;&lt;\/i&gt;&quot;\n    return wrapper\n\n@makebold\n@makeitalic\ndef hello():\n    return &quot;hello world&quot;\n\n@makebold\n@makeitalic\ndef log(s):\n    return s\n\nprint hello()        # returns &quot;&lt;b&gt;&lt;i&gt;hello world&lt;\/i&gt;&lt;\/b&gt;&quot;\nprint hello.__name__ # with functools.wraps() this returns &quot;hello&quot;\nprint log('hello')   # returns &quot;&lt;b&gt;&lt;i&gt;hello&lt;\/i&gt;&lt;\/b&gt;&quot;\n<\/code><\/pre>\n",
        "community_owned_date": null
    },
    {
        "owner": {
            "account_id": 809,
            "reputation": 177514,
            "user_id": 1057,
            "user_type": "registered",
            "accept_rate": 80,
            "profile_image": "https:\/\/www.gravatar.com\/avatar\/e5778b659d144e38ed982c3f4e566089?s=256&d=identicon&r=PG",
            "display_name": "Harley Holcombe",
            "link": "https:\/\/stackoverflow.com\/users\/1057\/harley-holcombe"
        },
        "is_accepted": true,
        "score": 3062,
        "last_activity_date": 1580917109,
        "last_edit_date": 1580917109,
        "creation_date": 1229651691,
        "answer_id": 379910,
        "question_id": 379906,
        "content_license": "CC BY-SA 4.0",
        "body_markdown": "    &gt;&gt;&gt; a = &quot;545.2222&quot;\r\n    &gt;&gt;&gt; float(a)\r\n    545.22220000000004\r\n    &gt;&gt;&gt; int(float(a))\r\n    545",
        "body": "<pre><code>&gt;&gt;&gt; a = \"545.2222\"\n&gt;&gt;&gt; float(a)\n545.22220000000004\n&gt;&gt;&gt; int(float(a))\n545\n<\/code><\/pre>\n",
        "community_owned_date": null
    },
    {
        "owner": {
            "account_id": 40137,
            "reputation": 37541,
            "user_id": 116186,
            "user_type": "registered",
            "accept_rate": 77,
            "profile_image": "https:\/\/www.gravatar.com\/avatar\/dc5f7c3937e6844cb776d2004b903578?s=256&d=identicon&r=PG",
            "display_name": "Petter",
            "link": "https:\/\/stackoverflow.com\/users\/116186\/petter"
        },
        "is_accepted": true,
        "score": 3061,
        "last_activity_date": 1655224853,
        "last_edit_date": 1655224853,
        "creation_date": 1295195045,
        "answer_id": 4706520,
        "question_id": 4706499,
        "content_license": "CC BY-SA 4.0",
        "body_markdown": "Set the mode in [`open()`][open] to `&quot;a&quot;` (append) instead of `&quot;w&quot;` (write):\r\n\r\n```python\r\nwith open(&quot;test.txt&quot;, &quot;a&quot;) as myfile:\r\n    myfile.write(&quot;appended text&quot;)\r\n```\r\n\r\nThe [documentation][open] lists all the available modes.\r\n\r\n[open]: https:\/\/docs.python.org\/3\/library\/functions.html#open",
        "body": "<p>Set the mode in <a href=\"https:\/\/docs.python.org\/3\/library\/functions.html#open\" rel=\"noreferrer\"><code>open()<\/code><\/a> to <code>&quot;a&quot;<\/code> (append) instead of <code>&quot;w&quot;<\/code> (write):<\/p>\n<pre class=\"lang-py prettyprint-override\"><code>with open(&quot;test.txt&quot;, &quot;a&quot;) as myfile:\n    myfile.write(&quot;appended text&quot;)\n<\/code><\/pre>\n<p>The <a href=\"https:\/\/docs.python.org\/3\/library\/functions.html#open\" rel=\"noreferrer\">documentation<\/a> lists all the available modes.<\/p>\n",
        "community_owned_date": null
    },
    {
        "owner": {
            "account_id": 35417,
            "reputation": 1067779,
            "user_id": 100297,
            "user_type": "moderator",
            "profile_image": "https:\/\/www.gravatar.com\/avatar\/24780fb6df85a943c7aea0402c843737?s=256&d=identicon&r=PG",
            "display_name": "Martijn Pieters",
            "link": "https:\/\/stackoverflow.com\/users\/100297\/martijn-pieters"
        },
        "is_accepted": true,
        "score": 3060,
        "last_activity_date": 1621178804,
        "last_edit_date": 1621178804,
        "creation_date": 1430926438,
        "answer_id": 30081318,
        "question_id": 30081275,
        "content_license": "CC BY-SA 4.0",
        "body_markdown": "The Python 3 `range()` object doesn&#39;t produce numbers immediately; it is a smart [sequence object](https:\/\/docs.python.org\/3\/library\/collections.abc.html#collections.abc.Sequence) that produces numbers *on demand*. All it contains is your start, stop and step values, then as you iterate over the object the next integer is calculated each iteration.\r\n\r\nThe object also implements the [`object.__contains__` hook](https:\/\/docs.python.org\/3\/reference\/datamodel.html#object.__contains__), and *calculates* if your number is part of its range. Calculating is a (near) constant time operation &lt;sup&gt;*&lt;\/sup&gt;. There is never a need to scan through all possible integers in the range.\r\n\r\nFrom the [`range()` object documentation](https:\/\/docs.python.org\/3\/library\/stdtypes.html#range):\r\n\r\n&gt; The advantage of the `range` type over a regular `list` or `tuple` is that a range object will always take the same (small) amount of memory, no matter the size of the range it represents (as it only stores the `start`, `stop` and `step` values, calculating individual items and subranges as needed).\r\n\r\nSo at a minimum, your `range()` object would do:\r\n\r\n    class my_range:\r\n        def __init__(self, start, stop=None, step=1, \/):\r\n            if stop is None:\r\n                start, stop = 0, start\r\n            self.start, self.stop, self.step = start, stop, step\r\n            if step &lt; 0:\r\n                lo, hi, step = stop, start, -step\r\n            else:\r\n                lo, hi = start, stop\r\n            self.length = 0 if lo &gt; hi else ((hi - lo - 1) \/\/ step) + 1\r\n\r\n        def __iter__(self):\r\n            current = self.start\r\n            if self.step &lt; 0:\r\n                while current &gt; self.stop:\r\n                    yield current\r\n                    current += self.step\r\n            else:\r\n                while current &lt; self.stop:\r\n                    yield current\r\n                    current += self.step\r\n\r\n        def __len__(self):\r\n            return self.length\r\n\r\n        def __getitem__(self, i):\r\n            if i &lt; 0:\r\n                i += self.length\r\n            if 0 &lt;= i &lt; self.length:\r\n                return self.start + i * self.step\r\n            raise IndexError(&#39;my_range object index out of range&#39;)\r\n\r\n        def __contains__(self, num):\r\n            if self.step &lt; 0:\r\n                if not (self.stop &lt; num &lt;= self.start):\r\n                    return False\r\n            else:\r\n                if not (self.start &lt;= num &lt; self.stop):\r\n                    return False\r\n            return (num - self.start) % self.step == 0\r\n\r\nThis is still missing several things that a real `range()` supports (such as the `.index()` or `.count()` methods, hashing, equality testing, or slicing), but should give you an idea.\r\n\r\nI also simplified the `__contains__` implementation to only focus on integer tests; if you give a real `range()` object a non-integer value (including subclasses of `int`), a slow scan is initiated to see if there is a match, just as if you use a containment test against a list of all the contained values. This was done to continue to support other numeric types that just happen to support equality testing with integers but are not expected to support integer arithmetic as well. See the original [Python issue](http:\/\/bugs.python.org\/issue1766304) that implemented the containment test.\r\n\r\n---\r\n\r\n&lt;sup&gt;*&lt;sup&gt; *Near* constant time because Python integers are unbounded and so math operations also grow in time as N grows, making this a O(log N) operation. Since it\u2019s all executed in optimised C code and Python stores integer values in 30-bit chunks, you\u2019d run out of memory before you saw any performance impact due to the size of the integers involved here.",
        "body": "<p>The Python 3 <code>range()<\/code> object doesn't produce numbers immediately; it is a smart <a href=\"https:\/\/docs.python.org\/3\/library\/collections.abc.html#collections.abc.Sequence\" rel=\"noreferrer\">sequence object<\/a> that produces numbers <em>on demand<\/em>. All it contains is your start, stop and step values, then as you iterate over the object the next integer is calculated each iteration.<\/p>\n<p>The object also implements the <a href=\"https:\/\/docs.python.org\/3\/reference\/datamodel.html#object.__contains__\" rel=\"noreferrer\"><code>object.__contains__<\/code> hook<\/a>, and <em>calculates<\/em> if your number is part of its range. Calculating is a (near) constant time operation <sup>*<\/sup>. There is never a need to scan through all possible integers in the range.<\/p>\n<p>From the <a href=\"https:\/\/docs.python.org\/3\/library\/stdtypes.html#range\" rel=\"noreferrer\"><code>range()<\/code> object documentation<\/a>:<\/p>\n<blockquote>\n<p>The advantage of the <code>range<\/code> type over a regular <code>list<\/code> or <code>tuple<\/code> is that a range object will always take the same (small) amount of memory, no matter the size of the range it represents (as it only stores the <code>start<\/code>, <code>stop<\/code> and <code>step<\/code> values, calculating individual items and subranges as needed).<\/p>\n<\/blockquote>\n<p>So at a minimum, your <code>range()<\/code> object would do:<\/p>\n<pre><code>class my_range:\n    def __init__(self, start, stop=None, step=1, \/):\n        if stop is None:\n            start, stop = 0, start\n        self.start, self.stop, self.step = start, stop, step\n        if step &lt; 0:\n            lo, hi, step = stop, start, -step\n        else:\n            lo, hi = start, stop\n        self.length = 0 if lo &gt; hi else ((hi - lo - 1) \/\/ step) + 1\n\n    def __iter__(self):\n        current = self.start\n        if self.step &lt; 0:\n            while current &gt; self.stop:\n                yield current\n                current += self.step\n        else:\n            while current &lt; self.stop:\n                yield current\n                current += self.step\n\n    def __len__(self):\n        return self.length\n\n    def __getitem__(self, i):\n        if i &lt; 0:\n            i += self.length\n        if 0 &lt;= i &lt; self.length:\n            return self.start + i * self.step\n        raise IndexError('my_range object index out of range')\n\n    def __contains__(self, num):\n        if self.step &lt; 0:\n            if not (self.stop &lt; num &lt;= self.start):\n                return False\n        else:\n            if not (self.start &lt;= num &lt; self.stop):\n                return False\n        return (num - self.start) % self.step == 0\n<\/code><\/pre>\n<p>This is still missing several things that a real <code>range()<\/code> supports (such as the <code>.index()<\/code> or <code>.count()<\/code> methods, hashing, equality testing, or slicing), but should give you an idea.<\/p>\n<p>I also simplified the <code>__contains__<\/code> implementation to only focus on integer tests; if you give a real <code>range()<\/code> object a non-integer value (including subclasses of <code>int<\/code>), a slow scan is initiated to see if there is a match, just as if you use a containment test against a list of all the contained values. This was done to continue to support other numeric types that just happen to support equality testing with integers but are not expected to support integer arithmetic as well. See the original <a href=\"http:\/\/bugs.python.org\/issue1766304\" rel=\"noreferrer\">Python issue<\/a> that implemented the containment test.<\/p>\n<hr \/>\n<p>* <em>Near<\/em> constant time because Python integers are unbounded and so math operations also grow in time as N grows, making this a O(log N) operation. Since it\u2019s all executed in optimised C code and Python stores integer values in 30-bit chunks, you\u2019d run out of memory before you saw any performance impact due to the size of the integers involved here.<\/p>\n",
        "community_owned_date": null
    },
    {
        "owner": {
            "account_id": 237172,
            "reputation": 203927,
            "user_id": 505154,
            "user_type": "registered",
            "accept_rate": 100,
            "profile_image": "https:\/\/www.gravatar.com\/avatar\/2e8b69989251cfc746626b802f610a2c?s=256&d=identicon&r=PG",
            "display_name": "Andrew Clark",
            "link": "https:\/\/stackoverflow.com\/users\/505154\/andrew-clark"
        },
        "is_accepted": true,
        "score": 3026,
        "last_activity_date": 1654492741,
        "last_edit_date": 1654492741,
        "creation_date": 1330978221,
        "answer_id": 9573259,
        "question_id": 9573244,
        "content_license": "CC BY-SA 4.0",
        "body_markdown": "Empty strings are &quot;falsy&quot; ([python 2][1] or [python 3][2] reference), which means they are considered false in a Boolean context, so you can just do this:\r\n\r\n    if not myString:\r\n\r\nThis is the preferred way if you know that your variable is a string.  If your variable could also be some other type then you should use:\r\n\r\n    if myString == &quot;&quot;:\r\n\r\n See the documentation on [Truth Value Testing][3] for other values that are false in Boolean contexts.\r\n\r\n\r\n  [1]: http:\/\/docs.python.org\/2\/library\/stdtypes.html#truth-value-testing\r\n  [2]: https:\/\/docs.python.org\/3\/library\/stdtypes.html#truth-value-testing\r\n  [3]: http:\/\/docs.python.org\/library\/stdtypes.html#truth-value-testing",
        "body": "<p>Empty strings are &quot;falsy&quot; (<a href=\"http:\/\/docs.python.org\/2\/library\/stdtypes.html#truth-value-testing\" rel=\"noreferrer\">python 2<\/a> or <a href=\"https:\/\/docs.python.org\/3\/library\/stdtypes.html#truth-value-testing\" rel=\"noreferrer\">python 3<\/a> reference), which means they are considered false in a Boolean context, so you can just do this:<\/p>\n<pre><code>if not myString:\n<\/code><\/pre>\n<p>This is the preferred way if you know that your variable is a string.  If your variable could also be some other type then you should use:<\/p>\n<pre><code>if myString == &quot;&quot;:\n<\/code><\/pre>\n<p>See the documentation on <a href=\"http:\/\/docs.python.org\/library\/stdtypes.html#truth-value-testing\" rel=\"noreferrer\">Truth Value Testing<\/a> for other values that are false in Boolean contexts.<\/p>\n",
        "community_owned_date": null
    },
    {
        "owner": {
            "account_id": 415066,
            "reputation": 39754,
            "user_id": 789649,
            "user_type": "registered",
            "profile_image": "https:\/\/www.gravatar.com\/avatar\/3aba5dec1e9c2b2b65adc491a0bc6253?s=256&d=identicon&r=PG",
            "display_name": "Rostyslav Dzinko",
            "link": "https:\/\/stackoverflow.com\/users\/789649\/rostyslav-dzinko"
        },
        "is_accepted": true,
        "score": 2946,
        "last_activity_date": 1660862073,
        "last_edit_date": 1660862073,
        "creation_date": 1346248983,
        "answer_id": 12179752,
        "question_id": 12179271,
        "content_license": "CC BY-SA 4.0",
        "body_markdown": "Though `classmethod` and `staticmethod` are quite similar, there&#39;s a slight difference in usage for both entities: `classmethod` must have a reference to a class object as the first parameter, whereas `staticmethod` can have no parameters at all.\r\n\r\n## Example\r\n\r\n    class Date(object):\r\n        \r\n        def __init__(self, day=0, month=0, year=0):\r\n            self.day = day\r\n            self.month = month\r\n            self.year = year\r\n\r\n        @classmethod\r\n        def from_string(cls, date_as_string):\r\n            day, month, year = map(int, date_as_string.split(&#39;-&#39;))\r\n            date1 = cls(day, month, year)\r\n            return date1\r\n\r\n        @staticmethod\r\n        def is_date_valid(date_as_string):\r\n            day, month, year = map(int, date_as_string.split(&#39;-&#39;))\r\n            return day &lt;= 31 and month &lt;= 12 and year &lt;= 3999\r\n    \r\n    date2 = Date.from_string(&#39;11-09-2012&#39;)\r\n    is_date = Date.is_date_valid(&#39;11-09-2012&#39;)\r\n\r\n## Explanation\r\n\r\nLet&#39;s assume an example of a class, dealing with date information (this will be our boilerplate):\r\n\r\n    class Date(object):\r\n        \r\n        def __init__(self, day=0, month=0, year=0):\r\n            self.day = day\r\n            self.month = month\r\n            self.year = year\r\n\r\nThis class obviously could be used to store information about certain dates (without timezone information; let&#39;s assume all dates are presented in UTC).\r\n\r\nHere we have `__init__`, a typical initializer of Python class instances, which receives arguments as a typical instance method, having the first non-optional argument (`self`) that holds a reference to a newly created instance.\r\n\r\n**Class Method**\r\n\r\nWe have some tasks that can be nicely done using `classmethod`s.\r\n\r\n*Let&#39;s assume that we want to create a lot of `Date` class instances having date information coming from an outer source encoded as a string with format &#39;dd-mm-yyyy&#39;. Suppose we have to do this in different places in the source code of our project.*\r\n\r\nSo what we must do here is:\r\n  \r\n  1. Parse a string to receive day, month and year as three integer variables or a 3-item tuple consisting of that variable.\r\n  2. Instantiate `Date` by passing those values to the initialization call.\r\n\r\nThis will look like:\r\n\r\n    day, month, year = map(int, string_date.split(&#39;-&#39;))\r\n    date1 = Date(day, month, year)\r\n\r\nFor this purpose, C++ can implement such a feature with overloading, but Python lacks this overloading. Instead, we can use `classmethod`. Let&#39;s create another *constructor*.\r\n\r\n        @classmethod\r\n        def from_string(cls, date_as_string):\r\n            day, month, year = map(int, date_as_string.split(&#39;-&#39;))\r\n            date1 = cls(day, month, year)\r\n            return date1\r\n\r\n    date2 = Date.from_string(&#39;11-09-2012&#39;)\r\n\r\nLet&#39;s look more carefully at the above implementation, and review what advantages we have here:\r\n\r\n 1. We&#39;ve implemented date string parsing in one place and it&#39;s reusable now.\r\n 2. Encapsulation works fine here (if you think that you could implement string parsing as a single function elsewhere, this solution fits the OOP paradigm far better).\r\n 3. `cls` is the **class itself**, not an instance of the class. It&#39;s pretty cool because if we inherit our `Date` class, all children will have `from_string` defined also.\r\n\r\n**Static method**\r\n\r\nWhat about `staticmethod`? It&#39;s pretty similar to `classmethod` but doesn&#39;t take any obligatory parameters (like a class method or instance method does).\r\n\r\nLet&#39;s look at the next use case.\r\n\r\n*We have a date string that we want to validate somehow. This task is also logically bound to the `Date` class we&#39;ve used so far, but doesn&#39;t require instantiation of it.*\r\n\r\nHere is where `staticmethod` can be useful. Let&#39;s look at the next piece of code:\r\n\r\n        @staticmethod\r\n        def is_date_valid(date_as_string):\r\n            day, month, year = map(int, date_as_string.split(&#39;-&#39;))\r\n            return day &lt;= 31 and month &lt;= 12 and year &lt;= 3999\r\n\r\n    # usage:\r\n    is_date = Date.is_date_valid(&#39;11-09-2012&#39;)\r\n\r\nSo, as we can see from usage of `staticmethod`, we don&#39;t have any access to what the class is---it&#39;s basically just a function,  called syntactically like a method, but without access to the object and its internals (fields and other methods), which `classmethod` does have.",
        "body": "<p>Though <code>classmethod<\/code> and <code>staticmethod<\/code> are quite similar, there's a slight difference in usage for both entities: <code>classmethod<\/code> must have a reference to a class object as the first parameter, whereas <code>staticmethod<\/code> can have no parameters at all.<\/p>\n<h2>Example<\/h2>\n<pre><code>class Date(object):\n    \n    def __init__(self, day=0, month=0, year=0):\n        self.day = day\n        self.month = month\n        self.year = year\n\n    @classmethod\n    def from_string(cls, date_as_string):\n        day, month, year = map(int, date_as_string.split('-'))\n        date1 = cls(day, month, year)\n        return date1\n\n    @staticmethod\n    def is_date_valid(date_as_string):\n        day, month, year = map(int, date_as_string.split('-'))\n        return day &lt;= 31 and month &lt;= 12 and year &lt;= 3999\n\ndate2 = Date.from_string('11-09-2012')\nis_date = Date.is_date_valid('11-09-2012')\n<\/code><\/pre>\n<h2>Explanation<\/h2>\n<p>Let's assume an example of a class, dealing with date information (this will be our boilerplate):<\/p>\n<pre><code>class Date(object):\n    \n    def __init__(self, day=0, month=0, year=0):\n        self.day = day\n        self.month = month\n        self.year = year\n<\/code><\/pre>\n<p>This class obviously could be used to store information about certain dates (without timezone information; let's assume all dates are presented in UTC).<\/p>\n<p>Here we have <code>__init__<\/code>, a typical initializer of Python class instances, which receives arguments as a typical instance method, having the first non-optional argument (<code>self<\/code>) that holds a reference to a newly created instance.<\/p>\n<p><strong>Class Method<\/strong><\/p>\n<p>We have some tasks that can be nicely done using <code>classmethod<\/code>s.<\/p>\n<p><em>Let's assume that we want to create a lot of <code>Date<\/code> class instances having date information coming from an outer source encoded as a string with format 'dd-mm-yyyy'. Suppose we have to do this in different places in the source code of our project.<\/em><\/p>\n<p>So what we must do here is:<\/p>\n<ol>\n<li>Parse a string to receive day, month and year as three integer variables or a 3-item tuple consisting of that variable.<\/li>\n<li>Instantiate <code>Date<\/code> by passing those values to the initialization call.<\/li>\n<\/ol>\n<p>This will look like:<\/p>\n<pre><code>day, month, year = map(int, string_date.split('-'))\ndate1 = Date(day, month, year)\n<\/code><\/pre>\n<p>For this purpose, C++ can implement such a feature with overloading, but Python lacks this overloading. Instead, we can use <code>classmethod<\/code>. Let's create another <em>constructor<\/em>.<\/p>\n<pre><code>    @classmethod\n    def from_string(cls, date_as_string):\n        day, month, year = map(int, date_as_string.split('-'))\n        date1 = cls(day, month, year)\n        return date1\n\ndate2 = Date.from_string('11-09-2012')\n<\/code><\/pre>\n<p>Let's look more carefully at the above implementation, and review what advantages we have here:<\/p>\n<ol>\n<li>We've implemented date string parsing in one place and it's reusable now.<\/li>\n<li>Encapsulation works fine here (if you think that you could implement string parsing as a single function elsewhere, this solution fits the OOP paradigm far better).<\/li>\n<li><code>cls<\/code> is the <strong>class itself<\/strong>, not an instance of the class. It's pretty cool because if we inherit our <code>Date<\/code> class, all children will have <code>from_string<\/code> defined also.<\/li>\n<\/ol>\n<p><strong>Static method<\/strong><\/p>\n<p>What about <code>staticmethod<\/code>? It's pretty similar to <code>classmethod<\/code> but doesn't take any obligatory parameters (like a class method or instance method does).<\/p>\n<p>Let's look at the next use case.<\/p>\n<p><em>We have a date string that we want to validate somehow. This task is also logically bound to the <code>Date<\/code> class we've used so far, but doesn't require instantiation of it.<\/em><\/p>\n<p>Here is where <code>staticmethod<\/code> can be useful. Let's look at the next piece of code:<\/p>\n<pre><code>    @staticmethod\n    def is_date_valid(date_as_string):\n        day, month, year = map(int, date_as_string.split('-'))\n        return day &lt;= 31 and month &lt;= 12 and year &lt;= 3999\n\n# usage:\nis_date = Date.is_date_valid('11-09-2012')\n<\/code><\/pre>\n<p>So, as we can see from usage of <code>staticmethod<\/code>, we don't have any access to what the class is---it's basically just a function,  called syntactically like a method, but without access to the object and its internals (fields and other methods), which <code>classmethod<\/code> does have.<\/p>\n",
        "community_owned_date": null
    },
    {
        "owner": {
            "account_id": 13511,
            "reputation": 77792,
            "user_id": 27204,
            "user_type": "registered",
            "profile_image": "https:\/\/www.gravatar.com\/avatar\/29671a1757eb710d42d327926b5e08b5?s=256&d=identicon&r=PG",
            "display_name": "gnud",
            "link": "https:\/\/stackoverflow.com\/users\/27204\/gnud"
        },
        "is_accepted": true,
        "score": 2934,
        "last_activity_date": 1610470831,
        "last_edit_date": 1610470831,
        "creation_date": 1257899602,
        "answer_id": 1712236,
        "question_id": 1712227,
        "content_license": "CC BY-SA 4.0",
        "body_markdown": "The [`len()`][1] function can be used with several different types in Python - both built-in types and library types. For example:\r\n\r\n    &gt;&gt;&gt; len([1, 2, 3])\r\n    3\r\n\r\n\r\n  [1]: https:\/\/docs.python.org\/3\/library\/functions.html#len",
        "body": "<p>The <a href=\"https:\/\/docs.python.org\/3\/library\/functions.html#len\" rel=\"noreferrer\"><code>len()<\/code><\/a> function can be used with several different types in Python - both built-in types and library types. For example:<\/p>\n<pre><code>&gt;&gt;&gt; len([1, 2, 3])\n3\n<\/code><\/pre>\n",
        "community_owned_date": null
    },
    {
        "owner": {
            "account_id": 7405,
            "reputation": 310419,
            "user_id": 12855,
            "user_type": "registered",
            "accept_rate": 86,
            "profile_image": "https:\/\/www.gravatar.com\/avatar\/e6488132d206883770017ba97d0f521f?s=256&d=identicon&r=PG",
            "display_name": "SilentGhost",
            "link": "https:\/\/stackoverflow.com\/users\/12855\/silentghost"
        },
        "is_accepted": false,
        "score": 2925,
        "last_activity_date": 1679964267,
        "last_edit_date": 1679964267,
        "creation_date": 1279492112,
        "answer_id": 3277516,
        "question_id": 3277503,
        "content_license": "CC BY-SA 4.0",
        "body_markdown": "This code will read the entire file into memory and remove all whitespace characters (newlines and spaces) from the end of each line:\r\n\r\n```python\r\nwith open(filename) as file:\r\n    lines = [line.rstrip() for line in file]\r\n```\r\n\r\nIf you&#39;re working with a large file, then you should instead read and process it line-by-line:\r\n\r\n```python\r\nwith open(filename) as file:\r\n    for line in file:\r\n        print(line.rstrip())\r\n```\r\n\r\nIn Python 3.8 and up you can use a while loop with the [walrus operator](https:\/\/docs.python.org\/3\/whatsnew\/3.8.html#assignment-expressions) like so:\r\n\r\n```python\r\nwith open(filename) as file:\r\n    while line := file.readline():\r\n        print(line.rstrip())\r\n```\r\n\r\nDepending on what you plan to do with your file and how it was encoded, you may also want to manually set the [access mode][1] and character encoding:\r\n\r\n```python\r\nwith open(filename, &#39;r&#39;, encoding=&#39;UTF-8&#39;) as file:\r\n    while line := file.readline():\r\n        print(line.rstrip())\r\n```\r\n\r\n  [1]: https:\/\/www.tutorialspoint.com\/python\/python_files_io.htm",
        "body": "<p>This code will read the entire file into memory and remove all whitespace characters (newlines and spaces) from the end of each line:<\/p>\n<pre class=\"lang-py prettyprint-override\"><code>with open(filename) as file:\n    lines = [line.rstrip() for line in file]\n<\/code><\/pre>\n<p>If you're working with a large file, then you should instead read and process it line-by-line:<\/p>\n<pre class=\"lang-py prettyprint-override\"><code>with open(filename) as file:\n    for line in file:\n        print(line.rstrip())\n<\/code><\/pre>\n<p>In Python 3.8 and up you can use a while loop with the <a href=\"https:\/\/docs.python.org\/3\/whatsnew\/3.8.html#assignment-expressions\" rel=\"noreferrer\">walrus operator<\/a> like so:<\/p>\n<pre class=\"lang-py prettyprint-override\"><code>with open(filename) as file:\n    while line := file.readline():\n        print(line.rstrip())\n<\/code><\/pre>\n<p>Depending on what you plan to do with your file and how it was encoded, you may also want to manually set the <a href=\"https:\/\/www.tutorialspoint.com\/python\/python_files_io.htm\" rel=\"noreferrer\">access mode<\/a> and character encoding:<\/p>\n<pre class=\"lang-py prettyprint-override\"><code>with open(filename, 'r', encoding='UTF-8') as file:\n    while line := file.readline():\n        print(line.rstrip())\n<\/code><\/pre>\n",
        "community_owned_date": null
    },
    {
        "owner": {
            "account_id": 292,
            "reputation": 31862,
            "user_id": 363,
            "user_type": "registered",
            "profile_image": "https:\/\/www.gravatar.com\/avatar\/d13c16cb15cd0a22161dcdce9f159d10?s=256&d=identicon&r=PG",
            "display_name": "Patrick Johnmeyer",
            "link": "https:\/\/stackoverflow.com\/users\/363\/patrick-johnmeyer"
        },
        "is_accepted": true,
        "score": 2898,
        "last_activity_date": 1654379280,
        "last_edit_date": 1654379280,
        "creation_date": 1217995036,
        "answer_id": 3071,
        "question_id": 3061,
        "content_license": "CC BY-SA 4.0",
        "body_markdown": "Given a module `foo` with method `bar`:\r\n\r\n    import foo\r\n    bar = getattr(foo, &#39;bar&#39;)\r\n    result = bar()\r\n\r\n[`getattr`][1] can similarly be used on class instance bound methods, module-level methods, class methods... the list goes on.\r\n\r\n\r\n  [1]: https:\/\/docs.python.org\/library\/functions.html#getattr",
        "body": "<p>Given a module <code>foo<\/code> with method <code>bar<\/code>:<\/p>\n<pre><code>import foo\nbar = getattr(foo, 'bar')\nresult = bar()\n<\/code><\/pre>\n<p><a href=\"https:\/\/docs.python.org\/library\/functions.html#getattr\" rel=\"noreferrer\"><code>getattr<\/code><\/a> can similarly be used on class instance bound methods, module-level methods, class methods... the list goes on.<\/p>\n",
        "community_owned_date": null
    },
    {
        "owner": {
            "account_id": 212122,
            "reputation": 291913,
            "user_id": 464744,
            "user_type": "registered",
            "accept_rate": 86,
            "profile_image": "https:\/\/www.gravatar.com\/avatar\/3dfd6067f4c69986a652444f44bb6d7c?s=256&d=identicon&r=PG",
            "display_name": "Blender",
            "link": "https:\/\/stackoverflow.com\/users\/464744\/blender"
        },
        "is_accepted": true,
        "score": 2886,
        "last_activity_date": 1676682906,
        "last_edit_date": 1676682906,
        "creation_date": 1350510852,
        "answer_id": 12944035,
        "question_id": 12943819,
        "content_license": "CC BY-SA 4.0",
        "body_markdown": "Use the `indent=` parameter of [`json.dump()`][2] or [`json.dumps()`][3] to specify how many spaces to indent by:\r\n\r\n```python-repl\r\n&gt;&gt;&gt; import json\r\n&gt;&gt;&gt; your_json = &#39;[&quot;foo&quot;, {&quot;bar&quot;: [&quot;baz&quot;, null, 1.0, 2]}]&#39;\r\n&gt;&gt;&gt; parsed = json.loads(your_json)\r\n&gt;&gt;&gt; print(json.dumps(parsed, indent=4))\r\n[\r\n    &quot;foo&quot;,\r\n    {\r\n        &quot;bar&quot;: [\r\n            &quot;baz&quot;,\r\n            null,\r\n            1.0,\r\n            2\r\n        ]\r\n    }\r\n]\r\n```\r\n\r\nTo parse a file, use [`json.load()`][4]:\r\n\r\n    with open(&#39;filename.txt&#39;, &#39;r&#39;) as handle:\r\n        parsed = json.load(handle)\r\n\r\n\r\n  [1]: https:\/\/docs.python.org\/3\/library\/json.html\r\n  [2]: https:\/\/docs.python.org\/3\/library\/json.html#json.dump\r\n  [3]: https:\/\/docs.python.org\/3\/library\/json.html#json.dumps\r\n  [4]: https:\/\/docs.python.org\/3\/library\/json.html#json.load\r\n\r\n",
        "body": "<p>Use the <code>indent=<\/code> parameter of <a href=\"https:\/\/docs.python.org\/3\/library\/json.html#json.dump\" rel=\"noreferrer\"><code>json.dump()<\/code><\/a> or <a href=\"https:\/\/docs.python.org\/3\/library\/json.html#json.dumps\" rel=\"noreferrer\"><code>json.dumps()<\/code><\/a> to specify how many spaces to indent by:<\/p>\n<pre><code>&gt;&gt;&gt; import json\n&gt;&gt;&gt; your_json = '[&quot;foo&quot;, {&quot;bar&quot;: [&quot;baz&quot;, null, 1.0, 2]}]'\n&gt;&gt;&gt; parsed = json.loads(your_json)\n&gt;&gt;&gt; print(json.dumps(parsed, indent=4))\n[\n    &quot;foo&quot;,\n    {\n        &quot;bar&quot;: [\n            &quot;baz&quot;,\n            null,\n            1.0,\n            2\n        ]\n    }\n]\n<\/code><\/pre>\n<p>To parse a file, use <a href=\"https:\/\/docs.python.org\/3\/library\/json.html#json.load\" rel=\"noreferrer\"><code>json.load()<\/code><\/a>:<\/p>\n<pre><code>with open('filename.txt', 'r') as handle:\n    parsed = json.load(handle)\n<\/code><\/pre>\n",
        "community_owned_date": null
    },
    {
        "owner": {
            "account_id": 53119,
            "reputation": 43952,
            "user_id": 158773,
            "user_type": "registered",
            "profile_image": "https:\/\/i.stack.imgur.com\/txDho.png?s=256&g=1",
            "display_name": "rbp",
            "link": "https:\/\/stackoverflow.com\/users\/158773\/rbp"
        },
        "is_accepted": true,
        "score": 2836,
        "last_activity_date": 1692018432,
        "last_edit_date": 1692018432,
        "creation_date": 1281470209,
        "answer_id": 3452888,
        "question_id": 2720014,
        "content_license": "CC BY-SA 4.0",
        "body_markdown": "There isn&#39;t a built-in flag yet. Starting with pip version 22.3, the `--outdated` and `--format=freeze` have become [mutually exclusive][pip22.3]. Use Python, to parse the JSON output:\r\n\r\n```bash\r\npip --disable-pip-version-check list --outdated --format=json | python -c &quot;import json, sys; print(&#39;\\n&#39;.join([x[&#39;name&#39;] for x in json.load(sys.stdin)]))&quot; | xargs -n1 pip install -U\r\n```\r\n\r\n[pip22.3]: https:\/\/pip.pypa.io\/en\/stable\/news\/#v22-3\r\n\r\nIf you are using `pip&lt;22.3` you can use:\r\n\r\n```bash\r\npip list --outdated --format=freeze | grep -v &#39;^\\-e&#39; | cut -d = -f 1  | xargs -n1 pip install -U\r\n```\r\n\r\nFor older versions of `pip`:\r\n\r\n```bash\r\npip freeze --local | grep -v &#39;^\\-e&#39; | cut -d = -f 1  | xargs -n1 pip install -U\r\n```\r\n\r\n---\r\n\r\n - The `grep` is to skip editable (&quot;-e&quot;) package definitions, as suggested by @jawache. (Yes, you could replace `grep`+`cut` with `sed` or `awk` or `perl` or...).\r\n\r\n - The `-n1` flag for `xargs` prevents stopping everything if updating one package fails (thanks [@andsens]).\r\n\r\n[@andsens]: https:\/\/stackoverflow.com\/users\/339505\/andsens\r\n\r\n---\r\n\r\n**Note:** there are infinite potential variations for this. I&#39;m trying to keep this answer short and simple, but please do suggest variations in the comments!\r\n\r\n\r\n",
        "body": "<p>There isn't a built-in flag yet. Starting with pip version 22.3, the <code>--outdated<\/code> and <code>--format=freeze<\/code> have become <a href=\"https:\/\/pip.pypa.io\/en\/stable\/news\/#v22-3\" rel=\"noreferrer\">mutually exclusive<\/a>. Use Python, to parse the JSON output:<\/p>\n<pre class=\"lang-bash prettyprint-override\"><code>pip --disable-pip-version-check list --outdated --format=json | python -c &quot;import json, sys; print('\\n'.join([x['name'] for x in json.load(sys.stdin)]))&quot; | xargs -n1 pip install -U\n<\/code><\/pre>\n<p>If you are using <code>pip&lt;22.3<\/code> you can use:<\/p>\n<pre class=\"lang-bash prettyprint-override\"><code>pip list --outdated --format=freeze | grep -v '^\\-e' | cut -d = -f 1  | xargs -n1 pip install -U\n<\/code><\/pre>\n<p>For older versions of <code>pip<\/code>:<\/p>\n<pre class=\"lang-bash prettyprint-override\"><code>pip freeze --local | grep -v '^\\-e' | cut -d = -f 1  | xargs -n1 pip install -U\n<\/code><\/pre>\n<hr \/>\n<ul>\n<li><p>The <code>grep<\/code> is to skip editable (&quot;-e&quot;) package definitions, as suggested by @jawache. (Yes, you could replace <code>grep<\/code>+<code>cut<\/code> with <code>sed<\/code> or <code>awk<\/code> or <code>perl<\/code> or...).<\/p>\n<\/li>\n<li><p>The <code>-n1<\/code> flag for <code>xargs<\/code> prevents stopping everything if updating one package fails (thanks <a href=\"https:\/\/stackoverflow.com\/users\/339505\/andsens\">@andsens<\/a>).<\/p>\n<\/li>\n<\/ul>\n<hr \/>\n<p><strong>Note:<\/strong> there are infinite potential variations for this. I'm trying to keep this answer short and simple, but please do suggest variations in the comments!<\/p>\n",
        "community_owned_date": null
    },
    {
        "owner": {
            "account_id": 10176,
            "reputation": 31546,
            "user_id": 19104,
            "user_type": "registered",
            "profile_image": "https:\/\/www.gravatar.com\/avatar\/8720289444c77047c986102192da5edc?s=256&d=identicon&r=PG",
            "display_name": "joeld",
            "link": "https:\/\/stackoverflow.com\/users\/19104\/joeld"
        },
        "is_accepted": false,
        "score": 2832,
        "last_activity_date": 1610210711,
        "last_edit_date": 1610210711,
        "creation_date": 1226604307,
        "answer_id": 287944,
        "question_id": 287871,
        "content_license": "CC BY-SA 4.0",
        "body_markdown": "This somewhat depends on what platform you are on. The most common way to do this is by printing ANSI escape sequences. For a simple example, here&#39;s some Python code from the [Blender build scripts][1]:\r\n\r\n    class bcolors:\r\n        HEADER = &#39;\\033[95m&#39;\r\n        OKBLUE = &#39;\\033[94m&#39;\r\n        OKCYAN = &#39;\\033[96m&#39;\r\n        OKGREEN = &#39;\\033[92m&#39;\r\n        WARNING = &#39;\\033[93m&#39;\r\n        FAIL = &#39;\\033[91m&#39;\r\n        ENDC = &#39;\\033[0m&#39;\r\n        BOLD = &#39;\\033[1m&#39;\r\n        UNDERLINE = &#39;\\033[4m&#39;\r\n\r\nTo use code like this, you can do something like:\r\n\r\n    print(bcolors.WARNING + &quot;Warning: No active frommets remain. Continue?&quot; + bcolors.ENDC)\r\n\r\nOr, with Python 3.6+:\r\n\r\n    print(f&quot;{bcolors.WARNING}Warning: No active frommets remain. Continue?{bcolors.ENDC}&quot;)\r\n\r\nThis will work on unixes including OS X, Linux and Windows (provided you use [ANSICON][2], or in Windows 10 provided you enable [VT100 emulation][3]). There are ANSI codes for setting the color, moving the cursor, and more.\r\n\r\nIf you are going to get complicated with this (and it sounds like you are if you are writing a game), you should look into the &quot;[curses][4]&quot; module, which handles a lot of the complicated parts of this for you. The [Python Curses HowTO][5] is a good introduction.\r\n\r\nIf you are not using extended ASCII (i.e., not on a PC), you are stuck with the ASCII characters below 127, and &#39;#&#39; or &#39;@&#39; is probably your best bet for a block. If you can ensure your terminal is using a IBM [extended ASCII character set][6], you have many more options. Characters 176, 177, 178 and 219 are the &quot;block characters&quot;.\r\n\r\nSome modern text-based programs, such as &quot;Dwarf Fortress&quot;, emulate text mode in a graphical mode, and use images of the classic PC font. You can find some of these bitmaps that you can use on the [Dwarf Fortress Wiki][7] see ([user-made tilesets][8]).\r\n\r\nThe [Text Mode Demo Contest][9] has more resources for doing graphics in text mode.\r\n\r\n  [1]: https:\/\/svn.blender.org\/svnroot\/bf-blender\/trunk\/blender\/build_files\/scons\/tools\/bcolors.py\r\n  [2]: https:\/\/github.com\/adoxa\/ansicon\r\n  [3]: https:\/\/msdn.microsoft.com\/en-us\/library\/mt638032\r\n  [4]: https:\/\/en.wikipedia.org\/wiki\/Curses_%28programming_library%29\r\n  [5]: http:\/\/docs.python.org\/howto\/curses.html &quot;Python Curses howto&quot;\r\n  [6]: http:\/\/telecom.tbi.net\/asc-ibm.html\r\n  [7]: http:\/\/dwarffortresswiki.org\/DF2014:Tilesets\r\n  [8]: http:\/\/dwarffortresswiki.org\/Tileset_repository\r\n  [9]: http:\/\/en.wikipedia.org\/wiki\/TMDC &quot;text mode demo contest&quot;\r\n\r\n\r\n\r\n",
        "body": "<p>This somewhat depends on what platform you are on. The most common way to do this is by printing ANSI escape sequences. For a simple example, here's some Python code from the <a href=\"https:\/\/svn.blender.org\/svnroot\/bf-blender\/trunk\/blender\/build_files\/scons\/tools\/bcolors.py\" rel=\"noreferrer\">Blender build scripts<\/a>:<\/p>\n<pre><code>class bcolors:\n    HEADER = '\\033[95m'\n    OKBLUE = '\\033[94m'\n    OKCYAN = '\\033[96m'\n    OKGREEN = '\\033[92m'\n    WARNING = '\\033[93m'\n    FAIL = '\\033[91m'\n    ENDC = '\\033[0m'\n    BOLD = '\\033[1m'\n    UNDERLINE = '\\033[4m'\n<\/code><\/pre>\n<p>To use code like this, you can do something like:<\/p>\n<pre><code>print(bcolors.WARNING + &quot;Warning: No active frommets remain. Continue?&quot; + bcolors.ENDC)\n<\/code><\/pre>\n<p>Or, with Python 3.6+:<\/p>\n<pre><code>print(f&quot;{bcolors.WARNING}Warning: No active frommets remain. Continue?{bcolors.ENDC}&quot;)\n<\/code><\/pre>\n<p>This will work on unixes including OS X, Linux and Windows (provided you use <a href=\"https:\/\/github.com\/adoxa\/ansicon\" rel=\"noreferrer\">ANSICON<\/a>, or in Windows 10 provided you enable <a href=\"https:\/\/msdn.microsoft.com\/en-us\/library\/mt638032\" rel=\"noreferrer\">VT100 emulation<\/a>). There are ANSI codes for setting the color, moving the cursor, and more.<\/p>\n<p>If you are going to get complicated with this (and it sounds like you are if you are writing a game), you should look into the &quot;<a href=\"https:\/\/en.wikipedia.org\/wiki\/Curses_%28programming_library%29\" rel=\"noreferrer\">curses<\/a>&quot; module, which handles a lot of the complicated parts of this for you. The <a href=\"http:\/\/docs.python.org\/howto\/curses.html\" rel=\"noreferrer\" title=\"Python Curses howto\">Python Curses HowTO<\/a> is a good introduction.<\/p>\n<p>If you are not using extended ASCII (i.e., not on a PC), you are stuck with the ASCII characters below 127, and '#' or '@' is probably your best bet for a block. If you can ensure your terminal is using a IBM <a href=\"http:\/\/telecom.tbi.net\/asc-ibm.html\" rel=\"noreferrer\">extended ASCII character set<\/a>, you have many more options. Characters 176, 177, 178 and 219 are the &quot;block characters&quot;.<\/p>\n<p>Some modern text-based programs, such as &quot;Dwarf Fortress&quot;, emulate text mode in a graphical mode, and use images of the classic PC font. You can find some of these bitmaps that you can use on the <a href=\"http:\/\/dwarffortresswiki.org\/DF2014:Tilesets\" rel=\"noreferrer\">Dwarf Fortress Wiki<\/a> see (<a href=\"http:\/\/dwarffortresswiki.org\/Tileset_repository\" rel=\"noreferrer\">user-made tilesets<\/a>).<\/p>\n<p>The <a href=\"http:\/\/en.wikipedia.org\/wiki\/TMDC\" rel=\"noreferrer\" title=\"text mode demo contest\">Text Mode Demo Contest<\/a> has more resources for doing graphics in text mode.<\/p>\n",
        "community_owned_date": null
    },
    {
        "owner": {
            "account_id": 1236018,
            "reputation": 77558,
            "user_id": 1199589,
            "user_type": "registered",
            "accept_rate": 91,
            "profile_image": "https:\/\/www.gravatar.com\/avatar\/d3c6a7f974f5d687a394415a2122c6b6?s=256&d=identicon&r=PG",
            "display_name": "root",
            "link": "https:\/\/stackoverflow.com\/users\/1199589\/root"
        },
        "is_accepted": true,
        "score": 2784,
        "last_activity_date": 1633564115,
        "last_edit_date": 1633564115,
        "creation_date": 1365668669,
        "answer_id": 15943975,
        "question_id": 15943769,
        "content_license": "CC BY-SA 4.0",
        "body_markdown": "For a dataframe `df`, one can use any of the following:\r\n\r\n - `len(df.index)`\r\n - `df.shape[0]`\r\n - `df[df.columns[0]].count()` (== [number of non-NaN values](https:\/\/pandas.pydata.org\/docs\/reference\/api\/pandas.Series.count.html) in first column)\r\n\r\n[![Performance plot][1]][1]\r\n\r\n---\r\n\r\nCode to reproduce the plot:\r\n```python\r\nimport numpy as np\r\nimport pandas as pd\r\nimport perfplot\r\n\r\nperfplot.save(\r\n    &quot;out.png&quot;,\r\n    setup=lambda n: pd.DataFrame(np.arange(n * 3).reshape(n, 3)),\r\n    n_range=[2**k for k in range(25)],\r\n    kernels=[\r\n        lambda df: len(df.index),\r\n        lambda df: df.shape[0],\r\n        lambda df: df[df.columns[0]].count(),\r\n    ],\r\n    labels=[&quot;len(df.index)&quot;, &quot;df.shape[0]&quot;, &quot;df[df.columns[0]].count()&quot;],\r\n    xlabel=&quot;Number of rows&quot;,\r\n)\r\n```\r\n\r\n\r\n  [1]: https:\/\/i.stack.imgur.com\/wEzue.png",
        "body": "<p>For a dataframe <code>df<\/code>, one can use any of the following:<\/p>\n<ul>\n<li><code>len(df.index)<\/code><\/li>\n<li><code>df.shape[0]<\/code><\/li>\n<li><code>df[df.columns[0]].count()<\/code> (== <a href=\"https:\/\/pandas.pydata.org\/docs\/reference\/api\/pandas.Series.count.html\" rel=\"noreferrer\">number of non-NaN values<\/a> in first column)<\/li>\n<\/ul>\n<p><a href=\"https:\/\/i.stack.imgur.com\/wEzue.png\" rel=\"noreferrer\"><img src=\"https:\/\/i.stack.imgur.com\/wEzue.png\" alt=\"Performance plot\" \/><\/a><\/p>\n<hr \/>\n<p>Code to reproduce the plot:<\/p>\n<pre class=\"lang-py prettyprint-override\"><code>import numpy as np\nimport pandas as pd\nimport perfplot\n\nperfplot.save(\n    &quot;out.png&quot;,\n    setup=lambda n: pd.DataFrame(np.arange(n * 3).reshape(n, 3)),\n    n_range=[2**k for k in range(25)],\n    kernels=[\n        lambda df: len(df.index),\n        lambda df: df.shape[0],\n        lambda df: df[df.columns[0]].count(),\n    ],\n    labels=[&quot;len(df.index)&quot;, &quot;df.shape[0]&quot;, &quot;df[df.columns[0]].count()&quot;],\n    xlabel=&quot;Number of rows&quot;,\n)\n<\/code><\/pre>\n",
        "community_owned_date": null
    },
    {
        "owner": {
            "account_id": 4670,
            "reputation": 42448,
            "user_id": 7136,
            "user_type": "registered",
            "accept_rate": 71,
            "profile_image": "https:\/\/www.gravatar.com\/avatar\/a0cd80eff2e11ff35af5ccf00873ccf2?s=256&d=identicon&r=PG",
            "display_name": "PierreBdR",
            "link": "https:\/\/stackoverflow.com\/users\/7136\/pierrebdr"
        },
        "is_accepted": false,
        "score": 2601,
        "last_activity_date": 1664911832,
        "last_edit_date": 1664911832,
        "creation_date": 1221656228,
        "answer_id": 82846,
        "question_id": 82831,
        "content_license": "CC BY-SA 4.0",
        "body_markdown": "Use [`os.path.exists`][1] to check both files and directories:\r\n\r\n    import os.path\r\n    os.path.exists(file_path)\r\n\r\nUse [`os.path.isfile`][2] to check only files (note: follows [symbolic links][3]):\r\n\r\n    os.path.isfile(file_path)\r\n\r\n  [1]: https:\/\/docs.python.org\/3\/library\/os.path.html#os.path.exists\r\n  [2]: https:\/\/docs.python.org\/3\/library\/os.path.html#os.path.isfile\r\n  [3]: https:\/\/en.wikipedia.org\/wiki\/Symbolic_link\r\n",
        "body": "<p>Use <a href=\"https:\/\/docs.python.org\/3\/library\/os.path.html#os.path.exists\" rel=\"noreferrer\"><code>os.path.exists<\/code><\/a> to check both files and directories:<\/p>\n<pre><code>import os.path\nos.path.exists(file_path)\n<\/code><\/pre>\n<p>Use <a href=\"https:\/\/docs.python.org\/3\/library\/os.path.html#os.path.isfile\" rel=\"noreferrer\"><code>os.path.isfile<\/code><\/a> to check only files (note: follows <a href=\"https:\/\/en.wikipedia.org\/wiki\/Symbolic_link\" rel=\"noreferrer\">symbolic links<\/a>):<\/p>\n<pre><code>os.path.isfile(file_path)\n<\/code><\/pre>\n",
        "community_owned_date": null
    },
    {
        "owner": {
            "account_id": 9315,
            "reputation": 218684,
            "user_id": 17160,
            "user_type": "registered",
            "accept_rate": 78,
            "profile_image": "https:\/\/www.gravatar.com\/avatar\/81cb50f5fe868629a680c16a56781f01?s=256&d=identicon&r=PG",
            "display_name": "nosklo",
            "link": "https:\/\/stackoverflow.com\/users\/17160\/nosklo"
        },
        "is_accepted": true,
        "score": 2592,
        "last_activity_date": 1655083524,
        "last_edit_date": 1655083524,
        "creation_date": 1234447966,
        "answer_id": 541394,
        "question_id": 541390,
        "content_license": "CC BY-SA 4.0",
        "body_markdown": "Use [`os.path.splitext`][2]:\r\n\r\n    &gt;&gt;&gt; import os\r\n    &gt;&gt;&gt; filename, file_extension = os.path.splitext(&#39;\/path\/to\/somefile.ext&#39;)\r\n    &gt;&gt;&gt; filename\r\n    &#39;\/path\/to\/somefile&#39;\r\n    &gt;&gt;&gt; file_extension\r\n    &#39;.ext&#39;\r\n\r\nUnlike most manual string-splitting attempts, `os.path.splitext` will correctly treat `\/a\/b.c\/d` as having no extension instead of having extension `.c\/d`, and it will treat `.bashrc` as having no extension instead of having extension `.bashrc`:\r\n\r\n    &gt;&gt;&gt; os.path.splitext(&#39;\/a\/b.c\/d&#39;)\r\n    (&#39;\/a\/b.c\/d&#39;, &#39;&#39;)\r\n    &gt;&gt;&gt; os.path.splitext(&#39;.bashrc&#39;)\r\n    (&#39;.bashrc&#39;, &#39;&#39;)\r\n\r\n[1]: https:\/\/docs.python.org\/2\/library\/os.path.html#os.path.splitext\r\n[2]: https:\/\/docs.python.org\/3\/library\/os.path.html#os.path.splitext",
        "body": "<p>Use <a href=\"https:\/\/docs.python.org\/3\/library\/os.path.html#os.path.splitext\" rel=\"noreferrer\"><code>os.path.splitext<\/code><\/a>:<\/p>\n<pre><code>&gt;&gt;&gt; import os\n&gt;&gt;&gt; filename, file_extension = os.path.splitext('\/path\/to\/somefile.ext')\n&gt;&gt;&gt; filename\n'\/path\/to\/somefile'\n&gt;&gt;&gt; file_extension\n'.ext'\n<\/code><\/pre>\n<p>Unlike most manual string-splitting attempts, <code>os.path.splitext<\/code> will correctly treat <code>\/a\/b.c\/d<\/code> as having no extension instead of having extension <code>.c\/d<\/code>, and it will treat <code>.bashrc<\/code> as having no extension instead of having extension <code>.bashrc<\/code>:<\/p>\n<pre><code>&gt;&gt;&gt; os.path.splitext('\/a\/b.c\/d')\n('\/a\/b.c\/d', '')\n&gt;&gt;&gt; os.path.splitext('.bashrc')\n('.bashrc', '')\n<\/code><\/pre>\n",
        "community_owned_date": null
    },
    {
        "owner": {
            "account_id": 12594,
            "reputation": 32023,
            "user_id": 24894,
            "user_type": "registered",
            "accept_rate": 67,
            "profile_image": "https:\/\/www.gravatar.com\/avatar\/8585b20b69e8ff4b0ba737accfdbb31b?s=256&d=identicon&r=PG",
            "display_name": "kovshenin",
            "link": "https:\/\/stackoverflow.com\/users\/24894\/kovshenin"
        },
        "is_accepted": true,
        "score": 2581,
        "last_activity_date": 1648616863,
        "last_edit_date": 1648616863,
        "creation_date": 1287751891,
        "answer_id": 3996930,
        "question_id": 3996904,
        "content_license": "CC BY-SA 4.0",
        "body_markdown": "Try [`random.randrange`](https:\/\/docs.python.org\/3\/library\/random.html#random.randrange):\r\n\r\n    from random import randrange\r\n    print(randrange(10))\r\n",
        "body": "<p>Try <a href=\"https:\/\/docs.python.org\/3\/library\/random.html#random.randrange\" rel=\"noreferrer\"><code>random.randrange<\/code><\/a>:<\/p>\n<pre><code>from random import randrange\nprint(randrange(10))\n<\/code><\/pre>\n",
        "community_owned_date": null
    },
    {
        "owner": {
            "account_id": 111213,
            "reputation": 45584,
            "user_id": 293929,
            "user_type": "registered",
            "accept_rate": 100,
            "profile_image": "https:\/\/www.gravatar.com\/avatar\/cd511289b5773fff5e7efe328846eef3?s=256&d=identicon&r=PG",
            "display_name": "adamk",
            "link": "https:\/\/stackoverflow.com\/users\/293929\/adamk"
        },
        "is_accepted": false,
        "score": 2535,
        "last_activity_date": 1641909383,
        "last_edit_date": 1641909383,
        "creation_date": 1278699217,
        "answer_id": 3215392,
        "question_id": 3207219,
        "content_license": "CC BY-SA 4.0",
        "body_markdown": "I prefer using the [`glob`][1] module, as it does pattern matching and expansion.\r\n\r\n    import glob\r\n    print(glob.glob(&quot;\/home\/adam\/*&quot;))\r\n\r\n\r\nIt does pattern matching intuitively\r\n\r\n    import glob\r\n    # All files and directories ending with .txt and that don&#39;t begin with a dot:\r\n    print(glob.glob(&quot;\/home\/adam\/*.txt&quot;)) \r\n    # All files and directories ending with .txt with depth of 2 folders, ignoring names beginning with a dot:\r\n    print(glob.glob(&quot;\/home\/adam\/*\/*.txt&quot;)) \r\n\r\n\r\nIt will return a list with the queried files and directories:\r\n\r\n    [&#39;\/home\/adam\/file1.txt&#39;, &#39;\/home\/adam\/file2.txt&#39;, .... ]\r\n\r\n\r\nNote that `glob` ignores files and directories that begin with a dot `.`, as those are considered hidden files and directories, unless the pattern is something like `.*`.\r\n\r\nUse [`glob.escape`][2] to escape strings that are not meant to be patterns:\r\n\r\n    print(glob.glob(glob.escape(directory_name) + &quot;\/*.txt&quot;))\r\n\r\n\r\n  [1]: https:\/\/docs.python.org\/library\/glob.html\r\n  [2]: https:\/\/docs.python.org\/3\/library\/glob.html#glob.escape",
        "body": "<p>I prefer using the <a href=\"https:\/\/docs.python.org\/library\/glob.html\" rel=\"noreferrer\"><code>glob<\/code><\/a> module, as it does pattern matching and expansion.<\/p>\n<pre><code>import glob\nprint(glob.glob(&quot;\/home\/adam\/*&quot;))\n<\/code><\/pre>\n<p>It does pattern matching intuitively<\/p>\n<pre><code>import glob\n# All files and directories ending with .txt and that don't begin with a dot:\nprint(glob.glob(&quot;\/home\/adam\/*.txt&quot;)) \n# All files and directories ending with .txt with depth of 2 folders, ignoring names beginning with a dot:\nprint(glob.glob(&quot;\/home\/adam\/*\/*.txt&quot;)) \n<\/code><\/pre>\n<p>It will return a list with the queried files and directories:<\/p>\n<pre><code>['\/home\/adam\/file1.txt', '\/home\/adam\/file2.txt', .... ]\n<\/code><\/pre>\n<p>Note that <code>glob<\/code> ignores files and directories that begin with a dot <code>.<\/code>, as those are considered hidden files and directories, unless the pattern is something like <code>.*<\/code>.<\/p>\n<p>Use <a href=\"https:\/\/docs.python.org\/3\/library\/glob.html#glob.escape\" rel=\"noreferrer\"><code>glob.escape<\/code><\/a> to escape strings that are not meant to be patterns:<\/p>\n<pre><code>print(glob.glob(glob.escape(directory_name) + &quot;\/*.txt&quot;))\n<\/code><\/pre>\n",
        "community_owned_date": null
    },
    {
        "owner": {
            "account_id": 202404,
            "reputation": 208601,
            "user_id": 449449,
            "user_type": "registered",
            "accept_rate": 100,
            "profile_image": "https:\/\/www.gravatar.com\/avatar\/b52c27e86c87d931e654d6a2d2cdf974?s=256&d=identicon&r=PG",
            "display_name": "eumiro",
            "link": "https:\/\/stackoverflow.com\/users\/449449\/eumiro"
        },
        "is_accepted": true,
        "score": 2529,
        "last_activity_date": 1607794253,
        "last_edit_date": 1607794253,
        "creation_date": 1341498207,
        "answer_id": 11346337,
        "question_id": 11346283,
        "content_license": "CC BY-SA 4.0",
        "body_markdown": "Just assign it to the `.columns` attribute:\r\n\r\n    &gt;&gt;&gt; df = pd.DataFrame({&#39;$a&#39;:[1,2], &#39;$b&#39;: [10,20]})\r\n    &gt;&gt;&gt; df\r\n       $a  $b\r\n    0   1  10\r\n    1   2  20\r\n\r\n    &gt;&gt;&gt; df.columns = [&#39;a&#39;, &#39;b&#39;]\r\n    &gt;&gt;&gt; df\r\n       a   b\r\n    0  1  10\r\n    1  2  20\r\n\r\n",
        "body": "<p>Just assign it to the <code>.columns<\/code> attribute:<\/p>\n<pre><code>&gt;&gt;&gt; df = pd.DataFrame({'$a':[1,2], '$b': [10,20]})\n&gt;&gt;&gt; df\n   $a  $b\n0   1  10\n1   2  20\n\n&gt;&gt;&gt; df.columns = ['a', 'b']\n&gt;&gt;&gt; df\n   a   b\n0  1  10\n1  2  20\n<\/code><\/pre>\n",
        "community_owned_date": null
    },
    {
        "owner": {
            "account_id": 13991,
            "reputation": 39012,
            "user_id": 28409,
            "user_type": "registered",
            "profile_image": "https:\/\/www.gravatar.com\/avatar\/?s=256&d=identicon&r=PG",
            "display_name": "user28409",
            "link": "https:\/\/stackoverflow.com\/users\/28409\/user28409"
        },
        "is_accepted": false,
        "score": 2526,
        "last_activity_date": 1691641847,
        "last_edit_date": 1691641847,
        "creation_date": 1224969750,
        "answer_id": 237028,
        "question_id": 231767,
        "content_license": "CC BY-SA 4.0",
        "body_markdown": "## Shortcut to understanding `yield` ##\r\n\r\nWhen you see a function with `yield` statements, apply this easy trick to understand what will happen:\r\n\r\n 1. Insert a line `result = []` at the start of the function.\r\n 2. Replace each `yield expr` with `result.append(expr)`.\r\n 3. Insert a line `return result` at the bottom of the function.\r\n 4. Yay - no more `yield` statements! Read and figure out the code.\r\n 5. Compare the function to the original definition.\r\n\r\nThis trick may give you an idea of the logic behind the function, but what actually happens with `yield` is significantly different than what happens in the list-based approach. In many cases, the yield approach will be a lot more memory efficient and faster too. In other cases, this trick will get you stuck in an infinite loop, even though the original function works just fine. Read on to learn more...\r\n\r\n## Don&#39;t confuse your iterables, iterators, and generators\r\n\r\nFirst, the **iterator protocol** - when you write\r\n\r\n    for x in mylist:\r\n        ...loop body...\r\n\r\nPython performs the following two steps:\r\n\r\n1. Gets an iterator for `mylist`:\r\n   \r\n   Call `iter(mylist)` -&gt; this returns an object with a `next()` method (or `__next__()` in Python 3).\r\n\r\n   [This is the step most people forget to tell you about]\r\n\r\n2. Uses the iterator to loop over items:\r\n\r\n   Keep calling the `next()` method on the iterator returned from step 1. The return value from `next()` is assigned to `x` and the loop body is executed. If an exception `StopIteration` is raised from within `next()`, it means there are no more values in the iterator and the loop is exited.\r\n\r\nThe truth is Python performs the above two steps anytime it wants to *loop over* the contents of an object - so it could be a for loop, but it could also be code like `otherlist.extend(mylist)` (where `otherlist` is a Python list).\r\n\r\nHere `mylist` is an *iterable* because it implements the iterator protocol. In a user-defined class, you can implement the `__iter__()` method to make instances of your class iterable. This method should return an *iterator*. An iterator is an object with a `next()` method. It is possible to implement both `__iter__()` and `next()` on the same class, and have `__iter__()` return `self`. This will work for simple cases, but not when you want two iterators looping over the same object at the same time.\r\n\r\nSo that&#39;s the iterator protocol, many objects implement this protocol:\r\n\r\n 1. Built-in lists, dictionaries, tuples, sets, and files.\r\n 2. User-defined classes that implement `__iter__()`.\r\n 3. Generators.\r\n\r\nNote that a `for` loop doesn&#39;t know what kind of object it&#39;s dealing with - it just follows the iterator protocol, and is happy to get item after item as it calls `next()`. Built-in lists return their items one by one, dictionaries return the *keys* one by one, files return the *lines* one by one, etc. And generators return... well that&#39;s where `yield` comes in:\r\n\r\n    def f123():\r\n        yield 1\r\n        yield 2\r\n        yield 3\r\n\r\n    for item in f123():\r\n        print item\r\n\r\nInstead of `yield` statements, if you had three `return` statements in `f123()` only the first would get executed, and the function would exit. But `f123()` is no ordinary function. When `f123()` is called, it *does not* return any of the values in the yield statements! It returns a generator object. Also, the function does not really exit - it goes into a suspended state. When the `for` loop tries to loop over the generator object, the function resumes from its suspended state at the very next line after the `yield` it previously returned from, executes the next line of code, in this case, a `yield` statement, and returns that as the next item. This happens until the function exits, at which point the generator raises `StopIteration`, and the loop exits. \r\n\r\nSo the generator object is sort of like an adapter - at one end it exhibits the iterator protocol, by exposing `__iter__()` and `next()` methods to keep the `for` loop happy. At the other end, however, it runs the function just enough to get the next value out of it and puts it back in suspended mode.\r\n\r\n## Why use generators? ##\r\n\r\nUsually, you can write code that doesn&#39;t use generators but implements the same logic. One option is to use the temporary list &#39;trick&#39; I mentioned before. That will not work in all cases, for e.g. if you have infinite loops, or it may make inefficient use of memory when you have a really long list. The other approach is to implement a new iterable class `SomethingIter` that keeps the state in instance members and performs the next logical step in its `next()` (or `__next__()` in Python 3) method. Depending on the logic, the code inside the `next()` method may end up looking very complex and prone to bugs. Here generators provide a clean and easy solution.",
        "body": "<h2>Shortcut to understanding <code>yield<\/code><\/h2>\n<p>When you see a function with <code>yield<\/code> statements, apply this easy trick to understand what will happen:<\/p>\n<ol>\n<li>Insert a line <code>result = []<\/code> at the start of the function.<\/li>\n<li>Replace each <code>yield expr<\/code> with <code>result.append(expr)<\/code>.<\/li>\n<li>Insert a line <code>return result<\/code> at the bottom of the function.<\/li>\n<li>Yay - no more <code>yield<\/code> statements! Read and figure out the code.<\/li>\n<li>Compare the function to the original definition.<\/li>\n<\/ol>\n<p>This trick may give you an idea of the logic behind the function, but what actually happens with <code>yield<\/code> is significantly different than what happens in the list-based approach. In many cases, the yield approach will be a lot more memory efficient and faster too. In other cases, this trick will get you stuck in an infinite loop, even though the original function works just fine. Read on to learn more...<\/p>\n<h2>Don't confuse your iterables, iterators, and generators<\/h2>\n<p>First, the <strong>iterator protocol<\/strong> - when you write<\/p>\n<pre><code>for x in mylist:\n    ...loop body...\n<\/code><\/pre>\n<p>Python performs the following two steps:<\/p>\n<ol>\n<li><p>Gets an iterator for <code>mylist<\/code>:<\/p>\n<p>Call <code>iter(mylist)<\/code> -&gt; this returns an object with a <code>next()<\/code> method (or <code>__next__()<\/code> in Python 3).<\/p>\n<p>[This is the step most people forget to tell you about]<\/p>\n<\/li>\n<li><p>Uses the iterator to loop over items:<\/p>\n<p>Keep calling the <code>next()<\/code> method on the iterator returned from step 1. The return value from <code>next()<\/code> is assigned to <code>x<\/code> and the loop body is executed. If an exception <code>StopIteration<\/code> is raised from within <code>next()<\/code>, it means there are no more values in the iterator and the loop is exited.<\/p>\n<\/li>\n<\/ol>\n<p>The truth is Python performs the above two steps anytime it wants to <em>loop over<\/em> the contents of an object - so it could be a for loop, but it could also be code like <code>otherlist.extend(mylist)<\/code> (where <code>otherlist<\/code> is a Python list).<\/p>\n<p>Here <code>mylist<\/code> is an <em>iterable<\/em> because it implements the iterator protocol. In a user-defined class, you can implement the <code>__iter__()<\/code> method to make instances of your class iterable. This method should return an <em>iterator<\/em>. An iterator is an object with a <code>next()<\/code> method. It is possible to implement both <code>__iter__()<\/code> and <code>next()<\/code> on the same class, and have <code>__iter__()<\/code> return <code>self<\/code>. This will work for simple cases, but not when you want two iterators looping over the same object at the same time.<\/p>\n<p>So that's the iterator protocol, many objects implement this protocol:<\/p>\n<ol>\n<li>Built-in lists, dictionaries, tuples, sets, and files.<\/li>\n<li>User-defined classes that implement <code>__iter__()<\/code>.<\/li>\n<li>Generators.<\/li>\n<\/ol>\n<p>Note that a <code>for<\/code> loop doesn't know what kind of object it's dealing with - it just follows the iterator protocol, and is happy to get item after item as it calls <code>next()<\/code>. Built-in lists return their items one by one, dictionaries return the <em>keys<\/em> one by one, files return the <em>lines<\/em> one by one, etc. And generators return... well that's where <code>yield<\/code> comes in:<\/p>\n<pre><code>def f123():\n    yield 1\n    yield 2\n    yield 3\n\nfor item in f123():\n    print item\n<\/code><\/pre>\n<p>Instead of <code>yield<\/code> statements, if you had three <code>return<\/code> statements in <code>f123()<\/code> only the first would get executed, and the function would exit. But <code>f123()<\/code> is no ordinary function. When <code>f123()<\/code> is called, it <em>does not<\/em> return any of the values in the yield statements! It returns a generator object. Also, the function does not really exit - it goes into a suspended state. When the <code>for<\/code> loop tries to loop over the generator object, the function resumes from its suspended state at the very next line after the <code>yield<\/code> it previously returned from, executes the next line of code, in this case, a <code>yield<\/code> statement, and returns that as the next item. This happens until the function exits, at which point the generator raises <code>StopIteration<\/code>, and the loop exits.<\/p>\n<p>So the generator object is sort of like an adapter - at one end it exhibits the iterator protocol, by exposing <code>__iter__()<\/code> and <code>next()<\/code> methods to keep the <code>for<\/code> loop happy. At the other end, however, it runs the function just enough to get the next value out of it and puts it back in suspended mode.<\/p>\n<h2>Why use generators?<\/h2>\n<p>Usually, you can write code that doesn't use generators but implements the same logic. One option is to use the temporary list 'trick' I mentioned before. That will not work in all cases, for e.g. if you have infinite loops, or it may make inefficient use of memory when you have a really long list. The other approach is to implement a new iterable class <code>SomethingIter<\/code> that keeps the state in instance members and performs the next logical step in its <code>next()<\/code> (or <code>__next__()<\/code> in Python 3) method. Depending on the logic, the code inside the <code>next()<\/code> method may end up looking very complex and prone to bugs. Here generators provide a clean and easy solution.<\/p>\n",
        "community_owned_date": null
    },
    {
        "owner": {
            "user_type": "does_not_exist",
            "display_name": "unbeknown"
        },
        "is_accepted": true,
        "score": 2517,
        "last_activity_date": 1528168719,
        "last_edit_date": 1528168719,
        "creation_date": 1236622884,
        "answer_id": 627453,
        "question_id": 627435,
        "content_license": "CC BY-SA 4.0",
        "body_markdown": "Use `del` and specify the index of the element you want to delete:\r\n\r\n    &gt;&gt;&gt; a = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\r\n    &gt;&gt;&gt; del a[-1]\r\n    &gt;&gt;&gt; a\r\n    [0, 1, 2, 3, 4, 5, 6, 7, 8]\r\n\r\nAlso supports slices:\r\n\r\n    &gt;&gt;&gt; del a[2:4]\r\n    &gt;&gt;&gt; a\r\n    [0, 1, 4, 5, 6, 7, 8, 9]\r\n\r\n\r\n[Here][1] is the section from the tutorial.\r\n\r\n\r\n  [1]: http:\/\/docs.python.org\/tutorial\/datastructures.html#the-del-statement",
        "body": "<p>Use <code>del<\/code> and specify the index of the element you want to delete:<\/p>\n\n<pre><code>&gt;&gt;&gt; a = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n&gt;&gt;&gt; del a[-1]\n&gt;&gt;&gt; a\n[0, 1, 2, 3, 4, 5, 6, 7, 8]\n<\/code><\/pre>\n\n<p>Also supports slices:<\/p>\n\n<pre><code>&gt;&gt;&gt; del a[2:4]\n&gt;&gt;&gt; a\n[0, 1, 4, 5, 6, 7, 8, 9]\n<\/code><\/pre>\n\n<p><a href=\"http:\/\/docs.python.org\/tutorial\/datastructures.html#the-del-statement\" rel=\"noreferrer\">Here<\/a> is the section from the tutorial.<\/p>\n",
        "community_owned_date": null
    },
    {
        "owner": {
            "account_id": 21978,
            "reputation": 97978,
            "user_id": 53850,
            "user_type": "registered",
            "profile_image": "https:\/\/www.gravatar.com\/avatar\/26b8c45762e996c0de755eb3c7f421a8?s=256&d=identicon&r=PG",
            "display_name": "sykora",
            "link": "https:\/\/stackoverflow.com\/users\/53850\/sykora"
        },
        "is_accepted": true,
        "score": 2515,
        "last_activity_date": 1584634343,
        "last_edit_date": 1584634343,
        "creation_date": 1233748932,
        "answer_id": 511059,
        "question_id": 510972,
        "content_license": "CC BY-SA 4.0",
        "body_markdown": "Have you tried the [``__name__`` attribute][1] of the class? ie ``type(x).__name__`` will give you the name of the class, which I think is what you want.\r\n\r\n    &gt;&gt;&gt; import itertools\r\n    &gt;&gt;&gt; x = itertools.count(0)\r\n    &gt;&gt;&gt; type(x).__name__\r\n    &#39;count&#39;\r\n\r\nIf you&#39;re still using Python 2, note that the above method works with [new-style classes][2] only (in Python 3+ all classes are &quot;new-style&quot; classes). Your code might use some old-style classes. The following works for both:\r\n\r\n    x.__class__.__name__\r\n\r\n\r\n  [1]: https:\/\/docs.python.org\/library\/stdtypes.html#definition.__name__\r\n  [2]: https:\/\/wiki.python.org\/moin\/NewClassVsClassicClass",
        "body": "<p>Have you tried the <a href=\"https:\/\/docs.python.org\/library\/stdtypes.html#definition.__name__\" rel=\"noreferrer\"><code>__name__<\/code> attribute<\/a> of the class? ie <code>type(x).__name__<\/code> will give you the name of the class, which I think is what you want.<\/p>\n\n<pre><code>&gt;&gt;&gt; import itertools\n&gt;&gt;&gt; x = itertools.count(0)\n&gt;&gt;&gt; type(x).__name__\n'count'\n<\/code><\/pre>\n\n<p>If you're still using Python 2, note that the above method works with <a href=\"https:\/\/wiki.python.org\/moin\/NewClassVsClassicClass\" rel=\"noreferrer\">new-style classes<\/a> only (in Python 3+ all classes are \"new-style\" classes). Your code might use some old-style classes. The following works for both:<\/p>\n\n<pre><code>x.__class__.__name__\n<\/code><\/pre>\n",
        "community_owned_date": null
    },
    {
        "owner": {
            "account_id": 3465,
            "reputation": 35381,
            "user_id": 4999,
            "user_type": "registered",
            "accept_rate": 100,
            "profile_image": "https:\/\/www.gravatar.com\/avatar\/ae995fa03b218e7c27a608b5f14e68ae?s=256&d=identicon&r=PG",
            "display_name": "\u0141ukasz",
            "link": "https:\/\/stackoverflow.com\/users\/4999\/%c5%81ukasz"
        },
        "is_accepted": true,
        "score": 2492,
        "last_activity_date": 1648552843,
        "last_edit_date": 1648552843,
        "creation_date": 1270733512,
        "answer_id": 2600208,
        "question_id": 2600191,
        "content_license": "CC BY-SA 4.0",
        "body_markdown": "If you only want a single item&#39;s count, use the `count` method:\r\n\r\n    &gt;&gt;&gt; [1, 2, 3, 4, 1, 4, 1].count(1)\r\n    3\r\n\r\n---\r\n\r\n#### **Important: this is very slow if you are counting *multiple* different items**\r\n\r\nEach `count` call goes over the entire list of `n` elements. Calling `count` in a loop `n` times means `n * n` total checks, which can be catastrophic for performance.\r\n\r\nIf you want to count multiple items, use [`Counter`](https:\/\/stackoverflow.com\/a\/5829377\/365102), which only does `n` total checks.",
        "body": "<p>If you only want a single item's count, use the <code>count<\/code> method:<\/p>\n<pre><code>&gt;&gt;&gt; [1, 2, 3, 4, 1, 4, 1].count(1)\n3\n<\/code><\/pre>\n<hr \/>\n<h4><strong>Important: this is very slow if you are counting <em>multiple<\/em> different items<\/strong><\/h4>\n<p>Each <code>count<\/code> call goes over the entire list of <code>n<\/code> elements. Calling <code>count<\/code> in a loop <code>n<\/code> times means <code>n * n<\/code> total checks, which can be catastrophic for performance.<\/p>\n<p>If you want to count multiple items, use <a href=\"https:\/\/stackoverflow.com\/a\/5829377\/365102\"><code>Counter<\/code><\/a>, which only does <code>n<\/code> total checks.<\/p>\n",
        "community_owned_date": null
    },
    {
        "owner": {
            "account_id": 680,
            "reputation": 961801,
            "user_id": 893,
            "user_type": "registered",
            "accept_rate": 84,
            "profile_image": "https:\/\/www.gravatar.com\/avatar\/747ffa5da3538e66840ebc0548b8fd58?s=256&d=identicon&r=PG",
            "display_name": "Greg Hewgill",
            "link": "https:\/\/stackoverflow.com\/users\/893\/greg-hewgill"
        },
        "is_accepted": true,
        "score": 2484,
        "last_activity_date": 1609100249,
        "last_edit_date": 1609100249,
        "creation_date": 1304198739,
        "answer_id": 5844692,
        "question_id": 5844672,
        "content_license": "CC BY-SA 4.0",
        "body_markdown": "The [`del` statement](http:\/\/docs.python.org\/reference\/simple_stmts.html#the-del-statement) removes an element:\r\n\r\n    del d[key]\r\n\r\nNote that this mutates the existing dictionary, so the contents of the dictionary changes for anybody else who has a reference to the same instance. To return a *new* dictionary, make a copy of the dictionary:\r\n\r\n    def removekey(d, key):\r\n        r = dict(d)\r\n        del r[key]\r\n        return r\r\n\r\nThe `dict()` constructor makes a *shallow copy*. To make a deep copy, see the [`copy` module](https:\/\/docs.python.org\/library\/copy.html).\r\n\r\n---\r\n\r\nNote that making a copy for every dict `del`\/assignment\/etc. means you&#39;re going from constant time to linear time, and also using linear space. For small dicts, this is not a problem. But if you&#39;re planning to make lots of copies of large dicts, you probably want a different data structure, like a HAMT (as described in [this answer](https:\/\/stackoverflow.com\/a\/50341031\/908494)).",
        "body": "<p>The <a href=\"http:\/\/docs.python.org\/reference\/simple_stmts.html#the-del-statement\" rel=\"noreferrer\"><code>del<\/code> statement<\/a> removes an element:<\/p>\n<pre><code>del d[key]\n<\/code><\/pre>\n<p>Note that this mutates the existing dictionary, so the contents of the dictionary changes for anybody else who has a reference to the same instance. To return a <em>new<\/em> dictionary, make a copy of the dictionary:<\/p>\n<pre><code>def removekey(d, key):\n    r = dict(d)\n    del r[key]\n    return r\n<\/code><\/pre>\n<p>The <code>dict()<\/code> constructor makes a <em>shallow copy<\/em>. To make a deep copy, see the <a href=\"https:\/\/docs.python.org\/library\/copy.html\" rel=\"noreferrer\"><code>copy<\/code> module<\/a>.<\/p>\n<hr \/>\n<p>Note that making a copy for every dict <code>del<\/code>\/assignment\/etc. means you're going from constant time to linear time, and also using linear space. For small dicts, this is not a problem. But if you're planning to make lots of copies of large dicts, you probably want a different data structure, like a HAMT (as described in <a href=\"https:\/\/stackoverflow.com\/a\/50341031\/908494\">this answer<\/a>).<\/p>\n",
        "community_owned_date": null
    },
    {
        "owner": {
            "account_id": 152622,
            "reputation": 490342,
            "user_id": 367273,
            "user_type": "registered",
            "accept_rate": 96,
            "profile_image": "https:\/\/www.gravatar.com\/avatar\/f1ed2b0c87f602ef30229f5c4b04eff6?s=256&d=identicon&r=PG",
            "display_name": "NPE",
            "link": "https:\/\/stackoverflow.com\/users\/367273\/npe"
        },
        "is_accepted": false,
        "score": 2467,
        "last_activity_date": 1655082369,
        "last_edit_date": 1655082369,
        "creation_date": 1315646816,
        "answer_id": 7370824,
        "question_id": 7370801,
        "content_license": "CC BY-SA 4.0",
        "body_markdown": "Use [`time.time()`][1] to measure the elapsed wall-clock time between two points:\r\n\r\n    import time\r\n    \r\n    start = time.time()\r\n    print(&quot;hello&quot;)\r\n    end = time.time()\r\n    print(end - start)\r\n\r\nThis gives the execution time in seconds.\r\n\r\n---\r\n\r\nAnother option since Python 3.3 might be to use [`perf_counter`][2] or [`process_time`][3], depending on your requirements. Before 3.3 it was recommended to use [`time.clock`][4] (thanks [Amber][5]). However, it is currently deprecated:\r\n\r\n&gt; On Unix, return the current processor time as a floating point number\r\n&gt; expressed in seconds. The precision, and in fact the very definition\r\n&gt; of the meaning of \u201cprocessor time\u201d, depends on that of the C function\r\n&gt; of the same name.\r\n&gt; \r\n&gt; On Windows, this function returns wall-clock seconds elapsed since the\r\n&gt; first call to this function, as a floating point number, based on the\r\n&gt; Win32 function `QueryPerformanceCounter()`. The resolution is typically\r\n&gt; better than one microsecond.\r\n&gt; \r\n&gt; *Deprecated since version 3.3*: The behaviour of this function depends\r\n&gt; on the platform: **use `perf_counter()` or `process_time()` instead**,\r\n&gt; depending on your requirements, to have a well defined behaviour.\r\n\r\n\r\n  [1]: http:\/\/docs.python.org\/library\/time.html#time.time\r\n  [2]: https:\/\/docs.python.org\/3\/library\/time.html#time.perf_counter\r\n  [3]: https:\/\/docs.python.org\/3\/library\/time.html#time.process_time\r\n  [4]: http:\/\/docs.python.org\/library\/time.html#time.clock\r\n  [5]: https:\/\/stackoverflow.com\/users\/148870\/amber",
        "body": "<p>Use <a href=\"http:\/\/docs.python.org\/library\/time.html#time.time\" rel=\"noreferrer\"><code>time.time()<\/code><\/a> to measure the elapsed wall-clock time between two points:<\/p>\n<pre><code>import time\n\nstart = time.time()\nprint(&quot;hello&quot;)\nend = time.time()\nprint(end - start)\n<\/code><\/pre>\n<p>This gives the execution time in seconds.<\/p>\n<hr \/>\n<p>Another option since Python 3.3 might be to use <a href=\"https:\/\/docs.python.org\/3\/library\/time.html#time.perf_counter\" rel=\"noreferrer\"><code>perf_counter<\/code><\/a> or <a href=\"https:\/\/docs.python.org\/3\/library\/time.html#time.process_time\" rel=\"noreferrer\"><code>process_time<\/code><\/a>, depending on your requirements. Before 3.3 it was recommended to use <a href=\"http:\/\/docs.python.org\/library\/time.html#time.clock\" rel=\"noreferrer\"><code>time.clock<\/code><\/a> (thanks <a href=\"https:\/\/stackoverflow.com\/users\/148870\/amber\">Amber<\/a>). However, it is currently deprecated:<\/p>\n<blockquote>\n<p>On Unix, return the current processor time as a floating point number\nexpressed in seconds. The precision, and in fact the very definition\nof the meaning of \u201cprocessor time\u201d, depends on that of the C function\nof the same name.<\/p>\n<p>On Windows, this function returns wall-clock seconds elapsed since the\nfirst call to this function, as a floating point number, based on the\nWin32 function <code>QueryPerformanceCounter()<\/code>. The resolution is typically\nbetter than one microsecond.<\/p>\n<p><em>Deprecated since version 3.3<\/em>: The behaviour of this function depends\non the platform: <strong>use <code>perf_counter()<\/code> or <code>process_time()<\/code> instead<\/strong>,\ndepending on your requirements, to have a well defined behaviour.<\/p>\n<\/blockquote>\n",
        "community_owned_date": null
    },
    {
        "owner": {
            "account_id": 6321039,
            "reputation": 386303,
            "user_id": 4909087,
            "user_type": "registered",
            "accept_rate": 97,
            "profile_image": "https:\/\/i.stack.imgur.com\/Zcszo.png?s=256&g=1",
            "display_name": "cs95",
            "link": "https:\/\/stackoverflow.com\/users\/4909087\/cs95"
        },
        "is_accepted": false,
        "score": 2393,
        "last_activity_date": 1695185139,
        "last_edit_date": 1695185139,
        "creation_date": 1554631434,
        "answer_id": 55557758,
        "question_id": 16476924,
        "content_license": "CC BY-SA 4.0",
        "body_markdown": "&gt;## How to iterate over rows in a DataFrame in Pandas\r\n\r\n# Answer: DON&#39;T&lt;sup&gt;*&lt;\/sup&gt;!\r\n\r\nIteration in Pandas is an anti-pattern and is something you should only do when you have exhausted every other option. You should not use any function with &quot;`iter`&quot; in its name for more than a few thousand rows or you will have to get used to a **lot** of waiting.\r\n\r\nDo you want to print a DataFrame? Use [**`DataFrame.to_string()`**][1].\r\n\r\nDo you want to compute something? In that case, search for methods in this order (list modified from [here][2]):\r\n\r\n1. Vectorization\r\n2. [Cython][3] routines\r\n3. List Comprehensions (vanilla `for` loop)\r\n4. [**`DataFrame.apply()`**][4]: i) &amp;nbsp;Reductions that can be performed in Cython, ii) Iteration in Python space\r\n5. [**`items()`**][5]  &lt;strike&gt;[**`iteritems()`**][6]&lt;\/strike&gt; &lt;sup&gt;(deprecated since v1.5.0)&lt;\/sup&gt; \r\n6. [**`DataFrame.itertuples()`**][7]\r\n7. [**`DataFrame.iterrows()`**][8]\r\n\r\n`iterrows` and `itertuples` (both receiving many votes in answers to this question) should be used in very rare circumstances, such as generating row objects\/nametuples for sequential processing, which is really the only thing these functions are useful for.\r\n\r\n**Appeal to Authority**\r\n\r\n[The documentation page][9] on iteration has a huge red warning box that says:\r\n\r\n&gt; Iterating through pandas objects is generally slow. In many cases, iterating manually over the rows is not needed [...].\r\n\r\n&lt;sub&gt;* It&#39;s actually a little more complicated than &quot;don&#39;t&quot;. `df.iterrows()` is the correct answer to this question, but &quot;vectorize your ops&quot; is the better one. I will concede that there are circumstances where iteration cannot be avoided (for example, some operations where the result depends on the value computed for the previous row). However, it takes some familiarity with the library to know when. If you&#39;re not sure whether you need an iterative solution, you probably don&#39;t. PS: To know more about my rationale for writing this answer, skip to the very bottom.&lt;\/sub&gt;\r\n\r\n----\r\n\r\n## Faster than Looping: [Vectorization][10], [Cython][11]\r\n\r\nA good number of basic operations and computations are &quot;vectorised&quot; by pandas (either through NumPy, or through Cythonized functions). This includes arithmetic, comparisons, (most) reductions, reshaping (such as pivoting), joins, and groupby operations. Look through the documentation on [Essential Basic Functionality][12] to find a suitable vectorised method for your problem.\r\n\r\nIf none exists, feel free to write your own using custom [Cython extensions][13].\r\n\r\n----\r\n## Next Best Thing: [List Comprehensions][14]&lt;sup&gt;*&lt;\/sup&gt;\r\n\r\nList comprehensions should be your next port of call if 1) there is no vectorized solution available, 2) performance is important, but not important enough to go through the hassle of cythonizing your code, and 3) you&#39;re trying to perform elementwise transformation on your code. There is a [good amount of evidence][15] to suggest that list comprehensions are sufficiently fast (and even sometimes faster) for many common Pandas tasks.\r\n\r\n\r\nThe formula is simple,\r\n\r\n```py\r\n# Iterating over one column - `f` is some function that processes your data\r\nresult = [f(x) for x in df[&#39;col&#39;]]\r\n\r\n# Iterating over two columns, use `zip`\r\nresult = [f(x, y) for x, y in zip(df[&#39;col1&#39;], df[&#39;col2&#39;])]\r\n\r\n# Iterating over multiple columns - same data type\r\nresult = [f(row[0], ..., row[n]) for row in df[[&#39;col1&#39;, ...,&#39;coln&#39;]].to_numpy()]\r\n\r\n# Iterating over multiple columns - differing data type\r\nresult = [f(row[0], ..., row[n]) for row in zip(df[&#39;col1&#39;], ..., df[&#39;coln&#39;])]\r\n```\r\n\r\nIf you can encapsulate your business logic into a function, you can use a list comprehension that calls it. You can make arbitrarily complex things work through the simplicity and speed of raw Python code.\r\n\r\n**Caveats**\r\n\r\nList comprehensions assume that your data is easy to work with - what that means is your data types are consistent and you don&#39;t have NaNs, but this cannot always be guaranteed.\r\n\r\n1. The first one is more obvious, but when dealing with NaNs, prefer in-built pandas methods if they exist (because they have much better corner-case handling logic), or ensure your business logic includes appropriate NaN handling logic.\r\n2. When dealing with mixed data types you should iterate over `zip(df[&#39;A&#39;], df[&#39;B&#39;], ...)` instead of `df[[&#39;A&#39;, &#39;B&#39;]].to_numpy()` as the latter implicitly upcasts data to the most common type. As an example if A is numeric and B is string, `to_numpy()` will cast the entire array to string, which may not be what you want. Fortunately `zip`ping your columns together is the most straightforward workaround to this.\r\n\r\n&lt;sub&gt;*Your mileage may vary for the reasons outlined in the **Caveats** section above.&lt;\/sub&gt;\r\n\r\n----\r\n\r\n## An Obvious Example\r\n\r\nLet&#39;s demonstrate the difference with a simple example of adding two pandas columns `A + B`. This is a vectorizable operation, so it will be easy to contrast the performance of the methods discussed above.\r\n\r\n&lt;img src=&quot;https:\/\/i.stack.imgur.com\/y44RJ.png&quot; width=&quot;600&quot; \/&gt;\r\n\r\n[Benchmarking code, for your reference][16]. The line at the bottom measures a function written in numpandas, a style of Pandas that mixes heavily with NumPy to squeeze out maximum performance. Writing numpandas code should be avoided unless you know what you&#39;re doing. Stick to the API where you can (i.e., prefer `vec` over `vec_numpy`).\r\n\r\nI should mention, however, that it isn&#39;t always this cut and dry. Sometimes the answer to &quot;what is the best method for an operation&quot; is &quot;it depends on your data&quot;. My advice is to test out different approaches on your data before settling on one.\r\n\r\n\r\n----\r\n\r\n## My Personal Opinion &lt;sup&gt;*&lt;\/sup&gt;\r\n\r\nMost of the analyses performed on the various alternatives to the iter family has been through the lens of performance. However, in most situations you will typically be working on a reasonably sized dataset (nothing beyond a few thousand or 100K rows) and performance will come second to simplicity\/readability of the solution.\r\n\r\nHere is my personal preference when selecting a method to use for a problem.\r\n\r\nFor the novice:\r\n\r\n&gt; *Vectorization* (when possible)*; `apply()`; List Comprehensions; `itertuples()`\/`iteritems()`; `iterrows()`; Cython*\r\n\r\nFor the more experienced:\r\n\r\n&gt; *Vectorization* (when possible)*; `apply()`; List Comprehensions; Cython; `itertuples()`\/`iteritems()`; `iterrows()`*\r\n\r\nVectorization prevails as the most idiomatic method for any problem that can be vectorized. Always seek to vectorize! When in doubt, consult the docs, or look on Stack Overflow for an existing question on your particular task.\r\n\r\nI do tend to go on about how bad `apply` is in a lot of my posts, but I do concede it is easier for a beginner to wrap their head around what it&#39;s doing. Additionally, there are quite a few use cases for `apply` has explained in [this post of mine](https:\/\/stackoverflow.com\/questions\/54432583\/when-should-i-not-want-to-use-pandas-apply-in-my-code).\r\n\r\nCython ranks lower down on the list because it takes more time and effort to pull off correctly. You will usually never need to write code with pandas that demands this level of performance that even a list comprehension cannot satisfy.\r\n\r\n&lt;sub&gt;* As with any personal opinion, please take with heaps of salt!&lt;\/sub&gt;\r\n\r\n----\r\n\r\n## Further Reading\r\n\r\n- [10 Minutes to pandas][17], and [Essential Basic Functionality][18] - Useful links that introduce you to Pandas and its library of vectorized*\/cythonized functions.\r\n\r\n- [Enhancing Performance][19] - A primer from the documentation on enhancing standard Pandas operations\r\n\r\n- *https:\/\/stackoverflow.com\/questions\/54028199\/for-loops-with-pandas-when-should-i-care* - a detailed write-up by me on list comprehensions and their suitability for various operations (mainly ones involving non-numeric data)\r\n\r\n- *https:\/\/stackoverflow.com\/questions\/54432583\/when-should-i-ever-want-to-use-pandas-apply-in-my-code* - `apply` is slow (but not as slow as the `iter*` family. There are, however, situations where one can (or should) consider `apply` as a serious alternative, especially in some `GroupBy` operations).\r\n\r\n&lt;sub&gt;* Pandas string methods are &quot;vectorized&quot; in the sense that they are specified on the series but operate on each element. The underlying mechanisms are still iterative, because string operations are inherently hard to vectorize.&lt;\/sub&gt;\r\n\r\n---\r\n\r\n## Why I Wrote this Answer\r\n\r\nA common trend I notice from new users is to ask questions of the form &quot;How can I iterate over my df to do X?&quot;. Showing code that calls `iterrows()` while doing something inside a `for` loop. Here is why. A new user to the library who has not been introduced to the concept of vectorization will likely envision the code that solves their problem as iterating over their data to do something. Not knowing how to iterate over a DataFrame, the first thing they do is Google it and end up here, at this question. They then see the accepted answer telling them how to, and they close their eyes and run this code without ever first questioning if iteration is the right thing to do.\r\n\r\nThe aim of this answer is to help new users understand that iteration is not necessarily the solution to every problem, and that better, faster and more idiomatic solutions could exist, and that it is worth investing time in exploring them. I&#39;m not trying to start a war of iteration vs. vectorization, but I want new users to be informed when developing solutions to their problems with this library.\r\n\r\nAnd finally ... a TLDR to summarize this post\r\n\r\n[![enter image description here][20]][20]\r\n\r\n\r\n  [1]: https:\/\/pandas.pydata.org\/pandas-docs\/stable\/reference\/api\/pandas.DataFrame.to_string.html\r\n  [2]: https:\/\/stackoverflow.com\/questions\/24870953\/does-iterrows-have-performance-issues\r\n  [3]: https:\/\/en.wikipedia.org\/wiki\/Cython\r\n  [4]: https:\/\/pandas.pydata.org\/pandas-docs\/stable\/reference\/api\/pandas.DataFrame.apply.html\r\n  [5]: https:\/\/pandas.pydata.org\/pandas-docs\/stable\/reference\/api\/pandas.DataFrame.items.html\r\n  [6]: https:\/\/pandas.pydata.org\/pandas-docs\/version\/1.5\/reference\/api\/pandas.DataFrame.iteritems.html\r\n  [7]: https:\/\/pandas.pydata.org\/pandas-docs\/stable\/reference\/api\/pandas.DataFrame.itertuples.html\r\n  [8]: https:\/\/pandas.pydata.org\/pandas-docs\/stable\/reference\/api\/pandas.DataFrame.iterrows.html#pandas.DataFrame.iterrows\r\n  [9]: https:\/\/pandas.pydata.org\/pandas-docs\/stable\/user_guide\/basics.html#iteration\r\n  [10]: https:\/\/stackoverflow.com\/questions\/1422149\/what-is-vectorization\r\n  [11]: https:\/\/cython.org\r\n  [12]: https:\/\/pandas.pydata.org\/pandas-docs\/stable\/user_guide\/basics.html#essential-basic-functionality\r\n  [13]: https:\/\/pandas.pydata.org\/pandas-docs\/stable\/user_guide\/enhancingperf.html#cython-writing-c-extensions-for-pandas\r\n  [14]: https:\/\/docs.python.org\/3\/tutorial\/datastructures.html#list-comprehensions\r\n  [15]: https:\/\/stackoverflow.com\/questions\/54028199\/for-loops-with-pandas-when-should-i-care\r\n  [16]: https:\/\/gist.github.com\/Coldsp33d\/948f96b384ca5bdf6e8ce203ac97c9a0\r\n  [17]: https:\/\/pandas.pydata.org\/pandas-docs\/stable\/user_guide\/10min.html\r\n  [18]: https:\/\/pandas.pydata.org\/pandas-docs\/stable\/user_guide\/basics.html\r\n  [19]: https:\/\/pandas.pydata.org\/pandas-docs\/stable\/user_guide\/enhancingperf.html\r\n  [20]: https:\/\/i.stack.imgur.com\/FYfgi.jpg",
        "body": "<blockquote>\n<h2>How to iterate over rows in a DataFrame in Pandas<\/h2>\n<\/blockquote>\n<h1>Answer: DON'T<sup>*<\/sup>!<\/h1>\n<p>Iteration in Pandas is an anti-pattern and is something you should only do when you have exhausted every other option. You should not use any function with &quot;<code>iter<\/code>&quot; in its name for more than a few thousand rows or you will have to get used to a <strong>lot<\/strong> of waiting.<\/p>\n<p>Do you want to print a DataFrame? Use <a href=\"https:\/\/pandas.pydata.org\/pandas-docs\/stable\/reference\/api\/pandas.DataFrame.to_string.html\" rel=\"noreferrer\"><strong><code>DataFrame.to_string()<\/code><\/strong><\/a>.<\/p>\n<p>Do you want to compute something? In that case, search for methods in this order (list modified from <a href=\"https:\/\/stackoverflow.com\/questions\/24870953\/does-iterrows-have-performance-issues\">here<\/a>):<\/p>\n<ol>\n<li>Vectorization<\/li>\n<li><a href=\"https:\/\/en.wikipedia.org\/wiki\/Cython\" rel=\"noreferrer\">Cython<\/a> routines<\/li>\n<li>List Comprehensions (vanilla <code>for<\/code> loop)<\/li>\n<li><a href=\"https:\/\/pandas.pydata.org\/pandas-docs\/stable\/reference\/api\/pandas.DataFrame.apply.html\" rel=\"noreferrer\"><strong><code>DataFrame.apply()<\/code><\/strong><\/a>: i) \u00a0Reductions that can be performed in Cython, ii) Iteration in Python space<\/li>\n<li><a href=\"https:\/\/pandas.pydata.org\/pandas-docs\/stable\/reference\/api\/pandas.DataFrame.items.html\" rel=\"noreferrer\"><strong><code>items()<\/code><\/strong><\/a>  <strike><a href=\"https:\/\/pandas.pydata.org\/pandas-docs\/version\/1.5\/reference\/api\/pandas.DataFrame.iteritems.html\" rel=\"noreferrer\"><strong><code>iteritems()<\/code><\/strong><\/a><\/strike> <sup>(deprecated since v1.5.0)<\/sup><\/li>\n<li><a href=\"https:\/\/pandas.pydata.org\/pandas-docs\/stable\/reference\/api\/pandas.DataFrame.itertuples.html\" rel=\"noreferrer\"><strong><code>DataFrame.itertuples()<\/code><\/strong><\/a><\/li>\n<li><a href=\"https:\/\/pandas.pydata.org\/pandas-docs\/stable\/reference\/api\/pandas.DataFrame.iterrows.html#pandas.DataFrame.iterrows\" rel=\"noreferrer\"><strong><code>DataFrame.iterrows()<\/code><\/strong><\/a><\/li>\n<\/ol>\n<p><code>iterrows<\/code> and <code>itertuples<\/code> (both receiving many votes in answers to this question) should be used in very rare circumstances, such as generating row objects\/nametuples for sequential processing, which is really the only thing these functions are useful for.<\/p>\n<p><strong>Appeal to Authority<\/strong><\/p>\n<p><a href=\"https:\/\/pandas.pydata.org\/pandas-docs\/stable\/user_guide\/basics.html#iteration\" rel=\"noreferrer\">The documentation page<\/a> on iteration has a huge red warning box that says:<\/p>\n<blockquote>\n<p>Iterating through pandas objects is generally slow. In many cases, iterating manually over the rows is not needed [...].<\/p>\n<\/blockquote>\n<p><sub>* It's actually a little more complicated than &quot;don't&quot;. <code>df.iterrows()<\/code> is the correct answer to this question, but &quot;vectorize your ops&quot; is the better one. I will concede that there are circumstances where iteration cannot be avoided (for example, some operations where the result depends on the value computed for the previous row). However, it takes some familiarity with the library to know when. If you're not sure whether you need an iterative solution, you probably don't. PS: To know more about my rationale for writing this answer, skip to the very bottom.<\/sub><\/p>\n<hr \/>\n<h2>Faster than Looping: <a href=\"https:\/\/stackoverflow.com\/questions\/1422149\/what-is-vectorization\">Vectorization<\/a>, <a href=\"https:\/\/cython.org\" rel=\"noreferrer\">Cython<\/a><\/h2>\n<p>A good number of basic operations and computations are &quot;vectorised&quot; by pandas (either through NumPy, or through Cythonized functions). This includes arithmetic, comparisons, (most) reductions, reshaping (such as pivoting), joins, and groupby operations. Look through the documentation on <a href=\"https:\/\/pandas.pydata.org\/pandas-docs\/stable\/user_guide\/basics.html#essential-basic-functionality\" rel=\"noreferrer\">Essential Basic Functionality<\/a> to find a suitable vectorised method for your problem.<\/p>\n<p>If none exists, feel free to write your own using custom <a href=\"https:\/\/pandas.pydata.org\/pandas-docs\/stable\/user_guide\/enhancingperf.html#cython-writing-c-extensions-for-pandas\" rel=\"noreferrer\">Cython extensions<\/a>.<\/p>\n<hr \/>\n<h2>Next Best Thing: <a href=\"https:\/\/docs.python.org\/3\/tutorial\/datastructures.html#list-comprehensions\" rel=\"noreferrer\">List Comprehensions<\/a><sup>*<\/sup><\/h2>\n<p>List comprehensions should be your next port of call if 1) there is no vectorized solution available, 2) performance is important, but not important enough to go through the hassle of cythonizing your code, and 3) you're trying to perform elementwise transformation on your code. There is a <a href=\"https:\/\/stackoverflow.com\/questions\/54028199\/for-loops-with-pandas-when-should-i-care\">good amount of evidence<\/a> to suggest that list comprehensions are sufficiently fast (and even sometimes faster) for many common Pandas tasks.<\/p>\n<p>The formula is simple,<\/p>\n<pre class=\"lang-py prettyprint-override\"><code># Iterating over one column - `f` is some function that processes your data\nresult = [f(x) for x in df['col']]\n\n# Iterating over two columns, use `zip`\nresult = [f(x, y) for x, y in zip(df['col1'], df['col2'])]\n\n# Iterating over multiple columns - same data type\nresult = [f(row[0], ..., row[n]) for row in df[['col1', ...,'coln']].to_numpy()]\n\n# Iterating over multiple columns - differing data type\nresult = [f(row[0], ..., row[n]) for row in zip(df['col1'], ..., df['coln'])]\n<\/code><\/pre>\n<p>If you can encapsulate your business logic into a function, you can use a list comprehension that calls it. You can make arbitrarily complex things work through the simplicity and speed of raw Python code.<\/p>\n<p><strong>Caveats<\/strong><\/p>\n<p>List comprehensions assume that your data is easy to work with - what that means is your data types are consistent and you don't have NaNs, but this cannot always be guaranteed.<\/p>\n<ol>\n<li>The first one is more obvious, but when dealing with NaNs, prefer in-built pandas methods if they exist (because they have much better corner-case handling logic), or ensure your business logic includes appropriate NaN handling logic.<\/li>\n<li>When dealing with mixed data types you should iterate over <code>zip(df['A'], df['B'], ...)<\/code> instead of <code>df[['A', 'B']].to_numpy()<\/code> as the latter implicitly upcasts data to the most common type. As an example if A is numeric and B is string, <code>to_numpy()<\/code> will cast the entire array to string, which may not be what you want. Fortunately <code>zip<\/code>ping your columns together is the most straightforward workaround to this.<\/li>\n<\/ol>\n<p><sub>*Your mileage may vary for the reasons outlined in the <strong>Caveats<\/strong> section above.<\/sub><\/p>\n<hr \/>\n<h2>An Obvious Example<\/h2>\n<p>Let's demonstrate the difference with a simple example of adding two pandas columns <code>A + B<\/code>. This is a vectorizable operation, so it will be easy to contrast the performance of the methods discussed above.<\/p>\n<img src=\"https:\/\/i.stack.imgur.com\/y44RJ.png\" width=\"600\" \/>\n<p><a href=\"https:\/\/gist.github.com\/Coldsp33d\/948f96b384ca5bdf6e8ce203ac97c9a0\" rel=\"noreferrer\">Benchmarking code, for your reference<\/a>. The line at the bottom measures a function written in numpandas, a style of Pandas that mixes heavily with NumPy to squeeze out maximum performance. Writing numpandas code should be avoided unless you know what you're doing. Stick to the API where you can (i.e., prefer <code>vec<\/code> over <code>vec_numpy<\/code>).<\/p>\n<p>I should mention, however, that it isn't always this cut and dry. Sometimes the answer to &quot;what is the best method for an operation&quot; is &quot;it depends on your data&quot;. My advice is to test out different approaches on your data before settling on one.<\/p>\n<hr \/>\n<h2>My Personal Opinion <sup>*<\/sup><\/h2>\n<p>Most of the analyses performed on the various alternatives to the iter family has been through the lens of performance. However, in most situations you will typically be working on a reasonably sized dataset (nothing beyond a few thousand or 100K rows) and performance will come second to simplicity\/readability of the solution.<\/p>\n<p>Here is my personal preference when selecting a method to use for a problem.<\/p>\n<p>For the novice:<\/p>\n<blockquote>\n<p><em>Vectorization<\/em> (when possible)<em>; <code>apply()<\/code>; List Comprehensions; <code>itertuples()<\/code>\/<code>iteritems()<\/code>; <code>iterrows()<\/code>; Cython<\/em><\/p>\n<\/blockquote>\n<p>For the more experienced:<\/p>\n<blockquote>\n<p><em>Vectorization<\/em> (when possible)<em>; <code>apply()<\/code>; List Comprehensions; Cython; <code>itertuples()<\/code>\/<code>iteritems()<\/code>; <code>iterrows()<\/code><\/em><\/p>\n<\/blockquote>\n<p>Vectorization prevails as the most idiomatic method for any problem that can be vectorized. Always seek to vectorize! When in doubt, consult the docs, or look on Stack Overflow for an existing question on your particular task.<\/p>\n<p>I do tend to go on about how bad <code>apply<\/code> is in a lot of my posts, but I do concede it is easier for a beginner to wrap their head around what it's doing. Additionally, there are quite a few use cases for <code>apply<\/code> has explained in <a href=\"https:\/\/stackoverflow.com\/questions\/54432583\/when-should-i-not-want-to-use-pandas-apply-in-my-code\">this post of mine<\/a>.<\/p>\n<p>Cython ranks lower down on the list because it takes more time and effort to pull off correctly. You will usually never need to write code with pandas that demands this level of performance that even a list comprehension cannot satisfy.<\/p>\n<p><sub>* As with any personal opinion, please take with heaps of salt!<\/sub><\/p>\n<hr \/>\n<h2>Further Reading<\/h2>\n<ul>\n<li><p><a href=\"https:\/\/pandas.pydata.org\/pandas-docs\/stable\/user_guide\/10min.html\" rel=\"noreferrer\">10 Minutes to pandas<\/a>, and <a href=\"https:\/\/pandas.pydata.org\/pandas-docs\/stable\/user_guide\/basics.html\" rel=\"noreferrer\">Essential Basic Functionality<\/a> - Useful links that introduce you to Pandas and its library of vectorized*\/cythonized functions.<\/p>\n<\/li>\n<li><p><a href=\"https:\/\/pandas.pydata.org\/pandas-docs\/stable\/user_guide\/enhancingperf.html\" rel=\"noreferrer\">Enhancing Performance<\/a> - A primer from the documentation on enhancing standard Pandas operations<\/p>\n<\/li>\n<li><p><em><a href=\"https:\/\/stackoverflow.com\/questions\/54028199\/for-loops-with-pandas-when-should-i-care\">Are for-loops in pandas really bad? When should I care?<\/a><\/em> - a detailed write-up by me on list comprehensions and their suitability for various operations (mainly ones involving non-numeric data)<\/p>\n<\/li>\n<li><p><em><a href=\"https:\/\/stackoverflow.com\/questions\/54432583\/when-should-i-ever-want-to-use-pandas-apply-in-my-code\">When should I (not) want to use pandas apply() in my code?<\/a><\/em> - <code>apply<\/code> is slow (but not as slow as the <code>iter*<\/code> family. There are, however, situations where one can (or should) consider <code>apply<\/code> as a serious alternative, especially in some <code>GroupBy<\/code> operations).<\/p>\n<\/li>\n<\/ul>\n<p><sub>* Pandas string methods are &quot;vectorized&quot; in the sense that they are specified on the series but operate on each element. The underlying mechanisms are still iterative, because string operations are inherently hard to vectorize.<\/sub><\/p>\n<hr \/>\n<h2>Why I Wrote this Answer<\/h2>\n<p>A common trend I notice from new users is to ask questions of the form &quot;How can I iterate over my df to do X?&quot;. Showing code that calls <code>iterrows()<\/code> while doing something inside a <code>for<\/code> loop. Here is why. A new user to the library who has not been introduced to the concept of vectorization will likely envision the code that solves their problem as iterating over their data to do something. Not knowing how to iterate over a DataFrame, the first thing they do is Google it and end up here, at this question. They then see the accepted answer telling them how to, and they close their eyes and run this code without ever first questioning if iteration is the right thing to do.<\/p>\n<p>The aim of this answer is to help new users understand that iteration is not necessarily the solution to every problem, and that better, faster and more idiomatic solutions could exist, and that it is worth investing time in exploring them. I'm not trying to start a war of iteration vs. vectorization, but I want new users to be informed when developing solutions to their problems with this library.<\/p>\n<p>And finally ... a TLDR to summarize this post<\/p>\n<p><a href=\"https:\/\/i.stack.imgur.com\/FYfgi.jpg\" rel=\"noreferrer\"><img src=\"https:\/\/i.stack.imgur.com\/FYfgi.jpg\" alt=\"enter image description here\" \/><\/a><\/p>\n",
        "community_owned_date": null
    },
    {
        "owner": {
            "account_id": 246250,
            "reputation": 27394,
            "user_id": 520287,
            "user_type": "registered",
            "accept_rate": 95,
            "profile_image": "https:\/\/www.gravatar.com\/avatar\/74503c4c9ba162be5ef8d077577a4b0e?s=256&d=identicon&r=PG",
            "display_name": "user52028778",
            "link": "https:\/\/stackoverflow.com\/users\/520287\/user52028778"
        },
        "is_accepted": false,
        "score": 2386,
        "last_activity_date": 1593020790,
        "last_edit_date": 1593020790,
        "creation_date": 1304063062,
        "answer_id": 5829377,
        "question_id": 2600191,
        "content_license": "CC BY-SA 4.0",
        "body_markdown": "Use [`Counter`][1] if you are using Python 2.7 or 3.x and you want the number of occurrences for each element: \r\n\r\n```python\r\n&gt;&gt;&gt; from collections import Counter\r\n&gt;&gt;&gt; z = [&#39;blue&#39;, &#39;red&#39;, &#39;blue&#39;, &#39;yellow&#39;, &#39;blue&#39;, &#39;red&#39;]\r\n&gt;&gt;&gt; Counter(z)\r\nCounter({&#39;blue&#39;: 3, &#39;red&#39;: 2, &#39;yellow&#39;: 1})\r\n```\r\n\r\n\r\n  [1]: https:\/\/docs.python.org\/3\/library\/collections.html#collections.Counter",
        "body": "<p>Use <a href=\"https:\/\/docs.python.org\/3\/library\/collections.html#collections.Counter\" rel=\"noreferrer\"><code>Counter<\/code><\/a> if you are using Python 2.7 or 3.x and you want the number of occurrences for each element:<\/p>\n<pre class=\"lang-py prettyprint-override\"><code>&gt;&gt;&gt; from collections import Counter\n&gt;&gt;&gt; z = ['blue', 'red', 'blue', 'yellow', 'blue', 'red']\n&gt;&gt;&gt; Counter(z)\nCounter({'blue': 3, 'red': 2, 'yellow': 1})\n<\/code><\/pre>\n",
        "community_owned_date": null
    },
    {
        "owner": {
            "account_id": 914,
            "reputation": 235159,
            "user_id": 1199,
            "user_type": "registered",
            "profile_image": "https:\/\/www.gravatar.com\/avatar\/78cb7314ef6c9ff2954f8e0d6506fc06?s=256&d=identicon&r=PG",
            "display_name": "Blair Conrad",
            "link": "https:\/\/stackoverflow.com\/users\/1199\/blair-conrad"
        },
        "is_accepted": true,
        "score": 2339,
        "last_activity_date": 1645090933,
        "last_edit_date": 1645090933,
        "creation_date": 1221529866,
        "answer_id": 68672,
        "question_id": 68645,
        "content_license": "CC BY-SA 4.0",
        "body_markdown": "Variables declared inside the class definition, but not inside a method are class or static variables:\r\n\r\n\r\n    &gt;&gt;&gt; class MyClass:\r\n    ...     i = 3\r\n    ...\r\n    &gt;&gt;&gt; MyClass.i\r\n    3 \r\n\r\nAs @[millerdev](https:\/\/stackoverflow.com\/questions\/68645\/static-class-variables-in-python#answer-69067) points out, this creates a class-level `i` variable, but this is distinct from any instance-level `i` variable, so you could have\r\n\r\n    &gt;&gt;&gt; m = MyClass()\r\n    &gt;&gt;&gt; m.i = 4\r\n    &gt;&gt;&gt; MyClass.i, m.i\r\n    &gt;&gt;&gt; (3, 4)\r\n\r\nThis is different from C++ and Java, but not so different from C#, where a static member can&#39;t be accessed using a reference to an instance.\r\n    \r\nSee [what the Python tutorial has to say on the subject of classes and class objects][1].\r\n\r\n@[Steve Johnson](#68656) has already answered regarding [static methods][2], also documented under [&quot;Built-in Functions&quot; in the Python Library Reference][3].\r\n\r\n    class C:\r\n        @staticmethod\r\n        def f(arg1, arg2, ...): ...\r\n\r\n\r\n@[beidy](#68747) recommends [classmethod][4]s over staticmethod, as the method then receives the class type as the first argument.\r\n\r\n  [1]: https:\/\/docs.python.org\/3\/tutorial\/classes.html#class-objects\r\n  [2]: http:\/\/web.archive.org\/web\/20090214211613\/http:\/\/pyref.infogami.com\/staticmethod\r\n  [3]: https:\/\/docs.python.org\/3\/library\/functions.html#staticmethod\r\n  [4]: https:\/\/docs.python.org\/3\/library\/functions.html#classmethod",
        "body": "<p>Variables declared inside the class definition, but not inside a method are class or static variables:<\/p>\n<pre><code>&gt;&gt;&gt; class MyClass:\n...     i = 3\n...\n&gt;&gt;&gt; MyClass.i\n3 \n<\/code><\/pre>\n<p>As @<a href=\"https:\/\/stackoverflow.com\/questions\/68645\/static-class-variables-in-python#answer-69067\">millerdev<\/a> points out, this creates a class-level <code>i<\/code> variable, but this is distinct from any instance-level <code>i<\/code> variable, so you could have<\/p>\n<pre><code>&gt;&gt;&gt; m = MyClass()\n&gt;&gt;&gt; m.i = 4\n&gt;&gt;&gt; MyClass.i, m.i\n&gt;&gt;&gt; (3, 4)\n<\/code><\/pre>\n<p>This is different from C++ and Java, but not so different from C#, where a static member can't be accessed using a reference to an instance.<\/p>\n<p>See <a href=\"https:\/\/docs.python.org\/3\/tutorial\/classes.html#class-objects\" rel=\"noreferrer\">what the Python tutorial has to say on the subject of classes and class objects<\/a>.<\/p>\n<p>@Steve Johnson has already answered regarding <a href=\"http:\/\/web.archive.org\/web\/20090214211613\/http:\/\/pyref.infogami.com\/staticmethod\" rel=\"noreferrer\">static methods<\/a>, also documented under <a href=\"https:\/\/docs.python.org\/3\/library\/functions.html#staticmethod\" rel=\"noreferrer\">&quot;Built-in Functions&quot; in the Python Library Reference<\/a>.<\/p>\n<pre><code>class C:\n    @staticmethod\n    def f(arg1, arg2, ...): ...\n<\/code><\/pre>\n<p>@beidy recommends <a href=\"https:\/\/docs.python.org\/3\/library\/functions.html#classmethod\" rel=\"noreferrer\">classmethod<\/a>s over staticmethod, as the method then receives the class type as the first argument.<\/p>\n",
        "community_owned_date": null
    },
    {
        "owner": {
            "account_id": 40044,
            "reputation": 84790,
            "user_id": 115845,
            "user_type": "registered",
            "accept_rate": 70,
            "profile_image": "https:\/\/www.gravatar.com\/avatar\/6263f31d56de4b97575338214071f41d?s=256&d=identicon&r=PG",
            "display_name": "Shawn Chin",
            "link": "https:\/\/stackoverflow.com\/users\/115845\/shawn-chin"
        },
        "is_accepted": false,
        "score": 2336,
        "last_activity_date": 1655977223,
        "last_edit_date": 1655977223,
        "creation_date": 1244149577,
        "answer_id": 953097,
        "question_id": 952914,
        "content_license": "CC BY-SA 4.0",
        "body_markdown": "You can use [`itertools.chain()`][1]:\r\n\r\n    &gt;&gt;&gt; import itertools\r\n    &gt;&gt;&gt; list2d = [[1,2,3], [4,5,6], [7], [8,9]]\r\n    &gt;&gt;&gt; merged = list(itertools.chain(*list2d))\r\n   \r\nOr you can use [`itertools.chain.from_iterable()`][2] which doesn&#39;t require unpacking the list with the `*` operator:\r\n\r\n    &gt;&gt;&gt; import itertools\r\n    &gt;&gt;&gt; list2d = [[1,2,3], [4,5,6], [7], [8,9]]\r\n    &gt;&gt;&gt; merged = list(itertools.chain.from_iterable(list2d))\r\n\r\n\r\nThis approach is arguably more readable than `[item for sublist in l for item in sublist]` and appears to be faster too:\r\n\r\n    $ python3 -mtimeit -s&#39;l=[[1,2,3],[4,5,6], [7], [8,9]]*99;import itertools&#39; &#39;list(itertools.chain.from_iterable(l))&#39;\r\n    20000 loops, best of 5: 10.8 usec per loop\r\n    $ python3 -mtimeit -s&#39;l=[[1,2,3],[4,5,6], [7], [8,9]]*99&#39; &#39;[item for sublist in l for item in sublist]&#39;\r\n    10000 loops, best of 5: 21.7 usec per loop\r\n    $ python3 -mtimeit -s&#39;l=[[1,2,3],[4,5,6], [7], [8,9]]*99&#39; &#39;sum(l, [])&#39;\r\n    1000 loops, best of 5: 258 usec per loop\r\n    $ python3 -mtimeit -s&#39;l=[[1,2,3],[4,5,6], [7], [8,9]]*99;from functools import reduce&#39; &#39;reduce(lambda x,y: x+y,l)&#39;\r\n    1000 loops, best of 5: 292 usec per loop\r\n    $ python3 --version\r\n    Python 3.7.5rc1\r\n\r\n  [1]: http:\/\/docs.python.org\/library\/itertools.html#itertools.chain\r\n  [2]: http:\/\/docs.python.org\/library\/itertools.html#itertools.chain.from_iterable\r\n",
        "body": "<p>You can use <a href=\"http:\/\/docs.python.org\/library\/itertools.html#itertools.chain\" rel=\"noreferrer\"><code>itertools.chain()<\/code><\/a>:<\/p>\n<pre><code>&gt;&gt;&gt; import itertools\n&gt;&gt;&gt; list2d = [[1,2,3], [4,5,6], [7], [8,9]]\n&gt;&gt;&gt; merged = list(itertools.chain(*list2d))\n<\/code><\/pre>\n<p>Or you can use <a href=\"http:\/\/docs.python.org\/library\/itertools.html#itertools.chain.from_iterable\" rel=\"noreferrer\"><code>itertools.chain.from_iterable()<\/code><\/a> which doesn't require unpacking the list with the <code>*<\/code> operator:<\/p>\n<pre><code>&gt;&gt;&gt; import itertools\n&gt;&gt;&gt; list2d = [[1,2,3], [4,5,6], [7], [8,9]]\n&gt;&gt;&gt; merged = list(itertools.chain.from_iterable(list2d))\n<\/code><\/pre>\n<p>This approach is arguably more readable than <code>[item for sublist in l for item in sublist]<\/code> and appears to be faster too:<\/p>\n<pre><code>$ python3 -mtimeit -s'l=[[1,2,3],[4,5,6], [7], [8,9]]*99;import itertools' 'list(itertools.chain.from_iterable(l))'\n20000 loops, best of 5: 10.8 usec per loop\n$ python3 -mtimeit -s'l=[[1,2,3],[4,5,6], [7], [8,9]]*99' '[item for sublist in l for item in sublist]'\n10000 loops, best of 5: 21.7 usec per loop\n$ python3 -mtimeit -s'l=[[1,2,3],[4,5,6], [7], [8,9]]*99' 'sum(l, [])'\n1000 loops, best of 5: 258 usec per loop\n$ python3 -mtimeit -s'l=[[1,2,3],[4,5,6], [7], [8,9]]*99;from functools import reduce' 'reduce(lambda x,y: x+y,l)'\n1000 loops, best of 5: 292 usec per loop\n$ python3 --version\nPython 3.7.5rc1\n<\/code><\/pre>\n",
        "community_owned_date": null
    },
    {
        "owner": {
            "account_id": 20652,
            "reputation": 32140,
            "user_id": 49559,
            "user_type": "registered",
            "accept_rate": 94,
            "profile_image": "https:\/\/www.gravatar.com\/avatar\/7145cb0edd64819646b468bf36515089?s=256&d=identicon&r=PG",
            "display_name": "Kiv",
            "link": "https:\/\/stackoverflow.com\/users\/49559\/kiv"
        },
        "is_accepted": true,
        "score": 2317,
        "last_activity_date": 1574352297,
        "last_edit_date": 1574352297,
        "creation_date": 1235349451,
        "answer_id": 576183,
        "question_id": 576169,
        "content_license": "CC BY-SA 4.0",
        "body_markdown": "`super()` lets you avoid referring to the base class explicitly, which can be nice. But the main advantage comes with multiple inheritance, where all sorts of [fun stuff][1] can happen. See the [standard docs on super][2] if you haven&#39;t already.\r\n\r\nNote that [the syntax changed in Python 3.0][3]: you can just say `super().__init__()` instead of `super(ChildB, self).__init__()` which IMO is quite a bit nicer. The standard docs also refer to a [guide to using `super()`](https:\/\/rhettinger.wordpress.com\/2011\/05\/26\/super-considered-super\/) which is quite explanatory.\r\n\r\n\r\n  [1]: http:\/\/www.artima.com\/weblogs\/viewpost.jsp?thread=236275\r\n  [2]: https:\/\/docs.python.org\/2\/library\/functions.html#super\r\n  [3]: https:\/\/docs.python.org\/3\/library\/functions.html#super",
        "body": "<p><code>super()<\/code> lets you avoid referring to the base class explicitly, which can be nice. But the main advantage comes with multiple inheritance, where all sorts of <a href=\"http:\/\/www.artima.com\/weblogs\/viewpost.jsp?thread=236275\" rel=\"noreferrer\">fun stuff<\/a> can happen. See the <a href=\"https:\/\/docs.python.org\/2\/library\/functions.html#super\" rel=\"noreferrer\">standard docs on super<\/a> if you haven't already.<\/p>\n\n<p>Note that <a href=\"https:\/\/docs.python.org\/3\/library\/functions.html#super\" rel=\"noreferrer\">the syntax changed in Python 3.0<\/a>: you can just say <code>super().__init__()<\/code> instead of <code>super(ChildB, self).__init__()<\/code> which IMO is quite a bit nicer. The standard docs also refer to a <a href=\"https:\/\/rhettinger.wordpress.com\/2011\/05\/26\/super-considered-super\/\" rel=\"noreferrer\">guide to using <code>super()<\/code><\/a> which is quite explanatory.<\/p>\n",
        "community_owned_date": null
    },
    {
        "owner": {
            "account_id": 75311,
            "reputation": 374168,
            "user_id": 216074,
            "user_type": "registered",
            "accept_rate": 90,
            "profile_image": "https:\/\/www.gravatar.com\/avatar\/609c93bafd659500f83fde04802a9be5?s=256&d=identicon&r=PG",
            "display_name": "poke",
            "link": "https:\/\/stackoverflow.com\/users\/216074\/poke"
        },
        "is_accepted": true,
        "score": 2311,
        "last_activity_date": 1609191613,
        "last_edit_date": 1609191613,
        "creation_date": 1265665206,
        "answer_id": 2225066,
        "question_id": 2225038,
        "content_license": "CC BY-SA 4.0",
        "body_markdown": "There are two built-in functions that help you identify the type of an object. You can use [`type()`](http:\/\/docs.python.org\/3\/library\/functions.html#type)  if you need the exact type of an object, and [`isinstance()`](http:\/\/docs.python.org\/3\/library\/functions.html#isinstance) to *check* an object\u2019s type against something. Usually, you want to use `isinstance()` most of the times since it is very robust and also supports type inheritance.\r\n\r\n---\r\n\r\nTo get the actual type of an object, you use the built-in [`type()`](http:\/\/docs.python.org\/3\/library\/functions.html#type) function. Passing an object as the only parameter will return the type object of that object:\r\n\r\n    &gt;&gt;&gt; type([]) is list\r\n    True\r\n    &gt;&gt;&gt; type({}) is dict\r\n    True\r\n    &gt;&gt;&gt; type(&#39;&#39;) is str\r\n    True\r\n    &gt;&gt;&gt; type(0) is int\r\n    True\r\n\r\nThis of course also works for custom types:\r\n\r\n    &gt;&gt;&gt; class Test1 (object):\r\n            pass\r\n    &gt;&gt;&gt; class Test2 (Test1):\r\n            pass\r\n    &gt;&gt;&gt; a = Test1()\r\n    &gt;&gt;&gt; b = Test2()\r\n    &gt;&gt;&gt; type(a) is Test1\r\n    True\r\n    &gt;&gt;&gt; type(b) is Test2\r\n    True\r\n\r\nNote that `type()` will only return the immediate type of the object, but won\u2019t be able to tell you about type inheritance.\r\n\r\n    &gt;&gt;&gt; type(b) is Test1\r\n    False\r\n\r\nTo cover that, you should use the [`isinstance`](http:\/\/docs.python.org\/3\/library\/functions.html#isinstance) function. This of course also works for built-in types:\r\n\r\n    &gt;&gt;&gt; isinstance(b, Test1)\r\n    True\r\n    &gt;&gt;&gt; isinstance(b, Test2)\r\n    True\r\n    &gt;&gt;&gt; isinstance(a, Test1)\r\n    True\r\n    &gt;&gt;&gt; isinstance(a, Test2)\r\n    False\r\n    &gt;&gt;&gt; isinstance([], list)\r\n    True\r\n    &gt;&gt;&gt; isinstance({}, dict)\r\n    True\r\n\r\n`isinstance()` is usually the preferred way to ensure the type of an object because it will also accept derived types. So unless you actually need the type object (for whatever reason), using `isinstance()` is preferred over `type()`.\r\n\r\nThe second parameter of `isinstance()` also accepts a tuple of types, so it\u2019s possible to check for multiple types at once. `isinstance` will then return true, if the object is of any of those types:\r\n\r\n    &gt;&gt;&gt; isinstance([], (tuple, list, set))\r\n    True",
        "body": "<p>There are two built-in functions that help you identify the type of an object. You can use <a href=\"http:\/\/docs.python.org\/3\/library\/functions.html#type\" rel=\"noreferrer\"><code>type()<\/code><\/a>  if you need the exact type of an object, and <a href=\"http:\/\/docs.python.org\/3\/library\/functions.html#isinstance\" rel=\"noreferrer\"><code>isinstance()<\/code><\/a> to <em>check<\/em> an object\u2019s type against something. Usually, you want to use <code>isinstance()<\/code> most of the times since it is very robust and also supports type inheritance.<\/p>\n<hr \/>\n<p>To get the actual type of an object, you use the built-in <a href=\"http:\/\/docs.python.org\/3\/library\/functions.html#type\" rel=\"noreferrer\"><code>type()<\/code><\/a> function. Passing an object as the only parameter will return the type object of that object:<\/p>\n<pre><code>&gt;&gt;&gt; type([]) is list\nTrue\n&gt;&gt;&gt; type({}) is dict\nTrue\n&gt;&gt;&gt; type('') is str\nTrue\n&gt;&gt;&gt; type(0) is int\nTrue\n<\/code><\/pre>\n<p>This of course also works for custom types:<\/p>\n<pre><code>&gt;&gt;&gt; class Test1 (object):\n        pass\n&gt;&gt;&gt; class Test2 (Test1):\n        pass\n&gt;&gt;&gt; a = Test1()\n&gt;&gt;&gt; b = Test2()\n&gt;&gt;&gt; type(a) is Test1\nTrue\n&gt;&gt;&gt; type(b) is Test2\nTrue\n<\/code><\/pre>\n<p>Note that <code>type()<\/code> will only return the immediate type of the object, but won\u2019t be able to tell you about type inheritance.<\/p>\n<pre><code>&gt;&gt;&gt; type(b) is Test1\nFalse\n<\/code><\/pre>\n<p>To cover that, you should use the <a href=\"http:\/\/docs.python.org\/3\/library\/functions.html#isinstance\" rel=\"noreferrer\"><code>isinstance<\/code><\/a> function. This of course also works for built-in types:<\/p>\n<pre><code>&gt;&gt;&gt; isinstance(b, Test1)\nTrue\n&gt;&gt;&gt; isinstance(b, Test2)\nTrue\n&gt;&gt;&gt; isinstance(a, Test1)\nTrue\n&gt;&gt;&gt; isinstance(a, Test2)\nFalse\n&gt;&gt;&gt; isinstance([], list)\nTrue\n&gt;&gt;&gt; isinstance({}, dict)\nTrue\n<\/code><\/pre>\n<p><code>isinstance()<\/code> is usually the preferred way to ensure the type of an object because it will also accept derived types. So unless you actually need the type object (for whatever reason), using <code>isinstance()<\/code> is preferred over <code>type()<\/code>.<\/p>\n<p>The second parameter of <code>isinstance()<\/code> also accepts a tuple of types, so it\u2019s possible to check for multiple types at once. <code>isinstance<\/code> will then return true, if the object is of any of those types:<\/p>\n<pre><code>&gt;&gt;&gt; isinstance([], (tuple, list, set))\nTrue\n<\/code><\/pre>\n",
        "community_owned_date": null
    },
    {
        "owner": {
            "account_id": 89879,
            "reputation": 139606,
            "user_id": 247696,
            "user_type": "registered",
            "accept_rate": 78,
            "profile_image": "https:\/\/www.gravatar.com\/avatar\/936383b387d6cc6d51279e429e5d7cd9?s=256&d=identicon&r=PG",
            "display_name": "Flimm",
            "link": "https:\/\/stackoverflow.com\/users\/247696\/flimm"
        },
        "is_accepted": true,
        "score": 2288,
        "last_activity_date": 1672307916,
        "last_edit_date": 1672307916,
        "creation_date": 1484065663,
        "answer_id": 41573588,
        "question_id": 41573587,
        "content_license": "CC BY-SA 4.0",
        "body_markdown": "**This is my personal recommendation for beginners:** start by learning [`virtualenv`][14] and [`pip`][15], tools which work with both Python 2 and 3 and in a variety of situations, and pick up other tools once you start needing them.\r\n\r\nNow on to answer the question: what is the difference between these similarly named things: venv, virtualenv, etc?\r\n\r\n\r\n# PyPI packages not in the standard library:\r\n\r\n - **[`virtualenv`][1]** is a very popular tool that creates isolated Python environments for Python libraries. If you&#39;re not familiar with this tool, I highly recommend learning it, as it is a very useful tool.\r\n\r\n   It works by installing a bunch of files in a directory (eg: `env\/`), and then modifying the `PATH` environment variable to prefix it with a custom `bin` directory (eg: `env\/bin\/`). An exact copy of the `python` or `python3` binary is placed in this directory, but Python is programmed to look for libraries relative to its path first, in the environment directory. It&#39;s not part of Python&#39;s standard library, but is officially blessed by the PyPA (Python Packaging Authority). Once activated, you can install packages in the virtual environment using `pip`.\r\n\r\n - **[`pyenv`][2]** is used to isolate Python versions. For example, you may want to test your code against Python 2.7, 3.6, 3.7 and 3.8, so you&#39;ll need a way to switch between them. Once activated, it prefixes the `PATH` environment variable with `~\/.pyenv\/shims`, where there are special files matching the Python commands (`python`, `pip`). These are not copies of the Python-shipped commands; they are special scripts that decide on the fly which version of Python to run based on the `PYENV_VERSION` environment variable, or the `.python-version` file, or the `~\/.pyenv\/version` file. `pyenv` also makes the process of downloading and installing multiple Python versions easier, using the command `pyenv install`.\r\n\r\n - **[`pyenv-virtualenv`][3]** is a plugin for `pyenv` by the same author as `pyenv`, to allow you to use `pyenv` and `virtualenv` at the same time conveniently. However, if you&#39;re using Python 3.3 or later, `pyenv-virtualenv` will try to run `python -m venv` if it is available, instead of `virtualenv`. You can use `virtualenv` and `pyenv` together without `pyenv-virtualenv`, if you don&#39;t want the convenience features.\r\n\r\n - **[`virtualenvwrapper`][4]** is a set of extensions to `virtualenv` (see [docs][5]). It gives you commands like `mkvirtualenv`, `lssitepackages`, and especially `workon` for switching between different `virtualenv` directories. This tool is especially useful if you want multiple `virtualenv` directories.\r\n\r\n - **[`pyenv-virtualenvwrapper`][6]** is a plugin for `pyenv` by the same author as `pyenv`, to conveniently integrate `virtualenvwrapper` into `pyenv`.\r\n\r\n - **[`pipenv`][7]** aims to combine `Pipfile`, `pip` and `virtualenv` into one command on the command-line. The `virtualenv` directory typically gets placed in `~\/.local\/share\/virtualenvs\/XXX`, with `XXX` being a hash of the path of the project directory. This is different from `virtualenv`, where the directory is typically in the current working directory. `pipenv` is meant to be used when developing Python applications (as opposed to libraries). There are alternatives to `pipenv`, such as `poetry`, which I won&#39;t list here since this question is only about the packages that are similarly named.\r\n\r\n# Standard library:\r\n\r\n- **`pyvenv`** (not to be confused with **[`pyenv`][2]** in the previous section) is a script shipped with Python 3.3 to 3.7. It was [removed from Python 3.8][11] as it had problems (not to mention the confusing name). Running `python3 -m venv` has exactly the same effect as `pyvenv`.\r\n\r\n- **[`venv`][12]** is a package shipped with Python 3, which you can run using `python3 -m venv` (although for some reason some distros separate it out into a separate distro package, such as `python3-venv` on Ubuntu\/Debian). It serves the same purpose as `virtualenv`, but only has a subset of its features ([see a comparison here][13]). `virtualenv` continues to be more popular than `venv`, especially since the former supports both Python 2 and 3.\r\n\r\n\r\n\r\n\r\n  [1]: https:\/\/pypi.python.org\/pypi\/virtualenv\r\n  [2]: https:\/\/github.com\/pyenv\/pyenv\r\n  [3]: https:\/\/github.com\/pyenv\/pyenv-virtualenv\r\n  [4]: https:\/\/pypi.python.org\/pypi\/virtualenvwrapper\r\n  [5]: http:\/\/virtualenvwrapper.readthedocs.io\/en\/latest\/\r\n  [6]: https:\/\/github.com\/pyenv\/pyenv-virtualenvwrapper\r\n  [7]: https:\/\/pypi.python.org\/pypi\/pipenv\r\n  [8]: https:\/\/github.com\/pypa\/pipenv\/issues\/4137\r\n  [9]: https:\/\/github.com\/pypa\/pipenv\/issues\/4058#issuecomment-565550646\r\n  [10]: https:\/\/pypi.org\/project\/poetry\/\r\n  [11]: https:\/\/docs.python.org\/3\/whatsnew\/3.8.html#api-and-feature-removals\r\n  [12]: https:\/\/docs.python.org\/3\/library\/venv.html\r\n  [13]: https:\/\/virtualenv.pypa.io\/en\/latest\/\r\n  [14]: https:\/\/pypi.org\/project\/virtualenv\/\r\n  [15]: https:\/\/pypi.org\/project\/pip\/",
        "body": "<p><strong>This is my personal recommendation for beginners:<\/strong> start by learning <a href=\"https:\/\/pypi.org\/project\/virtualenv\/\" rel=\"noreferrer\"><code>virtualenv<\/code><\/a> and <a href=\"https:\/\/pypi.org\/project\/pip\/\" rel=\"noreferrer\"><code>pip<\/code><\/a>, tools which work with both Python 2 and 3 and in a variety of situations, and pick up other tools once you start needing them.<\/p>\n<p>Now on to answer the question: what is the difference between these similarly named things: venv, virtualenv, etc?<\/p>\n<h1>PyPI packages not in the standard library:<\/h1>\n<ul>\n<li><p><strong><a href=\"https:\/\/pypi.python.org\/pypi\/virtualenv\" rel=\"noreferrer\"><code>virtualenv<\/code><\/a><\/strong> is a very popular tool that creates isolated Python environments for Python libraries. If you're not familiar with this tool, I highly recommend learning it, as it is a very useful tool.<\/p>\n<p>It works by installing a bunch of files in a directory (eg: <code>env\/<\/code>), and then modifying the <code>PATH<\/code> environment variable to prefix it with a custom <code>bin<\/code> directory (eg: <code>env\/bin\/<\/code>). An exact copy of the <code>python<\/code> or <code>python3<\/code> binary is placed in this directory, but Python is programmed to look for libraries relative to its path first, in the environment directory. It's not part of Python's standard library, but is officially blessed by the PyPA (Python Packaging Authority). Once activated, you can install packages in the virtual environment using <code>pip<\/code>.<\/p>\n<\/li>\n<li><p><strong><a href=\"https:\/\/github.com\/pyenv\/pyenv\" rel=\"noreferrer\"><code>pyenv<\/code><\/a><\/strong> is used to isolate Python versions. For example, you may want to test your code against Python 2.7, 3.6, 3.7 and 3.8, so you'll need a way to switch between them. Once activated, it prefixes the <code>PATH<\/code> environment variable with <code>~\/.pyenv\/shims<\/code>, where there are special files matching the Python commands (<code>python<\/code>, <code>pip<\/code>). These are not copies of the Python-shipped commands; they are special scripts that decide on the fly which version of Python to run based on the <code>PYENV_VERSION<\/code> environment variable, or the <code>.python-version<\/code> file, or the <code>~\/.pyenv\/version<\/code> file. <code>pyenv<\/code> also makes the process of downloading and installing multiple Python versions easier, using the command <code>pyenv install<\/code>.<\/p>\n<\/li>\n<li><p><strong><a href=\"https:\/\/github.com\/pyenv\/pyenv-virtualenv\" rel=\"noreferrer\"><code>pyenv-virtualenv<\/code><\/a><\/strong> is a plugin for <code>pyenv<\/code> by the same author as <code>pyenv<\/code>, to allow you to use <code>pyenv<\/code> and <code>virtualenv<\/code> at the same time conveniently. However, if you're using Python 3.3 or later, <code>pyenv-virtualenv<\/code> will try to run <code>python -m venv<\/code> if it is available, instead of <code>virtualenv<\/code>. You can use <code>virtualenv<\/code> and <code>pyenv<\/code> together without <code>pyenv-virtualenv<\/code>, if you don't want the convenience features.<\/p>\n<\/li>\n<li><p><strong><a href=\"https:\/\/pypi.python.org\/pypi\/virtualenvwrapper\" rel=\"noreferrer\"><code>virtualenvwrapper<\/code><\/a><\/strong> is a set of extensions to <code>virtualenv<\/code> (see <a href=\"http:\/\/virtualenvwrapper.readthedocs.io\/en\/latest\/\" rel=\"noreferrer\">docs<\/a>). It gives you commands like <code>mkvirtualenv<\/code>, <code>lssitepackages<\/code>, and especially <code>workon<\/code> for switching between different <code>virtualenv<\/code> directories. This tool is especially useful if you want multiple <code>virtualenv<\/code> directories.<\/p>\n<\/li>\n<li><p><strong><a href=\"https:\/\/github.com\/pyenv\/pyenv-virtualenvwrapper\" rel=\"noreferrer\"><code>pyenv-virtualenvwrapper<\/code><\/a><\/strong> is a plugin for <code>pyenv<\/code> by the same author as <code>pyenv<\/code>, to conveniently integrate <code>virtualenvwrapper<\/code> into <code>pyenv<\/code>.<\/p>\n<\/li>\n<li><p><strong><a href=\"https:\/\/pypi.python.org\/pypi\/pipenv\" rel=\"noreferrer\"><code>pipenv<\/code><\/a><\/strong> aims to combine <code>Pipfile<\/code>, <code>pip<\/code> and <code>virtualenv<\/code> into one command on the command-line. The <code>virtualenv<\/code> directory typically gets placed in <code>~\/.local\/share\/virtualenvs\/XXX<\/code>, with <code>XXX<\/code> being a hash of the path of the project directory. This is different from <code>virtualenv<\/code>, where the directory is typically in the current working directory. <code>pipenv<\/code> is meant to be used when developing Python applications (as opposed to libraries). There are alternatives to <code>pipenv<\/code>, such as <code>poetry<\/code>, which I won't list here since this question is only about the packages that are similarly named.<\/p>\n<\/li>\n<\/ul>\n<h1>Standard library:<\/h1>\n<ul>\n<li><p><strong><code>pyvenv<\/code><\/strong> (not to be confused with <strong><a href=\"https:\/\/github.com\/pyenv\/pyenv\" rel=\"noreferrer\"><code>pyenv<\/code><\/a><\/strong> in the previous section) is a script shipped with Python 3.3 to 3.7. It was <a href=\"https:\/\/docs.python.org\/3\/whatsnew\/3.8.html#api-and-feature-removals\" rel=\"noreferrer\">removed from Python 3.8<\/a> as it had problems (not to mention the confusing name). Running <code>python3 -m venv<\/code> has exactly the same effect as <code>pyvenv<\/code>.<\/p>\n<\/li>\n<li><p><strong><a href=\"https:\/\/docs.python.org\/3\/library\/venv.html\" rel=\"noreferrer\"><code>venv<\/code><\/a><\/strong> is a package shipped with Python 3, which you can run using <code>python3 -m venv<\/code> (although for some reason some distros separate it out into a separate distro package, such as <code>python3-venv<\/code> on Ubuntu\/Debian). It serves the same purpose as <code>virtualenv<\/code>, but only has a subset of its features (<a href=\"https:\/\/virtualenv.pypa.io\/en\/latest\/\" rel=\"noreferrer\">see a comparison here<\/a>). <code>virtualenv<\/code> continues to be more popular than <code>venv<\/code>, especially since the former supports both Python 2 and 3.<\/p>\n<\/li>\n<\/ul>\n",
        "community_owned_date": null
    },
    {
        "owner": {
            "account_id": 579,
            "reputation": 166735,
            "user_id": 745,
            "user_type": "registered",
            "accept_rate": 90,
            "profile_image": "https:\/\/www.gravatar.com\/avatar\/edf857d71f672d8f411ef6b8376316b8?s=256&d=identicon&r=PG",
            "display_name": "dbr",
            "link": "https:\/\/stackoverflow.com\/users\/745\/dbr"
        },
        "is_accepted": true,
        "score": 2279,
        "last_activity_date": 1674351764,
        "last_edit_date": 1674351764,
        "creation_date": 1239312276,
        "answer_id": 735978,
        "question_id": 735975,
        "content_license": "CC BY-SA 4.0",
        "body_markdown": "Yep, using the [`staticmethod`][1] decorator:\r\n\r\n    class MyClass(object):\r\n        @staticmethod\r\n        def the_static_method(x):\r\n            print(x)\r\n\r\n    MyClass.the_static_method(2)  # outputs 2\r\n\r\n\r\nNote that some code might use the old method of defining a static method, using `staticmethod` as a function rather than a decorator. This should only be used if you have to support ancient versions of Python (2.2 and 2.3):\r\n\r\n\r\n    class MyClass(object):\r\n        def the_static_method(x):\r\n            print(x)\r\n        the_static_method = staticmethod(the_static_method)\r\n\r\n    MyClass.the_static_method(2)  # outputs 2\r\n\r\n\r\nThis is entirely identical to the first example (using `@staticmethod`), just not using the nice decorator syntax.\r\n\r\nFinally, use [`staticmethod`][1] sparingly! There are very few situations where static-methods are necessary in Python, and I&#39;ve seen them used many times where a separate &quot;top-level&quot; function would have been clearer.\r\n\r\n---\r\n\r\n[The following is verbatim from the documentation:][1]:\r\n\r\n&gt; A static method does not receive an implicit first argument. To declare a static method, use this idiom:\r\n&gt; \r\n&gt;     class C:\r\n&gt;         @staticmethod\r\n&gt;         def f(arg1, arg2, ...): ...\r\n&gt;\r\n&gt; The @staticmethod form is a function [*decorator*][5] \u2013 see the description of function definitions in [*Function definitions*][2] for details.\r\n&gt;\r\n&gt; It can be called either on the class (such as `C.f()`) or on an instance (such as `C().f()`). The instance is ignored except for its class.\r\n&gt;\r\n&gt; Static methods in Python are similar to those found in Java or C++. For a more advanced concept, see [`classmethod()`][3].\r\n&gt;\r\n&gt; For more information on static methods, consult the documentation on the standard type hierarchy in [*The standard type hierarchy*][4].\r\n&gt;\r\n&gt; New in version 2.2.\r\n&gt;\r\n&gt;Changed in version 2.4: Function decorator syntax added.\r\n\r\n\r\n[1]: https:\/\/docs.python.org\/3\/library\/functions.html#staticmethod &quot;staticmethod&quot;\r\n[2]: https:\/\/docs.python.org\/3\/reference\/compound_stmts.html#function &quot;Function definitions&quot;\r\n[3]: https:\/\/docs.python.org\/3\/library\/functions.html#classmethod &quot;classmethod&quot;\r\n[4]: https:\/\/docs.python.org\/3\/reference\/datamodel.html#types &quot;types&quot;\r\n[5]: https:\/\/docs.python.org\/3\/glossary.html#term-decorator &quot;term-decorator&quot;",
        "body": "<p>Yep, using the <a href=\"https:\/\/docs.python.org\/3\/library\/functions.html#staticmethod\" rel=\"noreferrer\" title=\"staticmethod\"><code>staticmethod<\/code><\/a> decorator:<\/p>\n<pre><code>class MyClass(object):\n    @staticmethod\n    def the_static_method(x):\n        print(x)\n\nMyClass.the_static_method(2)  # outputs 2\n<\/code><\/pre>\n<p>Note that some code might use the old method of defining a static method, using <code>staticmethod<\/code> as a function rather than a decorator. This should only be used if you have to support ancient versions of Python (2.2 and 2.3):<\/p>\n<pre><code>class MyClass(object):\n    def the_static_method(x):\n        print(x)\n    the_static_method = staticmethod(the_static_method)\n\nMyClass.the_static_method(2)  # outputs 2\n<\/code><\/pre>\n<p>This is entirely identical to the first example (using <code>@staticmethod<\/code>), just not using the nice decorator syntax.<\/p>\n<p>Finally, use <a href=\"https:\/\/docs.python.org\/3\/library\/functions.html#staticmethod\" rel=\"noreferrer\" title=\"staticmethod\"><code>staticmethod<\/code><\/a> sparingly! There are very few situations where static-methods are necessary in Python, and I've seen them used many times where a separate &quot;top-level&quot; function would have been clearer.<\/p>\n<hr \/>\n<p><a href=\"https:\/\/docs.python.org\/3\/library\/functions.html#staticmethod\" rel=\"noreferrer\" title=\"staticmethod\">The following is verbatim from the documentation:<\/a>:<\/p>\n<blockquote>\n<p>A static method does not receive an implicit first argument. To declare a static method, use this idiom:<\/p>\n<pre><code>class C:\n    @staticmethod\n    def f(arg1, arg2, ...): ...\n<\/code><\/pre>\n<p>The @staticmethod form is a function <a href=\"https:\/\/docs.python.org\/3\/glossary.html#term-decorator\" rel=\"noreferrer\" title=\"term-decorator\"><em>decorator<\/em><\/a> \u2013 see the description of function definitions in <a href=\"https:\/\/docs.python.org\/3\/reference\/compound_stmts.html#function\" rel=\"noreferrer\" title=\"Function definitions\"><em>Function definitions<\/em><\/a> for details.<\/p>\n<p>It can be called either on the class (such as <code>C.f()<\/code>) or on an instance (such as <code>C().f()<\/code>). The instance is ignored except for its class.<\/p>\n<p>Static methods in Python are similar to those found in Java or C++. For a more advanced concept, see <a href=\"https:\/\/docs.python.org\/3\/library\/functions.html#classmethod\" rel=\"noreferrer\" title=\"classmethod\"><code>classmethod()<\/code><\/a>.<\/p>\n<p>For more information on static methods, consult the documentation on the standard type hierarchy in <a href=\"https:\/\/docs.python.org\/3\/reference\/datamodel.html#types\" rel=\"noreferrer\" title=\"types\"><em>The standard type hierarchy<\/em><\/a>.<\/p>\n<p>New in version 2.2.<\/p>\n<p>Changed in version 2.4: Function decorator syntax added.<\/p>\n<\/blockquote>\n",
        "community_owned_date": null
    },
    {
        "owner": {
            "account_id": 9034,
            "reputation": 72225,
            "user_id": 16511,
            "user_type": "registered",
            "accept_rate": 96,
            "profile_image": "https:\/\/www.gravatar.com\/avatar\/f1ead936fb3a1beb870c8541f463254a?s=256&d=identicon&r=PG",
            "display_name": "Rich Bradshaw",
            "link": "https:\/\/stackoverflow.com\/users\/16511\/rich-bradshaw"
        },
        "is_accepted": false,
        "score": 2271,
        "last_activity_date": 1632925126,
        "last_edit_date": 1632925126,
        "creation_date": 1226169113,
        "answer_id": 275025,
        "question_id": 275018,
        "content_license": "CC BY-SA 4.0",
        "body_markdown": "Try the method `rstrip()` (see doc [Python 2][2] and [Python 3][3])\r\n\r\n    &gt;&gt;&gt; &#39;test string\\n&#39;.rstrip()\r\n    &#39;test string&#39;\r\n\r\nPython&#39;s `rstrip()` method strips *all* kinds of trailing whitespace by default, not just one newline as Perl does with [`chomp`][1].\r\n\r\n    &gt;&gt;&gt; &#39;test string \\n \\r\\n\\n\\r \\n\\n&#39;.rstrip()\r\n    &#39;test string&#39;\r\n\r\nTo strip only newlines:\r\n\r\n    &gt;&gt;&gt; &#39;test string \\n \\r\\n\\n\\r \\n\\n&#39;.rstrip(&#39;\\n&#39;)\r\n    &#39;test string \\n \\r\\n\\n\\r &#39;\r\n\r\nIn addition to `rstrip()`, there are also the methods `strip()` and `lstrip()`. Here is an example with the three of them:\r\n\r\n    &gt;&gt;&gt; s = &quot;   \\n\\r\\n  \\n  abc   def \\n\\r\\n  \\n  &quot;\r\n    &gt;&gt;&gt; s.strip()\r\n    &#39;abc   def&#39;\r\n    &gt;&gt;&gt; s.lstrip()\r\n    &#39;abc   def \\n\\r\\n  \\n  &#39;\r\n    &gt;&gt;&gt; s.rstrip()\r\n    &#39;   \\n\\r\\n  \\n  abc   def&#39;\r\n\r\n  [1]: http:\/\/perldoc.perl.org\/functions\/chomp.html\r\n  [2]: http:\/\/docs.python.org\/2\/library\/stdtypes.html#str.rstrip\r\n  [3]: https:\/\/docs.python.org\/3\/library\/stdtypes.html#str.rstrip",
        "body": "<p>Try the method <code>rstrip()<\/code> (see doc <a href=\"http:\/\/docs.python.org\/2\/library\/stdtypes.html#str.rstrip\" rel=\"noreferrer\">Python 2<\/a> and <a href=\"https:\/\/docs.python.org\/3\/library\/stdtypes.html#str.rstrip\" rel=\"noreferrer\">Python 3<\/a>)<\/p>\n<pre><code>&gt;&gt;&gt; 'test string\\n'.rstrip()\n'test string'\n<\/code><\/pre>\n<p>Python's <code>rstrip()<\/code> method strips <em>all<\/em> kinds of trailing whitespace by default, not just one newline as Perl does with <a href=\"http:\/\/perldoc.perl.org\/functions\/chomp.html\" rel=\"noreferrer\"><code>chomp<\/code><\/a>.<\/p>\n<pre><code>&gt;&gt;&gt; 'test string \\n \\r\\n\\n\\r \\n\\n'.rstrip()\n'test string'\n<\/code><\/pre>\n<p>To strip only newlines:<\/p>\n<pre><code>&gt;&gt;&gt; 'test string \\n \\r\\n\\n\\r \\n\\n'.rstrip('\\n')\n'test string \\n \\r\\n\\n\\r '\n<\/code><\/pre>\n<p>In addition to <code>rstrip()<\/code>, there are also the methods <code>strip()<\/code> and <code>lstrip()<\/code>. Here is an example with the three of them:<\/p>\n<pre><code>&gt;&gt;&gt; s = &quot;   \\n\\r\\n  \\n  abc   def \\n\\r\\n  \\n  &quot;\n&gt;&gt;&gt; s.strip()\n'abc   def'\n&gt;&gt;&gt; s.lstrip()\n'abc   def \\n\\r\\n  \\n  '\n&gt;&gt;&gt; s.rstrip()\n'   \\n\\r\\n  \\n  abc   def'\n<\/code><\/pre>\n",
        "community_owned_date": 1226169113.0
    },
    {
        "owner": {
            "account_id": 11201,
            "reputation": 96914,
            "user_id": 21475,
            "user_type": "registered",
            "accept_rate": 98,
            "profile_image": "https:\/\/www.gravatar.com\/avatar\/003174af5095d12b7f9a5efc293eb041?s=256&d=identicon&r=PG",
            "display_name": "Cameron",
            "link": "https:\/\/stackoverflow.com\/users\/21475\/cameron"
        },
        "is_accepted": false,
        "score": 2259,
        "last_activity_date": 1693988047,
        "last_edit_date": 1693988047,
        "creation_date": 1291774333,
        "answer_id": 4383597,
        "question_id": 4383571,
        "content_license": "CC BY-SA 4.0",
        "body_markdown": "Note: This answer was intended for a very specific question. For most programmers coming here from a search engine, this is not the answer you are looking for. Typically you would structure your files into packages (see other answers) instead of modifying the search path.\r\n\r\n---\r\n\r\nBy default, you can&#39;t. When importing a file, Python only searches the directory that the entry-point script is running from and `sys.path` which includes locations such as the package installation directory (it&#39;s actually [a little more complex](https:\/\/docs.python.org\/3\/library\/sys.html#sys.path) than this, but this covers most cases).\r\n\r\nHowever, you can add to the Python path at runtime:\r\n\r\n    # some_file.py\r\n    import sys\r\n    # caution: path[0] is reserved for script path (or &#39;&#39; in REPL)\r\n    sys.path.insert(1, &#39;\/path\/to\/application\/app\/folder&#39;)\r\n\r\n    import file",
        "body": "<p>Note: This answer was intended for a very specific question. For most programmers coming here from a search engine, this is not the answer you are looking for. Typically you would structure your files into packages (see other answers) instead of modifying the search path.<\/p>\n<hr \/>\n<p>By default, you can't. When importing a file, Python only searches the directory that the entry-point script is running from and <code>sys.path<\/code> which includes locations such as the package installation directory (it's actually <a href=\"https:\/\/docs.python.org\/3\/library\/sys.html#sys.path\" rel=\"noreferrer\">a little more complex<\/a> than this, but this covers most cases).<\/p>\n<p>However, you can add to the Python path at runtime:<\/p>\n<pre><code># some_file.py\nimport sys\n# caution: path[0] is reserved for script path (or '' in REPL)\nsys.path.insert(1, '\/path\/to\/application\/app\/folder')\n\nimport file\n<\/code><\/pre>\n",
        "community_owned_date": null
    },
    {
        "owner": {
            "account_id": 15548,
            "reputation": 26458,
            "user_id": 32958,
            "user_type": "registered",
            "accept_rate": 100,
            "profile_image": "https:\/\/www.gravatar.com\/avatar\/e1cd00d3feef62963e58926f97ddf953?s=256&d=identicon&r=PG",
            "display_name": "Rex Logan",
            "link": "https:\/\/stackoverflow.com\/users\/32958\/rex-logan"
        },
        "is_accepted": false,
        "score": 2255,
        "last_activity_date": 1585518743,
        "last_edit_date": 1585518743,
        "creation_date": 1232303033,
        "answer_id": 455634,
        "question_id": 455612,
        "content_license": "CC BY-SA 4.0",
        "body_markdown": "You are running into the [old problem](https:\/\/en.wikipedia.org\/wiki\/IEEE_754) with floating point numbers that not all numbers can be represented exactly. The command line is just showing you the full floating point form from memory.\r\n\r\nWith floating point representation, your rounded version is the same number. Since computers are binary, they store floating point numbers as an integer and then divide it by a power of two so 13.95 will be represented in a similar fashion to 125650429603636838\/(2**53).\r\n\r\nDouble precision numbers have 53 bits (16 digits) of precision and regular floats have 24 bits (8 digits) of precision. The [floating point type in Python uses double precision](http:\/\/docs.python.org\/tutorial\/floatingpoint.html) to store the values.\r\n\r\nFor example,\r\n\r\n    &gt;&gt;&gt; 125650429603636838\/(2**53)\r\n    13.949999999999999\r\n\r\n    &gt;&gt;&gt; 234042163\/(2**24)\r\n    13.949999988079071\r\n\r\n    &gt;&gt;&gt; a = 13.946\r\n    &gt;&gt;&gt; print(a)\r\n    13.946\r\n    &gt;&gt;&gt; print(&quot;%.2f&quot; % a)\r\n    13.95\r\n    &gt;&gt;&gt; round(a,2)\r\n    13.949999999999999\r\n    &gt;&gt;&gt; print(&quot;%.2f&quot; % round(a, 2))\r\n    13.95\r\n    &gt;&gt;&gt; print(&quot;{:.2f}&quot;.format(a))\r\n    13.95\r\n    &gt;&gt;&gt; print(&quot;{:.2f}&quot;.format(round(a, 2)))\r\n    13.95\r\n    &gt;&gt;&gt; print(&quot;{:.15f}&quot;.format(round(a, 2)))\r\n    13.949999999999999\r\n\r\nIf you are after only two decimal places (to display a currency value, for example), then you have a couple of better choices:\r\n\r\n1. Use integers and store values in cents, not dollars and then divide by 100 to convert to dollars.\r\n2. Or use a fixed point number like [decimal][1].\r\n\r\n  [1]: https:\/\/docs.python.org\/library\/decimal.html\r\n",
        "body": "<p>You are running into the <a href=\"https:\/\/en.wikipedia.org\/wiki\/IEEE_754\" rel=\"noreferrer\">old problem<\/a> with floating point numbers that not all numbers can be represented exactly. The command line is just showing you the full floating point form from memory.<\/p>\n\n<p>With floating point representation, your rounded version is the same number. Since computers are binary, they store floating point numbers as an integer and then divide it by a power of two so 13.95 will be represented in a similar fashion to 125650429603636838\/(2**53).<\/p>\n\n<p>Double precision numbers have 53 bits (16 digits) of precision and regular floats have 24 bits (8 digits) of precision. The <a href=\"http:\/\/docs.python.org\/tutorial\/floatingpoint.html\" rel=\"noreferrer\">floating point type in Python uses double precision<\/a> to store the values.<\/p>\n\n<p>For example,<\/p>\n\n<pre><code>&gt;&gt;&gt; 125650429603636838\/(2**53)\n13.949999999999999\n\n&gt;&gt;&gt; 234042163\/(2**24)\n13.949999988079071\n\n&gt;&gt;&gt; a = 13.946\n&gt;&gt;&gt; print(a)\n13.946\n&gt;&gt;&gt; print(\"%.2f\" % a)\n13.95\n&gt;&gt;&gt; round(a,2)\n13.949999999999999\n&gt;&gt;&gt; print(\"%.2f\" % round(a, 2))\n13.95\n&gt;&gt;&gt; print(\"{:.2f}\".format(a))\n13.95\n&gt;&gt;&gt; print(\"{:.2f}\".format(round(a, 2)))\n13.95\n&gt;&gt;&gt; print(\"{:.15f}\".format(round(a, 2)))\n13.949999999999999\n<\/code><\/pre>\n\n<p>If you are after only two decimal places (to display a currency value, for example), then you have a couple of better choices:<\/p>\n\n<ol>\n<li>Use integers and store values in cents, not dollars and then divide by 100 to convert to dollars.<\/li>\n<li>Or use a fixed point number like <a href=\"https:\/\/docs.python.org\/library\/decimal.html\" rel=\"noreferrer\">decimal<\/a>.<\/li>\n<\/ol>\n",
        "community_owned_date": null
    },
    {
        "owner": {
            "account_id": 365419,
            "reputation": 22961,
            "user_id": 710332,
            "user_type": "registered",
            "profile_image": "https:\/\/i.stack.imgur.com\/GQqJh.jpg?s=256&g=1",
            "display_name": "Mike Lyons",
            "link": "https:\/\/stackoverflow.com\/users\/710332\/mike-lyons"
        },
        "is_accepted": false,
        "score": 2216,
        "last_activity_date": 1650832684,
        "last_edit_date": 1650832684,
        "creation_date": 1364086063,
        "answer_id": 15593865,
        "question_id": 7225900,
        "content_license": "CC BY-SA 4.0",
        "body_markdown": "This works for everyone:\r\n\r\n    pip install -r \/path\/to\/requirements.txt\r\n\r\n**Explanation:**\r\n\r\n&gt; -r, --requirement &lt; filename &gt;\r\n\r\nInstall from the given requirements file. This option can be used multiple times.\r\n\r\n\r\n\r\n",
        "body": "<p>This works for everyone:<\/p>\n<pre><code>pip install -r \/path\/to\/requirements.txt\n<\/code><\/pre>\n<p><strong>Explanation:<\/strong><\/p>\n<blockquote>\n<p>-r, --requirement &lt; filename &gt;<\/p>\n<\/blockquote>\n<p>Install from the given requirements file. This option can be used multiple times.<\/p>\n",
        "community_owned_date": null
    },
    {
        "owner": {
            "account_id": 11828,
            "reputation": 25900,
            "user_id": 1163767,
            "user_type": "registered",
            "profile_image": "https:\/\/www.gravatar.com\/avatar\/9175248d9183522cc0d95ef6d3705cce?s=256&d=identicon&r=PG",
            "display_name": "Fredrik Johansson",
            "link": "https:\/\/stackoverflow.com\/users\/1163767\/fredrik-johansson"
        },
        "is_accepted": true,
        "score": 2197,
        "last_activity_date": 1672940193,
        "last_edit_date": 1672940193,
        "creation_date": 1222772865,
        "answer_id": 152596,
        "question_id": 152580,
        "content_license": "CC BY-SA 4.0",
        "body_markdown": "Use [`isinstance`](https:\/\/docs.python.org\/library\/functions.html#isinstance) to check if `o` is an instance of `str` or any subclass of `str`:\r\n\r\n    if isinstance(o, str):\r\n\r\nTo check if the type of `o` is exactly `str`, *excluding subclasses of `str`*:\r\n\r\n    if type(o) is str:\r\n\r\n\r\nSee [Built-in Functions][1] in the Python Library Reference for relevant information.\r\n\r\n---\r\n\r\n#### Checking for strings in Python 2\r\n\r\nFor Python 2, this is a better way to check if `o` is a string:\r\n\r\n    if isinstance(o, basestring):\r\n\r\nbecause this will also catch Unicode strings. [`unicode`](https:\/\/docs.python.org\/2\/library\/functions.html#unicode) is not a subclass of `str`; both `str` and `unicode` are subclasses of [`basestring`](https:\/\/docs.python.org\/2\/library\/functions.html#basestring). In Python 3, `basestring` no longer exists since there&#39;s [a strict separation](https:\/\/docs.python.org\/whatsnew\/3.0.html#text-vs-data-instead-of-unicode-vs-8-bit) of strings ([`str`](https:\/\/docs.python.org\/3\/library\/functions.html#func-str)) and binary data ([`bytes`](https:\/\/docs.python.org\/3\/library\/functions.html#func-bytes)).\r\n\r\nAlternatively, `isinstance` accepts a tuple of classes. This will return `True` if `o` is an instance of any subclass of any of `(str, unicode)`:\r\n\r\n    if isinstance(o, (str, unicode)):\r\n\r\n\r\n  [1]: http:\/\/docs.python.org\/library\/functions.html",
        "body": "<p>Use <a href=\"https:\/\/docs.python.org\/library\/functions.html#isinstance\" rel=\"noreferrer\"><code>isinstance<\/code><\/a> to check if <code>o<\/code> is an instance of <code>str<\/code> or any subclass of <code>str<\/code>:<\/p>\n<pre><code>if isinstance(o, str):\n<\/code><\/pre>\n<p>To check if the type of <code>o<\/code> is exactly <code>str<\/code>, <em>excluding subclasses of <code>str<\/code><\/em>:<\/p>\n<pre><code>if type(o) is str:\n<\/code><\/pre>\n<p>See <a href=\"http:\/\/docs.python.org\/library\/functions.html\" rel=\"noreferrer\">Built-in Functions<\/a> in the Python Library Reference for relevant information.<\/p>\n<hr \/>\n<h4>Checking for strings in Python 2<\/h4>\n<p>For Python 2, this is a better way to check if <code>o<\/code> is a string:<\/p>\n<pre><code>if isinstance(o, basestring):\n<\/code><\/pre>\n<p>because this will also catch Unicode strings. <a href=\"https:\/\/docs.python.org\/2\/library\/functions.html#unicode\" rel=\"noreferrer\"><code>unicode<\/code><\/a> is not a subclass of <code>str<\/code>; both <code>str<\/code> and <code>unicode<\/code> are subclasses of <a href=\"https:\/\/docs.python.org\/2\/library\/functions.html#basestring\" rel=\"noreferrer\"><code>basestring<\/code><\/a>. In Python 3, <code>basestring<\/code> no longer exists since there's <a href=\"https:\/\/docs.python.org\/whatsnew\/3.0.html#text-vs-data-instead-of-unicode-vs-8-bit\" rel=\"noreferrer\">a strict separation<\/a> of strings (<a href=\"https:\/\/docs.python.org\/3\/library\/functions.html#func-str\" rel=\"noreferrer\"><code>str<\/code><\/a>) and binary data (<a href=\"https:\/\/docs.python.org\/3\/library\/functions.html#func-bytes\" rel=\"noreferrer\"><code>bytes<\/code><\/a>).<\/p>\n<p>Alternatively, <code>isinstance<\/code> accepts a tuple of classes. This will return <code>True<\/code> if <code>o<\/code> is an instance of any subclass of any of <code>(str, unicode)<\/code>:<\/p>\n<pre><code>if isinstance(o, (str, unicode)):\n<\/code><\/pre>\n",
        "community_owned_date": null
    },
    {
        "owner": {
            "account_id": 5807,
            "reputation": 392681,
            "user_id": 9530,
            "user_type": "registered",
            "accept_rate": 78,
            "profile_image": "https:\/\/www.gravatar.com\/avatar\/924800e76876546c5c575c0175e1f434?s=256&d=identicon&r=PG",
            "display_name": "Adam Rosenfield",
            "link": "https:\/\/stackoverflow.com\/users\/9530\/adam-rosenfield"
        },
        "is_accepted": false,
        "score": 2176,
        "last_activity_date": 1517405296,
        "last_edit_date": 1517405296,
        "creation_date": 1231302503,
        "answer_id": 419189,
        "question_id": 419163,
        "content_license": "CC BY-SA 3.0",
        "body_markdown": "When your script is run by passing it as a command to the Python interpreter,\r\n\r\n    python myscript.py\r\n\r\nall of the code that is at indentation level 0 gets executed.  Functions and classes that are defined are, well, defined, but none of their code gets run.  Unlike other languages, there&#39;s no `main()` function that gets run automatically - the `main()` function is implicitly all the code at the top level.\r\n\r\nIn this case, the top-level code is an `if` block.  `__name__` is a built-in variable which evaluates to the name of the current module.  However, if a module is being run directly (as in `myscript.py` above), then `__name__` instead is set to the string `&quot;__main__&quot;`.  Thus, you can test whether your script is being run directly or being imported by something else by testing\r\n\r\n    if __name__ == &quot;__main__&quot;:\r\n        ...\r\n\r\nIf your script is being imported into another module, its various function and class definitions will be imported and its top-level code will be executed, but the code in the then-body of the `if` clause above won&#39;t get run as the condition is not met. As a basic example, consider the following two scripts:\r\n\r\n    # file one.py\r\n    def func():\r\n        print(&quot;func() in one.py&quot;)\r\n    \r\n    print(&quot;top-level in one.py&quot;)\r\n    \r\n    if __name__ == &quot;__main__&quot;:\r\n        print(&quot;one.py is being run directly&quot;)\r\n    else:\r\n        print(&quot;one.py is being imported into another module&quot;)\r\n\r\n&lt;!-- --&gt;\r\n\r\n    # file two.py\r\n    import one\r\n    \r\n    print(&quot;top-level in two.py&quot;)\r\n    one.func()\r\n    \r\n    if __name__ == &quot;__main__&quot;:\r\n        print(&quot;two.py is being run directly&quot;)\r\n    else:\r\n        print(&quot;two.py is being imported into another module&quot;)\r\n\r\nNow, if you invoke the interpreter as\r\n\r\n    python one.py\r\n\r\nThe output will be\r\n\r\n    top-level in one.py\r\n    one.py is being run directly\r\n\r\nIf you run `two.py` instead:\r\n\r\n    python two.py\r\n\r\nYou get\r\n\r\n    top-level in one.py\r\n    one.py is being imported into another module\r\n    top-level in two.py\r\n    func() in one.py\r\n    two.py is being run directly\r\n\r\nThus, when module `one` gets loaded, its `__name__` equals `&quot;one&quot;` instead of `&quot;__main__&quot;`.\r\n",
        "body": "<p>When your script is run by passing it as a command to the Python interpreter,<\/p>\n\n<pre><code>python myscript.py\n<\/code><\/pre>\n\n<p>all of the code that is at indentation level 0 gets executed.  Functions and classes that are defined are, well, defined, but none of their code gets run.  Unlike other languages, there's no <code>main()<\/code> function that gets run automatically - the <code>main()<\/code> function is implicitly all the code at the top level.<\/p>\n\n<p>In this case, the top-level code is an <code>if<\/code> block.  <code>__name__<\/code> is a built-in variable which evaluates to the name of the current module.  However, if a module is being run directly (as in <code>myscript.py<\/code> above), then <code>__name__<\/code> instead is set to the string <code>\"__main__\"<\/code>.  Thus, you can test whether your script is being run directly or being imported by something else by testing<\/p>\n\n<pre><code>if __name__ == \"__main__\":\n    ...\n<\/code><\/pre>\n\n<p>If your script is being imported into another module, its various function and class definitions will be imported and its top-level code will be executed, but the code in the then-body of the <code>if<\/code> clause above won't get run as the condition is not met. As a basic example, consider the following two scripts:<\/p>\n\n<pre><code># file one.py\ndef func():\n    print(\"func() in one.py\")\n\nprint(\"top-level in one.py\")\n\nif __name__ == \"__main__\":\n    print(\"one.py is being run directly\")\nelse:\n    print(\"one.py is being imported into another module\")\n<\/code><\/pre>\n\n\n\n<pre><code># file two.py\nimport one\n\nprint(\"top-level in two.py\")\none.func()\n\nif __name__ == \"__main__\":\n    print(\"two.py is being run directly\")\nelse:\n    print(\"two.py is being imported into another module\")\n<\/code><\/pre>\n\n<p>Now, if you invoke the interpreter as<\/p>\n\n<pre><code>python one.py\n<\/code><\/pre>\n\n<p>The output will be<\/p>\n\n<pre><code>top-level in one.py\none.py is being run directly\n<\/code><\/pre>\n\n<p>If you run <code>two.py<\/code> instead:<\/p>\n\n<pre><code>python two.py\n<\/code><\/pre>\n\n<p>You get<\/p>\n\n<pre><code>top-level in one.py\none.py is being imported into another module\ntop-level in two.py\nfunc() in one.py\ntwo.py is being run directly\n<\/code><\/pre>\n\n<p>Thus, when module <code>one<\/code> gets loaded, its <code>__name__<\/code> equals <code>\"one\"<\/code> instead of <code>\"__main__\"<\/code>.<\/p>\n",
        "community_owned_date": null
    },
    {
        "owner": {
            "account_id": 3465245,
            "reputation": 836005,
            "user_id": 2901002,
            "user_type": "registered",
            "accept_rate": 97,
            "profile_image": "https:\/\/i.stack.imgur.com\/hMDvl.jpg?s=256&g=1",
            "display_name": "jezrael",
            "link": "https:\/\/stackoverflow.com\/users\/2901002\/jezrael"
        },
        "is_accepted": false,
        "score": 2096,
        "last_activity_date": 1612256807,
        "last_edit_date": 1612256807,
        "creation_date": 1432152108,
        "answer_id": 30359308,
        "question_id": 123198,
        "content_license": "CC BY-SA 4.0",
        "body_markdown": "| Function         | Copies&lt;br&gt;metadata | Copies&lt;br&gt;permissions | Uses file object | Destination&lt;br&gt;may be directory |\r\n|------------------|-----------------|--------------------|------------------|------------------------------|\r\n|[shutil.copy][1]       |   No            |    Yes             |    No            |      Yes                     |\r\n|[shutil.copyfile][2]   |   No            |     No             |    No            |       No                     |\r\n|[shutil.copy2][3]      |  Yes            |    Yes             |    No            |      Yes                     |\r\n|[shutil.copyfileobj][4]|   No            |     No             |   Yes            |       No                     |\r\n\r\n  [1]: https:\/\/docs.python.org\/3\/library\/shutil.html#shutil.copy\r\n  [2]: https:\/\/docs.python.org\/3\/library\/shutil.html#shutil.copyfile\r\n  [3]: https:\/\/docs.python.org\/3\/library\/shutil.html#shutil.copy2\r\n  [4]: https:\/\/docs.python.org\/3\/library\/shutil.html#shutil.copyfileobj",
        "body": "<div class=\"s-table-container\">\n<table class=\"s-table\">\n<thead>\n<tr>\n<th>Function<\/th>\n<th>Copies<br>metadata<\/th>\n<th>Copies<br>permissions<\/th>\n<th>Uses file object<\/th>\n<th>Destination<br>may be directory<\/th>\n<\/tr>\n<\/thead>\n<tbody>\n<tr>\n<td><a href=\"https:\/\/docs.python.org\/3\/library\/shutil.html#shutil.copy\" rel=\"noreferrer\">shutil.copy<\/a><\/td>\n<td>No<\/td>\n<td>Yes<\/td>\n<td>No<\/td>\n<td>Yes<\/td>\n<\/tr>\n<tr>\n<td><a href=\"https:\/\/docs.python.org\/3\/library\/shutil.html#shutil.copyfile\" rel=\"noreferrer\">shutil.copyfile<\/a><\/td>\n<td>No<\/td>\n<td>No<\/td>\n<td>No<\/td>\n<td>No<\/td>\n<\/tr>\n<tr>\n<td><a href=\"https:\/\/docs.python.org\/3\/library\/shutil.html#shutil.copy2\" rel=\"noreferrer\">shutil.copy2<\/a><\/td>\n<td>Yes<\/td>\n<td>Yes<\/td>\n<td>No<\/td>\n<td>Yes<\/td>\n<\/tr>\n<tr>\n<td><a href=\"https:\/\/docs.python.org\/3\/library\/shutil.html#shutil.copyfileobj\" rel=\"noreferrer\">shutil.copyfileobj<\/a><\/td>\n<td>No<\/td>\n<td>No<\/td>\n<td>Yes<\/td>\n<td>No<\/td>\n<\/tr>\n<\/tbody>\n<\/table>\n<\/div>",
        "community_owned_date": null
    },
    {
        "owner": {
            "account_id": 17447,
            "reputation": 30210,
            "user_id": 39057,
            "user_type": "registered",
            "accept_rate": 89,
            "profile_image": "https:\/\/www.gravatar.com\/avatar\/884a795250ab6d23ae2bf052ba831610?s=256&d=identicon&r=PG",
            "display_name": "Loki",
            "link": "https:\/\/stackoverflow.com\/users\/39057\/loki"
        },
        "is_accepted": true,
        "score": 2007,
        "last_activity_date": 1557289040,
        "last_edit_date": 1557289040,
        "creation_date": 1232050404,
        "answer_id": 448279,
        "question_id": 448271,
        "content_license": "CC BY-SA 4.0",
        "body_markdown": "It used to be a required part of a package ([old, pre-3.3 &quot;regular package&quot;](https:\/\/docs.python.org\/3\/reference\/import.html#regular-packages), not [newer 3.3+ &quot;namespace package&quot;](https:\/\/docs.python.org\/3\/reference\/import.html#namespace-packages)).\r\n\r\n[Here&#39;s the documentation.][1]\r\n\r\n&gt; Python defines two types of packages, regular packages and namespace packages. Regular packages are traditional packages as they existed in Python 3.2 and earlier. A regular package is typically implemented as a directory containing an `__init__.py` file. When a regular package is imported, this `__init__.py` file is implicitly executed, and the objects it defines are bound to names in the package\u2019s namespace. The `__init__.py` file can contain the same Python code that any other module can contain, and Python will add some additional attributes to the module when it is imported.\r\n\r\nBut just click the link, it contains an example, more information, and an explanation of namespace packages, the kind of packages without `__init__.py`.\r\n\r\n  [1]: https:\/\/docs.python.org\/3\/reference\/import.html#regular-packages",
        "body": "<p>It used to be a required part of a package (<a href=\"https:\/\/docs.python.org\/3\/reference\/import.html#regular-packages\" rel=\"noreferrer\">old, pre-3.3 \"regular package\"<\/a>, not <a href=\"https:\/\/docs.python.org\/3\/reference\/import.html#namespace-packages\" rel=\"noreferrer\">newer 3.3+ \"namespace package\"<\/a>).<\/p>\n\n<p><a href=\"https:\/\/docs.python.org\/3\/reference\/import.html#regular-packages\" rel=\"noreferrer\">Here's the documentation.<\/a><\/p>\n\n<blockquote>\n  <p>Python defines two types of packages, regular packages and namespace packages. Regular packages are traditional packages as they existed in Python 3.2 and earlier. A regular package is typically implemented as a directory containing an <code>__init__.py<\/code> file. When a regular package is imported, this <code>__init__.py<\/code> file is implicitly executed, and the objects it defines are bound to names in the package\u2019s namespace. The <code>__init__.py<\/code> file can contain the same Python code that any other module can contain, and Python will add some additional attributes to the module when it is imported.<\/p>\n<\/blockquote>\n\n<p>But just click the link, it contains an example, more information, and an explanation of namespace packages, the kind of packages without <code>__init__.py<\/code>.<\/p>\n",
        "community_owned_date": null
    },
    {
        "owner": {
            "account_id": 20660,
            "reputation": 21982,
            "user_id": 49590,
            "user_type": "registered",
            "profile_image": "https:\/\/www.gravatar.com\/avatar\/f65f19140499bdce208f0bf23b0dcc8c?s=256&d=identicon&r=PG",
            "display_name": "gregjor",
            "link": "https:\/\/stackoverflow.com\/users\/49590\/gregjor"
        },
        "is_accepted": false,
        "score": 1988,
        "last_activity_date": 1585900100,
        "last_edit_date": 1585900100,
        "creation_date": 1230720187,
        "answer_id": 402704,
        "question_id": 402504,
        "content_license": "CC BY-SA 4.0",
        "body_markdown": "Use the [`type()`][1] builtin function:\r\n\r\n    &gt;&gt;&gt; i = 123\r\n    &gt;&gt;&gt; type(i)\r\n    &lt;type &#39;int&#39;&gt;\r\n    &gt;&gt;&gt; type(i) is int\r\n    True\r\n    &gt;&gt;&gt; i = 123.456\r\n    &gt;&gt;&gt; type(i)\r\n    &lt;type &#39;float&#39;&gt;\r\n    &gt;&gt;&gt; type(i) is float\r\n    True\r\n\r\nTo check if a variable is of a given type, use [`isinstance`][2]:\r\n\r\n    &gt;&gt;&gt; i = 123\r\n    &gt;&gt;&gt; isinstance(i, int)\r\n    True\r\n    &gt;&gt;&gt; isinstance(i, (float, str, set, dict))\r\n    False\r\n\r\nNote that Python doesn&#39;t have the same types as C\/C++, which appears to be your question.\r\n\r\n  [1]: https:\/\/docs.python.org\/library\/functions.html#type\r\n  [2]: https:\/\/docs.python.org\/library\/functions.html#isinstance",
        "body": "<p>Use the <a href=\"https:\/\/docs.python.org\/library\/functions.html#type\" rel=\"noreferrer\"><code>type()<\/code><\/a> builtin function:<\/p>\n\n<pre><code>&gt;&gt;&gt; i = 123\n&gt;&gt;&gt; type(i)\n&lt;type 'int'&gt;\n&gt;&gt;&gt; type(i) is int\nTrue\n&gt;&gt;&gt; i = 123.456\n&gt;&gt;&gt; type(i)\n&lt;type 'float'&gt;\n&gt;&gt;&gt; type(i) is float\nTrue\n<\/code><\/pre>\n\n<p>To check if a variable is of a given type, use <a href=\"https:\/\/docs.python.org\/library\/functions.html#isinstance\" rel=\"noreferrer\"><code>isinstance<\/code><\/a>:<\/p>\n\n<pre><code>&gt;&gt;&gt; i = 123\n&gt;&gt;&gt; isinstance(i, int)\nTrue\n&gt;&gt;&gt; isinstance(i, (float, str, set, dict))\nFalse\n<\/code><\/pre>\n\n<p>Note that Python doesn't have the same types as C\/C++, which appears to be your question.<\/p>\n",
        "community_owned_date": null
    },
    {
        "owner": {
            "account_id": 107038,
            "reputation": 133900,
            "user_id": 284795,
            "user_type": "registered",
            "accept_rate": 79,
            "profile_image": "https:\/\/www.gravatar.com\/avatar\/99f7ffd3d45dbcef0b3b6960dcfe81a2?s=256&d=identicon&r=PG",
            "display_name": "Colonel Panic",
            "link": "https:\/\/stackoverflow.com\/users\/284795\/colonel-panic"
        },
        "is_accepted": true,
        "score": 1942,
        "last_activity_date": 1673114580,
        "last_edit_date": 1673114580,
        "creation_date": 1347968733,
        "answer_id": 12476379,
        "question_id": 4750806,
        "content_license": "CC BY-SA 4.0",
        "body_markdown": "Python 3.4+ and 2.7.9+\r\n----------------------\r\n\r\nGood news! [Python 3.4][1] (released March 2014) and [Python 2.7.9][2] (released December 2014) ship with Pip. This is the best feature of any Python release. It makes the community&#39;s wealth of libraries accessible to everyone. Newbies are no longer excluded from using community libraries by the prohibitive difficulty of setup. In shipping with a package manager, Python joins [Ruby][3], [Node.js][4], [Haskell][5], [Perl][6], [Go][7]&amp;mdash;almost every other contemporary language with a majority open-source community. Thank you, Python.\r\n\r\nIf you do find that pip is not available, simply run [`ensurepip`][22].\r\n\r\n  - On Windows:\r\n    \r\n        py -3 -m ensurepip\r\n\r\n  - Otherwise:\r\n\r\n        python3 -m ensurepip\r\n\r\nOf course, that doesn&#39;t mean Python packaging is problem solved. The experience remains frustrating. I discuss this [in the Stack Overflow question *Does Python have a package\/module management system?*][8].\r\n\r\nPython 3 \u2264 3.3 and 2 \u2264 2.7.8\r\n----------------------------\r\n\r\nFlying in the face of its [&#39;batteries included&#39;][9] motto, Python ships without a package manager. To make matters worse, Pip was&amp;mdash;until recently&amp;mdash;ironically difficult to install.\r\n\r\n### Official instructions\r\n\r\nPer [https:\/\/pip.pypa.io\/en\/stable\/installing\/#do-i-need-to-install-pip][21]:\r\n\r\nDownload [`get-pip.py`][10], being careful to save it as a `.py` file rather than `.txt`. Then, run it from the command prompt:\r\n\r\n    python get-pip.py\r\n\r\nYou possibly need an administrator command prompt to do this. Follow *[Start a Command Prompt as an Administrator][11]* (Microsoft TechNet).\r\n\r\nThis installs the pip package, which (in Windows) contains ...\\Scripts\\pip.exe that path must be in PATH environment variable to use pip from the command line (see the second part of &#39;Alternative Instructions&#39; for adding it to your PATH,\r\n\r\n\r\n### Alternative instructions\r\n\r\nThe official documentation tells users to install Pip and each of its dependencies from source. That&#39;s tedious for the experienced and prohibitively difficult for newbies.\r\n\r\nFor our sake, Christoph Gohlke prepares Windows installers (`.msi`) for popular Python packages. He builds installers for all Python versions, both 32 and 64 bit. You need to:\r\n\r\n1. [Install setuptools][12]\r\n2. [Install pip][13]\r\n\r\nFor me, this installed Pip at `C:\\Python27\\Scripts\\pip.exe`. Find `pip.exe` on your computer, then add its folder (for example, `C:\\Python27\\Scripts`) to your path (Start \/ Edit environment variables). Now you should be able to run `pip` from the command line. Try installing a package:\r\n\r\n    pip install httpie\r\n\r\nThere you go (hopefully)! Solutions for common problems are given below:\r\n\r\n### Proxy problems\r\n\r\nIf you work in an office, you might be behind an HTTP proxy. If so, set the environment variables [`http_proxy` and `https_proxy`][14]. Most Python applications (and other free software) respect these. Example syntax:\r\n\r\n    http:\/\/proxy_url:port\r\n    http:\/\/username:password@proxy_url:port\r\n\r\nIf you&#39;re really unlucky, your proxy might be a Microsoft [NTLM][15] proxy. Free software can&#39;t cope. The only solution is to install a free software friendly proxy that forwards to the nasty proxy. http:\/\/cntlm.sourceforge.net\/\r\n\r\n### Unable to find vcvarsall.bat\r\n\r\nPython modules can be partly written in C or C++. Pip tries to compile from source. If you don&#39;t have a C\/C++ compiler installed and configured, you&#39;ll see this cryptic error message.\r\n\r\n&gt; Error: Unable to find vcvarsall.bat\r\n\r\nYou can fix that by [installing a C++ compiler][16] such as [MinGW][17] or [Visual C++][18]. Microsoft actually ships one specifically for use with Python. Or try *[Microsoft Visual C++ Compiler for Python 2.7][19]*.\r\n\r\nOften though it&#39;s easier to check [Christoph&#39;s site][20] for your package.\r\n\r\n  [1]: https:\/\/docs.python.org\/3\/whatsnew\/3.4.html\r\n  [2]: https:\/\/docs.python.org\/2\/whatsnew\/2.7.html#pep-477-backport-ensurepip-pep-453-to-python-2-7\r\n  [3]: http:\/\/en.wikipedia.org\/wiki\/Ruby_%28programming_language%29\r\n  [4]: http:\/\/en.wikipedia.org\/wiki\/Node.js\r\n  [5]: http:\/\/en.wikipedia.org\/wiki\/Haskell_%28programming_language%29\r\n  [6]: http:\/\/en.wikipedia.org\/wiki\/Perl\r\n  [7]: http:\/\/en.wikipedia.org\/wiki\/Go_%28programming_language%29\r\n  [8]: https:\/\/stackoverflow.com\/questions\/2436731\/does-python-have-a-package-module-management-system\/13445719#13445719\r\n  [9]: http:\/\/www.python.org\/about\/\r\n  [10]: https:\/\/bootstrap.pypa.io\/get-pip.py\r\n  [11]: http:\/\/technet.microsoft.com\/en-us\/library\/cc947813(v=ws.10).aspx\r\n  [12]: http:\/\/www.lfd.uci.edu\/~gohlke\/pythonlibs\/#setuptools\r\n  [13]: http:\/\/www.lfd.uci.edu\/~gohlke\/pythonlibs\/#pip\r\n  [14]: http:\/\/docs.python.org\/2\/library\/urllib.html\r\n  [15]: https:\/\/en.wikipedia.org\/wiki\/NT_LAN_Manager\r\n  [16]: https:\/\/stackoverflow.com\/questions\/2817869\/error-unable-to-find-vcvarsall-bat\r\n  [17]: http:\/\/en.wikipedia.org\/wiki\/MinGW\r\n  [18]: http:\/\/en.wikipedia.org\/wiki\/Visual_C%2B%2B#32-bit_versions\r\n  [19]: http:\/\/aka.ms\/vcpython27\r\n  [20]: http:\/\/www.lfd.uci.edu\/~gohlke\/pythonlibs\/\r\n  [21]: https:\/\/pip.pypa.io\/en\/stable\/installing\/#do-i-need-to-install-pip\r\n  [22]: https:\/\/docs.python.org\/library\/ensurepip.html",
        "body": "<h2>Python 3.4+ and 2.7.9+<\/h2>\n<p>Good news! <a href=\"https:\/\/docs.python.org\/3\/whatsnew\/3.4.html\" rel=\"noreferrer\">Python 3.4<\/a> (released March 2014) and <a href=\"https:\/\/docs.python.org\/2\/whatsnew\/2.7.html#pep-477-backport-ensurepip-pep-453-to-python-2-7\" rel=\"noreferrer\">Python 2.7.9<\/a> (released December 2014) ship with Pip. This is the best feature of any Python release. It makes the community's wealth of libraries accessible to everyone. Newbies are no longer excluded from using community libraries by the prohibitive difficulty of setup. In shipping with a package manager, Python joins <a href=\"http:\/\/en.wikipedia.org\/wiki\/Ruby_%28programming_language%29\" rel=\"noreferrer\">Ruby<\/a>, <a href=\"http:\/\/en.wikipedia.org\/wiki\/Node.js\" rel=\"noreferrer\">Node.js<\/a>, <a href=\"http:\/\/en.wikipedia.org\/wiki\/Haskell_%28programming_language%29\" rel=\"noreferrer\">Haskell<\/a>, <a href=\"http:\/\/en.wikipedia.org\/wiki\/Perl\" rel=\"noreferrer\">Perl<\/a>, <a href=\"http:\/\/en.wikipedia.org\/wiki\/Go_%28programming_language%29\" rel=\"noreferrer\">Go<\/a>\u2014almost every other contemporary language with a majority open-source community. Thank you, Python.<\/p>\n<p>If you do find that pip is not available, simply run <a href=\"https:\/\/docs.python.org\/library\/ensurepip.html\" rel=\"noreferrer\"><code>ensurepip<\/code><\/a>.<\/p>\n<ul>\n<li><p>On Windows:<\/p>\n<pre><code>py -3 -m ensurepip\n<\/code><\/pre>\n<\/li>\n<li><p>Otherwise:<\/p>\n<pre><code>python3 -m ensurepip\n<\/code><\/pre>\n<\/li>\n<\/ul>\n<p>Of course, that doesn't mean Python packaging is problem solved. The experience remains frustrating. I discuss this <a href=\"https:\/\/stackoverflow.com\/questions\/2436731\/does-python-have-a-package-module-management-system\/13445719#13445719\">in the Stack Overflow question <em>Does Python have a package\/module management system?<\/em><\/a>.<\/p>\n<h2>Python 3 \u2264 3.3 and 2 \u2264 2.7.8<\/h2>\n<p>Flying in the face of its <a href=\"http:\/\/www.python.org\/about\/\" rel=\"noreferrer\">'batteries included'<\/a> motto, Python ships without a package manager. To make matters worse, Pip was\u2014until recently\u2014ironically difficult to install.<\/p>\n<h3>Official instructions<\/h3>\n<p>Per <a href=\"https:\/\/pip.pypa.io\/en\/stable\/installing\/#do-i-need-to-install-pip\" rel=\"noreferrer\">https:\/\/pip.pypa.io\/en\/stable\/installing\/#do-i-need-to-install-pip<\/a>:<\/p>\n<p>Download <a href=\"https:\/\/bootstrap.pypa.io\/get-pip.py\" rel=\"noreferrer\"><code>get-pip.py<\/code><\/a>, being careful to save it as a <code>.py<\/code> file rather than <code>.txt<\/code>. Then, run it from the command prompt:<\/p>\n<pre><code>python get-pip.py\n<\/code><\/pre>\n<p>You possibly need an administrator command prompt to do this. Follow <em><a href=\"http:\/\/technet.microsoft.com\/en-us\/library\/cc947813(v=ws.10).aspx\" rel=\"noreferrer\">Start a Command Prompt as an Administrator<\/a><\/em> (Microsoft TechNet).<\/p>\n<p>This installs the pip package, which (in Windows) contains ...\\Scripts\\pip.exe that path must be in PATH environment variable to use pip from the command line (see the second part of 'Alternative Instructions' for adding it to your PATH,<\/p>\n<h3>Alternative instructions<\/h3>\n<p>The official documentation tells users to install Pip and each of its dependencies from source. That's tedious for the experienced and prohibitively difficult for newbies.<\/p>\n<p>For our sake, Christoph Gohlke prepares Windows installers (<code>.msi<\/code>) for popular Python packages. He builds installers for all Python versions, both 32 and 64 bit. You need to:<\/p>\n<ol>\n<li><a href=\"http:\/\/www.lfd.uci.edu\/%7Egohlke\/pythonlibs\/#setuptools\" rel=\"noreferrer\">Install setuptools<\/a><\/li>\n<li><a href=\"http:\/\/www.lfd.uci.edu\/%7Egohlke\/pythonlibs\/#pip\" rel=\"noreferrer\">Install pip<\/a><\/li>\n<\/ol>\n<p>For me, this installed Pip at <code>C:\\Python27\\Scripts\\pip.exe<\/code>. Find <code>pip.exe<\/code> on your computer, then add its folder (for example, <code>C:\\Python27\\Scripts<\/code>) to your path (Start \/ Edit environment variables). Now you should be able to run <code>pip<\/code> from the command line. Try installing a package:<\/p>\n<pre><code>pip install httpie\n<\/code><\/pre>\n<p>There you go (hopefully)! Solutions for common problems are given below:<\/p>\n<h3>Proxy problems<\/h3>\n<p>If you work in an office, you might be behind an HTTP proxy. If so, set the environment variables <a href=\"http:\/\/docs.python.org\/2\/library\/urllib.html\" rel=\"noreferrer\"><code>http_proxy<\/code> and <code>https_proxy<\/code><\/a>. Most Python applications (and other free software) respect these. Example syntax:<\/p>\n<pre><code>http:\/\/proxy_url:port\nhttp:\/\/username:password@proxy_url:port\n<\/code><\/pre>\n<p>If you're really unlucky, your proxy might be a Microsoft <a href=\"https:\/\/en.wikipedia.org\/wiki\/NT_LAN_Manager\" rel=\"noreferrer\">NTLM<\/a> proxy. Free software can't cope. The only solution is to install a free software friendly proxy that forwards to the nasty proxy. <a href=\"http:\/\/cntlm.sourceforge.net\/\" rel=\"noreferrer\">http:\/\/cntlm.sourceforge.net\/<\/a><\/p>\n<h3>Unable to find vcvarsall.bat<\/h3>\n<p>Python modules can be partly written in C or C++. Pip tries to compile from source. If you don't have a C\/C++ compiler installed and configured, you'll see this cryptic error message.<\/p>\n<blockquote>\n<p>Error: Unable to find vcvarsall.bat<\/p>\n<\/blockquote>\n<p>You can fix that by <a href=\"https:\/\/stackoverflow.com\/questions\/2817869\/error-unable-to-find-vcvarsall-bat\">installing a C++ compiler<\/a> such as <a href=\"http:\/\/en.wikipedia.org\/wiki\/MinGW\" rel=\"noreferrer\">MinGW<\/a> or <a href=\"http:\/\/en.wikipedia.org\/wiki\/Visual_C%2B%2B#32-bit_versions\" rel=\"noreferrer\">Visual C++<\/a>. Microsoft actually ships one specifically for use with Python. Or try <em><a href=\"http:\/\/aka.ms\/vcpython27\" rel=\"noreferrer\">Microsoft Visual C++ Compiler for Python 2.7<\/a><\/em>.<\/p>\n<p>Often though it's easier to check <a href=\"http:\/\/www.lfd.uci.edu\/%7Egohlke\/pythonlibs\/\" rel=\"noreferrer\">Christoph's site<\/a> for your package.<\/p>\n",
        "community_owned_date": null
    }
]
